---
title: 内存管理及问题分析-note
tags: []
categories: []
reward: true
date: 2019-12-12 15:06:56
---

# Linux内存管理及问题分析

## 内存使用情况分析

### 系统总内存分析

```shell
$ cat /proc/meminfo   # 可用的物理内存 = MemFree + Buffers + Cached
MemTotal:        8057484 kB
MemFree:         3063940 kB
MemAvailable:    7450944 kB
Buffers:         1482896 kB
Cached:          2473588 kB
SwapCached:            0 kB
Active:          3194404 kB
Inactive:         939116 kB
Active(anon):     184656 kB
Inactive(anon):    19640 kB
Active(file):    3009748 kB
Inactive(file):   919476 kB
Unevictable:          32 kB
Mlocked:              32 kB
SwapTotal:             0 kB
SwapFree:              0 kB
Dirty:                36 kB
Writeback:             0 kB
AnonPages:        177068 kB
Mapped:           199280 kB
Shmem:             27272 kB
Slab:             793512 kB
SReclaimable:     761556 kB
SUnreclaim:        31956 kB
KernelStack:        6048 kB
PageTables:        14968 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:     4028740 kB
Committed_AS:    2330284 kB
VmallocTotal:   34359738367 kB
VmallocUsed:           0 kB
VmallocChunk:          0 kB
HardwareCorrupted:     0 kB
AnonHugePages:         0 kB
CmaTotal:              0 kB
CmaFree:               0 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
DirectMap4k:      134544 kB
DirectMap2M:     3942400 kB
DirectMap1G:     5242880 kB

# 清理系统的cache
$ echo 3 > /proc/sys/vm/drop_caches
```

### 进程内存分析

```shell
$ cat /proc/{pid}/maps
00008000-00729000 r-xp 00000000 b3:1f 109        /opt/qcom/bin/tr069-v2
```

## Linux 性能分析 -- CPU

每一次调查性能问题都要从头梳理一次，而每一次检索都只能找到单独的命令，所以在这里就把常用的命令和方法做一下记录。至于判断标准，是从各个博文中找到的，未能从原理上证实其准确性，所以可能会有出入。

另外这里对所有的命令和工具都是做极简的概要性说明，详细说明可在文后的参考链接中查看。

**CPU利用率的判断标准：**

- **查看CPU利用率**：User65%～70%，System30%～35%，Idle0%～5%。

- **上下文切换**：只是一个参考因素，只要CPU利用率正常，这个值不需要太关注。

- **可运行队列**：每个处理可以负担的可运行队列约为：1～3。

- **CPU负载**：  一般15分钟内的负载应该 < 核心数*0.7

**系统CPU利用率监测工具:**

- `top` :  监测系统CPU利用率，关注：User、sys、Idle及CPU占用率持续较高的进程

- `mpstat`：查看各CPU的利用率

- `perf top`：查看当前CPU占用率较高的系统API

- `vmstat`：查看CPU利用率、中断、上下文切换、可运行队列数、阻塞队列数

- `cat /proc/cpuinfo`：查看CPU信息

- `uptime`：查看CPU负载

**进程CPU利用率监测、分析工具：**

- `pstack PID`：  按照线程，打印进程堆栈

- `perf + 火焰图`：利用perf打印进程信息，并使用火焰图将其图形化，然后找到CPU耗费时间高的函数

- `top -Hp PID`： 将进程中的线程，按CPU占用率进行排列

- `ps -mp PID -o THREAD,tid,time`：查看进程内的线程信息

- `ps hH p PID`： 列出进程内的所有线程

## Linux 性能分析 -- 内存

**内存需要注意的情况：**

- **available**：接近于0

- **swap**：持续增加或者波动

- `dmesg | grep oom-killer`：OutOfMemory-killer运行状态

**以下情况都属于正常情况：**

- **free**：接近于0

- **used**：接近于total

- **available**：大于20%*total

- **swap**：为0或者稳定在固定值

**内存监测工具：**

- `top + M`：按照内存使用情况，对进程进行排列

- `free -m/-g/-h`：查看当前系统内存

- **vmstat 时间间隔**：打印系统内存、CPU情况，若swap出现波动，需要注意。

- `sar -W`：各CPU的swap切换频率，正常情况下应该为0

- `cat /proc/meminfo`：查看系统当前内存分配

- `losf`：查看系统文件占用情况

**进程内的内存监测工具：**

- `pmap -d PID`：查看进程内的内存分配情况，尤其注意最后一行

- `hcache -pid PID`：查看置顶进程内的缓存文件

- `cat /proc/PID/smaps`：查看进程的内存占用情况

- `pidstat`：查看进程占用资源，如内存、IO、CPU，详细使用说明请查看帮助（man pidstat）

**缓存监测工具：**

- slabtop：

- `ipcs -m`：查看共享内存

- `vmtouch`：查看当前系统内已缓存的文件并显示其详细信息

- `hcache —top 10`：查看当前系统中占用缓存最高的10个进程

**内存泄漏监测工具：**

- `valgrind —memcheck`：扫描进程，并列出内存泄漏点

- `gdb`：调试过程中，需要中断进程

- `libcmalloc`：需要修改代码









## 内存泄漏

### 内存泄露类型

- 常发性内存泄漏

    发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏

- 偶发性内存泄漏

    发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要

- 一次性内存泄漏

    发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅有一块内存发生泄漏

- 隐式内存泄漏

    程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏

### 常用内存泄露检测工具

**C/C++：**

1. **Valgrind**: Debugging and profiling Linux programs, aiming at programs written in C and C++ 
2. **ccmalloc**: Linux和Solaris下对C和C++程序的简单的使用内存泄漏和malloc调试库 
3. **LeakTracer**: Linux、Solaris和HP-UX下跟踪和分析C++程序中的内存泄漏 
4. **Electric Fence**: Linux分发版中由Bruce Perens编写的malloc()调试库 
5. **Leaky**: Linux下检测内存泄漏的程序 
6. **Dmalloc**: Debug Malloc Library 
7. **MEMWATCH**: 由Johan Lindh编写，是一个开放源代码C语言内存错误检测工具，主要是通过gcc的precessor来进行 
8. **KCachegrind**: A visualization tool for the profiling data generated by Cachegrind and Calltree 

## Linux下的proc/进程号目录

请注意，作为普通用户，您(理论上)只能查看与您自己的进程相关的信息，而不是其他用户的。因此，请升级为 root 用户，并查看进程 127 包含哪些信息：

```shell
$ su
Password:
$ cd /proc/127
$ ls -l
total 0-9
-r--r--r--    1 root     root            0 Dec 14 19:53 cmdline
lrwx------    1 root     root            0 Dec 14 19:53 cwd -> //
-r--------    1 root     root            0 Dec 14 19:53 environ
lrwx------    1 root     root            0 Dec 14 19:53 exe -> /usr/sbin/apmd*
dr-x------    2 root     root            0 Dec 14 19:53 fd/
pr--r--r--    1 root     root            0 Dec 14 19:53 maps|
-rw-------    1 root     root            0 Dec 14 19:53 mem
lrwx------    1 root     root            0 Dec 14 19:53 root -> //
-r--r--r--    1 root     root            0 Dec 14 19:53 stat
-r--r--r--    1 root     root            0 Dec 14 19:53 statm
-r--r--r--    1 root     root            0 Dec 14 19:53 status
```

每个目录包含同样的项目。以下简单介绍其中某些项目：

- `cmdline`：该(虚拟)文件包含了启动该进程的整个命令行。它未曾格式化：程序与其参数之间没有空格，行末也没有换行。要查看它，您可以使用：

    `perl -ple 's,\00, ,g' cmdline`

    `cat /proc/pid/cmdline | tr '\0' ' '`

- `cwd`：该符号链接指向该进程的当前工作目录。

- `environ`：该文件包含为该进程定义的所有环境变量，格式为 变量=值。与 cmdline 文件一样，其内容未曾格式化过：各个变量之间没有分行，文件末尾也没有换行。要查看，可以：

    `perl -pl -e 's,\00,\n,g' environ`

- exe：这是指向该进程所执行的可执行程序文件的符号链接。

- `fd`：在此子目录中包含了该进程当前打开的所有描述符。参见下文。

- `maps`：当您打印该命名管道内容时(例如使用 cat)，您将看到该进程地址空间中当前映射到文件中的那部分。自左至右各列为：与该映射关联的地址空间，与该映射关联的权限，该映射起始位置的偏移量(从文件开始处算起)，保存该映射文件设备的主、从序号(十六进制格式)，该文件的 inode 序号，以及该文件的文件名。当设备号为 0 且没有 inode 号或文件名时，它就是一个匿名映射。请参阅 mmap(2)。

- `root`：该符号链接指向该进程使用的根目录。通常为 `/`，请参阅 chroot(2)。

- `status`：该文件包含该进程的众多信息：可执行文件名、当前状态、PID 和 PPID、实际及有效的 UID 和 GID、内存使用情况、以及其他。请注意，stat 和 statm 现已过时。它们包含的信息现存于 status。

浏览进程 127 的 fd 目录，我们将看到：

```shell
$ ls -l fd
total 0
lrwx------    1 root     root           64 Dec 16 22:04 0 -> /dev/console
l-wx------    1 root     root           64 Dec 16 22:04 1 -> pipe:[128]
l-wx------    1 root     root           64 Dec 16 22:04 2 -> pipe:[129]
l-wx------    1 root     root           64 Dec 16 22:04 21 -> pipe:[130]
lrwx------    1 root     root           64 Dec 16 22:04 3 -> /dev/apm_bios
lr-x------    1 root     root           64 Dec 16 22:04 7 -> pipe:[130]
lrwx------    1 root     root           64 Dec 16 22:04 9 -> /dev/console
```

实际上，这是该进程打开的文件描述符列表。每个打开的描述符由一个符号链接表示，其名称为该描述符的编号，并指向该描述符打开的文件[25]。请注意这些符号链接的权限：它们的意义仅代表被相应描述符打开的文件的权限。











## 常用工具

### Linux内核内存泄漏检测kmemleak

kmemlean提供了一种检测内核内存泄露的方法，当内存对象没有被释放是，将其记录在/sys/kernel/debug/kmemleak中。

**使能kmemleak：**

```
CONFIG_DEBUG_KMEMLEAK=y
CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE=400
# CONFIG_DEBUG_KMEMLEAK_TEST is not set
CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF=n----------默认打开
```

如果没有打开KMEMLEAK_FULL，则使用了精简版。完整版比较耗内存，精简版适合嵌入式调试。

**配置获取kmemleak结果：**

参数配置：

```shell
off 禁用kmemleak（不可逆）
stack=on 启用任务堆栈扫描(default)
stack=off 禁用任务堆栈扫描
scan=on 启动自动记忆扫描线程(default)
scan=off 停止自动记忆扫描线程
scan=<secs> 设置n秒内自动记忆扫描
scan 开启内核扫描
clear 清除内存泄露报告
dump=<addr> 转存信息对象在<addr>
通过“kmemleak = OFF”，也可以在启动时禁用Kmemleak在内核命令行。在初始化kmemleak之前，内存的分配或释放这些动作被存储在一个前期日志缓冲区。这个缓冲区的大小通过配CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE设置。 
```

```shell
$ cat /sys/kernel/debug/kmemleak > kmemleak.txt
```

**分析kmemleak泄漏情况：**

参考文档：

《[kmemleak的使用](http://blog.csdn.net/lishenglong666/article/details/8287783)》

《[Linux Kernel Memory Leak Detection](https://events.linuxfoundation.org/images/stories/pdf/lceu11_marinas.pdf)》

《[Linux memory leak detection](http://blog.thewebsitepeople.org/2011/03/linux-memory-leak-detection/)》

**valgrind：**

[Linux C/C++ Memory Leak Detection Tool](http://www.cnblogs.com/LittleHann/p/4353145.html)

##### [Linux 下几款程序内存泄漏检查工具](http://blog.csdn.net/youbingchen/article/details/52002778)

[Linux下几款C++程序中的内存泄露检查工具](http://blog.csdn.net/gatieme/article/details/51959654)

[Linux 内存泄露检测技巧](http://blog.csdn.net/hnlyyk/article/details/49176501)

[应用 Valgrind 发现 Linux 程序的内存问题](https://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/)





## Reference

**CPU相关：**

> [Linux性能监测](https://www.cnblogs.com/sinlang5778/articles/2120551.html)
>
> [Linux Performance Measurements using vmstat(介绍vmstat命令并给出问题分析示例)](https://www.thomas-krenn.com/en/wiki/Linux_Performance_Measurements_using_vmstat)
>
> [理解Linux系统负荷](http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html)
>
> [系统性能分析工具perf的介绍与使用](https://www.cnblogs.com/arnoldlu/p/6241297.html)
>
> [FlameGraph（火焰图转换工具）](https://github.com/brendangregg/FlameGraph)

**内存相关：**

> [谁吃了我的Linux内存](https://colobu.com/2017/03/07/what-is-in-linux-cached/)
>
> [Linux内存占用分析](http://huqunxing.site/2017/03/31/linux内存占用分析/)
>
> [Linux查看进程消耗内存情况总结](https://www.cnblogs.com/kerrycode/p/9568854.html)
>
> [Linux监控之Memory](https://jin-yang.github.io/post/linux-monitor-memory.html)
>
> [hcache](https://github.com/silenceshell/hcache)
>
> [vmtouch](https://hoytech.com/vmtouch/)

> [linux下内存泄露查找、BUG调试](https://www.xuebuyuan.com/1815509.html)

> [Linux下的proc/进程号目录](https://blog.csdn.net/mydriverc2/article/details/41978771)
>
> [Linux /proc目录详解](https://www.cnblogs.com/DswCnblog/p/5780389.html)
>
> [如何查询一个进程下面的线程数（进程和线程区别）](https://www.cnblogs.com/kevingrace/p/5252919.html)

> [Linux系统内存分析***](https://www.cnblogs.com/blog-yejy/p/9631708.html)

