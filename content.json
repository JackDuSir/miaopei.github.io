{"meta":{"title":"Mr.Miaow Blog","subtitle":"天道酬勤，地道酬善，人道酬誠，商道酬信，業道酬精","description":"滴水石穿，不是力量大，而是功夫深!","author":"苗沛","url":"http://miaopei.github.io"},"pages":[{"title":"archives","date":"2018-07-22T11:46:47.000Z","updated":"2019-06-03T01:50:25.000Z","comments":true,"path":"archives/index.html","permalink":"http://miaopei.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2018-07-29T03:04:52.000Z","updated":"2019-06-03T07:33:58.000Z","comments":false,"path":"about/index.html","permalink":"http://miaopei.github.io/about/index.html","excerpt":"","text":"本文链接： 作者： Miao Pei 出处： http://miaopei.github.io/ 本文基于 知识共享署名-相同方式共享 4.0 国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名 Miao Pei及链接。"},{"title":"categories","date":"2018-07-22T12:02:59.000Z","updated":"2019-06-03T01:50:25.000Z","comments":false,"path":"categories/index.html","permalink":"http://miaopei.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-22T09:34:23.000Z","updated":"2019-06-03T01:50:25.000Z","comments":false,"path":"tags/index.html","permalink":"http://miaopei.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"FFMpeg实时美颜直播推流","slug":"FFmpeg/ffmpeg实时美颜推流","date":"2019-05-19T02:14:50.000Z","updated":"2019-06-11T09:08:50.443Z","comments":true,"path":"2019/05/19/FFmpeg/ffmpeg实时美颜推流/","link":"","permalink":"http://miaopei.github.io/2019/05/19/FFmpeg/ffmpeg实时美颜推流/","excerpt":"实战 - 基于ffmpeg，qt5，opencv视频课程 1. 基础知识1.1 直播推流流程分析","text":"实战 - 基于ffmpeg，qt5，opencv视频课程 1. 基础知识1.1 直播推流流程分析 rtmp 延时一般 1-3 秒 1.2 直播 rtmp 协议分析 2. 直播服务器讲解和配置 2.1 直播服务器介绍 crtmpserver 编译运行1234567891011121314$ apt-get install wget cmake$ apt-get install libssl-dev$ wget https://codeload.github.com/j0sh/crtmpserver/zip/centosinit --no-check-certificate$ unzip centosinit$ cd builders/cmake$ cmake . $ make$ ./crtmpserver/crtmpserver ./crtmpserver/crtmpserver.lua#$ ffmpeg -i test.flv -f flv rtmp://192.168.1.44/live#ʹc rtmp://192.168.1.44/live#ʹplay ffplay rtmp://192.168.1.44/live -fflags nobuffer 123456# errorCMake Error at cmake_find_modules/Find_openssl.cmake:99 (MESSAGE): Looking for openssl headers - not foundCall Stack (most recent call first): CMakeLists.txt:46 (INCLUDE)$ cmake -DOPENSSL_ROOT_DIR=/usr/local/opt/openssl -DOPENSSL_LIBRARIES=/usr/local/opt/openssl/lib 2.2 下载 ffmpeg 工具推流并使用功能 vlc 拉流播放测试12345$ wget https://nginx.org/download/nginx-1.16.0.tar.gz --no-check-certificate$ git clone https://github.com/arut/nginx-rtmp-module.git$ ./configure --add-module=/home/miaopei/workdir/test/ffmpet-test/nginx/nginx-rtmp-module $ make$ make install 12345678910# nginx.conf 配置rtmp &#123; server &#123; listen 1935; chunk_size 4096; application live &#123; live on; &#125; &#125;&#125; 12# 推流命令$ ffmpeg -i test.mp4 -c copy -f flv rtmp://192.168.2.76/live 1234567891011# 网页查看推流的状态server &#123; listen 8080; location /stat&#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; location /stat.xsl&#123; root /home/miaopei/workdir/test/ffmpet-test/nginx/nginx-rtmp-module; &#125;&#125; 12345678Reload config: $ nginx -s reloadReopen Logfile: $ nginx -s reopenStop process: $ nginx -s stopWaiting on exit process $ nginx -s quit 3. FFMpeg SDK 解封和推流3.1 ffmpeg SDK开发环境准备 4. OpencvSDK 基础 Mac源码安装使用OpenCV 在MacOS 10.13.2 下编译 OpenCV3.4.0 + OpenCV Contrib 3.4.0 成 Java 库 在MacOS上安装OpenCV 3.4(c++) OpenCV 源码编译： 12345678910111213141516171819202122232425262728# 下载 OpenCV 3.4.0$ # 解压，进入到 opencv-3.4.0 目录下$ mkdir -p build/install$ cd build$ cmake -G \"Unix Makefiles\" -j8 -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_OSX_ARCHITECTURES=x86_64 -D CMAKE_INSTALL_PREFIX=/Users/miaopei/install/opencv/opencv-3.4.0/build/install ../$ make -j8$ make install# 配置环境变量PKG_CONFIG_PATH=$PKG_CONFIG_PATH:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib/pkgconfigexport PKG_CONFIG_PATHexport LD_LIBRARY_PATH=Users/miaopei/install/opencv/opencv-3.4.0/build/install/bin:SLD_LIBRARY_PATHexport PATH=$&#123;PATH&#125;:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib# 测试demo,打印当前版本号#include &lt;opencv2/core/utility.hpp&gt;#include &lt;iostream&gt;int main(int argc, const char* argv[])&#123; std::cout &lt;&lt; \"Welcome to OpenCV \" &lt;&lt; CV_VERSION &lt;&lt; std::endl; return 0;&#125;# MakefileCXX ?= g++CXXFLAGS += -c -Wall $(shell pkg-config --cflags opencv)LDFLAGS += $(shell pkg-config --libs --static opencv)all: test_versionopencv_example: test_version.o; $(CXX) $&lt; -o $@ $(LDFLAGS)%.o: %.cpp; $(CXX) $&lt; -o $@ $(CXXFLAGS)clean: ; rm -f test_version.o test_version 4.1 VideoCapture打开摄像头接口讲解和源码分析 5. 视频采集编码推流和类封装 6. 音频录制编码推流和类封装 QT音频录制接口： 7. 音视频同步编码推流处理 8. XRtmpStreamer 项目完成（界面和美颜）直播推流要求实时性，一秒钟25帧，做美颜的总耗时一定要低于40ms（每帧消耗40ms） 现在视频推流一般都是1280 X 720 手机端是基于GPU 第三方库做的计算 美颜算法一般都是基于GPU做的 头文件尽量不用引用命名空间，因为不知道谁来调用，可能会出现问题。 头文件中尽量不要引用第三方库文件，应为涉及到第三方库版本升级之类的，第三方头文件的引用应该在代码中引用。 9. 补充9.0 流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）1. RTP： 参考文档 RFC3550/RFC3551 (Real-time Transport Protocol) 是用于 Internet 上针对多媒体数据流的一种传输层协议。RTP 协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP 协议常用于流媒体系统（配合 RTCP协议），视频会议和一键通（Push to Talk）系统（配合 H.323 或 SIP），使它成为 IP 电话产业的技术基础。RTP 协议和 RTP 控制协议 RTCP 一起使用，而且它是建立在 UDP 协议上的。 RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于低层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。 RTP 由两个紧密链接部分组成： RTP ― 传送具有实时属性的数据； RTP 控制协议（RTCP） ― 监控服务质量并传送正在进行的会话参与者的相关信息。 2. RTCP 实时传输控制协议（Real-time Transport Control Protocol 或 RTP Control Protocol 或简写 RTCP）是实时传输协议（RTP）的一个姐妹协议。RTCP 为 RTP 媒体流提供信道外（out-of-band）控制。RTCP 本身并不传输数据，但和 RTP 一起协作将多媒体数据打包和发送。RTCP 定期在流多媒体会话参加者之间传输控制数据。RTCP 的主要功能是为 RTP 所提供的服务质量（Quality of Service）提供反馈。 RTCP 收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等等。网络应用程序可以利用 RTCP 所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP 本身不提供数据加密或身份认证。SRTCP 可以用于此类用途。 3. SRTP &amp; SRTCP 参考文档 RFC3711 安全实时传输协议（Secure Real-time Transport Protocol 或 SRTP）是在实时传输协议（Real-time Transport Protocol 或 RTP）基础上所定义的一个协议，旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护。它是由 David Oran（思科）和 Rolf Blom（爱立信）开发的，并最早由 IETF 于 2004年3月作为 RFC3711 发布。 由于实时传输协议和可以被用来控制实时传输协议的会话的实时传输控制协议（RTP Control Protocol 或 RTCP）有着紧密的联系，安全实时传输协议同样也有一个伴生协议，它被称为安全实时传输控制协议（Secure RTCP 或 SRTCP）；安全实时传输控制协议为实时传输控制协议提供类似的与安全有关的特性，就像安全实时传输协议为实时传输协议提供的那些一样。 在使用实时传输协议或实时传输控制协议时，使不使用安全实时传输协议或安全实时传输控制协议是可选的；但即使使用了安全实时传输协议或安全实时传输控制协议，所有它们提供的特性（如加密和认证）也都是可选的，这些特性可以被独立地使用或禁用。唯一的例外是在使用安全实时传输控制协议时，必须要用到其消息认证特性。 4. RTSP 参考文档 RFC2326 是由 Real Networks 和 Netscape 共同提出的。该协议定义了一对多应用程序如何有效地通过 IP 网络传送多媒体数据。RTSP 提供了一个可扩展框架，使实时数据，如音频与视频的受控、点播成为可能。数据源包括现场数据与存储在剪辑中的数据。该协议目的在于控制多个数据发送连接，为选择发送通道，如UDP、多播UDP与TCP提供途径，并为选择基于RTP上发送机制提供方法。 RTSP（Real Time Streaming Protocol）是用来控制声音或影像的多媒体串流协议，并允许同时多个串流需求控制，传输时所用的网络通讯协定并不在其定义的范围内，服务器端可以自行选择使用 TCP 或 UDP来传送串流内容，它的语法和运作跟 HTTP 1.1 类似，但并不特别强调时间同步，所以比较能容忍网络延迟。而前面提到的允许同时多个串流需求控制（Multicast），除了可以降低服务器端的网络用量，更进而支持多方视讯会议（Video Conference）。 因为与 HTTP1.1 的运作方式相似，所以代理服务器《Proxy》的快取功能《Cache》也同样适用于 RTSP，并因 RTSP 具有重新导向功能，可视实际负载情况来转换提供服务的服务器，以避免过大的负载集中于同一服务器而造成延迟。 5. RTSP 和 RTP 的关系 RTP 不象 http 和 ftp 可完整的下载整个影视文件，它是以固定的数据率在网络上发送数据，客户端也是按照这种速度观看影视文件，当影视画面播放过后，就不可以再重复播放，除非重新向服务器端要求数据。 RTSP 与 RTP 最大的区别在于：RTSP 是一种双向实时数据传输协议，它允许客户端向服务器端发送请求，如回放、快进、倒退等操作。当然，RTSP 可基于 RTP 来传送数据，还可以选择 TCP、UDP、组播 UDP 等通道来发送数据，具有很好的扩展性。它是一种类似与 http 协议的网络应用层协议。目前碰到的一个应用：服务器端实时采集、编码并发送两路视频，客户端接收并显示两路视频。由于客户端不必对视频数据做任何回放、倒退等操作，可直接采用 UDP + RTP + 组播实现。 RTP：实时传输协议（Real-time Transport Protocol） RTP/RTCP 是实际传输数据的协议 RTP 传输音频/视频数据，如果是 PLAY，Server 发送到 Client 端，如果是 RECORD，可以由Client 发送到 Server 整个 RTP 协议由两个密切相关的部分组成： RTP数据协议 RTP控制协议（即RTCP） RTSP：实时流协议（Real Time Streaming Protocol，RTSP） RTSP 的请求主要有 DESCRIBE, SETUP, PLAY, PAUSE, TEARDOWN, OPTIONS 等，顾名思义可以知道起对话和控制作用 RTSP 的对话过程中 SETUP 可以确定 RTP/RTCP 使用的端口，PLAY/PAUSE/TEARDOWN 可以开始或者停止 RTP 的发送，等等 RTCP： RTCP 包括 Sender Report 和 Receiver Report，用来进行音频/视频的同步以及其他用途，是一种控制协议 6. SDP 会话描述协议（SDP）为会话通知、会话邀请和其它形式的多媒体会话初始化等目的提供了多媒体会话描述。 会话目录用于协助多媒体会议的通告，并为会话参与者传送相关设置信息。SDP 即用于将这种信息传输到接收端。SDP 完全是一种会话描述格式 ― 它不属于传输协议 ― 它只使用不同的适当的传输协议，包括会话通知协议（SAP）、会话初始协议（SIP）、实时流协议（RTSP）、MIME 扩展协议的电子邮件以及超文本传输协议（HTTP）。 SDP 的设计宗旨是通用性，它可以应用于大范围的网络环境和应用程序，而不仅仅局限于组播会话目录，但 SDP 不支持会话内容或媒体编码的协商。 在因特网组播骨干网（Mbone）中，会话目录工具被用于通告多媒体会议，并为参与者传送会议地址和参与者所需的会议特定工具信息，这由 SDP 完成。SDP 连接好会话后，传送足够的信息给会话参与者。SDP 信息发送利用了会话通知协议（SAP），它周期性地组播通知数据包到已知组播地址和端口处。这些信息是 UDP 数据包，其中包含 SAP 协议头和文本有效载荷（text payload）。这里文本有效载荷指的是 SDP 会话描述。此外信息也可以通过电子邮件或 WWW （World Wide Web） 进行发送。 SDP 文本信息包括： 会话名称和意图； 会话持续时间； 构成会话的媒体； 有关接收媒体的信息（地址等）。 协议结构 SDP 信息是文本信息，采用 UTF-8 编 码中的 ISO 10646 字符集。SDP 会话描述如下：（标注 * 符号的表示可选字段）： 123456789v = （协议版本）o = （所有者/创建者和会话标识符）s = （会话名称）i = * （会话信息）u = * （URI 描述）e = * （Email 地址）p = * （电话号码）c = * （连接信息 ― 如果包含在所有媒体中，则不需要该字段）b = * （带宽信息） 一个或更多时间描述（如下所示）： 123z = * （时间区域调整）k = * （加密密钥）a = * （0 个或多个会话属性行） 0个或多个媒体描述（如下所示） 时间描述 12t = （会话活动时间）r = * （0或多次重复次数） 媒体描述 123456m = （媒体名称和传输地址）i = * （媒体标题）c = * （连接信息 — 如果包含在会话层则该字段可选）b = * （带宽信息）k = * （加密密钥）a = * （0 个或多个会话属性行） 7. RTMP/RTMPS RTMP(Real Time Messaging Protocol) 实时消息传送协议是 Adobe Systems 公司为 Flash 播放器和服务器之间音频、视频和数据传输 开发的开放协议。 它有三种变种： 1) 工作在 TCP 之上的明文协议，使用端口1935； 2) RTMPT 封装在 HTTP 请求之中，可穿越防火墙； 3) RTMPS 类似 RTMPT，但使用的是 HTTPS 连接； RTMP 协议(Real Time Messaging Protocol)是被 Flash 用于对象, 视频, 音频的传输. 这个协议建立在 TCP 协议或者轮询 HTTP 协议之上. RTMP 协议就像一个用来装数据包的容器, 这些数据既可以是 AMF 格式的数据,也可以是 FLV 中的视/音频数据. 一个单一的连接可以通过不同的通道传输多路网络流. 这些通道中的包都是按照固定大小的包传输的. 8. mms MMS (Microsoft Media Server Protocol)，中文“微软媒体服务器协议”，用来访问并流式接收 Windows Media 服务器中 .asf 文件的一种协议。MMS 协议用于访问 Windows Media 发布点上的单播内容。MMS 是连接 Windows Media 单播服务的默认方法。若观众在 Windows Media Player 中键入一个 URL 以连接内容，而不是通过超级链接访问内容，则他们必须使用MMS 协议引用该流。MMS的预设埠（端口）是1755 当使用 MMS 协议连接到发布点时，使用协议翻转以获得最佳连接。“协议翻转”始于试图通过 MMSU 连接客户端。 MMSU 是 MMS 协议结合 UDP 数据传送。如果 MMSU 连接不成功，则服务器试图使用 MMST。MMST 是 MMS 协议结合 TCP 数据传送。 如果连接到编入索引的 .asf 文件，想要快进、后退、暂停、开始和停止流，则必须使用 MMS。不能用 UNC 路径快进或后退。若您从独立的 Windows Media Player 连接到发布点，则必须指定单播内容的 URL。若内容在主发布点点播发布，则 URL 由服务器名和 .asf 文件名组成。例如：mms://windows_media_server/sample.asf。其中 windows_media_server 是 Windows Media 服务器名，sample.asf 是您想要使之转化为流的 .asf 文件名。 若您有实时内容要通过广播单播发布，则该 URL 由服务器名和发布点别名组成。例如：mms://windows_media_server/LiveEvents。这里 windows_media_server 是 Windows Media 服务器名，而 LiveEvents 是发布点名 9. HLS HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在 iOS 系统，为 iOS 设备（如iPhone、iPad）提供音视频直播和点播方案。HLS 点播，基本上就是常见的分段 HTTP 点播，不同在于，它的分段非常小。 相对于常见的流媒体直播协议，例如 RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS 协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS 是以点播的技术方式来实现直播。由于数据通过 HTTP 协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过 HLS 的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。 根据以上的了解要实现 HTTP Live Streaming 直播，需要研究并实现以下技术关键点： 采集视频源和音频源的数据 对原始数据进行H264编码和AAC编码 视频和音频数据封装为MPEG-TS包 HLS分段生成策略及m3u8索引文件 HTTP传输协议 9.1 HLS，RTSP，RTMP的区别 HLS （ HTTP Live Streaming）苹果公司提出的流媒体协议，直接把流媒体切片成一段段，信息保存到m3u列表文件中，可以将不同速率的版本切成相应的片；播放器可以直接使用http协议请求流数据，可以在不同速率的版本间自由切换，实现无缝播放；省去使用其他协议的烦恼。缺点是延迟大小受切片大小影响，不适合直播，适合视频点播。 RTSP （Real-Time Stream Protocol）由Real Networks 和 Netscape共同提出的，基于文本的多媒体播放控制协议。RTSP定义流格式，流数据经由RTP传输；RTSP实时效果非常好，适合视频聊天，视频监控等方向。 RTMP（Real Time Message Protocol） 有 Adobe 公司提出，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题，优势在于低延迟，稳定性高，支持所有摄像头格式，浏览器加载 flash插件就可以直接播放。 总结：HLS 延迟大，适合视频点播；RTSP虽然实时性最好，但是实现复杂，适合视频聊天和视频监控；RTMP强在浏览器支持好，加载flash插件后就能直接播放，所以非常火，相反在浏览器里播放rtsp就很困难了。 9.2 RTSP、RTCP、RTP区别1：RTSP实时流协议 作为一个应用层协议，RTSP提供了一个可供扩展的框架，它的意义在于使得实时流媒体数据的受控和点播变得可能。总的说来，RTSP是一个流媒体表示 协议，主要用来控制具有实时特性的数据发送，但它本身并不传输数据，而是必须依赖于下层传输协议所提供的某些服务。RTSP可以对流媒体提供诸如播放、暂 停、快进等操作，它负责定义具体的控制消息、操作方法、状态码等，此外还描述了与RTP间的交互操作（RFC2326）。 2：RTCP控制协议 RTCP控制协议需要与RTP数据协议一起配合使用，当应用程序启动一个RTP会话时将同时占用两个端口，分别供RTP和RTCP使用。RTP本身并 不能为按序传输数据包提供可靠的保证，也不提供流量控制和拥塞控制，这些都由RTCP来负责完成。通常RTCP会采用与RTP相同的分发机制，向会话中的 所有成员周期性地发送控制信息，应用程序通过接收这些数据，从中获取会话参与者的相关资料，以及网络状况、分组丢失概率等反馈信息，从而能够对服务质量进 行控制或者对网络状况进行诊断。 RTCP协议的功能是通过不同的RTCP数据报来实现的，主要有如下几种类型： SR：发送端报告，所谓发送端是指发出RTP数据报的应用程序或者终端，发送端同时也可以是接收端。(SERVER定时间发送给CLIENT)。 RR：接收端报告，所谓接收端是指仅接收但不发送RTP数据报的应用程序或者终端。(SERVER接收CLIENT端发送过来的响应)。 SDES：源描述，主要功能是作为会话成员有关标识信息的载体，如用户名、邮件地址、电话号码等，此外还具有向会话成员传达会话控制信息的功能。 BYE：通知离开，主要功能是指示某一个或者几个源不再有效，即通知会话中的其他成员自己将退出会话。 APP：由应用程序自己定义，解决了RTCP的扩展性问题，并且为协议的实现者提供了很大的灵活性。 3：RTP数据协议 RTP数据协议负责对流媒体数据进行封包并实现媒体流的实时传输，每一个RTP数据报都由头部（Header）和负载（Payload）两个部分组成，其中头部前12个字节的含义是固定的，而负载则可以是音频或者视频数据。 RTP用到的地方就是 PLAY ，服务器往客户端传输数据用UDP协议，RTP是在传输数据的前面加了个12字节的头(描述信息)。 RTP载荷封装设计本文的网络传输是基于IP协议，所以最大传输单元(MTU)最大为1500字节，在使用IP／UDP／RTP的协议层次结构的时候，这 其中包括至少20字节的IP头，8字节的UDP头，以及12字节的RTP头。这样，头信息至少要占用40个字节，那么RTP载荷的最大尺寸为1460字 节。以H264 为例，如果一帧数据大于1460，则需要分片打包，然后到接收端再拆包，组合成一帧数据，进行解码播放。 9.3 RTSP、 RTMP、HTTP的共同点、区别共同点： RTSP RTMP HTTP都是在应用应用层。 理论上RTSP RTMPHTTP都可以做直播和点播，但一般做直播用RTSP RTMP，做点播用HTTP。做视频会议的时候原来用SIP协议，现在基本上被RTMP协议取代了。 区别： HTTP: 即超文本传送协议(ftp即文件传输协议)。 HTTP:（Real Time Streaming Protocol），实时流传输协议。 HTTP全称Routing Table Maintenance Protocol（路由选择表维护协议）。 HTTP将所有的数据作为文件做处理。http协议不是流媒体协议。 RTMP 和 RTSP协议是流媒体协议。 RTMP协议是Adobe的私有协议,未完全公开，RTSP协议和HTTP协议是共有协议，并有专门机构做维护。 RTMP协议一般传输的是flv，f4v格式流，RTSP协议一般传输的是ts,mp4格式的流。HTTP没有特定的流。 RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据。","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/tags/FFmpeg/"}]},{"title":"WebRTC","slug":"WebRTC/webrtc","date":"2019-05-14T02:14:50.000Z","updated":"2019-06-11T09:10:45.862Z","comments":true,"path":"2019/05/14/WebRTC/webrtc/","link":"","permalink":"http://miaopei.github.io/2019/05/14/WebRTC/webrtc/","excerpt":"WebRTC WebRTC API Node.js v10.15.3 文档 廖雪峰 - nodejs 1. WebRTC 介绍","text":"WebRTC WebRTC API Node.js v10.15.3 文档 廖雪峰 - nodejs 1. WebRTC 介绍 Google 开源 跨平台 用于浏览器 实时传输 100ms 延迟 通话质量非常好 200ms 延迟 通话质量比较优质 500ms 延迟 可以接受 超过1s 非常迟滞 音视频引擎 WebRTC 应用： WebRTC 愿景： 学习 WebRTC 的难点： 学习路线： 学习内容： 学习收获： WebRTC能做啥： 能学到什么： google webrtc 示例：https://appr.tc/ 2. WebRTC 原理与架构WebRTC 整体架构： WebRTC 的目录结构图： WebRTC 两个基本概念：轨与流 Track MediaStream WebRTC重要类： MediaStream RTCPeerConnection RTCDataChannel PeerConnection调用过程： 调用时序图： WebRTC之PeerConnection的建立过程 WebRTC系列（3）：PeerConnection通信建立流程 3. Web服务器原理与Nodejs搭建Web服务器选型： Nodejs Nginx Apache Web服务工作原理： Nodejs工作原理： JavaScript解析： Nodejs 事件处理： 两个V8引擎： 最简单的http服务： require 引入http模块 创建http服务 侦听端口 启动Nodejs服务： node app.js nohub node app.js forever start app.js pm2 start app.js Https基本原理： Nodejs 搭建 https 服务： 生成 HTTPS证书 引入 HTTPS模块 指定证书位置，并创建 HTTPS 服务 真正的Web服务： 引用 express 模块 引入 server-index 模块 指定发布目录 4. JavaScript 必备知识回顾基础知识： 变量与类型 基本运算 if/else for循环 函数 日志打印 变量与类型： 基本运算： 5. WebRTC设备管理enumerateDevices： JavaScript中的Promise： 6. WebRTC音视频数据采集音视频采集API： getUserMedia的不同实现： 适配置不同浏览器的方法： https://webrtc.github.io/adapter/adapter-latest.js WebRTC音视频采集约束： 约束详解： width height 宽高比例：4:3 16:9 aspectRatio frameRate facingMode user - 前置摄像头 environment - 后置摄像头 left - 前置左侧摄像头 right - 前置右侧摄像头 resizeMode 音频约束详解： volume - 范围 0 - 1.0 sampleRate sampleSize - 一般16位 echoCancellation - 回音消除 autoGainControl - 是否在原有声音基础上增加音量 noiseSuppression - 降噪 latency - 延迟大小 channelCount - 声道 乐器一般是双声道 deviceID - 作用是多个设备切换 groupID WebRTC约束例子： 1234567891011121314151617&#123; audio: true, video: &#123; width: &#123; min: 300, max: 640, &#125;, height: &#123; min: 300, max: 480, &#125;, frameRate: &#123; min: 15, max: 30, &#125; &#125;&#125; 浏览器视频特效： CSS filter，-webkit-filter/filter 如何将 video 与 filter 关联 OpenGL/Metal/… 支持的特效种类： 保存图片是实现滤镜效果，可以对 canvas.data 进行数据修改。 MediaStream API 获取视频约束： 7. WebRTC音视频录制实战7.1 WebRTC录制基本知识MediaRecoder类： 7.2 WebRTC 捕获桌面 捕获桌面需要设置Chrome，具体 操作：chrome://flags/#enable-experimental-web-platform-features Experimental Web Platform features 设置为 enable 8. WebRTC信令服务器实现如果没有信令服务器WebRTC之间是不能通信的。 两个client之间通信必须有两个信息通过信令服务器的： 媒体信息， SDP 网络信息 具体的业务 Socket.IO 发送消息： 给本次连接发送消息 1socket.emit() 给某个房间内所有人发送消息 1io.in(room).emit() 除本链接外，给某个房间内所有人发送消息 1socket.to(room).emit() 除本链接外，给所有人发送消息 1socket.broadcast.emit() Socket.IO 客户端处理消息： 发送 action 命令 12S: socket.emit('action');C: socket.on('action', function()&#123;...&#125;); 发送了一个 action 命令，还有 data 数据 12S: socket.emit('action', data);C: socket.on('action', function(data)&#123;...&#125;); 发送了 action 命令，还有两个数据 12S: socket.emit('action', arg1, arg2);C: socket.on('action', function(arg1, arg2)&#123;...&#125;); 发送了一个 action 命令，在 emit 方法中包含回调函数 12S: socket.emit('action', data, function(arg1, arg2)&#123;...&#125;;C: socket.on('action', function(data, fn)&#123;fn('a', 'b');&#125;); 8.1 [实战] 通过 socket.io 实现信令服务器改造服务端的基本流程： 安装 socket.io 引入 socket.io 处理 connection 消息 9. WebRTC网络基础补充：P2P/STUN/TRUN/ICE知识9.1 WebRTC 网络传输基本知识WebRTC 传输基本知识： NAT（Network Address Translator） STUN（Simple Traversal of UDP Through NAT） TURN（Travelsal Using Relays around NAT） ICE（Interactive Connectivity Establishment） NAT 产生的原因： 由于IPv4的地址不够 处于网络安全的原因 NAT 的种类： 完全锥型 NAT（Full Cone NAT） 地址限制锥型 NAT（Address Restricted Cone NAT） 端口限制锥型 NAT（Port Restricted Cone NAT） 对称型 NAT（Symmetric NAT） 9.2 NAT 打洞原理 NAT 穿越原理： C1，C2 向 STUN 发消息 交换公网 IP 及 端口 C1 -&gt; C2，C2 -&gt; C1，甚至是端口猜测 9.3 NAT 类型检测 公网 IP： 如果 Client 收到的 IP 和第一次发出去的 IP 是不一样的，则是对称型 NAT，如果是一样的需要进一步判断： Client 通过 Port2 发送消息到 STUN Port1，STUN Server 通过 Port2 给 Client 回消息，如果 Client 能收到消息，则说明是 IP 限制型的；如果不能收到，则说明是端口限制型的： 9.4 【协议规范】STUN 协议一STUN 介绍： STUN 存在的目的就是进行 NAT 穿越 STUN 是典型的客户端 / 服务器模式。客户端发送请求，服务端进行响应 RFC STUN 规范： RFC3489/STUN SImple Traversal of UDP Trough NAT RFC5389/STUN — 包含UDP和TCP Session Traversal Utilities for NAT STUN 协议： 包括 20 字节的 STUN header Body 中可以有 0 个或多个 Attribute STUN header（RFC3489）： 其中 2 个字节（16bit）类型 2 个字节（16bit）消息长度，不包括消息头 16 个字节（128bit）事物ID，请求与响应事物 ID 相同 STUN header（RFC5389）格式： M 代表请求值，C 代表分类： RFC5389 把私密类型去掉了： 9.5 【协议规范】STUN 协议二Inter 机子都是小端模式： 9.6 【协议规范】TURN 协议TURN 介绍： 其目的是解决对称 NAT 无法穿越的问题 其建立在 STUN 之上，消息格式使用 STUN 格式消息 TURN Client 要求服务端分配一个公共 IP 和 Port 用于接受 或 发送数据 TURN 发送机制： Send 和 Data Channel 9.7 【协议规范】ICE 框架 Candidate 类型： 主机候选者 反射侯选者 中继候选者 ICE 具体做些什么： 收集 Candidate 对 Candidate Pair 排序 连通性检查 收集 Candidate： Host Candidate：本机所有 IP 和指定端口 Reflexive Candidate：STUN/TURN Relay Candidate：TURN 什么是 SDP： SDP（Session Description Protocol） 它只是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息。 形成 Candidate Pair： 一方收集到所有候选者后，通过信令传给对方 同样，另一方收到候选者后，也做收集工作 当双方拿到全部列表后，将侯选者形成匹配对儿 连通性检查： 对侯选者进行优先级排序 对每个侯选对进行发送检查 对每个侯选对进行接收检查 9.8 网络协议分析方法 tcpdump 与 wireshark讲解常用工具： Linux 服务端用 tcpdump 其它端 WireShark 9.9 网络协议分析方法 tcpdump 与 wireshark 实战vim 打开二进制数据： 1：%！xxd WireShark 中的逻辑运算： 与：and 或 &amp;&amp; 或：or 或 || 非：not 或 ！ WireShark 中判断语句： 等于：eq 或 == 小于：lt 或 &lt; 大于：gt 或 &gt; 小于等于：le 或 &lt;= 大于等于：ge 或 &gt;= 不等于：ne 或 != WireShark 按协议过滤： stun tcp udp 模拟STUN数据可以使用这个网站中的工具：https://webrtc.github.io/samples Wireshark 按 IP 过滤： 123ip.dst == 192.168.1.2ip.src == 192.168.1.2ip.addr == 192.168.1.2 WireShark 按 port 过滤： 1234tcp.port == 8080udp.port == 3478udp.dstport == 3478udp.srcport == 3478 WireShark 过滤长度： 123udp.length &lt; 30tcp.length &lt; 30http.content_length &lt; 30 WireShark 过滤内容： TODO 10. 端对端1V1传输基本流程10.1 媒体能力协商过程WebRTC 端对端连接： RTCPeerConnection： 基本格式 1pc = new RTCPeerConnection([configuration]); RTCPeerConnection 方法分类： 媒体协商 Stream/Track 传输相关方法 统计相关方法 媒体协商方法： createOffer createAnswer setLocakDescription setRemoteDescription createOffer： 基本格式 1aPromise = myPeerConnection.createOffer([options]); createAnswer： 基本格式 1aPromise = myPeerConnection.createAnswer([options]); setLocakDescription： 基本格式 1aPromise = myPc.setLocalDescription(sessionDescription); setRemoteDescription： 基本格式 1aPromise = myPc.setRemoteDescription(sessionDescription); Track 方法： addTrack removeTrack addTrack： 基本格式 1rtpSender = myPc.addTrack(track, stream...); Parameters removeTrack： 基本格式 1myPc.remoteTrack(rtpSender); 重要事件： onnegotiationneeded - 协商的时候触发这个事件 onicecandidate - 当收到 ICE 候选者的时候触发这个事件 10.2 1:1 连接的基本流程 A 与 B 通信，大的方向分为三部分： 媒体协商部分 ICE 候选者的交换、连接、检测部分 媒体数据流的通信部分 10.3 【实战】WebRTC 视频传输TODO 10.4 【实战】显示通讯双方的 SDP 内容TODO 11. WebRTC核心之SDP详解11.1 【协议规范】SDP 规范SDP 规范： 会话层 媒体层 可以把会话层看做树根，媒体层看成树干。 会话层： 会话的名称与目的 会话的存活时间 会话中包含多个媒体信息 SDP 媒体信息： 媒体格式 传输协议 传输 IP 和 端口 媒体负载类型 SDP 格式： 由多个 &lt;type&gt;=&lt;value&gt; 组成 一个会话级描述 多个媒体级描述 SDP 结构： Session Description Time Description Media Description 11.2 【协议规范】WebRTC 中的 SDP 11.3 【详解】WebRTC 中 Offer_Answer SDP12 12. 实现1V1音视频实时互动直播系统12.1 STUN/TURN 服务器搭建coTurn Download Address：https://github.com/coturn/coturn ICE 测试地址：https://webrtc.github.io/samples 12# 启动 turn server$ turnserver -c /usr/local/coturn/etc/turnserver.conf 12.2 【参数介绍】再论 RTCPeerConnection 12.3 直播系统中的信令及其逻辑关系【实战】真正的音视频传输 客户端信令消息： join 加入房间 leave 离开房间 message 端到端消息 端到端信令消息： Offer 消息 Answer 消息 Candidate 消息 服务端信令消息： joined 已加入房间 otherjoin 其它用户加入房间 full 房间人数已满 leaved 已离开房间 bye 对方离开房间 12.4 实现 1：1 音视频实时互动信令服务器信令服务器改造 TODO 12.5 再论CreateOffer CreateOffer 实战： 接收远端音频 接收远端视频 静音检测 ICE restart 12.6 WebRTC 客户端状态机及处理逻辑直播客户端的实现： 12.7 WebRTC 客户端的实现 12.8 共享远程桌面 13. WebRTC核心之RTP媒体控制与数据统计13.1 RTPPReceiver 发送器RTP Media 13.2 RTPSender 发送器 13.3 传输速率的控制 chrome WebRTC 状态查询地址：chrome://webrtc-internals 13.4 【实战】WebRTC统计信息TODO 14. WebRTC非音视频数据传输14.1 传输非音视频数据基础知识 Reliability：可靠性 Delivery：可达性 Transmission：传输方式 Flow control：流控 Congestion control：拥塞控制 14.2 端到端文本聊天TODO 14.3 文件实时传输 15. WebRTC实时数据传输网络协议详解15.1 【协议规范】RTP-SRTP协议头详解 15.2 【协议规范】RTCP 中的 SR 与 RR 报文 15.3 【协议规范】DTSL 15.4 wireshark 分析 rtp-rtcp 包TODO 16. Android端与浏览器互通16.1 Android 与浏览器互通 16.2 WebRTCNative 开发逻辑 16.3 实战-权限申请-库的引入与界面 16.4 实战-通过 socket.io 实现信令收发 16.5 实战-Android 与浏览器互通创建 PeerConnection： 音视频数据采集 创建 PeerConnection 媒体能力协商： 协商媒体能力 Candidate 连通 视频渲染 17. iOS端与浏览器互通17.1 IOS权限获取 17.2 IOS引入WebRTC库 17.3 IOS端SocketIO的使用 17.4 IOS界面布局TODO 17.5 IOS本地视频采集与展示TODO 17.6 IOS端RTCPeerConnectionTODO 17.7 IOS媒体协商 17.8 IOS远端视频渲染 18. 课程总结 Reference JavaScript 是如何工作的:WebRTC 和对等网络的机制！ 深入理解WebRTC WebRTC架构简介 HTTPS证书生成原理和部署细节 SSL证书生成流程 Gradle官网 Gradle 包 Mac下AndroidStudio中手动配置Gradle WebRTC的分层协议图： 信令，会话和协议： 问题解决里程node 启动 server 报错： 12345678910111213141516events.js:141 throw er; // Unhandled 'error' event ^Error: listen EACCES 0.0.0.0:443 at Object.exports._errnoException (util.js:870:11) at exports._exceptionWithHostPort (util.js:893:20) at Server._listen2 (net.js:1224:19) at listen (net.js:1273:10) at net.js:1382:9 at nextTickCallbackWith3Args (node.js:452:9) at process._tickCallback (node.js:358:17) at Function.Module.runMain (module.js:444:11) at startup (node.js:136:18) at node.js:966:3[Solve]$ sudo setcap 'cap_net_bind_service=+ep' $(readlink -f $(which node)) 查询端口是否别占用： 1$ netstat -ntpl | grep 443 VIM 快捷键温习 Vim 插件 tern_for_vim Javascript 自动补全 最全的vim快捷键 vim 格式化文本，调整缩进： = 是格式化文本的快捷方法， 当你发现代码缩进的不整齐的，可以用这个快速对齐它们。 直接按＝号就可以，不能进入命令模式（以 “:” 冒号开始的命令行）。 gg=G ：从头格到尾，爽。 ＝＝ 格式化一行 如要格式化一段代码，可以先选中这些代码，再按＝号。 调整缩进还有个比较慢的办法，按＞＞，向右缩进一格，＜＜向左缩进一格。 vim常用快捷键总结： 光标移动到行首：0 光标移动到行尾：$ 光标移动到文件开始：GG 光标移动到文件末尾：shift +G 先前翻页：Ctrl+f 向后翻页：Ctrl+b 删至行首：d0 删至行尾：d$ 删除当前行及其后面n-1行：ndd 删除当前字符：x 删除当前字符的前一个字符：X 删除当前字符：dl 删除到第三个字符的结尾位置：d3w 删除到某个单词的末尾：dw 删除到某个单词的开始：db 删除当前行到文件的末尾：dG 删除当前行到文件第一行：dH 删除知道屏幕上最后一行：dL 替换当前行所有temp为hehe：:s/temp/hehe/g 替换每行中第一个#include为hehe：:%s/#include/hehe/ 替换每行中所有的#include为hehe：:%s/#include/hehe/g 替换第n行开始到最后一行中每一行的第一个#include为hehe：:n,$s/#include/hehe/ 替换第n行开始到最后一行中每一行的所有#include为hehe：:n,$s/#include/hehe/g 替换当前行到末尾的所有#include为hehe：:.,$s/#include/hehe/g 替换正文中所有出现的#include为hehe：:1,$s/#include/hehe/g 回复上一步操作：u 全部回复操作：shift + u 重做上一步操作：Ctrl + r 把下一行合并到当前行尾：J 选中当前行及其后面的n-1行：nV 复制当前光标到此单词末尾：yw 批量添加注释：Ctrl+v可视模式，上、下、左、右移动光标选择若干行开头；Shift+i进入插入模式；输入// 者；按Esc 批量去掉注释：Ctrl+v可视模式，上、下、左、右移动关闭选择要删除的注释符，如//或#；按d删除 横向打开另一个窗口：:sp 文件名 竖向打开另一个窗口：:vsp 文件名 关闭当前打开的所有窗口：:qa 选择当前字符所在的单词：Ctrl+v可视模式，然后a+w或i+w 选择当前字符所在的段落：Ctrl+v可视模视，然后i+p或a+p","categories":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://miaopei.github.io/categories/WebRTC/"}],"tags":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://miaopei.github.io/tags/WebRTC/"}]},{"title":"ffmpeg编程基础和一些常见问题的解答","slug":"FFmpeg/ffmpeg编程基础和一些常见问题的解答","date":"2019-05-09T02:14:50.000Z","updated":"2019-06-10T07:29:14.483Z","comments":true,"path":"2019/05/09/FFmpeg/ffmpeg编程基础和一些常见问题的解答/","link":"","permalink":"http://miaopei.github.io/2019/05/09/FFmpeg/ffmpeg编程基础和一些常见问题的解答/","excerpt":"ffmpeg编程基础和一些常见问题的解答 FFMpeg 编程的大致框架","text":"ffmpeg编程基础和一些常见问题的解答 FFMpeg 编程的大致框架 进一步的详解，具体到函数调用级别 详细步骤： 注册所有容器格式和 CODEC:av_register_all(） 打开文件: av_open_input_file() 从文件中提取流信息 : av_find_stream_info() 穷举所有的流，查找其中种类为 CODEC_TYPE_VIDEO 查找对应的解码器 : avcodec_find_decoder() 打开编解码器 : avcodec_open() 为解码帧分配内存 : avcodec_alloc_frame() 不停地从码流中提取出帧数据 : av_read_frame() 判断帧的类型，对于视频帧调用 : avcodec_decode_video() 解码完后，释放解码器 : avcodec_close() 关闭输入文件 : av_close_input_file() 首先第一件事情就是开一个视频文件并从中得到流。 我们要做的第一件事情就是使用 av_register_all() ;来初始化 libavformat/libavcodec : 这一步注册库中含有的所有可用的文件格式和编码器，这样当打开一个文件时，它们才能够自动选择相应的文件格式和编码器。av_register_all() 只需调用一次，所以，要放在初始化代码中。也可以仅仅注册个人的文件格式和编码。 下一步，打开文件： 123AVFormatContext *pFormatCtx;const char *filename = \"myvideo.mpg\";av_open_input_file(&amp;pFormatCtx, filename, NULL, 0, NULL)； // 打开视频文件 最后三个参数描述了文件格式，缓冲区大小（size）和格式参数；我们通过简单地指明NULL或0告诉 libavformat 去自动探测文件格式并且使用默认的缓冲区大小。这里的格式参数指的是视频输出参数，比如宽高的坐标。 下一步，我们需要取出包含在文件中的流信息： 12345678av_find_stream_info(pFormatCtx)； // 取出流信息dump_format(pFormatCtx, 0, filename, false); //我们可以使用这个函数把获取到得参数全部输出。for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++) //区分视频流和音频流if(pFormatCtx-&gt;streams-&gt;codec.codec_type == CODEC_TYPE_VIDEO) //找到视频流，这里也可以换成音频&#123; videoStream = i; break;&#125; 接下来就需要寻找解码器 123AVCodec *pCodec;pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);avcodec_open(pCodecCtx, pCodec)； // 打开解码器 给视频帧分配空间以便存储解码后的图片： 12AVFrame *pFrame;pFrame = avcodec_alloc_frame(); ////////////////////////////////////////开始解码/////////////////////////////////////////// 第一步当然是读数据： 我们将要做的是通过读取包来读取整个视频流，然后把它解码成帧，最后转换格式并且保存。 12345678910while(av_read_frame(pFormatCtx, &amp;packet)&gt;=0) &#123; //读数据 if(packet.stream_index==videoStream)&#123; //判断是否视频流 avcodec_decode_video(pCodecCtx, pFrame, &amp;frameFinished, packet.data, packet.size); //解码 &#125; if(frameFinished) &#123; img_convert((AVPicture *)pFrameRGB, PIX_FMT_RGB24,(AVPicture*)pFrame, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx- &gt;height); //转换 &#125; SaveFrame(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, i); //保存数据 av_free_packet(&amp;packet); //释放&#125; av_read_frame() 读取一个包并且把它保存到 AVPacket 结构体中。这些数据可以在后面通过 av_free_packet() 来释放。函数 avcodec_decode_video() 把包转换为帧。然而当解码一个包的时候，我们可能没有得到我们需要的关于帧的信息。因此，当我们得到下一帧的时候， avcodec_decode_video() 为我们设置了帧结束标志 frameFinished。最后，我们使用 img_convert() 函数来把帧从原始格式（pCodecCtx-&gt;pix_fmt）转换成为 RGB 格式。要记住，你可以把一个 AVFrame 结构体的指针转换为 AVPicture 结构体的指针。最后，我们把帧和高度宽度信息传递给我们的 SaveFrame 函数。 到此解码完毕，显示过程使用 SDL 完成考虑到我们以后会使用 firmware 进行显示操作，SDL 忽略不讲。 音视频同步DTS（解码时间戳）和 PTS（显示时间戳） 当我们调用 av_read_frame() 得到一个包的时候，PTS 和 DTS 的信息也会保存在包中。但是我们真正想要的 PTS 是我们刚刚解码出来的原始帧的 PTS，这样我们才能知道什么时候来显示它。然而，我们从 avcodec_decode_video() 函数中得到的帧只是一个 AVFrame，其中并没有包含有用的 PTS 值（注意：AVFrame 并没有包含时间戳信息，但当我们等到帧的时候并不是我们想要的样子）。 我们保存一帧的第一个包的 PTS：这将作为整个这一帧的 PTS。我们可以通过函数 avcodec_decode_video() 来计算出哪个包是一帧的第一个包。 怎样实现呢？任何时候当一个包开始一帧的时候，avcodec_decode_video() 将调用一个函数来为一帧申请一个缓冲。当然，ffmpeg 允许我们重新定义那个分配内存的函数。计算前一帧和现在这一帧的时间戳来预测出下一个时间戳的时间。同时，我们需要同步视频到音频。我们将设置一个音频时间 audioclock；一个内部值记录了我们正在播放的音频的位置。就像从任意的 mp3 播放器中读出来的数字一样。既然我们把视频同步到音频，视频线程使用这个值来算出是否太快还是太慢。 用 FFMPEG SDK 进行视频转码压缩时解决音视频不同步问题的方法: 用 FFMPEG SDK 进行视频转码压缩的时候，转码成功后去看视频的内容，发现音视频是不同步的。这个的确是一个恼火的事情。我在用 FFMPEG SDK 做 h264 格式的 FLV 文件编码 Filter 的时候就碰到了这个问题。 经过研究发现，FFMPEG SDK 写入视频的时候有两个地方用来控制写入的时间戳，一个是 AvPacket 一个是 AvFrame 。在调用 avcodec_encode_video 的时候需要传入 AvFrame 的对象指针，也就是传入一帧未压缩的视频进行压缩处理，AvFrame 包含一个 pts 的参数，这个参数就是当前帧将来在还原播放的时候的时间戳。而 AvPacket 里面也有 pts，还有 dts。说起这个就必须要说明一下 I , P , B 三种视频压缩帧。I 帧就是关键帧，不依赖于其他视频帧，P 帧是向前预测的帧，只依赖于前面的视频帧，而 B 帧是双向预测视频帧，依赖于前后视频帧。由于 B 帧的存在，因为它是双向的，必须知道前面的视频帧和后面的视频帧的详细内容后，才能知道本 B 帧最终该呈现什么图像。而 pts 和 dts 两个参数就是用来控制视频帧的显示和解码的顺序。 pts 就是帧显示的顺序。dts 就是帧被读取进行解码的顺序。如果没有 B 帧存在，dts 和 pts 是相同的。反之，则是不相同的。关于这个的详细介绍可以参考一下 mpeg 的原理。 AvPacket 包含的 pts 和 dts 两个到底该设置什么值？ pts 和 dts 需要设置的就是视频帧解码和显示的顺序。每增加一帧就加一，并不是播放视频的时间戳。但是实践证明经过 rmvb 解码的视频有时候并不是固定帧率的，而是变帧率的，这样，如果每压缩一帧，pts 和 dts 加一的方案为导致音视频不同步。 那怎么来解决音视频同步的问题呢？ 请看如下代码段。 lTimeStamp 是通过 directshow 获取的当前的视频帧的时间戳。m_llframe_index 为当前已经经过压缩处理的帧的数量。 首先 av_rescale 计算得到当前压缩处理已经需要处理什么时间戳的视频帧，如果该时间戳尚未到达 directshow 当前提供的视频帧的时间戳，则将该帧丢弃掉。 否则进行压缩操作。并设置 AVPacket 的 pts 和 dts。这里假设 B 帧不存在。 因为在将来播放的时候视频以我们设定的固定播放帧率进行播放，所以需要根据设定的播放帧率计算得到的视频帧时间戳和 directshow 提供的当前视频帧的时间戳进行比较，设定是否需要进行实施延缓播放的策略。如果需要延缓播放，则将 pts 增加步长 2，否则以普通速度播放，则设置为 1.dts 与之相同。 1234567891011121314151617181920212223242526272829303132333435363738394041__int64 x =av_rescale(m_llframe_index,AV_TIME_BASE*(int64_t)c-&gt;time_base.num,c-&gt;time_base.den); if( x &gt; lTimeStamp )&#123; return TRUE;&#125;m_pVideoFrame2-&gt;pts = lTimeStamp;m_pVideoFrame2-&gt;pict_type = 0; int out_size = avcodec_encode_video( c, m_pvideo_outbuf, video_outbuf_size,m_pVideoFrame2 );/* if zero size, it means the image was buffered */if (out_size &gt; 0)&#123; AVPacket pkt; av_init_packet(&amp;pkt);&#125;if( x &gt; lTimeStamp )&#123; pkt.pts = pkt.dts = m_llframe_index; pkt.duration = 0;&#125; else&#123; pkt.duration = (lTimeStamp - x)*c-&gt;time_base.den/1000000 + 1; pkt.pts = m_llframe_index; pkt.dts = pkt.pts; m_llframe_index += pkt.duration;&#125; //pkt.pts = lTimeStamp * (__int64)frame_rate.den / 1000;if( c-&gt;coded_frame &amp;&amp; c-&gt;coded_frame-&gt;key_frame )&#123; pkt.flags |= PKT_FLAG_KEY;&#125; pkt.stream_index= m_pVideoStream-&gt;index;pkt.data= m_pvideo_outbuf;pkt.size= out_size; /* write the compressed frame in the media file */ret = av_interleaved_write_frame( m_pAvFormatContext, &amp;pkt );&#125;else&#123; ret = 0;&#125; avcodec_decode_video 解码的帧为什么后面的比前面的 pts 小呢？ 请问如下代码： 1234567891011121314while( av_read_frame(pFormatCtxSource,&amp;packet)&gt;=0 )&#123; if( packet.stream_index == videoStream )&#123; int out_size = avcodec_decode_video(pCodecCtxSource, pFrameSource, &amp;bFrameFinished, packet.data, packet.size); if( bFrameFinished )&#123; pFrameSource-&gt;pts = av_rescale_q(packet.pts, pCodecCtxSource-&gt;time_base, pStCodec-&gt;time_base); int out_size = avcodec_encode_video(pStCodec, video_buffer, 200000, pFrameSource); // Encodeto output if( out_size&gt;0 )&#123; // ... &#125; &#125; &#125; av_free_packet(&amp;packet);&#125; 在我Decode的时候，第一帧得到的 pFrameSource-&gt;pts 是96，再解第二帧的时候，pFrameSource-&gt;pts计算完后就成了80几，后几帧也是比96小，过一会又会解出来一个100多的，接下来又是比100多小的，这是为什么？在Encode的时候，先Encode一个pts=96的，再去Encode比96小的帧就返回-1了，直到找到一个比96大的。 理解： Decoder后output的pts是按正常的顺序，即显示的顺序输出的，如果有B帧，decoder会缓存。 但encoder后，输出的是按dts输出的。 Pts,dts并不是时间戳，而更应该理解为frame的顺序序列号。由于每帧frame的帧率并不一定是一致的，可能会变化的。转换为时间戳的话，应该是（pts 帧率）。为加深理解 可以将pts比做是第pts帧frame，假设每帧的帧率不变的话，则显示的时间戳为（pts**帧率），如果考虑帧率变化的，则要想办法将（pts 当前的帧率）累加到后面。 可以看出有的pts是+1累加，有的是加了很多，但都是按顺序累加的。当传人decoder前的packet有pts时，则decoder后获取的frame将会赋值packet的pts；当传人的packet只是一帧的部分数据或是B帧，由于decoder出来的frame要按正常的pts顺序输出，有可能decoder不会获取到frame，或decoder内部会缓存也不会输出frame，即frame的pts会为空。Frame pts（即opaque）为空的话则会看frame-&gt;dts,dts都没有的话才认为frame-&gt;pts为0. 对于： 12345pts *= av_q2d(is-&gt;video_st-&gt;time_base); // 即pts帧率// Did we get avideo frame?if(frameFinished) &#123; pts=synchronize_video(is, pFrame, pts); synchronize_video 考虑了 3中情况： 1. pts 拿到的话就用该pts 2. pts没有拿到的话就用前一帧的pts时间 3. 如果该帧要重复显示，则将显示的数量 * 帧率，再加到前面的 pts 中。 1234567891011121314151617181920212223if(queue_picture(is, pFrame, pts) &lt; 0) &#123;/////传人decoder后的帧队列中，以便后续去获取show。static double synchronize_video(VideoState *is, AVFrame*src_frame, double pts) &#123; doubleframe_delay; if(pts != 0) &#123; /* if we havepts, set video clock to it */ is-&gt;video_clock = pts; &#125; else &#123; /* if we aren'tgiven a pts, set it to the clock */ pts =is-&gt;video_clock; &#125; /* update thevideo clock */ /////很关键：前面传进来的pts已经是时间戳了，是当前frame开始播放的时间戳， /////下面frame_delay是该帧显示完将要花费的时间，（pts+frame_delay）也即是/////预测的下一帧将要播放的时间戳。 frame_delay =av_q2d(is-&gt;video_st-&gt;codec-&gt;time_base); /* if we arerepeating a frame, adjust clock accordingly */ //////重复多帧的话要累加上 frame_delay +=src_frame-&gt;repeat_pict * (frame_delay * 0.5); is-&gt;video_clock += frame_delay; return pts;/////此时返回的值即为下一帧将要开始显示的时间戳。&#125; ///////开定时器去显示帧队列中的已经decode过的数据，按前面的分析我们已经知道帧队列中的数据已经是按pts顺序插入到队列中的。Timer的作用就是有帧率不一致及重复帧的情况造成时间戳不是线性的，有快有慢，从而tutorial5才有timer的方式来播放追赶 以下是一个网友很直观浅显的例子解释： if(packet-&gt;dts == AV_NOPTS_VALUE 是不是就是没有获取到 dts 的情况？ 就是有一把尺子一只蚂蚁跟着一个标杆走 标杆是匀速的蚂蚁或快或慢 慢了你就抽让他跑起来快了就拽它 这样音（标杆）视频（蚂蚁）就能同步了 这里最大的问题就是音频是匀速的视频是非线性的 另外：此时 vp–&gt;pts 获取到的 pts 已经转化为时间戳了，这个时间戳为就是当前帧显示结束的时间戳，也即是下一帧将显示的预测时间戳。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static void video_refresh_timer(void *userdata) &#123; VideoState *is = (VideoState*)userdata; VideoPicture *vp; double actual_delay, delay,sync_threshold, ref_clock, diff; if(is-&gt;video_st) &#123; if(is-&gt;pictq_size == 0) &#123; schedule_refresh(is, 1); &#125; else &#123; vp =&amp;is-&gt;pictq[is-&gt;pictq_rindex]; delay = vp-&gt;pts -is-&gt;frame_last_pts; /* the pts from last time */ ////这是当前要显示的frame和下一副 //////将要显示的frame的间隔时间 if(delay &lt;= 0 || delay&gt;= 1.0) &#123; /* if incorrect delay, useprevious one */ delay =is-&gt;frame_last_delay; &#125; /* save for next time */ is-&gt;frame_last_delay =delay; is-&gt;frame_last_pts =vp-&gt;pts; /* update delay to sync toaudio */ ref_clock = get_audio_clock(is);/////获取到声音当前播放的时间戳。 diff = vp-&gt;pts -ref_clock;////// vp-&gt;pts实际上是预测的下一帧将要播放的开始时间, //也就是说在diff这段时间中声音是匀速发生的，但是在delay这段时间frame的显示可能就会有快//////////慢的区别。 /* Skip or repeat the frame.Take delay into account FFPlay still doesn't \"know if this is thebest guess.\" */ sync_threshold = (delay &gt;AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD; if(fabs(diff) &lt; AV_NOSYNC_THRESHOLD) &#123; if(diff &lt;=-sync_threshold) &#123; delay = 0;//////下一帧画面显示的时间和当前的声音很近的话加快显示下一帧（即后面video_display显示完当前帧后开启定时器很快 去显示下一帧） &#125; else if(diff &gt;=sync_threshold) &#123; delay = 2 * delay; //////下一帧开始显示的时间和当前声音的时间隔的比较长则延缓，即两帧画面间话的显示的时间长度大于两帧画面 间的声音播放的时间，则我们将两帧画显示的时候加倍拖长点，比如帧1和帧2的时间显示间隔为40ms，但帧1和帧2的声音播放时间为55ms，怎么办呢？我们不可能去打乱声音的质量的，则我们采用的方法是：将两帧画面的播放间隔加大，本来是过30ms就要开始播下一帧的，我们改成60ms后才播下一帧。 &#125; &#125;///当然如果diff大于AV_NOSYNC_THRESHOLD，即快进的模式了，画面跳动太大，不存在音视频同步的问题了。 is-&gt;frame_timer += delay; /* computer the REAL delay*/ actual_delay =is-&gt;frame_timer - (av_gettime() / 1000000.0); if(actual_delay &lt; 0.010)&#123; /* Really it should skipthe picture instead */ actual_delay = 0.010; &#125; schedule_refresh(is,(int)(actual_delay * 1000 + 0.5));////开定时器去显示下一帧 /* show the picture! */ video_display(is);////立马显示当前帧 /* update queue for nextpicture! */ if(++is-&gt;pictq_rindex ==VIDEO_PICTURE_QUEUE_SIZE) &#123; is-&gt;pictq_rindex = 0; &#125; SDL_LockMutex(is-&gt;pictq_mutex); is-&gt;pictq_size--; SDL_CondSignal(is-&gt;pictq_cond); SDL_UnlockMutex(is-&gt;pictq_mutex); &#125; &#125; else &#123; schedule_refresh(is, 100); &#125;","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/tags/FFmpeg/"}]},{"title":"FFmpeg命令大全","slug":"FFmpeg/FFmpeg命令大全","date":"2019-05-04T02:14:50.000Z","updated":"2019-06-05T04:03:57.388Z","comments":true,"path":"2019/05/04/FFmpeg/FFmpeg命令大全/","link":"","permalink":"http://miaopei.github.io/2019/05/04/FFmpeg/FFmpeg命令大全/","excerpt":"1. 前言FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。 本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。","text":"1. 前言FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。 本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。 2. FFMPEG 目录及作用 libavcodec： 提供了一系列编码器的实现。 libavformat： 实现在流协议，容器格式及其本IO访问。 libavutil： 包括了hash器，解码器和各类工具函数。 libavfilter： 提供了各种音视频过滤器。 libavdevice： 提供了访问捕获设备和回放设备的接口。 libswresample： 实现了混音和重采样。 libswscale： 实现了色彩转换和缩放工能。 3. FFMPEG 基本概念在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。 音／视频流 在音视频领域，我们把一路音／视频称为一路流。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。 容器 我们一般把 MP4､ FLV、MOV 等文件格式称之为容器。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。 channel channel 是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。 4. FFMPEG 命令我们按使用目的可以将 FFMPEG 命令分成以下几类： 基本信息查询命令 录制 分解 / 复用 处理原始数据 滤镜 切割与合并 图／视互转 直播相关 除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。 然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。 默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。 您可以通过使用 -vn / -an / -sn / -dn 选项来禁用某些默认设置。 要进行全面的手动控制，请使用 -map选项，该选项禁用刚描述的默认设置。 下面我们就来详细介绍一下这些命令。 5. 基本信息查询命令FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 ffmpeg -filters 来查询。详细参数说明如下： 参数 说明 -version 显示版本。 -formats 显示可用的格式（包括设备）。 -demuxers 显示可用的demuxers。 -muxers 显示可用的muxers。 -devices 显示可用的设备。 -codecs 显示libavcodec已知的所有编解码器。 -decoders 显示可用的解码器。 -encoders 显示所有可用的编码器。 -bsfs 显示可用的比特流filter。 -protocols 显示可用的协议。 -filters 显示可用的libavfilter过滤器。 -pix_fmts 显示可用的像素格式。 -sample_fmts 显示可用的采样格式。 -layouts 显示channel名称和标准channel布局。 -colors 显示识别的颜色名称。 接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。 6. 命令基本格式及参数下面是 FFMPEG 的基本命令格式： 12$ ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ... &#123;[output_file_options] output_url&#125; ... ffmpeg 通过 -i 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等），并写入任意数量的输出“文件”。 原则上，每个输入 / 输出“文件”都可以包含任意数量的不同类型的视频流（视频 / 音频 / 字幕 / 附件 / 数据）。 流的数量和 / 或类型是由容器格式来限制。 选择从哪个输入进入到哪个输出将自动完成或使用 -map 选项。 要引用选项中的输入文件，您必须使用它们的索引（从 0 开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 例如： 2：3 是指第三个输入文件中的第四个流。 上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数： 6.1 主要参数 参数 说明 -f fmt（输入/输出） 强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。 -i url（输入） 输入文件的网址 -y（全局参数） 覆盖输出文件而不询问。 -n（全局参数） 不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。 -c [：stream_specifier] codec（输入/输出，每个流） 选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT -codec [：stream_specifier]编解码器（输入/输出，每个流） 同 -c -t duration（输入/输出） 当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。 -ss位置（输入/输出） 当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。 -frames [：stream_specifier] framecount（output，per-stream） 停止在帧计数帧之后写入流。 -filter [：stream_specifier] filtergraph（output，per-stream） 创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。 6.2 视频参数 参数 说明 -vframes num（输出） 设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。 -r [：stream_specifier] fps（输入/输出，每个流） 设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。 -s [：stream_specifier]大小（输入/输出，每个流） 设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。 -aspect [：stream_specifier] 宽高比（输出，每个流） 设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。 -vn（输出） 禁用视频录制。 -vcodec编解码器（输出） 设置视频编解码器。这是 -codec：v 的别名。 -vf filtergraph（输出） 创建由filtergraph指定的过滤器图，并使用它来过滤流。 6.3 音频参数 参数 说明 -aframes（输出） 设置要输出的音频帧的数量。这是 -frames：a 的一个过时的别名。 -ar [：stream_specifier] freq（输入/输出，每个流） 设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。 -ac [：stream_specifier]通道（输入/输出，每个流） 设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。 -an（输出） 禁用录音。 -acodec编解码器（输入/输出） 设置音频编解码器。这是-codec的别名：a。 -sample_fmt [：stream_specifier] sample_fmt（输出，每个流） 设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。 -af filtergraph（输出） 创建由filtergraph指定的过滤器图，并使用它来过滤流。 了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。 7. 录制首先通过下面的命令查看一下 mac 上都有哪些设备。 1$ ffmpeg -f avfoundation -list_devices true -i \"\" 录屏 1$ ffmpeg -f avfoundation -i 1 -r 30 out.yuv -f 指定使用 avfoundation 采集数据。 -i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。 -r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而 -r 用于限制输出。 注意：桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。 录屏+声音 1$ ffmpeg -f avfoundation -i 1:0 -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k out.flv -i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。 -c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。 -crf 是 x264 的参数。 0 表式无损压缩。 -c:a 与参数 -acodec 一样，表示音频编码器。 -profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。 -b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。 录视频 1$ ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4 -framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。 -f 指定使用 avfoundation 采集数据。 -i 指定视频设备的索引号。 视频+音频 1$ ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4 录音 1$ ffmpeg -f avfoundation -i :0 out.wav 录制音频裸数据 1$ ffmpeg -f avfoundation -i :0 -ar 44100 -f s16le out.pcm 8. 分解与复用流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为： 由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。 抽取音频流 1$ ffmpeg -i input.mp4 -acodec copy -vn out.aac acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。 vn: v 代表视频，n 代表 no 也就是无视频的意思。 抽取视频流 1$ ffmpeg -i input.mp4 -vcodec copy -an out.h264 vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。 an: a 代表视频，n 代表 no 也就是无音频的意思。 转格式 1$ ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv 上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了 flv。 音视频合并 1$ ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4 9. 处理原始数据提取YUV数据 12$ ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv$ ffplay -s wxh out.yuv -c:v rawvideo 指定将视频转成原始数据 -pixel_format yuv420p 指定转换格式为 yuv420p YUV 转 H264 1$ ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264 提取 PCM 数据 12$ ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm$ ffplay -ar 44100 -ac 2 -f s16le -i out.pcm PCM 转 WAV 1$ ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav 10. 滤镜在编码之前，ffmpeg 可以使用 libavfilter 库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg 区分两种类型的过滤器图形：简单和复杂。 10.1 简单滤镜简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示： 简单的 filtergraphs 配置了 per-stream-filter 选项（分别为视频和音频使用 -vf 和 -af 别名）。 一个简单的视频 filtergraph 可以看起来像这样的例子： 请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的 fps 过滤器会改变帧数，但不会触及帧内容。 另一个例子是 setpts 过滤器，它只设置时间戳，否则不改变帧。 10.2 复杂滤镜复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示： 复杂的过滤器图使用 -filter_complex 选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。 -lavfi 选项等同于 -filter_complex。 一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是 amix 滤波器。 添加水印 1$ ffmpeg -i out.mp4 -vf \"movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]\" water.mp4 -vf 中的 movie 指定 logo 位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。 删除水印 先通过 ffplay 找到要删除 LOGO 的位置 1$ ffplay -i test.flv -vf delogo=x=806:y=20:w=70:h=80:show=1 使用 delogo 滤镜删除 LOGO 1$ ffmpeg -i test.flv -vf delogo=x=806:y=20:w=70:h=80 output.flv 视频缩小一倍 1$ ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4 -vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。 视频裁剪 1$ ffmpeg -i VR.mov -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4 crop 格式：crop=out_w:out_h:x:y out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。 out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。 x : X坐标 y : Y坐标 如果 x 和 y 设置为 0, 说明从左上角开始裁剪。如果不写是从中心点裁剪。 倍速播放 1$ ffmpeg -i out.mp4 -filter_complex \"[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]\" -map \"[v]\" -map \"[a]\" speed2.0.mp4 -filter_complex 复杂滤镜，[0:v] 表示第一个（文件索引号是 0）文件的视频作为输入。setpts=0.5*PTS 表示每帧视频的 pts 时间戳都乘 0.5 ，也就是差少一半。[v] 表示输出的别名。音频同理就不详述了。 map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。 对称视频 1$ ffmpeg -i out.mp4 -filter_complex \"[0:v]pad=w=2*iw[a];[0:v]hflip[b];[a][b]overlay=x=w\" duicheng.mp4 hflip 水平翻转 如果要修改为垂直翻转可以用 vflip。 画中画 1$ ffmpeg -i out.mp4 -i out1.mp4 -filter_complex \"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]\" -map \"[out]\" -movflags faststart new.mp4 录制画中画 12345$ ffmpeg -f avfoundation -i \"1\" -framerate 30 -f avfoundation -i \"0:0\" -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex \"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[a];[0:v][a]overlay=x=W-w-10:y=0[out]\" -map \"[out]\" -movflags faststart -map 1:a b.mp4 多路视频拼接 1$ ffmpeg -f avfoundation -i \"1\" -framerate 30 -f avfoundation -i \"0:0\" -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex \"[0:v]scale=320:240[a];[a]pad=640:240[b];[b][1:v]overlay=320:0[out]\" -map \"[out]\" -movflags faststart -map 1:a c.mp4 11. 音视频的拼接与裁剪裁剪 1$ ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4 -ss 指定裁剪的开始时间，精确到秒 -t 被裁剪后的时长。 合并 首先创建一个 inputs.txt 文件，文件内容如下： 123$ file '1.flv'$ file '2.flv'$ file '3.flv' 然后执行下面的命令： 1$ ffmpeg -f concat -i inputs.txt -c copy output.flv hls切片 1$ ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls out.m3u8 -strict -2 指明音频使有AAC。 -f hls 转成 m3u8 格式。 12. 视频图片互转视频转 JPEG 1$ ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg 视频转 gif 1$ ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif 图片转视频 1$ ffmpeg -f image2 -i image-%3d.jpeg images.mp4 13. 直播相关推流 1$ ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName 拉流保存 1$ ffmpeg -i rtmp://server/live/streamName -c copy dump.flv 转流 1$ ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream 实时推流 1$ ffmpeg -framerate 15 -f avfoundation -i \"1\" -s 1280x720 -c:v libx264 -f flv rtmp://localhost:1935/live/room 14. ffplay播放 YUV 数据 1$ ffplay -pix_fmt nv12 -s 192x144 1.yuv 播放 YUV 中的 Y 平面 1$ ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes='y' 1.yuv","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/tags/FFmpeg/"}]},{"title":"音视频核心技术","slug":"FFmpeg/音视频核心技术","date":"2019-04-30T06:14:50.000Z","updated":"2019-06-12T06:47:34.994Z","comments":true,"path":"2019/04/30/FFmpeg/音视频核心技术/","link":"","permalink":"http://miaopei.github.io/2019/04/30/FFmpeg/音视频核心技术/","excerpt":"","text":"1. 学习大纲FFmpeg 常用命令： 视频录制命令 多媒体文件的分解/复用命令 裁剪与合并命令 图片/视频互转命令 直播相关命令 各种滤镜命令 FFmpeg 基本开发： C 语言回顾 FFmpeg 核心概念与常用结构体 实战 - 多媒体文件的分解与复用 实战 - 多媒体格式的互转 实战 - 从 MP4 裁剪一段视频 作业 - 实现一个简单的小咖秀 音视频编解码实战： 实战 - H264 解码 实战 - H264 编码 实战 - 音频 AAC 解码 实战 - 音频 AAC 编码 实战 - 视频转图片 音视频渲染实战： SDL 事件处理 SDL 视频文理渲染 SDL 音频渲染 实战1 - 实现 YUV 视频播放 实战2 - YUV 视频倍数播放 实战3 - 实现 PCM 播放器 FFmpeg 开发播放器核心功能： 实战 - 实现 MP4 文件的视频播放 实战 - 实现 MP4 文件的音频播放 实战 - 实现一个初级播放器 实战 - 音视频同步 实战 - 实现播放器内核 Android 中实战 FFmpeg： 编译 Android 端可以使用的 FFmpeg Java 与 C 语言相互调用 实战 - Android 调用 FFmpeg 学习建议： 牢牢抓住音视频的处理机制，了解其本质 勤加练习，熟能生巧 待着问题去学习，事半功倍 音视频的广泛应用： 直播类：音视频会议、教育直播、娱乐/游戏直播 短视频：抖音、快手、小咖秀 网络视频：优酷、腾讯视频、爱奇艺等 音视频通话：微信、QQ、Skype等 视频监控 人工智能：人脸识别，智能音箱等，更关注算法 播放器架构： 渲染流程： FFmpeg 都能做啥： FFmpeg 是一个非常优秀的多媒体框架 FFmpeg 可以运行在 Linux、Mac、Windows 等平台上 能够解码、编码、转码、复用、解复用、过滤音视频数据 FFmpeg 下载与安装： FFMpeg 下载与安装 123$ git clone https://git.ffmpeg.org/ffmpeg.git$ config -- help$ make &amp;&amp; make install 2. FFmpeg 常用命令实战我们按使用目的可以将 FFMPEG 命令分成以下几类： 基本信息查询命令 录制 分解 / 复用 处理原始数据 滤镜 切割与合并 图／视互转 直播相关 除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。 1$ ffplay -s 2560x1600 -pix_fmt uyvy422 out.yuv 3. 初级开发内容 FFmpeg 日志的使用及目录的操作 介绍 FFmpeg 的基本概念及常用的结构体 对复用/解复用及流程操作的各种实践 FFmpeg 代码结构： libavcodec： 提供了一系列编码器的实现。 libavformat： 实现在流协议，容器格式及其本IO访问。 libavutil： 包括了hash器，解码器和各类工具函数。 libavfilter： 提供了各种音视频过滤器。 libavdevice： 提供了访问捕获设备和回放设备的接口。 libswresample： 实现了混音和重采样。 libswscale： 实现了色彩转换和缩放工能。 3.1 FFmpeg 日志系统12345#include &lt;libavutil/log.h&gt;av_log_set_level(AV_LOG_DEBUG) av_log(NULL, AV_LOG_INFO, \"...%s\\n\", op) AV_LOG_ERROR AV_LOG_WARNING AV_LOG_INFO FFmpeg日志系统使用 1234567891011#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;int main(int argc, char *argv[])&#123; av_log_set_level(AV_LOG_DEBUG); av_log(NULL, AV_LOG_INFO, \"hello world: %s!\\n\", \"aaa\"); return 0;&#125; 3.2 FFmpeg 文件与目录操作文件的删除与重命名： 12345#include &lt;libavformat/avformat.h&gt;avpriv_io_delete() avpriv_io_move(src, dst) FFmpeg文件与目录操作 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;#include &lt;libavformat/avformat.h&gt;int main(int argc, char *argv[])&#123; int ret; ret = avpriv_io_delete(\"./mytestfile.txt\"); if(ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, \"Failed to delete file mytestfile.txt\\n\"); return -1 &#125; ret = avpriv_io_move(\"111.txt\", \"222.txt\"); if(ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, \"Filed to rename\\n\"); return -1; &#125; return 0;&#125; 123456$ clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --libs libavformat`# pkg-config --libs libavformat 指令可以搜索libavformat库所在路径$ pkg-config --libs libavformat-L/usr/local/ffmpeg/lib -lavformat 3.3 FFmpeg 操作目录重要函数123avio_open_dir()avio_read_dir()avio_close_dir() 操作目录重要结构体： AVIODirContext 操作目录的上下文 AVIODirEntry 目录项。用于存放文件名，文件大小等信息 FFmpeg操作目录 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;#include &lt;libavformat/avformat.h&gt;int main(int argc, char *argv[])&#123; av_log_set_level(AV_LOG_INFO); int ret; AVIODirContext *ctx = NULL; AVIODirEntry *entry = NULL; ret = avio_open_dir(&amp;ctx, \"./\", NULL); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, \"Cant open dir:%s\\n\", av_err2str(ret)); return -1; &#125; while(1) &#123; ret = avio_read_dir(ctx, &amp;entry); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, \"Cant read dir: %s\\n\", av_err2str(ret)); goto __fail; &#125; if (!entry) &#123; break; &#125; av_log(NULL, AV_LOG_INFO, \"%l2\"PRId64\" %s\\n\", entry-&gt;size, entry-&gt;name); avio_free_directory_entry(&amp;entry); &#125;__fail: avio_close_dir(&amp;ctx); return 0;&#125; 1$ clang -g -o list ffmpeg_list.c `pkg-config --libs libavformat libavutil` 3.4 多媒体文件的基本概念 多媒体文件其实是个容器 在容器里有很多流（Stream/Track) 每种流是由不同的编码器编码的 从流中读出的数据称为包 在一个包中包含着一个或多个帧 几个重要的结构体： AVFormatContext AVStream AVPacket FFmpeg 操作流数据的基本步骤： 解复用 —&gt; 获取流 —&gt; 读取数据包 —&gt; 释放资源 3.5 [实战] 打印音/视频信息123av_register_all()avformat_open_input() / avformat_close_input()av_dump_format() [实战] 打印音/视频信息 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;#include &lt;libavformat/avformat.h&gt;int main(int argc, char *argv[])&#123; int ret; av_log_set_level(AV_LOG_INFO); AVFormatContext *fmt_ctx = NULL; av_register_all(); ret = avformat_open_input(&amp;fmt_ctx, \"./test.mp4\", NULL, NULL); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, \"Can't open file: %s\\n\", av_err2str(ret)); return -1; &#125; av_dump_format(fmt_ctx, 0, \"./test.mp4\", 0); avformat_close_input(&amp;fmt_ctx); return 0;&#125; 3.6 [实战] 抽取音频数据123av_init_packet()av_find_best_stream()av_read_frame() / av_packet_unref() [实战] 抽取音频数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;#include &lt;libavformat/avformat.h&gt;int main(int argc, char *argv[])&#123; int ret; int len; int audio_index; char *src = NULL; char *dst = NULL; av_log_set_level(AV_LOG_INFO); AVPacket pkt; AVFormatContext *fmt_ctx = NULL; av_register_all(); // 1. read two params form console if (argc &lt; 3) &#123; av_log(NULL, AV_LOG_ERROR, \"eg: %s in_file out_file\\n\", argv[0]); return -1; &#125; src = argv[1]; dst = argv[2]; if (!src || !dst) &#123; av_log(NULL, AV_LOG_ERROR, \"src or dst is null\\n\"); return -1; &#125; ret = avformat_open_input(&amp;fmt_ctx, src, NULL, NULL); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, \"Can't open file: %s\\n\", av_err2str(ret)); return -1; &#125; FILE *dst_fd = fopen(dst, \"wb\"); if (dst_fd) &#123; av_log(NULL, AV_LOG_ERROR, \"Can't open out file!\\n\"); avformat_close_input(&amp;fmt_ctx); return -1; &#125; av_dump_format(fmt_ctx, 0, src, 0); // 2. get stream ret = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, \"Can't find the best stream!\\n\"); avformat_close_input(&amp;fmt_ctx); fclose(dst_fd); return -1; &#125; audio_index = ret; av_init_packet(&amp;pkt); while(av_read_frame(fmt_ctx, &amp;pkt) &gt;= 0) &#123; if (pkt.stream_index == audio_index) &#123; // 3. write audio data to aac file. len = fwrite(pkt.data, 1, pkt.size, dst_fd); if (len != pkt.size) &#123; av_log(NULL, AV_LOG_WARNING, \"warning, length of data is not equal size of pkt!\\n\"); &#125; &#125; av_packet_unref(&amp;pkt); &#125; avformat_close_input(&amp;fmt_ctx); if (dst_fd) &#123; fclose(dst_fd); &#125; return 0;&#125; 12$ lang -g -o extra_audio extra_audio.c `pkg-config --libs libavutil libavformat`$ ./extra_audio test.mp4 killer.aa 3.7 [实战] 抽取视频数据 Start code SPS/PPS codec -&gt; extradata 3.8 [实战] 将 MP4 转成 FLV 格式123456avformat_alloc_output_context2() / avformat_free_context();avformat_new_stream();avcodec_parameters_copy();avformat_write_header();av_write_frame() / av_interleaved_write_frame();av_write_trailer() 3.9 [实战] 从 MP4 截取一段视频1av_seek_frame() 从 MP4 截取一段视频代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;stdlib.h&gt;#include &lt;libavutil/timestamp.h&gt;#include &lt;libavformat/avformat.h&gt;static void log_packet(const AVFormatContext *fmt_ctx, const AVPacket *pkt, const char *tag)&#123; AVRational *time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base; printf(\"%s: pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\\n\", tag, av_ts2str(pkt-&gt;pts), av_ts2timestr(pkt-&gt;pts, time_base), av_ts2str(pkt-&gt;dts), av_ts2timestr(pkt-&gt;dts, time_base), av_ts2str(pkt-&gt;duration), av_ts2timestr(pkt-&gt;duration, time_base), pkt-&gt;stream_index);&#125;int cut_video(double from_seconds, double end_seconds, const char* in_filename, const char* out_filename) &#123; AVOutputFormat *ofmt = NULL; AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL; AVPacket pkt; int ret, i; av_register_all(); if ((ret = avformat_open_input(&amp;ifmt_ctx, in_filename, 0, 0)) &lt; 0) &#123; fprintf(stderr, \"Could not open input file '%s'\", in_filename); goto end; &#125; if ((ret = avformat_find_stream_info(ifmt_ctx, 0)) &lt; 0) &#123; fprintf(stderr, \"Failed to retrieve input stream information\"); goto end; &#125; av_dump_format(ifmt_ctx, 0, in_filename, 0); avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, out_filename); if (!ofmt_ctx) &#123; fprintf(stderr, \"Could not create output context\\n\"); ret = AVERROR_UNKNOWN; goto end; &#125; ofmt = ofmt_ctx-&gt;oformat; for (i = 0; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123; AVStream *in_stream = ifmt_ctx-&gt;streams[i]; AVStream *out_stream = avformat_new_stream(ofmt_ctx, in_stream-&gt;codec-&gt;codec); if (!out_stream) &#123; fprintf(stderr, \"Failed allocating output stream\\n\"); ret = AVERROR_UNKNOWN; goto end; &#125; ret = avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec); if (ret &lt; 0) &#123; fprintf(stderr, \"Failed to copy context from input to output stream codec context\\n\"); goto end; &#125; out_stream-&gt;codec-&gt;codec_tag = 0; if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER) out_stream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER; &#125; av_dump_format(ofmt_ctx, 0, out_filename, 1); if (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123; ret = avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE); if (ret &lt; 0) &#123; fprintf(stderr, \"Could not open output file '%s'\", out_filename); goto end; &#125; &#125; ret = avformat_write_header(ofmt_ctx, NULL); if (ret &lt; 0) &#123; fprintf(stderr, \"Error occurred when opening output file\\n\"); goto end; &#125; // int indexs[8] = &#123;0&#125;; // int64_t start_from = 8*AV_TIME_BASE; ret = av_seek_frame(ifmt_ctx, -1, from_seconds*AV_TIME_BASE, AVSEEK_FLAG_ANY); if (ret &lt; 0) &#123; fprintf(stderr, \"Error seek\\n\"); goto end; &#125; int64_t *dts_start_from = malloc(sizeof(int64_t) * ifmt_ctx-&gt;nb_streams); memset(dts_start_from, 0, sizeof(int64_t) * ifmt_ctx-&gt;nb_streams); int64_t *pts_start_from = malloc(sizeof(int64_t) * ifmt_ctx-&gt;nb_streams); memset(pts_start_from, 0, sizeof(int64_t) * ifmt_ctx-&gt;nb_streams); while (1) &#123; AVStream *in_stream, *out_stream; ret = av_read_frame(ifmt_ctx, &amp;pkt); if (ret &lt; 0) break; in_stream = ifmt_ctx-&gt;streams[pkt.stream_index]; out_stream = ofmt_ctx-&gt;streams[pkt.stream_index]; log_packet(ifmt_ctx, &amp;pkt, \"in\"); if (av_q2d(in_stream-&gt;time_base) * pkt.pts &gt; end_seconds) &#123; av_free_packet(&amp;pkt); break; &#125; if (dts_start_from[pkt.stream_index] == 0) &#123; dts_start_from[pkt.stream_index] = pkt.dts; printf(\"dts_start_from: %s\\n\", av_ts2str(dts_start_from[pkt.stream_index])); &#125; if (pts_start_from[pkt.stream_index] == 0) &#123; pts_start_from[pkt.stream_index] = pkt.pts; printf(\"pts_start_from: %s\\n\", av_ts2str(pts_start_from[pkt.stream_index])); &#125; /* copy packet */ pkt.pts = av_rescale_q_rnd(pkt.pts - pts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX); pkt.dts = av_rescale_q_rnd(pkt.dts - dts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX); if (pkt.pts &lt; 0) &#123; pkt.pts = 0; &#125; if (pkt.dts &lt; 0) &#123; pkt.dts = 0; &#125; pkt.duration = (int)av_rescale_q((int64_t)pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base); pkt.pos = -1; log_packet(ofmt_ctx, &amp;pkt, \"out\"); printf(\"\\n\"); ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt); if (ret &lt; 0) &#123; fprintf(stderr, \"Error muxing packet\\n\"); break; &#125; av_free_packet(&amp;pkt); &#125; free(dts_start_from); free(pts_start_from); av_write_trailer(ofmt_ctx); end: avformat_close_input(&amp;ifmt_ctx); /* close output */ if (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE)) avio_closep(&amp;ofmt_ctx-&gt;pb); avformat_free_context(ofmt_ctx); if (ret &lt; 0 &amp;&amp; ret != AVERROR_EOF) &#123; fprintf(stderr, \"Error occurred: %s\\n\", av_err2str(ret)); return 1; &#125; return 0;&#125;int main(int argc, char *argv[])&#123; if(argc &lt; 5)&#123; fprintf(stderr, \"Usage: \\ command startime, endtime, srcfile, outfile\"); return -1; &#125; double startime = atoi(argv[1]); double endtime = atoi(argv[2]); cut_video(startime, endtime, argv[3], argv[4]); return 0;&#125; 3.10 [实战] 一个简单的小咖秀 将两个媒体文件中分别抽取音频与视频轨 将音频与视频轨合并成一个新文件 对音频与视频轨进行裁剪 4. FFmpeg 中级开发内容 FFmpeg H264 解码 FFmpeg H264 编码 FFmpeg AAC 解码 FFmpeg AAC 编码 4.1 FFmpeg H264 解码1#include &lt;libavcodec/avcodec.h&gt; 常用数据结构： AVCodec 编码器结构体 AVCodecContext 编码器上下文 AVFrame 解码后的帧 结构体内存的分配与释放： 123av_frame_alloc / av_frame_free();avcodec_alloc_context3();avcodec_free_context(); 解码步骤： 查找解码器（avcodec_find_decoder） 打开解码器（avcodec_open2） 解码（avcodec_decode_video2） 4.2 FFmpeg H264 编码H264编码流程： 查找编码器（avcodec_find_encoder_by_name） 设置参数，打开编码器（avcondec_open2） 编码（avcondec_encode_video2） 4.3 视频转图片TODO 4.4 FFmpeg AAC 编码 编码流程与视频相同 编码函数 avcodec_encodec_audio2 5. SDL 介绍 SDL 官网 SDL（Simple DirectMedia Layer） 是一套开放源代码的跨平台多媒体开发库 由 C 语言实现的跨平台的媒体开源库 多用于开发游戏、模拟器、媒体播放器等多媒体应用领域 语法与子系统： SDL将功能分成下列数个子系统（subsystem）： Video（图像）—图像控制以及线程（thread）和事件管理（event）。 Audio（声音）—声音控制 Joystick（摇杆）—游戏摇杆控制 CD-ROM（光盘驱动器）—光盘媒体控制 Window Management（视窗管理）－与视窗程序设计集成 Event（事件驱动）－处理事件驱动 以下是一支用C语言写成、非常简单的SDL示例： 12345678910111213141516171819// Headers#include \"SDL.h\"// Main functionint main(int argc, char* argv[])&#123; // Initialize SDL if(SDL_Init(SDL_INIT_EVERYTHING) == -1) return(1); // Delay 2 seconds SDL_Delay(2000); // Quit SDL SDL_Quit(); // Return return 0;&#125; 上述程序会加载所有SDL子系统（出错则退出程序），然后暂停两秒，最后关闭SDL并退出程序。 5.1 SDL 编译与安装 下载 SDL 源码 生成Makefile configure –prefix=/usr/local 安装 sudo make -j 8 &amp;&amp; make install 5.2 使用 SDL 基本步骤 添加头文件 #include &lt;SDL.h&gt; 初始化 SDL 退出 SDL SDL 渲染窗口： 123SDL_Init() / SDL_Quit();SDL_CreateWindow() / SDL_DestoryWindow();SDL_CreateRender(); // 创建渲染器 1$ clang -g -o first_sdl first_sdl.c `pkg-config --libs sdl2` SDL 渲染窗口： 123SDL_CreateRender() / SDL_DestoryRenderer();SDL_RenderClear();SDL_RenderPresent(); 5.3 SDL 事件基本原理 SDL 将所有的事件都存放在一个队列中 所有对事件的操作，其实就是队列的操作 SDL 事件种类： SDL_WindowEvent：窗口事件 SDL_KeyboardEvent：键盘事件 SDL_MouseMotionEvent：鼠标事件 自定义事件 SDL 事件处理： 123SDL_PollEvent(); // 轮询检测SDL_WaitEvent(); // 常用的方式SDL_WaitEventTimeout(); 5.4 文理渲染SDL 渲染基本原理： SDL 文理相关 API： 12345SDL_CreateTexture();- format: YUV, RGB- access: Texture 类型， Target， StreamSDL_DestroyTexture(); SDL 渲染相关 API： 1234SDL_SetRenderTarget();SDL_RenderClear();SDL_RenderCopy();SDL_RenderPresent(); 5.5 [实战] YUV 视频播放器创建线程： 1234SDL_CreateThread();- fn: 线程执行函数- name: 线程名- data: 执行函数参数 SDL 更新文理： 12SDL_UpdateTexture();SDL_UpdateYUVTexture(); 5.6 SDL 播放音频播放音频基本流程： 播放音频的基本原则： 声卡向你要数据而不是你主动推给声卡 数据的多少由音频参数决定的 SDL 音频 API： 123SDL_OpenAudio() / SDL_CloseAudio();SDL_PauseAudio();SDL_MixAudio(); 5.7 实现 PCM 播放器TODO 6. 最简单的播放器 该播放器只实现视频播放 将 FFmpeg 与 SDL 结合到一起 通过 FFmpeg 解码视频数据 通过 SDL 进行渲染 1$ clang -g -o player2 player2.c `pkg-config --cflags --libs sdl2 libavformat libavutil libswscale libavcodec libswresample` 最简单的播放器之二： 可以同时播放音频与视频 使用队列存放音频包 6.1 多线程与锁为什么要用多线程： 多线程的好处 多线程带来的问题 线程的互斥与同步： 互斥 同步 大的任务分为很多小任务通过信号协调 锁与信号量： 锁的种类 通过信号进行同步 锁的中种类： 读写锁 自旋锁 可重入锁 SDL 线程的创建： 12SDL_CreateThread();SDL_WaitThread(); SDL 锁： 12SDL_CreateMutex() / SDL_DestroyMutex(); // 创建互斥量SDL_LockMutex() / SDL_UnlockMutex(); // 锁互斥量于解锁互斥量 SDL 条件变量： 12SDL_CreateCond() / SDL_DestroyCond();SDL_CondWait() / SDL_CondSignal(); 6.2 锁与条件变量的使用TODO 6.3 播放器线程模型 6.4 线程的退出机制 主线程接收到退出事件 解复用线程在循环分流时对 quit 进行判断 视频解码线程从视频流队列中取包时对 quit 进行判断 音视解码从音频流队列中取包时对 quit 进行判断 音视循环解码时对 quit 进行判断 在收到信号变量消息时对 quit 进行判断 6.5 音视频同步时间戳： PTS：Presentation timestamp 渲染时间戳 DTS：Decoding timestamp 解码时间戳 I（intra）/ B（bidirectional）/ P（predicted）帧 时间戳顺序： 实际帧顺序：I B B P 存放帧顺序：I P B B 解码时间戳：1 4 2 3 展示时间戳：1 2 3 4 从哪儿获得 PTS： AVPacket 中的 PTS AVFrame 中的 PTS av_frame_get_best_effort_timestamp() 时间基： tbr：帧率 tbn：time base of stream 流的时间基 tbc：time base of codec 解码的时间基 计算当前帧的 PTS： PTS = PTS * av_q2d(video_stream-&gt;time_base) av_q2d(AVRotional a){ return a.num / (double)a.den; } 计算下一帧的 PTS： video_clock：预测的下一帧视频的 PTS frame_delay：1/tbr audio_clock：音频当前播放的时间戳 音视频同步方式： 视频同步到音频 音频同步到视频 音频和视频都同步到系统时钟 视频播放的基本思路： 一般的做法，展示第一帧视频帧后，获得要显示的下一个视频帧的 PTS，然后设置一个定时器，当定时器超时时后，刷新新的视屏帧，如此反复操作。 最简单的播放器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;math.h&gt;#include &lt;SDL.h&gt;#include &lt;libavcodec/avcodec.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libswscale/swscale.h&gt;#include &lt;libswresample/swresample.h&gt;// compatibility with newer API#if LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)#define av_frame_alloc avcodec_alloc_frame#define av_frame_free avcodec_free_frame#endif#define SDL_AUDIO_BUFFER_SIZE 1024#define MAX_AUDIO_FRAME_SIZE 192000 //channels(2) * data_size(2) * sample_rate(48000)#define MAX_AUDIOQ_SIZE (5 * 16 * 1024)#define MAX_VIDEOQ_SIZE (5 * 256 * 1024)#define AV_SYNC_THRESHOLD 0.01#define AV_NOSYNC_THRESHOLD 10.0#define SAMPLE_CORRECTION_PERCENT_MAX 10#define AUDIO_DIFF_AVG_NB 20#define FF_REFRESH_EVENT (SDL_USEREVENT)#define FF_QUIT_EVENT (SDL_USEREVENT + 1)#define VIDEO_PICTURE_QUEUE_SIZE 1#define DEFAULT_AV_SYNC_TYPE AV_SYNC_AUDIO_MASTER //AV_SYNC_VIDEO_MASTERtypedef struct PacketQueue &#123; AVPacketList *first_pkt, *last_pkt; int nb_packets; int size; SDL_mutex *mutex; SDL_cond *cond;&#125; PacketQueue;typedef struct VideoPicture &#123; AVPicture *bmp; int width, height; /* source height &amp; width */ int allocated; double pts;&#125; VideoPicture;typedef struct VideoState &#123; //multi-media file char filename[1024]; AVFormatContext *pFormatCtx; int videoStream, audioStream; //sync int av_sync_type; double external_clock; /* external clock base */ int64_t external_clock_time; double audio_diff_cum; /* used for AV difference average computation */ double audio_diff_avg_coef; double audio_diff_threshold; int audio_diff_avg_count; double audio_clock; double frame_timer; double frame_last_pts; double frame_last_delay; double video_clock; ///&lt;pts of last decoded frame / predicted pts of next decoded frame double video_current_pts; ///&lt;current displayed pts (different from video_clock if frame fifos are used) int64_t video_current_pts_time; ///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts //audio AVStream *audio_st; AVCodecContext *audio_ctx; PacketQueue audioq; uint8_t audio_buf[(MAX_AUDIO_FRAME_SIZE * 3) / 2]; unsigned int audio_buf_size; unsigned int audio_buf_index; AVFrame audio_frame; AVPacket audio_pkt; uint8_t *audio_pkt_data; int audio_pkt_size; int audio_hw_buf_size; //video AVStream *video_st; AVCodecContext *video_ctx; PacketQueue videoq; struct SwsContext *video_sws_ctx; struct SwrContext *audio_swr_ctx; VideoPicture pictq[VIDEO_PICTURE_QUEUE_SIZE]; int pictq_size, pictq_rindex, pictq_windex; SDL_mutex *pictq_mutex; SDL_cond *pictq_cond; SDL_Thread *parse_tid; SDL_Thread *video_tid; int quit;&#125; VideoState;SDL_mutex *text_mutex;SDL_Window *win = NULL;SDL_Renderer *renderer;SDL_Texture *texture;enum &#123; AV_SYNC_AUDIO_MASTER, AV_SYNC_VIDEO_MASTER, AV_SYNC_EXTERNAL_MASTER,&#125;;FILE *yuvfd = NULL;FILE *audiofd = NULL;/* Since we only have one decoding thread, the Big Struct can be global in case we need it. */VideoState *global_video_state;void packet_queue_init(PacketQueue *q) &#123; memset(q, 0, sizeof(PacketQueue)); q-&gt;mutex = SDL_CreateMutex(); q-&gt;cond = SDL_CreateCond();&#125;int packet_queue_put(PacketQueue *q, AVPacket *pkt) &#123; AVPacketList *pkt1; if(av_dup_packet(pkt) &lt; 0) &#123; return -1; &#125; pkt1 = av_malloc(sizeof(AVPacketList)); if (!pkt1) return -1; pkt1-&gt;pkt = *pkt; pkt1-&gt;next = NULL; SDL_LockMutex(q-&gt;mutex); if (!q-&gt;last_pkt) q-&gt;first_pkt = pkt1; else q-&gt;last_pkt-&gt;next = pkt1; q-&gt;last_pkt = pkt1; q-&gt;nb_packets++; q-&gt;size += pkt1-&gt;pkt.size; SDL_CondSignal(q-&gt;cond); SDL_UnlockMutex(q-&gt;mutex); return 0;&#125;int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block)&#123; AVPacketList *pkt1; int ret; SDL_LockMutex(q-&gt;mutex); for(;;) &#123; if(global_video_state-&gt;quit) &#123; ret = -1; break; &#125; pkt1 = q-&gt;first_pkt; if (pkt1) &#123; q-&gt;first_pkt = pkt1-&gt;next; if (!q-&gt;first_pkt) q-&gt;last_pkt = NULL; q-&gt;nb_packets--; q-&gt;size -= pkt1-&gt;pkt.size; *pkt = pkt1-&gt;pkt; av_free(pkt1); ret = 1; break; &#125; else if (!block) &#123; ret = 0; break; &#125; else &#123; SDL_CondWait(q-&gt;cond, q-&gt;mutex); &#125; &#125; SDL_UnlockMutex(q-&gt;mutex); return ret;&#125;double get_audio_clock(VideoState *is) &#123; double pts; int hw_buf_size, bytes_per_sec, n; pts = is-&gt;audio_clock; /* maintained in the audio thread */ hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index; bytes_per_sec = 0; n = is-&gt;audio_ctx-&gt;channels * 2; if(is-&gt;audio_st) &#123; bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n; &#125; if(bytes_per_sec) &#123; pts -= (double)hw_buf_size / bytes_per_sec; &#125; return pts;&#125;double get_video_clock(VideoState *is) &#123; double delta; delta = (av_gettime() - is-&gt;video_current_pts_time) / 1000000.0; return is-&gt;video_current_pts + delta;&#125;double get_external_clock(VideoState *is) &#123; return av_gettime() / 1000000.0;&#125;double get_master_clock(VideoState *is) &#123; if(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) &#123; return get_video_clock(is); &#125; else if(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) &#123; return get_audio_clock(is); &#125; else &#123; return get_external_clock(is); &#125;&#125;/* Add or subtract samples to get a better sync, return new audio buffer size */int synchronize_audio(VideoState *is, short *samples, int samples_size, double pts) &#123; int n; double ref_clock; n = 2 * is-&gt;audio_ctx-&gt;channels; if(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) &#123; double diff, avg_diff; int wanted_size, min_size, max_size /*, nb_samples */; ref_clock = get_master_clock(is); diff = get_audio_clock(is) - ref_clock; if(diff &lt; AV_NOSYNC_THRESHOLD) &#123; // accumulate the diffs is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef * is-&gt;audio_diff_cum; if(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) &#123; is-&gt;audio_diff_avg_count++; &#125; else &#123; avg_diff = is-&gt;audio_diff_cum * (1.0 - is-&gt;audio_diff_avg_coef); if(fabs(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123; wanted_size = samples_size + ((int)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n); min_size = samples_size * ((100 - SAMPLE_CORRECTION_PERCENT_MAX) / 100); max_size = samples_size * ((100 + SAMPLE_CORRECTION_PERCENT_MAX) / 100); if(wanted_size &lt; min_size) &#123; wanted_size = min_size; &#125; else if (wanted_size &gt; max_size) &#123; wanted_size = max_size; &#125; if(wanted_size &lt; samples_size) &#123; /* remove samples */ samples_size = wanted_size; &#125; else if(wanted_size &gt; samples_size) &#123; uint8_t *samples_end, *q; int nb; /* add samples by copying final sample*/ nb = (samples_size - wanted_size); samples_end = (uint8_t *)samples + samples_size - n; q = samples_end + n; while(nb &gt; 0) &#123; memcpy(q, samples_end, n); q += n; nb -= n; &#125; samples_size = wanted_size; &#125; &#125; &#125; &#125; else &#123; /* difference is TOO big; reset diff stuff */ is-&gt;audio_diff_avg_count = 0; is-&gt;audio_diff_cum = 0; &#125; &#125; return samples_size;&#125;int audio_decode_frame(VideoState *is, uint8_t *audio_buf, int buf_size, double *pts_ptr) &#123; int len1, data_size = 0; AVPacket *pkt = &amp;is-&gt;audio_pkt; double pts; int n; for(;;) &#123; while(is-&gt;audio_pkt_size &gt; 0) &#123; int got_frame = 0; len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt); if(len1 &lt; 0) &#123; /* if error, skip frame */ is-&gt;audio_pkt_size = 0; break; &#125; data_size = 0; if(got_frame) &#123; /* data_size = av_samples_get_buffer_size(NULL, is-&gt;audio_ctx-&gt;channels, is-&gt;audio_frame.nb_samples, is-&gt;audio_ctx-&gt;sample_fmt, 1); */ data_size = 2 * is-&gt;audio_frame.nb_samples * 2; assert(data_size &lt;= buf_size); swr_convert(is-&gt;audio_swr_ctx, &amp;audio_buf, MAX_AUDIO_FRAME_SIZE*3/2, (const uint8_t **)is-&gt;audio_frame.data, is-&gt;audio_frame.nb_samples); fwrite(audio_buf, 1, data_size, audiofd); //memcpy(audio_buf, is-&gt;audio_frame.data[0], data_size); &#125; is-&gt;audio_pkt_data += len1; is-&gt;audio_pkt_size -= len1; if(data_size &lt;= 0) &#123; /* No data yet, get more frames */ continue; &#125; pts = is-&gt;audio_clock; *pts_ptr = pts; n = 2 * is-&gt;audio_ctx-&gt;channels; is-&gt;audio_clock += (double)data_size / (double)(n * is-&gt;audio_ctx-&gt;sample_rate); /* We have data, return it and come back for more later */ return data_size; &#125; if(pkt-&gt;data) av_free_packet(pkt); if(is-&gt;quit) &#123; return -1; &#125; /* next packet */ if(packet_queue_get(&amp;is-&gt;audioq, pkt, 1) &lt; 0) &#123; return -1; &#125; is-&gt;audio_pkt_data = pkt-&gt;data; is-&gt;audio_pkt_size = pkt-&gt;size; /* if update, update the audio clock w/pts */ if(pkt-&gt;pts != AV_NOPTS_VALUE) &#123; is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts; &#125; &#125;&#125;void audio_callback(void *userdata, Uint8 *stream, int len) &#123; VideoState *is = (VideoState *)userdata; int len1, audio_size; double pts; SDL_memset(stream, 0, len); while(len &gt; 0) &#123; if(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123; /* We have already sent all our data; get more */ audio_size = audio_decode_frame(is, is-&gt;audio_buf, sizeof(is-&gt;audio_buf), &amp;pts); if(audio_size &lt; 0) &#123; /* If error, output silence */ is-&gt;audio_buf_size = 1024 * 2 * 2; memset(is-&gt;audio_buf, 0, is-&gt;audio_buf_size); &#125; else &#123; audio_size = synchronize_audio(is, (int16_t *)is-&gt;audio_buf, audio_size, pts); is-&gt;audio_buf_size = audio_size; &#125; is-&gt;audio_buf_index = 0; &#125; len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index; if(len1 &gt; len) len1 = len; SDL_MixAudio(stream,(uint8_t *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME); //memcpy(stream, (uint8_t *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1); len -= len1; stream += len1; is-&gt;audio_buf_index += len1; &#125;&#125;static Uint32 sdl_refresh_timer_cb(Uint32 interval, void *opaque) &#123; SDL_Event event; event.type = FF_REFRESH_EVENT; event.user.data1 = opaque; SDL_PushEvent(&amp;event); return 0; /* 0 means stop timer */&#125;/* schedule a video refresh in 'delay' ms */static void schedule_refresh(VideoState *is, int delay) &#123; SDL_AddTimer(delay, sdl_refresh_timer_cb, is);&#125;void video_display(VideoState *is) &#123; SDL_Rect rect; VideoPicture *vp; float aspect_ratio; int w, h, x, y; int i; vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex]; if(vp-&gt;bmp) &#123; SDL_UpdateYUVTexture(texture, NULL, vp-&gt;bmp-&gt;data[0], vp-&gt;bmp-&gt;linesize[0], vp-&gt;bmp-&gt;data[1], vp-&gt;bmp-&gt;linesize[1], vp-&gt;bmp-&gt;data[2], vp-&gt;bmp-&gt;linesize[2]); rect.x = 0; rect.y = 0; rect.w = is-&gt;video_ctx-&gt;width; rect.h = is-&gt;video_ctx-&gt;height; SDL_LockMutex(text_mutex); SDL_RenderClear( renderer ); SDL_RenderCopy( renderer, texture, NULL, &amp;rect); SDL_RenderPresent( renderer ); SDL_UnlockMutex(text_mutex); &#125;&#125;void video_refresh_timer(void *userdata) &#123; VideoState *is = (VideoState *)userdata; VideoPicture *vp; double actual_delay, delay, sync_threshold, ref_clock, diff; if(is-&gt;video_st) &#123; if(is-&gt;pictq_size == 0) &#123; schedule_refresh(is, 1); //fprintf(stderr, \"no picture in the queue!!!\\n\"); &#125; else &#123; //fprintf(stderr, \"get picture from queue!!!\\n\"); vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex]; is-&gt;video_current_pts = vp-&gt;pts; is-&gt;video_current_pts_time = av_gettime(); delay = vp-&gt;pts - is-&gt;frame_last_pts; /* the pts from last time */ if(delay &lt;= 0 || delay &gt;= 1.0) &#123; /* if incorrect delay, use previous one */ delay = is-&gt;frame_last_delay; &#125; /* save for next time */ is-&gt;frame_last_delay = delay; is-&gt;frame_last_pts = vp-&gt;pts; /* update delay to sync to audio if not master source */ if(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) &#123; ref_clock = get_master_clock(is); diff = vp-&gt;pts - ref_clock; /* Skip or repeat the frame. Take delay into account FFPlay still doesn't \"know if this is the best guess.\" */ sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD; if(fabs(diff) &lt; AV_NOSYNC_THRESHOLD) &#123; if(diff &lt;= -sync_threshold) &#123; delay = 0; &#125; else if(diff &gt;= sync_threshold) &#123; delay = 2 * delay; &#125; &#125; &#125; is-&gt;frame_timer += delay; /* computer the REAL delay */ actual_delay = is-&gt;frame_timer - (av_gettime() / 1000000.0); if(actual_delay &lt; 0.010) &#123; /* Really it should skip the picture instead */ actual_delay = 0.010; &#125; schedule_refresh(is, (int)(actual_delay * 1000 + 0.5)); /* show the picture! */ video_display(is); /* update queue for next picture! */ if(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123; is-&gt;pictq_rindex = 0; &#125; SDL_LockMutex(is-&gt;pictq_mutex); is-&gt;pictq_size--; SDL_CondSignal(is-&gt;pictq_cond); SDL_UnlockMutex(is-&gt;pictq_mutex); &#125; &#125; else &#123; schedule_refresh(is, 100); &#125;&#125; void alloc_picture(void *userdata) &#123; int ret; VideoState *is = (VideoState *)userdata; VideoPicture *vp; vp = &amp;is-&gt;pictq[is-&gt;pictq_windex]; if(vp-&gt;bmp) &#123; // we already have one make another, bigger/smaller avpicture_free(vp-&gt;bmp); free(vp-&gt;bmp); vp-&gt;bmp = NULL; &#125; // Allocate a place to put our YUV image on that screen SDL_LockMutex(text_mutex); vp-&gt;bmp = (AVPicture*)malloc(sizeof(AVPicture)); ret = avpicture_alloc(vp-&gt;bmp, AV_PIX_FMT_YUV420P, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height); if (ret &lt; 0) &#123; fprintf(stderr, \"Could not allocate temporary picture: %s\\n\", av_err2str(ret)); &#125; SDL_UnlockMutex(text_mutex); vp-&gt;width = is-&gt;video_ctx-&gt;width; vp-&gt;height = is-&gt;video_ctx-&gt;height; vp-&gt;allocated = 1;&#125;int queue_picture(VideoState *is, AVFrame *pFrame, double pts) &#123; VideoPicture *vp; /* wait until we have space for a new pic */ SDL_LockMutex(is-&gt;pictq_mutex); while(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp; !is-&gt;quit) &#123; SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex); &#125; SDL_UnlockMutex(is-&gt;pictq_mutex); if(is-&gt;quit) return -1; // windex is set to 0 initially vp = &amp;is-&gt;pictq[is-&gt;pictq_windex]; /* allocate or resize the buffer! */ if(!vp-&gt;bmp || vp-&gt;width != is-&gt;video_ctx-&gt;width || vp-&gt;height != is-&gt;video_ctx-&gt;height) &#123; vp-&gt;allocated = 0; alloc_picture(is); if(is-&gt;quit) &#123; return -1; &#125; &#125; /* We have a place to put our picture on the queue */ if(vp-&gt;bmp) &#123; vp-&gt;pts = pts; // Convert the image into YUV format that SDL uses sws_scale(is-&gt;video_sws_ctx, (uint8_t const * const *)pFrame-&gt;data, pFrame-&gt;linesize, 0, is-&gt;video_ctx-&gt;height, vp-&gt;bmp-&gt;data, vp-&gt;bmp-&gt;linesize); /* now we inform our display thread that we have a pic ready */ if(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) &#123; is-&gt;pictq_windex = 0; &#125; SDL_LockMutex(is-&gt;pictq_mutex); is-&gt;pictq_size++; SDL_UnlockMutex(is-&gt;pictq_mutex); &#125; return 0;&#125;double synchronize_video(VideoState *is, AVFrame *src_frame, double pts) &#123; double frame_delay; if(pts != 0) &#123; /* if we have pts, set video clock to it */ is-&gt;video_clock = pts; &#125; else &#123; /* if we aren't given a pts, set it to the clock */ pts = is-&gt;video_clock; &#125; /* update the video clock */ frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base); /* if we are repeating a frame, adjust clock accordingly */ frame_delay += src_frame-&gt;repeat_pict * (frame_delay * 0.5); is-&gt;video_clock += frame_delay; return pts;&#125;int decode_video_thread(void *arg) &#123; VideoState *is = (VideoState *)arg; AVPacket pkt1, *packet = &amp;pkt1; int frameFinished; AVFrame *pFrame; double pts; pFrame = av_frame_alloc(); for(;;) &#123; if(packet_queue_get(&amp;is-&gt;videoq, packet, 1) &lt; 0) &#123; // means we quit getting packets break; &#125; pts = 0; // Decode video frame avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet); if((pts = av_frame_get_best_effort_timestamp(pFrame)) != AV_NOPTS_VALUE) &#123; &#125; else &#123; pts = 0; &#125; pts *= av_q2d(is-&gt;video_st-&gt;time_base); // Did we get a video frame? if(frameFinished) &#123; pts = synchronize_video(is, pFrame, pts); if(queue_picture(is, pFrame, pts) &lt; 0) &#123; break; &#125; &#125; av_free_packet(packet); &#125; av_frame_free(&amp;pFrame); return 0;&#125;int stream_component_open(VideoState *is, int stream_index) &#123; AVFormatContext *pFormatCtx = is-&gt;pFormatCtx; AVCodecContext *codecCtx = NULL; AVCodec *codec = NULL; SDL_AudioSpec wanted_spec, spec; if(stream_index &lt; 0 || stream_index &gt;= pFormatCtx-&gt;nb_streams) &#123; return -1; &#125; codecCtx = avcodec_alloc_context3(NULL); int ret = avcodec_parameters_to_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codecpar); if (ret &lt; 0) return -1; codec = avcodec_find_decoder(codecCtx-&gt;codec_id); if(!codec) &#123; fprintf(stderr, \"Unsupported codec!\\n\"); return -1; &#125; if(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123; // Set audio settings from codec info wanted_spec.freq = codecCtx-&gt;sample_rate; wanted_spec.format = AUDIO_S16SYS; wanted_spec.channels = 2;//codecCtx-&gt;channels; wanted_spec.silence = 0; wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE; wanted_spec.callback = audio_callback; wanted_spec.userdata = is; fprintf(stderr, \"wanted spec: channels:%d, sample_fmt:%d, sample_rate:%d \\n\", 2, AUDIO_S16SYS, codecCtx-&gt;sample_rate); if(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; 0) &#123; fprintf(stderr, \"SDL_OpenAudio: %s\\n\", SDL_GetError()); return -1; &#125; is-&gt;audio_hw_buf_size = spec.size; &#125; if(avcodec_open2(codecCtx, codec, NULL) &lt; 0) &#123; fprintf(stderr, \"Unsupported codec!\\n\"); return -1; &#125; switch(codecCtx-&gt;codec_type) &#123; case AVMEDIA_TYPE_AUDIO: is-&gt;audioStream = stream_index; is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index]; is-&gt;audio_ctx = codecCtx; is-&gt;audio_buf_size = 0; is-&gt;audio_buf_index = 0; memset(&amp;is-&gt;audio_pkt, 0, sizeof(is-&gt;audio_pkt)); packet_queue_init(&amp;is-&gt;audioq); //Out Audio Param uint64_t out_channel_layout=AV_CH_LAYOUT_STEREO; //AAC:1024 MP3:1152 int out_nb_samples= is-&gt;audio_ctx-&gt;frame_size; //AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16; int out_sample_rate=is-&gt;audio_ctx-&gt;sample_rate; int out_channels=av_get_channel_layout_nb_channels(out_channel_layout); //Out Buffer Size /* int out_buffer_size=av_samples_get_buffer_size(NULL, out_channels, out_nb_samples, AV_SAMPLE_FMT_S16, 1); */ //uint8_t *out_buffer=(uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE*2); int64_t in_channel_layout=av_get_default_channel_layout(is-&gt;audio_ctx-&gt;channels); struct SwrContext *audio_convert_ctx; audio_convert_ctx = swr_alloc(); swr_alloc_set_opts(audio_convert_ctx, out_channel_layout, AV_SAMPLE_FMT_S16, out_sample_rate, in_channel_layout, is-&gt;audio_ctx-&gt;sample_fmt, is-&gt;audio_ctx-&gt;sample_rate, 0, NULL); fprintf(stderr, \"swr opts: out_channel_layout:%lld, out_sample_fmt:%d, out_sample_rate:%d, in_channel_layout:%lld, in_sample_fmt:%d, in_sample_rate:%d\", out_channel_layout, AV_SAMPLE_FMT_S16, out_sample_rate, in_channel_layout, is-&gt;audio_ctx-&gt;sample_fmt, is-&gt;audio_ctx-&gt;sample_rate); swr_init(audio_convert_ctx); is-&gt;audio_swr_ctx = audio_convert_ctx; SDL_PauseAudio(0); break; case AVMEDIA_TYPE_VIDEO: is-&gt;videoStream = stream_index; is-&gt;video_st = pFormatCtx-&gt;streams[stream_index]; is-&gt;video_ctx = codecCtx; is-&gt;frame_timer = (double)av_gettime() / 1000000.0; is-&gt;frame_last_delay = 40e-3; is-&gt;video_current_pts_time = av_gettime(); packet_queue_init(&amp;is-&gt;videoq); is-&gt;video_sws_ctx = sws_getContext( is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height, is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BILINEAR, NULL, NULL, NULL); is-&gt;video_tid = SDL_CreateThread(decode_video_thread, \"decode_video_thread\", is); break; default: break; &#125;&#125;int demux_thread(void *arg) &#123; int err_code; char errors[1024] = &#123;0,&#125;; VideoState *is = (VideoState *)arg; AVFormatContext *pFormatCtx; AVPacket pkt1, *packet = &amp;pkt1; int video_index = -1; int audio_index = -1; int i; is-&gt;videoStream=-1; is-&gt;audioStream=-1; global_video_state = is; /* open input file, and allocate format context */ if ((err_code=avformat_open_input(&amp;pFormatCtx, is-&gt;filename, NULL, NULL)) &lt; 0) &#123; av_strerror(err_code, errors, 1024); fprintf(stderr, \"Could not open source file %s, %d(%s)\\n\", is-&gt;filename, err_code, errors); return -1; &#125; is-&gt;pFormatCtx = pFormatCtx; // Retrieve stream information if(avformat_find_stream_info(pFormatCtx, NULL)&lt;0) return -1; // Couldn't find stream information // Dump information about file onto standard error av_dump_format(pFormatCtx, 0, is-&gt;filename, 0); // Find the first video stream for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++) &#123; if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp; video_index &lt; 0) &#123; video_index=i; &#125; if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp; audio_index &lt; 0) &#123; audio_index=i; &#125; &#125; if(audio_index &gt;= 0) &#123; stream_component_open(is, audio_index); &#125; if(video_index &gt;= 0) &#123; stream_component_open(is, video_index); &#125; if(is-&gt;videoStream &lt; 0 || is-&gt;audioStream &lt; 0) &#123; fprintf(stderr, \"%s: could not open codecs\\n\", is-&gt;filename); goto fail; &#125; //creat window from SDL win = SDL_CreateWindow(\"Media Player\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height, SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE); if(!win) &#123; fprintf(stderr, \"SDL: could not set video mode - exiting\\n\"); exit(1); &#125; renderer = SDL_CreateRenderer(win, -1, 0); //IYUV: Y + U + V (3 planes) //YV12: Y + V + U (3 planes) Uint32 pixformat= SDL_PIXELFORMAT_IYUV; //create texture for render texture = SDL_CreateTexture(renderer, pixformat, SDL_TEXTUREACCESS_STREAMING, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height); // main decode loop for(;;) &#123; if(is-&gt;quit) &#123; break; &#125; // seek stuff goes here if(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE || is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) &#123; SDL_Delay(10); continue; &#125; if(av_read_frame(is-&gt;pFormatCtx, packet) &lt; 0) &#123; if(is-&gt;pFormatCtx-&gt;pb-&gt;error == 0) &#123; SDL_Delay(100); /* no error; wait for user input */ continue; &#125; else &#123; break; &#125; &#125; // Is this a packet from the video stream? if(packet-&gt;stream_index == is-&gt;videoStream) &#123; packet_queue_put(&amp;is-&gt;videoq, packet); &#125; else if(packet-&gt;stream_index == is-&gt;audioStream) &#123; packet_queue_put(&amp;is-&gt;audioq, packet); &#125; else &#123; av_free_packet(packet); &#125; &#125; /* all done - wait for it */ while(!is-&gt;quit) &#123; SDL_Delay(100); &#125;fail: if(1)&#123; SDL_Event event; event.type = FF_QUIT_EVENT; event.user.data1 = is; SDL_PushEvent(&amp;event); &#125; return 0;&#125;int main(int argc, char *argv[]) &#123; SDL_Event event; VideoState *is; is = av_mallocz(sizeof(VideoState)); if(argc &lt; 2) &#123; fprintf(stderr, \"Usage: test &lt;file&gt;\\n\"); exit(1); &#125; yuvfd = fopen(\"testout.yuv\", \"wb+\"); audiofd = fopen(\"testout.pcm\", \"wb+\"); // Register all formats and codecs av_register_all(); if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123; fprintf(stderr, \"Could not initialize SDL - %s\\n\", SDL_GetError()); exit(1); &#125; text_mutex = SDL_CreateMutex(); av_strlcpy(is-&gt;filename, argv[1], sizeof(is-&gt;filename)); is-&gt;pictq_mutex = SDL_CreateMutex(); is-&gt;pictq_cond = SDL_CreateCond(); schedule_refresh(is, 40); is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE; is-&gt;parse_tid = SDL_CreateThread(demux_thread,\"demux_thread\", is); if(!is-&gt;parse_tid) &#123; av_free(is); return -1; &#125; for(;;) &#123; SDL_WaitEvent(&amp;event); switch(event.type) &#123; case FF_QUIT_EVENT: case SDL_QUIT: is-&gt;quit = 1; SDL_Quit(); return 0; break; case FF_REFRESH_EVENT: video_refresh_timer(event.user.data1); break; default: break; &#125; &#125; fclose(yuvfd); fclose(audiofd); return 0;&#125; 7. 如何在 Android 下使用 FFmpegAndroid 架构： 内容： Java 与 C 之间的相互调用 Android 下 FFmpeg 的编译 Android 下如何使用FFmpeg 第一个 JNI 程序： TODO JNI 基本概念： JNIEnv JavaVM 一个Android APP只有一个 JavaVM， 一个 JavaVM 可以有多个JNIEnv 线程 一个线程对应一个JNIEnv Java调用C/C++ 方法一： 在Java层定义 native 关键字函数 方法一：在C/C++层创建 Java_packname_classname_methodname 函数 Java调用C/C++方法二： 什么是Signature： Java与C/C++ 相互调用时，表式函数参数的描述符 输入参数放在（）内，输出参数放在（）外 多个参数之间顺序存放，且用 “；” 分割 C/C++ 调用 Java 方法： FindClass GetMethodID / GetFieldID NewObject Call&lt;TYPE&gt;Method / [G/S]et&lt;type&gt;Field 7.1 [实战] Android 下的播放器TODO 8. IOS 下使用 FFmpegTODO 9. 音视频进阶 FFmpeg Filter 的使用 FFmpeg 裁剪与优化 视频渲染（OpenGL / Metal） 声音的特效 网络传输 Webrtc - 实时互动、直播、P2P音视频传输 AR技术 OpenCV 行业痛点： 回音消除 降噪 视频秒开 多人多视频实时互动 PC端/APP/网页实时视频互通 实时互动与大并发负载 FFmpeg音视频同步原理与实现 音视频同步解决方案 一种基于FFMPEG的音视频同步算法 音视频同步原理如果简单的按照音频的采样率与视频的帧率去播放，由于机器运行速度，解码效率等种种造成时间差异的因素影响，很难同步，音视频时间差将会呈现线性增长。所以要做音视频的同步，有三种方式： 参考一个外部时钟，将音频与视频同步至此时间。我首先想到这种方式，但是并不好，由于某些生物学的原理，人对声音的变化比较敏感，但是对视觉变化不太敏感。所以频繁的去调整声音的播放会有些刺耳或者杂音吧影响用户体验。（ps：顺便科普生物学知识，自我感觉好高大上_）。 以视频为基准，音频去同步视频的时间。不采用，理由同上。 以音频为基准，视频去同步音频的时间。 所以这个办法了。 所以，原理就是以音频时间为基准，判断视频快了还是慢了，从而调整视频速度。其实是一个动态的追赶与等待的过程。 一些概念音视频中都有 DTS 与 PTS。 DTS ，Decoding Time Stamp，解码时间戳，告诉解码器packet的解码顺序。 PTS ，Presentation Time Stamp，显示时间戳，指示从packet中解码出来的数据的显示顺序。 音频中二者是相同的，但是视频由于B帧（双向预测）的存在，会造成解码顺序与显示顺序并不相同，也就是视频中 DTS 与 PTS 不一定相同。 时间基 : 看 FFmpeg 源码 12345678AVRational time_base;/*** rational number numerator/denominator*/typedef struct AVRational&#123; int num; ///&lt; numerator int den; ///&lt; denominator&#125; AVRational; 个人理解，其实就是 ffmpeg中 的用分数表示时间单位，num 为分子，den 为分母。并且 ffmpeg 提供了计算方法： 12345678/*** Convert rational to double.* @param a rational to convert* @return (double) a*/static inline double av_q2d(AVRational a)&#123; return a.num / (double) a.den;&#125; 所以 视频中某帧的显示时间 计算方式为(单位为妙)： 1time = pts * av_q2d(time_base); 同步代码音频部分 clock 为音频的播放时长（从开始到当前的时间） 123if (packet-&gt;pts != AV_NOPTS_VALUE) &#123; audio-&gt;clock = av_q2d(audio-&gt;time_base) * packet-&gt;pts;&#125; 然后加上此 packet 中数据需要播放的时间 12double time = datalen/((double) 44100 *2 * 2);audio-&gt;clock = audio-&gt;clock +time; datalen 为数据长度。采样率为 44100，采样位数为 16，通道数为 2。所以 数据长度 / 每秒字节数。 ps：此处计算方式不是很完美，有很多问题，回头研究在再补上。 视频部分 先定义几个值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263double last_play //上一帧的播放时间 ,play //当前帧的播放时间 , last_delay // 上一次播放视频的两帧视频间隔时间 ,delay //两帧视频间隔时间 ,audio_clock //音频轨道 实际播放时间 ,diff //音频帧与视频帧相差时间 ,sync_threshold //合理的范围 ,start_time //从第一帧开始的绝对时间 ,pts ,actual_delay//真正需要延迟时间 start_time = av_gettime() / 1000000.0;// 获取pts if ((pts = av_frame_get_best_effort_timestamp(frame)) == AV_NOPTS_VALUE) &#123; pts = 0; &#125; play = pts * av_q2d(vedio-&gt;time_base);// 纠正时间 play = vedio-&gt;synchronize(frame, play); delay = play - last_play; if (delay &lt;= 0 || delay &gt; 1) &#123; delay = last_delay; &#125; audio_clock = vedio-&gt;audio-&gt;clock; last_delay = delay; last_play = play;//音频与视频的时间差 diff = vedio-&gt;clock - audio_clock;// 在合理范围外 才会延迟 加快 sync_threshold = (delay &gt; 0.01 ? 0.01 : delay); if (fabs(diff) &lt; 10) &#123; if (diff &lt;= -sync_threshold) &#123; delay = 0; &#125; else if (diff &gt;= sync_threshold) &#123; delay = 2 * delay; &#125; &#125; start_time += delay; actual_delay = start_time - av_gettime() / 1000000.0; if (actual_delay &lt; 0.01) &#123; actual_delay = 0.01; &#125;// 休眠时间 ffmpeg 建议这样写 为什么 要这样写 有待研究 av_usleep(actual_delay * 1000000.0 + 6000);纠正play （播放时间）的方法 repeat_pict / (2 * fps) 是ffmpeg注释里教的synchronize(AVFrame *frame, double play) &#123; //clock是当前播放的时间位置 if (play != 0) clock=play; else //pst为0 则先把pts设为上一帧时间 play = clock; //可能有pts为0 则主动增加clock //需要求出扩展延时： double repeat_pict = frame-&gt;repeat_pict; //使用AvCodecContext的而不是stream的 double frame_delay = av_q2d(codec-&gt;time_base); //fps double fps = 1 / frame_delay; //pts 加上 这个延迟 是显示时间 double extra_delay = repeat_pict / (2 * fps); double delay = extra_delay + frame_delay; clock += delay; return play;&#125; FFmpeg 痛点解决回音消除解决方案： 语音自适应回声消除（AEC）算法 回声消除(AEC)原理 音频降噪在 58 直播中的研究与实现 视频秒开： 直播视频秒开及视频优化 视频直播秒开背后的技术与优化经验 短视频“秒播”那点事 百度LSS 音视频直播 秒开 播放器的“妥协”造就了视频“秒开”的实现！ 多人视频实时互动： WebRTC现状以及多人视频通话分析 多人视频连麦——直播高效互动方式 实时互动与大并发负载： RTP直播分发服务器集群方案 海量用户实时互动直播架构探索 直播开发过程中关于直播技术的架构问题","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/tags/FFmpeg/"}]},{"title":"音视频入门知识","slug":"FFmpeg/移动端音视频入门","date":"2019-04-23T02:14:50.000Z","updated":"2019-06-13T02:01:37.274Z","comments":true,"path":"2019/04/23/FFmpeg/移动端音视频入门/","link":"","permalink":"http://miaopei.github.io/2019/04/23/FFmpeg/移动端音视频入门/","excerpt":"H264基本原理 1. 万人直播架构讲解直播产品的种类： 泛娱乐化直播 花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播 实时互动直播 音视频会议、教育直播等，像 思科、全时、声网","text":"H264基本原理 1. 万人直播架构讲解直播产品的种类： 泛娱乐化直播 花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播 实时互动直播 音视频会议、教育直播等，像 思科、全时、声网 泛娱乐化直播架构 信令服务器：创建房间、聊天、礼物。。。。 美女主播 –信令–&gt; 信令服务器 信令服务器–rtmp流地址–&gt;美女主播 美女主播 –推流–&gt; 流媒体云CDN 观众 –信令–&gt; 信令服务器：将观众加入到美女主播间 信令服务器–rmtp流地址–&gt; 观众 观众 &lt;–拉流–&gt; 流媒体云CDN 泛娱乐化直播架构 基于TCP协议实现 发送信令到信令服务器, 服务器收到\\执行后, 返回给共享端一个流媒体云的地址 共享端采集自己音视频数据, 形成rtmp流, 推送到CDN网络(推流) 获取流媒体云地址 拉流 实时互动直播架构 基于UDP实现 自有网络: UDP没有自有网络, 需自己搭建 多个节点: 为了保障服务的稳定性以及负载均衡 控制中心: 每个节点定期(心跳)向控制中心报告健康程度, 控制中心根据响应的数据做出决策 内总线: 数据安全性\\吞吐量等可靠性得以保障 媒体服务器: 将RTP协议的数据转换成RTMP协议的数据 CDN网络: 根据用户需求进行拉流 2. CDN网络介绍 CDN网络是为了解决什么问题而出现的？ 总结为一句话：CDN网络是为了解决用户访问网络资源慢而出现的一个技术，两个原因： 网络链路太长 人为因素（南电信北联通，利益相关） CDN构成： 边缘结点：用户从边缘节点上获取数据 二级节点：主干网节点，主要用于缓存、减转源站压力 源站：CP(内容提供方)将内容放到源站 查找顺序：边缘结点-&gt;二级节点-&gt;源站 3. 亲手搭建一套简单的直播系统安装nginx 配置rtmp 123456$ brew install nginx-full --with-rtmp-module#(这一步卡了我好久，安装nginx提示一直找不到nginx-full,网上相关的教程没更新，原因在于nginx仓库已搬迁)$ brew tap denji/nginx$ nginx -s reload 重启$ nginx 启动 1$ vi /usr/local/etc/nginx/nginx.conf 12345# 推流$ ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName# 拉流$ ffmpeg -i rtmp://server/live/streamName -c copy dump.flv 4. 音频基础知识 图一音量：甲乙的振动频率相同、振幅不同。图二音调：甲乙振幅相同、频率不同 5. 音频的量化与编码模拟信号进行采样，采样时分频率的从模拟信号获取数据波形值，采样后，进行数据量化，量化后进行编码，把采样的十进制转化为计算机的二进制，也就是数字信号。 模拟数据——》采样——》量化——》编码——》数字信号 采样大小决定了音频的振幅的高度，采样时指一个采样用多少bit存放，常用的是16bit 12345# bit：位 一个二进制数据0或1，是1bit# byte：字节 存储空间的基本计量单位，如：MySQL中定义 VARCHAR(45) 即是指 45个字节；# 1 Byte = 8 Bit = 1 字节# 2^8 = 256, 2^16 = 65535 aac通常44.1k采样率 采样率:采样频率8k/秒、16k/秒、32k/秒、44.1k/秒、48k/秒 什么是音频的采样率？采样率和音质有没有关系？ - 知乎 人能听到的声音范围是20hz-2whz 码率 = 采样率 x 采样大小 x 声道数 12# 宽带速率的单位用 bps(或b/s)表示# 1 B = 8 b 1 B/s = 8 b/s 原始的wav文件，大小是1411.2Kb/s 做完aaclc的编码，大小是128Kb/s 如果是aache-vr这种编码，大小是32Kb/s 6. 音频压缩技术讲解音频压缩技术 1、消除冗余数据（有损压缩技术）。 压缩的主要方法是去除采集到的音频冗余信息，所谓冗余信息包括人耳听觉范围外的音频信号以及被掩蔽掉的音频信号 信号的掩蔽可分为频域掩蔽和时域掩蔽 频域掩蔽：一个强纯音会掩蔽在其附近同时发声的弱纯音。也称同时掩蔽 时域掩蔽：在时间上相邻的声音之间也有掩蔽现象，主要原因是人的大脑处理信息需要花费时间。 同步掩蔽效应和不同频率声音的频率和相对竟是有关，而时间掩蔽则仅仅和时间有关。如果两个声音在时间上特别接近，分辨会有困难（如两个声音音量相差较大且两个声音间隔时间低于5毫秒，则其中弱的那个声音会听不到）。 2、哈夫曼无损编码 音频压缩：频域，时域。 频域: 截取人耳能听到的频率范围，滤掉响度低的声音，去掉某个高频周围低频的声音； 时域: 滤掉某个长时间说话中的低音 7. 音频编解码器选型网上测评结果：音频编解码器 opus &gt; aac &gt; vorbis 音频编解码器： 1：opus， 口模型：实时互动，对实时性要求非常高 耳模型：高保真，对质量要求非常高 至于什么时候使用那个模型，由opus自己内部来决定，同时，他是性能最好的，压缩率最好。 2：AAC，经常用于泛娱乐化直播，因为其对实时性要求不是很高但是对音质要求可能较高，所以，选用AAC，当然也可以选用opus的耳模型 3：sppex，最大的特点就是不仅可以编码音频，还可以对音频进行降噪，优化，尽可能的获取原音频数据 4：G.711(722)，主要用于音视频会议，为了和固话进行相应的融合 8. AAC 讲解cdn，rtmp 支持 aac AAC 产生的目的是取代 MP3 格式： AAC 相对优点：压缩率高，损耗低 aac 三种类型aacaacv1: aac+sbr(频率复用-高频部分采样率高，低频部分采样率低)aacv2: aac+sbr+ps(声道关联，一个声道采集全部，一个声道只采集相对不同的声音) AAC规格描述（AAC、AAC HE、AAC HE V2）–&gt; AAC+SBR=AAC HE V1, AAC + SBR + PS = AAC HE V2 AAC格式： 1、ADIF(Audio Data Interchange Format):只能从头开始解码，常用在磁盘文件中。 2、ADTS(Audio Data Transport Stream)：这种格式每一帧都有一个同步字，可以在音频流的任何位置开始解码，它似于数据流格式（缺点：文件比ADIF大，优点:每个帧都可以被单独解码播放） aac 编码库 ffmpeg AAC，libfdk AAC 9. 视频基本知识I帧：关键帧，采用帧内压缩技术 P帧：向前参考帧，压缩时只参考前一个帧，属于帧间压缩技术 B帧：双向参考帧，压缩时即参考前一帧也参考后一帧，属于帧间压缩技术 一般实时互动都不会使用 B 帧 GOF(group of frame): 一组帧，可以将一段时间内画面变化不大的所有帧划为一组帧 SPS与PPS（这两种都划为 I 帧）： SPS(Sequence Parameter Set): 序列参数集，存放帧数、参考帧数目、解码图像尺寸、帧场编码模式选择标识等。 PPS(Picture Parameter Set): 图像参数集，存放熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系统数调整标识等 视频花屏/卡顿原因： 1、如果 GOP 分组中的 P 帧丢失会造成解码端的图像发生错误（于是形成了花屏）。 2、为了避免花屏问题的发生，一般如果发现 P 帧或者I帧丢失，就不显示本 GOP 内的所有帧，直到下一个 I 帧来后重新刷新图像（因为丢了一组数据，所以形成了卡顿） 视频编码器： 1、x264/x265。 2、openH264(支持 SVC（分层传输） 技术)。 3、vp8/vp9 10. H264 宏块的划分与帧分组H264压缩技术 帧内预测压缩，解决的是空域数据冗余问题（将一幅图里的人眼不是很敏感的色彩、光亮等数据剔除） 帧间预测压缩，解决的是时域数据冗余问题（将一组图里面连续的重复性高的帧剔除） 整数离散余弦变换(DCT)，将空间上的相关性变为频域上无关的数据然后进行量化 CABAC压缩，也叫上下文适应无损压缩 宏块的划分与分组： H264宏块划分与子块划分：宏块里面可以再包含很多子块 子块划分： 帧分组(一组连续的图片，一幅图片为一帧) 11. 视频压缩技术详解 帧间预测: 解决时间数据冗余，比较相邻两帧不同给出运动矢量 + 残差值 帧内预测: 解决空间数据冗余，每一个宏块有一个预测模式，然后讲预测后的图像与原图比较算差值，最后存储预测模式和差值即可。帧内压缩是针对于 I 帧的 11.1 帧间预测组内宏块查找： 11.2 帧内预测 11.3 DCT 压缩 11.4 VLC 压缩 11.5 CABAC 压缩 12. H264 结构与码流H264编码分层： 1、NAL层（Network Abstraction Layer）, 视频数据网络抽象层。 2、VCL层（Video Coding Layer），视频数据编码层，对原始数据进行压缩 码流基本概念： 1、SODB（String Of Data Bits）,原始数据比特流，长度不一定是8的倍数，它是由VCL层产生的。 2、RBSP（Raw Byte Sequence Payload,SODB+trailing bits），算法是在SODB最后一位补1，不按字节对齐则补0。 3、EBSP(Encapsulate Byte Sequence Payload)，需到两个连续的0x00就增加一个0x03。 4、NALU，NAL Header(1B)+EBSP 以太网最大传输字节 1500 字节。 一个H264帧最少要有一个切片(NAL Unit) 切片与宏块的关系： 每个切片都包括切片头和切片数据， 每个切片数据又包括了很多宏块， 每个宏块又包括了宏块的类型、宏块的预测、编码的残渣数据等 13. NAL 单元详解 5 - 关键帧 7- SPS 序列参数集 8- PPS 图像参数集 如： P帧B帧很多都是单一类型。 SPS和PPS这两个NAL单元一般放在同一个RTP包里头 14. YUV 讲解 YUV常见格式：YUV4:2:0、YUV4:2:2、YUV4:4:4 RGB8:8:8 UV 混存则为packed(打包存储)， UV分开存则为planar(平面存储) 15. 总结 rtmp 实时消息传输: tcp/ip 应用层协议 推送/直播 基本数据单元为消息 1B 消息类型 2B 长度 3B 时间 4B 流id 消息体 传输时 消息回被拆分成消息块 chunk chunk header + chunk data flv: 大块音视频 加入标记头信息 延迟表现和大规模并发成熟 HLS：分成5-10s 用m3u8索引管理 用于朋友圈分享 m3u8索引： 直播信号源–视频编码器（后台视频处理）–流切片器–各种ts媒体文件（分发模块）–索引文件（数据库）–客户端 cdn网络 为了解决用户访问资源慢出现的技术 边缘节点 二级节点（大城市） 源站 搭建流媒体服务： 准备流媒体服务器 linux max 编译安装nginx服务 配置rtmp服务并启动nginx服务 声音三要素：音调 音量 音色 音频量化(模数转换)：模拟数据 采样 量化 编码 数字信号 == 0101001110 码率 = 采样率（1.6w/44.1/48k）x 采样大小(8位-电话/16位-常见) x 声道数（单/双） 音频压缩： 有损消除冗余数据 哈夫曼无损编码 音频编码： 时域转频域—心里声学模型—量化编码—比特流格式化—比特流 音频编解码 ： opus（口 耳 实时互动 最快） aac(直播用 次快) speed(回音 降噪等) g.711（固话） aac : 取代mp3 加入 sir ps 技术 aac lc 128k / aac he v2 64k / aac he v2 32k/ aac 格式 ： adif 从头开始解码，用在磁盘文件中 adts 每一帧都有一个同步字，可以在任何位置解码 aac 编码库 ： libfdk_aac &gt; ffmpeg aac &gt;libfaac&gt; libvo_aacenc H264： I帧 关键 帧内压缩 / p帧 向前参考1帧 / B帧 双向参考帧 sps: 序列参数集/pps:图像参数集 GOF： 一组帧数 p帧丢失 会花屏卡顿 视频编码器： x264/x265 /open h264(svc)/vp8/vp9 h264 压缩技术-编码原理： 帧内预测压缩，空域冗余数据/帧间预测压缩，时域冗余数据/dcp整数离散余炫变换，傅立叶变换/cabac压缩 h264结构：视频序列–图像–片–宏块–子快 h264编码分层：nal 视频数据网络抽象层–vcl 视频数据编码层 码率：sodb 原始比特流 / rbsp sodb最后补1 / ebsp 起始码增加一个起始位0x03 / nalu nal+ebsp nal unit = nalu 头部 + 一个切片（头/数据） 切片 yuv格式：4：4:4/4:4:2/4：2:0 （平坦编码 /半平坦编码）","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://miaopei.github.io/tags/FFmpeg/"}]},{"title":"Vim 快捷键","slug":"vimHotKey","date":"2018-03-20T08:53:46.000Z","updated":"2019-06-13T06:43:59.866Z","comments":true,"path":"2018/03/20/vimHotKey/","link":"","permalink":"http://miaopei.github.io/2018/03/20/vimHotKey/","excerpt":"Vim使用笔记 1. 文档操作 :e – 重新加载当前文档。 :e! – 重新加载当前文档，并丢弃已做的改动。 :e file – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。 :e! file – 放弃对当前文件的修改，编辑新的文件。 :e# 或 ctrl+^ – 回到刚才编辑的文件，很实用。 gf – 打开以光标所在字符串为文件名的文件。 :saveas newfilename – 另存为","text":"Vim使用笔记 1. 文档操作 :e – 重新加载当前文档。 :e! – 重新加载当前文档，并丢弃已做的改动。 :e file – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。 :e! file – 放弃对当前文件的修改，编辑新的文件。 :e# 或 ctrl+^ – 回到刚才编辑的文件，很实用。 gf – 打开以光标所在字符串为文件名的文件。 :saveas newfilename – 另存为 2. 光标的移动 gj : 移动到一段内的下一行； gk : 移动到一段内的上一行； w : 前移一个单词，光标停在下一个单词开头； b : 后移一个单词，光标停在上一个单词开头； ( : 前移1句。 ) : 后移1句。 { : 前移1段。 } : 后移1段。 fc : 把光标移到同一行的下一个 c 字符处 Fc : 把光标移到同一行的上一个 c 字符处 tc : 把光标移到同一行的下一个 c 字符前 Tc : 把光标移到同一行的上一个 c 字符后 ; : 配合 f &amp; t 使用，重复一次 , : 配合 f &amp; t 使用，反向重复一次 上面的操作都可以配合 n 使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动 3 个字符。 0 : 移动到行首。 g0 : 移到光标所在屏幕行行首。 ^ : 移动到本行第一个非空白字符。 g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。 $ : 移动到行尾。 g$ : 移动光标所在屏幕行行尾。 n| : 把光标移到递 n 列上。 nG : 到文件第 n 行。 :n&lt;cr&gt; : 移动到第 n 行。 :$&lt;cr&gt; : 移动到最后一行。 H : 把光标移到屏幕最顶端一行。 M : 把光标移到屏幕中间一行。 L : 把光标移到屏幕最底端一行。 gg : 到文件头部。 G : 到文件尾部。 2.1 翻屏 ctrl+f : 下翻一屏。 ctrl+b : 上翻一屏。 ctrl+d : 下翻半屏。 ctrl+u : 上翻半屏。 ctrl+e : 向下滚动一行。 ctrl+y : 向上滚动一行。 n% : 到文件 n% 的位置。 zz : 将当前行移动到屏幕中央。 zt : 将当前行移动到屏幕顶端。 zb : 将当前行移动到屏幕底端。 2.2 标记使用标记可以快速移动。到达标记后，可以用 Ctrl+o 返回原来的位置。 Ctrl+o 和 Ctrl+i 很像浏览器上的 后退 和 前进 。 m{a-z} : 标记光标所在位置，局部标记，只用于当前文件。 m{A-Z} : 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。 ``{a-z}` : 移动到标记位置。 &#39;{a-z} : 移动到标记行的行首。 ``{0-9}` ：回到上[2-10]次关闭vim时最后离开的位置。 ``: 移动到上次编辑的位置。’’ 也可以，不过``精确到列，而 ‘’ 精确到行 。如果想跳转到更老的位置，可以按 C-o，跳转到更新的位置用 C-i。 `” : 移动到上次离开的地方。 `. : 移动到最后改动的地方。 :marks – 显示所有标记。 :delmarks a b – 删除标记 a 和 b。 :delmarks a-c – 删除标记 a、b 和 c。 :delmarks a c-f – 删除标记 a、c、d、e、f。 :delmarks! – 删除当前缓冲区的所有标记。 :help mark-motions – 查看更多关于 mark 的知识。 3. 插入文本3.1 基本插入 i : 在光标前插入；一个小技巧：按 8，再按 i，进入插入模式，输入 =， 按 esc 进入命令模式，就会出现 8 个 = 。 这在插入分割线时非常有用，如30i+&lt;esc&gt; 就插入了 36 个 + 组成的分割线。 :r filename : 在当前位置插入另一个文件的内容。 :r !date : 在光标处插入当前日期与时间。同理，:r !command 可以将其它 shell 命令的输出插入当前文档。 3.2 改写插入 c[n]w : 改写光标后 1(n) 个词。 c[n]l : 改写光标后 n 个字母。 c[n]h : 改写光标前 n 个字母。 [n]cc : 修改当前 [n] 行。 [n]s : 以输入的文本替代光标之后 1(n) 个字符，相当于 c[n]l。 [n]S : 删除指定数目的行，并以所输入文本代替之。 注意，类似 cnw,dnw,ynw 的形式同样可以写为 ncw,ndw,nyw。 4. 剪切复制和寄存器4.1 剪切和复制、粘贴 [n]x : 剪切光标右边 n 个字符，相当于 d[n]l。 [n]X : 剪切光标左边 n 个字符，相当于 d[n]h。 y : 复制在可视模式下选中的文本。 yy or Y : 复制整行文本。 y[n]w : 复制一 (n) 个词。 y[n]l : 复制光标右边 1(n) 个字符。 y[n]h : 复制光标左边 1(n) 个字符。 y$ : 从光标当前位置复制到行尾。 y0 : 从光标当前位置复制到行首。 :m,ny&lt;cr&gt; : 复制 m 行到 n 行的内容。 y1G 或 ygg : 复制光标以上的所有行。 yG : 复制光标以下的所有行。 yaw 和 yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。 d : 删除（剪切）在可视模式下选中的文本。 d$ or D : 删除（剪切）当前位置到行尾的内容。 d[n]w: 删除（剪切）1(n)个单词 d[n]l: 删除（剪切）光标右边 1(n) 个字符。 d[n]h: 删除（剪切）光标左边 1(n) 个字符。 d0: 删除（剪切）当前位置到行首的内容 [n] dd: 删除（剪切）1(n) 行。 :m,nd&lt;cr&gt; : 剪切 m 行到 n 行的内容。 d1G 或 dgg : 剪切光标以上的所有行。 dG : 剪切光标以下的所有行。 daw 和 das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。 d/f&lt;cr&gt;：这是一个比较高级的组合命令，它将删除当前位置 到下一个 f 之间的内容。 p: 在光标之后粘贴。 P : 在光标之前粘贴。 4.2 文本对象 aw：一个词 as：一句。 ap：一段。 ab：一块（包含在圆括号中的）。 y, d, c, v 都可以跟文本对象。 4.3 寄存器 a-z：都可以用作寄存器名。&quot;ayy 把当前行的内容放入 a 寄存器。 A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如 &quot;Ayy 把当前行的内容追加到 a 寄存器中。 :reg : 显示所有寄存器的内容。 &quot;&quot;：不加寄存器索引时，默认使用的寄存器。 &quot;*：当前选择缓冲区，&quot;*yy 把当前行的内容放入当前选择缓冲区。 &quot;+：系统剪贴板。&quot;+yy 把当前行的内容放入系统剪贴板。 5. 查找与替换5.1 查找 /something : 在后面的文本中查找 something。 ?something : 在前面的文本中查找 something。 /pattern/+number : 将光标停在包含 pattern 的行后面第 number 行上。 /pattern/-number : 将光标停在包含 pattern 的行前面第 number 行上。 n : 向后查找下一个。 N : 向前查找下一个。 可以用 grep 或 vimgrep 查找一个模式都在哪些地方出现过，其中 :grep 是调用外部的 grep 程序，而 :vimgrep 是 vim 自己的查找算法。 用法为： :vim[grep]/pattern/[g] [j] files g 的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。 j 的含义是 grep 结束后，结果停在第 j 项，默认是停在第一项。 vimgrep 前面可以加数字限定搜索结果的上限，如 :1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。 其实 vimgrep 在读纯文本电子书时特别有用，可以生成导航的目录。 比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：:vim/^d{1,}./ % 然后用 :cw 或 :copen 查看结果，可以用 C-w H 把 quickfix 窗口移到左侧，就更像个目录了。 5.2 替换 :s/old/new – 用 new 替换当前行第一个 old。 :s/old/new/g – 用 new 替换当前行所有的 old。 :n1,n2s/old/new/g – 用 new 替换文件 n1 行到 n2 行所有的 old。 :%s/old/new/g – 用 new 替换文件中所有的 old。 :%s/^/xxx/g – 在每一行的行首插入 xxx，^ 表示行首。 :%s/$/xxx/g – 在每一行的行尾插入 xxx，$ 表示行尾。 所有替换命令末尾加上 c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。 还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令， 语法为 :[range]g/pattern/command 例如 : %g/^ xyz/normal dd。 表示对于以一个空格和 xyz 开头的行执行 normal 模式下的 dd 命令。 关于 range 的规定为： 如果不指定 range，则表示当前行。 m,n : 从 m 行到 n 行。 0 : 最开始一行（可能是这样）。 $ : 最后一行 . : 当前行 % : 所有行 5.3 正则表达式高级的查找替换就要用到正则表达式。 \\d : 表示十进制数（我猜的） \\s : 表示空格 \\S : 非空字符 \\a : 英文字母 \\| : 表示 或 \\. : 表示. {m,n} : 表示 m 到 n 个字符。这要和 \\s 与 \\a 等连用，如 \\a\\{m,n} 表示 m 到 n 个英文字母。 {m,}: 表示 m 到无限多个字符。 **: 当前目录下的所有子目录。 :help pattern 得到更多帮助。 6. 编辑多个文件6.1 一次编辑多个文件我们可以一次打开多个文件，如 1$ vi a.txt b.txt c.txt 使用 :next(:n) 编辑下一个文件。 :2n 编辑下 2 个文件。 使用 :previous或:N 编辑上一个文件。 使用 :wnext，保存当前文件，并编辑下一个文件。 使用 :wprevious，保存当前文件，并编辑上一个文件。 使用 :args 显示文件列表。 :n filenames 或 :args filenames 指定新的文件列表。 vi -o filenames 在水平分割的多个窗口中编辑多个文件。 vi -O filenames 在垂直分割的多个窗口中编辑多个文件。 6.2 多标签编辑 vim -p files : 打开多个文件，每个文件占用一个标签页。 :tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。 ^w gf – 在新的标签页里打开光标下路径指定的文件。 :tabn – 切换到下一个标签。Control + PageDown，也可以。 :tabp – 切换到上一个标签。Control + PageUp，也可以。 [n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第 n 个标签。第一个标签的序号就是 1。 :tab split – 将当前缓冲区的内容在新页签中打开。 :tabc[lose] – 关闭当前的标签页。 :tabo[nly] – 关闭其它的标签页。 :tabs – 列出所有的标签页和它们包含的窗口。 :tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。 6.3 缓冲区 :buffers 或 :ls 或 :files 显示缓冲区列表。 ctrl+^：在最近两个缓冲区间切换。 :bn – 下一个缓冲区。 :bp – 上一个缓冲区。 :bl – 最后一个缓冲区。 :b[n] 或 :[n]b – 切换到第 n 个缓冲区。 :nbw(ipeout) – 彻底删除第 n 个缓冲区。 :nbd(elete) – 删除第 n 个缓冲区，并未真正删除，还在 unlisted 列表中。 :ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。 7. 分屏编辑 vim -o file1 file2 : 水平分割窗口，同时打开 file1 和 file2 vim -O file1 file2 : 垂直分割窗口，同时打开 file1 和 file2 7.1 水平分割 :split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S 可能会冻结终端，请按 CTRL-Q 继续。 :split filename – 水平分割窗口，并在新窗口中显示另一个文件。 :nsplit(:nsp) – 水平分割出一个 n 行高的窗口。 :[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 ( CTRL-W n 或 CTRL-W CTRL-N) ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。 C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。 7.2 垂直分割 :vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v 或 CTRL CTRL-V) :[N]vne[w] – 垂直分割出一个新窗口。 :vertical 水平分割的命令： 相应的垂直分割。 7.3 关闭子窗口 :qall – 关闭所有窗口，退出 vim。 :wall – 保存所有修改过的窗口。 :only – 只保留当前窗口，关闭其它窗口。(CTRL-W o) :close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x 同样工作 ) 7.4 调整窗口大小 ctrl+w + –当前窗口增高一行。也可以用 n 增高 n 行。 ctrl+w - –当前窗口减小一行。也可以用 n 减小 n 行。 ctrl+w _ –当前窗口扩展到尽可能的大。也可以用 n 设定行数。 :resize n – 当前窗口 n 行高。 ctrl+w = – 所有窗口同样高度。 n ctrl+w _ – 当前窗口的高度设定为 n 行。 ctrl+w &lt; –当前窗口减少一列。也可以用 n 减少 n 列。 ctrl+w &gt; –当前窗口增宽一列。也可以用 n 增宽 n 列。 ctrl+w | –当前窗口尽可能的宽。也可以用 n 设定列数。 7.5 切换和移动窗口如果支持鼠标，切换和调整子窗口的大小就简单了。 ctrl+w ctrl+w : 切换到下一个窗口。或者是 ctrl+w w。 ctrl+w p : 切换到前一个窗口。 ctrl+w h(l,j,k) :切换到左（右，下，上）的窗口。 ctrl+w t(b) :切换到最上（下）面的窗口。 ctrl+w H(L,K,J) : 将当前窗口移动到最左（右、上、下）面。 ctrl+w r：旋转窗口的位置。 ctrl+w T : 将当前的窗口移动到新的标签页上。 8. 快速编辑8.1 改变大小写 ~ : 反转光标所在字符的大小写。 可视模式下的 U 或 u：把选中的文本变为大写或小写。 gu(U) 接范围（如$，或 G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如 gu5j，把当前行和下面四行全部变成小写。 8.2 替换（normal模式） r : 替换光标处的字符，同样支持汉字。 R : 进入替换模式，按 esc 回到正常模式。 8.3 撤消与重做（normal模式） [n] u : 取消一(n)个改动。 :undo 5 – 撤销 5 个改变。 :undolist – 你的撤销历史。 ctrl + r : 重做最后的改动。 U : 取消当前行中所有的改动。 :earlier 4m – 回到 4 分钟前 :later 55s – 前进 55 秒 8.4 宏 . –重复上一个编辑动作 qa：开始录制宏 a（键盘操作记录） q：停止录制 @a：播放宏 a 9. 编辑特殊文件9.1 文件加解密 vim -x file : 开始编辑一个加密的文件。 :X – 为当前文件设置密码。 :set key= – 去除文件的密码。 这里是 滇狐总结的比较高级的 vi 技巧。 9.2 文件的编码 :e ++enc=utf8 filename, 让 vim 用 utf-8 的编码打开这个文件。 :w ++enc=gbk，不管当前文件什么编码，把它转存成 gbk 编码。 :set fenc 或 :set fileencoding，查看当前文件的编码。 在 vimrc 中添加 set fileencoding=ucs-bom,utf-8,cp936，vim 会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936 对应于 gbk 编码。 ucs-bom 对应于 windows 下的文件格式。 让 vim 正确处理文件格式和文件编码，有赖于 ~/.vimrc的正确配置 9.3 文件格式大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。 :e ++ff=dos filename, 让 vim 用 dos 格式打开这个文件。 :w ++ff=mac filename, 以 mac 格式存储这个文件。 :set ff，显示当前文件的格式。 在 vimrc 中添加 set fileformats=unix,dos,mac，让 vim 自动识别文件格式。 10. 编程辅助10.1 一些按键 gd : 跳转到局部变量的定义处； gD : 跳转到全局变量的定义处，从当前文件开头开始搜索； g; : 上一个修改过的地方； g, : 下一个修改过的地方； [[ : 跳转到上一个函数块开始，需要有单独一行的 {。 ]] : 跳转到下一个函数块开始，需要有单独一行的 {。 [] : 跳转到上一个函数块结束，需要有单独一行的 }。 ][ : 跳转到下一个函数块结束，需要有单独一行的 }。 [{ : 跳转到当前块开始处； ]} : 跳转到当前块结束处； [/ : 跳转到当前注释块开始处； ]/ : 跳转到当前注释块结束处； % : 不仅能移动到匹配的 (),{} 或 []上，而且能在 #if，#else， #endif 之间跳跃。 下面的括号匹配对编程很实用的。 ci&#39;, di&#39;, yi&#39;：修改、剪切或复制 &#39; 之间的内容。 ca&#39;, da&#39;, ya&#39;：修改、剪切或复制 &#39; 之间的内容，包含 &#39;。 ci&quot;, di&quot;, yi&quot;：修改、剪切或复制 &quot; 之间的内容。 ca&quot;, da&quot;, ya&quot;：修改、剪切或复制 &quot; 之间的内容，包含 &quot;。 ci(, di(, yi(：修改、剪切或复制 ()之间的内容。 ca(, da(, ya(：修改、剪切或复制 () 之间的内容，包含 ()。 ci[, di[, yi[：修改、剪切或复制 [] 之间的内容。 ca[, da[, ya[：修改、剪切或复制 []之间的内容，包含 []。 ci{, di{, yi{：修改、剪切或复制 {} 之间的内容。 ca{, da{, ya{：修改、剪切或复制 {} 之间的内容，包含 {}。 ci&lt;, di&lt;, yi&lt;：修改、剪切或复制 &lt;&gt; 之间的内容。 ca&lt;, da&lt;, ya&lt;：修改、剪切或复制 &lt;&gt; 之间的内容，包含&lt;&gt;。 10.2 ctags Ctrl + ] 找到光标所在位置的标签定义的地方 Ctrl + t 回到跳转之前的标签处 Ctrl + o 退回原来的地方 [I 查找全局标识符. Vim会列出它所找出的匹配行，不仅在当前文件内查找，还会在所有的包含文件中查找 [i 从当前文件起始位置开始查找第一处包含光标所指关键字的位置 ]i 类似上面的 [i，但这里是从光标当前位置开始往下搜索 [{ 转到上一个位于第一列的”{“。（前提是 “{” 和 “}” 都在第一列。） ]} 转到下一个位于第一列的”}” Ctrl+＼+ s 会出现所有调用、定义该函数的地方，输入索引号，回车即可 [ + ctrl + i 跳转到函数、变量和 #define 用 ctrl+o 返回 [ + ctrl + d 跳转到 #define 处用 ctrl+o 返回 ctags -R : 生成 tag 文件，-R 表示也为子目录中的文件生成 tags :set tags=path/tags – 告诉 ctags 使用哪个 tag 文件 :tag xyz – 跳到 xyz 的定义处，或者将光标放在 xyz 上按 C-]，返回用 C-t :stag xyz – 用分割的窗口显示 xyz 的定义，或者 C-w ]， 如果用 C-w n ]，就会打开一个 n 行高的窗口 :ptag xyz – 在预览窗口中打开 xyz 的定义，热键是 C-w }。 :pclose – 关闭预览窗口。热键是 C-w z。 :pedit abc.h – 在预览窗口中编辑 abc.h :psearch abc – 搜索当前文件和当前文件 include 的文件，显示包含 abc 的行。 有时一个 tag 可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。 :[n]tnext – 下一 [n] 个匹配。 :[n]tprev – 上一 [n]个匹配。 :tfirst – 第一个匹配 :tlast – 最后一个匹配 :tselect tagname – 打开选择列表 tab 键补齐 :tag xyz&lt;tab&gt; – 补齐以 xyz 开头的 tag 名，继续按 tab 键，会显示其他的。 :tag /xyz&lt;tab&gt; – 会用名字中含有 xyz 的 tag 名补全。 ctags 对 c++ 生成 tags : 1ctags -R --c++-kinds=+p --fields=+iaS --extra=+q 每个参数解释如下： -R : ctags 循环生成子目录的 tags --c++-kinds=+px : ctags 记录 c++ 文件中的函数声明和各种外部和前向声明 --fields=+iaS : ctags 要求描述的信息 其中 i 表示如果有继承，则标识出父类； a 表示如果元素是类成员的话，要标明其调用权限（即是 public 还是 private）； S 表示如果是函数，则标识函数的 signature。 --extra=+q : 强制要求 ctags 做如下操作—如果某个语法元素是类的一个成员，ctags 默认会给其记录一行，可以要求 ctags 对同一个语法元斯屹记一行，这样可以保证在 VIM 中多个同名函数可以通过路径不同来区分。 10.3 cscope查看阅读 c++ 代码 cscope 缺省只解析 C 文件 (.c 和 .h)、lex 文件( .l )和 yacc 文件( .y )，虽然它也可以支持 C++ 以及 Java，但它在扫描目录时会跳过 C++ 及 Java 后缀的文件。如果希望 cscope 解析 C++ 或 Java 文件，需要把这些文件的名字和路径保存在一个名为 cscope.files 的文件。当 cscope 发现在当前目录中存在 cscope.files 时，就会为 cscope.files 中列出的所有文件生成索引数据库。 下面的命令会查找当前目录及子目录中所有后缀名为 &quot;.h&quot;, &quot;.c&quot;, &quot;cc&quot; 和 &quot;.cpp&quot; 的文件，并把查找结果重定向到文件 cscope.files 中。然后 cscope 根据 cscope.files 中的所有文件，生成符号索引文件。最后一条命令使用 ctags 命令，生成一个 tags 文件，在 vim 中执行 &quot;:help tags&quot; 命令查询它的用法。它可以和 cscope 一起使用。 123$ find . -name \"*.h\" -o -name \"*.c\" -o -name \"*.cc\" -o \"*.cpp\" &gt; cscope.files$ cscope -bkq -i cscope.files$ ctags -R ​ cscope -Rbq : 生成 cscope.out 文件 :cs add /path/to/cscope.out /your/work/dir :cs find c func – 查找 func 在哪些地方被调用 s: 查找 C 语言符号，即查找函数名、宏、枚举值等出现的地方 g: 查找函数、宏、枚举等定义的位置，类似 ctags 所提供的功能 d: 查找本函数调用的函数 c: 查找调用本函数的函数 t: 查找指定的字符串 e: 查找 egrep 模式，相当于 egrep 功能，但查找速度快多了 f: 查找并打开文件，类似 vim 的 find 功能 i: 查找包含本文件的文件 :cw – 打开 quickfix 窗口查看结果 10.4 gtagsGtags 综合了 ctags 和 cscope 的功能。 使用 Gtags 之前，你需要安装 GNU Gtags。 然后在工程目录运行 gtags 。 :Gtags funcname 定位到 funcname 的定义处。 :Gtags -r funcname 查询 funcname被引用的地方。 :Gtags -s symbol 定位 symbol 出现的地方。 :Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。 :Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。 :Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示 vm 目录下的文件。 10.5 编译vim 提供了 :make 来编译程序，默认调用的是 make， 如果你当前目录下有 makefile，简单地 :make 即可。 如果你没有 make 程序，你可以通过配置 makeprg 选项来更改 make 调用的程序。 如果你只有一个 abc.java 文件，你可以这样设置： 1set makeprg=javac\\ abc.java 然后 :make 即可。如果程序有错，可以通过 quickfix 窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让 vim 识别错误信息。 如： 1:setl efm=%A%f:%l:\\ %m,%-Z%p^,%-C%.%# %f 表示文件名，%l 表示行号， %m 表示错误信息，其它的还不能理解。 请参考 :help errorformat。 10.6 快速修改窗口其实是 quickfix 插件提供的功能， 对编译调试程序非常有用 :copen – 打开快速修改窗口。 :cclose – 关闭快速修改窗口。 快速修改窗口在 make 程序时非常有用，当 make 之后： :cl – 在快速修改窗口中列出错误。 :cn – 定位到下一个错误。 :cp – 定位到上一个错误。 :cr – 定位到第一个错误。 10.7 自动补全 C-x C-s – 拼写建议。 C-x C-v – 补全 vim 选项和命令。 C-x C-l – 整行补全。 C-x C-f – 自动补全文件路径。弹出菜单后，按 C-f 循环选择，当然也可以按 C-n 和 C-p。 C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按 C-p 和 C-n也可以。 C-x C-o – 编程时可以补全关键字和函数名啊。 C-x C-i – 根据头文件内关键字补全。 C-x C-d – 补全宏定义。 C-x C-n – 按缓冲区中出现过的关键字补全。 直接按 C-n 或 C-p 即可。 当弹出补全菜单后： C-p 向前切换成员； C-n 向后切换成员； C-e 退出下拉菜单，并退回到原来录入的文字； C-y 退出下拉菜单，并接受当前选项。 10.8 多行缩进缩出 正常模式下，按两下 &gt;; 光标所在行会缩进。 如果先按了 n，再按两下 &gt;;，光标以下的 n 行会缩进。 对应的，按两下 &lt;;，光标所在行会缩出。 如果在编辑代码文件，可以用 = 进行调整。 在可视模式下，选择要调整的代码块，按 =，代码会按书写规则缩排好。 或者 n =，调整 n 行代码的缩排。 10.9 折叠 zf – 创建折叠的命令，可以在一个可视区域上使用该命令； zd – 删除当前行的折叠； zD – 删除当前行的折叠； zfap – 折叠光标所在的段； zo – 打开折叠的文本； zc – 收起折叠； za – 打开/关闭当前折叠； zr – 打开嵌套的折行； zm – 收起嵌套的折行； zR (zO) – 打开所有折行； zM (zC) – 收起所有折行； zj – 跳到下一个折叠处； zk – 跳到上一个折叠处； zi -- enable/disable fold; 11. 其它11.1 工作目录 :pwd 显示vim的工作目录。 :cd path 改变 vim 的工作目录。 :set autochdir 可以让 vim 根据编辑的文件自动切换工作目录。 11.2 一些快捷键（收集中） K : 打开光标所在词的 manpage。 * : 向下搜索光标所在词。 g* : 同上，但部分符合即可。 \\# : 向上搜索光标所在词。 g# : 同上，但部分符合即可。 g C-g : 统计全文或统计部分的字数。 11.3 在线帮助 :h(elp) 或 F1 打开总的帮助。 :help user-manual 打开用户手册。 命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。 :helptags somepath 为 somepath 中的文档生成索引。 :helpgrep 可以搜索整个帮助文档，匹配的列表显示在 quickfix 窗口中。 Ctrl+] 跳转到 tag 主题，Ctrl+t 跳回。 :ver 显示版本信息。 高亮所有搜索模式匹配 shift + * 向后搜索光标所在位置的单词 shift + # 向前搜索光标所在位置的单词 n 和 N 可以继续向后或者向前搜索匹配的字符串 :set hlsearch 高亮所有匹配的字符串 :nohlsearch 临时关闭 :set nohlsearch 彻底关闭，只有重新 :set hlsearch 才可以高亮搜索 vim 高亮显示光标所在的单词，在单词的地方输入 gd 语法高亮 syntax on syntax off vim自动补全 ctrl + n 或者 ctrl + p 复制 vim 文件中所有内容 gg 回到文件首 shift + v 进入 VISUAL LINE 模式 shift + g 全选所有内容 ctrl + insert 复制所选的内容","categories":[{"name":"Vim","slug":"Vim","permalink":"http://miaopei.github.io/categories/Vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://miaopei.github.io/tags/vim/"}]},{"title":"WebSocket教程","slug":"WebSocket教程","date":"2017-05-16T06:15:08.000Z","updated":"2019-06-05T04:03:57.392Z","comments":true,"path":"2017/05/16/WebSocket教程/","link":"","permalink":"http://miaopei.github.io/2017/05/16/WebSocket教程/","excerpt":"转自阮一峰网络编程 WebSocket 是一种网络通信协议，很多高级功能都需要它。 为什么需要 WebSocker初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？","text":"转自阮一峰网络编程 WebSocket 是一种网络通信协议，很多高级功能都需要它。 为什么需要 WebSocker初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 简介WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是 ws（如果加密，则为 wss ），服务器网址就是 URL。 1ws://example.com:80/some/path 客户端的简单示例WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 123456789101112131415var ws = new WebSocket(\"wss://echo.websocket.org\");ws.onopen = function(evt) &#123; console.log(\"Connection open ...\"); ws.send(\"Hello WebSockets!\");&#125;;ws.onmessage = function(evt) &#123; console.log( \"Received Message: \" + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log(\"Connection closed.\");&#125;; 客户端的 APIWebSocket 客户端的 API 如下。 WebSocket 构造函数WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 1var ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。 实例对象的所有属性和方法清单，参见这里。 webSocket.readyStatereadyState 属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; webSocket.onopen实例对象的 onopen 属性，用于指定连接成功后的回调函数。 123ws.onopen = function () &#123; ws.send('Hello Server!');&#125; 如果要指定多个回调函数，可以使用addEventListener`方法。 123ws.addEventListener('open', function (event) &#123; ws.send('Hello Server!');&#125;); webSocket.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。 12345678910111213ws.onclose = function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;;ws.addEventListener(\"close\", function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;); webSocket.onmessage实例对象的 onmessage 属性，用于指定收到服务器数据后的回调函数。 123456789ws.onmessage = function(event) &#123; var data = event.data; // 处理数据&#125;;ws.addEventListener(\"message\", function(event) &#123; var data = event.data; // 处理数据&#125;); 注意，服务器数据可能是文本，也可能是二进制数据（ blob 对象或 Arraybuffer 对象）。 12345678910ws.onmessage = function(event)&#123; if(typeof event.data === String) &#123; console.log(\"Received data string\"); &#125; if(event.data instanceof ArrayBuffer)&#123; var buffer = event.data; console.log(\"Received arraybuffer\"); &#125;&#125; 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。 1234567891011// 收到的是 blob 数据ws.binaryType = \"blob\";ws.onmessage = function(e) &#123; console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = \"arraybuffer\";ws.onmessage = function(e) &#123; console.log(e.data.byteLength);&#125;; webSocket.send( )实例对象的 send( ) 方法用于向服务器发送数据。 发送文本的例子。 1ws.send('your message'); 发送 Blob 对象的例子。 1234var file = document .querySelector('input[type=\"file\"]') .files[0];ws.send(file); 发送 ArrayBuffer 对象的例子。 1234567// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer); webSocket.bufferedAmount实例对象的 bufferedAmount 属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。 12345678var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125; webSocket.onerror实例对象的onerror属性，用于指定报错时的回调函数。 1234567socket.onerror = function(event) &#123; // handle error event&#125;;socket.addEventListener(\"error\", function(event) &#123; // handle error event&#125;); 服务端的实现WebSocket 服务器的实现，可以查看维基百科的列表。 常用的 Node 实现有以下三种。 µWebSockets Socket.IO WebSocket-Node 具体的用法请查看它们的文档，这里不详细介绍了。 WebSocketd下面，我要推荐一款非常特别的 WebSocket 服务器：Websocketd。 它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。 举例来说，下面是一个 Bash 脚本 counter.sh。 123456789#!/bin/bashecho 1sleep 1echo 2sleep 1echo 3 命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。 1234$ bash ./counter.sh123 现在，启动websocketd，指定这个脚本作为服务。 1$ websocketd --port=8080 bash ./counter.sh 上面的命令会启动一个 WebSocket 服务器，端口是 8080 。每当客户端连接这个服务器，就会执行 counter.sh 脚本，并将它的输出推送给客户端。 12345var ws = new WebSocket('ws://localhost:8080/');ws.onmessage = function(event) &#123; console.log(event.data);&#125;; 上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。 有了它，就可以很方便地将命令行的输出，发给浏览器。 1$ websocketd --port=8080 ls 上面的命令会执行ls命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（代码）。 更多的用法可以参考官方示例。 Bash 脚本读取客户端输入的例子 五行代码实现一个最简单的聊天服务器 websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务 greeter.js。 12345678process.stdin.setEncoding('utf8');process.stdin.on('readable', function() &#123; var chunk = process.stdin.read(); if (chunk !== null) &#123; process.stdout.write('data: ' + chunk); &#125;&#125;); 启动这个脚本的命令如下。 1$ websocketd --port=8080 node ./greeter.js 官方仓库还有其他各种语言的例子。 参考链接 How to Use WebSockets WebSockets - Send &amp; Receive Messages Introducing WebSockets: Bringing Sockets to the Web","categories":[{"name":"前端","slug":"前端","permalink":"http://miaopei.github.io/categories/前端/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://miaopei.github.io/tags/WebSocket/"}]},{"title":"定制支持串口安装的ubuntu系统镜像","slug":"定制支持串口安装的ubuntu系统镜像","date":"2017-05-15T07:48:06.000Z","updated":"2019-06-05T04:03:57.392Z","comments":true,"path":"2017/05/15/定制支持串口安装的ubuntu系统镜像/","link":"","permalink":"http://miaopei.github.io/2017/05/15/定制支持串口安装的ubuntu系统镜像/","excerpt":"1、所需环境：硬件环境： 笔记本 串口调试线缆 光盘 显示器 FWA产品的任一机型（此次使用的是FWA-4210） SATA或者USB光驱×1","text":"1、所需环境：硬件环境： 笔记本 串口调试线缆 光盘 显示器 FWA产品的任一机型（此次使用的是FWA-4210） SATA或者USB光驱×1 软件环境： 带有genisoimage(旧版是mkisofs)的linux发行版（此次使用的是Ubuntu 16.04 server版） Ubuntu官网通用镜像ISO文件 2、操作过程：2.1 开机进入系统，将光盘挂载到Ubuntu系统CLI命令如下； 1$ mount -o loop ubuntu-16.04.2-server-amd64.iso /mnt/temp 2.2 更改配置相关配置文件（menu.cfg、txt.cfg、isolinux.cfg此文件不是必须要修改，具体见下边解释）。将光盘文件，拷贝到临时目录（家目录或者自己新建目录均可，但建议拷贝到/var或/temp目录下），具体命令如下： 1$ cp -rf /mnt/temp/ /var/mycdrom 因为 /mnt 目录的默认权限是 333 ，所以在此使用 -r 和 -f 参数，-r 代表递归，即文件夹下所有文件都拷贝，-f 代表强制执行； 更改 menu.cfg 文件，如下图，主要是注释掉标准安装的配置文件，以便可以定制安装。 123$ cd /var/mycdrom/temp/isolinux$ vi menu.cfg 注： vi有三种模式，普通模式、编辑模式、命令行模式； I o a进入编辑模式， 普通模式下数字+yy复制 P黏贴 命令行模式：w写入，q离开，！强制执行 注释 menu.cfg 内容如下红框所示： 更改 txt.cfg 文件，主要用于定制串口安装（如下图）： 更改 isolinux.cfg 文件，主要修改grub菜单等待时间（如下图），也可不修改； 2.3 重新打包ISO文件命令如下： 1$ genisoimage -o ubuntu-16.04.2-server-adm64-console_115200.iso -r -J -no-emul-boot -boot-load-size 4 -boot-info-table -b isolinux/isolinux.bin -c isolinux/boot.cat /var/mycdrom/temp genisoimage 是linux各大发行版制作ISO镜像比较流行的工具，若要定制系统，最好在linux下更改相关配置，并使用此工具重新打包；若在Windows平台使用UltraISO等工具解压更改重新打包会出现不稳定的情况（无法找到镜像，无法找到安装源等）。 -o ：是output缩写，用来指定输出镜像名称 -r ： 即rational-rock，用来开放ISO文件所有权限（r、w、x） -J ： 即Joliet，一种ISO9600扩展格式，用来增加兼容性，最好加上 -no-emul-boot -boot-load-size 4 -boot-info-table ：指定兼容模式下虚拟扇区的数量，若不指定，有些BISO会出现一些问题 -b ：指定开机映像文件 -c ：具体开机配置文件 最后加上输出目录 Reboot系统U盘启动，即可安装系统。 3、文本安装系统注意事项3.1 进入安装模式关闭系统插入U盘，启动系统，看到如下提示按F12进入安装系统模式： 1Press F12 for boot menu.. 选择U盘所在的选项。 3.2 分区若是硬盘已有linux发行版系统，那在如下界面，必须umount分区，才能将更改写入分区表 3.3 自动更新如下界面，若有特许需求（需要安装一些特许软件apache、weblogic等）可以选择自动更新（需要联网），一般情况不选则自动更新","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://miaopei.github.io/categories/Ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://miaopei.github.io/tags/ubuntu/"}]},{"title":"Shell脚本攻略笔记","slug":"Shell脚本攻略笔记","date":"2017-05-15T07:40:41.000Z","updated":"2019-06-03T08:50:47.354Z","comments":true,"path":"2017/05/15/Shell脚本攻略笔记/","link":"","permalink":"http://miaopei.github.io/2017/05/15/Shell脚本攻略笔记/","excerpt":"1. 基本命令1.1 shell 格式输出12345678$ echo 'Hello world !'-n # 忽略结尾的换行符-e # 激活转义字符-E # disable转义字符# echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。$ echo -e \"1\\t2\\t3\"","text":"1. 基本命令1.1 shell 格式输出12345678$ echo 'Hello world !'-n # 忽略结尾的换行符-e # 激活转义字符-E # disable转义字符# echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。$ echo -e \"1\\t2\\t3\" 打印彩色输出： 1234567# 彩色文本# 重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37$ echo -e \"\\e[1;31m This is red text \\e[0m\"# 彩色背景# 重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47$ echo -e \"\\e[1;42m Green Background \\e[0m\" 1$ printf \"%-5s %-10s %-4s\\n\" No Name Mark 原理： %-5s 指明了一个格式为左对齐且宽度为5的字符串替换（ -表示左对齐）。如果不用 - 指定对齐方式，字符串就采用右对齐形式。 %s 、 %c 、%d 和 %f 都是格式替换符（format substitution character），其所对应的参数可以置于带引号的格式字符串之后。 1.2 替换命令 tr123456789101112131415161718192021222324252627282930313233# tr 是 translate的简写$ tr '\\0' '\\n' # 将 \\0 替换成 \\n$ tr [选项]… 集合1 [集合2]选项说明：-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。-d, –delete 删除集合1中的字符而不是转换-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符字符集合的范围：\\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)\\\\ 反斜杠\\a Ctrl-G 铃声\\b Ctrl-H 退格符\\f Ctrl-L 走行换页\\n Ctrl-J 新行\\r Ctrl-M 回车\\t Ctrl-I tab键\\v Ctrl-X 水平制表符CHAR1-CHAR2 从CHAR1 到 CHAR2的所有字符按照ASCII字符的顺序[CHAR*] in SET2, copies of CHAR until length of SET1[CHAR*REPEAT] REPEAT copies of CHAR, REPEAT octal if starting with 0[:alnum:] 所有的字母和数字[:alpha:] 所有字母[:blank:] 水平制表符，空白等[:cntrl:] 所有控制字符[:digit:] 所有的数字[:graph:] 所有可打印字符，不包括空格[:lower:] 所有的小写字符[:print:] 所有可打印字符，包括空格[:punct:] 所有的标点字符[:space:] 所有的横向或纵向的空白[:upper:] 所有大写字母 1.3 打印变量1234$ var=\"value\"$ echo $var或者$ echo $&#123;var&#125; 1.4 设置环境变量12345# 在PATH中添加一条新路径$ export PATH=\"$PATH:/home/user/bin\"也可以使用：$ PATH=\"$PATH:/home/user/bin\"$ export PATH 1.5 Shell中三种引号的用法123456789101112131415161718# 单引号# 使用单引号时，变量不会被扩展（expand），将依照原样显示。$ var=\"123\"$ echo '$var' will print $var结果为：'$var' will print 123# 双引号# 输出引号中的内容，若存在命令、变量等，会先执行命令解析出结果再输出$ echo \"$var\" will print $var结果为：123 will print 123# 反引号# 命令替换$ var=`whoami`$ echo $var结果为：root# 备注：反引号和$()作用相同 1.6 获得字符串的长度123456# 用法$ length=$&#123;#var&#125;$ var=12345678901234567890$ echo $&#123;#var&#125;20 1.7 识别当前shell123$ echo $SHELL也可以使用：$ echo $0 1.8 使用shell进行数学运算在Bash shell环境中，可以利用 let、(( )) 和[] 执行基本的算术操作。而在进行高级操作时，expr 和 bc 这两个工具也会非常有用。 使用 let 时，变量名之前不需要再添加 $ 123$ no1=4$ let no1++$ let no1+=6 # 等同于let no=no+6 1234# 操作符[]的使用方法和let命令类似$ result=$[ no1 + no2 ]# 在[]中也可以使用$前缀$ result=$[ $no1 + 5 ] 12# 使用(())时，变量名之前需要加上$$ result=$(( no1 + 50 )) 123# expr同样可以用于基本算术操作$ result=`expr 3 + 4`$ result=$(expr $no1 + 5) bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项 。此处不多介绍。 1.9 shell中各种括号的作用()、(())、[]、[[]]、{}1.9.1 小括号，圆括号（）1、单小括号 ( ) 命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。 命令替换。等同于cmd，shell扫描一遍命令行，发现了$(cmd)结构 ，便将 $(cmd) 中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。 用于初始化数组。如：array=(a b c d)。 2、双小括号 (( )) 整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。 只要括号中的运算符、表达式符合C语言运算规则，都可用在 $((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)。 单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6。 常用于算术运算比较，双括号中的变量可以不使用$ 符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i&lt;5;i++)), 如果不使用双括号, 则为for i in seq 0 4或者for i in {0..4}。再如可以直接使用 if (($i&lt;5)) , 如果不使用双括号, 则为 if [ $i -lt 5 ] 。 1.9.2 中括号，方括号[]1、单中括号 [] bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。 Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。 字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。 在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。 2、双中括号 [[ ]] [[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。 支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。 使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用 if [[ $a != 1 &amp;&amp; $a != 2 ]] , 如果不适用双括号, 则为 if [ $a -ne 1] &amp;&amp; [ $a != 2 ]或者 if [ $a -ne 1 -a $a != 2 ] 。 bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。 1.9.3 大括号、花括号 {}1）常规用法 大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt 代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。 2）几种特殊的替换结构 1$&#123;var:-string&#125;,$&#123;var:+string&#125;,$&#123;var:=string&#125;,$&#123;var:?string&#125; ${var:-string} 和 ${var:=string}: 若变量var为空，则用在命令行中用string来替换 ${var:-string}，否则变量var不为空时，则用变量var的值来替换 ${var:-string} ；对于 ${var:=string} 的替换规则和 ${var:-string} 是一样的，所不同之处是 ${var:=string} 若var为空时，用string替换 ${var:=string} 的同时，把string赋给变量 var： ${var:=string} 很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。 ${var:+string} 的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 。 ${var:?string} 替换规则为：若变量var不为空，则用变量var的值来替换 ${var:?string} ；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。 补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。 3）四种模式匹配替换结构 模式匹配记忆方法： 123# 是去掉左边(在键盘上#在$之左边)% 是去掉右边(在键盘上%在$之右边)#和%中的单一符号是最小匹配，两个相同符号是最大匹配。 1$&#123;var%pattern&#125;,$&#123;var%%pattern&#125;,$&#123;var#pattern&#125;,$&#123;var##pattern&#125; 第一种模式：${variable%pattern} ，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式 第二种模式：${variable%%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式 第三种模式：${variable#pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式 第四种模式：${variable##pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式 这四种模式中都不会改变variable的值，其中，只有在pattern中使用了匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。 4）字符串提取和替换 1$&#123;var:num&#125;,$&#123;var:num1:num2&#125;,$&#123;var/pattern/pattern&#125;,$&#123;var//pattern/pattern&#125; 第一种模式：${var:num} ，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如 ${var: -2} 、${var:1-3} 或 ${var:(-2)}。 第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从 $var字符串的第$num1 个位置开始提取长度为$num2的子串。不能为负数。 第三种模式：${var/pattern/pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。。 第四种模式：${var//pattern/pattern} 表示将var字符串中的所有能匹配的pattern替换为另一个pattern。 1.9.4 符号$后的括号 ${a} 变量a的值, 在不引起歧义的情况下可以省略大括号。 $(cmd) 命令替换，和cmd效果相同，结果为shell命令cmd的输，过某些Shell版本不支持 $() 形式的命令替换, 如tcsh。 $((expression)) 和exprexpression效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。 1.9.5 多条命令执行 单小括号，(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。 单大括号，{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。 对 {} 和 () 而言, 括号中的重定向符只影响该条命令，而括号外的重定向符影响到括号中的所有命令。 1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数 变量 含义 $0 当前脚本的文件名。 $n 传递给脚本或函数的参数。n是一个数字，表示几个参数。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有采纳数。被双引号(“ “)包含是，与$* 稍有不同。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前shell进程ID。对于shell脚本，就是这个脚本所在的进程ID。 1.10.1 命令行参数运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。 1.10.2 $* 和 $@ 的区别$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 但是当它们被双引号(“ “)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot; 的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以 &quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;的形式输出所有参数。 1.10.3 退出状态$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。 退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。 不过，也有一些命令返回其他值，表示不同类型的错误。 $? 也可以表示函数的返回值，此处不展开。 1.11 Shell重定向1、重定向符号 1234&gt; 输出重定向到一个文件或设备 覆盖原来的文件&gt;! 输出重定向到一个文件或设备 强制覆盖原来的文件&gt;&gt; 输出重定向到一个文件或设备 追加原来的文件&lt; 输入重定向到一个程序 2、标准输入刷出 1234在 bash 命令执行的过程中，主要有三种输出入的状况，分别是：1. 标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt;2. 标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt;3. 错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt; 3、使用实例 12345678910111213# &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。# 1&gt;&amp;2 意思是把标准输出重定向到标准错误.# 2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。# &amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中$ cmd &lt;&gt; file # 以读写方式打开文件 file$ cmd &gt;&amp;n # 将 cmd 的输出发送到文件描述符 n$ cmd m&gt;&amp;n # 将本该输出到文件描述符 m 的内容, 发送到文件描述符 n$ cmd m&lt;&amp;n # 除了本该从文件描述符 m 处获取输入，改为从文件描述符 n 处获取$ cmd &gt;&amp;- # 关闭标准输出$ cmd &lt;&amp;- # 关闭标准输入$ cmd &gt;&amp; file # 将标准输出和标准错误都发送到文件 file $ cmd &amp;&gt; file # 作用同上, 更好的格式 要在终端中打印stdout，同时将它重定向到一个文件中，那么可以这样使用tee 。 12345678# 用法：command | tee FILE1 FILE2$ cat a* | tee out.txt | cat -n# 默认情况下， tee命令会将文件覆盖，但它提供了一个-a选项，用于追加内容$ cat a* | tee -a out.txt | cat –n# 我们可以使用stdin作为命令参数。只需要将-作为命令的文件名参数即可# 用法：$ cmd1 | cmd2 | cmd -$ echo who is this | tee - 1.12 Shell数组和关联数组1.12.1 简介数组是Shell脚本非常重要的组成部分，它借助索引将多个独立的独立的数据存储为一个集合。普通数组只能使用整数作为数组索引，关联数组不仅可以使用整数作为索引，也可以使用字符串作为索引。通常情况下，使用字符串做索引更容易被人们理解。Bash从4.0之后开始引入关联数组。 1.12.2 定义打印普通数组数组的方法有如下几种： 1234567#在一行上列出所有元素$ array_var=(1 2 3 4 5 6)#以“索引-值”的形式一一列出$ array_var[0]=\"test1\"$ array_var[1]=\"test2\"$ array_var[2]=\"test3\" 注意：第一种方法要使用圆括号，否则后面会报错。 数组元素的方法有如下几种： 123456$ echo $&#123;array_var[0]&#125; #输出结果为 test1$ index=2$ echo $&#123;array_var[$index]&#125; #输出结果为 test3$ echo $&#123;array_var[*]&#125; #输出所有数组元素$ echo $&#123;array_var[@]&#125; #输出所有数组元素$ echo $&#123;#array_var[*]&#125; #输出值为 3 注意：在ubuntu 14.04中，shell脚本要以#!/bin/bash开头，且执行脚本的方式为 bash test.sh。 1.12.3 定义打印关联数组定义关联数组在关联数组中，可以使用任何文本作为数组索引。定义关联数组时，首先需要使用声明语句将一个变量声明为关联数组，然后才可以在数组中添加元素，过程如下： 12345678$ declare -A ass_array #声明一个关联数组$ ass_array=([\"index1\"]=index1 [\"index2\"]=index2)#内嵌“索引-值”列表法$ ass_array[\"index3\"]=index3$ ass_array[\"index4\"]=index4$ echo $&#123;ass_array[\"index1\"]&#125; #输出为index1$ echo $&#123;ass_array[\"index4\"]&#125;$ echo $&#123;!ass_array[*]&#125; #输出索引列表$ echo $&#123;!ass_array[@]&#125; #输出索引列表 注意：对于普通数组，使用上面的方法依然可以列出索引列表，在声明关联数组以及添加数组元素时，都不能在前面添加美元符$。 1.13 使用别名alias命令的作用只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名设置一直保持作用，可以将它放入~/.bashrc文件中。因为每当一个新的shell进程生成时，都会执行 ~/.bashrc中的命令。 1$ alias install='sudo apt-get install' 1.14 获取、设置日期和延时时间方面 : 1234567891011121314% : 印出% %n : 下一行%t : 跳格%H : 小时(00..23)%I : 小时(01..12)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数 %S : 秒(00..61)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区 日期方面 : 12345678910111213141516171819%a : 星期几 (Sun..Sat)%A : 星期几 (Sunday..Saturday)%b : 月份 (Jan..Dec)%B : 月份 (January..December)%y : 年份的最后两位数字 (00.99)%Y : 完整年份 (0000..9999)%c : 直接显示日期与时间%d : 日 (01..31)%D : 直接显示日期 (mm/dd/yy)%h : 同 %b%j : 一年中的第几天 (001..366)%m : 月份 (01..12)%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)%w : 一周中的第几天 (0..6)%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)%x : 直接显示日期 (mm/dd/yy) 若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中： 1234567MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数 参数 : -d datestr : 显示 datestr 中所设定的时间 (非系统时间) –help : 显示辅助讯息 -s datestr : 将系统时间设为 datestr 中所设定的时间 -u : 显示目前的格林威治时间 –version : 显示版本编号 例子： 12345$ date # 获取日期$ date +%s # 打印纪元时$ date \"+%d %B %Y\" # 用格式串结合 + 作为date命令的参数，可以按照你的选择打印出对应格式的日期20 May 2010$ date -s \"21 June 2009 11:01:22\" # 设置日期和时间 1.15 脚本调试1.15.1使用选项–x，启用shell脚本的跟踪调试功能1$ bash -x script.sh 1.15.2 使用set -x和set +x对脚本进行部分调试123456789#!/bin/bash#文件名: debug.shfor i in &#123;1..6&#125;do set -x echo $i set +xdoneecho \"Script executed\" set –x：在执行时显示参数和命令。 set +x：禁止调试。 set –v：当命令进行读取时显示输入。 set +v：禁止打印输入。 1.15.3 通过传递 _DEBUG环境变量调试123456789#!/bin/bashfunction DEBUG()&#123; [ \"$_DEBUG\" == \"on\" ] &amp;&amp; $@ || :&#125;for i in &#123;1..10&#125;do DEBUG echo $idone 可以将调试功能置为”on”来运行上面的脚本： 1$ _DEBUG=on ./script.sh 我们在每一个需要打印调试信息的语句前加上DEBUG。如果没有把 _DEBUG=on传递给脚本，那么调试信息就不会打印出来。在Bash中，命令 : 告诉shell不要进行任何操作。 1.15.4 利用shebang来进行调试shebang的妙用把shebang从 #!/bin/bash 改成 #!/bin/bash -xv，这样一来，不用任何其他选项就可以启用调试功能了。 1.16 函数参数1234567$0 # 脚本名$1 # 第一个参数$2 # 第二个参数$n # 第n个参数\"$@\" # 被扩展成 \"$1\" \"$2\" \"$3\"等\"$*\" # 被扩展成 \"$1c$2c$3\"，其中c是IFS的第一个字符\"$@\" 要比\"$*\"用得多。由于 \"$*\"将所有的参数当做单个字符串，因此它很少被使用。 导出函数： 函数也能像环境变量一样用export导出，如此一来，函数的作用域就可以扩展到子进程中，例如： 1export -f fname 1.17 read命令123456789101112# 从输入中读取n个字符并存入变量$ read -n 2 var$ echo $var# 用无回显的方式读取密码$ read -s var# 显示提示信息$ read -p \"Enter input:\" var# 在特定时(秒)限内读取输入$ read -t timeout var 1.18 条件比较与测试123456789101112131415# if条件if conditionthen commandsfi# else if和elseif conditionthen commandselse if condition then commandselse commandsfi if的条件判断部分可能会变得很长，但可以用逻辑运算符将它变得简洁一些： 12[ condition ] &amp;&amp; action # 如果condition为真，则执行action[ condition ] || action # 如果condition为假，则执行action &amp;&amp; 是逻辑与运算符， || 是逻辑或运算符。编写Bash脚本时，这是一个很有用的技巧。现在来了解一下条件和比较操作。 算术比较： -gt ：大于。 -lt ：小于。 -ge ：大于或等于。 -le ：小于或等于。 可以按照下面的方法结合多个条件进行测试： 12[ $var1 -ne 0 -a $var2 -gt 2 ] #使用逻辑与-a[ $var1 -ne 0 -o var2 -gt 2 ] #逻辑或 -o 文件系统相关测试： 我们可以使用不同的条件标志测试不同的文件系统相关的属性。 [ -f $file_var ] ：如果给定的变量包含正常的文件路径或文件名，则返回真。 [ -x $var ] ：如果给定的变量包含的文件可执行，则返回真。 [ -d $var ] ：如果给定的变量包含的是目录，则返回真。 [ -e $var ] ：如果给定的变量包含的文件存在，则返回真。 [ -c $var ] ：如果给定的变量包含的是一个字符设备文件的路径，则返回真。 [ -b $var ] ：如果给定的变量包含的是一个块设备文件的路径，则返回真。 [ -w $var ] ：如果给定的变量包含的文件可写，则返回真。 [ -r $var ] ：如果给定的变量包含的文件可读，则返回真。 [ -L $var ] ：如果给定的变量包含的是一个符号链接，则返回真。 字符串比较： 使用字符串比较时，最好用双中括号，因为有时候采用单个中括号会产生错误，所以最好避开它们。 可以用下面的方法检查两个字符串，看看它们是否相同。 [[ $str1 = $str2 ]]：当str1等于str2时，返回真。也就是说， str1和str2包含的文本是一模一样的。 [[ $str1 == $str2 ]] ：这是检查字符串是否相等的另一种写法。 也可以检查两个字符串是否不同。 [[ $str1 != $str2 ]] ：如果str1和str2不相同，则返回真。 我们还可以检查字符串的字母序情况，具体如下所示。 [[ $str1 &gt; $str2 ]] ：如果str1的字母序比str2大，则返回真。 [[ $str1 &lt; $str2 ]] ：如果str1的字母序比str2小，则返回真。 [[ -z $str1 ]] ：如果str1包含的是空字符串，则返回真。 [[ -n $str1 ]] ：如果str1包含的是非空字符串，则返回真。 使用逻辑运算符 &amp;&amp; 和 || 能够很容易地将多个条件组合起来： 1234if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]] then commandsfi test命令可以用来执行条件检测。用test可以避免使用过多的括号。之前讲过的[]中的测试条件同样可以用于test命令。 123if [ $var -eq 0 ]; then echo \"True\"; fi# 也可以写成：if test $var -eq 0 ; then echo \"True\"; fi 补充内容1. 利用子shell生成一个独立的进程子shell本身就是独立的进程。可以使用 ( )操作符来定义一个子shell ： 123pwd;(cd /bin; ls);pwd; 2. 无限循环的实例1repeat() &#123; while true; do $@ &amp;&amp; return; done &#125; 工作原理： 函数repeat，它包含了一个无限while循环，该循环执行以参数形式（通过 $@ 访问）传入函数的命令。如果命令执行成功，则返回，进而退出循环。 一种更快的做法 ： 在大多数现代系统中， true 是作为 /bin 中的一个二进制文件来实现的。这就意味着每执行一次while循环， shell就不得不生成一个进程。如果不想这样，可以使用shell内建的 :命令，它总是会返回为0的退出码： 1repeat() &#123; while :; do $@ &amp;&amp; return; done &#125; 尽管可读性不高，但是肯定比第一种方法快。 2. 命令之乐2.1 cat命令123456# 摆脱多余的空白行$ cat -s file# 显示行号$ cat -n file# -n甚至会为空白行加上行号。如果你想跳过空白行，那么可以使用选项-b。 2.2 find命令123456# 列出当前目录及子目录下所有的文件和文件夹$ find base_path$ find . -print# -print指明打印出匹配文件的文件名（路径）。当使用 -print时， '\\n'作为用于对输出的文件名进行分隔。就算你忽略-print， find命令仍会打印出文件名。# -print0指明使用'\\0'作为匹配的文件名之间的定界符。 1、find命令有一个选项 -iname（忽略字母大小写） 12345$ lsexample.txt EXAMPLE.txt file.txt$ find . -iname \"example*\" -print./example.txt./EXAMPLE.txt 2、如果想匹配多个条件中的一个，可以采用OR条件操作 : 12345$ lsnew.txt some.jpg text.pdf$ find . \\( -name \"*.txt\" -o -name \"*.pdf\" \\) -print./text.pdf./new.txt 3、选项-path的参数可以使用通配符来匹配文件路径。 -name 总是用给定的文件名进行匹配。-path 则将文件路径作为一个整体进行匹配。例如 : 123$ find /home/users -path \"*/slynux/*\" -print/home/users/list/slynux.txt/home/users/slynux/eg.css 4、选项 -regex 的参数和 -path 的类似，只不过 -regex 是基于正则表达式来匹配文件路径的。 12345678$ lsnew.PY next.jpg test.py$ find . -regex \".*\\(\\.py\\|\\.sh\\)$\"./test.py# 类似地， -iregex可以让正则表达式忽略大小写。例如：$ find . -iregex \".*\\(\\.py\\|\\.sh\\)$\"./test.py./new.PY 5、find也可以用“!”否定参数的含义。例如： 1234567$ lslist.txt new.PY new.txt next.jpg test.py$ find . ! -name \"*.txt\" -print../next.jpg./test.py./new.PY 6、基于目录深度的搜索 123456# 深度选项-maxdepth和 -mindepth来限制find命令遍历的目录深度# 下列命令将find命令向下的最大深度限制为1:$ find . -maxdepth 1 -name \"f*\" -print# 打印出深度距离当前目录至少两个子目录的所有文件:$ find . -mindepth 2 -name \"f*\" -print 注：-maxdepth和-mindepth应该作为find的第三个参数出现。如果作为第4个或之后的参数，就可能会影响到find的效率，因为它不得不进行一些不必要的检查。 根据文件类型搜索 7、根据文件类型搜索 -type 可以对文件搜索进行过滤 文件类型 类型参数 普通文件 f 符号链接 l 目录 d 字符设备 c 块设备 b 套接字 s FIFO p 8、根据文件时间进行搜索 访问时间（-atime）：用户最近一次访问文件的时间。 修改时间（-mtime）：文件内容最后一次被修改的时间。 变化时间（-ctime）：文件元数据（例如权限或所有权）最后一次改变的时间。 -atime、 -mtime、 -ctime可作为find的时间选项。它们可以用整数值指定，单位是天。这些整数值通常还带有 - 或 + ： - 表示小于， + 表示大于。 12345678# 打印出在最近7天内被访问过的所有文件：$ find . -type f -atime -7 -print# 打印出恰好在7天前被访问过的所有文件：$ find . -type f -atime 7 -print# 打印出访问时间超过7天的所有文件：$ find . -type f -atime +7 -print -atime、 -mtime以及-ctime都是基于时间的参数，其计量单位是“天”。还有其他一些基于时间的参数是以分钟作为计量单位的。这些参数包括： -amin（访问时间） -mmin（修改时间） -cmin（变化时间） 使用 -newer ，我们可以指定一个用于比较时间戳的参考文件，然后找出比参考文件更新的（更近的修改时间）所有文件 12# 找出比file.txt修改时间更近的所有文件：$ find . -type f -newer file.txt -print 9、基于文件大小的搜索 12345678$ find . -type f -size +2k# 大于2KB的文件$ find . -type f -size -2k# 小于2KB的文件$ find . -type f -size 2k# 大小等于2KB的文件 b —— 块（512字节） c —— 字节 w —— 字（2字节） k —— 1024字节 M —— 1024k字节 G —— 1024M字节 10、删除匹配的文件 -delete 可以用来删除find查找到的匹配文件。 12# 删除当前目录下所有的 .swp文件：$ find . -type f -name \"*.swp\" -delete 11、基于文件权限和所有权的匹配 12$ find . -type f -perm 644 -print# 打印出权限为644的文件 -perm指明find应该只匹配具有特定权限值的文件。 12、利用find执行命令或动作 find命令可以借助选项-exec与其他命名进行结合。 -exec算得上是find最强大的特性之一。 123$ find . -type f -user root -exec chown slynux &#123;&#125; \\;# &#123;&#125;是一个与 -exec选项搭配使用的特殊字符串。对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名。 -exec 结合多个命令 : 我们无法在-exec参数中直接使用多个命令。它只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个shell脚本中（例如command.sh），然后在-exec中使用这个脚本： 1-exec ./commands.sh &#123;&#125; \\; 13、让find跳过特定的目录 123$ find devel/source_path \\( -name \".git\" -prune \\) -o \\( -type f -print \\)# 以上命令打印出不包括在.git目录中的所有文件的名称（路径）。 \\( -name &quot;.git&quot; -prune \\) 的作用是用于进行排除，它指明了 .git目录应该被排除在外，而\\( -type f -print \\) 指明了需要执行的动作。这些动作需要被放置在第二个语句块中（打印出所有文件的名称和路径）。 2.3 玩转xargsxargs 擅长将标准输入数据转换成命令行参数。 xargs 命令把从 stdin接收到的数据重新格式化，再将其作为参数提供给其他命令。 2.3.1 将多行输入转换成单行输出只需要将换行符移除，再用” “（空格）进行代替，就可以实现多行输入的转换。 123456$ cat example.txt # 样例文件1 2 3 4 5 67 8 9 1011 12$ cat example.txt | xargs1 2 3 4 5 6 7 8 9 10 11 12 2.3.2 将单行输入转换成多行输出指定每行最大的参数数量 n，我们可以将任何来自stdin的文本划分成多行，每行 n 个参数。 12345$ cat example.txt | xargs -n 31 2 34 5 67 8 910 11 12 2.3.3 定制定界符用 -d 选项为输入指定一个定制的定界符： 123456$ echo \"splitXsplitXsplitXsplit\" | xargs -d Xsplit split split split$ echo \"splitXsplitXsplitXsplit\" | xargs -d X -n 2split splitsplit split 在这里，我们明确指定X作为输入定界符，而在默认情况下， xargs采用内部字段分隔符（空格）作为输入定界符。 2.3.4 读取stdin，将格式化参数传递给命令-I 指定替换字符串，这个字符串在xargs扩展时会被替换掉。如果将 -I 与 xargs 结合使用，对于每一个参数，命令都会被执行一次。 12345678$ cat args.txtarg1arg2arg3$ cat args.txt | xargs -I &#123;&#125; ./cecho.sh -p &#123;&#125; -l-p arg1 -l #-p arg2 -l #-p arg3 -l # -I {} 指定了替换字符串。对于每一个命令参数，字符串 {} 都会被从stdin读取到的参数替换掉。 使用 -I 的时候，命令以循环的方式执行。 xargs和find算是一对死党。两者结合使用可以让任务变得更轻松。 不过人们通常却是以一种错误的组合方式使用它们。例如： 1$ find . -type f -name \"*.txt\" -print | xargs rm -f 这样做很危险。 有时可能会删除不必要删除的文件。 只要我们把 find 的输出作为 xargs 的输入，就必须将 -print0 与 find 结合使用，以字符null（&#39;\\0&#39;）来分隔输出。 12345$ find . -type f -name \"*.txt\" -print0 | xargs -0 rm -f# xargs -0将\\0作为输入定界符。$ find source_code_dir_path -type f -name \"*.c\" -print0 | xargs -0 wc -l# 统计源代码目录中所有C程序文件的行数 2.4 校验和与核实校验和（checksum）程序用来从文件中生成校验和密钥，然后利用这个校验和密钥核实文件的完整性。文件可以通过网络或任何存储介质分发到不同的地点。 最知名且使用最为广泛的校验和技术是md5sum和SHA-1。它们对文件内容使用相应的算法来生成校验和。 123456789101112$ md5sum filename68b329da9893e34099c7d8ad5cb9c940 filename$ md5sum filename &gt; file_sum.md5$ md5sum file1 file2 file3 ..$ md5sum -c file_sum.md5# 这个命令会输出校验和是否匹配的消息# 如果需要用所有的.md5信息来检查所有的文件，可以使用：$ md5sum -c *.md5 计算SAH-1串的命令是sha1sum。其用法和md5sum的非常相似。只需要把先前讲过的那些命令中的md5sum替换成sha1sum就行了，记住将输入文件名从file_sum.md5改为file_sum.sha1。 对目录进行校验： 123456789$ md5deep -rl directory_path &gt; directory.md5# -r使用递归的方式# -l使用相对路径。默认情况下， md5deep会输出文件的绝对路径# 或者也可以结合find来递归计算校验和：$ find directory_path -type f -print0 | xargs -0 md5sum &gt;&gt; directory.md5# 用下面的命令进行核实：$ md5sum -c directory.md5 2.4.1 加密工具与散列crypt、 gpg、 base64、 md5sum、 sha1sum 以及 openssl 的用法。 1）crypt是一个简单的加密工具，它从stdin接受一个文件以及口令作为输入，然后将加密数据输出到Stdout（因此要对输入、输出文件使用重定向）。 1234567$ crypt &lt;input_file &gt;output_fileEnter passphrase:# 它会要求输入一个口令。我们也可以通过命令行参数来提供口令。$ crypt PASSPHRASE &lt;input_file &gt;encrypted_file# 如果需要解密文件，可以使用：$ crypt PASSPHRASE -d &lt;encrypted_file &gt;output_file 2）gpg（GNU隐私保护）是一种应用广泛的工具，它使用加密技术来保护文件，以确保数据在送达目的地之前无法被读取。这里我们讨论如何加密、解密文件。 12345# 用gpg加密文件：$ gpg -c filename# 该命令采用交互方式读取口令，并生成filename.gpg。使用以下命令解密gpg文件：$ gpg filename.gpg# 该命令读取口令，然后对文件进行解密。 3）Base64是一组相似的编码方案，它将ASCII字符转换成以64为基数的形式，以可读的ASCII字符串来描述二进制数据。 base64命令可以用来编码/解码Base64字符串。要将文件编码为Base64格式，可以使用： 123456789$ base64 filename &gt; outputfile# 或者$ cat file | base64 &gt; outputfile# base64可以从stdin中进行读取。# 解码Base64数据：$ base64 -d file &gt; outputfile# 或者$ cat base64_file | base64 -d &gt; outputfile 4）md5sum与sha1sum都是单向散列算法，均无法逆推出原始数据。它们通常用于验证数据完整性或为特定数据生成唯一的密钥： 1234$ md5sum file8503063d5488c3080d4800ff50850dc9 file$ sha1sum file1ba02b66e2e557fede8f61b7df282cd0a27b816b file 这种类型的散列算法是存储密码的理想方案。密码使用其对应的散列值来存储。如果某个用户需要进行认证，读取该用户提供的密码并转换成散列值，然后将其与之前存储的散列值进行比对。如果相同，用户就通过认证，被允许访问；否则，就会被拒绝访问。 5）openssl 用openssl生成shadow密码。 shadow密码通常都是salt密码。所谓SALT就是额外的一个字符串，用来起一个混淆的作用，使加密更加不易被破解。 salt由一些随机位组成，被用作密钥生成函数的输入之一，以生成密码的salt散列值。 123$ opensslpasswd -1 -salt SALT_STRING PASSWORD$1$SALT_STRING$323VkWkSLHuhbt1zkSsUG.# 将SALT_STRING替换为随机字符串，并将PASSWORD替换成你想要使用的密码。 2.5 排序、唯一与重复1234567891011121314151617# 对一组文件进行排序：$ sort file1.txt file2.txt &gt; sorted.txt# 按照数字顺序进行排序：$ sort -n file.txt# 按照逆序进行排序：$ sort -r file.txt# 按照月份进行排序（依照一月，二月，三月……）：$ sort -M months.txt# 合并两个已排序过的文件：$ sort -m sorted1 sorted2# 找出已排序文件中不重复的行：$ sort file1.txt file2.txt | uniq 检查文件是否已经排序过： 12345678#!/bin/bash#功能描述：排序sort -C filename ;if [ $? -eq 0 ]; then echo Sorted;else echo Unsorted;fi -k 指定了排序应该按照哪一个键（key）来进行。键指的是列号，而列号就是执行排序时的依据。 -r 告诉sort命令按照逆序进行排序。例如： 12345678910111213# 依据第1列，以逆序形式排序$ sort -nrk 1 data.txt4 linux 10003 bsd 10002 winxp 40001 mac 2000# -nr表明按照数字，采用逆序形式排序# 依据第2列进行排序$ sort -k 2 data.txt3 bsd 10004 linux 10001 mac 20002 winxp 4000 有时文本中可能会包含一些像空格之类的不必要的多余字符。如果需要忽略这些字符，并以字典序进行排序，可以使用： 12$ sort -bd unsorted.txt# 选项-b用于忽略文件中的前导空白行，选项-d用于指明以字典序进行排序。 sort选项： 1234567891011121314151617181920212223-b：忽略每行前面开始出的空格字符；-c：检查文件是否已经按照顺序排序； -d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符； -f：排序时，将小写字母视为大写字母； -i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；-m：将几个排序号的文件进行合并； -M：将前面3个字母依照月份的缩写进行排序； -n：依照数值的大小排序； -o&lt;输出文件&gt;：将排序后的结果存入制定的文件； -r：以相反的顺序来排序； -t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符； +&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。 uniq选项： 1234567891011-c或——count：在每列旁边显示该行重复出现的次数； -d或--repeated：仅显示重复出现的行列； -f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位； -s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符； -u或——unique：仅显示出一次的行列； -w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。 wc选项： 12345678910111213-c或--bytes或——chars：只显示Bytes数； # 统计字符数-l或——lines：只显示列数； # 统计行数-w或——words：只显示字数。 # 统计单词数# 当不使用任何选项执行wc时，它会分别打印出文件的行数、单词数和字符数：$ wc file1435 15763 112200# 使用-L选项打印出文件中最长一行的长度：$ wc file -L205 2.6 临时文件命名与随机数123456789101112131415161718# 创建临时文件：$ filename=`mktemp`$ echo $filename/tmp/tmp.8xvhkjF5fH# 创建临时目录：$ dirname=`mktemp -d`$ echo $dirnametmp.NI8xzW7VRX# 如果仅仅是想生成文件名，又不希望创建实际的文件或目录，方法如下：$ tmpfile=`mktemp -u`$ echo $tmpfile/tmp/tmp.RsGmilRpcT# 根据模板创建临时文件名：$mktemp test.XXXtest.2tc 如果提供了定制模板， X会被随机的字符（字母或数字）替换。注意， mktemp正常工作的前提是保证模板中只少要有3个X。 2.7 split 分割文件和数据1234# 将文件分割成多个大小为10KB的文件$ split -b 10k data.file$ lsdata.file xaa xab xac xad xae xaf xag xah xai xaj 上面的命令将data.file分割成多个文件，每一个文件大小为10KB。这些文件以xab、 xac、 xad的形式命名。这表明它们都有一个字母后缀。如果想以数字为后缀，可以另外使用-d参数。此外，使用 -a length可以指定后缀长度： 123$ split -b 10k data.file -d -a 4$ lsdata.file x0009 x0019 x0029 x0039 x0049 x0059 x0069 x0079 除了k（KB）后缀，我们还可以使用M（MB）、 G（GB）、 c（byte）、 w（word）等后缀。 12345678910# 为分割后的文件指定文件名前缀 $ split -b 10k data.file -d -a 4 split_file$ lsdata.file split_file0002 split_file0005 split_file0008 strtok.csplit_file0000 split_file0003 split_file0006 split_file0009split_file0001 split_file0004 split_file0007# 如果不想按照数据块大小，而是需要根据行数来分割文件的话，可以使用 -l no_of_lines：$ split -l 10 data.file# 分割成多个文件，每个文件包含10行 csplit。它能够依据指定的条件和字符串匹配选项对日志文件进行分割。 12345678910111213141516171819$ cat server.logSERVER-1[connection] 192.168.0.1 success[connection] 192.168.0.2 failed[disconnect] 192.168.0.3 pending[connection] 192.168.0.4 successSERVER-2[connection] 192.168.0.1 failed[connection] 192.168.0.2 failed[disconnect] 192.168.0.3 success[connection] 192.168.0.4 failedSERVER-3[connection] 192.168.0.1 pending[connection] 192.168.0.2 pending[disconnect] 192.168.0.3 pending[connection] 192.168.0.4 failed$ csplit server.log /SERVER/ -n 2 -s &#123;*&#125; -f server -b \"%02d.log\" ; rm server00.log$ lsserver01.log server02.log server03.log server.log 有关这个命令的详细说明如下。 /SERVER/ 用来匹配某一行，分割过程即从此处开始。 /[REGEX]/ 表示文本样式。包括从当前行（第一行）直到（但不包括）包含“SERVER”的匹配行。 {*} 表示根据匹配重复执行分割，直到文件末尾为止。可以用{整数}的形式来指定分割执行的次数。 -s 使命令进入静默模式，不打印其他信息。 -n 指定分割后的文件名后缀的数字个数，例如01、 02、 03等。 -f 指定分割后的文件名前缀（在上面的例子中， server就是前缀）。 -b 指定后缀格式。例如%02d.log，类似于C语言中printf的参数格式。在这里文件名=前缀+后缀=server + %02d.log。 因为分割后的第一个文件没有任何内容（匹配的单词就位于文件的第一行中），所以我们删除了server00.log。 2.7.1 根据扩展名切分文件名$、借助 % 操作符可以轻松将名称部分从 “名称.扩展名” 这种格式中提取出来。 12345file_jpg=\"sample.jpg\"name=$&#123;file_jpg%.*&#125;echo File name is: $name输出结果：File name is: sample 将文件名的扩展名部分提取出来，这可以借助 # 操作符实现。 1234extension=$&#123;file_jpg#*.&#125;echo Extension is: jpg输出结果：Extension is: jpg ${VAR%.*} 的含义如下所述： 从 $VAR中删除位于 % 右侧的通配符（在前例中是.*）所匹配的字符串。通配符从右向左进行匹配。 给VAR赋值， VAR=sample.jpg。那么，通配符从右向左就会匹配到.jpg，因此，从 $VAR中删除匹配结果，就会得到输出sample。 %属于非贪婪（non-greedy）操作。它从右到左找出匹配通配符的最短结果。还有另一个操作符 %%，这个操作符与%相似，但行为模式却是贪婪的，这意味着它会匹配符合条件的最长的字符串。 操作符%%则用.*从右向左执行贪婪匹配（.fun.book.txt）。 ${VAR#*.} 的含义如下所述：从$VAR中删除位于#右侧的通配符（即在前例中使用的*.）所匹配的字符串。通配符从左向右进行匹配。和 %% 类似， #也有一个相对应的贪婪操作符 ##。 ##从左向右进行贪婪匹配，并从指定变量中删除匹配结果。 这里有个能够提取域名不同部分的实用案例。假定 URL=&quot;www.google.com&quot;： 12345678$ echo $&#123;URL%.*&#125; # 移除.*所匹配的最右边的内容www.google$ echo $&#123;URL%%.*&#125; # 将从右边开始一直匹配到最左边的*.移除（贪婪操作符）www$ echo $&#123;URL#*.&#125; # 移除*.所匹配的最左边的内容google.com$ echo $&#123;URL##*.&#125; # 将从左边开始一直匹配到最右边的*.移除（贪婪操作符）com 2.8 批量重命名和移动123456789101112131415# 将 *.JPG更名为 *.jpg：$ rename *.JPG *.jpg# 将文件名中的空格替换成字符“_”：$ rename 's/ /_/g' *# 转换文件名的大小写：$ rename 'y/A-Z/a-z/' *$ rename 'y/a-z/A-Z/' *# 将所有的 .mp3文件移入给定的目录：$ find path -type f -name \"*.mp3\" -exec mv &#123;&#125; target_dir \\;# 将所有文件名中的空格替换为字符“_”：$ find path -type f -exec rename 's/ /_/g' &#123;&#125; \\; 3 以文件之名3.1 生成任意大小的文件1$ dd if=/dev/zero of=junk.data bs=1M count=1 该命令会创建一个1MB大小的文件junk.data。来看一下命令参数： if代表输入文件（input file），of代表输出文件（output file）， bs代表以字节为单位的块大小（block size）， count代表需要被复制的块数。 使用dd命令时一定得留意，该命令运行在设备底层。要是你不小心出了岔子，搞不好会把磁盘清空或是损坏数据。所以一定要反复检查dd命令所用的语法是否正确，尤其是参数of=。 单元大小 代码 字节（1B） c 字（2B） w 块（512B） b 千字节（1024B） k 兆字节（1024KB） M 吉字节（1024MB） G ls -lS 对当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息。 3.2 文件权限、所有权和粘滞位用命令ls -l可以列出文件的权限： 123-rw-r--r-- 1 slynux slynux 2497 2010-02-28 11:22 bot.pydrwxr-xr-x 2 slynux slynux 4096 2010-05-27 14:31 a.py-rw-r--r-- 1 slynux slynux 539 2010-02-10 09:11 cl.pl -—— 普通文件。 d —— 目录。 c —— 字符设备。 b —— 块设备。 l —— 符号链接。 s —— 套接字。 p —— 管道。 123456789101112# 更改所有权$ chown user.group filename# 设置粘滞位# 要设置粘滞位，利用chmod将 +t应用于目录：$ chmod a+t directory_name# 以递归的方式设置权限$ chmod 777 . -R# 以递归的方式设置所有权$ chown user.group . -R 3.3 创建不可修改的文件chattr能够将文件设置为不可修改。 12345# 使用下列命令将一个文件设置为不可修改：$ chattr +i file# 如果需要使文件恢复可写状态，移除不可修改属性即可：$ chattr -i file 3.4 查找符号链接及其指向目标12345678910111213141516171819# 创建符号链接：$ ln -s target symbolic_link_name例如：$ ln -l -s /var/www/ ~/web#这个命令在已登录用户的home目录中创建了一个名为Web的符号链接。该链接指向/var/www。# 使用下面的命令来验证是否创建链接：$ ls -l weblrwxrwxrwx 1 slynux slynux 8 2010-06-25 21:34 web -&gt; /var/www# 打印出当前目录下的符号链接：$ ls -l | grep \"^l\"# 使用find打印当前目录以及子目录下的符号链接：$ find . -type l -print# 使用readlink打印出符号链接所指向的目标路径：$ readlink web/var/www 3.5 列举文件类型统计信息12345678# 用下面的命令打印文件类型信息：$ file filename$ file /etc/passwd/etc/passwd: ASCII text# 打印不包括文件名在内的文件类型信息：$ file -b filenameASCII text 3.6 使用环回文件1234567891011121314151617181920212223242526# 下面的命令可以创建一个1GB大小的文件：$ dd if=/dev/zero of=loobackfile.img bs=1G count=11024+0 records in1024+0 records out1073741824 bytes (1.1 GB) copied, 37.3155 s, 28.8 MB/s# 你会发现创建好的文件大小超过了1GB。这是因为硬盘作为块设备，其分配存储空间时是按照块大小的整数倍来进行的。# 用mkfs命令将1GB的文件格式化成ext4文件系统：$ mkfs.ext4 loopbackfile.img# 使用下面的命令检查文件系统：$ file loobackfile.imgloobackfile.img: Linux rev 1.0 ext4 filesystem data,UUID=c9d56c42-f8e6-4cbd-aeab-369d5056660a (extents) (large files) (huge files)# 现在就可以挂载环回文件了：$ mkdir /mnt/loopback$ mount -o loop loopbackfile.img /mnt/loopback# -o loop用来挂载环回文件系统。# 我们也可以手动来操作：$ losetup /dev/loop1 loopbackfile.img$ mount /dev/loop1 /mnt/loopback# 使用下面的方法进行卸载（umount）：$ umount mount_point 3.7 生成 ISO 文件及混合型 ISO123456789#用下面的命令从/dev/cdrom创建一个ISO镜像：$ cat /dev/cdrom &gt; image.iso#尽管可以奏效。但创建ISO镜像最好的方法还是使用dd工具：$ dd if=/dev/cdrom of=image.iso# mkisofs命令用于创建ISO文件系统。$ mkisofs -V \"Label\" -o image.iso source_dir/# 选项 -o指定了ISO文件的路径。 source_dir是作为ISO文件内容来源的目录路径，选项 -V指定了ISO文件的卷标。 3.8 diff命令12345678910111213141516171819202122232425262728293031323334- # 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。-a或--text # diff预设只会逐行比较文本文件。-b或--ignore-space-change # 不检查空格字符的不同。-B或--ignore-blank-lines # 不检查空白行。-c # 显示全部内文，并标出不同之处。-C或--context # 与执行\"-c-\"指令相同。-d或--minimal # 使用不同的演算法，以较小的单位来做比较。-D或ifdef # 此参数的输出格式可用于前置处理器巨集。-e或--ed # 此参数的输出格式可用于ed的script文件。-f或-forward-ed # 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。-H或--speed-large-files # 比较大文件时，可加快速度。-l或--ignore-matching-lines # 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。-i或--ignore-case # 不检查大小写的不同。-l或--paginate # 将结果交由pr程序来分页。-n或--rcs # 将比较结果以RCS的格式来显示。-N或--new-file # 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。-p # 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。-P或--unidirectional-new-file # 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。-q或--brief # 仅显示有无差异，不显示详细的信息。-r或--recursive # 比较子目录中的文件。-s或--report-identical-files # 若没有发现任何差异，仍然显示信息。-S或--starting-file # 在比较目录时，从指定的文件开始比较。-t或--expand-tabs # 在输出时，将tab字符展开。-T或--initial-tab # 在每行前面加上tab字符以便对齐。-u,-U或--unified= # 以合并的方式来显示文件内容的不同。-v或--version # 显示版本信息。-w或--ignore-all-space # 忽略全部的空格字符。-W或--width # 在使用-y参数时，指定栏宽。-x或--exclude # 不比较选项中所指定的文件或目录。-X或--exclude-from # 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件。-y或--side-by-side # 以并列的方式显示文件的异同之处。--help # 显示帮助。--left-column # 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。--suppress-common-lines # 在使用-y参数时，仅显示不同之处。 生成目录的差异信息 ： 1$ diff -Naur directory1 directory2 -N：将所有缺失的文件视为空文件。 -a：将所有文件视为文本文件。 -u：生成一体化输出。 -r：遍历目录下的所有文件。 12345678910111213# 生成patch文件$ diff -u version1.txt version2.txt &gt; version.patch# 用下列命令来进行修补：$ patch -p1 version1.txt &lt; version.patchpatching file version1.txt# version1.txt的内容现在和verson2.txt的内容一模一样。# 下面的命令可以撤销做出的修改：$ patch -p1 version1.txt &lt; version.patchpatching file version1.txtReversed (or previously applied) patch detected! Assume -R? [n] y# 修改被撤销 3.9 more、less、head与tail命令3.9.1 more文件内容输出查看工具123456789101112$ more [参数选项] [文件] # 参数如下： +num # 从第num行开始显示； -num # 定义屏幕大小，为num行； +/pattern # 从pattern 前两行开始显示； -c # 从顶部清屏然后显示； -d # 提示Press space to continue, 'q' to quit.（按空格键继续，按q键退出），禁用响铃功能； -l # 忽略Ctrl+l （换页）字符； -p # 通过清除窗口而不是滚屏来对文件进行换页。和-c参数有点相似； -s # 把连续的多个空行显示为一行； -u # 把文件内容中的下划线去掉退出more的动作指令是q 举例： 1234567891011# 显示提示，并从终端或控制台顶部显示；$ more -dc /etc/profile # 从profile的第4行开始显示；$ more +4 /etc/profile # 每屏显示4行；$ more -4 /etc/profile # 从profile中的第一个MAIL单词的前两行开始显示；$ more +/MAIL /etc/profile more 的动作指令： 123456789Enter # 向下n行，需要定义，默认为1行； Ctrl+f # 向下滚动一屏； 空格键 # 向下滚动一屏； Ctrl+b # 返回上一屏； = # 输出当前行的行号； :f # 输出文件名和当前行的行号； v # 调用vi编辑器； ! 命令 # 调用Shell，并执行命令； q # 退出more当我们查看某一文件时，想调用vi来编辑它，不要忘记了v动作指令，这是比较方便的； 其它命令通过管道和more结合的运用例子： 1$ ls -l /etc |more 3.9.2 less查看文件内容工具12345678910-c # 从顶部（从上到下）刷新屏幕，并显示文件内容。而不是通过底部滚动完成刷新； -f # 强制打开文件，二进制文件显示时，不提示警告； -i # 搜索时忽略大小写；除非搜索串中包含大写字母； -I # 搜索时忽略大小写，除非搜索串中包含小写字母； -m # 显示读取文件的百分比； -M # 显法读取文件的百分比、行号及总行数； -N # 在每行前输出行号； -p # pattern 搜索pattern；比如在/etc/profile搜索单词MAIL，就用 less -p MAIL /etc/profile -s # 把连续多个空白行作为一个空白行显示； -Q # 在终端下不响铃； less的动作命令： 123456789101112131415回车键 # 向下移动一行； y # 向上移动一行； 空格键 # 向下滚动一屏； b # 向上滚动一屏； d # 向下滚动半屏； h # less的帮助； u # 向上洋动半屏； w # 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示； g # 跳到第一行； G # 跳到最后一行； p # n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示； /pattern # 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词； v # 调用vi编辑器； q # 退出less !command # 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件； 3.9.3 headhead 是显示一个文件的内容的前多少行： 1$ head -n 10 /etc/profile 3.9.4 tailtail 是显示一个文件的内容的最后多少行： 1$ tail -n 5 /etc/profile 3.10 getopts 参数解析3.10.1 getopts（shell内置命令）1234$ type getoptgetopt 是 /usr/bin/getopt$ type getopts getopts 是 shell 内建 getopts不能直接处理长的选项（如：–prefix=/home等） 关于getopts的使用方法，可以man bash 搜索getopts。 getopts有两个参数，第一个参数是一个字符串，包括字符和“：”，每一个字符都是一个有效的选项，如果字符后面带有“：”，表示这个字符有自己的参数。getopts从命令中获取这些参数，并且删去了“-”，并将其赋值在第二个参数中，如果带有自己参数，这个参数赋值在 $OPTARG中。提供getopts的shell内置了 $OPTARG 这个变变，getopts修改了这个变量。 这里变量 $OPTARG 存储相应选项的参数，而 $OPTIND 总是存储原始 $* 中下一个要处理的元素位置。while getopts &quot;:a:bc&quot; opt #第一个冒号表示忽略错误；字符后面的冒号表示该选项必须有自己的参数 getopts后面的字符串就是可以使用的选项列表，每个字母代表一个选项，后面带:的意味着选项除了定义本身之外，还会带上一个参数作为选项的值，比如d:在实际的使用中就会对应-d 30，选项的值就是30；getopts字符串中没有跟随:的是开关型选项，不需要再指定值，相当于true/false，只要带了这个参数就是true。如果命令行中包含了没有在getopts列表中的选项，会有警告信息，如果在整个getopts字符串前面也加上个:，就能消除警告信息了。 两个特殊变量： 12$OPTIND # 特殊变量，option index，会逐个递增, 初始值为1$OPTARG # 特殊变量，option argument，不同情况下有不同的值 例子： 1234567891011121314151617echo $*while getopts \":a:bc\" optdo case $opt in a ) echo $OPTARG echo $OPTIND;; b ) echo \"b $OPTIND\";; c ) echo \"c $OPTIND\";; ? ) echo \"error\" exit 1;; esacdoneecho $OPTINDshift $(($OPTIND - 1))#通过shift $(($OPTIND - 1))的处理，$*中就只保留了除去选项内容的参数，可以在其后进行正常的shell编程处理了。echo $0echo $* 12345678$ ./getopts.sh -a 11 -b -c-a 11 -b -c113b 4c 55./getopts.sh 3.10.2 getopt（一个外部工具）具体用用法可以 man getopt -o 表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，如 -carg 而不能是 -c arg。 --long 表示长选项 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/bin/bash# A small example program for using the new getopt(1) program.# This program will only work with bash(1)# An similar program using the tcsh(1) script. language can be found# as parse.tcsh# Example input and output (from the bash prompt):# ./parse.bash -a par1 'another arg' --c-long 'wow!*\\?' -cmore -b \" very long \"# Option a# Option c, no argument# Option c, argument `more'# Option b, argument ` very long '# Remaining arguments:# --&gt; `par1'# --&gt; `another arg'# --&gt; `wow!*\\?'# Note that we use `\"$@\"' to let each command-line parameter expand to a# separate word. The quotes around `$@' are essential!# We need TEMP as the `eval set --' would nuke the return value of getopt.#-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项#如-carg 而不能是-c arg#--long表示长选项#\"$@\"在上面解释过# -n:出错时的信息# -- ：举一个例子比较好理解：#我们要创建一个名字为 \"-f\"的目录你会怎么办？# mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用# mkdir -- -f 这样-f就不会被作为选项。TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \\ -n 'example.bash' -- \"$@\"`if [ $? != 0 ] ; then echo \"Terminating...\" &gt;&amp;2 ; exit 1 ; fi# Note the quotes around `$TEMP': they are essential!#set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了eval set -- \"$TEMP\"#经过getopt的处理，下面处理具体选项。while true ; do case \"$1\" in -a|--a-long) echo \"Option a\" ; shift ;; -b|--b-long) echo \"Option b, argument \\`$2'\" ; shift 2 ;; -c|--c-long) # c has an optional argument. As we are in quoted mode, # an empty parameter will be generated if its optional # argument is not found. case \"$2\" in \"\") echo \"Option c, no argument\"; shift 2 ;; *) echo \"Option c, argument \\`$2'\" ; shift 2 ;; esac ;; --) shift ; break ;; *) echo \"Internal error!\" ; exit 1 ;; esacdoneecho \"Remaining arguments:\"for arg do echo '--&gt; '\"\\`$arg'\" ;done 123456$ ./getopt.sh --b-long abc -a -c33 remainOption b, argument `abc'Option aOption c, argument `33'Remaining arguments:--&gt; `remain' 3.11 只列出目录的各种方法123456789101112# 使用ls –d：$ ls -d */# 使用grep结合ls –F：$ ls -F | grep \"/$\"# 当使用-F时，所有的输出项都会添加上一个代表文件类型的字符，如@、 *、 |等。目录对应的是 / 字符。我们用grep只过滤那些以 /$ 作为行尾标记的输出项。# 使用grep结合ls –l：$ ls -l | grep \"^d\"# 使用find：$ find . -type d -maxdepth 1 -print 3.12 使用pushd和popd进行快速定位使用pushd和popd时，可以无视cd命令。 123456789101112131415161718# 压入并切换路径：$ pushd /var/www# 再压入下一个目录路径：$ pushd /usr/src# 用下面的命令查看栈内容：$ dirs/usr/src /var/www ~ /usr/share /etc0 1 2 3 4# 当你想切换到列表中任意一个路径时，将每条路径从0到n进行编号，然后使用你希望切换到的路径编号，例如：$ pushd +3# 这条命令会将栈进行翻转并切换到目录 /use/share。# 要删除最后添加的路径并把当前目录更改为上一级目录，可以使用以下命令：$ popd# 用popd +num可以从列表中移除特定的路径。num是从左到右，从0到n开始计数的。 3.13 tree打印目录树1234567891011# 重点标记出匹配某种样式的文件：$ tree PATH -P \"*.sh\" # 用一个目录路径代替PATH|-- home| |-- packtpub| | `-- automate.sh# 重点标记出除符合某种样式之外的那些文件：$ tree path -I PATTERN# 使用 -h选项同时打印出文件和目录的大小：$ tree -h 4 让文件飞4.1 正则表达式 正则表达式 描述 示例 ^ 行起始标记 ^tux 匹配以tux起始的行 $ 行尾标记 tux$ 匹配以tux结尾的行 . 匹配任意一个字符 Hack.匹配Hackl和Hacki，它只能匹配单个字符 [ ] 匹配包含在 [字符] 之中的任意一个字符 coo[kl] 匹配cook或cool [ ^ ] 匹配除 [^字符] 之外的任意一个字符 9[^01]匹配92、 93，但是不匹配91或90 [ - ] 匹配 [ ] 中指定范围内的任意一个字符 [1-5] 匹配从1～5的任意一个数字 ? 匹配之前的项1次或0次 colou?r 匹配color或colour，但是不能匹配colouur + 匹配之前的项1次或多次 Rollno-9+ 匹配Rollno-99、Rollno-9，但是不能匹配Rollno- * 匹配之前的项0次或多次 co*l 匹配cl、 col、 coool等 ( ) 创建一个用于匹配的子串 ma(tri)?x 匹配max或maxtrix {n} 匹配之前的项n次 [0-9]{3} 匹 配 任 意 一 个 三 位 数 ， [0-9]{3} 可 以 扩 展 为[0-9][0-9][0-9] {n, } 之前的项至少需要匹配n次 [0-9]{2,} 匹配任意一个两位或更多位的数字 {n, m} 指定之前的项所必需匹配的最小次数和最大次数 [0-9]{2,5} 匹配从两位数到五位数之间的任意一个数字 | 交替——匹配 | 两边的任意一项 Oct (1st | 2nd) 匹配Oct 1st或Oct 2nd \\ 转义符可以将上面介绍的特殊字符进行转义 a\\.b 匹配a.b，但不能匹配ajb。通过在 . 之间加上前缀 \\ ，从而忽略了 . 的特殊意义 正则表达式 描述 [:alnum:] 所有的字母和数字 [:alpha:] 所有字母 [:blank:] 水平制表符，空白等 [:cntrl:] 所有控制字符 [:digit:] 所有的数字 [:graph:] 所有可打印字符，不包括空格 [:lower:] 所有的小写字符 [:print:] 所有可打印字符，包括空格 [:punct:] 所有的标点字符 [:space:] 所有的横向或纵向的空白 [:upper:] 所有大写字母 4.2 grep命令1234567891011121314151617181920212223242526-a # 不要忽略二进制的数据。-A&lt;显示列数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之后的内容。-b # 在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。-B&lt;显示列数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前的内容。-c # 计算符合范本样式的列数。-C&lt;显示列数&gt;或-&lt;显示列数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。-d&lt;进行动作&gt; # 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。-e&lt;范本样式&gt; # 指定字符串做为查找文件内容的范本样式。-E # 将范本样式为延伸的普通表示法来使用。-f&lt;范本文件&gt; # 指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。-F # 将范本样式视为固定字符串的列表。-G # 将范本样式视为普通的表示法来使用。-h # 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。-H # 在显示符合范本样式的那一列之前，表示该列所属的文件名称。-i # 忽略字符大小写的差别。-l # 列出文件内容符合指定的范本样式的文件名称。-L # 列出文件内容不符合指定的范本样式的文件名称。-n # 在显示符合范本样式的那一列之前，标示出该列的列数编号。-q # 不显示任何信息。-r # 此参数的效果和指定“-d recurse”参数相同。-s # 不显示错误信息。-v # 反转查找。-V # 显示版本信息。-w # 只显示全字符合的列。-x # 只显示全列符合的列。-o # 只输出文件中匹配到的部分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 单个grep命令也可以对多个文件进行搜索：$ grep \"match_text\" file1 file2 file3 ...# grep -E选项——这意味着使用扩展（extended）正则表达式：$ grep -E \"[a-z]+\" filename# 或者$ egrep \"[a-z]+\" filename# 只输出文件中匹配到的文本部分，可以使用选项 -o：$ echo this is a line. | egrep -o \"[a-z]+\\.\"line.# 要打印除包含match_pattern行之外的所有行，选项-v可以将匹配结果进行反转（invert）。可使用：$ grep -v match_pattern file# 统计文件或文本中包含匹配字符串的行数：$ grep -c \"text\" filename10# 需要注意的是-c只是统计匹配行的数量，并不是匹配的次数。。例如：$ echo -e \"1 2 3 4\\nhello\\n5 6\" | egrep -c \"[0-9]\"2# 要文件中统计匹配项的数量，可以使用下面的技巧：$ echo -e \"1 2 3 4\\nhello\\n5 6\" | egrep -o \"[0-9]\" | wc -l6# 打印模式匹配所位于的字符或字节偏移：$ echo gnu is not unix | grep -b -o \"not\"7:not# 选项 -b总是和 -o配合使用。# 搜索多个文件并找出匹配文本位于哪一个文件中：$ grep -l linux sample1.txt sample2.txtsample1.txtsample2.txt# 和-l相反的选项是-L，它会返回一个不匹配的文件列表。# grep的选项-R和-r功能一样。# 忽略样式中的大小写$ echo hello world | grep -i \"HELLO\"hello# grep匹配多个样式$ echo this is a line of text | grep -e \"this\" -e \"line\" -othisline# 在grep搜索中指定或排除文件$ grep \"main()\" . -r --include *.&#123;c,cpp&#125; # 目录中递归搜索所有的 .c和 .cpp文件# 如果需要排除目录，可以使用 --exclude-dir选项。# 如果需要从文件中读取所需排除的文件列表，使用--exclude-from FILE。# 使用0值字节作为后缀的grep与xargs，为了指明输入的文件名是以0值字节（\\0）作为终止符，需要在xargs中使用-0。# grep使用-Z选项输出以0值字节作为终结符的文件名（\\0）。$ grep \"test\" file* -lZ | xargs -0 rm# -Z通常和 -l结合使用。# grep的静默输出# grep的静默选项（-q）来实现。在静默模式中， grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。# 要打印匹配某个结果之后的3行，使用 -A选项：$ seq 10 | grep 5 -A 35678# 要打印匹配某个结果之前的3行，使用 -B选项：$ seq 10 | grep 5 -B 32345# 要打印匹配某个结果之前以及之后的3行，使用-C选项：$ seq 10 | grep 5 -C 32345678# 如果有多个匹配，那么使用--作为各部分之间的定界符：$ echo -e \"a\\nb\\nc\\na\\nb\\nc\" | grep a -A 1ab--ab 4.3 cut 按列切分文件1234# 显示第2列和第3列：$ cut -f 2,3 filename# 记法 范围 N - 从第N个字节，字符或字段到行尾 N - M 从第N个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段 - M 第1个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段 结合下列选项将字段指定为某个范围内的字节或字符 ： -b ：表示字节 -c ：表示字符 -f ：用于定义字段 123456789101112131415161718$ cat range_fields.txtabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxy# 打印第1个到第5个字符：$ cut -c1-5 range_fields.txtabcdeabcdeabcdeabcde# 打印前2个字符：$ cut range_fields.txt -c -2abababab 4.4 sed 进行文本替换选项： 12345-e &lt;script&gt; # 以选项中指定的script来处理输入的文本文件-f &lt;script&gt; # 以选项中指定的script文件来处理输入的文本文件-h # 显示帮助-n # 仅显示script处理后的结果-V # 显示版本信息 命令： 1234567891011121314151617181920212223a\\ # 在当前行下面插入文本。i\\ # 在当前行上面插入文本。c\\ # 把选定的行改为新的文本。 d # 删除，删除选择的行。 D # 删除模板块的第一行。s # 替换指定字符 h 拷贝模板块的内容到内存中的缓冲区。 H # 追加模板块的内容到内存中的缓冲区。 g # 获得内存缓冲区的内容，并替代当前模板块中的文本。 G # 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 l # 列表不能打印字符的清单。 n # 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 N # 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 p # 打印模板块的行。 P(大写) 打印模板块的第一行。 q # 退出Sed。 b lable # 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 r file # 从file中读行。 t label # if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 T label # 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。w file # 写并追加模板块到file末尾。 W file # 写并追加模板块的第一行到file末尾。 ! # 表示后面的命令对所有没有被选定的行发生作用。 = # 打印当前行号码。 # 把注释扩展到下一个换行符以前。 sed 替换标记： 1234567g # 表示行内全面替换。p # 表示打印行。 w # 表示把行写入一个文件。 x # 表示互换模板块中的文本和缓冲区中的文本。 y # 表示把一个字符翻译为另外的字符（但是不用于正则表达式） \\1 # 子串匹配标记 &amp; # 已匹配字符串标记 sed 元字符集： 12345678910111213^ # 匹配行开始，如：/^sed/匹配所有以sed开头的行。$ # 匹配行结束，如：/sed$/匹配所有以sed结尾的行。 . # 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 * # 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 [] # 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 [^] # 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/ 匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。\\(..\\) # 匹配子串，保存匹配的字符，如s/(love)able/\\1rs，loveable被替换成lovers。 &amp; # 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 \\&lt; # 匹配单词的开始，如:/\\&lt;love/匹配包含以开头的单词的行。\\&gt; # 匹配单词的结束，如:/love\\&gt;/匹配包含以love结尾的单词的行。x\\&#123;m\\&#125; # 重复字符x，m次，如：/0\\&#123;5\\&#125;/匹配包含5个0的行。 x\\&#123;m,\\&#125; # 重复字符x，至少m次，如：/0\\&#123;5,\\&#125;/匹配至少有5个0的行。 x\\&#123;m,n\\&#125; # 重复字符x，至少m次，不多于n次，如：/0\\&#123;5,10\\&#125;/匹配5~10个0的行。 123456789101112131415161718192021222324252627282930313233343536373839# sed可以替换给定文本中的字符串。$ sed 's/pattern/replace_string/' file# 如果需要在替换的同时保存更改，可以使用-i选项$ sed -i 's/text/replace/' file# 后缀/g意味着sed会替换每一处匹配。但是有时候我们只需要从第n处匹配开始替换。对此，可以使用/Ng选项。$ sed 's/pattern/replace_string/g' file$ echo thisthisthisthis | sed 's/this/THIS/2g'thisTHISTHISTHIS$ echo thisthisthisthis | sed 's/this/THIS/3g'thisthisTHISTHIS# 字符/在sed中被作为定界符使用。我们可以像下面一样使用任意的定界符：$ sed 's:text:replace:g'$ sed 's|text|replace|g'# 当定界符出现在样式内部时，我们必须用前缀\\对它进行转义：$ sed 's|te\\|xt|replace|g'# \\|是一个出现在样式内部并经过转义的定界符。# 移除空白行$ sed '/^$/d' file# 已匹配字符串标记（&amp;）在sed中，我们可以用 &amp;标记匹配样式的字符串，这样就能够在替换字符串时使用已匹配的内容。$ echo this is an example | sed 's/\\w\\+/[&amp;]/g'[this] [is] [an] [example]# 正则表达式 \\w\\+ 匹配每一个单词，然后我们用[&amp;]替换它。 &amp; 对应于之前所匹配到的单词。# 组合多个表达式$ sed 'expression' | sed 'expression'# 它等价于$ sed 'expression; expression'# 或者$ sed -e 'expression' -e expression'# 引用。sed表达式通常用单引号来引用。双引号会通过对表达式求值来对其进行扩展。$ text=hello$ echo hello world | sed \"s/$text/HELLO/\"HELLO world 4.5 awk 进行高级文本处理4.5.1 awk 常用命令选项 -F fs fs指定输入分隔符，fs可以是字符串或正则表达式，如-F: -v var=value 赋值一个用户定义变量，将外部变量传递给awk -f scripfile 从脚本文件中读取awk命令 -m[fr] val 对val值设置内在限制，-mf 选项限制分配给val的最大块数目；-mr 选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。 4.5.2 awk 脚本基本结构1234$ awk 'BEGIN&#123; print \"start\" &#125; pattern&#123; commands &#125; END&#123; print \"end\" &#125;' file# 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：$ awk 'BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;' filename $ awk \"BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;\" filename 4.5.3 awk 的工作原理1$ awk 'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;' 第一步：执行 BEGIN{ commands } 语句块中的语句 第二步：从文件或标准输入(stdin)读取一行，然后执行 pattern{ commands } 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕 第三步：当读至输入流末尾时，执行 END{ commands } 语句块 4.5.4 awk 内置变量（预定义变量）说明： [A][N][P][G]表示第一个支持变量的工具，[A]=awk、[N]=nawk、[P]=POSIXawk、[G]=gawk 12345678910111213141516171819202122$n # 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 $0 # 这个变量包含执行过程中当前行的文本内容。 [N] ARGC # 命令行参数的数目。 [G] ARGIND # 命令行中当前文件的位置（从0开始算）。 [N] ARGV # 包含命令行参数的数组。 [G] CONVFMT # 数字转换格式（默认值为%.6g）。 [P] ENVIRON # 环境变量关联数组。 [N] ERRNO # 最后一个系统错误的描述。 [G] FIELDWIDTHS # 字段宽度列表（用空格键分隔）。 [A] FILENAME # 当前输入文件的名。 [P] FNR # 同NR，但相对于当前文件。 [A] FS # 字段分隔符（默认是任何空格）。 [G] IGNORECASE # 如果为真，则进行忽略大小写的匹配。 [A] NF # 表示字段数，在执行过程中对应于当前的字段数。 [A] NR # 表示记录数，在执行过程中对应于当前的行号。 [A] OFMT # 数字的输出格式（默认值是%.6g）。 [A] OFS # 输出字段分隔符（默认值是一个空格）。 [A] ORS # 输出记录分隔符（默认值是一个换行符）。 [A] RS # 记录分隔符（默认是一个换行符）。 [N] RSTART # 由match函数所匹配的字符串的第一个位置。 [N] RLENGTH # 由match函数所匹配的字符串的长度。 [N] SUBSEP # 数组下标分隔符（默认值是34）。 1234567891011121314151617181920212223242526272829$ echo -e \"line1 f2 f3nline2 f4 f5nline3 f6 f7\" | awk '&#123;print \"Line No:\"NR\", No of fields:\"NF, \"$0=\"$0, \"$1=\"$1, \"$2=\"$2, \"$3=\"$3&#125;' Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3 Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5 Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7# 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推：$ echo -e \"line1 f2 f3n line2 f4 f5\" | awk '&#123;print $NF&#125;' f3f5$ echo -e \"line1 f2 f3n line2 f4 f5\" | awk '&#123;print $(NF-1)&#125;' f2 f4# 打印每一行的第二和第三个字段：$ awk '&#123; print $2,$3 &#125;' filename# 统计文件中的行数：$ awk 'END&#123; print NR &#125;' filename# 一个每一行中第一个字段值累加的例子：$ seq 5 | awk 'BEGIN&#123; sum=0; print \"总和：\" &#125; &#123; print $1\"+\"; sum+=$1 &#125; END&#123; print \"等于\"; print sum &#125;' 总和： 1+ 2+ 3+ 4+ 5+ 等于 15 4.5.5 将外部变量值传递给awk借助 -v 选项，可以将外部值（并非来自stdin）传递给awk： 12345678910$ VAR=10000 $ echo | awk -v VARIABLE=$VAR '&#123; print VARIABLE &#125;'# 另一种传递外部变量方法：$ var1=\"aaa\" $ var2=\"bbb\" $ echo | awk '&#123; print v1,v2 &#125;' v1=$var1 v2=$var2# 当输入来自于文件时使用：$ awk '&#123; print v1,v2 &#125;' v1=$var1 v2=$var2 filename 4.5.6 awk 运算与判断算数运算符： 运算符 描述 + - 加、减 * / &amp; 乘，除与求余 + - ! 一元加、减和逻辑非 ^ *** 求幂 ++ – 增加或减少，作为前缀或后缀 12$ awk 'BEGIN&#123;a=\"b\";print a++,++a;&#125;' 0 2 **注意：**所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0 赋值运算符： 运算符 描述 = += -= = /= %= ^= *= 赋值语句 逻辑运算符： 运算符 描述 || 逻辑或 &amp;&amp; 逻辑与 12$ awk 'BEGIN&#123;a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);&#125;'0 1 正则运算符： 运算符 描述 ~ ~! 匹配正则表达式和不匹配正则表达式 12$ awk 'BEGIN&#123;a=\"100testa\";if(a ~ /^100*/)&#123;print \"ok\";&#125;&#125;' ok 关系运算符： 运算符 描述 &lt; &lt;= &gt; &gt;= != == 关系运算符 12$ awk 'BEGIN&#123;a=11;if(a &gt;= 9)&#123;print \"ok\";&#125;&#125;' ok **注意：**> < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。 其他运算符： 运算符 描述 $ 字段引用 空格 字符串连接符 ? : C条件表达式 in 数组中是否存在某键值 12345678$ awk 'BEGIN&#123;a=\"b\";print a==\"b\"?\"ok\":\"err\";&#125;' ok $ awk 'BEGIN&#123;a=\"b\";arr[0]=\"b\";arr[1]=\"c\";print (a in arr);&#125;' 0 $ awk 'BEGIN&#123;a=\"b\";arr[0]=\"b\";arr[\"b\"]=\"c\";print (a in arr);&#125;' 1 运算级优先级表： 级别 运算符 说明 1 =, +=, -=, *=, /=, %=, &amp;=, ^=, |=, &lt;&lt;=, &gt;&gt;= 赋值、运算 2 || 逻辑或 3 &amp;&amp; 逻辑与 4 | 按位或 5 ^ 按位异或 6 &amp; 按位与 7 ==, != 等于、不等于 8 &lt;=, &gt;=, &lt;, &gt; 小于等于、大于等于、小于、大于 9 &lt;&lt;, &gt;&gt; 按位左移，按位右移 10 +, - 加、减 11 *, /, % 乘、除、取模 12 !, ~ 逻辑非、按位取反或补码 13 -, + 正、负 级别越高越优先 4.5.7 awk 高级输入输出读取下一条记录： awk中 next 语句使用：在循环逐行匹配，如果遇到 next，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。net语句一般用于多行合并： 12345678910$ cat text.txt a b c d e $ awk 'NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;' text.txt 2 b 4 d 当记录行号除以2余1，就跳过当前行。下面的 print NR,$0 也不会执行。下一行开始，程序有开始判断 NR%2 值。这个时候记录行号是 ：2 ，就会执行下面语句块：&#39;print NR,$0&#39; 分析发现需要将包含有 “web” 行进行跳过，然后需要将内容与下面行合并为一行： 123456789101112131415161718192021$ cat text.txt web01[192.168.2.100] httpd ok tomcat ok sendmail ok web02[192.168.2.101] httpd ok postfix ok web03[192.168.2.102] mysqld ok httpd ok 0 $ awk '/^web/&#123;T=$0;next;&#125;&#123;print T\":t\"$0;&#125;' test.txt web01[192.168.2.100]: httpd ok web01[192.168.2.100]: tomcat ok web01[192.168.2.100]: sendmail ok web02[192.168.2.101]: httpd ok web02[192.168.2.101]: postfix ok web03[192.168.2.102]: mysqld ok web03[192.168.2.102]: httpd ok 简单地读取一条记录： awk getline 用法：输出重定向需用到 getline函数。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。 getline语法：getline var，变量var包含了特定行的内容。 awk getline从整体上来说，用法说明： 当其左右无重定向符 | 或 &lt; 时：getline作用于当前文件，读入当前文件的第一行给其后跟的变量 var 或 $0（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。 当其左右有重定向符 | 或 &lt; 时：getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。 12345678# 执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它：$ awk 'BEGIN&#123; \"date\" | getline out; print out &#125;' test# 执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，split函数把变量out转化成数组mon，然后打印数组mon的第二个元素：$ awk 'BEGIN&#123; \"date\" | getline out; split(out,mon); print mon[2] &#125;' test# 命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。$ awk 'BEGIN&#123; while( \"ls\" | getline) print &#125;' 关闭文件： awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。 1close(\"filename\") filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。 输出到一个文件： 123$ echo | awk '&#123;printf(\"hello word!n\") &gt; \"datafile\"&#125;'或 $ echo | awk '&#123;printf(\"hello word!n\") &gt;&gt; \"datafile\"&#125;' 4.5.8 设置字段定界符默认的字段定界符是空格，可以使用 `-F \"定界符\"` 明确指定一个定界符： 123$ awk -F: '&#123; print $NF &#125;' /etc/passwd 或 $ awk 'BEGIN&#123; FS=\":\" &#125; &#123; print $NF &#125;' /etc/passwd 在 BEGIN语句块 中则可以用 OFS=“定界符” 设置输出字段的定界符。 4.5.9 流程控制语句条件判断语句： 123456789101112$ awk 'BEGIN&#123; test=100; if(test&gt;90)&#123; print \"very good\"; &#125; else if(test&gt;60)&#123; print \"good\"; &#125; else&#123; print \"no pass\"; &#125; &#125;' very good 每条命令语句后面可以用 ; 分号结尾。 循环语句： while语句： 12345678910$ awk 'BEGIN&#123; test=100; total=0; while(i&lt;=test)&#123; total+=i; i++; &#125; print total; &#125;' 5050 for循环： 格式1： 12345678910111213$ awk 'BEGIN&#123; for(k in ENVIRON)&#123; print k\"=\"ENVIRON[k]; &#125; &#125;' TERM=linux G_BROKEN_FILENAMES=1 SHLVL=1 pwd=/root/text ... logname=root HOME=/root SSH_CLIENT=192.168.1.21 53087 22 注：ENVIRON是awk常量，是子典型数组。 格式2： 123456789$ awk 'BEGIN&#123; total=0; for(i=0;i&lt;=100;i++)&#123; total+=i; &#125; print total; &#125;' 5050 do循环： 12345678910$ awk 'BEGIN&#123; total=0; i=0; do &#123; total+=i;i++; &#125; while(i&lt;=100) print total; &#125;' 5050 其他语句： break 当 break 语句用于 while 或 for 语句时，导致退出程序循环 continue 当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代 next 能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程 exit 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行 4.5.10 数组应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 得到数组长度$ awk 'BEGIN&#123;info=\"it is a test\";lens=split(info,tA,\" \");print length(tA),lens;&#125;' 4 4# length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。# asort对数组进行排序，返回数组长度。$ awk 'BEGIN&#123;info=\"it is a test\";split(info,tA,\" \");print asort(tA);&#125;' 4# 输出数组内容（无序，有序输出）：$ awk 'BEGIN&#123;info=\"it is a test\";split(info,tA,\" \");for(k in tA)&#123;print k,tA[k];&#125;&#125;' 4 test 1 it 2 is 3 a # for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。$ awk 'BEGIN&#123;info=\"it is a test\";tlen=split(info,tA,\" \");for(k=1;k&lt;=tlen;k++)&#123;print k,tA[k];&#125;&#125;' 1 it 2 is 3 a 4 test# 注意：数组下标是从1开始，与C数组不一样。# 判断键值存在以及删除键值：$ awk 'BEGIN&#123;tB[\"a\"]=\"a1\";tB[\"b\"]=\"b1\";if( \"c\" in tB)&#123;print \"ok\";&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;' a a1 b b1# 删除键值： $ awk 'BEGIN&#123;tB[\"a\"]=\"a1\";tB[\"b\"]=\"b1\";delete tB[\"a\"];for(k in tB)&#123;print k,tB[k];&#125;&#125;' b b1# 二维、多维数组使用$ awk 'BEGIN&#123; for(i=1;i&lt;=9;i++)&#123; for(j=1;j&lt;=9;j++)&#123; tarr[i,j]=i*j; print i,\"*\",j,\"=\",tarr[i,j]; &#125; &#125; &#125;' 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 ... 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81# 可以通过array[k,k2]引用获得数组内容。# 另一种方法：$ awk 'BEGIN&#123; for(i=1;i&lt;=9;i++)&#123; for(j=1;j&lt;=9;j++)&#123; tarr[i,j]=i*j; &#125; &#125; for(m in tarr)&#123; split(m,tarr2,SUBSEP); print tarr2[1],\"*\",tarr2[2],\"=\",tarr[m]; &#125; &#125;' 4.5.11 内置函数awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数。 算数函数： 格式 描述 atan2( y, x ) 返回 y/x 的反正切 cos( x ) 返回 x 的余弦；x 是弧度 sin( x ) 返回 x 的正弦；x 是弧度 exp( x ) 返回 x 幂函数 log( x ) 返回 x 的自然对数 sqrt( x ) 返回 x 平方根 int( x ) 返回 x 的截断至整数的值 rand( ) 返回任意数字 n，其中 0 &lt;= n &lt; 1 srand( [expr] ) 将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。 12345678910$ awk 'BEGIN&#123;OFMT=\"%.3f\";fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;&#125;' 0.841 22026.466 2.303 3# 获得随机数：$ awk 'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;' 78 $ awk 'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;' 31 $ awk 'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;' 41 字符串函数： 格式 描述 gsub( Ere, Repl, [ In ] ) 除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行 sub( Ere, Repl, [ In ] ) 用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量） index( String1, String2 ) 在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零） length [(String)] 返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量） blength [(String)] 返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量） substr( String, M, [ N ] ) 返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度 match( String, Ere ) 在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一） split( String, A, [Ere] ) 将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建 tolower( String ) 返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义 toupper( String ) 返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义 sprintf(Format, Expr, Expr, . . . ) 根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串 注：Ere都可以是正则表达式。 1234567891011121314151617181920212223# gsub,sub使用 $ awk 'BEGIN&#123;info=\"this is a test2010test!\";gsub(/[0-9]+/,\"!\",info);print info&#125;' this is a test!test!# 查找字符串（index使用） $ awk 'BEGIN&#123;info=\"this is a test2010test!\";print index(info,\"test\")?\"ok\":\"no found\";&#125;' ok# 正则表达式匹配查找(match使用） $ awk 'BEGIN&#123;info=\"this is a test2010test!\";print match(info,/[0-9]+/)?\"ok\":\"no found\";&#125;' ok# 截取字符串(substr使用） $ awk 'BEGIN&#123;info=\"this is a test2010test!\";print substr(info,4,10);&#125;' s is a tes# 字符串分割（split使用） $ awk 'BEGIN&#123;info=\"this is a test\";split(info,tA,\" \");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;' 4 4 test 1 this 2 is 3 a 格式化字符串输出（sprintf使用） 格式化字符串格式： 格式 描述 %d 十进制有符号整数 %u 十进制无符号整数 %f 浮点数 %s 字符串 %c 单个字符 %p 指针的值 %e 指数形式的浮点数 %x %X 无符号以十六进制表示的整数 %o 无符号以八进制表示的整数 %g 自动选择合适的表示法 12$ awk 'BEGIN&#123;n1=124.113;n2=-1.224;n3=1.2345; printf(\"%.2f,%.2u,%.2g,%X,%on\",n1,n2,n3,n1,n1);&#125;' 124.11,18446744073709551615,1.2,7C,174 一般函数： 格式 描述 close( Expression ) 用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的 system(command ) 执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程 Expression | getline [ Variable ] 从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录 getline [ Variable ] &lt; Expression 从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录 getline [ Variable ] 将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量 12345678910111213141516171819202122# 打开外部文件（close用法） $ awk 'BEGIN&#123;while(\"cat /etc/passwd\"|getline)&#123;print $0;&#125;;close(\"/etc/passwd\");&#125;' root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin# 逐行读取外部文件(getline使用方法） $ awk 'BEGIN&#123;while(getline &lt; \"/etc/passwd\")&#123;print $0;&#125;;close(\"/etc/passwd\");&#125;' root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin $ awk 'BEGIN&#123;print \"Enter your name:\";getline name;print name;&#125;' Enter your name: chengmo chengmo# 调用外部应用程序(system使用方法） $ awk 'BEGIN&#123;b=system(\"ls -al\");print b;&#125;' total 42092 drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 . drwxr-xr-x 95 root root 4096 10-08 14:01 .. # b返回值，是执行结果。 时间函数： 格式 描述 函数名 说明 mktime( YYYY MM dd HH MM ss[ DST]) 生成时间格式 strftime([format [, timestamp]]) 格式化时间输出，将时间戳转为时间字符串 具体格式，见下表. systime() 得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数 12345678910# 建指定时间(mktime使用） $ awk 'BEGIN&#123;tstamp=mktime(\"2001 01 01 12 12 12\");print strftime(\"%c\",tstamp);&#125;' 2001年01月01日 星期一 12时12分12秒 $ awk 'BEGIN&#123;tstamp1=mktime(\"2001 01 01 12 12 12\");tstamp2=mktime(\"2001 02 01 0 0 0\");print tstamp2-tstamp1;&#125;' 2634468 # 求2个时间段中间时间差，介绍了strftime使用方法 $ awk 'BEGIN&#123;tstamp1=mktime(\"2001 01 01 12 12 12\");tstamp2=systime();print tstamp2-tstamp1;&#125;' 308201392 strftime日期和时间格式说明符 格式 描述 %a 星期几的缩写（Sun） %A 星期几的完整写法（Sunday） %b 月名的缩写（Oct） %B 月名的完整写法（October） %c 本地日期和时间 %d 十进制日期 %D 日期 08/20/99 %e 日期，如果只有一位会补上一个空格 %H 用十进制表示24小时格式的时间 %I 用十进制表示12小时格式的时间 %j 从1月1日期一年中的第几天 %m 十进制表示的月份 %M 十进制表示的分钟 %p 12小时表示法（AM/PM） %S 十进制表示的秒 %U 十进制表示的一年中的第几个星期（星期天作为一个星期的开始） %w 十进制表示的星期几（星期天是0） %W 十进制表示的一年中的第几个星期（星期一作为一个星期的开始） %x 重新设置本地日期（08/20/99） %X 重新设置本地时间（12 : 00 : 00） %y 两位数字表示的年（99） %Y 当前月份 %Z 时区（PDT） %% 百分号（%） 4.6 find 对目录中的所有文件进行文本替换12345# 将所有.cpp文件中的Copyright替换成Copyleft：$ find . -name *.cpp -print0 | xargs -I&#123;&#125; -0 sed -i 's/Copyright/Copyleft/g' &#123;&#125;# 选项-exec实现同样的效果：$ find . -name *.cpp -exec sed -i 's/Copyright/Copyleft/g' \\&#123;\\&#125; \\; 5 一团乱麻5.1 wget命令12345678910111213141516171819202122-a&lt;日志文件&gt;： # 在指定的日志文件中记录资料的执行过程； -A&lt;后缀名&gt;： # 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔； -b： # 进行后台的方式运行wget； -B&lt;连接地址&gt;： # 设置参考的连接地址的基地地址； -c： # 继续执行上次终端的任务； -C&lt;标志&gt;： # 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； -d： # 调试模式运行指令； -D&lt;域名列表&gt;： # 设置顺着的域名列表，域名之间用“，”分隔； -e&lt;指令&gt;： # 作为文件“.wgetrc”中的一部分执行指定的指令； -h： # 显示指令帮助信息； -i&lt;文件&gt;： # 从指定文件获取要下载的URL地址； -l&lt;目录列表&gt;： # 设置顺着的目录列表，多个目录用“，”分隔； -L： # 仅顺着关联的连接； -r： # 递归下载方式； -nc： # 文件存在时，下载文件不覆盖原有文件； -nv： # 下载时只显示更新和出错信息，不显示指令的详细执行过程； -q： # 不显示指令执行过程； -nh： # 不查询主机名称； -v： # 显示详细执行过程； -V： # 显示版本信息； --passive-ftp： # 使用被动模式PASV连接FTP服务器； --follow-ftp： # 从HTML文件中下载FTP连接文件。 12345678910111213141516171819202122# 使用wget下载单个文件 $ wget http://www.linuxde.net/testfile.zip# 下载并以不同的文件名保存 $ wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080# wget限速下载 $ wget --limit-rate=300k http://www.linuxde.net/testfile.zip# 使用wget断点续传 $ wget -c http://www.linuxde.net/testfile.zip# 使用wget后台下载 $ wget -b http://www.linuxde.net/testfile.zip Continuing in background, pid 1840. Output will be written to `wget-log'.# 对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载，你可以使用以下命令来察看下载进度： $ tail -f wget-log# 伪装代理名称下载 $ wget --user-agent=\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16\" http://www.linuxde.net/testfile.zip# 有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装。 测试下载链接： 当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 1$ wget --spider URL 如果下载链接正确，将会显示: 12345Spider mode enabled. Check if remote file exists. HTTP request sent, awaiting response... 200 OK Length: unspecified [text/html] Remote file exists and could contain further links, but recursion is disabled -- not retrieving. 这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误: 1234$ wget --spider url Spider mode enabled. Check if remote file exists. HTTP request sent, awaiting response... 404 Not Found Remote file does not exist -- broken link!!! 你可以在以下几种情况下使用–spider参数： 定时下载之前进行检查 间隔检测网站是否可用 检查网站页面的死链接 123456789101112131415161718192021222324# 增加重试次数 $ wget --tries=40 URL# 下载多个文件 $ wget -i filelist.txt # 首先，保存一份下载链接文件： $ cat &gt; filelist.txt url1 url2 url3 url4 # 接着使用这个文件和参数-i下载。# 过滤指定格式下载 $ wget --reject=gif ur # 下载一个网站，但你不希望下载图片，可以使用这条命令。# 把下载信息存入日志文件 $ wget -o download.log URL # 不希望下载信息直接显示在终端而是在一个日志文件，可以使用。 # 限制总下载文件大小 $ wget -Q5m -i filelist.txt # 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。 镜像网站： 1$ wget --mirror -p --convert-links -P ./LOCAL URL 下载整个网站到本地。 –mirror 开户镜像下载 -p 下载所有为了html页面显示正常的文件 –convert-links 下载后，转换成本地的链接 -P ./LOCAL URL 保存所有文件和目录到本地指定目录 下载指定格式文件： 1$ wget -r -A.pdf url 可以在以下情况使用该功能： 下载一个网站的所有图片 下载一个网站的所有视频 下载一个网站的所有PDF文件 FTP下载： 12$ wget ftp-url $ wget --ftp-user=USERNAME --ftp-password=PASSWORD url 可以使用wget来完成ftp链接的下载。 使用wget匿名ftp下载： 1$ wget ftp-url 使用wget用户名和密码认证的ftp下载： 1$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url 5.2 curl 命令常见参数： 12345678910111213141516-A/--user-agent &lt;string&gt; # 设置用户代理发送给服务器-b/--cookie &lt;name=string/file&gt; # cookie字符串或文件读取位置-c/--cookie-jar &lt;file&gt; # 操作结束后把cookie写入到这个文件中-C/--continue-at &lt;offset&gt; # 断点续转-D/--dump-header &lt;file&gt; # 把header信息写入到该文件中-e/--referer # 来源网址-f/--fail # 连接失败时不显示http错误-o/--output # 把输出写到该文件中-O/--remote-name # 把输出写到该文件中，保留远程文件的文件名-r/--range &lt;range&gt; # 检索来自HTTP/1.1或FTP服务器字节范围-s/--silent # 静音模式。不输出任何东西-T/--upload-file &lt;file&gt; # 上传文件-u/--user &lt;user[:password]&gt; # 设置服务器的用户和密码-w/--write-out [format] # 什么输出完成后-x/--proxy &lt;host[:port]&gt; # 在给定的端口上使用HTTP代理-#/--progress-bar # 进度条显示当前的传送状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 不显示进度信息使用--silent选项。$ curl URL --silent# 使用选项 -O 将下载的数据写入到文件，必须使用文件的绝对地址：$ curl http://man.linuxde.net/text.iso --silent -O# 选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条：$ curl http://man.linuxde.net/test.iso -o filename.iso --progress######################################### 100.0%# 断点续传$ curl URL/File -C 偏移量 # 偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -： $ curl -C -URL# 使用--referer选项指定参照页字符串： $ curl --referer http://www.google.com http://man.linuxde.net # 用curl设置cookies 使用--cookie \"COKKIES\"选项来指定cookie，多个cookie使用分号分隔： $ curl http://man.linuxde.net --cookie \"user=root;pass=123456\" # 将cookie另存为一个文件，使用--cookie-jar选项： $ curl URL --cookie-jar cookie_file # 用curl设置用户代理字符串 有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用--user-agent或者-A选项：$ curl URL --user-agent \"Mozilla/5.0\" curl URL -A \"Mozilla/5.0\" # 其他HTTP头部信息也可以使用curl来发送，使用-H\"头部信息\" 传递多个头部信息，例如： $ curl -H \"Host:man.linuxde.net\" -H \"accept-language:zh-cn\" URL # curl的带宽控制和下载配额 使用--limit-rate限制curl的下载速度： $ curl URL --limit-rate 50k # 命令中用k（千字节）和m（兆字节）指定下载速度限制。 # 使用--max-filesize指定可下载的最大文件大小： $ curl URL --max-filesize bytes # 如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。 # 用curl进行认证 使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码： $ curl -u user:pwd http://man.linuxde.net $ curl -u user http://man.linuxde.net # 只打印响应头部信息 通过-I或者-head可以只打印出HTTP头部信息： $ curl -I http://man.linuxde.net HTTP/1.1 200 OK Server: nginx/1.2.5 date: Mon, 10 Dec 2012 09:24:34 GMT Content-Type: text/html; charset=UTF-8 Connection: keep-alive Vary: Accept-Encoding X-Pingback: http://man.linuxde.net/xmlrpc.php 其他参数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192-a/--append # 上传文件时，附加到目标文件--anyauth # 可以使用“任何”身份验证方法--basic # 使用HTTP基本验证-B/--use-ascii # 使用ASCII文本传输-d/--data &lt;data&gt; # HTTP POST方式传送数据--data-ascii &lt;data&gt; # 以ascii的方式post数据--data-binary &lt;data&gt; # 以二进制的方式post数据--negotiate # 使用HTTP身份验证--digest # 使用数字身份验证--disable-eprt # 禁止使用EPRT或LPRT--disable-epsv # 禁止使用EPSV--egd-file &lt;file&gt; # 为随机数据(SSL)设置EGD socket路径--tcp-nodelay # 使用TCP_NODELAY选项-E/--cert &lt;cert[:passwd]&gt; # 客户端证书文件和密码 (SSL)--cert-type &lt;type&gt; # 证书文件类型 (DER/PEM/ENG) (SSL)--key &lt;key&gt; # 私钥文件名 (SSL)--key-type &lt;type&gt; # 私钥文件类型 (DER/PEM/ENG) (SSL)--pass &lt;pass&gt; # 私钥密码 (SSL)--engine &lt;eng&gt; # 加密引擎使用 (SSL). \"--engine list\" for list--cacert &lt;file&gt; # CA证书 (SSL)--capath &lt;directory&gt; # CA目 (made using c_rehash) to verify peer against (SSL)--ciphers &lt;list&gt; # SSL密码--compressed # 要求返回是压缩的形势 (using deflate or gzip)--connect-timeout &lt;seconds&gt; # 设置最大请求时间--create-dirs # 建立本地目录的目录层次结构--crlf # 上传是把LF转变成CRLF--ftp-create-dirs # 如果远程目录不存在，创建远程目录--ftp-method [multicwd/nocwd/singlecwd] # 控制CWD的使用--ftp-pasv # 使用 PASV/EPSV 代替端口--ftp-skip-pasv-ip # 使用PASV的时候,忽略该IP地址--ftp-ssl # 尝试用 SSL/TLS 来进行ftp数据传输--ftp-ssl-reqd # 要求用 SSL/TLS 来进行ftp数据传输-F/--form &lt;name=content&gt; # 模拟http表单提交数据-form-string &lt;name=string&gt; # 模拟http表单提交数据-g/--globoff # 禁用网址序列和范围使用&#123;&#125;和[]-G/--get # 以get的方式来发送数据-h/--help # 帮助-H/--header &lt;line&gt; # 自定义头信息传递给服务器--ignore-content-length # 忽略的HTTP头信息的长度-i/--include # 输出时包括protocol头信息-I/--head # 只显示文档信息-j/--junk-session-cookies # 读取文件时忽略session cookie--interface &lt;interface&gt; # 使用指定网络接口/地址--krb4 &lt;level&gt; # 使用指定安全级别的krb4-k/--insecure # 允许不使用证书到SSL站点-K/--config # 指定的配置文件读取-l/--list-only # 列出ftp目录下的文件名称--limit-rate &lt;rate&gt; # 设置传输速度--local-port&lt;NUM&gt; # 强制使用本地端口号-m/--max-time &lt;seconds&gt; # 设置最大传输时间--max-redirs &lt;num&gt; # 设置最大读取的目录数--max-filesize &lt;bytes&gt; # 设置最大下载的文件总量-M/--manual # 显示全手动-n/--netrc # 从netrc文件中读取用户名和密码--netrc-optional # 使用 .netrc 或者 URL来覆盖-n--ntlm # 使用 HTTP NTLM 身份验证-N/--no-buffer # 禁用缓冲输出-p/--proxytunnel # 使用HTTP代理--proxy-anyauth # 选择任一代理身份验证方法--proxy-basic # 在代理上使用基本身份验证--proxy-digest # 在代理上使用数字身份验证--proxy-ntlm # 在代理上使用ntlm身份验证-P/--ftp-port &lt;address&gt; # 使用端口地址，而不是使用PASV-Q/--quote &lt;cmd&gt; # 文件传输前，发送命令到服务器--range-file # 读取（SSL）的随机文件-R/--remote-time # 在本地生成文件时，保留远程文件时间--retry &lt;num&gt; # 传输出现问题时，重试的次数--retry-delay &lt;seconds&gt; # 传输出现问题时，设置重试间隔时间--retry-max-time &lt;seconds&gt; # 传输出现问题时，设置最大重试时间-S/--show-error # 显示错误--socks4 &lt;host[:port]&gt; # 用socks4代理给定主机和端口--socks5 &lt;host[:port]&gt; # 用socks5代理给定主机和端口-t/--telnet-option &lt;OPT=val&gt; # Telnet选项设置--trace &lt;file&gt; # 对指定文件进行debug--trace-ascii &lt;file&gt; # Like --跟踪但没有hex输出--trace-time # 跟踪/详细输出时，添加时间戳--url &lt;URL&gt; # Spet URL to work with-U/--proxy-user &lt;user[:password]&gt; # 设置代理用户名和密码-V/--version # 显示版本信息-X/--request &lt;command&gt; # 指定什么命令-y/--speed-time # 放弃限速所要的时间。默认为30-Y/--speed-limit # 停止传输速度的限制，速度时间'秒-z/--time-cond # 传送时间设置-0/--http1.0 # 使用HTTP 1.0-1/--tlsv1 # 使用TLSv1（SSL）-2/--sslv2 # 使用SSLv2的（SSL）-3/--sslv3 # 使用的SSLv3（SSL）--3p-quote # like -Q for the source URL for 3rd party transfer--3p-url # 使用url，进行第三方传送--3p-user # 使用用户名和密码，进行第三方传送-4/--ipv4 # 使用IP4-6/--ipv6 # 使用IP6 5.3 curl wget两种方法模拟http的get post请求get请求： 12345# 使用curl命令：$ curl \"http://www.baidu.com\" # 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地$ curl -i \"http://www.baidu.com\" # 显示全部信息$ curl -l \"http://www.baidu.com\" # 只显示头部信息$ curl -v \"http://www.baidu.com\" # 显示get请求全过程解析 12# 使用wget命令：$ wget \"http://www.baidu.com\" post请求： 12# 使用curl命令(通过-d参数，把访问参数放在里面)：$ curl -d \"param1=value1&amp;param2=value2\" \"http://www.baidu.com\" 12# 使用wget命令：（--post-data参数来实现）$ wget --post-data 'user=foo&amp;password=bar' http://server.com/auth.PHP 6 B计划6.1 用tar归档tar支持的参数包括： A、 c、 d、 r、 u、 x、 f 和 v 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 用tar对文件进行归档：$ tar -cf output.tar file1 file2 file3 folder1 ..# 使用选项-t列出归档文件中所包含的文件：$ tar -tf archive.tarfile1file2# 如果需要在归档或列出归档文件列表时获知更多的细节信息，可以使用-v或-vv参数$ $ tar -tvf archive.tar-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file1-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file2# 文件名必须紧跟在-f之后，而且-f应该是选项中的最后一个。# 向归档文件中添加文件,追加选项-r$ tar -rvf original.tar new_file# 用下面的方法列出归档文件中的内容：$ tar -tf archive.tarhello.txt# 从归档文件中提取文件或文件夹, -x 表示提取$ tar -xf archive.tar# 用选项-C来指定需要将文件提取到哪个目录：$ tar -xf archive.tar -C /path/to/extraction_directory# 可以通过将文件名指定为命令行参数来提取特定的文件：$ tar -xvf file.tar file1 file4# 上面的命令只提取file1和file4，忽略其他文件。# 在tar中使用stdin和stdout$ tar cvf - files/ | ssh user@example.com \"tar xv -C Documents/\"# 在上面的例子中，对files目录中的内容进行了归档并输出到stdout（由'-'指明）。# 拼接两个归档文件, -A 选项轻松地合并多个tar文件$ tar -Af file1.tar file2.tar# 查看内容，验证操作是否成功：$ tar -tvf file1.tar# 通过检查时间戳来更新归档文件中的内容# 可以用更新选项-u指明：只有比归档文件中的同名文件更新时才会被添加。$ tar -tf archive.tarfileafilebfilec# 仅当filea自上次被加入archive.tar后出现了变动才对其进行追加，可以使用：$ tar -uf archive.tar filea# 如果两个filea的时间戳相同，则什么都不会发生。# 可用touch命令修改文件的时间戳，然后再用tar命令：$ tar -uvvf archive.tar filea-rw-r--r-- slynux/slynux 0 2010-08-14 17:53 filea# 比较归档文件与文件系统中的内容, 选项 -d 可以打印出两者之间的差别：$ tar -df archive.tarafile: Mod time differsafile: Size differs# 从归档文件中删除文件, --delete选项从给定的归档文件中删除文件$ tar -tf archive.tarfileafilebfilec# 删除filea：$ tar --delete --file archive.tar filea$ tar -tf archive.tarfilebfilec 压缩tar归档文件： 归档文件通常被压缩成下列格式之一： file.tar.gz file.tar.bz2 file.tar.lzma 不同的tar选项可以用来指定不同的压缩格式： -j 指定bunzip2格式； -z 指定gzip格式； –lzma 指定lzma格式。 12345678910111213141516171819# 为了让tar支持根据扩展名自动进行压缩，使用 -a或 --auto-compress选项：$ tar acvf archive.tar.gz filea fileb filec# 从归档中排除部分文件, --exclude [PATTERN]排除匹配通配符样式的文件$ tar -cf arch.tar * --exclude \"*.txt\"# 样式应该使用双引号来引用，避免shell对其进行扩展。# 也可以将需要排除的文件列表放入文件中，同时配合选项 -X：$ cat listfileafileb$ tar -cf arch.tar * -X list# 排除版本控制目录， 可以使用tar的 --exclude-vcs选项。例如：$ tar --exclude-vcs -czvvf source_code.tar.gz eye_of_gnome_svn# 打印总字节数，用–totals就可以在归档完成之后打印出总归档字节数：$ tar -cf arc.tar * --exclude \"*.txt\" --totalsTotal bytes written: 20480 (20KiB, 12MiB/s) 6.2 用cpio归档1234567891011# 创建测试文件：$ touch file1 file2 file3# 将测试文件按照下面的方法进行归档：$ echo file1 file2 file3 | cpio -ov &gt; archive.cpio# 列出cpio归档文件中的内容：$ cpio -it &lt; archive.cpio# 从cpio归档文件中提取文件：$ cpio -id &lt; archive.cpio 对于归档命令： -o 指定了输出； -v 用来打印归档文件列表。 在列出给定cpio归档文件所有内容的命令中： -i 用于指定输入； -t 表示列出归档文件中的内容。 当使用命令进行提取时， -d用来表示提取。 cpio在覆盖文件时不会发出提示。 6.3 使用gzip压缩数据12345678910111213141516171819# 要使用gzip压缩文件，可以使用下面的命令：$ gzip filename$ lsfilename.gz# 将gzip文件解压缩的方法如下：$ gunzip filename.gz$ lsfile# 列出压缩文件的属性信息：$ gzip -l test.txt.gzcompressed uncompressed ratio uncompressed_name35 6 -33.3% test.txt# gzip命令可以从stdin中读入文件，也可以将压缩文件写出到stdout，选项 -c用来将输出指定到stdout。$ cat file | gzip -c &gt; file.gz# 我们可以指定gzip的压缩级别。用 --fast或 --best选项分别提供最低或最高的压缩比。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 压缩归档文件# 方法 1$ tar -czvvf archive.tar.gz [FILES]或者$ tar -cavvf archive.tar.gz [FILES]# 选项 -a表明从文件扩展名自动推断压缩格式。# 方法 2# 首先，创建一个tar归档文件：$ tar -cvvf archive.tar [FILES]# 压缩tar归档文件：$ gzip archive.tar# zcat——无需解压缩，直接读取gzip格式文件$ lstest.gz$ zcat test.gzA test file# 文件test包含了一行文本\"A test file\"$ lstest.gz# 压缩率# 我们可以指定压缩率，它共有9级，其中：# 1级的压缩率最低，但是压缩速度最快；# 9级的压缩率最高，但是压缩速度最慢。$ gzip -5 test.img# 这应该能在压缩速度和压缩比之间获得一个不错的平衡。# 使用bzip2，唯一的不同在于bzip2的压缩效率比gzip更高，但花费的时间比gzip更长$ bzip2 filename# 解压缩bzip2格式的文件：$ bunzip2 filename.bz2# 生成tar.bz2文件并从中提取内容的方法同之前介绍的tar.gz类似：$ tar -xjvf archive.tar.bz2# 其中-j表明该归档文件是bzip2格式。# 使用lzma# lzma是另一种压缩工具，它的压缩率甚至比gzip和bzip2更好。$ lzma filename# 解压缩lzma文件：$ unlzma filename.lzma# 可以使用tar命令的--lzma选项对生成的tar归档文件进行压缩或提取：$ tar -cvvf --lzma archive.tar.lzma [FILES]或者$ tar -cavvf archive.tar.lzma [FILES]# 如果要将经过lzma压缩过的tar归档文件中的内容提取到指定的目录中，可以使用：$ tar -xvvf --lzma archive.tar.lzma -C extract_directory# 其中， -x用于提取内容， --lzma指定使用lzma对归档文件进行解压缩。# 我们也可以用：$ tar -xavvf archive.tar.lzma -C extract_directory 6.4 用 zip 归档和压缩123456789101112131415161718# 对归档文件采用ZIP格式进行压缩：$ zip file.zip file# 对目录和文件进行递归操作, -r 用于指定递归操作：$ zip -r archive.zip folder1 folder2# 要从ZIP文件中提取内容，可以使用：$ unzip file.zip# 在完成提取操作之后， unzip并不会删除file.zip# 如果需要更新压缩文件中的内容，使用选项 -u：$ zip file.zip -u newfile# 从压缩文件中删除内容，则使用-d：$ zip -d arc.zip file.txt# 列出压缩文件中的内容：$ unzip -l archive.zip 6.5 更快的归档工具 pbzip2123456789101112131415161718192021# 压缩单个文件：$ pbzip2 myfile.tar# pbzip2会自动检测系统中处理器核心的数量，然后将myfile.tar压缩成myfile.tar.bz2。# 要将多个文件或目录进行归档及压缩，可以使用tar配合pbzip2来实现：$ tar cf myfile.tar.bz2 --use-compress-prog=pbzip2 dir_to_compress/或者$ tar -c directory_to_compress/ | pbzip2 -c &gt; myfile.tar.bz2# 从pbzip2格式的文件中进行提取。# 如果是tar.bz2文件，我们可以一次性完成解压缩和提取工作：$ pbzip2 -dc myfile.tar.bz2 | tar x# 如果是经过pbzip2压缩过的归档文件，可以使用：$ pbzip2 -d myfile.tar.bz2# 手动指定处理器数量, 使用pbzip2的-p选项来手动指定处理器核心的数量$ pbzip2 -p4 myfile.tar# 上面的命令告诉pbzip2使用4个处理器核心。# 指定压缩比# 像其他压缩工具一样，我们可以使用从1到9的选项来分别指定最快和最优的压缩比。 6.6 创建压缩文件系统squashfs是一种具有超高压缩率的只读型文件系统，这种文件系统能够将2GB~3GB的数据压缩成一个700MB的文件。 123456789101112131415161718# 添加源目录和文件，创建一个squashfs文件：$ sudo mksquashfs /etc test.squashfsParallel mksquashfs: Using 2 processorsCreating 4.0 filesystem on test.squashfs, block size 131072.[=======================================] 1867/1867 100%# 利用环回形式挂载squashfs文件：$ mkdir /mnt/squash$ mount -o loop compressedfs.squashfs /mnt/squash# 你可以访问/mnt/squashfs访问其中的内容。# 在创建squashfs文件时排除部分文件, 选项-e，将需要排除的文件列表以命令行参数的方式来指定。例如：$ sudo mksquashfs /etc test.squashfs -e /etc/passwd /etc/shadow# 也可以将需要排除的文件名列表写入文件，然后用 -ef指定该文件：$ cat excludelist/etc/passwd/etc/shadow$ sudo mksquashfs /etc test.squashfs -ef excludelist 6.7 使用 rsync 备份系统快照rsync可以对位于不同位置的文件和目录进行同步，它利用差异计算以及压缩技术来最小化数据传输量。 rsync也支持压缩、加密等多种特性。 1234567891011121314151617181920212223242526272829303132# 将源目录复制到目的端：$ rsync -av /home/slynux/data slynux@192.168.0.6:/home/backups/data# 其中： -a表示要进行归档； -v表示在stdout上打印出细节信息或进度。# 将数据备份到远程服务器或主机：$ rsync -av source_dir username@host:PATH# 用下面的方法将远程主机上的数据恢复到本地主机：$ rsync -av username@host:PATH destination# 通过网络进行传输时，压缩数据能够明显改善传输效率。我们可以用rsync的选项 -z 指定在网络传输时压缩数据。例如：$ rsync -avz source destination# 将一个目录中的内容同步到另一个目录：$ rsync -av /home/test/ /home/backups# 这条命令将源目录（/home/test）中的内容（不包括目录本身）复制到现有的backups目录中# 在使用rsync进行归档的过程中排除部分文件$ rsync -avz /home/code/some_code /mnt/disk/backup/code --exclude \"*.txt\"# 或者我们可以通过一个列表文件指定需要排除的文件。# 这可以利用--exclude-from FILEPATH。# 在更新rsync备份时，删除不存在的文件, rsync并不会在目的端删除那些在源端已不存在的文件$ rsync -avz SOURCE DESTINATION --delete# 定期进行备份$ crontab -ev# 添加上这么一行：0 */10 * * * rsync -avz /home/code user@IP_ADDRESS:/home/backups# 上面的crontab条目将rsync调度为每10个小时运行一次。 6.8 用 fsarchiver 创建全盘镜像1234567891011121314# 创建文件系统/分区备份。# 使用fsarchiver的savefs选项：$ fsarchiver savefs backup.fsa /dev/sda1# 同时备份多个分区。$ fsarchiver savefs backup.fsa /dev/sda1 /dev/sda2# 从备份归档中恢复分区。$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1# id=0 表 明 我 们 希 望 从 备 份 归 档 中 提 取 第 一 个 分 区 的 内 容 ， 将 其 恢 复 到 由 dest=/dev/sda1所指定的分区中。# 从备份归档中恢复多个分区。# 像之前一样，使用restfs选项：$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1 id=1,dest=/dev/sdb1 7 无网不利7.1 设置网络1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 手动设置网络接口的IP地址：$ ifconfig wlan0 192.168.0.80# 使用以下命令设置比IP地址的子网掩码：$ ifconfig wlan0 192.168.0.80 netmask 255.255.252.0# 自动配置网络接口$ dhclient eth0# 打印网络接口列表$ ifconfig | cut -c-10 | tr -d ' ' | tr -s '\\n'lowlan0# 显示IP地址$ ifconfig wlan0 | egrep -o \"inet addr:[^ ]*\" | grep -o \"[0-9.]*\"192.168.0.82# 硬件地址（MAC地址）欺骗$ ifconfig eth0 hw ether 00:1c:bf:87:25:d5# 名字服务器与DNS（域名服务）$ cat /etc/resolv.confnameserver 8.8.8.8# 我们可以像下面这样手动添加名字服务器：$ echo nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf# DNS查找$ host google.comgoogle.com has address 64.233.181.105google.com has address 64.233.181.99google.com has address 64.233.181.147google.com has address 64.233.181.106google.com has address 64.233.181.103google.com has address 64.233.181.104$ nslookup google.comServer: 8.8.8.8Address: 8.8.8.8#53Non-authoritative answer:Name: google.comAddress: 64.233.181.105Name: google.comAddress: 64.233.181.99Name: google.comAddress: 64.233.181.147Name: google.comAddress: 64.233.181.106Name: google.comAddress: 64.233.181.103Name: google.comAddress: 64.233.181.104Server: 8.8.8.8# 上面最后一行对应着用于DNS解析的默认名字服务器。# 如果不使用DNS服务器，也可以为IP地址解析添加符号名，这只需要向文件 /etc/hosts中加入条目即可。# 用下面的方法进行添加：$ echo IP_ADDRESS symbolic_name &gt;&gt; /etc/hosts# 例如：$ echo 192.168.0.9 backupserver &gt;&gt; /etc/hosts# 添加了条目之后，任何时候解析backupserver，都会返回192.168.0.9。# 显示路由表信息$ routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref UseIface192.168.0.0 * 255.255.252.0 U 2 0 0wlan0link-local * 255.255.0.0 U 1000 0 0wlan0default p4.local 0.0.0.0 UG 0 0 0wlan0# 也可以使用：$ route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.0.0 0.0.0.0 255.255.252.0 U 2 0 0 wlan0169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 wlan00.0.0.0 192.168.0.4 0.0.0.0 UG 0 0 0 wlan0# -n指定以数字形式显示地址。如果使用-n， route会以数字形式的IP地址显示每一个条目；否则，如果IP地址具有对应的DNS条目，就会显示符号形式的主机名。# 设置默认网关：$ route add default gw 192.168.0.1 wlan0 7.2 traceroute 命令traceroute，它可以显示分组途径的所有网关的地址。 traceroute信息可以帮助我们搞明白分组到达目的地需要经过多少跳（hop）。中途的网关或路由器的数量给出了一个测量网络上两个节点之间距离的度量（metric）。 traceroute的输出如下： 12345678910111213141516$ traceroute google.comtraceroute to google.com (74.125.77.104), 30 hops max, 60 byte packets1 gw-c6509.lxb.as5577.net (195.26.4.1) 0.313 ms 0.371 ms 0.457 ms2 40g.lxb-fra.as5577.net (83.243.12.2) 4.684 ms 4.754 ms 4.823 ms3 de-cix10.net.google.com (80.81.192.108) 5.312 ms 5.348 ms 5.327 ms4 209.85.255.170 (209.85.255.170) 5.816 ms 5.791 ms 209.85.255.172(209.85.255.172) 5.678 ms5 209.85.250.140 (209.85.250.140) 10.126 ms 9.867 ms 10.754 ms6 64.233.175.246 (64.233.175.246) 12.940 ms 72.14.233.114(72.14.233.114) 13.736 ms 13.803 ms7 72.14.239.199 (72.14.239.199) 14.618 ms 209.85.255.166(209.85.255.166) 12.755 ms 209.85.255.143 (209.85.255.143) 13.803 ms8 209.85.255.98 (209.85.255.98) 22.625 ms 209.85.255.110(209.85.255.110) 14.122 ms*9 ew-in-f104.1e100.net (74.125.77.104) 13.061 ms 13.256 ms 13.484 ms 7.3 列出网络上所有的活动主机 (fping)fping的选项如下： 选项 -a指定打印出所有活动主机的IP地址； 选项 -u指定打印出所有无法到达的主机； 选项 -g指定从 “IP地址/子网掩码”记法或者”IP地址范围”记法中生成一组IP地址； 12345678910111213141516$ fping -a 192.160.1/24 -g# 或者$ fping -a 192.160.1 192.168.0.255 -g# 我们可以用已有的命令行工具来查询网络上的主机状态：$ fping -a 192.160.1/24 -g 2&gt; /dev/null192.168.0.1192.168.0.90# 或者，使用：$ fping -a 192.168.0.1 192.168.0.255 -g# &gt;/dev/null将由于主机无法到达所产生的错误信息打印到null设备。$ fping -a 192.168.0.1 192.168.0.5 192.168.0.6# 将IP地址作为参数传递$ fping -a &lt; ip.list# 从文件中传递一组IP地址 7.4 ssh 命令123456789101112131415# SSH的压缩功能,选项-C启用这一功能：$ ssh -C user@hostname COMMANDS# 将数据重定向至远程shell命令的stdin$ echo 'text' | ssh user@remote_host 'echo'text# 或者# 将文件中的数据进行重定向$ ssh user@remote_host 'echo' &lt; file# 在远程主机中执行图形化命令# 对此，你需要像这样设置变量$DISPLAY：$ ssh user@host \"export DISPLAY=:0 ; command1; command2\"\"\"# 这将启用远程主机上的图形化输出。如果你想在本地主机上也显示图形化输出，使用SSH的X11转发选项（forwarding option）：$ ssh -X user@host \"command1; command2 7.5 通过网络传输文件计算机联网的主要目的就是资源共享。在资源共享方面，使用最多的是文件共享。有多种方法可以用来在网络中传输文件。这则攻略就讨论了如何用常见的协议FTP、 SFTP、 RSYNC和SCP传输文件。 通过FTP传输文件可以使用lftp命令，通过SSH连接传输文件可以使用sftp， RSYNC使用SSH与rsync命令， scp通过SSH进行传输。 文件传输协议（File Transfer Protocol， FTP） ： 1234# 要连接FTP服务器传输文件，可以使用：$ lftp username@ftphost# 它会提示你输入密码，然后显示一个像下面那样的登录提示符：lftp username@ftphost:~&gt; 你可以在提示符后输入命令，如下所示。 用cd directory改变目录。 用lcd改变本地主机的目录。 用mkdir创建目录。 列出远程机器当前目录下的文件使用Is。 用get filename下载文件：lftp username@ftphost:~&gt; get filename 用put filename从当前目录上传文件：lftp username@ftphost:~&gt; put filename 用quit退出lftp会话。 FTP自动传输 ： ftp是另一个可用于FTP文件传输的命令。相比较而言， lftp的用法更灵活。 lftp和ftp为用户启动一个交互式会话（通过显示消息来提示用户输入）。 SFTP（Secure FTP，安全FTP） ： 12345$ cd /home/slynux$ put testfile.jpg$ get serverfile.jpg# 运行sftp：$ sftp user@domainname rsync命令 ： rsync广泛用于网络文件复制及系统备份。 SCP（Secure Copy Program，安全复制程序） ： 123$ scp filename user@remotehost:/home/path$ scp user@remotehost:/home/path/filename filename 用SCP进行递归复制 : 123$ scp -r /home/slynux user@remotehost:/home/backups# 将目录/home/slynux递归复制到远程主机中# scp的 -p 选项能够在复制文件的同时保留文件的权限和模式。 7.6 连接网线网络我们需要用ifconfig分配IP地址和子网掩码才能连接上有线网络。对于无线网络来说，还需要其他工具（如iwconfig和iwlist）来配置更多的参数。 iwlist工具扫描并列出可用的无线网络。用下面的命令进行扫描： 12345678$ iwlist scanwlan0 Scan completed : Cell 01 - Address: 00:12:17:7B:1C:65 Channel:11 Frequency:2.462 GHz (Channel 11) Quality=33/70 Signal level=-77 dBm Encryption key:on ESSID:\"model-2\" 7.7 在本地挂载点上挂载远程驱动器sshfs允许你将远程文件系统挂载到本地挂载点上。 123456# 将位于远程主机上的文件系统挂载到本地挂载点上：$ sshfs -o allow_other user@remotehost:/home/path /mnt/mountpointPassword:# 完成任务后，可用下面的方法卸载：$ umount /mnt/mountpoint 7.8 网络流量与端口分析列出系统中的开放端口以及运行在端口上的服务的详细信息，可以使用以下命令： 1234$ lsof -i# 要列出本地主机当前的开放端口，可以使用：$ lsof -i | grep \":[0-9]\\+-&gt;\" -o | grep \"[0-9]\\+\" -o | sort | uniq 用netstat查看开放端口与服务 ： 12# netstat -tnp列出开放端口与服务：$ netstat -tnp 7.9 创建套接字最简单的方法就是使用netcat命令（或nc）。我们需要两个套接字：一个用来侦听，一个用来连接。 12345678# 设置侦听套接字：$ nc -l 1234# 这会在本地主机的端口1234上创建一个侦听套接字。# 连接到该套接字：$ nc HOST 1234# 要想发送消息，只需要在执行第2步操作的主机终端中输入信息并按回车键就行了。消息会出现在执行第1步操作的主机终端中。 在网络上进行快速文件复制 ： 12345# 在接收端执行下列命令：$ nc -l 1234 &gt; destination_filename# 在发送端执行下列命令：$ nc HOST 1234 &lt; source_filename 7.10 iptables防火墙设置12345678910# 阻塞发送到特定IP地址的流量：$ iptables -A OUTPUT -d 8.8.8.8 -j DROP# 阻塞发送到特定端口的流量：$ iptables -A OUTPUT -p tcp -dport 21 -j DROP# iptables中的第一个选项-A表明向链（chain）中添加一条新的规则，该规则由后续参数给出。OUTPUT链，它可以对所有出站（outgoing）的流量进行控制。-d指定了所要匹配的分组目的地址。-j来使iptables丢弃（DROP）符合条件的分组。-p指定该规则是适用于TCP， -dport指定了对应的端口。# 清除对iptables链所做出的所有改动。$ iptables --flush 8 当个好管家8.1 监视磁盘使用情况df 是disk free的缩写， du 是disk usage的缩写。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 找出某个文件（或多个文件）占用的磁盘空间：$ du file.txt# 要获得某个目录中所有文件的磁盘使用情况，并在每一行中显示各个文件的磁盘占用详情，可以使用：$ du -a DIRECTORY# 以KB、 MB或块（block）为单位显示磁盘使用情况$ du -h FILENAME# 显示磁盘使用总计, -c 可以输出作为命令参数的所有文件和目录的磁盘使用情况$ du -c process_log.shpcpu.sh4 process_log.sh4 pcpu.sh8 total# -s（summarize，合计）则只输出合计数据。它可以配合 -h打印出人们易读的格式。$ du -sh slynux680K slynux# 打印以字节（默认输出）为单位的文件大小：$ du -b FILE(s)# 打印以KB为单位的文件大小：$ du -k FILE(s)# 打印以MB为单位的文件大小：$ du -m FILE(s)# 打印以指定块为单位的文件大小：$ du -B BLOCK_SIZE FILE(s)# 从磁盘使用统计中排除部分文件$ du --exclude \"*.txt\" FILES(s)# 排除所有的.txt文件$ du --exclude-from EXCLUDE.txt DIRECTORY# EXCLUDE.txt包含了需要排除的文件列表# --max-depth指定du应该遍历的目录层次的最大深度。$ du --max-depth 2 DIRECTORY# 找出指定目录中最大的10个文件$ du -ak /home/slynux | sort -nrk 1 | head -n 4$ find . -type f -exec du -k &#123;&#125; \\; | sort -nrk 1 | head du提供磁盘使用情况信息，而df提供磁盘可用空间信息。 123456789$ df -hFilesystem Size Used Avail Use% Mounted on/dev/sda1 9.2G 2.2G 6.6G 25% /none 497M 240K 497M 1% /devnone 502M 168K 501M 1% /dev/shmnone 502M 88K 501M 1% /var/runnone 502M 0 502M 0% /var/locknone 502M 0 502M 0% /lib/init/rwnone 9.2G 2.2G 6.6G 25% /var/lib/ureadahead/debugfs 8.2 计算命令执行时间 real: %e user: %U sys: %S 12345678910111213141516171819202122$ time COMMAND# 可以用选项-o filename将相关的时间统计信息写入文件：$ /usr/bin/time -o output.txt COMMAND# 要将命令执行时间添加到文件而不影响其原有内容，使用选项-a以及-o：$ /usr/bin/time -a -o output.txt COMMAND# 创建格式化输出：$ /usr/bin/time -f \"Time: %U\" -a -o timing.log unameLinux# 用错误重定向操作符（2&gt;）对时间信息重定向。$ /usr/bin/time -f \"Time: %U\" uname&gt; command_output.txt 2&gt;time.log$ cat time.logTime: 0.00$ cat command_output.txtLinux# 使用参数%Z显示系统页面大小：$ /usr/bin/time -f \"Page size: %Z bytes\" ls&gt; /dev/nullPage size: 4096 bytes 三种不同类型的时： Real时间指的是挂钟时间（wall clock time），也就是命令从开始执行到结束的时间。这段时间包括其他进程所占用的时间片（time slice）以及进程被阻塞时所花费的时间（例如，为等待I/O操作完成所用的时间）。 User时间是指进程花费在用户模式（内核之外）中的CPU时间。这是唯一真正用于执行进程所花费的时间。执行其他进程以及花费在阻塞状态中的时间并没有计算在内。 Sys时间是指进程花费在内核中的CPU时间。它代表在内核中执行系统调用所使用的时间，这和库代码（library code）不同，后者仍旧运行在用户空间。与“user时间”类似，这也是真正由进程使用的CPU时间。 time命令 一些可以使用的参数： 参数 描述 %C 进行计时的命令名称以及命令行参数 %D 进程非共享数据区域的大小，以KB为单位 %E 进程使用的real时间（挂钟时间），显示格式为[小时:]分钟:秒 %x 命令的退出状态 %k 进程接收到的信号数量 %W 进程被交换出主存的次数 %Z 系统的页面大小。这是一个系统常量，但在不同的系统中，这个常量值也不同 %P 进程所获得的CPU时间百分比。这个值等于user+system时间除以总运行时间。结果以百分比形式显示 %K 进程的平均总（data+stack+text）内存使用量，以KB为单位 %w 进程主动进行上下文切换的次数，例如等待I/O操作完成 %c 进程被迫进行上下文切换的次数（由于时间片到期） 8.3 收集与当前登录用户、启动日志及启动故障的相关信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 获取当前登录用户的相关信息：$ whoslynux pts/0 2010-09-29 05:24 (slynuxs-macbook-pro.local)slynux tty7 2010-09-29 07:08 (:0)# 获得有关登录用户更详细的信息：$ w 07:09:05 up 1:45, 2 users, load average: 0.12, 0.06, 0.02USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATslynux pts/0 slynuxs 05:24 0.00s 0.65s 0.11s sshd: slynuxslynux tty7 :0 07:08 1:45m 3.28s 0.26s gnome-session# 第一行列出了当前时间，系统运行时间，当前登录的用户数量以及过去的1分钟、 5分钟、 15分钟内的系统平均负载。接下来的每一行显示了每一个登录用户的详细信息，其中包括登录名、 TTY、远程主机、登录时间、空闲时间、自该用户登录后所使用的总CPU时间、当前运行进程所使用的CPU时间以及进程所对应的命令行。# 列出当前登录主机的用户列表：$ usersslynux slynux slynux hacker$ users | tr ' ' '\\n' | sort | uniqslynuxhacker# 查看系统已经加电运行了多长时间：$ uptime21:44:33 up 3:17, 8 users, load average: 0.09, 0.14, 0.09$ uptime | grep -Po '\\d&#123;2&#125;\\:\\d&#123;2&#125;\\:\\d&#123;2&#125;'# 获取上一次启动以及用户登录会话的信息：$ lastslynux tty7 :0 Tue Sep 28 18:27 still logged inreboot system boot 2.6.32-21-generic Tue Sep 28 18:10 - 21:46 (03:35)slynux pts/0 :0.0 Tue Sep 28 05:31 - crash (12:39)# last命令可以提供登录会话信息。它实际上是一个系统登录日志，包括了登录tty、登录时间、状态等信息。# last命令以日志文件/var/log/wtmp作为输入日志数据。它也可以用选项-f明确地指定日志文件。例如：$ last -f /var/log/wtmp# 获取单个用户登录会话的信息：$ last USER# 获取重启会话（reboot session）信息：$ last rebootreboot system boot 2.6.32-21-generi Tue Sep 28 18:10 - 21:48 (03:37)reboot system boot 2.6.32-21-generi Tue Sep 28 05:14 - 21:48 (16:33)# 获取失败的用户登录会话信息：$ lastbtest tty8 :0 Wed Dec 15 03:56 - 03:56 (00:00)slynux tty8 :0 Wed Dec 15 03:55 - 03:55 (00:00) 8.4 使用 watch 监视命令输出watch命令可以用来在终端中以固定的间隔监视命令输出。 123456789101112$ watch ls$ watch 'ls -l | grep \"^d\"'# 只列出目录# 命令默认每2秒更新一次输出。# -n SECOND指定更新输出的时间间隔。例如：$ watch -n 5 'ls -l'# 以5秒为间隔，监视ls -l的输出# 突出标示watch输出中的差异, -d 可以启用这一功能：$ watch -d 'COMMANDS' 8.5 用 logrotate 管理日志文件用一种被称为轮替（rotation）的技术来限制日志文件的体积，一旦它超过了限定的大小，就对其内容进行抽取（strip），同时将 日志文件中的旧条目存储到日志目录中的归档文件内。旧的日志文件就会得以保存以便随后参阅。 logrotate 的配置目录位于/etc/logrotate.d。 12345678910$ cat /etc/logrotate.d/program/var/log/program.log &#123;missingoknotifemptysize 30kcompressweeklyrotate 5create 0600 root root&#125; 配置文件中各个参数的含义： 参数 描述 missingok 如果日志文件丢失，则忽略；然后返回（不对日志文件进行轮替） notifempty 仅当源日志文件非空时才对其进行轮替 size 30k 限制实施轮替的日志文件的大小。可以用1M表示1MB compress 允许用gzip压缩较旧的日志 weekly 指定进行轮替的时间间隔。可以是weekly、 yearly或daily rotate 5 这是需要保留的旧日志文件的归档数量。在这里指定的是5，所以这些文件名将会是program.log.1.gz、 program.log.2.gz等直到program.log.5.gz create 0600 root root 指定所要创建的归档文件的模式、用户以及用户组 8.6 用 syslog 记录日志每一个标准应用进程都可以利用syslog记录日志信息。 使用命令logger通过syslogd记录日志。 Linux中一些重要的日志文件 ： 日志文件 描述 /var/log/boot.log 系统启动信息 /var/log/httpd Apache Web服务器日志 /var/log/messages 发布内核启动信息 /var/log/auth.log 用户认证日志 /var/log/dmesg 系统启动信息 /var/log/mail.log 邮件服务器日志 /var/log/Xorg.0.log X服务器日志 12345678910111213# 向系统日志文件/var/log/message中写入日志信息：$ logger This is a test log line$ tail -n 1 /var/log/messagesSep 29 07:47:44 slynux-laptop slynux: This is a test log line # 如果要记录特定的标记（tag），可以使用：$ logger -t TAG This is a message$ tail -n 1 /var/log/messagesSep 29 07:48:42 slynux-laptop TAG: This is a message# 但是当logger发送消息时，它用标记字符串来确定应该记录到哪一个日志文件中。 syslogd使用与日志相关联的TAG来决定应该将其记录到哪一个文件中。你可以从/etc/rsyslog.d/目录下的配置文件中看到标记字符串以及与其相关联的日志文件。# 要将另一个日志文件的最后一行记录到系统日志中，可以使用：$ logger -f /var/log/source.log 8.7 通过监视用户登录找出入侵者入侵者定义为：屡次试图登入系统达两分钟以上，并且期间的登录过程全部失败。凡是这类用户都应该被检测出来并生成包含以下细节信息的报告： 试图登录的账户 试图登录的次数 攻击者的IP地址 IP地址所对应的主机 进行登录的时间段 为了处理SSH登录失败的情况，还得知道用户认证会话日志会被记录在日志文件/var/log/auth.log中。脚本需要扫描这个日志文件来检测出失败的登录信息，执行各种检查来获取所需要的数据。我们可以用host命令找出IP地址所对应的主机。 8.8 监视磁盘活动12345678# 交互式监视, iotop的-o选项只显示出那些正在进行I/O活动的进程：$ iotop -o# 用于shell脚本的非交互式用法：$ iotop -b -n 2# 监视特定进程$ iotop -p PID 8.9 检查磁盘及文件系统错误使用fsck的各种选项对文件系统错误进行检查和修复。 12345678910111213141516171819202122232425# 要检查分区或文件系统的错误，只需要将路径作为fsck的参数：$ fsck /dev/sdb3fsck from util-linux 2.20.1e2fsck 1.42.5 (29-Jul-2012)HDD2 has been mounted 26 times without being checked, check forced.Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary informationHDD2: 75540/16138240 files (0.7% non-contiguous), 48756390/64529088 blocks# 检查/etc/fstab中所配置的所有文件系统：$ fsck -A# 该命令会依次检查/etc/fstab中列出的文件系统。 fstab文件对磁盘及其挂载点之间的映射关系进行了配置，以便于更便捷地挂载文件系统# 指定fsck自动修复错误，无需询问是否进行修复：$ fsck -a /dev/sda2# 模拟fsck要执行的操作：$ fsck -ANfsck from util-linux 2.20.1[/sbin/fsck.ext4 (1) -- /] fsck.ext4 /dev/sda8[/sbin/fsck.ext4 (1) -- /home] fsck.ext4 /dev/sda7[/sbin/fsck.ext3 (1) -- /media/Data] fsck.ext3 /dev/sda6 9 管理重任9.1 收集进程信息1234567891011121314151617181920212223242526272829303132333435# 为了包含更多的信息，可以使用-f（表示full）来显示多列，如下所示：$ ps -fUID PID PPID C STIME TTY TIME CMDslynux 1220 1219 0 18:18 pts/0 00:00:00 -bashslynux 1587 1220 0 18:59 pts/0 00:00:00 ps -f# 使用选项 -e（every）。选项-ax（all）也可以生成同样的输出。# 运行如下命令之一： ps –e， ps –ef， ps -ax或ps –axf。$ ps -e | headPID TTY TIME CMD1 ? 00:00:00 init2 ? 00:00:00 kthreadd3 ? 00:00:00 migration/04 ? 00:00:00 ksoftirqd/05 ? 00:00:00 watchdog/06 ? 00:00:00 events/07 ? 00:00:00 cpuset8 ? 00:00:00 khelper9 ? 00:00:00 netns# 用 -o 来指定想要显示的列，以便只打印出我们需要的内容。# -o 的参数以逗号操作符（,）作为定界符。值得注意的是，逗号操作符与它分隔的参数之间是没有空格的。# -e和过滤器结合使用没有任何实际效果，依旧会显示所有的进程。# 示例如下，其中comm表示COMMAND， pcpu表示CPU占用率：$ ps -eo comm,pcpu | headCOMMAND %CPUinit 0.0kthreadd 0.0migration/0 0.0ksoftirqd/0 0.0watchdog/0 0.0events/0 0.0cpuset 0.0khelper 0.0netns 0.0 选项-o可以使用不同的参数： 参数 描述 pcpu CPU占用率 pid 进程ID ppid 父进程ID pmem 内存使用率 comm 可执行文件名 cmd 简单命令 user 启动进程的用户 nice 优先级 time 累计的CPU时间 etime 进程启动后流逝的时间 tty 所关联的TTY设备 euid 有效用户ID stat 进程状态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# top, 默认会输出一个占用CPU最多的进程列表。输出结果每隔几秒就会更新。$ top# 根据参数对ps输出进行排序$ ps -eo comm,pcpu --sort -pcpu | headCOMMAND %CPUXorg 0.1hald-addon-stor 0.0ata/0 0.0scsi_eh_0 0.0gnome-settings- 0.0init 0.0hald 0.0pulseaudio 0.0gdm-simple-gree 0.0$ ps -eo comm,pid,pcpu,pmem | grep bashbash 1255 0.0 0.3bash 1680 5.5 0.3# 找出给定命令名所对应的进程ID，在参数后加上=就可以移除列名。$ ps -C bash -o pid=12551680$ pgrep bash12551680# 如果不使用换行符作为定界符，而是要自行指定可以像下面这样：$ pgrep bash -d \":\"1255:1680# 指定进程的用户（拥有者）列表：$ pgrep -u root,slynux COMMAND# 根据真实用户或ID以及有效用户或ID过滤ps输出 用 -u EUSER1,EUSER2 …，指定有效用户列表； 用 -U RUSER1,RUSER2 …，指定真实用户列表$ ps -u root -U root -o user,pcpu# 用TTY过滤ps输出, 可以通过指定进程所属的TTY选择ps的输出。用选项 -t指定TTY列表：$ ps -t pts/0,pts/1PID TTY TIME CMD1238 pts/0 00:00:00 bash1835 pts/1 00:00:00 bash1864 pts/0 00:00:00 ps# 进程线程的相关信息# 通常与进程线程相关的信息在ps输出中是看不到的。我们可以用选项 –L 在ps输出中显示线程的相关信息。这会显示出两列： NLWP和NLP。 NLWP是进程的线程数量， NLP是ps输出中每个条目的线程ID。例如：$ ps -eLf# 指定输出宽度以及所要显示的列# 可以按照你自己的使用方式来进行应用。尝试以下选项: -f ps –ef u ps -e u ps ps -e w（w表示宽松输出）# 显示进程的环境变量# 了解某个进程依赖哪些环境变量，这类信息我们通常都用得着。进程的运行方式可能极其依赖某组环境变量。我们可以利用环境变量调试并修复与进程相关的问题。$ ps -eo pid,cmd e | tail -n 31162 hald-addon-acpi: listening on acpid socket /var/run/acpid.socket1172 sshd: slynux [priv]1237 sshd: slynux@pts/01238 -bash USER=slynux LOGNAME=slynux HOME=/home/slynuxPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/gamesMAIL=/var/mail/slynux SHELL=/bin/bash SSH_CLIENT=10.211.55.2 49277 22SSH_CONNECTION=10.211.55.2 49277 10.211.55.4 22 SSH_TTY=/dev/pts/0 TERM=xterm-colorLANG=en_IN XDG_SESSION_COOKIE=d1e96f5cc8a7a3bc3a0a73e44c95121a-1286499339.592429-1573657095 9.2 which、 whereis、 file、 whatis与平均负载1234567891011121314151617181920212223# which, which命令用来找出某个命令的位置。$ which ls/bin/ls# whereis# whereis与which命令类似，但它不仅返回命令的路径，还能够打印出其对应的命令手册的位置以及命令源代码的路径（如果有的话）$ whereis lsls: /bin/ls /usr/share/man/man1/ls.1.gz# file$ file FILENAME# 该命令会打印出与该文件类型相关的细节信息。$ file /bin/ls/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked(uses shared libs), for GNU/Linux 2.6.15, stripped# whatis, whatis命令会输出作为参数的命令的简短描述信息。$ whatis lsls (1) - list directory contents# 平均负载$ uptime12:40:53 up 6:16, 2 users, load average: 0.00, 0.00, 0.00 9.3 杀死进程以及发送或响应信号信号是Linux中的一种进程间通信机制。 当进程接收到一个信号时，它会通过执行对应的信号处理程序（signal handler）来进行响应。 123456789101112131415# 列出所有可用的信号：$ kill -l# 终止进程：$ kill PROCESS_ID_LIST# kill命令默认发出一个TERM信号。进程ID列表使用空格作为进程ID之间的定界符。# 要通过kill命令向进程发送指定的信号，可以使用：$ kill -s SIGNAL PID# 参数SIGNAL要么是信号名称，要么是信号编号。# 我们经常要强行杀死进程，可以使用：$ kill -s SIGKILL PROCESS_ID或者$ kill -9 PROCESS_ID 常用到的信号量： SIGHUP 1——对控制进程或终端的终结进行挂起检测（hangup detection） SIGINT 2——当按下Ctrl + C时发送该信号 SIGKILL 9——用于强行杀死进程 SIGTERM 15——默认用于终止进程 SIGTSTP 20——当按下Ctrl + Z时发送该信号 1234567891011121314151617# killall命令通过命令名终止进程：$ killall process_name# 通过名称向进程发送信号：$ killall -s SIGNAL process_name# 通过名称强行杀死进程：$ killall -9 process_name# pkill命令和kill命令类似，不过默认情况下pkill接受的是进程名，而非进程ID。例如：$ pkill process_name$ pkill -s SIGNAL process_name# pkill不支持信号名称。# 捕捉并响应信号# trap命令在脚本中用来为信号分配信号处理程序。$ trap 'signal_handler_function_name' SIGNAL LIST 9.4 向用户终端发送消息1234567# wall命令用来向当前所有登录用户的终端写入消息。$ cat message | wall或者$ wall&lt; messageBroadcast Message from slynux@slynux-laptop(/dev/pts/1) at 12:54 ...This is a messag 9.5 采集系统信息1234567891011121314151617181920212223242526272829303132# 打印当前系统的主机名：$ hostname或者$ uname -n# 打印Linux内核版本、硬件架构等详细信息：$ uname -a# 打印内核发行版本：$ uname -r# 打印主机类型：$ uname -m# 打印CPU相关信息：$ cat /proc/cpuinfo# 获取处理器名称：$ cat /proc/cpuinfo | sed -n 5p# 打印内存的详细信息：$ cat /proc/meminfo# 打印系统可用内存总量：$ cat /proc/meminfo | head -1MemTotal: 1026096 kB# 列出系统的分区信息：$ cat /proc/partitions或者$ fdisk -l #如果没有输出，切换到root用户执行该命令# 获取系统的详细信息：$ lshw #建议以root用户来执行 9.6 使用 proc 采集信息以Bash为例，它的进程ID是4295（pgrep bash），那么就会有一个对应的目录/proc/4295。进程对应的目录中包含了大量有关进程的信息。 /proc/PID中一些重要的文件如下所示。 environ：包含与进程相关的环境变量。使用cat /proc/4295/environ，可以显示所有传递给该进程的环境变量 cwd： 是一个到进程工作目录（working directory）的符号链接 exe：是一个到当前进程所对应的可执行文件的符号链接 $ readlink /proc/4295/exe/bin/bash fd：包含了进程所使用的文件描述符 9.7 用 cron 进行调度crontab任务配置基本格式： 12* * * * * command分钟(0-59) 小时(0-23) 日期(1-31) 月份(1-12) 星期(0-6,0代表星期天) 命令 cron表中的每一个条目都由6部分组成，并按照下列顺序排列： 分钟（0～59） 小时（0～23） 天（1～31） 月份（1～12） 工作日（0～6） 命令（在指定时间执行的脚本或命令） 星号（*）指定命令应该在每个时间段执行。 除了数字还有几个个特殊的符号就是 &quot;*&quot; 、&quot;/&quot; 和 &quot;-&quot; 、&quot;,&quot; ，* 代表所有的取值范围内的数字，&quot;/&quot; 代表每的意思, &quot;*/5&quot; 表示每5个单位，&quot;-&quot; 代表从某个数字到某个数字, &quot;,&quot; 分开几个离散的数字。以下举几个例子说明问题： 1234567891011121314151617181920212223242526272829# 指定每小时的第5分钟执行一次ls命令5 * * * * ls # 指定每天的 5:30 执行ls命令30 5 * * * ls # 指定每月8号的7：30分执行ls命令30 7 8 * * ls # 指定每年的6月8日5：30执行ls命令30 5 8 6 * ls # 指定每星期日的6:30执行ls命令 [ 注：0表示星期天，1表示星期1，以此类推，也可以用英文来表示，sun表示星期天，mon表示星期一等。 ]30 6 * * 0 ls # 每月10号及20号的3：30执行ls命令 [注：“，”用来连接多个不连续的时段 ]30 3 10,20 * * ls # 每天8-11点的第25分钟执行ls命令 [注：“-”用来连接连续的时段 ]25 8-11 * * * ls # 每15分钟执行一次ls命令 [即每个小时的第0 15 30 45 60分钟执行ls命令 ]*/15 * * * * ls # 每个月中，每隔10天6:30执行一次ls命令[即每月的1、11、21、31日是的6：30执行一次ls命令。 ]30 6 */10 * * ls # 每天7：50以root 身份执行/etc/cron.daily目录中的所有可执行文件50 7 * * * root run-parts /etc/cron.daily # [ 注：run-parts参数表示，执行后面目录中的所有可执行文件。 ] 配置用户定时任务的语法： 123$ crontab [-u user]file$ crontab -u user[-i] 参数与说明： crontab -u //设定某个用户的cron服务 crontab -l //列出某个用户cron服务的详细内容 crontab -r //删除没个用户的cron服务 crontab -e //编辑某个用户的cron服务 9.8 从终端截图12345678# 取整个屏幕：$ import -window root screenshot.png# 手动选择部分区域进行抓取：$ import screenshot.png# 抓取特定窗口：$ import -window window_id screenshot.png","categories":[{"name":"Shell","slug":"Shell","permalink":"http://miaopei.github.io/categories/Shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://miaopei.github.io/tags/shell/"}]},{"title":"Linux命令eval的用法","slug":"Linux命令eval的用法","date":"2017-04-13T11:50:19.000Z","updated":"2019-06-05T04:03:57.392Z","comments":true,"path":"2017/04/13/Linux命令eval的用法/","link":"","permalink":"http://miaopei.github.io/2017/04/13/Linux命令eval的用法/","excerpt":"eval command-line其中command－line是在终端上键入的一条普通命令行。然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次。如： 123$ pipe=\"|\"$ eval ls $pipe wc -l shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。","text":"eval command-line其中command－line是在终端上键入的一条普通命令行。然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次。如： 123$ pipe=\"|\"$ eval ls $pipe wc -l shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。 如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（；｜ &amp;），I／o重定向符（&lt; &gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。 eval echo $# 取得最后一个参数如： 12345$ cat lasteval echo $$#$ ./last one two three fourfour 第一遍扫描后，shell把反斜杠去掉了。当shell再次扫描该行时，它替换了$4的值，并执行echo命令 以下示意如何用eval命令创建指向变量的“指针”：1234567891011$ x=100$ ptrx=x$ eval echo $$ptrx #指向ptrx，用这里的方法可以理解b中的例子100 打印100$ eval $ptrx=50 #将50存到ptrx指向的变量中。$ echo $x50 打印50","categories":[{"name":"Shell","slug":"Shell","permalink":"http://miaopei.github.io/categories/Shell/"}],"tags":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://miaopei.github.io/tags/Linux-Shell/"}]},{"title":"HTTP思维导图","slug":"HTTP思维导图","date":"2017-04-12T07:41:58.000Z","updated":"2019-06-05T04:03:57.392Z","comments":true,"path":"2017/04/12/HTTP思维导图/","link":"","permalink":"http://miaopei.github.io/2017/04/12/HTTP思维导图/","excerpt":"文章来自HTTP思维导图。 HTTP mindmap整理 source from 《HTTP权威指南》","text":"文章来自HTTP思维导图。 HTTP mindmap整理 source from 《HTTP权威指南》 概述-Summary 报文-Message 连接-Connection 代理-Proxy 缓存-Cache 网关、隧道与中继-Gateway、Tunnel and Relay 识别-Identification 认证-Authentication 安全-Security 实体与编码-Entity and Encoding","categories":[{"name":"http","slug":"http","permalink":"http://miaopei.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://miaopei.github.io/tags/http/"}]},{"title":"Webpack创建、运行vue.js项目及其目录结构详解","slug":"Webpack创建、运行vue-js项目及其目录结构详解","date":"2017-04-10T10:18:27.000Z","updated":"2019-06-05T04:03:57.392Z","comments":true,"path":"2017/04/10/Webpack创建、运行vue-js项目及其目录结构详解/","link":"","permalink":"http://miaopei.github.io/2017/04/10/Webpack创建、运行vue-js项目及其目录结构详解/","excerpt":"项目环境搭建：1.安装node 进入node官网进行下载。 版本查看： 12$ node -vv6.10.1 **注意：**node版本最好新一点，推介6.0以上。","text":"项目环境搭建：1.安装node 进入node官网进行下载。 版本查看： 12$ node -vv6.10.1 **注意：**node版本最好新一点，推介6.0以上。 2.全局安装vue-cli 1$ npm install -g vue-cli 注意： 如果安装失败可能需要root权限重新安装。 3.创建一个基于 webpack 模板的新项目 12$ vue init webpack project-name #(默认安装2.0版本)$ vue init webpack#1.0 project-name #(安装1.0版本) 项目目录结构： main.js是入口文件，主要作用是初始化vue实例并使用需要的插件 123456789101112131415// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。其实你也可以理解为所有的路由也是App.vue的子组件。所以我将router标示为App.vue的子组件。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;, components: &#123; Hello &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; index.html文件入口 src放置组件和入口文件 node_modules为依赖的模块 config中配置了路径端口值等 build中配置了webpack的基本配置、开发环境配置、生产环境配置等 运行项目：1234$ cd project-name$ npm install$ npm run dev# 上述步骤都完成后在浏览器输入：localhost:8080","categories":[{"name":"Docker","slug":"Docker","permalink":"http://miaopei.github.io/categories/Docker/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://miaopei.github.io/tags/webpack/"}]},{"title":"lighttpd 配置https","slug":"lighttpd-配置https","date":"2017-03-31T04:34:28.000Z","updated":"2019-06-03T08:10:56.870Z","comments":true,"path":"2017/03/31/lighttpd-配置https/","link":"","permalink":"http://miaopei.github.io/2017/03/31/lighttpd-配置https/","excerpt":"确定安装的lighttpd支持ssl版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看： 123$ lighttpd -vlighttpd/1.4.35 (ssl) - a light and fast webserverBuild-Date: Apr 25 2017 10:25:18","text":"确定安装的lighttpd支持ssl版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看： 123$ lighttpd -vlighttpd/1.4.35 (ssl) - a light and fast webserverBuild-Date: Apr 25 2017 10:25:18 生成自签名证书完整的ssl证书分为四个部分： CA根证书（root CA） 中级证书（Intermediate Certificate） 域名证书 证书秘钥（仅由开发者提供） 证书相当于公钥，pem相当于私钥。 Self-Signed Certificates：包含公钥和私钥的结合体，证书（公钥）会在连接请求的时候发给浏览器，以便浏览器解密和加密。 创建Self-Signed Certificates： 1$ openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes 上边的命令生成一个server.pem文件。 lighttpd.conf 配置1234$SERVER[\"socket\"] == \"[::]:443\" &#123; ssl.engine = \"enable\" ssl.pemfile = \"/mnt/flash/server.pem\"&#125; 强制定向到HTTPS下面是 lighttpd.conf 文件中关于强制 HTTP 定向到 HTTPS 的部分配置： 1234567$HTTP[\"scheme\"] == \"http\" &#123; # capture vhost name with regex conditiona -&gt; %0 in redirect pattern # must be the most inner block to the redirect rule $HTTP[\"host\"] =~ \".*\" &#123; url.redirect = (\".*\" =&gt; \"https://%0$0\") &#125;&#125; 此功能需要lighttpd mod_redirect 模块支持。使用此功能前确保模块已经安装。 lighttpd安全配置禁用 SSL Compression (抵御 CRIME 攻击) 1ssl.use-compression = \"disable\" 禁用 SSLv2 及 SSLv3 12ssl.use-sslv2 = \"disable\"ssl.use-sslv3 = \"disable\" 抵御 Poodle 和 SSL downgrade 攻击 需要支持 TLS-FALLBACK-SCSV 以自动开启此功能。下列 openSSL 版本包含对 TLS-FALLBACK-SCSV 的支持，lighttpd 会自动启用此特性。 OpenSSL 1.0.1 在 1.0.1j 及之后的版本中支持 OpenSSL 1.0.0 在 1.0.0o 及之后的版本中支持 OpenSSL 0.9.8 在 0.9.8zc 及之后的版本中支持 加密及交换算法 一份推介的配置： 1ssl.cipher-list = \"EECDH+AESGCM:EDH+AESGCM:AES128+EECDH:AES128+EDH\" 如果您需要兼容一些老式系统和浏览器 (例如 Windows XP 和 IE6)，请使用下面的： 1ssl.cipher-list = \"EECDH+AESGCM:EDH+AESGCM:ECDHE-RSA-AES128-GCM-SHA256:AES256+EECDH:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4\" 配置 Forward Secrecy 和 DHE 参数 生成强 DHE 参数： 12$ cd /etc/ssl/certs$ openssl dhparam -out dhparam.pem 4096 建议您使用性能强劲的平台生成此文件，例如最新版的至强物理机。如果您只有一台小型 VPS，请使用 openssl dhparam -out dhparam.pem 2048 命令生成 2048bit 的参数文件。 添加到 SSL 配置文件： 12ssl.dh-file = \"/etc/ssl/certs/dhparam.pem\"ssl.ec-curve = \"secp384r1\" 启用 HSTS 1234server.modules += ( \"mod_setenv\" )$HTTP[\"scheme\"] == \"https\" &#123; setenv.add-response-header = ( \"Strict-Transport-Security\" =&gt; \"max-age=63072000; includeSubdomains; preload\")&#125; 参考资料Lighttpd","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://miaopei.github.io/tags/http/"},{"name":"lighttpd","slug":"lighttpd","permalink":"http://miaopei.github.io/tags/lighttpd/"}]},{"title":"lighttpd+fastcgi","slug":"lighttpd-fastcgi","date":"2017-03-31T04:34:28.000Z","updated":"2019-06-03T08:10:56.874Z","comments":true,"path":"2017/03/31/lighttpd-fastcgi/","link":"","permalink":"http://miaopei.github.io/2017/03/31/lighttpd-fastcgi/","excerpt":"简介lighttpd 提供了一种外部程序调用的接口，即 FastCGI 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。 这就意味着能够在 Apache 服务器上运行的 FastCGI 程序，也一定可以无缝的在 lighttpd 上使用。","text":"简介lighttpd 提供了一种外部程序调用的接口，即 FastCGI 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。 这就意味着能够在 Apache 服务器上运行的 FastCGI 程序，也一定可以无缝的在 lighttpd 上使用。 FastCGI介绍1）就像 CGI 一样，FastCGI 也是独立于编程语言的。2）就像 CGI 一样，FastCGI 程序运行在完全独立于核心 Web Server 之外的进程中，和 API 方式相比，提供了很大的安全性。（API会将程序代码与核心Web Server挂接在一起，这就意味着基于问题API的应用程序可能会使整个Web Server或另一个应用程序崩溃；一个恶意API还可以从核心Web Server或另一个应用程序中盗取安全密钥） 3) 虽然 FastCGI 不能一夜之间复制CGI的所有功能，但是 FastCGI 一直宣扬开放，这也使得我们拥有很多免费的 FastCGI 应用程序库（C/C++、Java、Perl、TCL）和免费的Server模块（Apache、ISS、Lighttpd）。 4) 就像 CGI 一样，FastCGI 并不依附于任何 Web Server 的内部架构，因此即使 Server 的技术实现变动，FastCGI 仍然非常稳定；而 API 设计是反映 Web Server 内部架构的，因此，一旦架构改变，API要随之变动。 5) FastCGI 程序可以运行在任何机器上，完全可以和 Web Server 不在一台机器上。这种分布式计算的思想可以确保可扩展性、提高系统可用性和安全性。 6) CGI 程序主要是对 HTTP 请求做计算处理，而 FastCGI 却还可以做得更多，例如模块化认证、授权检查、数据类型转换等等。在未来，FastCGI 还会有能力扮演更多角色。 7) FastCGI 移除了 CGI 程序的许多弊端。例如，针对每一个新请求，WebServer 都必须重启 CGI 程序来处理新请求，这导致 WebServer 的性能会大受影响。而 FastCGI 通过保持进程处理运行状态并持续处理请求的方式解决了该问题，这就将进程创建和销毁的时间节省了出来。 8) CGI 程序需要通过管道（pipe）方式与 Web Server 通信，而 FastCGI 则是通过 Unix-Domain-Sockets 或 TCP/IP 方式来实现与 Web Server 的通信。这确保了 FastCGI 可以运行在 Web Server 之外的服务器上。FastCGI 提供了 FastCGI 负载均衡器，它可以有效控制多个独立的 FastCGI Server 的负载，这种方式比 load-balancer+apache+mod_php 方式能够承担更多的流量。 FastCGI 模块若要 lighttpd 支持 fastcgi，则需要配置如下内容： 在 fastcgi.conf 中配置 1server.modules += ( &quot;mod_fastcgi&quot; ) 及在 module.conf 中配置 1include &quot;conf.d/fastcgi.conf&quot; FastCGI 配置选项lighttpd 通过 fastcgi 模块的方式实现了对 fastcgi 的支持，并且在配置文件中提供了三个相关的选项： 1） fastcgi.debug 可以设置一个从0到65535的值，用于设定 FastCGI 模块的调试等级。当前仅有0和1可用。1表示开启调试（会输出调试信息），0表示禁用。例如： 1fastcgi.debug = 1 2） fastcgi.map-extentsions 同一个 fastcgi server 能够映射多个扩展名，如 .php3 和 .php4 都对应 .php。例如： 1fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot; ) or for multiple 1fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot;, &quot;.php4&quot; =&gt; &quot;.php&quot; ) 3） fastcgi.server 这个配置是告诉 Web Server 将 FastCGI 请求发送到哪里，其中每一个文件扩展名可以处理一个类型的请求。负载均衡器可以实现对同一扩展名的多个对象的负载均衡。 fastcgi.server 的结构语法如下： 1234567891011121314151617181920( &lt;extension&gt; =&gt; ( [ &lt;name&gt; =&gt; ] ( # Be careful: lighty does *not* warn you if it doesn't know a specified option here (make sure you have no typos) \"host\" =&gt; &lt;string&gt; , \"port\" =&gt; &lt;integer&gt; , \"socket\" =&gt; &lt;string&gt;, # either socket or host+port \"bin-path\" =&gt; &lt;string&gt;, # optional \"bin-environment\" =&gt; &lt;array&gt;, # optional \"bin-copy-environment\" =&gt; &lt;array&gt;, # optional \"mode\" =&gt; &lt;string&gt;, # optional \"docroot\" =&gt; &lt;string&gt; , # optional if \"mode\" is not \"authorizer\" \"check-local\" =&gt; &lt;string&gt;, # optional \"max-procs\" =&gt; &lt;integer&gt;, # optional - when omitted, default is 4 \"broken-scriptfilename\" =&gt; &lt;boolean&gt;, # optional \"kill-signal\" =&gt; &lt;integer&gt;, # optional, default is SIGTERM(15) (v1.4.14+) ), ( \"host\" =&gt; ... ) )) 其中： extentsion ：文件名后缀或以”/”开头的前缀（也可为文件名）name ：这是一个可选项，表示handler的名称，在mod_status中用于统计功能，可以清晰的分辨出是哪一个handler处理了。 host ：FastCGI进程监听的IP地址。此处不支持hostname形式。port ：FastCGI进程所监听的TCP端口号bin-path ：本地FastCGI二进制程序的路径，当本地没有FastCGI正在运行时，会启动这个FastCGI程序。socket ：unix-domain-socket所在路径。mode ：可以选择FastCGI协议的模式，默认是“responder”，还可以选择authorizer。docroot ：这是一个可选项，对于responder模式来讲，表示远程主机docroot；对于authorizer模式来说，它表示MANDATORY，并且指向授权请求的docroot。check_local ：这是一个可选项，默认是enable。如果是enable，那么server会首先在本地（server.document-root）目录中检查被请求的文件是否存在，如果不存在，则给用户返回404（Not Found），而不会把这个请求传递给FastCGI。如果是disable，那么server不会检查本地文件，而是直接将请求转发给FastCGI。（disable的话，server从某种意义上说就变为了一个转发器）broken-scriptfilename ：以类似PHP抽取PATH_INFO的方式，抽取URL中的SCRIPT_FILENAME。 如果 bin-path 被设置了，那么： max-procs ：设置多少个FastCGI进程被启动bin-environment ：在FastCGI进程启动时设置一个环境变量bin-copy-environment ：清除环境，并拷贝指定的变量到全新的环境中。kill-signal ：默认的话，在停止FastCGI进程时，lighttpd会发送SIGTERM(-15)信号给子进程。此处可以设置发送的信号。 举例 ： 使用前缀来对应主机： 123456789fastcgi.server = ( \"/remote_scripts/\" =&gt; (( \"host\" =&gt; \"192.168.0.3\", \"port\" =&gt; 9000, \"check-local\" =&gt; \"disable\", \"docroot\" =&gt; \"/\" # remote server may use # it's own docroot ))) 如果有一个请求 “http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且 SCRIPT_NAME 会被赋值为 “/remote_scripts/test.cgi”。如果所设置的 handler 的末尾不是 “/” ，那么会被认为是一个文件。 负载均衡 ： FastCGI 模块提供了一种在多台 FastCGI 服务器间负载均衡的方法。 例如： 123456789fastcgi.server = ( \".php\" =&gt; ( ( \"host\" =&gt; \"10.0.0.2\", \"port\" =&gt; 1030 ), ( \"host\" =&gt; \"10.0.0.3\", \"port\" =&gt; 1030 ) ) ) 为了更好的理解负载均衡实现的原理，建议你置 fastcgi.debug 为 1 。即使对于本机的多个 FastCGI ，你也会获得如下输出： 123456789101112proc: 127.0.0.1 1031 1 1 1 31454proc: 127.0.0.1 1028 1 1 1 31442proc: 127.0.0.1 1030 1 1 1 31449proc: 127.0.0.1 1029 1 1 2 31447proc: 127.0.0.1 1026 1 1 2 31438got proc: 34 31454release proc: 40 31438proc: 127.0.0.1 1026 1 1 1 31438proc: 127.0.0.1 1028 1 1 1 31442proc: 127.0.0.1 1030 1 1 1 31449proc: 127.0.0.1 1031 1 1 2 31454proc: 127.0.0.1 1029 1 1 2 31447 上述信息显示出了IP地址，端口号、当前链接数（也就是负载）（倒数第二列）、进程ID（倒数第一列）等等。整个输出信息总是以负载域来从小到大排序的。 参考文献 说说lighttpd的fastcgi Nginx + CGI/FastCGI + C/Cpp FastCGI+lighttpd开发之介绍和环境搭建 附：QC V3 PP 版本 lighttpd.conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091$ cat /etc/qtilighttpd.conf # ------------------------------------------------------------------------------# Copyright (c) 2016 Qualcomm Technologies, Inc.# All Rights Reserved.# Confidential and Proprietary - Qualcomm Technologies, Inc.# ------------------------------------------------------------------------------server.document-root = \"/opt/qcom/www\"server.port = 80server.username = \"apps\"server.groupname = \"apps\"server.bind = \"0.0.0.0\"server.tag = \"lighttpd\"$SERVER[\"socket\"] == \"[::]:80\" &#123; &#125;server.errorlog-use-syslog = \"enable\"accesslog.use-syslog = \"enable\"server.modules = ( \"mod_access\",\"mod_accesslog\", \"mod_cgi\", \"mod_fastcgi\")fastcgi.debug = 1fastcgi.server = ( \"/fsmoam\" =&gt; ( \"fsmoam.fcgi.handler\" =&gt; ( \"socket\" =&gt; \"/tmp/fsmoam.fcgi.socket\", \"check-local\" =&gt; \"disable\", \"bin-path\" =&gt; \"/opt/qcom/bin/tests/fsmWebServer --default-log-level=DEBUG\", \"max-procs\" =&gt; 1) ))# mimetype mappingmimetype.assign = ( \".pdf\" =&gt; \"application/pdf\", \".sig\" =&gt; \"application/pgp-signature\", \".spl\" =&gt; \"application/futuresplash\", \".class\" =&gt; \"application/octet-stream\", \".ps\" =&gt; \"application/postscript\", \".torrent\" =&gt; \"application/x-bittorrent\", \".dvi\" =&gt; \"application/x-dvi\", \".gz\" =&gt; \"application/x-gzip\", \".pac\" =&gt; \"application/x-ns-proxy-autoconfig\", \".swf\" =&gt; \"application/x-shockwave-flash\", \".tar.gz\" =&gt; \"application/x-tgz\", \".tgz\" =&gt; \"application/x-tgz\", \".tar\" =&gt; \"application/x-tar\", \".zip\" =&gt; \"application/zip\", \".mp3\" =&gt; \"audio/mpeg\", \".m3u\" =&gt; \"audio/x-mpegurl\", \".wma\" =&gt; \"audio/x-ms-wma\", \".wax\" =&gt; \"audio/x-ms-wax\", \".ogg\" =&gt; \"audio/x-wav\", \".wav\" =&gt; \"audio/x-wav\", \".gif\" =&gt; \"image/gif\", \".jpg\" =&gt; \"image/jpeg\", \".jpeg\" =&gt; \"image/jpeg\", \".png\" =&gt; \"image/png\", \".xbm\" =&gt; \"image/x-xbitmap\", \".xpm\" =&gt; \"image/x-xpixmap\", \".xwd\" =&gt; \"image/x-xwindowdump\", \".css\" =&gt; \"text/css\", \".html\" =&gt; \"text/html\", \".htm\" =&gt; \"text/html\", \".js\" =&gt; \"text/javascript\", \".asc\" =&gt; \"text/plain\", \".c\" =&gt; \"text/plain\", \".conf\" =&gt; \"text/plain\", \".text\" =&gt; \"text/plain\", \".txt\" =&gt; \"text/plain\", \".dtd\" =&gt; \"text/xml\", \".xml\" =&gt; \"text/xml\", \".mpeg\" =&gt; \"video/mpeg\", \".mpg\" =&gt; \"video/mpeg\", \".mov\" =&gt; \"video/quicktime\", \".qt\" =&gt; \"video/quicktime\", \".avi\" =&gt; \"video/x-msvideo\", \".asf\" =&gt; \"video/x-ms-asf\", \".asx\" =&gt; \"video/x-ms-asf\", \".wmv\" =&gt; \"video/x-ms-wmv\", \".bz2\" =&gt; \"application/x-bzip\", \".tbz\" =&gt; \"application/x-bzip-compressed-tar\", \".tar.bz2\" =&gt; \"application/x-bzip-compressed-tar\")index-file.names = ( \"index.html\" )cgi.assign = ( \".sh\" =&gt; \"/bin/sh\" )","categories":[],"tags":[{"name":"lighttpd","slug":"lighttpd","permalink":"http://miaopei.github.io/tags/lighttpd/"},{"name":"FastCGI","slug":"FastCGI","permalink":"http://miaopei.github.io/tags/FastCGI/"}]},{"title":"svn 常用操作命令","slug":"svn-常用操作命令","date":"2017-03-29T08:23:27.000Z","updated":"2019-06-05T04:03:57.392Z","comments":true,"path":"2017/03/29/svn-常用操作命令/","link":"","permalink":"http://miaopei.github.io/2017/03/29/svn-常用操作命令/","excerpt":"检出123456$ svn checkout http://路径(目录或文件的全路径) [本地目录全路径] --username 用户名$ svn checkout svn://路径(目录或文件的全路径) [本地目录全路径] --username 用户名# 也可以使用缩写# 例子：$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc$ svn co http://localhost/test/testapp --username wzhnsc","text":"检出123456$ svn checkout http://路径(目录或文件的全路径) [本地目录全路径] --username 用户名$ svn checkout svn://路径(目录或文件的全路径) [本地目录全路径] --username 用户名# 也可以使用缩写# 例子：$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc$ svn co http://localhost/test/testapp --username wzhnsc 注 ：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。 不指定本地目录全路径，则检出到当前目录下。 导出（导出一个干净的不带.svn文件夹的目录树）1234567$ svn export [-r 版本号] http://路径(目录或文件的全路径) [本地目录全路径] --username 用户名$ svn export [-r 版本号] svn://路径(目录或文件的全路径) [本地目录全路径] --username 用户名$ svn export 本地检出的(即带有.svn文件夹的)目录全路径 要导出的本地目录全路径# 例子：$ svn export svn://localhost/测试工具 /home/testtools --username wzhnsc$ svn export svn://localhost/test/testapp --username wzhnsc$ svn export /home/testapp /home/testtools 注 ：第一种从版本库导出干净工作目录树的形式是指定URL， ​ 如果指定了修订版本号，会导出相应的版本， ​ 如果没有指定修订版本，则会导出最新的，导出到指定位置。 ​ 如果省略 本地目录全路径，URL的最后一部分会作为本地目录的名字。 ​ 第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留， ​ 但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。 添加新文件1234567$ svn add 文件名# 注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！# 例子：$ svn add test.php # 添加test.php $ svn commit -m \"添加我的测试用test.php\" test.php$ svn add *.php # 添加当前目录下所有的php文件$ svn commit -m \"添加我的测试用全部php文件\" *.php 提交12345678910$ svn commit -m \"提交备注信息文本\" [-N] [--no-unlock] 文件名$ svn ci -m \"提交备注信息文本\" [-N] [--no-unlock] 文件名# 必须带上-m参数，参数可以为空，但是必须写上-m# 例子：$ svn commit -m \"提交当前目录下的全部在版本控制下的文件\" * # 注意这个*表示全部文件$ svn commit -m \"提交我的测试用test.php\" test.php$ svn commit -m \"提交我的测试用test.php\" -N --no-unlock test.php # 保持锁就用–no-unlock开关$ svn ci -m \"提交当前目录下的全部在版本控制下的文件\" * # 注意这个*表示全部文件$ svn ci -m \"提交我的测试用test.php\" test.php$ svn ci -m \"提交我的测试用test.php\" -N --no-unlock test.php # 保持锁就用–no-unlock开关 更新文件123456789101112$ svn update$ svn update -r 修正版本 文件名$ svn update 文件名# 例子：# 后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本$ svn update # 将版本库中的文件 test.cpp 还原到修正版本（revision）200$ svn update -r 200 test.cpp# 更新与版本库同步。提交的时候提示过期冲突，需要先 update 修改文件，然后清除svn resolved，最后再提交commit。$ svn update test.php 删除文件123456789$ svn delete svn://路径(目录或文件的全路径) -m \"删除备注信息文本\"# 推荐如下操作：$ svn delete 文件名 $ svn ci -m \"删除备注信息文本\"# 例子：$ svn delete svn://localhost/testapp/test.php -m \"删除测试文件test.php\"# 推荐如下操作：$ svn delete test.php $ svn ci -m \"删除测试文件test.php\" 加锁 / 解锁12345$ svn lock -m \"加锁备注信息文本\" [--force] 文件名 $ svn unlock 文件名# 例子：$ svn lock -m \"锁信测试用test.php文件\" test.php $ svn unlock test.php 比较差异12345678$ svn diff 文件名 $ svn diff -r 修正版本号m:修正版本号n 文件名# 例子：# 将修改的文件与基础版本比较$ svn diff test.php # 对修正版本号200 和 修正版本号201 比较差异$ svn diff -r 200:201 test.php 查看文件或者目录状态123456789$ svn st 目录路径/名# 目录下的文件和子目录的状态，正常状态不显示.# 【?：不在svn的控制中； M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 $ svn status 目录路径/名 $ svn -v 目录路径/名# 显示文件和子目录状态# 【第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人】$ svn status -v 目录路径/名 注 ：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 查看日志1234$ svn log 文件名# 例子：# 显示这个文件的所有修改记录，及其版本号的变化$ svn log test.php 查看文件详细信息123$ svn info 文件名# 例子：$ svn info test.php SVN 帮助1234# 全部功能选项$ svn help# 具体功能的说明$ svn help ci 查看版本库下的文件和目录列表1234567$ svn list svn://路径(目录或文件的全路径)$ svn ls svn://路径(目录或文件的全路径)# 例子：$ svn list svn://localhost/test# 显示svn://localhost/test目录下的所有属于版本库的文件和目录$ svn ls svn://localhost/test 创建纳入版本控制下的新目录12345$ svn mkdir 目录名$ svn mkdir -m \"新增目录备注文本\" http://目录全路径# 例子：$ svn mkdir newdir$ svn mkdir -m \"Making a new dir.\" svn://localhost/test/newdir 注 ： 添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败” 1$ svn update 注 ：如果手工在checkout出来的目录里创建了一个新文件夹newsubdir， ​ 再用svn mkdir newsubdir命令后，SVN会提示： ​ svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？ ​ svn: 无法创建目录“hello”: 文件已经存在 此时，用如下命令解决： svn add --non-recursive newsubdir​ 在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录 ​ 再用 svn mkdir -m “添hello功能模块文件” svn://localhost/test/newdir/newsubdir 命令， ​ SVN提示： ​ svn: File already exists: filesystem ‘/data/svnroot/test/db’, transaction ‘4541-1’, ​ path ‘/newdir/newsubdir ‘ 恢复本地修改12345678$ svn revert [--recursive] 文件名# 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。# 例子：# 丢弃对一个文件的修改$ svn revert foo.c# 恢复一整个目录的文件，. 为当前目录$ svn revert --recursive . 把工作拷贝更新到别的URL1234$ svn switch http://目录全路径 本地目录全路径# 例子：# (原为123的分支)当前所在目录分支到localhost/test/456$ svn switch http://localhost/test/456 . 解决冲突12345678910111213$ svn resolved [本地目录全路径]# 例子：$ svn updateC foo.cUpdated to revision 31.# 如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：$ lsfoo.cfoo.c.minefoo.c.r30foo.c.r31# 当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。# 你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。 不checkout而查看输出特定文件或URL的内容1234567891011$ svn cat http://文件全路径# 例子：$ svn cat http://localhost/test/readme.txt# 新建一个分支copy# 从branchA拷贝出一个新分支branchB$ svn copy branchA branchB -m \"make B branch\" # 合并内容到分支merge# 把对branchA的修改合并到分支branchB$ svn merge branchA branchB","categories":[],"tags":[{"name":"svn","slug":"svn","permalink":"http://miaopei.github.io/tags/svn/"}]},{"title":"hexo 使用指南","slug":"hexo-使用指南","date":"2017-03-28T08:53:46.000Z","updated":"2019-06-05T04:03:57.392Z","comments":true,"path":"2017/03/28/hexo-使用指南/","link":"","permalink":"http://miaopei.github.io/2017/03/28/hexo-使用指南/","excerpt":"安装、初始化和配置准备工作 git node.js github","text":"安装、初始化和配置准备工作 git node.js github 安装和初始化首先确定已经安装好了 nodejs 和 npm 以及 git 12345$ npm install hexo -g$ hexo init blog$ cd blog$ npm install$ hexo server 访问http://localhost:4000，会看到生成好的博客。 主目录结构12345678|-- _config.yml|-- package.json|-- scaffolds|-- source |-- _posts|-- themes|-- .gitignore|-- package.json _config.yml 全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。 package.json hexo框架的参数和所依赖插件，如下： 12345678910111213141516171819&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"3.2.0\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.2.0\", \"hexo-generator-archive\": \"^0.1.4\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.2.0\", \"hexo-renderer-stylus\": \"^0.3.1\", \"hexo-renderer-marked\": \"^0.2.10\", \"hexo-server\": \"^0.2.0\" &#125;&#125; scaffold scaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。 _config.yml文件 _config.yml 采用YAML语法格式，具体语法自行学习 。具体配置可以参考官方文档，_config.yml 文件中的内容，并对主要参数做简单的介绍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo #网站标题subtitle: #网站副标题description: #网站描述author: John Doe #作者language: #语言timezone: #网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com #你的站点Urlroot: / #站点的根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式 permalink_defaults: #永久链接中各部分的默认值# Directory source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹 archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 # Writingnew_post_name: :title.md #新文章的文件名称default_layout: post #预设布局titlecase: false #把标题转换为 title caseexternal_link: true #在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #是否显示草稿post_asset_folder: false #是否启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址 future: true #显示未来的文章highlight: #内容中代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式 # Pagination## Set per_page to 0 to disable paginationper_page: 10 #分页数量pagination_dir: page # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape #主题名称# Deployment## Docs: https://hexo.io/docs/deployment.html# 部署部分的设置deploy: type: git #类型，常用的git repo: https://github.com/nanshanyi/nanshanyi.github.io.git #github仓库的地址 注意如果页面中出现中文，应以UTF-8无BOM编码格式，所以不要用win自带的记事本，而是用notepad++这种支持编码转换的编辑器。 由于google在天朝大陆被墙，进入 themes\\landscape\\layout\\_partial ，打开 head.ejs ，删掉第31行 fonts.googleapis.com 的链接。 下载下来 jQuery-2.0.3.min.js ，放到 themes\\landscape\\source\\js 文件夹中。之后进入 themes\\landscape\\layout\\_partial ，打开 after-footer.ejs ，将第17行的路径替换为 /js/jquery-2.0.3.min.js 。 至此大功告成。 写文章&amp;草稿文章命令行输入： 1$ hexo new post \"new article\" 之后在 soource/_posts 目录下面多了一个 new-article.md 的文件。 文章属性 Setting Description Default layout Layout post或page title 文章的标题 date 穿件日期 文件的创建日期 updated 修改日期 文件的修改日期 comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字 文件名 toc 是否开启目录 true reward 是否开启打赏 true 分类和标签12345categories: - 日记tags: - Hexo - node.js 摘要&lt;!--more--&gt; 之上的内容为摘要。 草稿草稿相当于很多博客都有的“私密文章”功能。 1$ hexo new draft \"new draft\" 会在 source/_drafts 目录下生成一个 new-draft.md 文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到 _drafts 目录之中。 如果你希望强行预览草稿，更改配置文件： 1render_drafts: true 或者，如下方式启动server： 1$ hexo server --drafts 下面这条命令可以把草稿变成文章，或者页面： 1234$ hexo publish [layout] &lt;filename&gt;eg:$ hexo publish drafts hexo-使用指南 Blog中出入图片和音乐文章推介：Hexo 博客中插入音乐/视频 ​ 使用七牛为Hexo存储图片 [hexo主题中添加相册功能](http://www.cnblogs.com/xljzlw/p/5137622.html)​ 为 Hexo 主题添加多种图片样式(主题不错考虑移植) ​ Hexo折腾记——基本配置篇 ​ hexo博客进阶－相册和独立域名 插入图片基本分为两种办法** ： （1） 放在本地文件 首先在根目录下确认 _config.yml 中有 post_asset_folder:true 。在 hexo 目录，执行： 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 之后再使用 hexo new &#39;new&#39;创建新博客的时候，会在 source/_posts 里面创建 .md 文件的同时生成一个相同的名字的文件夹。把该文章中需要使用的图片放在该文件夹下即可。使用的时候 123![“图片描述”（可以不写）](/文件夹名/你的图片名字.JPG)例如：！[ ] (new/text.jpg) （2）放在七牛上，需要先注册，上传图片生成链接，直接在文章中使用链接即可。 插入音乐 ： 可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器；复制代码，直接粘贴到博文中即可。这样会显示一个网易的播放器，可以把 12&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"http://music.163.com/outchain/player?type=2&amp;id=32192436&amp;auto=1&amp;height=32\"&gt;&lt;/iframe&gt;//其中的width=298 height=52 均改为0就看不到了，依然可以播放音乐 代码高亮highlight.js支持highlightjs官网 highlightjs主题风格 其他Hexo，Yilia主题添加站内搜索功能 为Hexo博客添加目录 Hexo站点中添加文章目录以及归档 使用LeanCloud平台为Hexo博客添加文章浏览量统计组件 使用hexo搭建静态博客 Hexo Docs中文 ： （二）基本用法","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://miaopei.github.io/tags/hexo/"}]},{"title":"nodejs+webpack+vuejs 搭建开发环境学习套路","slug":"nodejs-webpack-vuejs-搭建开发环境学习套路","date":"2017-03-27T10:02:52.000Z","updated":"2017-03-28T10:25:52.000Z","comments":true,"path":"2017/03/27/nodejs-webpack-vuejs-搭建开发环境学习套路/","link":"","permalink":"http://miaopei.github.io/2017/03/27/nodejs-webpack-vuejs-搭建开发环境学习套路/","excerpt":"官方文档官方手册 中文官网 vuejs 2.0 中文文档 ECMAScript 6 入门 node.js相关的中文文档及教程 Node.js中文网API Webpack 中文指南 webpack2.2中文文档 以上是提供的一些官方资料，下面开始我们的套路吧：","text":"官方文档官方手册 中文官网 vuejs 2.0 中文文档 ECMAScript 6 入门 node.js相关的中文文档及教程 Node.js中文网API Webpack 中文指南 webpack2.2中文文档 以上是提供的一些官方资料，下面开始我们的套路吧： 环境构建1.新建一个目录vuepro2.初始化 1234$ cd vuepro# 初始化的时候可以一路回车，在最后输入\"yes\"后会生成package.json文件$ npm init 3.安装模块，先装这么多，有需要再安装 1$ npm install vue webpack babel-loader babel-core babel-preset-env babel-cli babel-preset-es2015 html-webpack-plugin --save-dev 4.创建良好的目录层级 12$ mkdir src$ cd src &amp;&amp; mkdir -p html jssrc webapp html放置模板文件，jssrc放置js文件，最终编译好的文件放置在webapp目录里，这个目录也就是我们网站的目录。 5.在项目根目录下创建webpack配置文件：webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738var HtmlWebpackPlugin = require('html-webpack-plugin');var webpack=require(\"webpack\");module.exports =&#123; entry: &#123; //入口文件 \"index\":__dirname+'/src/jssrc/index.js', &#125;, output: &#123; path: __dirname+'/src/webapp/js', //输出文件夹 filename:'[name].js' //最终打包生成的文件名(只是文件名，不带路径的哦) &#125;, /*resolve: &#123; alias: &#123; vue: 'vue/dist/vue.js' &#125; &#125;,*/ externals: &#123; &#125;, module:&#123; loaders:[ &#123;test:/\\.js$/,loader:\"babel-loader\",query:&#123;compact:true&#125;&#125;, //这里肯定要加入n个loader 譬如vue-loader、babel-loader、css-loader等等 ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; filename: __dirname+'/src/webapp/index.html', //目标文件 template: __dirname+'/src/html/index.html', //模板文件 inject:'body', hash:true, //代表js文件后面会跟一个随机字符串,解决缓存问题 chunks:[\"index\"] &#125;) ]&#125; 6.同样在根目录下创建babel配置文件：.babelrc 123&#123; &quot;presets&quot; : [&quot;es2015&quot;]&#125; 然后就可以在webpack里面配置loader，我们上面webpack配置中已经写了： 1234loaders:[ &#123;test:/\\.js$/,loader:\"babel-loader\",query:&#123;compact:true&#125;&#125;, // 经过测试旧版用的是loader:\"babel\",在新版中用的是loader:\"babel-loader\" ] 这句话意思就是：凡是 .js 文件都使用 babel-loader , 并且压缩。 学习vue最简单的一个套路思考：数据如何渲染？ 套路如下： 首先要有个数据块标记 vue里面可以像模板引擎一样写上 {\\{name\\}} 其中 name 就是变量名 接下来进行实战练习 index.htm l如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"me\"&gt; 我的年龄是&#123;age&#125; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; index.js 如下： 123456import Vue from \"vue\"; //会去node_modules\\vue\\package.jsonnew Vue(&#123; el:\"#me\", data:&#123;age:18&#125;&#125;) 至此，我们需要用 webpack 打包，打包到 webapp 目录下。 需要修改2个地方： (1)因为我们的 webpack 不是全局安装的，所以不能直接执行 webpack 命令，我们这里借助 npm 来执行。所以需要修改项目根目录下的 package.json 文件，加入： 1234\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\"&#125;, 表示：执行build，就会去node_modules.bin\\下去寻找webpack命令。build 这个名字是自定义的。 (2)还需要修改 webpack 配置文件：webpack.config.js 12345resolve: &#123; alias: &#123; vue: 'vue/dist/vue.js' &#125; &#125;, 我们之前把这个注释掉了，现在打开。此处的意义是找到 node_modules/vue/dist/vue.js 最后，我们就来打包，看看结果是怎样的？ 终端里还是cd到项目根目录下，执行： 1$ npm run build index.html 就是打包之后的模板文件，js/index.js 就是打包之后的js文件，在 index.html 被引用了。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"me\"&gt; 我的年龄是&#123;age&#125; &lt;/div&gt;&lt;script type=\"text/javascript\" src=\"js/index.js?43c73980e35f1569ef72\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预览一下index.html: 这样就完成了 vueJS 的一个简单案列","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://miaopei.github.io/tags/nodejs/"}]},{"title":"Hexo + Github 博客多终端同步","slug":"Hexo-Github-博客多终端同步","date":"2017-03-19T20:20:57.000Z","updated":"2019-06-05T04:03:57.392Z","comments":true,"path":"2017/03/20/Hexo-Github-博客多终端同步/","link":"","permalink":"http://miaopei.github.io/2017/03/20/Hexo-Github-博客多终端同步/","excerpt":"原文链接 主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解：","text":"原文链接 主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解： 1. 准备条件安装了Node.js,Git,Hexo环境完成Github与本地Hexo的对接这部分大家可以参考史上最详细的Hexo博客搭建图文教程 配置好这些，就可以捋起袖子大干一场了！ 2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上在利用Github+Hexo搭建自己的博客时，新建了一个Hexo的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到Github项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示： 123456789101112131415161718# 初始化本地仓库$ git init# 将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件$ git add source$ git commit -m \"Blog Source Hexo\"# 新建hexo分支$ git branch hexo# 切换到hexo分支上$ git checkout hexo# 将本地与Github项目对接$ git remote add origin https://github.com/yourname/yourname.github.io.git# push到Github项目的hexo分支上$ git push origin hexo 这样你的github项目中就会多出一个Hexo分支，这个就是用于多终端同步关键的部分。 3. 另一终端完成clone和push更新此时在另一终端更新博客，只需要将Github的hexo分支clone下来，进行初次的相关配置 123456789101112131415161718192021222324# 将Github中hexo分支clone到本地$ git clone -b hexo https://github.com/yourname/yourname.github.io.git# 切换到刚刚clone的文件夹内$ cd yourname.github.io# cheackout 远程代码到本地hexo分支$ git checkout -b hexo origin/hexo# 注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init$ npm install# 新建一个.md文件，并编辑完成自己的博客内容$ hexo new post \"new blog name\"# 经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客$ git add source$ git commit -m \"XX\"# 更新分支$ git push origin hexo# push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master$ hexo d -g 4. 不同终端间愉快地玩耍在不同的终端已经做完配置，就可以愉快的分享自己更新的博客进入自己相应的文件夹 123456789101112# 先pull完成本地与远端的融合$ git pull origin hexo$ hexo new post \" new blog name\"$ git add source$ git commit -m \"XX\"$ git push origin hexo$ hexo d -g","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://miaopei.github.io/tags/hexo/"}]},{"title":"常用Git命令清单","slug":"git-common-list","date":"2017-01-27T10:02:52.000Z","updated":"2019-06-03T08:10:56.870Z","comments":true,"path":"2017/01/27/git-common-list/","link":"","permalink":"http://miaopei.github.io/2017/01/27/git-common-list/","excerpt":"我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。","text":"我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url]二、配置Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot;三、增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed]四、代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...五、分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]六、标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag]七、查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog八、远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all九、撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop十、其他# 生成一个可供发布的压缩包 $ git archive","categories":[{"name":"git","slug":"git","permalink":"http://miaopei.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://miaopei.github.io/tags/git/"}]},{"title":"Git使用规范流程","slug":"git-using-standard-process","date":"2017-01-27T10:02:52.000Z","updated":"2019-06-03T08:10:56.870Z","comments":true,"path":"2017/01/27/git-using-standard-process/","link":"","permalink":"http://miaopei.github.io/2017/01/27/git-using-standard-process/","excerpt":"团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。 否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。 下面是ThoughtBot 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。","text":"团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。 否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。 下面是ThoughtBot 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。 第一步：新建分支首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考《Git分支管理策略》）。 # 获取主干最新代码 $ git checkout master $ git pull # 新建一个开发分支myfeature $ git checkout -b myfeature第二步：提交分支commit分支修改后，就可以提交commit了。 $ git add --all $ git status $ git commit --verbosegit add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。 git status 命令，用来查看发生变动的文件。 git commit 命令的 verbose 参数，会列出 diff 的结果。 第三步：撰写提交信息提交commit时，必须给出完整扼要的提交信息，下面是一个范本。 Present-tense summary under 50 characters * More information about commit (under 72 characters). * More information about commit (under 72 characters). http://project.management-system.com/ticket/123第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。 第四步：与主干同步分支的开发过程中，要经常与主干保持同步。 $ git fetch origin $ git rebase origin/master第五步：合并commit分支开发完成后，很可能有一堆 commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。 那么，怎样才能将多个 commit 合并呢？这就要用到 git rebase 命令。 $ git rebase -i origin/mastergit rebase 命令的 i 参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。 pick 07c5abd Introduce OpenPGP and teach basic usage pick de9b1eb Fix PostChecker::Post#urls pick 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend # Rebase 8db7e8b..fa20af3 onto 8db7e8b # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out上面的互动界面，先列出当前分支最新的4个 commit（越下面越新）。每个 commit 前面有一个操作命令，默认是 pick，表示该行 commit 被选中，要进行 rebase 操作。 4个commit的下面是一大堆注释，列出可以使用的命令。 pick：正常选中 reword：选中，并且修改提交信息； edit：选中，rebase时会暂停，允许你修改这个commit（参考这里） squash：选中，会将当前commit与上一个commit合并 fixup：与squash相同，但不会保存当前commit的提交信息 exec：执行其他shell命令 上面这6个命令当中，squash 和 fixup 可以用来合并 commit。先把需要合并的 commit 前面的动词，改成 squash（或者s）。 pick 07c5abd Introduce OpenPGP and teach basic usage s de9b1eb Fix PostChecker::Post#urls s 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。 # This is a combination of 3 commits. # The first commit&apos;s message is: Introduce OpenPGP and teach basic usage # This is the 2nd commit message: Fix PostChecker::Post#urls # This is the 3rd commit message: Hey kids, stop all the highlighting如果将第三行的 squash 命令改成 fixup 命令。 pick 07c5abd Introduce OpenPGP and teach basic usage s de9b1eb Fix PostChecker::Post#urls f 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。 # This is a combination of 3 commits. # The first commit&apos;s message is: Introduce OpenPGP and teach basic usage # This is the 2nd commit message: Fix PostChecker::Post#urls # This is the 3rd commit message: # Hey kids, stop all the highlightingPony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。 $ git reset HEAD~5 $ git add . $ git commit -am &quot;Here&apos;s the bug fix that closes #28&quot; $ git push --forcesquash 和 fixup 命令，还可以当作命令行参数使用，自动合并commit。 $ git commit --fixup $ git rebase -i --autosquash 这个用法请参考http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html，这里就不解释了。 第六步：推送到远程仓库合并commit后，就可以推送当前分支到远程仓库了。 $ git push --force origin myfeaturegit push 命令要加上 force 参数，因为 rebase 以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送。 第七步：发出Pull Request提交到远程仓库以后，就可以发出 Pull Request 到 master 分支，然后请求别人进行代码 review，确认可以合并到 master。","categories":[{"name":"git","slug":"git","permalink":"http://miaopei.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://miaopei.github.io/tags/git/"}]},{"title":"Docker 学习笔记","slug":"Docker-学习笔记","date":"2016-12-23T02:14:50.000Z","updated":"2019-06-03T08:10:56.874Z","comments":true,"path":"2016/12/23/Docker-学习笔记/","link":"","permalink":"http://miaopei.github.io/2016/12/23/Docker-学习笔记/","excerpt":"Docker基本命令常用Docker命令","text":"Docker基本命令常用Docker命令 1234567891011121314151617181920# 开启Docker守护进程调试模式$ sudo docker daemon -D# 查看Docker信息$ sudo docker info # 停止或者启动Docker$ sudo service docker stop/start # 以命令行模式运行一个容器$ sudo docker run -i -t ubuntu /bin/bash # 给容器命名$ sudo docker run --name Micheal_container -i -t ubuntu /bin/bash# 启动或者停止运行的容器$ sudo docker start/stop Micheal_container # 附着到正在运行的容器$ sudo docker attach Micheal_container 创建守护式容器 1$ sudo docker run --name daemon_dave -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 上面的docker run 使用了-d参数，因此Docker会将容器放到后台运行。 Docker日志 1234567891011121314# 获取守护式容器的日志$ sudo docker logs daemon_dave# 跟踪守护式容器的日志$ sudo docker logs -f daemon_dave# 获取日志的最后10行$ sudo docker logs --tail 10 daemon_dave # 跟踪某个容器的最新日志$ sudo docker logs --tail 0 -f daemon_dave# -t 标志为每条日志项加上时间戳$ sudo docker logs -ft daemon_dave Docker日志驱动 1$ sudo docker run --log-driver=\"syslog\" --name daemon_dave -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 使用syslog将会禁用docker logs命令，并且将所有容器的日志输出都重定向到Syslog。 查看容器内的进程 1$ sudo docker top daemon_dave Docker统计信息 1$ sudo docker stats daemon_dave daemon_kate daemon_clear daemon_sarah 以上命令可以看到一个守护容器的列表，以及他们的CPU、内存、网络I/O以及存储I/O的性能和指标。这对快速监控一台主机上的一组容器非常有用。 在容器内部运行进程 1$ sudo docker exec -d daemon_dave touch /etc/new_config_file -d表示需要运行一个后台进程 12# 在容器内运行交互命令$ sudo docker exec -t -i daemon_dave /bin/bash 自动重启容器 1$ sudo docker run --restart=always --name daemon_dave -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" --restart标志被设置为always。无论容器的退出代码是什么，Docker都会自动重启改容器。除了always，还可以将这个标志设为on-failure，这样，只有当容器的退出代码为非0值的时候，才会自动重启。另外，on-failure还接受一个可选的重启次数参数，--restart=on-failure:5,Docker会尝试自动重启改容器，最多重启5次。 深入容器 1$ sudo docker inspect daemon_dave docker inspect命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置以及很多有用的数据。可以使用-f或者--format标志来选定查看结果。 1$ sudo docker inspect --format='&#123;.State.Running&#125;' daemon_dave 查看多个容器 1$ sudo docker inspect --format '&#123;.Name&#125; &#123;.State.Running&#125;' daemon_dave Micheal_container 删除容器​ 1234$ sudo docker rm daemon_dave# 删除所有容器$ sudo docker rm `sudo docker ps -a -q` 列出所有镜像 1$ sudo docker images 拉去镜像 1$ sudo docker pull ubuntu:16.04 运行一个带标签的Docker镜像 1$ sudo docker run -i -t --name new_container ubuntu:16.04 /bin/bash 查找镜像 1$ sudo docker search puppet 构建镜像 使用docker commit命令 使用docker build命令和Dockerfile文件 用Docker的commit命令创建镜像 123456789101112131415$ sudo docker run -i -t ubuntu /bin/bash# 接下来安装需要安装的工具，安装完成后exit退出容器, eg：$ apt-get -yqq update$ apt-get -y install apache2# 指定提交修改过的容器的ID（可以通过docker ps -l -q命令得到刚创建的容器的ID）$ sudo docker commit 4aab3cecb76 micheal/apache2 # 检查新创建的镜像sudo docker images micheal/apache2 # 提交另一个新定制容器# -m 选项用来指定新创建的镜像的提交信息，-a 用来列出该镜像的作者信息。$ sudo docker commit -m\"A new custom image\" -a\"Micheal\" 4aab3cecb76 micheal/apache2:webserver 用Dockerfile构建镜像 Dockerfile文件示例： 123456# Vsersion: 0.0.1FROM ubuntu:16.04MAINTAINER Micheal \"miaopei@baicells.com\"RUN apt-get -yqq update &amp;&amp; apt-get -y install nginxRUN echo 'Hi, I an in your container' &gt; /usr/share/nginx/html/index.htmlEXPOSE 80 Dockerfile中的指令会按照顺序从上到下执行，所以根据需要合理安排指令的顺序。 如果Dockerfile由于某些原因没有正常结束，那么用户得到了一个可以使用的镜像。这对调试非常有帮助：可以基于改镜像运行一个具备交互功能的容器，使用最后创建的镜像对为什么用户指令会失败进行调试。 每个Dockerfile的第一条指令必须是FROM,FROM指令指定一个已经存在的镜像，后续指令都将基于该镜像进行，这个镜像被称为基础镜像。 MAINTAINER指令告诉Docker镜像的作者是谁，以及作者的电子邮件。有助于标识镜像的所有者和联系方式。 默认情况下，RUN指令会在shell里使用命令包装器/bin/sh -c来执行，如果是在一个不支持shell的平台上运行或者不希望在shell中运行（比如避免shell字符串篡改），也可以使用exec格式的RUN指令，如下所示： 1RUN [ \"apt-get\", \" install\", \"-y\", \"nginx\" ] EXPOSE指令告诉Docker该容器内的应用程序将会使用该容器的指定端口。 基于Dockerfile构建新镜像 12345678$ sudo docker build -t=\"micheal/static_web\" .$ sudo docker build -t=\"micheal/static_web:v1\" .# 这里Docker假设在这个Git仓库的根目录下存在Dockerfile文件$ sudo docker build -t=\"micheal/static_web:v1\" git@github.com:micheal/docker_static_web # 忽略Dockerfile的构建缓存$ sudo docker build --no-cache -t=\"micheal/static_web\" . 查看镜像 1234567# 列出Docker镜像$ sudo docker images# 查看镜像每一层，以及创建这些层的Dockerfile指令$ sudo docker history micheal/static_web $ sudo docker run -d -p 80 --name statix_web micheal/static_web nginx -g \"daemon off;\" nginx -g “daemon off;”,这将以前台的方式启动Nginx。 -p标志用来控制Docker在运行时应该公开那些网络端口给外部（宿主机）。运行一个容器时，Docker可以通过两种方式来在宿主机上分配端口。 Docker可以在宿主机上随机选择一个位于32768 ~ 61000的一个比较大的端口号来映射到容器中的80端口上。 可以在Docker宿主机只指定一个具体的端口号来映射到容器中的80端口上。 查看Docker端口映射情况 1234567$ sudo docker ps -l# 返回宿主机中映射的端口$ sudo socker port static_web 80 # -p会将容器内的80端口绑定到宿主机的8080端口上$ sudo docker run -d -p 8080:80 --name statix_web micheal/static_web nginx -g \"daemon off;\" Dockerfile指令 CMD CMD指令用于指定一个容器启动时要运行的命令。这有点儿类似于RUN指令，只是RUN指令是指定容器镜像被构建时要运行的命令，而CMD是指定容器被启动时要运行的命令。 1CMD [\"/bin/bash/\", \"-l\"] ENTRYPOINT ENTRYPOINT和CMD指令非常类似，我们可在docker run命令行中覆盖CMD指令，而ENTRYPOINT指令提供的命令则不容易在启动容器的时候被覆盖。 可以组合使用ENTRYPOINT和CMD指令来完成一些巧妙的工作。 12ENTRYPOINT [\"/usr/sbin/nginx\"]CMD [\"-h\"] WORKDIR WORKDIR指令用来在从镜像创建一个新容器时，在容器内部设置一个工作目录，ENTRYPOINT和/或CMD指定的程序会在这个目录下执行。 1234WORKDIR /opt/webapp/dbRUN bundle installWORKDIR /opt/webappENTRYPOINT [\"rackup\"] 可以通过-w标志在运行时覆盖工作目录 1$ sudo docker run -ti -w /var/log ubuntu pwd/var/log ENV ENV指令用来在镜像构建过程中设置环境变量。这些变量会持久保存到从我们镜像创建的任何容器中。 1ENV RVM_PATH /home/rvm 也可以使用docker run命令行的-e标志来传递环境变量。这些环境变量只会在运行时有效。 1$ sudo docker run -ti -e \"WEB_PORT=8080\" ubuntu env USER USER指令用来指定该镜像会以什么样的用户身份来运行。我们可以指定用户名或者UID以及组或GID，甚至是两者的组合。 123456USER userUSER user:groupUSER uidUSER uid:gidUSER user:gidUSER uid:group 也可以在docker run命令行中通过-u标志覆盖该指令指定的值。 VOLUME VOLUME指令用来向基于镜像创建的容器添加卷。一个卷可以存在于一个或者多个容器内特定的目录，这个目录可以绕过联合文件系统，并提供如下共享数据或者对数据进行持久化的功能。 卷可以在容器间共享和重用 一个容器可以不是必须和其他容器共享卷 对卷的修改是立即生效的 对卷的修改不会对更新镜像产生影响 卷会一直存在直到没有任何容器再使用它 卷功能让我们可以将数据（如源代码）、数据库或者其他内容添加到镜像中而不是将这些内容提交到镜像中，并且允许我们在多个容器间共享这些内容，我们可以利用此功能来测试容器和内部应用程序代码，管理日志，或者处理容器内部的数据库。 1VOLUME [\"/opt/project\"] 这条指令将会基于此镜像的任何容器创建一个名为/opt/project的挂载点。 也可以通过指定数组的方式指定多个卷 1VOLUME [\"/opt/project\", \"/data\"] ADD ADD指令用来将构建环境下的文件和目录复制到镜像中。不能对构建目录或者上下文之外的文件进行ADD操作。 12ADD software.lic /opt/application/software.licADD latest.tar.gz /var/www/wordpress/ //这条指令会将归档文件解开到指定的目录下 COPY COPY指令非常类似ADD，它们根本不同是COPY只关心构建上下文中复制本地文件，而不会去做文件提取（extraction）和解压（decompression）的工作。 1COPY conf.d/ /etc/apache2/ LABEL LABEL指令用于为Docker镜像添加元数据。元数据以键值对的形式展现 12LABEL version=\"1.0\"LABEL location=\"New York\" type=\"Data Center\" role=\"Web Server\" 可以使用docker inspect命令查看容器标签 1$ sudo docker inspect micheal/apache2 STOPSIGNAL STOPSIGNAL指令用来设置停止容器时发送什么系统调用信号给容器。 ARG ARG指令用来定义可以在docker build命令运行时传递给构建运行时的变量，我们只需要在构建时使用–build-arg标志即可。用户只能在构建时指定在Dockerfile文件汇总定义过的参数。 1234ARG buildARG webapp_user=user$ docker build --build-arg build=1234 -t micheal/webapp . ONBUILD ONBUILD指令能为镜像添加触发器（trigger）。当一个镜像被用做其他镜像的基础镜像时（比如用户的镜像需要从某未准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本），该镜像中的触发器将会被执行。 触发器会在构建过程中插入新指令，我们可以认为这些指令是紧跟在FROM之后指定的。触发器可以是任何构建指令。 12ONBUILD ADD . /app/srcONBUILD RUN cd /app/src/ &amp;&amp; make 上面的代码将会在创建的镜像中加入ONBUILD触发器，ONBUILD指令可以在镜像上运行docker inspect命令查看。 Docker Networking 容器之间的连接用网络创建，这被称为Docker Networking。Docker Networking允许用户创建自己的网络，容器可以通过这个网上互相通信。更重要的是，现在容器可以跨越不同的宿主机来通信，并且网络配置可以更灵活的定制。Docker Networking也和Docker Compose以及Swarm进行了集成。 要想使用Docker网络，需要先创建一个网络，然后在这个网络下启动容器。 1$ sudo docker network create app 这里使用docker network命令创建了一个桥接网络，命名为app。可以使用docker network inspect命令查看新创建的这个网络。 1$ sudo docker network inspect app 我们可以看到这个新网络是一个本地的桥接网络（这非常像docker0网络），而且现在没有容器再这个网络中运行。 可以使用docker network ls命令列出当前系统中所有的网络。 1$ sudo docker network ls 也可以使用 docker network rm命令删除一个Docker网络。 在Docker网络中创建Redis容器 1$ sudo docker run -d --net=app --name db micheal/redis --net标志指定了新容器将会在那个网络中运行。 1$ sudo docker network inspect app 将已有容器连接到Docker网络 1$ sudo docker network connect app db2 可以通过docker network disconnect 命令断开一个容器与指定网络的连接 1$ sudo docker network disconnect app db2 通过Docker链接连接容器 启动一个Redis容器 1$ sudo docker run -d --name redis micheal/redis 注意：这里没有公开容器的任何端口。一会就能看到这么做的原因。 链接Redis容器 1$ sudo docker run -p 4567 --name webapp --link redis:db -t -i -v $PWD/webapp_redis:/opt/webapp micheal/sinatra /bin/bash 这个命令做了不少事情，我们逐一解释。首先，我们使用-p标志公开4567端口，这样就能从外面访问web应用程序。 我们还使用--name标志给容器命名为webapp，并且使用了-v标志把web应用程序目录作为卷挂载到了容器里。 然而，这次我们使用了一个新标志--link。--link标志创建了两个容器间的客户-服务链接。这个标志需要两个参数：一个是要链接的容器的名字，另一个是链接的别名。这个例子中我们创建了客户联系，webapp容器是客户，redis容器是“服务”，并且为这个服务增加了db作为别名。这个别名让我们可以一致地访问容器公开信息，而无须关注底层容器的名字。链接让服务容器有能力与客户容器通信，并且能分享一些连接细节，这些细节有助于在应用程序中配置并使用这个链接。 连接也能得到一些安全上的好处。注意，启动 Redis 容器时，并没有使用-p标志公开Redis的端口。因为不需要这么做。通过把容器链接在一起，可以让客户直接访问任意服务容器的公开端口（即客户webapp容器可以连接到服务redis容器的6379端口）。更妙的是，只有使用--link标志链接到这个容器的容器才能连接到这个端口。容器的端口不需要对本地宿主机公开，现在我们已经拥有一个非常安全的模型。通过这个安全模型，就可以限制容器化应用程序被攻击面，减少应用暴露的网络。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://miaopei.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://miaopei.github.io/tags/Docker/"}]},{"title":"CPlusPlus 设计模式","slug":"Program-C/cplus-设计模式","date":"2016-06-28T02:14:50.000Z","updated":"2019-06-11T08:14:19.395Z","comments":true,"path":"2016/06/28/Program-C/cplus-设计模式/","link":"","permalink":"http://miaopei.github.io/2016/06/28/Program-C/cplus-设计模式/","excerpt":"","text":"单例模式 单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。 定义一个单例类： 私有化它的构造函数，以防止外界创建单例类的对象； 使用类的私有静态指针变量指向类的唯一实例； 使用一个公有的静态方法获取该实例。 懒汉模式 即第一次调用该类实例的时候才产生一个新的该类实例，并在以后仅返回此实例。 需要用锁，来保证其线程安全性：原因：多个线程可能进入判断是否已经存在实例的 if 语句，从而non thread safety. 使用double-check来保证thread safety.但是如果处理大量数据时，该锁才成为严重的性能瓶颈。 1. 静态成员实例的懒汉模式： 12345678910111213141516171819202122class Singleton&#123;public: static Singleton* getInstance();private: static Singleton* m_instance; Singleton()&#123;&#125;&#125;;Singleton* Singleton::getInstance()&#123; if(NULL == m_instance) &#123; Lock();//借用其它类来实现，如boost if(NULL == m_instance) &#123; m_instance = new Singleton; &#125; UnLock(); &#125; return m_instance;&#125; 2. 内部静态实例的懒汉模式： 12345678910111213class SingletonInside&#123;public: static SingletonInside* getInstance() &#123; Lock(); // not needed after C++0x static SingletonInside instance; UnLock(); // not needed after C++0x return instance; &#125;private: SingletonInside()&#123;&#125;&#125;; 饿汉模式 即无论是否调用该类的实例，在程序开始时就会产生一个该类的实例，并在以后仅返回此实例。 由静态初始化实例保证其线程安全性，WHY？因为静态实例初始化在程序开始时进入主函数之前就由主线程以单线程方式完成了初始化，不必担心多线程问题。 故在性能需求较高时，应使用这种模式，避免频繁的锁争夺。 饿汉模式： 1234567891011121314class SingletonStatic&#123;public: static const SingletonStatic* getInstance() &#123; return m_instance; &#125;private: static const SingletonStatic* m_instance; SingletonStatic()&#123;&#125;&#125;;//外部初始化 before invoke mainconst SingletonStatic* SingletonStatic::m_instance = new SingletonStatic; m_pInstance 指向的空间什么时候释放呢？更严重的问题是，该实例的析构函数什么时候执行？ 单例模式 - 线程安全 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;&gt;using namespace std; class Singleton &#123;public: static Singleton *GetInstance(); private: Singleton() &#123; cout &lt;&lt; \"Singleton ctor\" &lt;&lt; endl; &#125; ~Singleton() &#123; cout &lt;&lt; \"Singleton dtor\" &lt;&lt; endl; &#125; static Singleton *m_pInstance; class Garbo &#123; public: ~Garbo() &#123; if (Singleton::m_pInstance) &#123; cout &lt;&lt; \"Garbo dtor\" &lt;&lt; endl; delete Singleton::m_pInstance; &#125; &#125; &#125;; static Garbo garbo; &#125;; Singleton::Garbo Singleton::garbo; // 一定要初始化，不然程序结束时不会析构garboSingleton *Singleton::m_pInstance = NULL;Singleton *Singleton::GetInstance()&#123; if (m_pInstance == NULL) m_pInstance = new Singleton; return m_pInstance; &#125; int main()&#123; Singleton *p1 = Singleton::GetInstance(); Singleton *p2 = Singleton::GetInstance(); if (p1 == p2) cout &lt;&lt; \"p1 == p2\" &lt;&lt; endl; return 0;&#125; 12345# 输出结果如下：Singleton ctorp1 == p2Garbo dtorSingleton dtor 类 CGarbo 被定义为 CSingleton 的私有内嵌类，以防该类被在其他地方滥用。 程序运行结束时，系统会调用 CSingleton的 静态成员 Garbo 的析构函数，该析构函数会删除单例的唯一实例。 使用这种方法释放单例对象有以下特征： 在单例类内部定义专有的嵌套类； 在单例类内定义私有的专门用于释放的静态成员； 利用程序在结束时析构全局变量的特性，选择最终的释放时机； 使用单例的代码不需要任何操作，不必关心对象的释放。 工厂模式 在C++中利用反射和简单工厂模式实现业务模块解耦 用一个单独的类来做创造实例的过程，就是工厂。 简单工厂模式简单工厂模式基本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;class AbstractProduct &#123;public: virtual ~AbstractProduct() &#123;&#125; virtual void Operation() = 0;&#125;;class ProductA : public AbstractProduct &#123;public: void Operation() &#123; cout &lt;&lt; \"ProductA\" &lt;&lt; endl; &#125;&#125;;class ProductB : public AbstractProduct &#123;public: void Operation() &#123; cout &lt;&lt; \"ProductB\" &lt;&lt; endl; &#125;&#125;;class Factory &#123;public: AbstractProduct* createProduct(char product) &#123; AbstractProduct* ap = NULL; switch(product) &#123; case 'A': ap = new ProductA(); break; case 'B': ap = new ProductB(); break; &#125; return ap; &#125;&#125;;int main() &#123; Factory* f = new Factory(); AbstractProduct* apa = f-&gt;createProduct('A'); apa-&gt;Operation(); // ProductA AbstractProduct* apb = f-&gt;createProduct('B'); apb-&gt;Operation(); // ProductB delete apa; delete apb; delete f; return 0;&#125; 12345678910111213class OperationFactory &#123;public: Operation createOperate(string operate) &#123; Operation oper = null; switch (operate) &#123; case \"+\": oper = new OperationAdd(); break; case \"-\": oper = new OperationSub(); break; case \"*\": oper = new OperationMul(); break; case \"/\": oper = new OperationDiv(); break; &#125; return oper; &#125;&#125;; 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。 工厂方法模式工厂方法模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。 工厂方法模式基本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;class Product &#123;public: virtual ~Product()&#123;&#125; virtual void Operation() = 0;&#125;;class ConcreteProductA : public Product &#123;public: void Operation() &#123; cout &lt;&lt; \"ConcreteProductA\" &lt;&lt; endl; &#125;&#125;;class ConcreteProductB : public Product &#123;public: void Operation() &#123; cout &lt;&lt; \"ConcreteProductB\" &lt;&lt; endl; &#125;&#125;;class Creator&#123;public: virtual Product* FactoryMethod() = 0; virtual ~Creator()&#123;&#125;&#125;;class ConcreteCreatorA : public Creator &#123;public: Product* FactoryMethod() &#123; return new ConcreteProductA(); &#125;&#125;;class ConcreteCreatorB : public Creator &#123;public: Product* FactoryMethod() &#123; return new ConcreteProductB(); &#125;&#125;;int main() &#123; Creator* ca = new ConcreteCreatorA(); Product* pa = ca-&gt;FactoryMethod(); pa-&gt;Operation(); // ConcreteProductA Creator* cb = new ConcreteCreatorB(); Product* pb = cb-&gt;FactoryMethod(); pb-&gt;Operation(); // ConcreteProductB delete ca; delete pa; delete cb; delete pb; return 0;&#125; 把简单工厂模式中的工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，就变成了一个工厂抽象接口和多个具体生成对象的工厂。 这样整个工厂和产品体系就没有修改，而只是扩展，符合开放 - 封闭原则。 抽象工厂模式抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 抽象工厂模式基本代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;using namespace std;class AbstractProductA &#123;public: virtual ~AbstractProductA()&#123;&#125; virtual void Operation() = 0;&#125;;class ProductA1 : public AbstractProductA &#123;public: void Operation() &#123; cout &lt;&lt; \"ProductA1\" &lt;&lt; endl; &#125;&#125;;class ProductA2 : public AbstractProductA &#123;public: void Operation() &#123; cout &lt;&lt; \"ProductA2\" &lt;&lt; endl; &#125;&#125;;class AbstractProductB &#123;public: virtual ~AbstractProductB()&#123;&#125; virtual void Operation() = 0;&#125;;class ProductB1 : public AbstractProductB &#123;public: void Operation() &#123; cout &lt;&lt; \"ProductB1\" &lt;&lt; endl; &#125;&#125;;class ProductB2 : public AbstractProductB &#123;public: void Operation() &#123; cout &lt;&lt; \"ProductB2\" &lt;&lt; endl; &#125;&#125;;class AbstractFactory &#123;public: virtual AbstractProductA* CreateProductA() = 0; virtual AbstractProductB* CreateProductB() = 0; virtual ~AbstractFactory()&#123;&#125;&#125;;class ConcreteFactory1 : public AbstractFactory &#123;public: ProductA1* CreateProductA() &#123; return new ProductA1(); &#125; ProductB1* CreateProductB() &#123; return new ProductB1(); &#125;&#125;;class ConcreteFactory2 : public AbstractFactory &#123;public: ProductA2* CreateProductA() &#123; return new ProductA2(); &#125; ProductB2* CreateProductB() &#123; return new ProductB2(); &#125;&#125;;int main() &#123; AbstractFactory* af1 = new ConcreteFactory1(); // 具体工厂创建对应的具体产品 AbstractProductA* apa1 = af1-&gt;CreateProductA(); // 工厂1创建产品A apa1-&gt;Operation(); // ProductA1 AbstractProductB* apb1 = af1-&gt;CreateProductB(); // 工厂1创建产品B apb1-&gt;Operation(); // ProductB1 AbstractFactory* af2 = new ConcreteFactory2(); AbstractProductA* apa2 = af2-&gt;CreateProductA(); // 工厂2创建产品A apa2-&gt;Operation(); // ProductA2 AbstractProductB* apb2 = af2-&gt;CreateProductB(); // 工厂2创建产品B apb2-&gt;Operation(); // ProductB2 delete apa1; delete apa2; delete af1; delete apb1; delete apb2; delete af2; return 0;&#125; 抽象工厂函数的优缺点 优点： 易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这样就使得改变一个应用的具体工厂变得非常容易，只需要改变具体工厂即可使用不同的产品配置。 让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂实现分离，不会出现在客户代码中。 缺点：增加新的产品时需要改动多处代码。","categories":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/categories/Program-C/"}],"tags":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/tags/Program-C/"}]},{"title":"Interview STL","slug":"Program-C/STL","date":"2016-06-18T02:14:50.000Z","updated":"2019-06-10T09:09:07.775Z","comments":true,"path":"2016/06/18/Program-C/STL/","link":"","permalink":"http://miaopei.github.io/2016/06/18/Program-C/STL/","excerpt":"STL网站 github . huihut/note/STL.md cplusplus . stl cppreference . C++ 参考手册 CSDN专栏：STL学习笔记","text":"STL网站 github . huihut/note/STL.md cplusplus . stl cppreference . C++ 参考手册 CSDN专栏：STL学习笔记 组成 容器（containers） 算法（algorithms） 迭代器（iterators） 仿函数（functors） 配接器（adapters） 空间配置器（allocator） 容器（containers） 序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted） 关联式容器（associattive containers） arrayarray是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。 在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。 与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。 零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。 与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。 数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。 1template &lt; class T, size_t N &gt; class array; array::begin返回指向数组容器中第一个元素的迭代器。 12 iterator begin() noexcept;const_iterator begin() const noexcept; Example 12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 5&gt; myarray = &#123;2, 16, 77,34, 50&#125;; std::cout &lt;&lt; \"myarray contains:\"; for(auto it = myarray.begin(); it != myarray.end(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::end返回指向数组容器中最后一个元素之后的理论元素的迭代器。 12 iterator end() noexcept;const_iterator end() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 5, 19, 77, 34, 99 &#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.begin(); it != myarray.end(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray contains: 5 19 77 34 99 array::rbegin返回指向数组容器中最后一个元素的反向迭代器。 12 reverse_iterator rbegin（）noexcept;const_reverse_iterator rbegin（）const noexcept; Example 12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125; ; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray contains: 14 80 26 4 array::rend返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。 12 reverse_iterator rend() noexcept;const_reverse_iterator rend() const noexcept; Example 1234567891011121314#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125;; std::cout &lt;&lt; \"myarray contains\"; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray contains: 14 80 26 4 array::cbegin返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。 1const_iterator cbegin（）const noexcept; Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123;2, 16, 77, 34, 50&#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::cend返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。 1const_iterator cend() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 15, 720, 801, 1002, 3502 &#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::crbegin返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator） 1const_reverse_iterator crbegin（）const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; \"myarray backwards:\"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray backwards: 60 50 40 30 20 10 array::crend返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。 1const_reverse_iterator crend() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; \"myarray backwards:\"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray backwards: 60 50 40 30 20 10 array::size返回数组容器中元素的数量。 1constexpr size_type size（）noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myints; std::cout &lt;&lt; \"size of myints:\" &lt;&lt; myints.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"sizeof(myints):\" &lt;&lt; sizeof(myints) &lt;&lt; std::endl; return 0;&#125; Possible Output 12size of myints: 5sizeof(myints): 20 array::max_size返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。 1constexpr size_type max_size() noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myints; std::cout &lt;&lt; \"size of myints: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; std::cout &lt;&lt; \"max_size of myints: \" &lt;&lt; myints.max_size() &lt;&lt; '\\n'; return 0;&#125; Output 12size of myints: 10max_size of myints: 10 array::empty返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。 1constexpr bool empty() noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,0&gt; first; std::array&lt;int,5&gt; second; std::cout &lt;&lt; \"first \" &lt;&lt; (first.empty() ? \"is empty\" : \"is not empty\") &lt;&lt; '\\n'; std::cout &lt;&lt; \"second \" &lt;&lt; (second.empty() ? \"is empty\" : \"is not empty\") &lt;&lt; '\\n'; return 0;&#125; Output: 12first is emptysecond is not empt array::operator[]返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。 12 reference operator[] (size_type n);const_reference operator[] (size_type n) const; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myarray; unsigned int i; // assign some values: for(i=0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; \"myarray contains:\"; for(i=0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray[i]; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::at返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。 12 reference at ( size_type n );const_reference at ( size_type n ) const; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myarray; unsigned int i; // assign some values: for(i=0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; \"myarray contains:\"; for(i=0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray[i]; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::front返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。在空容器上调用此函数会导致未定义的行为。 12 reference front();const_reference front() const; Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;2, 16, 77&#125;; std::cout &lt;&lt; \"front is: \" &lt;&lt; myarray.front() &lt;&lt; std::endl; // 2 std::cout &lt;&lt; \"back is: \" &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.front() = 100; std::cout &lt;&lt; \"myarray now contains:\"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 123front is: 2back is: 77myarray now contains: 100 16 77 array::back返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。在空容器上调用此函数会导致未定义的行为。 12 reference back();const_reference back() const; Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;5, 19, 77&#125;; std::cout &lt;&lt; \"front is: \" &lt;&lt; myarray.front() &lt;&lt; std::endl; // 5 std::cout &lt;&lt; \"back is: \" &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.back() = 50; std::cout &lt;&lt; \"myarray now contains:\"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 123front is: 5back is: 77myarray now contains: 5 19 50 array::data返回指向数组对象中第一个元素的指针。 由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。 12 value_type* data() noexcept;const value_type* data() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;array&gt;int main ()&#123; const char* cstr = \"Test string\"; std::array&lt;char,12&gt; charray; std::memcpy (charray.data(),cstr,12); std::cout &lt;&lt; charray.data() &lt;&lt; '\\n'; return 0;&#125; Output 1Test string array::fill用val填充数组所有元素，将val设置为数组对象中所有元素的值。 1void fill (const value_type&amp; val); Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main () &#123; std::array&lt;int,6&gt; myarray; myarray.fill(5); std::cout &lt;&lt; \"myarray contains:\"; for ( int&amp; x : myarray) &#123; std::cout &lt;&lt; ' ' &lt;&lt; x; &#125; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myarray contains: 5 5 5 5 5 5 array::swap通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。 与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。 1void swap (array&amp; x) noexcept(noexcept(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;()))); Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; first = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; second = &#123;11, 22, 33, 44, 55&#125;; first.swap (second); std::cout &lt;&lt; \"first:\"; for (int&amp; x : first) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"second:\"; for (int&amp; x : second) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 12first: 11 22 33 44 55second: 10 20 30 40 50 get（array）形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。 123template &lt;size_t I，class T，size_t N&gt; T＆get（array &lt;T，N&gt;＆arr）noexcept; template &lt;size_t I，class T，size_t N&gt; T &amp;&amp; get（array &lt;T，N&gt; &amp;&amp; arr）noexcept; template &lt;size_t I，class T，size_t N&gt; const T＆get（const array &lt;T，N&gt;＆arr）noexcept; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;tuple&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;10, 20, 30&#125;; std::tuple&lt;int,int,int&gt; mytuple (10, 20, 30); std::tuple_element&lt;0,decltype(myarray)&gt;::type myelement; // int myelement myelement = std::get&lt;2&gt;(myarray); std::get&lt;2&gt;(myarray) = std::get&lt;0&gt;(myarray); std::get&lt;0&gt;(myarray) = myelement; std::cout &lt;&lt; \"first element in myarray: \" &lt;&lt; std::get&lt;0&gt;(myarray) &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"first element in mytuple: \" &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; \"\\n\"; return 0;&#125; Output 12first element in myarray: 30first element in mytuple: 10 relational operators (array)形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。 123456789101112131415161718（1） template &lt;class T，size_T N&gt; bool operator ==（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（2） template &lt;class T，size_T N&gt; bool operator！=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（3） template &lt;class T，size_T N&gt; bool operator &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（4） template &lt;class T，size_T N&gt; bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（5） template &lt;class T，size_T N&gt; bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（6） template &lt;class T，size_T N&gt; bool operator&gt; =（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）; Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; a = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; b = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; c = &#123;50, 40, 30, 20, 10&#125;; if (a==b) std::cout &lt;&lt; \"a and b are equal\\n\"; if (b!=c) std::cout &lt;&lt; \"b and c are not equal\\n\"; if (b&lt;c) std::cout &lt;&lt; \"b is less than c\\n\"; if (c&gt;b) std::cout &lt;&lt; \"c is greater than b\\n\"; if (a&lt;=b) std::cout &lt;&lt; \"a is less than or equal to b\\n\"; if (a&gt;=b) std::cout &lt;&lt; \"a is greater than or equal to b\\n\"; return 0;&#125; Output 123456a and b are equalb and c are not equalb is less than cc is greater than ba is less than or equal to ba is greater than or equal to b vectorvector是表示可以改变大小的数组的序列容器。 就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。 在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。 相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。 因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。 与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。 针对 vector 的各种常见操作的复杂度（效率）如下： 随机访问 - 常数 O(1) 在尾部增删元素 - 平摊（amortized）常数 O(1)}} 增删元素 - 至 vector 尾部的线性距离 O(n)}} 1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; vector::vector（1）empty容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）fill构造函数用n个元素构造一个容器。每个元素都是val的副本（如果提供）。（3）范围（range）构造器使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。（4）复制（copy）构造函数（并用分配器复制）按照相同的顺序构造一个包含x中每个元素的副本的容器。（5）移动（move）构造函数（和分配器移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（6）初始化列表构造函数构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。 12345678910111213141516171819default (1) explicit vector (const allocator_type&amp; alloc = allocator_type());fill (2) explicit vector (size_type n); vector (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) vector (const vector&amp; x);vector (const vector&amp; x, const allocator_type&amp; alloc);move (5) vector (vector&amp;&amp; x);vector (vector&amp;&amp; x, const allocator_type&amp; alloc);initializer list (6) vector (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type()); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; // constructors used in the same order as described above: std::vector&lt;int&gt; first; // empty vector of ints std::vector&lt;int&gt; second(4, 100); // four ints with value 100 std::vector&lt;int&gt; third(second.begin(), second.end());// iterating through second std::vector&lt;int&gt; fourth(third); // a copy of third // the iterator constructor can also be used to construct from arrays: int myints[] = &#123;16,2,77,29&#125;; std::vector&lt;int&gt; fifth(myints, myints + sizeof(myints) / sizeof(int)); std::cout &lt;&lt; \"The contents of fifth are:\"; for(std::vector&lt;int&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1The contents of fifth are: 16 2 77 29 vector::~vector销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。 1~vector(); vector::operator=将新内容分配给容器，替换其当前内容，并相应地修改其大小。 123456copy (1) vector&amp; operator= (const vector&amp; x);move (2) vector&amp; operator= (vector&amp;&amp; x);initializer list (3) vector&amp; operator= (initializer_list&lt;value_type&gt; il); Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,0); std::vector&lt;int&gt; bar (5,0); bar = foo; foo = std::vector&lt;int&gt;(); std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &apos;\\n&apos;; std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &apos;\\n&apos;; return 0;&#125; Output 12Size of foo: 0Size of bar: 3 vector::beginvector::endvector::rbeginvector::rendvector::cbeginvector::cendvector::rcbeginvector::rcendvector::size返回vector中元素的数量。 这是vector中保存的实际对象的数量，不一定等于其存储容量。 1size_type size() const noexcept; Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myints; std::cout &lt;&lt; \"0. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; for (int i=0; i&lt;10; i++) myints.push_back(i); std::cout &lt;&lt; \"1. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; myints.insert (myints.end(),10,100); std::cout &lt;&lt; \"2. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; myints.pop_back(); std::cout &lt;&lt; \"3. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; return 0;&#125; Output 12340. size: 01. size: 102. size: 203. size: 19 vector::max_size返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制， 这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。 1size_type max_size() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; \"size: \" &lt;&lt; myvector.size() &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"capacity: \" &lt;&lt; myvector.capacity() &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"max_size: \" &lt;&lt; myvector.max_size() &lt;&lt; \"\\n\"; return 0;&#125; A possible output for this program could be: 123size: 100capacity: 128max_size: 1073741823 vector::resize调整容器的大小，使其包含n个元素。 如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。 如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。 如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。 注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。 12void resize (size_type n);void resize (size_type n, const value_type&amp; val); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some initial content: for (int i=1;i&lt;10;i++) myvector.push_back(i); myvector.resize(5); myvector.resize(8,100); myvector.resize(12); std::cout &lt;&lt; \"myvector contains:\"; for (int i=0;i&lt;myvector.size();i++) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0 vector::capacity返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。 1size_type capacity() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; \"size: \" &lt;&lt; (int) myvector.size() &lt;&lt; '\\n'; std::cout &lt;&lt; \"capacity: \" &lt;&lt; (int) myvector.capacity() &lt;&lt; '\\n'; std::cout &lt;&lt; \"max_size: \" &lt;&lt; (int) myvector.max_size() &lt;&lt; '\\n'; return 0;&#125; A possible output for this program could be: 123size: 100capacity: 128max_size: 1073741823 vector::empty返回vector是否为空（即，它的size是否为0） 1bool empty() const noexcept; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); for (int i=1;i&lt;=10;i++) myvector.push_back(i); while (!myvector.empty()) &#123; sum += myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; \"total: \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125; Output 1total: 55 vector::reserve请求vector容量至少足以包含n个元素。 如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。 在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。 这个函数对vector大小没有影响，也不能改变它的元素。 1void reserve (size_type n); Example 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt;::size_type sz; std::vector&lt;int&gt; foo; sz = foo.capacity(); std::cout &lt;&lt; \"making foo grow:\\n\"; for (int i=0; i&lt;100; ++i) &#123; foo.push_back(i); if (sz!=foo.capacity()) &#123; sz = foo.capacity(); std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n'; &#125; &#125; std::vector&lt;int&gt; bar; sz = bar.capacity(); bar.reserve(100); // this is the only difference with foo above std::cout &lt;&lt; \"making bar grow:\\n\"; for (int i=0; i&lt;100; ++i) &#123; bar.push_back(i); if (sz!=bar.capacity()) &#123; sz = bar.capacity(); std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n'; &#125; &#125; return 0;&#125; Possible output 1234567891011making foo grow:capacity changed: 1capacity changed: 2capacity changed: 4capacity changed: 8capacity changed: 16capacity changed: 32capacity changed: 64capacity changed: 128making bar grow:capacity changed: 100 vector::shrink_to_fit要求容器减小其capacity(容量)以适应其尺寸。 该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。 1void shrink_to_fit(); Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (100); std::cout &lt;&lt; \"1. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; myvector.resize(10); std::cout &lt;&lt; \"2. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; myvector.shrink_to_fit(); std::cout &lt;&lt; \"3. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; return 0;&#125; Possible output 1231. capacity of myvector: 1002. capacity of myvector: 1003. capacity of myvector: 10 vector::operator[]vector::atvector::frontvector::backvector::datavector::assign将新内容分配给vector，替换其当前内容，并相应地修改其大小。 在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。 在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。 在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。 所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。 1234567range (1) template &lt;class InputIterator&gt; void assign (InputIterator first, InputIterator last);fill (2) void assign (size_type n, const value_type&amp; val);initializer list (3) void assign (initializer_list&lt;value_type&gt; il); Example 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; first; std::vector&lt;int&gt; second; std::vector&lt;int&gt; third; first.assign (7,100); // 7 ints with a value of 100 std::vector&lt;int&gt;::iterator it; it=first.begin()+1; second.assign (it,first.end()-1); // the 5 central values of first int myints[] = &#123;1776,7,4&#125;; third.assign (myints,myints+3); // assigning from array. std::cout &lt;&lt; \"Size of first: \" &lt;&lt; int (first.size()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"Size of second: \" &lt;&lt; int (second.size()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"Size of third: \" &lt;&lt; int (third.size()) &lt;&lt; '\\n'; return 0;&#125; Output 123Size of first: 7Size of second: 5Size of third: 3 补充：vector::assign 与 vector::operator= 的区别： vector::assign 实现源码 12345678910111213141516void assign(size_type __n, const _Tp&amp; __val) &#123; _M_fill_assign(__n, __val); &#125;template &lt;class _Tp, class _Alloc&gt;void vector&lt;_Tp, _Alloc&gt;::_M_fill_assign(size_t __n, const value_type&amp; __val) &#123; if (__n &gt; capacity()) &#123; vector&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator()); __tmp.swap(*this); &#125; else if (__n &gt; size()) &#123; fill(begin(), end(), __val); _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val); &#125; else erase(fill_n(begin(), __n, __val), end());&#125; vector::operator= 实现源码 12345678910111213141516171819202122232425template &lt;class _Tp, class _Alloc&gt;vector&lt;_Tp,_Alloc&gt;&amp; vector&lt;_Tp,_Alloc&gt;::operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x)&#123; if (&amp;__x != this) &#123; const size_type __xlen = __x.size(); if (__xlen &gt; capacity()) &#123; iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end()); destroy(_M_start, _M_finish); _M_deallocate(_M_start, _M_end_of_storage - _M_start); _M_start = __tmp; _M_end_of_storage = _M_start + __xlen; &#125; else if (size() &gt;= __xlen) &#123; iterator __i = copy(__x.begin(), __x.end(), begin()); destroy(__i, _M_finish); &#125; else &#123; copy(__x.begin(), __x.begin() + size(), _M_start); uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish); &#125; _M_finish = _M_start + __xlen; &#125; return *this;&#125; vector::push_back在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。 这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。 12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int myint; std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\"; do &#123; std::cin &gt;&gt; myint; myvector.push_back (myint); &#125; while (myint); std::cout &lt;&lt; \"myvector stores \" &lt;&lt; int(myvector.size()) &lt;&lt; \" numbers.\\n\"; return 0;&#125; vector::pop_back删除vector中的最后一个元素，有效地将容器size减少一个。 这破坏了被删除的元素。 1void pop_back(); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); myvector.push_back (100); myvector.push_back (200); myvector.push_back (300); while (!myvector.empty()) &#123; sum+=myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; \"The elements of myvector add up to \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125; Output 1The elements of myvector add up to 600 vector::insert通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。 由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 1234567891011single element (1) iterator insert (const_iterator position, const value_type&amp; val);fill (2) iterator insert (const_iterator position, size_type n, const value_type&amp; val);range (3) template &lt;class InputIterator&gt;iterator insert (const_iterator position, InputIterator first, InputIterator last);move (4) iterator insert (const_iterator position, value_type&amp;&amp; val);initializer list (5) iterator insert (const_iterator position, initializer_list&lt;value_type&gt; il); Example 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (3,100); std::vector&lt;int&gt;::iterator it; it = myvector.begin(); it = myvector.insert ( it , 200 ); myvector.insert (it,2,300); // \"it\" no longer valid, get a new one: it = myvector.begin(); std::vector&lt;int&gt; anothervector (2,400); myvector.insert (it+2,anothervector.begin(),anothervector.end()); int myarray [] = &#123; 501,502,503 &#125;; myvector.insert (myvector.begin(), myarray, myarray+3); std::cout &lt;&lt; \"myvector contains:\"; for (it=myvector.begin(); it&lt;myvector.end(); it++) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myvector contains: 501 502 503 300 300 400 400 200 100 100 100 补充：insert 迭代器野指针错误： 123456789101112131415int main()&#123; std::vector&lt;int&gt; v(5, 0); std::vector&lt;int&gt;::iterator vi; // 获取vector第一个元素的迭代器 vi = v.begin(); // push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错 v.push_back(10); v.insert(vi, 2, 300); return 0;&#125; 改正：应该把vi = v.begin();放到v.push_back(10);后面 vector::erase从vector中删除单个元素（position）或一系列元素（[first，last））。 这有效地减少了被去除的元素的数量，从而破坏了容器的大小。 由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 12iterator erase (const_iterator position);iterator erase (const_iterator first, const_iterator last); Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some values (from 1 to 10) for (int i=1; i&lt;=10; i++) myvector.push_back(i); // erase the 6th element myvector.erase (myvector.begin()+5); // erase the first 3 elements: myvector.erase (myvector.begin(),myvector.begin()+3); std::cout &lt;&lt; \"myvector contains:\"; for (unsigned i=0; i&lt;myvector.size(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myvector contains: 4 5 7 8 9 10 vector::swap通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。 在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。 请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。 1void swap (vector&amp; x); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,100); // three ints with a value of 100 std::vector&lt;int&gt; bar (5,200); // five ints with a value of 200 foo.swap(bar); std::cout &lt;&lt; \"foo contains:\"; for (unsigned i=0; i&lt;foo.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; foo[i]; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"bar contains:\"; for (unsigned i=0; i&lt;bar.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; bar[i]; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 12foo contains: 200 200 200 200 200 bar contains: 100 100 100 vector::clear从vector中删除所有的元素（被销毁），留下size为0的容器。 不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：vector&lt;T&gt;().swap(x); // clear x reallocating 1void clear() noexcept; Example 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;void printVector(const std::vector&lt;int&gt; &amp;v)&#123; for (auto it = v.begin(); it != v.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; ' '; &#125; std::cout &lt;&lt; std::endl;&#125;int main()&#123; std::vector&lt;int&gt; v1(5, 50); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.clear(); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.push_back(11); v1.push_back(22); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; return 0;&#125; Output 12345678950 50 50 50 50v1 size = 5v1 capacity = 5v1 size = 0v1 capacity = 511 22v1 size = 2v1 capacity = 5 vector::emplace通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。 由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。 12template &lt;class... Args&gt;iterator emplace (const_iterator position, Args&amp;&amp;... args); Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector = &#123;10,20,30&#125;; auto it = myvector.emplace ( myvector.begin()+1, 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std::cout &lt;&lt; \"myvector contains:\"; for (auto&amp; x: myvector) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1myvector contains: 10 200 100 20 30 300 vector::emplace_back在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。 这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。 该元素是通过调用allocator_traits :: construct来转换args来创建的。 与push_back相比，emplace_back可以避免额外的复制和移动操作。 12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args); Example 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) &#123; std::cout &lt;&lt; \"I am being constructed.\\n\"; &#125; President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) &#123; std::cout &lt;&lt; \"I am being moved.\\n\"; &#125; President&amp; operator=(const President&amp; other) = default;&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; \"emplace_back:\\n\"; elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; \"\\npush_back:\\n\"; reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936)); std::cout &lt;&lt; \"\\nContents:\\n\"; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was re-elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125;&#125; Output 12345678910emplace_back:I am being constructed. push_back:I am being constructed.I am being moved. Contents:Nelson Mandela was elected president of South Africa in 1994.Franklin Delano Roosevelt was re-elected president of the USA in 1936. vector::get_allocator返回与vector关联的构造器对象的副本。 1allocator_type get_allocator() const noexcept; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int * p; unsigned int i; // allocate an array with space for 5 elements using vector's allocator: p = myvector.get_allocator().allocate(5); // construct values in-place on the array: for (i=0; i&lt;5; i++) myvector.get_allocator().construct(&amp;p[i],i); std::cout &lt;&lt; \"The allocated array contains:\"; for (i=0; i&lt;5; i++) std::cout &lt;&lt; ' ' &lt;&lt; p[i]; std::cout &lt;&lt; '\\n'; // destroy and deallocate: for (i=0; i&lt;5; i++) myvector.get_allocator().destroy(&amp;p[i]); myvector.get_allocator().deallocate(p,5); return 0;&#125; Output 1The allocated array contains: 0 1 2 3 4 relational operators (vector)swap (vector)vector dequedeque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。 特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。 因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。 两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。 对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。 deque上常见操作的复杂性（效率）如下： 随机访问 - 常数O(1) 在结尾或开头插入或移除元素 - 摊销不变O(1) 插入或移除元素 - 线性O(n)1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque; deque::deque构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容： Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; unsigned int i; // constructors used in the same order as described above: std::deque&lt;int&gt; first; // empty deque of ints std::deque&lt;int&gt; second (4,100); // four ints with value 100 std::deque&lt;int&gt; third (second.begin(),second.end()); // iterating through second std::deque&lt;int&gt; fourth (third); // a copy of third // the iterator constructor can be used to copy arrays: int myints[] = &#123;16,2,77,29&#125;; std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); std::cout &lt;&lt; \"The contents of fifth are:\"; for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1The contents of fifth are: 16 2 77 29 deque::push_back在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。 这有效地增加了一个容器的大小。 12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int myint; std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\"; do &#123; std::cin &gt;&gt; myint; mydeque.push_back (myint); &#125; while (myint); std::cout &lt;&lt; \"mydeque stores \" &lt;&lt; (int) mydeque.size() &lt;&lt; \" numbers.\\n\"; return 0;&#125; deque::push_front在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。 这有效地增加了一个容器的大小。 12void push_front (const value_type&amp; val);void push_front (value_type&amp;&amp; val); Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque (2,100); // two ints with a value of 100 mydeque.push_front (200); mydeque.push_front (300); std::cout &lt;&lt; \"mydeque contains:\"; for (std::deque&lt;int&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1300 200 100 100 deque::pop_back删除deque容器中的最后一个元素，有效地将容器大小减少一个。 这破坏了被删除的元素。 1void pop_back(); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int sum (0); mydeque.push_back (10); mydeque.push_back (20); mydeque.push_back (30); while (!mydeque.empty()) &#123; sum+=mydeque.back(); mydeque.pop_back(); &#125; std::cout &lt;&lt; \"The elements of mydeque add up to \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125; Output 1The elements of mydeque add up to 60 deque::pop_front删除deque容器中的第一个元素，有效地减小其大小。 这破坏了被删除的元素。 1void pop_front(); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; mydeque.push_back (100); mydeque.push_back (200); mydeque.push_back (300); std::cout &lt;&lt; \"Popping out the elements in mydeque:\"; while (!mydeque.empty()) &#123; std::cout &lt;&lt; ' ' &lt;&lt; mydeque.front(); mydeque.pop_front(); &#125; std::cout &lt;&lt; \"\\nThe final size of mydeque is \" &lt;&lt; int(mydeque.size()) &lt;&lt; '\\n'; return 0;&#125; Output 12Popping out the elements in mydeque: 100 200 300The final size of mydeque is 0 deque::emplace_front在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 该元素是通过调用allocator_traits::construct来转换args来创建的。 存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。 12template &lt;class... Args&gt; void emplace_front (Args&amp;&amp;... args); Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_front (111); mydeque.emplace_front (222); std::cout &lt;&lt; \"mydeque contains:\"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1mydeque contains: 222 111 10 20 30 deque::emplace_back在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 该元素是通过调用allocator_traits::construct来转换args来创建的。 存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中 12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args); Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_back (100); mydeque.emplace_back (200); std::cout &lt;&lt; \"mydeque contains:\"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1mydeque contains: 10 20 30 100 200 forward_listforward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。 forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表 之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。 与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。 的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。 该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。 forward_list::forward_list12345678910111213141516171819default (1) explicit forward_list (const allocator_type&amp; alloc = allocator_type());fill (2) explicit forward_list (size_type n);explicit forward_list (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; forward_list (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) forward_list (const forward_list&amp; fwdlst);forward_list (const forward_list&amp; fwdlst, const allocator_type&amp; alloc);move (5) forward_list (forward_list&amp;&amp; fwdlst);forward_list (forward_list&amp;&amp; fwdlst, const allocator_type&amp; alloc);initializer list (6) forward_list (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type()); Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; // constructors used in the same order as described above: std::forward_list&lt;int&gt; first; // default: empty std::forward_list&lt;int&gt; second (3,77); // fill: 3 seventy-sevens std::forward_list&lt;int&gt; third (second.begin(), second.end()); // range initialization std::forward_list&lt;int&gt; fourth (third); // copy constructor std::forward_list&lt;int&gt; fifth (std::move(fourth)); // move ctor. (fourth wasted) std::forward_list&lt;int&gt; sixth = &#123;3, 52, 25, 90&#125;; // initializer_list constructor std::cout &lt;&lt; \"first:\" ; for (int&amp; x: first) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"second:\"; for (int&amp; x: second) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"third:\"; for (int&amp; x: third) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"fourth:\"; for (int&amp; x: fourth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"fifth:\"; for (int&amp; x: fifth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"sixth:\"; for (int&amp; x: sixth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125; Possible output 1234567forward_list constructor examples:first:second: 77 77 77third: 77 77 77fourth:fifth: 77 77 77sixth: 3 52 25 90 forward_list::~forward_listforward_list::before_begin返回指向容器中第一个元素之前的位置的迭代器。 返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。 12 iterator before_begin() noexcept;const_iterator before_begin() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;20, 30, 40, 50&#125;; mylist.insert_after ( mylist.before_begin(), 11 ); std::cout &lt;&lt; \"mylist contains:\"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1mylist contains: 11 20 30 40 50 forward_list::cbefore_begin返回指向容器中第一个元素之前的位置的const_iterator。 一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。 返回的价值不得解除引用。 1const_iterator cbefore_begin() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;77, 2, 16&#125;; mylist.insert_after ( mylist.cbefore_begin(), 19 ); std::cout &lt;&lt; \"mylist contains:\"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1mylist contains: 19 77 2 16 liststackqueuepriority_queuesetmultisetmapmap 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。 在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种： 1typedef pair&lt;const Key, T&gt; value_type; 在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施 12345template &lt; class Key, // map::key_type class T, // map::mapped_type class Compare = less&lt;Key&gt;, // map::key_compare class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; // map::allocator_type &gt; class map; map::map构造一个映射容器对象，根据所使用的构造器版本初始化其内容： （1）空容器构造函数（默认构造函数） 构造一个空的容器，没有元素。 （2）范围构造函数 构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。 （3）复制构造函数（并用分配器复制） 使用x中的每个元素的副本构造一个容器。 （4）移动构造函数（并与分配器一起移动） 构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。 （5）初始化列表构造函数 用il中的每个元素的副本构造一个容器。 12345678910111213141516171819empty (1) explicit map (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());explicit map (const allocator_type&amp; alloc);range (2) template &lt;class InputIterator&gt; map (InputIterator first, InputIterator last, const key_compare&amp; comp = key_compare(), const allocator_type&amp; = allocator_type());copy (3) map (const map&amp; x);map (const map&amp; x, const allocator_type&amp; alloc);move (4) map (map&amp;&amp; x);map (map&amp;&amp; x, const allocator_type&amp; alloc);initializer list (5) map (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type()); Example 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;bool fncomp (char lhs, char rhs) &#123;return lhs&lt;rhs;&#125;struct classcomp &#123; bool operator() (const char&amp; lhs, const char&amp; rhs) const &#123;return lhs&lt;rhs;&#125;&#125;;int main ()&#123; std::map&lt;char,int&gt; first; first['a']=10; first['b']=30; first['c']=50; first['d']=70; std::map&lt;char,int&gt; second (first.begin(),first.end()); std::map&lt;char,int&gt; third (second); std::map&lt;char,int,classcomp&gt; fourth; // class as Compare bool(*fn_pt)(char,char) = fncomp; std::map&lt;char,int,bool(*)(char,char)&gt; fifth (fn_pt); // function pointer as Compare return 0;&#125; map::begin返回引用map容器中第一个元素的迭代器。 由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。 如果容器是空的，则返回的迭代器值不应被解除引用。 12 iterator begin() noexcept;const_iterator begin() const noexcept; Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['b'] = 100; mymap['a'] = 200; mymap['c'] = 300; // show content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125; Output 123a =&gt; 200b =&gt; 100c =&gt; 300 map::key_comp返回容器用于比较键的比较对象的副本。 1key_compare key_comp() const; Example 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::key_compare mycomp = mymap.key_comp(); mymap['a']=100; mymap['b']=200; mymap['c']=300; std::cout &lt;&lt; \"mymap contains:\\n\"; char highest = mymap.rbegin()-&gt;first; // key value of last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; &#125; while ( mycomp((*it++).first, highest) ); std::cout &lt;&lt; '\\n'; return 0;&#125; Output 1234mymap contains:a =&gt; 100b =&gt; 200c =&gt; 300 map::value_comp返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。 1value_compare value_comp() const; Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['x']=1001; mymap['y']=2002; mymap['z']=3003; std::cout &lt;&lt; \"mymap contains:\\n\"; std::pair&lt;char,int&gt; highest = *mymap.rbegin(); // last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; &#125; while ( mymap.value_comp()(*it++, highest) ); return 0;&#125; Output 1234mymap contains:x =&gt; 1001y =&gt; 2002z =&gt; 3003 map::find在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。 如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。 另一个成员函数map::count可以用来检查一个特定的键是否存在。 12 iterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator it; mymap['a']=50; mymap['b']=100; mymap['c']=150; mymap['d']=200; it = mymap.find('b'); if (it != mymap.end()) mymap.erase (it); // print content: std::cout &lt;&lt; \"elements in mymap:\" &lt;&lt; '\\n'; std::cout &lt;&lt; \"a =&gt; \" &lt;&lt; mymap.find('a')-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"c =&gt; \" &lt;&lt; mymap.find('c')-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"d =&gt; \" &lt;&lt; mymap.find('d')-&gt;second &lt;&lt; '\\n'; return 0;&#125; Output 1234elements in mymap:a =&gt; 50c =&gt; 150d =&gt; 200 map::count在容器中搜索具有等于k的键的元素，并返回匹配的数量。 由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。 如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。 1size_type count (const key_type&amp; k) const; Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; char c; mymap ['a']=101; mymap ['c']=202; mymap ['f']=303; for (c='a'; c&lt;'h'; c++) &#123; std::cout &lt;&lt; c; if (mymap.count(c)&gt;0) std::cout &lt;&lt; \" is an element of mymap.\\n\"; else std::cout &lt;&lt; \" is not an element of mymap.\\n\"; &#125; return 0;&#125; Output 1234567a is an element of mymap.b is not an element of mymap.c is an element of mymap.d is not an element of mymap.e is not an element of mymap.f is an element of mymap.g is not an element of mymap. map::lower_bound将迭代器返回到下限 返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。 该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。 如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。 一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。 12 iterator lower_bound (const key_type&amp; k);const_iterator lower_bound (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125; Output 12a =&gt; 20e =&gt; 100 map::upper_bound将迭代器返回到上限 返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。 该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。 如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。 类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。 12 iterator upper_bound (const key_type&amp; k);const_iterator upper_bound (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125; Output 12a =&gt; 20e =&gt; 100 map::equal_range获取相同元素的范围 返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。 如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。 12pair&lt;const_iterator,const_iterator&gt; equal_range (const key_type&amp; k) const;pair&lt;iterator,iterator&gt; equal_range (const key_type&amp; k); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['a']=10; mymap['b']=20; mymap['c']=30; std::pair&lt;std::map&lt;char,int&gt;::iterator,std::map&lt;char,int&gt;::iterator&gt; ret; ret = mymap.equal_range('b'); std::cout &lt;&lt; \"lower bound points to: \"; std::cout &lt;&lt; ret.first-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; ret.first-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"upper bound points to: \"; std::cout &lt;&lt; ret.second-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; ret.second-&gt;second &lt;&lt; '\\n'; return 0;&#125; Output 12lower bound points to: &apos;b&apos; =&gt; 20upper bound points to: &apos;c&apos; =&gt; 30 multimap无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap包括： unordered_set unordered_multiset unordered_map unordered_multimap 都是以哈希表实现的。 unordered_set、unodered_multiset结构： unordered_map、unodered_multimap结构： unordered_setunordered_multisetunordered_mapunordered_multimaptuple元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。 1template &lt;class... Types&gt; class tuple; Example 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;tuple&gt; // std::tuple, std::get, std::tie, std::ignoreint main ()&#123; std::tuple&lt;int,char&gt; foo (10,'x'); auto bar = std::make_tuple (\"test\", 3.1, 14, 'y'); std::get&lt;2&gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get&lt;3&gt;(bar); std::get&lt;0&gt;(foo) = std::get&lt;2&gt;(bar); std::get&lt;1&gt;(foo) = mychar; std::cout &lt;&lt; \"foo contains: \"; std::cout &lt;&lt; std::get&lt;0&gt;(foo) &lt;&lt; ' '; std::cout &lt;&lt; std::get&lt;1&gt;(foo) &lt;&lt; '\\n'; return 0;&#125; Output 1foo contains: 100 y tuple::tuple构建一个 tuple（元组）对象。 这涉及单独构建其元素，初始化取决于调用的构造函数形式： （1）默认的构造函数 构建一个 元组对象的元素值初始化。 （2）复制/移动构造函数 该对象使用tpl的内容进行初始化 元组目的。tpl的相应元素被传递给每个元素的构造函数。 （3）隐式转换构造函数 同上。tpl中的所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。 （4）初始化构造函数用elems中的相应元素初始化每个元素。elems的相应元素被传递给每个元素的构造函数。 （5）对转换构造函数 该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。 （6）分配器版本 和上面的版本一样，除了每个元素都是使用allocator alloc构造的。 1234567891011121314151617181920212223242526272829303132333435363738default (1) constexpr tuple();copy / move (2) tuple (const tuple&amp; tpl) = default;tuple (tuple&amp;&amp; tpl) = default;implicit conversion (3) template &lt;class... UTypes&gt; tuple (const tuple&lt;UTypes...&gt;&amp; tpl);template &lt;class... UTypes&gt; tuple (tuple&lt;UTypes...&gt;&amp;&amp; tpl);initialization (4) explicit tuple (const Types&amp;... elems);template &lt;class... UTypes&gt; explicit tuple (UTypes&amp;&amp;... elems);conversion from pair (5) template &lt;class U1, class U2&gt; tuple (const pair&lt;U1,U2&gt;&amp; pr);template &lt;class U1, class U2&gt; tuple (pair&lt;U1,U2&gt;&amp;&amp; pr);allocator (6) template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&amp;&amp; tpl);template&lt;class Alloc,class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&lt;UTypes...&gt;&amp; tpl);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&lt;UTypes...&gt;&amp;&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const Types&amp;... elems);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, UTypes&amp;&amp;... elems);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const pair&lt;U1,U2&gt;&amp; pr);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, pair&lt;U1,U2&gt;&amp;&amp; pr); Example 123456789101112131415161718#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::make_pair#include &lt;tuple&gt; // std::tuple, std::make_tuple, std::getint main ()&#123; std::tuple&lt;int,char&gt; first; // default std::tuple&lt;int,char&gt; second (first); // copy std::tuple&lt;int,char&gt; third (std::make_tuple(20,'b')); // move std::tuple&lt;long,char&gt; fourth (third); // implicit conversion std::tuple&lt;int,char&gt; fifth (10,'a'); // initialization std::tuple&lt;int,char&gt; sixth (std::make_pair(30,'c')); // from pair / move std::cout &lt;&lt; \"sixth contains: \" &lt;&lt; std::get&lt;0&gt;(sixth); std::cout &lt;&lt; \" and \" &lt;&lt; std::get&lt;1&gt;(sixth) &lt;&lt; '\\n'; return 0;&#125; Output 1sixth contains: 30 and c pair这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。 pair是tuple（元组）的一个特例。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。 应用： 可以将两个类型数据组合成一个如map&lt;key, value&gt; 当某个函数需要两个返回值时 1template &lt;class T1, class T2&gt; struct pair; pair::pair构建一个pair对象。 这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式： （1）默认的构造函数 构建一个 对对象的元素值初始化。 （2）复制/移动构造函数（和隐式转换） 该对象被初始化为pr的内容 对目的。pr的相应成员被传递给每个成员的构造函数。 （3）初始化构造函数 会员 第一是由一个和成员构建的第二与b。 （4）分段构造 构造成员 first 和 second 到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。 1234567891011121314default (1) constexpr pair();copy / move (2) template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);pair (const pair&amp; pr) = default;pair (pair&amp;&amp; pr) = default;initialization (3) pair (const first_type&amp; a, const second_type&amp; b);template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);piecewise (4) template &lt;class... Args1, class... Args2&gt; pair (piecewise_construct_t pwc, tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args); Example 12345678910111213141516171819#include &lt;utility&gt; // std::pair, std::make_pair#include &lt;string&gt; // std::string#include &lt;iostream&gt; // std::coutint main () &#123; std::pair &lt;std::string,double&gt; product1; // default constructor std::pair &lt;std::string,double&gt; product2 (\"tomatoes\",2.30); // value init std::pair &lt;std::string,double&gt; product3 (product2); // copy constructor product1 = std::make_pair(std::string(\"lightbulbs\"),0.99); // using make_pair (move) product2.first = \"shoes\"; // the type of first is string product2.second = 39.90; // the type of second is double std::cout &lt;&lt; \"The price of \" &lt;&lt; product1.first &lt;&lt; \" is $\" &lt;&lt; product1.second &lt;&lt; '\\n'; std::cout &lt;&lt; \"The price of \" &lt;&lt; product2.first &lt;&lt; \" is $\" &lt;&lt; product2.second &lt;&lt; '\\n'; std::cout &lt;&lt; \"The price of \" &lt;&lt; product3.first &lt;&lt; \" is $\" &lt;&lt; product3.second &lt;&lt; '\\n'; return 0;&#125; Output 123The price of lightbulbs is $0.99The price of shoes is $39.9The price of tomatoes is $2.3","categories":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/categories/Program-C/"}],"tags":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/tags/Program-C/"}]},{"title":"Interview C C++","slug":"Program-C/interview","date":"2016-06-08T02:14:50.000Z","updated":"2019-06-11T02:02:19.077Z","comments":true,"path":"2016/06/08/Program-C/interview/","link":"","permalink":"http://miaopei.github.io/2016/06/08/Program-C/interview/","excerpt":"C/C++ 面试知识总结C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。 勘误新增请 Issue、PR，建议、讨论请 #issues/12，排版使用 中文文案排版指北 使用建议： Ctrl + F：快速查找定位知识点 TOC 导航：jawil/GayHub 插件快速目录跳转","text":"C/C++ 面试知识总结C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。 勘误新增请 Issue、PR，建议、讨论请 #issues/12，排版使用 中文文案排版指北 使用建议： Ctrl + F：快速查找定位知识点 TOC 导航：jawil/GayHub 插件快速目录跳转 目录 C/C++ STL 数据结构 算法 Problems 操作系统 计算机网络 网络编程 数据库 设计模式 链接装载库 海量数据处理 音视频 其他 书籍 复习刷题网站 招聘时间岗位 面试题目经验 C/C++const作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针和指针常量； 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 使用const 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 类class A&#123;private: const int a; // 常对象成员，只能在初始化列表赋值public: // 构造函数 A() &#123; &#125;; A(int x) : a(x) &#123; &#125;; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值&#125;;void function()&#123; // 对象 A b; // 普通对象，可以调用全部成员函数 const A a; // 常对象，只能调用常成员函数、更新常成员变量 const A *p = &amp;a; // 常指针 const A &amp;q = a; // 常引用 // 指针 // 还有其中区别方法，沿着 * 号划一条线： // 如果const位于 * 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量； // 如果const位于 * 的右侧，const就是修饰指针本身，即指针本身是常量。 char greeting[] = \"Hello\"; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量 char* const p3 = greeting; // 常指针，指向字符数组变量 const char* const p4 = greeting; // 常指针，指向字符数组常量&#125;// 函数void function1(const int Var); // 传递过来的参数在函数内不可变void function2(const char* Var); // 参数指针所指内容为常量void function3(char* const Var); // 参数指针为常指针void function4(const int&amp; Var); // 引用参数在函数内为常量// 函数返回值const int function5(); // 返回一个常数const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6();int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); static作用 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。 C++ static 和const 的作用 this 指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。 在以下场景中，经常需要显式引用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 inline 内联函数特征 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 不能包含循环、递归、switch 等复杂操作； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。 使用inline 使用 12345678910111213141516171819// 声明1（加 inline，建议使用）inline int functionName(int first, int secend,...);// 声明2（不加 inline）int functionName(int first, int secend,...);// 定义inline int functionName(int first, int secend,...) &#123;/****/&#125;;// 类内定义，隐式内联class A &#123; int doA() &#123; return 0; &#125; // 隐式内联&#125;// 类外定义，需要显式内联class A &#123; int doA();&#125;inline int A::doA() &#123; return 0; &#125; // 需要显式内联 编译器对 inline 函数的处理步骤 将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 优缺点优点 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。 缺点 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。 虚函数（virtual）可以是内联函数（inline）吗？Are “inline virtual” member functions ever actually “inlined”? 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。 虚函数内联使用 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std;class Base&#123;public: inline virtual void who() &#123; cout &lt;&lt; \"I am Base\\n\"; &#125; virtual ~Base() &#123;&#125;&#125;;class Derived : public Base&#123;public: inline void who() // 不写inline时隐式内联 &#123; cout &lt;&lt; \"I am Derived\\n\"; &#125;&#125;;int main()&#123; // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 Base b; b.who(); // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 Base *ptr = new Derived(); ptr-&gt;who(); // 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。 delete ptr; ptr = nullptr; system(\"pause\"); return 0;&#125; assert()断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;cassert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。 assert() 使用 1234#define NDEBUG // 加上这行，则 assert 不可用#include &lt;assert.h&gt;assert( p != NULL ); // assert 不可用 sizeof() sizeof 对数组，得到整个数组所占空间大小。 sizeof 对指针，得到指针本身所占空间大小。 #pragma pack(n)设定结构体、联合以及类成员变量以 n 字节方式对齐 #pragma pack(n) 使用 1234567891011#pragma pack(push) // 保存对齐状态#pragma pack(4) // 设定为 4 字节对齐struct test&#123; char m1; double m4; int m3;&#125;;#pragma pack(pop) // 恢复对齐状态 位域1Bit mode: 2; // mode 占 2 位 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。 位域在内存中的布局是与机器有关的 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定 取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域 volatile1volatile int i = 10; volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile extern “C” 被 extern 限定的函数或变量是 extern 类型的 被 extern &quot;C&quot; 修饰的变量和函数是按照 C 语言方式编译和连接的 extern &quot;C&quot; 的作用是让 C++ 编译器将 extern &quot;C&quot; 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 extern \"C\" 使用 123456789#ifdef __cplusplusextern \"C\" &#123;#endifvoid *memset(void *, int, size_t);#ifdef __cplusplus&#125;#endif struct 和 typedef structC 中1234// ctypedef struct Student &#123; int age; &#125; S; 等价于 123456// cstruct Student &#123; int age; &#125;;typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。 另外还可以定义与 struct Student 不冲突的 void Student() {}。 C++ 中由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。 一、如果在类标识符空间定义了 struct Student {...};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。 即表现为可以使用 Student 也可以使用 struct Student，如下： 123456// cppstruct Student &#123; int age; &#125;;void f( Student me ); // 正确，\"struct\" 关键字可省略 二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下： 12345678910111213typedef struct Student &#123; int age; &#125; S;void Student() &#123;&#125; // 正确，定义后 \"Student\" 只代表此函数//void S() &#123;&#125; // 错误，符号 \"S\" 已经被定义为一个 \"struct Student\" 的别名int main() &#123; Student(); struct Student me; // 或者 \"S me\"; return 0;&#125; C++ 中 struct 和 class总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 区别 最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。 union 联合联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： 默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的 union 使用 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;union UnionTest &#123; UnionTest() : i(10) &#123;&#125;; int i; double d;&#125;;static union &#123; int i; double d;&#125;;int main() &#123; UnionTest u; union &#123; int i; double d; &#125;; std::cout &lt;&lt; u.i &lt;&lt; std::endl; // 输出 UnionTest 联合的 10 ::i = 20; std::cout &lt;&lt; ::i &lt;&lt; std::endl; // 输出全局静态匿名联合的 20 i = 30; std::cout &lt;&lt; i &lt;&lt; std::endl; // 输出局部匿名联合的 30 return 0;&#125; C 实现 C++ 类C 语言实现封装、继承和多态 explicit（显式）构造函数explicit 修饰的构造函数可用来防止隐式转换 explicit 使用 1234567891011121314151617181920212223242526272829class Test1&#123;public: Test1(int n) // 普通构造函数 &#123; num=n; &#125;private: int num;&#125;;class Test2&#123;public: explicit Test2(int n) // explicit（显式）构造函数 &#123; num=n; &#125;private: int num;&#125;;int main()&#123; Test1 t1=12; // 隐式调用其构造函数，成功 Test2 t2=12; // 编译错误，不能隐式调用其构造函数 Test2 t2(12); // 显式调用成功 return 0;&#125; friend 友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制 usingusing 声明一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如： 1using namespace_name::name; 构造函数的 using 声明【C++11】在 C++11 中，派生类能够重用其直接基类定义的构造函数。 12345class Derived : Base &#123;public: using Base::Base; /* ... */&#125;; 如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数： 1derived(parms) : base(args) &#123; &#125; using 指示using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如： 1using namespace_name name; 尽量少使用 using 指示 污染命名空间 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了制定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。 using 使用 尽量少使用 using 指示 1using namespace std; 应该多使用 using 声明 123int x;std::cin &gt;&gt; x ;std::cout &lt;&lt; x &lt;&lt; std::endl; 或者 123456using std::cin;using std::cout;using std::endl;int x;cin &gt;&gt; x;cout &lt;&lt; x &lt;&lt; endl; :: 范围解析运算符分类 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 :: 使用 1234567891011121314151617int count = 0; // 全局（::）的 countclass A &#123;public: static int count; // 类 A 的 count（A::count）&#125;;int main() &#123; ::count = 1; // 设置全局的 count 的值为 1 A::count = 2; // 设置类 A 的 count 为 2 int count = 0; // 局部的 count count = 3; // 设置局部的 count 的值为 3 return 0;&#125; enum 枚举类型限定作用域的枚举类型1enum class open_modes &#123; input, output, append &#125;; 不限定作用域的枚举类型12enum color &#123; red, yellow, green &#125;;enum &#123; floatPrec = 6, doublePrec = 10 &#125;; C++ 枚举类型详解 decltypedecltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法： 1decltype ( expression ) decltype 使用 1234567891011121314// 尾置返回允许我们在参数列表之后声明返回类型template &lt;typename It&gt;auto fcn(It beg, It end) -&gt; decltype(*beg)&#123; // 处理序列 return *beg; // 返回序列中一个元素的引用&#125;// 为了使用模板参数成员，必须用 typenametemplate &lt;typename It&gt;auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type&#123; // 处理序列 return *beg; // 返回序列中一个元素的拷贝&#125; 引用左值引用常规引用，一般表示对象的身份。 右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 引用折叠 X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp; X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp; 详解c++ 引用（reference）与 指针（pointer）的区别与联系 宏 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。 成员初始化列表好处 更高效：少了一次调用默认构造函数的过程。 有些场合必须要用初始化列表： 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。 initializer_list 列表初始化【C++11】用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数. initializer_list 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt; template &lt;class T&gt;struct S &#123; std::vector&lt;T&gt; v; S(std::initializer_list&lt;T&gt; l) : v(l) &#123; std::cout &lt;&lt; \"constructed with a \" &lt;&lt; l.size() &lt;&lt; \"-element list\\n\"; &#125; void append(std::initializer_list&lt;T&gt; l) &#123; v.insert(v.end(), l.begin(), l.end()); &#125; std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123; return &#123;&amp;v[0], v.size()&#125;; // 在 return 语句中复制列表初始化 // 这不使用 std::initializer_list &#125;&#125;; template &lt;typename T&gt;void templated_fn(T) &#123;&#125; int main()&#123; S&lt;int&gt; s = &#123;1, 2, 3, 4, 5&#125;; // 复制初始化 s.append(&#123;6, 7, 8&#125;); // 函数调用中的列表初始化 std::cout &lt;&lt; \"The vector size is now \" &lt;&lt; s.c_arr().second &lt;&lt; \" ints:\\n\"; for (auto n : s.v) std::cout &lt;&lt; n &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"Range-for over brace-init-list: \\n\"; for (int x : &#123;-1, -2, -3&#125;) // auto 的规则令此带范围 for 工作 std::cout &lt;&lt; x &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; auto al = &#123;10, 11, 12&#125;; // auto 的特殊规则 std::cout &lt;&lt; \"The list bound to auto has size() = \" &lt;&lt; al.size() &lt;&lt; '\\n'; // templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式， // 它无类型，故 T 无法推导 templated_fn&lt;std::initializer_list&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // OK templated_fn&lt;std::vector&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // 也 OK&#125; 面向对象面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。 面向对象三大特征 —— 封装、继承、多态 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 关键字：public, protected, friendly, private。不写默认为 friendly。 关键字 当前类 包内 子孙类 包外 public √ √ √ √ protected √ √ √ × friendly √ √ × × private √ × × × 继承 基类（父类）——&gt; 派生类（子类） 多态 多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。 C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。 多态是以封装和继承为基础的。 静态多态（早绑定）函数重载 123456class A&#123;public: void do(int a); void do(int a, int b);&#125;; 动态多态（晚绑定） 虚函数：用 virtual 修饰成员函数，使其成为虚函数 注意： 普通函数（非类成员函数）不能是虚函数 静态函数（static）不能是虚函数 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针） 内联函数不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？ 动态多态使用 123456789101112131415161718192021222324252627282930313233class Shape // 形状类&#123;public: virtual double calcArea() &#123; ... &#125; virtual ~Shape();&#125;;class Circle : public Shape // 圆形类&#123;public: virtual double calcArea(); ...&#125;;class Rect : public Shape // 矩形类&#123;public: virtual double calcArea(); ...&#125;;int main()&#123; Shape * shape1 = new Circle(4.0); Shape * shape2 = new Rect(5.0, 6.0); shape1-&gt;calcArea(); // 调用圆形类里面的方法 shape2-&gt;calcArea(); // 调用矩形类里面的方法 delete shape1; shape1 = nullptr; delete shape2; shape2 = nullptr; return 0;&#125; 虚析构函数虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 虚析构函数使用 123456789101112131415161718192021class Shape&#123;public: Shape(); // 构造函数不能是虚函数 virtual double calcArea(); virtual ~Shape(); // 虚析构函数&#125;;class Circle : public Shape // 圆形类&#123;public: virtual double calcArea(); ...&#125;;int main()&#123; Shape * shape1 = new Circle(4.0); shape1-&gt;calcArea(); delete shape1; // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。 shape1 = NULL; return 0；&#125; 纯虚函数纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。 1virtual int A() = 0; 虚函数、纯虚函数CSDN . C++ 中的虚函数、纯虚函数区别和联系 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。 虚函数指针、虚函数表 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。 虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。 虚继承虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 虚继承、虚函数 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间） 不同之处： 虚继承 虚基类依旧存在继承类中，只占用存储空间 虚基类表存储的是虚基类相对直接继承类的偏移 虚函数 虚函数不占用存储空间 虚函数表存储的是虚函数地址 模板类、成员模板、虚函数 模板类中可以使用虚函数 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数 抽象类、接口类、聚合类 抽象类：含有纯虚函数的类 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有有定于任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配和管理 C/C++内存管理详解 - ShinChan’s Blog malloc、calloc、realloc、alloca malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。 calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 malloc、free用于分配、释放内存 malloc、free 使用 申请内存，确认是否申请成功 12char *str = (char*) malloc(100);assert(str != nullptr); 释放内存后指针置空 12free(p); p = nullptr; new、delete new / new[]：完成两件事，先底层调用 malloc 分了配内存，然后调用构造函数（创建对象）。 delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。 new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。 new、delete 使用 申请内存，确认是否申请成功 123456int main()&#123; T* t = new T(); // 先内存分配 ，再构造函数 delete t; // 先析构函数，再内存释放 return 0;&#125; 定位 new定位 new（placement new）允许我们向 new 传递额外的参数。 1234new (palce_address) typenew (palce_address) type (initializers)new (palce_address) type [size]new (palce_address) type [size] &#123; braced initializer list &#125; palce_address 是个指针 initializers 提供一个（可能为空的）以逗号分隔的初始值列表 delete this 合法吗？Is it legal (and moral) for a member function to say delete this? 合法，但： 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数 必须保证成员函数的 delete this 后面没有调用 this 了 必须保证 delete this 后没有人使用了 如何定义一个只能在堆上（栈上）生成对象的类？如何定义一个只能在堆上（栈上）生成对象的类? 只能在堆上方法：将析构函数设置为私有 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。 只能在栈上方法：将 new 和 delete 重载为私有 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。 智能指针 C++11及C++14标准的智能指针 C++ 智能指针 使用 C++11 智能指针时要避开的 10 大错误 C++ 标准库（STL）中头文件：#include &lt;memory&gt; C++ 981std::auto_ptr&lt;std::string&gt; ps (new std::string(str))； C++ 11 shared_ptr unique_ptr weak_ptr auto_ptr（被 C++11 弃用） Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。 shared_ptr多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 weak_ptrweak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 unique_ptrunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 unique_ptr 用于取代 auto_ptr auto_ptr被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。 auto_ptr 与 unique_ptr 比较 auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义； auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）； 强制类型转换运算符MSDN . 强制转换运算符 C++类型转换总结 static_cast 用于非多态类型的转换 不执行运行时类型检查（转换安全性不如 dynamic_cast） 通常用于转换数值数据类型（如 float -&gt; int） 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法） 向上转换是一种隐式转换。 dynamic_cast 用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换 const_cast 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ） reinterpret_cast 用于位的简单重新解释 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。 bad_cast 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。 bad_cast 使用 123456try &#123; Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape); &#125; catch (bad_cast b) &#123; cout &lt;&lt; \"Caught: \" &lt;&lt; b.what(); &#125; 运行时类型信息 (RTTI)dynamic_cast 用于多态类型的转换 typeid typeid 运算符允许在运行时确定对象的类型 type_id 返回一个 type_info 对象的引用 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数 只能获取对象的实际类型 type_info type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。 头文件：typeinfo typeid、type_info 使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Flyable // 能飞的&#123;public: virtual void takeoff() = 0; // 起飞 virtual void land() = 0; // 降落&#125;;class Bird : public Flyable // 鸟&#123;public: void foraging() &#123;...&#125; // 觅食 virtual void takeoff() &#123;...&#125; virtual void land() &#123;...&#125;&#125;;class Plane : public Flyable // 飞机&#123;public: void carry() &#123;...&#125; // 运输 virtual void take off() &#123;...&#125; virtual void land() &#123;...&#125;&#125;;class type_info&#123;public: const char* name() const; bool operator == (const type_info &amp; rhs) const; bool operator != (const type_info &amp; rhs) const; int before(const type_info &amp; rhs) const; virtual ~type_info();private: ...&#125;;class doSomething(Flyable *obj) // 做些事情&#123; obj-&gt;takeoff(); cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl; // 输出传入对象类型（\"class Bird\" or \"class Plane\"） if(typeid(*obj) == typeid(Bird)) // 判断对象类型 &#123; Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // 对象转化 bird-&gt;foraging(); &#125; obj-&gt;land();&#125;; Effective C++ 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高） 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数） 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现） 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数） 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理） 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class） 令 operator= 返回一个 reference to *this （用于连锁赋值） 在 operator= 中处理 “自我赋值” 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数） 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII）） 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr）） 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便） 成对使用 new 和 delete 时要采取相同形式（new 中使用 [] 则 delete []，new 中不使用 [] 则 delete） 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏） 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任） 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象） 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。） 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等） 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性） 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数 考虑写一个不抛异常的 swap 函数 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率） 尽量少做转型动作（旧式：(T)expression、T(expression)；新式：const_cast&lt;T&gt;(expression)、dynamic_cast&lt;T&gt;(expression)、reinterpret_cast&lt;T&gt;(expression)、static_cast&lt;T&gt;(expression)、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型） 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性） 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型） 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级） 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能过够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件） 确定你的 public 继承塑模出 is-a 关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象） 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日） 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承） 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数） 绝不重新定义继承而来的 non-virtual 函数 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound） Google C++ Style Guide 英文：Google C++ Style Guide中文：C++ 风格指南 Google C++ Style Guide 图 图片来源于：CSDN . 一张图总结Google C++编程规范(Google C++ Style Guide) STLSTL 索引STL 方法含义索引 C++ STL容器总结 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持快速随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1)头部插入、头部删除 O(n) 无序 可重复 支持快速随机访问 list 双向链表 插入、删除 O(1)随机读改 O(n) 无序 可重复 支持快速增删 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector容器+heap处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 hash_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 hash_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 hash_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 hash_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 STL 算法 算法 底层算法 时间复杂度 可不可重复 find 顺序查找 O(n) 可重复 sort 内省排序 O(n*log2n) 可重复 数据结构顺序结构顺序栈（Sequence Stack）SqStack.cpp 顺序栈数据结构和图片 123456typedef struct &#123; ElemType *elem; int top; int size; int increment;&#125; SqSrack; 队列（Sequence Queue）队列数据结构 123456typedef struct &#123; ElemType * elem; int front; int rear; int maxSize;&#125;SqQueue; 非循环队列非循环队列图片 SqQueue.rear++ 循环队列循环队列图片 SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize 顺序表（Sequence List）SqList.cpp 顺序表数据结构和图片 123456typedef struct &#123; ElemType *elem; int length; int size; int increment;&#125; SqList; 链式结构LinkList.cpp LinkList_with_head.cpp 链式数据结构 1234typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList; 链队列（Link Queue）链队列图片 线性表的链式表示单链表（Link List）单链表图片 双向链表（Du-Link-List）双向链表图片 循环链表（Cir-Link-List）循环链表图片 哈希表HashTable.cpp 概念哈希函数：H(key): K -&gt; D , key ∈ K 构造方法 直接定址法 除留余数法 数字分析法 折叠法 平方取中法 冲突处理方法 链地址法：key 相同的用单链表链接 开放定址法 线性探测法：key 相同 -&gt; 放到 key 的下一个位置，Hi = (H(key) + i) % m 二次探测法：key 相同 -&gt; 放到 Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2） 随机探测法：H = (H(key) + 伪随机数) % m 线性探测的哈希表数据结构线性探测的哈希表数据结构和图片 123456789101112typedef char KeyType;typedef struct &#123; KeyType key;&#125;RcdType;typedef struct &#123; RcdType *rcd; int size; int count; bool *tag;&#125;HashTable; 递归概念函数直接或间接地调用自身 递归与分治 分治法 问题的分解 问题规模的分解 折半查找（递归） 归并查找（递归） 快速排序（递归） 递归与迭代 迭代：反复利用变量旧值推出新值 折半查找（迭代） 归并查找（迭代） 广义表头尾链表存储表示广义表的头尾链表存储表示和图片 12345678910111213141516// 广义表的头尾链表存储表示typedef enum &#123;ATOM, LIST&#125; ElemTag;// ATOM==0：原子，LIST==1：子表typedef struct GLNode &#123; ElemTag tag; // 公共部分，用于区分原子结点和表结点 union &#123; // 原子结点和表结点的联合部分 AtomType atom; // atom 是原子结点的值域，AtomType 由用户定义 struct &#123; struct GLNode *hp, *tp; &#125; ptr; // ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾 &#125; a;&#125; *GList, GLNode; 扩展线性链表存储表示扩展线性链表存储表示和图片 1234567891011121314// 广义表的扩展线性链表存储表示typedef enum &#123;ATOM, LIST&#125; ElemTag;// ATOM==0：原子，LIST==1：子表typedef struct GLNode1 &#123; ElemTag tag; // 公共部分，用于区分原子结点和表结点 union &#123; // 原子结点和表结点的联合部分 AtomType atom; // 原子结点的值域 struct GLNode1 *hp; // 表结点的表头指针 &#125; a; struct GLNode1 *tp; // 相当于线性链表的 next，指向下一个元素结点&#125; *GList1, GLNode1; 二叉树BinaryTree.cpp 性质 非空二叉树第 i 层最多 2(i-1) 个结点 （i &gt;= 1） 深度为 k 的二叉树最多 2k - 1 个结点 （k &gt;= 1） 度为 0 的结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1 有 n 个结点的完全二叉树深度 k = ⌊ log2(n) ⌋ + 1 对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点 若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋ 若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i 若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1 存储结构二叉树数据结构 12345typedef struct BiTNode&#123; TElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 顺序存储二叉树顺序存储图片 链式存储二叉树链式存储图片 遍历方式 先序遍历 中序遍历 后续遍历 层次遍历 分类 满二叉树 完全二叉树（堆） 大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右 小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右 二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右 平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1 最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整： LL型：根的左孩子右旋 RR型：根的右孩子左旋 LR型：根的左孩子左旋，再右旋 RL型：右孩子的左子树，先右旋，再左旋 其他树及森林树的存储结构 双亲表示法 双亲孩子表示法 孩子兄弟表示法 并查集一种不相交的子集所构成的集合 S = {S1, S2, …, Sn} 平衡二叉树（AVL树）性质 | 左子树树高 - 右子树树高 | &lt;= 1 平衡二叉树必定是二叉搜索树，反之则不一定 最小二叉平衡树的节点的公式：F(n)=F(n-1)+F(n-2)+1 （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量） 平衡二叉树图片 最小失衡树平衡二叉树插入新结点导致失衡的子树 调整： LL 型：根的左孩子右旋 RR 型：根的右孩子左旋 LR 型：根的左孩子左旋，再右旋 RL 型：右孩子的左子树，先右旋，再左旋 红黑树红黑树的特征是什么？ 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是 NIL 节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红） 调整 变色 左旋 右旋 应用 关联数组：如 STL 中的 map、set 红黑树、B 树、B+ 树的区别？ 红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些 B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。 B 树（B-tree）、B+ 树（B+-tree）B 树、B+ 树图片 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用B树、B+树作为索引结构 区别 B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。 B+树中所有叶子节点都是通过指针连接在一起，而B树不会。 B树的优点对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B+树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。 B 树、B+ 树区别来自：differences-between-b-trees-and-b-trees、B树和B+树的区别 八叉树八叉树图片 八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。 用途 三维计算机图形 最邻近搜索 算法排序 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性 冒泡排序 O(n2) O(n2) O(1) 稳定 选择排序 O(n2) O(n2) O(1) 数组不稳定、链表稳定 插入排序 O(n2) O(n2) O(1) 稳定 快速排序 O(n*log2n) O(n2) O(log2n) 不稳定 堆排序 O(n*log2n) O(n*log2n) O(1) 不稳定 归并排序 O(n*log2n) O(n*log2n) O(n) 稳定 希尔排序 O(n*log2n) O(n2) O(1) 不稳定 计数排序 O(n+m) O(n+m) O(n+m) 稳定 桶排序 O(n) O(n) O(m) 稳定 基数排序 O(k*n) O(n2) 稳定 均按从小到大排列 k：代表数值中的 “数位” 个数 n：代表数据规模 m：代表数据的最大值减最小值 来自：wikipedia . 排序算法 查找 查找算法 平均时间复杂度 空间复杂度 查找条件 顺序查找 O(n) O(1) 无序或有序 二分查找（折半查找） O(log2n) O(1) 有序 插值查找 O(log2(log2n)) O(1) 有序 斐波那契查找 O(log2n) O(1) 有序 哈希查找 O(1) O(n) 无序或有序 二叉查找树（二叉搜索树查找） O(log2n) 红黑树 O(log2n) 2-3树 O(log2n - log3n) B树/B+树 O(log2n) 图搜索算法 图搜索算法 数据结构 遍历时间复杂度 空间复杂度 BFS广度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) DFS深度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) 其他算法 算法 思想 应用 分治法 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 循环赛日程安排问题、排序算法（快速排序、归并排序） 动态规划 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题 背包问题、斐波那契数列 贪心法 一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法 旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码 ProblemsSingle Problem Chessboard Coverage Problem（棋盘覆盖问题） Knapsack Problem（背包问题） Neumann Neighbor Problem（冯诺依曼邻居问题） Round Robin Problem（循环赛日程安排问题） Tubing Problem（输油管道问题） Leetcode Problems Github . haoel/leetcode Github . pezy/LeetCode 剑指 Offer Github . zhedahht/CodingInterviewChinese2 Github . gatieme/CodingInterviews Cracking the Coding Interview 程序员面试金典 Github . careercup/ctci 牛客网 . 程序员面试金典 牛客网 牛客网 . 在线编程专题 操作系统 【构建操作系统】进程间通信 C++ 高性能服务器网络框架设计细节 epoll编程，如何实现高并发服务器开发？ 如何实现高并发服务器开发 进程与线程 编程思想之多线程与多进程(4)——C++中的多线程 对于有线程系统： 进程是资源分配的独立单位 线程是资源调度的独立单位 对于无线程系统： 进程是资源调度、分配的独立单位 进程之间的通信方式以及优缺点 管道（PIPE） 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信 优点：可以实现任意关系的进程间的通信 缺点： 长期存于系统中，使用不当容易出错 缓冲区有限 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程） 优点：简单方便 缺点： 局限于单向通信 只能创建在它的进程以及其有亲缘关系的进程之间 缓冲区有限 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问 优点：可以同步进程 缺点：信号量有限 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问 优点：无须复制，快捷，信息量大 缺点： 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信 套接字（Socket）：可用于不同及其间的进程通信 优点： 传输数据为字节级，传输数据可自定义，数据量小效率高 传输数据时间短，性能高 适合于客户端和服务器端之间信息实时交互 可以加密,数据安全性强 缺点：需对传输的数据进行解析，转化成应用级的数据。 线程之间的通信方式 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition） 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持着是否已经释放锁。 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制(Semaphore) 无名线程信号量 命名线程信号量 信号机制(Signal)：类似进程间的信号处理 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制 进程之间的通信方式以及优缺点来源于：进程线程面试题总结 进程之间私有和共享的资源 私有：地址空间、堆、全局变量、栈、寄存器 共享：代码段，公共数据，进程目录，进程 ID 线程之间私有和共享的资源 私有：线程栈，寄存器，程序寄存器 共享：堆，地址空间，全局变量，静态变量 多进程与多线程间的对比、优劣与选择对比 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用 IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU 利用率低 占用内存少，切换简单，CPU 利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 适应于多核分布式 进程占优 优劣 优劣 多进程 多线程 优点 编程、调试简单，可靠性较高 创建、销毁、切换速度快，内存、资源占用小 缺点 创建、销毁、切换速度慢，内存、资源占用大 编程、调试复杂，可靠性较差 选择 需要频繁创建销毁的优先用线程 需要进行大量计算的优先使用线程 强相关的处理用线程，弱相关的处理用进程 可能要扩展到多机分布的用进程，多核分布的用线程 都满足需求的情况下，用你最熟悉、最拿手的方式 多进程与多线程间的对比、优劣与选择来自：多线程还是多进程的选择及区别 多进程并发优点： 将应用程序分为多个、独立的、单纯和的进程，它们运行在同一时刻，就像你可以同时进行网页浏览和文字处理，这些独立的进程可以通过所有常规的进程间通信渠道互相传递信息（信号、套接字、文件、管道等）。 操作系统在进程间提供的附加保护操作和更高级别的通信机制，意味着可以比线程更容易地编写安全的并发代码。 使用独立的进程实现并发，可以在网络连接的不同的机器上运行独立的进程，虽然这增加了通信成本，但在一个精心设计的系统上，这可能是一个提高并行可用行和提高性能的低成本方法。 缺点： 这种进程之间的通信通常设置复杂，或是速度较慢，或两者兼备，因为操作系统通常在进程间提供了大量的保护，以避免一个进程不小心修改了属于另一个进程的数据。 运行多个进和所需的固有开销：启动进程需要时间，操作系统必须投入内部资源来管理进程。 多线程并发优点： 每个线程相互独立运行，且每个线程可以运行不同的指令序列。但进程中的所有的线程都共享相同的地址空间，并且从所有线程中访问大部分数据——全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。 共享的地址空间，以及缺少线程间的数据保护，使得使用多线程相关的开销远小于使用多进程，因为操作系统有更少的簿记要做。 缺点： 虽然通常可以在进程之间共享内存，但这难以建立并且通常难以管理，因为同一数据的内存地址在不同的进程中也不尽相同。 共享内存的灵活性是有代价的：如果数据要被多个线程访问，那么必须确保当每个线程访问时所看到的数据是一致的。 Linux 内核的同步方式原因在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。 同步方式 原子操作 信号量（semaphore） 读写信号量（rw_semaphore） 自旋锁（spinlock） 大内核锁（BKL，Big Kernel Lock） 读写锁（rwlock） 大读者锁（brlock-Big Reader Lock） 读-拷贝修改(RCU，Read-Copy Update) 顺序锁（seqlock） 来自：Linux 内核的同步机制，第 1 部分、Linux 内核的同步机制，第 2 部分 死锁原因 系统资源不足 资源分配不当 进程运行推进顺序不合适 产生条件 互斥 请求和保持 不剥夺 环路 预防 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 有序资源分配法 银行家算法 文件系统 Windows：FCB 表 + FAT + 位图 Unix：inode + 混合索引 + 成组链接 主机字节序与网络字节序主机字节序（CPU 字节序）概念主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种： 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址 存储方式32 位整数 0x12345678 是从起始位置为 0x00 的地址开始存放，则： 内存地址 0x00 0x01 0x02 0x03 大端 12 34 56 78 小端 78 56 34 12 大端小端图片 判断大端小端判断大端小端 可以这样判断自己 CPU 字节序是大端还是小端： 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 0x12345678; if (*((char*)&amp;i) == 0x12) cout &lt;&lt; \"大端\" &lt;&lt; endl; else cout &lt;&lt; \"小端\" &lt;&lt; endl; return 0;&#125; 各架构处理器的字节序 x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序； Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序； ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。 网络字节序网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保重数据在不同主机之间传输时能够被正确解释。 网络字节顺序采用：大端（Big Endian）排列方式。 页面置换算法在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。 分类 全局置换：在整个内存空间置换 局部置换：在本进程中进行置换 算法全局： 工作集算法 缺页率置换算法 局部： 最佳置换算法（OPT） 先进先出置换算法（FIFO） 最近最久未使用（LRU）算法 时钟（Clock）置换算法 计算机网络计算机经网络体系结构： 各层作用及协议 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 物理层 传输数据的单位 ———— 比特 数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点） 通道： 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播 双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息 通道复用技术： 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信 数据链路层主要信道： 点对点信道 广播信道 点对点信道 数据单元 ———— 帧 三个基本问题： 封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符） 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check） 点对点协议（Point-to-Point Protocol）： 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议 广播信道广播通信： 硬件地址（物理地址、MAC 地址） 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧 网络层 IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议） IP 网际协议IP 地址分类： IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;} IP 地址类别 网络号 网络范围 主机号 IP 地址范围 A 类 8bit，第一位固定为 0 0 —— 127 24bit 1.0.0.0 —— 127.255.255.255 B 类 16bit，前两位固定为 10 128.0 —— 191.255 16bit 128.0.0.0 —— 191.255.255.255 C 类 24bit，前三位固定为 110 192.0.0 —— 223.255.255 8bit 192.0.0.0 —— 223.255.255.255 D 类 前四位固定为 1110，后面为多播地址 E 类 前五位固定为 11110，后面保留为今后所用 IP 数据报格式： ICMP 网际控制报文协议ICMP 报文格式： 应用： PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性 TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量 内部网关协议 RIP（Routing Information Protocol，路由信息协议） OSPF（Open Sortest Path First，开放最短路径优先） 外部网关协议 BGP（Border Gateway Protocol，边界网关协议） IP多播 IGMP（Internet Group Management Protocol，网际组管理协议） 多播路由选择协议 VPN 和 NAT VPN（Virtual Private Network，虚拟专用网） NAT（Network Address Translation，网络地址转换） 路由表包含什么？ 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。 子网掩码（subnet mask）：用来判断 IP 所属网络 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。 根据应用和执行的不同，路由表可能含有如下附加信息： 花费（Cost）：就是数据发送过程中通过路径所需要的花费。 路由的服务质量 路由中需要过滤的出/入连接列表 运输层协议： TCP（Transmission Control Protocol，传输控制协议） UDP（User Datagram Protocol，用户数据报协议） 端口： 应用程序 FTP TELNET SMTP DNS TFTP HTTP HTTPS SNMP 端口号 21 23 25 53 69 80 443 161 TCP TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。 特征： 面向连接 只能点对点（一对一）通信 可靠交互 全双工通信 面向字节流 TCP 如何保证可靠传输： 确认和超时重传 数据合理分片和排序 流量控制 拥塞控制 数据校验 TCP 报文结构 TCP 首部 TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下： URG：紧急比特（urgent），当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。 ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。 PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。 RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。 FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 UDP UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。 特征： 无连接 尽最大努力交付 面向报文 没有拥塞控制 支持一对一、一对多、多对一、多对多的交互通信 首部开销小 UDP 报文结构 UDP 首部 TCP/UDP 图片来源于：https://github.com/JerryC8080/understand-tcp-udp TCP 与 UDP 的区别 TCP 面向连接，UDP 是无连接的； TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付 TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信 TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题） UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等） TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节 TCP 黏包问题原因TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。 解决 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。 在数据包之间设置边界，如添加特殊符号 \\r\\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \\r\\n，则会误判为消息的边界。 使用更加复杂的应用层协议。 TCP 流量控制概念流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。 方法利用可变窗口进行流量控制 TCP 拥塞控制概念拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 方法 慢开始( slow-start ) 拥塞避免( congestion avoidance ) 快重传( fast retransmit ) 快恢复( fast recovery ) TCP的拥塞控制图 TCP 传输连接管理 因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png TCP 三次握手建立连接 【TCP 建立连接全过程解释】 客户端发送 SYN 给服务器，说明客户端请求建立连接； 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）； 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）； 服务端收到客户端的 ACK，连接已建立，可以数据传输。 TCP 为什么要进行三次握手？【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。） Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信} 【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。 知乎 . TCP 为什么是三次握手，而不是两次或四次？ 【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 《计算机网络（第 7 版）-谢希仁》 TCP 四次挥手释放连接 【TCP 释放连接全过程解释】 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）； 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）； 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）； 服务端继续发送之前没发完的数据给客户端； 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）； 客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）； 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。 TCP 为什么要进行四次挥手？【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？ 【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。 【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手） 【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。 【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？ 【答案三】 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。 Time-wait状态(2MSL)一些理解 TCP 有限状态机TCP 有限状态机图片 TCP和UDP详解 HTTP、TCP、UDP详解 应用层DNS DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。 域名： 域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}，如：blog.huihut.com FTP FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。 TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定 TELNET TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。 WWW WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问 URL URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address） 标准格式： 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 完整格式： 协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项如：https://github.com/huihut/interview#cc HTTPHTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。 请求方法 方法 意义 OPTIONS 请求一些选项信息，允许客户端查看服务器的性能 GET 请求指定的页面信息，并返回实体主体 HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 PUT 从客户端向服务器传送的数据取代指定的文档的内容 DELETE 请求服务器删除指定的页面 TRACE 回显服务器收到的请求，主要用于测试或诊断 状态码（Status-Code） 1xx：表示通知信息，如请求收到了或正在进行处理 100 Continue：继续，客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 2xx：表示成功，如接收或知道了 200 OK: 请求成功 3xx：表示重定向，如要完成请求还必须采取进一步的行动 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替 4xx：表示客户的差错，如请求中有错误的语法或不能完成 400 Bad Request: 客户端请求的语法错误，服务器无法理解 401 Unauthorized: 请求要求用户的身份认证 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时 5xx：表示服务器的差错，如服务器失效无法完成请求 500 Internal Server Error: 服务器内部错误，无法完成请求 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求 更多状态码：菜鸟教程 . HTTP状态码 其他协议 SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途： 用于内部网络或网络服务供应商自动分配 IP 地址给用户 用于内部网络管理员作为对所有电脑作中央管理的手段 SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。 网络编程SocketLinux Socket 编程（不限 Linux） Socket 中的 read()、write() 函数12ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count); read() read 函数是负责从 fd 中读取内容。 当读成功时，read 返回实际所读的字节数。 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。 write() write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。 （1）write 的返回值大于 0，表示写了部分或者是全部的数据。 （2）返回的值小于 0，此时出现了错误。 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。 Socket 中 TCP 的三次握手建立连接我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下： 客户端向服务器发送一个 SYN J 服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1 客户端再想服务器发一个确认 ACK K+1 只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图： 从图中可以看出： 当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态； 服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态； 客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认； 服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。 Socket 中 TCP 的四次握手释放连接上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图： 图示过程如下： 某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M； 另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N； 接收到这个 FIN 的源发送端 TCP 对它进行确认。 这样每个方向上都有一个 FIN 和 ACK。 数据库 数据库事务四大特性：原子性、一致性、分离性、持久性 数据库索引：顺序索引、B+ 树索引、hash 索引MySQL 索引背后的数据结构及算法原理 SQL 约束 (Constraints) 范式 第一范式（1NF）：属性（字段）是最小单位不可再分 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖） 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖） 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖） 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖） 设计模式 各大设计模式例子参考：CSDN专栏 . C++ 设计模式 系列博文 设计模式工程目录 单例模式单例模式例子 抽象工厂模式抽象工厂模式例子 适配器模式适配器模式例子 桥接模式桥接模式例子 观察者模式观察者模式例子 设计模式的六大原则 单一职责原则（SRP，Single Responsibility Principle） 里氏替换原则（LSP，Liskov Substitution Principle） 依赖倒置原则（DIP，Dependence Inversion Principle） 接口隔离原则（ISP，Interface Segregation Principle） 迪米特法则（LoD，Law of Demeter） 开放封闭原则（OCP，Open Close Principle） 链接装载库内存、栈、堆一般应用程序内存空间有如下区域： 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据 栈栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面： 函数的返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 保存上下文：包括函数调用前后需要保持不变的寄存器 堆堆分配算法： 空闲链表（Free List） 位图（Bitmap） 对象池 “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。 普遍原因： 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针 编译链接各平台文件格式 平台 可执行文件 目标文件 动态库/共享对象 静态库 Windows exe obj dll lib Unix/Linux ELF、out o so a Mac Mach-O o dylib、tbd、framework a、framework 编译链接过程 预编译（预编译器处理如 #include、#define 等预编译指令，生成 .i 或 .ii 文件） 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 .s 文件） 汇编（汇编器把汇编码翻译成机器码，生成 .o 文件） 链接（连接器进行地址和空间分配、符号决议、重定位，生成 .out 文件） 现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin 目标文件编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。 可执行文件（Windows 的 .exe 和 Linux 的 ELF）、动态链接库（Windows 的 .dll 和 Linux 的 .so）、静态链接库（Windows 的 .lib 和 Linux 的 .a）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF） 目标文件格式 Windows 的 PE（Portable Executable），或称为 PE-COFF，.obj 格式 Linux 的 ELF（Executable Linkable Format），.o 格式 Intel/Microsoft 的 OMF（Object Module Format） Unix 的 a.out 格式 MS-DOS 的 .COM 格式 PE 和 ELF 都是 COFF（Common File Format）的变种 目标文件存储结构 段 功能 File Header 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等） .text section 代码段，执行语句编译成的机器代码 .data section 数据段，已初始化的全局变量和局部静态变量 .bss section BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间） .rodata section 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量 .comment section 注释信息段，存放编译器版本信息 .note.GNU-stack section 堆栈提示段 其他段略 链接的接口————符号在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。 如下符号表（Symbol Table）： Symbol（符号名） Symbol Value （地址） main 0x100 Add 0x123 … … Linux 的共享库（Shared Library）Linux 下的共享库就是普通的 ELF 共享对象。 共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容 命名libname.so.x.y.z x：主版本号，不同主版本号的库之间不兼容，需要重新编译 y：次版本号，高版本号向后兼容低版本号 z：发布版本号，不对接口进行更改，完全兼容 路径大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。 /lib：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等 /usr/lib：存放非系统运行时所需要的关键性的库，主要是开发库 /usr/local/lib：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库 动态链接器会在 /lib、/usr/lib 和由 /etc/ld.so.conf 配置文件指定的，目录中查找共享库 环境变量 LD_LIBRARY_PATH：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序 LD_PRELOAD：指定预先装载的一些共享库甚至是目标文件 LD_DEBUG：打开动态链接器的调试功能 so 共享库的编写使用 CLion 编写共享库 创建一个名为 MySharedLib 的共享库 CMakeLists.txt 123456cmake_minimum_required(VERSION 3.10)project(MySharedLib)set(CMAKE_CXX_STANDARD 11)add_library(MySharedLib SHARED library.cpp library.h) library.h 12345678910111213141516171819#ifndef MYSHAREDLIB_LIBRARY_H#define MYSHAREDLIB_LIBRARY_H// 打印 Hello World!void hello();// 使用可变模版参数求和template &lt;typename T&gt;T sum(T t)&#123; return t;&#125;template &lt;typename T, typename ...Types&gt;T sum(T first, Types ... rest)&#123; return first + sum&lt;T&gt;(rest...);&#125;#endif library.cpp 123456#include &lt;iostream&gt;#include \"library.h\"void hello() &#123; std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;&#125; so 共享库的使用（被可执行项目调用）使用 CLion 调用共享库 创建一个名为 TestSharedLib 的可执行项目 CMakeLists.txt 12345678910111213141516171819cmake_minimum_required(VERSION 3.10)project(TestSharedLib)# C++11 编译set(CMAKE_CXX_STANDARD 11)# 头文件路径set(INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径set(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)include_directories($&#123;INC_DIR&#125;)link_directories($&#123;LIB_DIR&#125;)link_libraries(MySharedLib)add_executable(TestSharedLib main.cpp)# 链接 MySharedLib 库target_link_libraries(TestSharedLib MySharedLib) main.cpp 12345678910111213#include &lt;iostream&gt;#include \"library.h\"using std::cout;using std::endl;int main() &#123; hello(); cout &lt;&lt; \"1 + 2 = \" &lt;&lt; sum(1,2) &lt;&lt; endl; cout &lt;&lt; \"1 + 2 + 3 = \" &lt;&lt; sum(1,2,3) &lt;&lt; endl; return 0;&#125; 执行结果 123Hello, World!1 + 2 = 31 + 2 + 3 = 6 运行库（Runtime Library）典型程序运行步骤 操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数） 入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。 入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。 main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。 一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。 glibc 入口_start -&gt; __libc_start_main -&gt; exit -&gt; _exit 其中 main(argc, argv, __environ) 函数在 __libc_start_main 里执行。 MSVC CRT 入口int mainCRTStartup(void) 执行如下操作： 初始化和 OS 版本有关的全局变量。 初始化堆。 初始化 I/O。 获取命令行参数和环境变量。 初始化 C 库的一些数据。 调用 main 并记录返回值。 检查错误并将 main 的返回值返回。 C 语言运行库（CRT）大致包含如下功能： 启动与退出：包括入口函数及入口函数所依赖的其他函数等。 标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。 I/O：I/O 功能的封装和实现。 堆：堆的封装和实现。 语言实现：语言中一些特殊功能的实现。 调试：实现调试功能的代码。 C语言标准库（ANSI C）包含： 标准输入输出（stdio.h） 文件操作（stdio.h） 字符操作（ctype.h） 字符串操作（string.h） 数学函数（math.h） 资源管理（stdlib.h） 格式转换（stdlib.h） 时间/日期（time.h） 断言（assert.h） 各种类型上的常数（limits.h &amp; float.h） 变长参数（stdarg.h） 非局部跳转（setjmp.h） 回调函数和钩子函数什么是回调函数？简而言之，回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。 为什么要使用回调函数？因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为 int ）的被调用函数。 如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、 shell 排序、 shake 排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（ int 、 float 、 string ），此时，该怎么办呢？可以使用函数指针，并进行回调。 回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API 使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。 另一个使用回调机制的 API 函数是 EnumWindow() ，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。 EnumWindow() 并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。 使用场景不管怎么说，回调函数是继续自 C 语言的，因而，在 C++ 中，应只在与 C 代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在 C++ 中应使用虚拟方法或函数符（ functor ），而不是回调函数。 机制也可以这样，更容易理解：回调函数就好像是一个中断处理函数，系统在符合你设定的条件时自动调用。 为此，你需要做三件事： 声明； 定义； 设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用。 声明和定义时应注意：回调函数由系统调用，所以可以认为它属于WINDOWS系统，不要把它当作你的某个类的成员函数 回调函数是一个程序员不能显式调用的函数；通过将回调函数的地址传给调用者从而实现调用。回调函数使用是必要的，在我们想通过一个统一接口实现不同的内容，这时用回掉函数非常合适。比如，我们为几个不同的设备分别写了不同的显示函数：void TVshow(); void ComputerShow(); void NoteBookShow()…等等。这是我们想用一个统一的显示函数，我们这时就可以用回掉函数了。void show(void (*ptr)()); 使用时根据所传入的参数不同而调用不同的回调函数。 参考 C语言中的回调函数 一文搞懂C语言回调函数 c语言实现回调函数 函数指针 什么是钩子函数？钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。对每种类型的钩子由系统来维护一个钩子链，最近安装的钩子放在链的开始，而最先安装的钩子放在最后，也就是后加入的先获得控制权。 本质钩子函数是Windows消息处理机制的一部分，通过设置“钩子”，应用程序可以在系统级对所有消息、事件进行过滤，访问在正常情况下无法访问的消息。钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。 类型 局部钩子：仅钩挂您自己进程的事件。 远程钩子：可以钩挂自己进程或其他进程的事件， 远程钩子又分为两种： 一种是系统级的全局钩子， 一种是线程级的钩子。 全局钩子函数需要定义在 DLL 中，线程级的钩子中经常用到 GetCurrentThreadID 函数来获取当前线程的ID。 机制当创建一个钩子时，WINDOWS会先在内存中创建一个数据结构，该数据结构包含了钩子的相关信息，然后把该结构体加到已经存在的钩子链表中去。新的钩子将加到老的前面。当一个事件发生时，如果安装的是一个局部钩子，自己进程中的钩子函数将被调用。如果是一个远程钩子，系统就必须把钩子函数插入到其他进程的地址空间，要做到这一点要求钩子函数必须在一个动态链接库中，所以如果想要使用远程钩子，就必须把该钩子函数放到动态链接库中去。 两个例外： 工作日志钩子 工作日志回放钩子。 这两个钩子的钩子函数必须在安装钩子的线程中。原因是： 这两个钩子是用来监控比较底层的硬件事件的，既然是记录和回放，所有的事件就当然都是有先后次序的。所以如果把回调函数放在DLL中，输入的事件被放在几个线程中记录，所以我们无法保证得到正确的次序。 解决办法：把钩子函数放到单个的线程中，譬如安装钩子的线程。 参考 浅谈c++ hook 钩子的使用介绍 异步消息的传递－回调机制 异步消息的传递－回调机制 什么是回调软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类： 同步调用 回调 异步调用 同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知。 同步调用是三者当中最简单的，而回调又常常是异步调用的基础，因此，下面我们着重讨论回调机制在不同软件架构中的实现。 对于不同类型的语言（如结构化语言和对象语言）、平台（Win32、JDK）或构架（CORBA、DCOM、WebService），客户和服务的交互除了同步方式以外，都需要具备一定的异步通知机制，让服务方（或接口提供方）在某些情况下能够主动通知客户，而回调是实现异步的一个最简捷的途径。 对于一般的结构化语言，可以通过回调函数来实现回调。回调函数也是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数。 在面向对象的语言中，回调则是通过接口或抽象类来实现的，我们把实现这种接口的类成为回调类，回调类的对象成为回调对象。对于象C++或Object Pascal这些兼容了过程特性的对象语言，不仅提供了回调对象、回调方法等特性，也能兼容过程语言的回调函数机制。 Windows平台的消息机制也可以看作是回调的一种应用，我们通过系统提供的接口注册消息处理函数（即回调函数），从而实现接收、处理消息的目的。由于Windows平台的API是用C语言来构建的，我们可以认为它也是回调函数的一个特例。 对于分布式组件代理体系CORBA，异步处理有多种方式，如回调、事件服务、通知服务等。事件服务和通知服务是CORBA用来处理异步消息的标准服务，他们主要负责消息的处理、派发、维护等工作。对一些简单的异步处理过程，我们可以通过回调机制来实现。 下面我们集中比较具有代表性的语言（C、Object Pascal）和架构（CORBA）来分析回调的实现方式、具体作用等。 过程语言中的回调（C）函数指针回调在C语言中是通过函数指针来实现的，通过将回调函数的地址传给被调函数从而实现回调。因此，要实现回调，必须首先定义函数指针，请看下面的例子： 12void Func(char *s)； // 函数原型void (*pFunc) (char *); //函数指针 可以看出，函数的定义和函数指针的定义非常类似。 一般的话，为了简化函数指针类型的变量定义，提高程序的可读性，我们需要把函数指针类型自定义一下。 1typedef void(*pcb)(char *); 回调函数可以象普通函数一样被程序调用，但是只有它被当作参数传递给被调函数时才能称作回调函数。 被调函数的例子： 1234567891011void GetCallBack(pcb callback)&#123; /* do something */&#125;// 用户在调用上面的函数时，需要自己实现一个pcb类型的回调函数：void fCallback(char *s) &#123; /* do something */&#125; // 然后，就可以直接把fCallback当作一个变量传递给GetCallBack,GetCallBack（fCallback）; 如果赋了不同的值给该参数，那么调用者将调用不同地址的函数。赋值可以发生在运行时，这样使你能实现动态绑定。 参数传递规则到目前为止，我们只讨论了函数指针及回调而没有去注意 ANSI C/C++ 的编译器规范。许多编译器有几种调用规范。如在Visual C++中，可以在函数类型前加 _cdecl，_stdcall 或者 _pascal 来表示其调用规范（默认为 _cdecl）。C++ Builder也支持 _fastcall 调用规范。调用规范影响编译器产生的给定函数名，参数传递的顺序（从右到左或从左到右），堆栈清理责任（调用者或者被调用者）以及参数传递机制（堆栈，CPU寄存器等）。 将调用规范看成是函数类型的一部分是很重要的；不能用不兼容的调用规范将地址赋值给函数指针。例如： 123456// 被调用函数是以 int 为参数，以 int 为返回值__stdcall int callee(int); // 调用函数以函数指针为参数void caller( __cdecl int(*ptr)(int)); // 在 p 中企图存储被调用函数地址的非法操作__cdecl int(*p)(int) = callee; // 出错 指针 p 和 callee() 的类型不兼容，因为它们有不同的调用规范。因此不能将被调用者的地址赋值给指针p，尽管两者有相同的返回值和参数列 应用举例C 语言的标准库函数中很多地方就采用了回调函数来让用户定制处理过程。如常用的快速排序函数、二分搜索函数等。 123456// 快速排序函数原型：void qsort(void *base, size_t nelem, size_t width, int (_USERENTRY *fcmp)(const void *, const void *));// 二分搜索函数原型：void *bsearch(const void *key, const void *base, size_t nelem, size_t width, int (_USERENTRY *fcmp)(const void *, const void *)); 其中 fcmp 就是一个回调函数的变量。 下面给出一个具体的例子： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int sort_function( const void *a, const void *b);int list[5] = &#123; 54, 21, 11, 67, 22 &#125;;int main(void)&#123; int x; qsort((void *)list, 5, sizeof(list[0]), sort_function); for (x = 0; x &lt; 5; x++) printf(\"%i\\n\", list[x]); return 0;&#125;int sort_function( const void *a, const void *b)&#123; return *(int*)a-*(int*)b;&#125; 回调在分布式计算中的应用（CORBA）回调接口模型CORBA 的消息传递机制有很多种，比如回调接口、事件服务和通知服务等。回调接口的原理很简单，CORBA 客户和服务器都具有双重角色，即充当服务器也是客户客户。 回调接口的反向调用与正向调用往往是同时进行的，如果服务端多次调用该回调接口，那么这个回调接口就变成异步接口了。因此，回调接口在 CORBA 中常常充当事件注册的用途，客户端调用该注册函数时，客户函数就是回调函数，在此后的调用中，由于不需要客户端的主动参与，该函数就是实现了一种异步机制。 从 CORBA 规范我们知道，一个 CORBA 接口在服务端和客户端有不同的表现形式，在客户端一般使用桩（Stub）文件，服务端则用到框架（Skeleton）文件，接口的规格采用 IDL 来定义。而回调函数的引入，使得服务端和客户端都需要实现一定的桩和框架。下面是回调接口的实现模型： 下面给出了一个使用回调的接口文件，服务端需要实现 Server 接口的框架，客户端需要实现 CallBack 的框架： 1234567891011121314module cb&#123; interface CallBack; interface Server; interface CallBack &#123; void OnEvent(in long Source,in long msg); &#125;; interface Server &#123; long RegisterCB(in CallBack cb); void UnRegisterCB(in long hCb); &#125;;&#125;; 客户端首先通过同步方式调用服务端的接口 RegistCB，用来注册回调接口 CallBack。服务端收到该请求以后，就会保留该接口引用，如果发生某种事件需要向客户端通知的时候就通过该引用调用客户方的 OnEvent 函数，以便对方及时处理。 野指针避免野指针的方法为了防止野指针带来的灾难，建议指针在定义时给一个初值，比如“NULL”，意思是不指向任何内存地址。然后再使用malloc函数给指针分配一块存储空间。 避免野指针的方法 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;int main()&#123; char *str1 = \"123\"; char *str2 = NULL; //str2 赋初值，不指向任何内存 printf(\"str2的值是: %u\\n\", str2); str2 = (char *)malloc(10); printf(\"str2被分配的地址是: %u\\n\", str2); strcpy(str2, str1); printf(\"str2指向的字符串是: %s\\n\", str2); if(NULL != str2) &#123; free(str2); // 主动释放分配给str2的内存 str2 = NULL; // 让str2不指向任何内存 &#125; return 0;&#125; 海量数据处理 海量数据处理面试题集锦 十道海量数据处理面试题与十个方法大总结 音视频 最全实时音视频开发要用到的开源工程汇总 18个实时音视频开发中会用到开源项目 其他 Bjarne Stroustrup 的常见问题 Bjarne Stroustrup 的 C++ 风格和技巧常见问题 书籍语言 《C++ Primer》 《Effective C++》 《More Effective C++》 《深度探索 C++ 对象模型》 《深入理解 C++11》 《STL 源码剖析》 算法 《剑指 Offer》 《编程珠玑》 《程序员面试宝典》 系统 《深入理解计算机系统》 《Windows 核心编程》 《Unix 环境高级编程》 网络 《Unix 网络编程》 《TCP/IP 详解》 其他 《程序员的自我修养》 复习刷题网站 leetcode 牛客网 慕课网 菜鸟教程 招聘时间岗位 牛客网 . 2019 IT名企校招指南 面试题目经验牛客网 牛客网 . 2017秋季校园招聘笔经面经专题汇总 牛客网 . 史上最全2017春招面经大合集！！ 牛客网 . 面试题干货在此 知乎 知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。 知乎 . 互联网公司最常见的面试算法题有哪些？ 知乎 . 面试 C++ 程序员，什么样的问题是好问题？ CSDN CSDN . 全面整理的C++面试题 CSDN . 百度研发类面试题（C++方向） CSDN . c++常见面试题30道 CSDN . 腾讯2016实习生面试经验（已经拿到offer) cnblogs cnblogs . C++面试集锦( 面试被问到的问题 ) cnblogs . C/C++ 笔试、面试题目大汇总 cnblogs . 常见C++面试题及基本知识点总结（一） Segmentfault segmentfault . C++常见面试问题总结 HTTP相关知识 你必须知道的HTTP基本概念 浏览器中常见网络协议介绍 WebRTC介绍及简单应用 WebRTC架构简介 了不起的WebRTC：生态日趋完善，或将实时音视频技术白菜化 Spark Apache Spark 中文文档 Apache Spark 2.2.0 官方文档中文版（翻译完成 98%. 除 MLib 外） | ApacheCN 30分钟概览Spark分布式计算引擎 加密安全问题 SHA算法系列介绍 比特币背后的密码学原理 比特币的加密算法 密码学大事件！ SHA-1 哈希碰撞实例 如何安全的存储用户的密码 机器学习作用于信息安全的五大顶级案例 机器学习和数据挖掘在网络安全领域会有哪些应用？ 机器学习正在安全领域挂起一阵小旋风，但这里面有BUG 其他 终于有人把P2P、P2C、O2O、B2C、B2B、C2C 的区别讲透了！ 如何真正让小程序,WebRTC和APP互通连麦直播 创业者必读：开发一款 App 到底需要多久？ 如何开发一个app（Android） 微信小程序开发教程–从零开始 面向机器学习:数据平台的设计与搭建 基于Apache Spark以BigDL搭建可扩展的分布式深度学习框架 高德面试基本知识 1、进程和线程 2、多线程通讯方式 3、消费者和生产者模式（消费者是否轮询方式读取消息，用等待信号方式） 4、linux命令 top、netstat 5、gdb调试，怎样切换到某个线程 6、inline和宏定义区别 7、vector和list区别，什么情况分别是用什么 8、类的什么函数不能作为虚函数、析构函数能否作为虚函数，虚函数怎么实现的 9、setsocektopt no-delay，等参数的作用 10、tcp关闭时的几个步骤，tcp的慢启动时啥意思，，，， 11、epoll模型，我说的是多线程，每个线程一个epoll，一个专门接收链接，另外的读数据 ，解码在哪个线程中进行 12、c++11 智能指针 13、死锁概念 14、什么叫做稳定排序、有哪些排序算法、快排怎么实现的 15、怎么样判断一棵树和平衡二叉树 16、当前编写代码（输入一个字符串和一个分隔符，，，，，，把字符串用分割符分割几部分，然后输出） 项目： 1、freeswitch的系统结构模型、并发的语音的最大路数，语音编码 2、视频花屏是怎样优化的 3、rtp，udp 4、语音包、和视频包是不是固定大小的，，，是否分包","categories":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/categories/Program-C/"}],"tags":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/tags/Program-C/"}]},{"title":"Program-C 数据结构","slug":"Program-C/数据结构","date":"2016-06-03T02:14:50.000Z","updated":"2019-06-10T08:03:58.792Z","comments":true,"path":"2016/06/03/Program-C/数据结构/","link":"","permalink":"http://miaopei.github.io/2016/06/03/Program-C/数据结构/","excerpt":"数据结构","text":"数据结构 一、数据结构概念1.1 数据结构相关概念疑惑 1、我学完了C语言，可是现在感觉还是写不出代码。 2、为什么会有各种各样的程序存在？ 3、程序的本质是什么？ 程序是为了具体问题而存在的 程序需要围绕问题的解决进行设计 同一个问题可以有多种解决方案 如何追求程序的“性价比”？ 是否有可量化的方法判别程序的好坏？ 数据结构起源 计算机从解决数值计算问题到解决生活中的问题 现实生活中的问题涉及不同个体间的复杂联系 需要在计算机程序中描述生活中个体间的联系 *数据结构主要研究非数值计算程序问题中的操作对象以及它们之间的关系 * 不是研究复杂的算法 数据结构中的基本概念 数据 – 程序的操作对象，用于描述客观事物 (int a, int b,) 数据的特点： 可以输入到计算机 可以被计算机程序处理 数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等 数据元素：组成数据的基本单位 数据项：一个数据元素由若干数据项组成 数据对象 – 性质相同的数据元素的集合 （比如：数组，链表） 123456789101112131415161718//声明一个结构体类型struct _MyTeacher&#123; //一种数据类型 char name[32]; char tile[32]; int age; char addr[128];&#125;;int main21()&#123; struct _MyTeacher t1; //数据元素 struct _MyTeacher tArray[30]; //数据对象 memset(&amp;t1, 0, sizeof(t1)); strcpy(t1.name, \"name\"); //数据项 strcpy(t1.addr, \"addr\"); //数据项 strcpy(t1.tile, \"addr\"); //数据项 t1.age = 1;&#125; 数据元素之间不是独立的，存在特定的关系，这些关系即结构 *数据结构指数据对象中数据元素之间的关系 * 如：数组中各个元素之间存在固定的线性关系 编写一个“好”的程序之前，必须分析待处理问题中各个对象的特性，以及对象之间的关系。 基本概念总结： 数据的逻辑结构 指数据元素之间的逻辑关系。即从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。逻辑结构可细分为4类： 数据的物理结构 数据的运算 1.2 算法算法概念 算法是特定问题求解步骤的描述 在计算机中表现为指令的有限序列 算法是独立存在的一种解决问题的方法和思想。 对于算法而言，语言并不重要，重要的是思想。 算法和数据结构区别 数据结构只是静态的描述了数据元素之间的关系 高效的程序需要在数据结构的基础上设计和选择算法 程序 = 数据结构 + 算法 总结： 算法是为了解决实际问题而设计的 数据结构是算法需要处理的问题载体 数据结构与算法相辅相成 算法特性 输入 算法具有0个或多个输入 输出 算法至少有1个或多个输出 有穷性 算法在有限的步骤之后会自动结束而不会无限循环 确定性 算法中的每一步都有确定的含义，不会出现二义性 可行性 算法的每一步都是可行的 算法效率的度量 1、事后统计法 比较不同算法对同一组输入数据的运行处理时间 缺陷 为了获得不同算法的运行时间必须编写相应程序 运行时间严重依赖硬件以及运行时的环境因素 算法的测试数据的选取相当困难 事后统计法虽然直观，但是实施困难且缺陷多 算法效率的度量 事前分析估算 依据统计的方法对算法效率进行估算 影响算法效率的主要因素 算法采用的策略和方法 问题的输入规模 编译器所产生的代码 计算机执行速度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//算法最终编译成具体的计算机指令//每一个指令，在具体的计算机上运行速度固定//通过具体的n的步骤，就可以推导出算法的复杂度long sum1(int n)&#123; long ret = 0; int* array = (int*)malloc(n * sizeof(int)); int i = 0; for(i=0; i&lt;n; i++) array[i] = i + 1; for(i=0; i&lt;n; i++) ret += array[i]; free(array); return ret; &#125;long sum2(int n)&#123; long ret = 0; int i = 0; for(i=1; i&lt;=n; i++) ret += i; return ret;&#125;long sum3(int n)&#123; long ret = 0; if( n &gt; 0 ) ret = (1 + n) * n / 2; return ret;&#125;int main()&#123; printf(\"%d\\n\", sum1(100)); printf(\"%d\\n\", sum2(100)); printf(\"%d\\n\", sum3(100)); return 0;&#125;int func(int a[], int len)&#123; int i = 0; int j = 0; int s = 0; for(i=0; i&lt;len; i++)&#123; for(j=0; j&lt;len; j++)&#123; s += i*j; //n*n &#125; &#125; return s; &#125; 注意 1：判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略。 注意 2：在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度。 2、大 O 表示法 算法效率严重依赖于操作(Operation)数量 在判断时首先关注操作数量的最高次项 操作数量的估算可以作为时间复杂度的估算 1234O(5) = O(1)O(2n + 1) = O(2n) = O(n) O(n2+ n + 1) = O(n2)O(3n3+1) = O(3n3) = O(n3) 常见时间复杂度 关系 3、算法的空间复杂度 算法的空间复杂度通过计算算法的存储空间实现 1S(n) = O(f(n)) 其中，n 为问题规模，f(n) 为在问题规模为 n 时所占用存储空间的函数 大 O 表示法同样适用于算法的空间复杂度 当算法执行时所需要的空间是常数时，空间复杂度为O(1) 空间与时间的策略： 多数情况下，算法执行时所用的时间更令人关注 如果有必要，可以通过增加空间复杂度来降低时间复杂度 同理，也可以通过增加时间复杂度来降低空间复杂度 练习1：分析 sum1 sum2 sum3 函数的空间复杂度 1O(4n+12) O(8)=O(1) O(4)=O(1) 总结：实现算法时，需要分析具体问题，对执行时间和空间的要求。 练习2：时间换空间 1234567891011121314151617181920212223242526272829303132333435/* 问题： 在一个由自然数 1-1000 中某些数字所组成的数组中，每个数字可能出现零次或者多次。 设计一个算法，找出出现次数最多的数字。*/方法1： 排序，然后找出出现次数最多的数字方法2：void search(int a[], int len)&#123; int sp[1000] = &#123;0&#125;; int i = 0; int max = 0; for(i=0; i&lt;len; i++)&#123; int index = a[i] - 1; sp[index]++; &#125; for(i=0; i&lt;1000; i++)&#123; if( max &lt; sp[i] ) max = sp[i]; &#125; for(i=0; i&lt;1000; i++)&#123; if( max == sp[i] ) printf(\"%d\\n\", i+1); &#125;&#125;int main()&#123; int array[] = &#123;1, 1, 3, 4, 5, 6, 6, 6, 2, 3&#125;; search(array, sizeof(array)/sizeof(*array)); return 0;&#125; 把每个数字出现的次数的中间结果，缓存下来；在缓存的结果中求最大值。 二、线性表2.1 线性表基本概念线性表定义 线性表(List)是零个或多个数据元素的集合 线性表中的数据元素之间是有顺序的 线性表中的数据元素个数是有限的 线性表中的数据元素的类型必须相同 数学定义 线性表是具有相同类型的 n（ ≥ 0）个数据元素的有限序列 12（a1, a2, …, an）ai 是表项，n 是表长度。 性质 a0 为线性表的第一个元素，只有一个后继 an 为线性表的最后一个元素，只有一个前驱 除 a0 和 an 外的其它元素 ai，既有前驱，又有后继 线性表能够逐项访问和顺序存取 练习 下面的关系中可以用线性表描述的是 A.班级中同学的友谊关系 N:N B.公司中的上下级关系 1:N C.冬天图书馆排队占座关系 D.花名册上名字之间的关系 1::1 线性表的操作 创建线性表 销毁线性表 清空线性表 将元素插入线性表 将元素从线性表中删除 获取线性表中某个位置的元素 获取线性表的长度 线性表在程序中表现为一种特殊的数据类型 线性表的操作在程序中的表现为一组函数 1234567891011121314151617181920212223242526272829/* C 语言描述=====》线性表的设计与实现 ADT 抽象层 《[数据结构(C语言版)].严蔚敏_吴伟民.扫描版.pdf》 p44页 */#ifndef _WBM_LIST_H_#define _WBM_LIST_H_typedef void List;typedef void ListNode;//创建并且返回一个空的线性表List* List_Create();//销毁一个线性表listvoid List_Destroy(List* list);//将一个线性表list中的所有元素清空, 线性表回到创建时的初始状态void List_Clear(List* list);//返回一个线性表list中的所有元素个数int List_Length(List* list);//向一个线性表list的pos位置处插入新元素nodeint List_Insert(List* list, ListNode* node, int pos); //获取一个线性表list的pos位置处的元素ListNode* List_Get(List* list, int pos);//删除一个线性表list的pos位置处的元素 返回值为被删除的元素，NULL表示删除失败ListNode* List_Delete(List* list, int pos);#endif/* 注意: */int List_Insert(List* list, ListNode* node, int pos); (重点:分离思想) 2.2 线性表的顺序存储结构基本概念 设计与实现 插入元素算法 判断线性表是否合法 判断插入位置是否合法 把最后一个元素到插入位置的元素后移一个位置 将新元素插入 线性表长度加 1 获取元素操作 判断线性表是否合法 判断位置是否合法 直接通过数组下标的方式获取元素 删除元素算法 判断线性表是否合法 判断删除位置是否合法 将元素取出 将删除位置后的元素分别向前移动一个位置 线性表长度减 1 链表顺序存储插入算法和删除算法 优点和缺点 优点： 无需为线性表中的逻辑关系增加额外的空间 可以快速的获取表中合法位置的元素 缺点： 插入和删除操作需要移动大量元素 当线性表长度变化较大时难以确定存储空间的容量 2.3 线性表的链式存储基本概念 链式存储定义 为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。 表头结点 链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息 数据结点 链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息 尾结点 链表中的最后一个数据结点，其下一元素指针为空，表示无后继。 链表技术领域推演 设计与实现 链表链式存储 _api 实现分析 在C语言中可以用结构体来定义链表中的指针域 链表中的表头结点也可以用结构体实现 12345678910111213141516typedef void * LK; // 不希望看到内部数据是可以这么定义// 初始化链表LK init_LinkList(); // 插入节点void Insert_LinkList(LK list, int position, void *data);// 遍历void Foreach_LinkList(LK list, void(*myforeach)(void *)) ;// 删除节点void RemoveByPos_LinkList(LK list, int position);// 销毁void Destroy_LinkList(LK list); 123456789101112131415161718192021// 带头结点、位置从0的单链表// 返回链表中第3个位置处，元素的值LinkListNode* LinkList_Get(LinkList* list, int pos)&#123; int i = 0; TLinkList *tList = (TLinkList *)list; LinkListNode *current = NULL; LinkListNode *ret = NULL; if (list == NULL || pos &lt; 0 || pos &gt;= tList-&gt;length) return NULL; current = (LinkListNode *)tList; for (i=0; i&lt;pos; i++) current = current-&gt;next; ret = current-&gt;next; return ret ;&#125;/* */ 返回第三个位置的,移动pos次以后，当前指针指向哪里？ 答案：指向位置2，所以需要返回 ret = current-&gt;next; 1234567/* 备注：循环遍历时， 遍历第1次，指向位置0 遍历第2次，指向位置1 遍历第3次，指向位置2 遍历第n次，指向位置n-1;*/ 所以如果想返回位置 n 的元素的值，需要怎么做 ret = current-&gt;next; 此问题是：*指向头结点的指针移动 n 次 和 第 n 个元素之间的关系？ * 删除元素 优点和缺点 优点： 无需一次性定制链表的容量 插入和删除操作无需移动数据元素 缺点： 数据元素必须保存后继元素的位置信息 获取指定数据的元素操作需要顺序访问之前的元素 2.4 循环链表基本概念 循环链表的定义：将单链表中最后一个数据元素的next指针指向第一个元素 循环链表拥有单链表的所有操作 创建链表 销毁链表 获取链表长度 清空链表 获取第pos个元素操作 插入元素到位置pos 删除位置pos处的元素 新增功能：游标 的定义 在循环链表中可以定义一个“当前”指针，这个指针通常称为 游标，可以通过这个游标来遍历链表中的所有元素。 循环链表新操作 123456789101112// 将游标重置指向链表中的第一个数据元素CircleListNode* CircleList_Reset(CircleList* list);// 获取当前游标指向的数据元素CircleListNode* CircleList_Current(CircleList* list);// 将游标移动指向到链表中的下一个数据元素CircleListNode* CircleList_Next(CircleList* list);// 直接指定删除链表中的某个数据元素 CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node); // 根据元素的 值 删除, 元素 pk 根据元素的 位置 删除元素 循环链表的应用 证明循环链表 打印两次。 约瑟夫问题求解 约瑟夫问题 - 循环链表典型应用 n 个人围成一个圆圈，首先第 1 个人从 1 开始一个人一个人顺时针报数，报到第 m 个人，令其出列。然后再从下一 个人开始从 1 顺时针报数，报到第 m 个人，再令其出列，…，如此下去，求出列顺序。 设计与实现 循环链表插入元素的分析 1） 普通插入元素（和单链表是一样的） 2） 尾插法（和单链表是一样的，单链表的写法支持尾插法；因：辅助指针向后跳length次，指向最后面那个元素） 1void CircleList_Insert(list, (CircleListNode*)&amp;v1, CircleList_Length(list)); 3） 头插法（要进行头插法，需要求出尾结点，和单链表不一样的地方，保证是循环链表）第一次插入元素时，让游标指向 0 号结点 1void CircleList_Insert(list, (CircleListNode*)&amp;v1, 0); 4）第一次插入元素 循环链表插入综合场景分析图 循环链表删除结点分析 1、 删除普通结点 2、 删除头结点（删除 0 号位置处元素），需要求出尾结点 优点和缺点 优点：功能强了。 循环链表只是在单链表的基础上做了一个加强 循环链表可以完全取代单链表的使用 循环链表的 Next 和 Current 操作可以高效的遍历链表中的所有元素 缺点： 代码复杂度提高了 2.5 双向链表基本概念 请思考： 为什么 需要 双向链表？ 单链表的结点都只有一个指向下一个结点的指针 单链表的数据元素无法直接访问其前驱元素 逆序访问单链表 中的元素是极其 耗时 的操作！ 1234567len = LinkList_Length(list);for (i=len-1; len&gt;=0; i++) //O(n)&#123; LinkListNode *p = LinkList_Get(list, i); //O(n) //访问数据元素p中的元素 //&#125; 双向链表的定义 在单链表的结点中增加一个指向其前驱的 pre 指针 双向链表拥有单链表的所有操作 创建链表 销毁链表 获取链表长度 清空链表 获取第 pos 个元素操作 插入元素到位置 pos 删除位置 pos 处的元素 设计与实现 循环链表一般操作 插入操作 插入操作异常处理 插入第一个元素异常处理 在 0 号位置处插入元素； 删除操作 删除操作异常处理 双向链表的新操作 获取当前游标指向的数据元素 将游标重置指向链表中的第一个数据元素 将游标移动指向到链表中的下一个数据元素 将游标移动指向到链表中的上一个数据元素 直接指定删除链表中的某个数据元素 123456DLinkListNode* DLinkList_DeleteNode(DLinkList* list, DLinkListNode* node);DLinkListNode* DLinkList_Reset(DLinkList* list);DLinkListNode* DLinkList_Current(DLinkList* list);DLinkListNode* DLinkList_Next(DLinkList* list);DLinkListNode* DLinkList_Pre(DLinkList* list);//大家一定要注意：教科书不会告诉你 项目上如何用；哪些点是项目的重点；做一个企业级的财富库，完成你人生开发经验的积累，是我们的学习重点，要注意！ 优点和缺点 优点： 双向链表在单链表的基础上增加了指向前驱的指针 功能上双向链表可以完全取代单链表的使用 双向链表的 Next，Pre 和 Current 操作可以高效的遍历链表中的所有元素 缺点： 代码复杂 三、栈 stack 和队列 queue3.1栈 stackStack基本概念 栈是一种 特殊的线性表 栈仅能在线性表的一端进行操作 栈顶(Top)：允许操作的一端 栈底(Bottom)：不允许操作的一端 Stack的常用操作 创建栈 销毁栈 清空栈 进栈 出栈 获取栈顶元素 获取栈的大小 1234567891011121314151617181920#ifndef _MY_STACK_H_#define _MY_STACK_H_typedef void Stack;Stack* Stack_Create();void Stack_Destroy(Stack* stack);void Stack_Clear(Stack* stack);int Stack_Push(Stack* stack, void* item);void* Stack_Pop(Stack* stack);void* Stack_Top(Stack* stack);int Stack_Size(Stack* stack);#endif //_MY_STACK_H_ 栈模型和链表模型关系分析 栈的顺序存储设计与实现 设计与实现 1234567891011121314151617181920212223#ifndef __MY_SEQLIST_H__ #define __MY_SEQLIST_H__typedef void SeqList;typedef void SeqListNode;SeqList* SeqStack_Create(int capacity);void SeqStack _Destroy(SeqStack * list);void SeqStack _Clear(SeqStack * list);int SeqStack _Length(SeqStack * list);int SeqStack _Capacity(SeqStack * list);int SeqStack _Insert(SeqStack * list, SeqListNode* node, int pos);SeqListNode* SeqList_Get(SeqList* list, int pos);SeqListNode* SeqList_Delete(SeqList* list, int pos);#endif //__MY_SEQLIST_H__ 栈的链式存储设计与实现 设计与实现 1234567891011121314151617181920#ifndef _MY_LINKSTACK_H_#define _MY_LINKSTACK_H_typedef void LinkStack;LinkStack* LinkStack_Create();void LinkStack_Destroy(LinkStack* stack);void LinkStack_Clear(LinkStack* stack);int LinkStack_Push(LinkStack* stack, void* item);void* LinkStack_Pop(LinkStack* stack);void* LinkStack_Top(LinkStack* stack);int LinkStack_Size(LinkStack* stack);#endif //_MY_LINKSTACK_H_ 栈的应用 案例1：就近匹配 应用1：就近匹配 几乎所有的编译器都具有检测括号是否匹配的能力 如何实现编译器中的符号成对检测？ 1234567#include &lt;stdio.h&gt; int main() &#123; int a[4][4]; int (*p)[4]; p = a[0]; return 0;&#125; 算法思路 从第一个字符开始扫描 当遇见普通字符时忽略， 当遇见左符号时压入栈中 当遇见右符号时从栈中弹出栈顶符号，并进行匹配 匹配成功：继续读入下一个字符 匹配失败：立即停止，并报错 结束： 成功: 所有字符扫描完毕，且栈为空 失败：匹配失败或所有字符扫描完毕但栈非空 当需要检测成对出现但又互不相邻的事物时，可以使用栈 “后进先出” 的特性，栈非常适合于需要“就近匹配”的场合 案例2：中缀表达式和后缀表达式 应用2：中缀 后缀 计算机的本质工作就是做数学运算，那计算机可以读入字符串 “9 + (3 - 1) * 5 + 8 / 2”并计算值吗？ 后缀表达式 ==？符合计算机运算 波兰科学家在20世纪50年代提出了一种将运算符放在数字后面的后缀表达式对应的， 我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯 1234// 实例：5 + 4=&gt; 5 4 + 1 + 2 * 3 =&gt; 1 2 3 * + 8 + ( 3 – 1 ) * 5 =&gt; 8 3 1 – 5 * + 中缀表达式符合人类的阅读和思维习惯 后缀表达式符合计算机的“运算习惯” 如何将中缀表达式转换成后缀表达式？ 中缀转后缀算法： 遍历中缀表达式中的数字和符号 对于数字：直接输出 对于符号： 左括号：进栈 运算符号：与栈顶符号进行优先级比较 若栈顶符号优先级低：此符合进栈 （默认栈顶若是左括号，左括号优先级最低） 若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈 右括号：将栈顶符号弹出并输出，直到匹配左括号 遍历结束：将栈中的所有符号弹出并输出 中缀转后缀 计算机是如何基于后缀表达式计算的？ 8 3 1 – 5 * + 遍历后缀表达式中的数字和符号 对于数字：进栈 对于符号： 从栈中弹出右操作数 从栈中弹出左操作数 根据符号进行运算 将运算结果压入栈中 遍历结束：栈中的唯一数字为计算结果 栈的神奇！ 中缀表达式是人习惯的表达方式 后缀表达式是计算机喜欢的表达方式 通过栈可以方便的将中缀形式变换为后缀形式 中缀表达式的计算过程类似程序编译运行的过程 扩展：给你一个字符串，计算结果 “1 + 2 * (66 / (2 * 3) + 7 )” 字符串解析 词法语法分析 优先级分析 数据结构选型===》栈还是树？ 3.2 队列queuequeue基本概念 队列是一种特殊的线性表 队列仅在线性表的两端进行操作 队头(Front)：取出数据元素的一端 队尾(Rear)：插入数据元素的一端 队列不允许在中间部位进行操作！ queue常用操作 销毁队列 清空队列 进队列 出队列 获取队头元素 获取队列的长度 1234567891011121314151617181920#ifndef _MY_QUEUE_H_#define _MY_QUEUE_H_typedef void Queue;Queue* Queue_Create();void Queue_Destroy(Queue* queue);void Queue_Clear(Queue* queue);int Queue_Append(Queue* queue, void* item);void* Queue_Retrieve(Queue* queue);void* Queue_Header(Queue* queue);int Queue_Length(Queue* queue);#endif //_MY_QUEUE_H_ 队列模型和链表模型关系分析 队列的顺序存储设计与实现 队列也是一种特殊的线性表；可以用线性表顺序存储来模拟队列。 设计与实现 12345678910111213141516171819202122#ifndef _MY_SEQQUEUE_H_#define _MY_SEQQUEUE_H_typedef void SeqQueue;SeqQueue* SeqQueue_Create(int capacity);void SeqQueue_Destroy(SeqQueue* queue);void SeqQueue_Clear(SeqQueue* queue);int SeqQueue_Append(SeqQueue* queue, void* item);void* SeqQueue_Retrieve(SeqQueue* queue);void* SeqQueue_Header(SeqQueue* queue);int SeqQueue_Length(SeqQueue* queue);int SeqQueue_Capacity(SeqQueue* queue);#endif //_MY_SEQQUEUE_H_ 队列的链式存储设计与实现 队列也是一种特殊的线性表；可以用线性表链式存储来模拟队列的链式存储。 设计与实现 1234567891011121314151617181920#ifndef _MY_LINKQUEUE_H_#define _MY_LINKQUEUE_H_typedef void LinkQueue;LinkQueue* LinkQueue_Create();void LinkQueue_Destroy(LinkQueue* queue);void LinkQueue_Clear(LinkQueue* queue);int LinkQueue_Append(LinkQueue* queue, void* item);void* LinkQueue_Retrieve(LinkQueue* queue);void* LinkQueue_Header(LinkQueue* queue);int LinkQueue_Length(LinkQueue* queue);#endif //_MY_LINKQUEUE_H_ 四、树专题树基本概念 非线性结构，一个直接前驱，但可能有多个直接后继（1:n） 树的表示法 图形表示法 广义表表示法 左孩子－右兄弟表示法 双亲孩子表示法 树的逻辑结构 一对多（1:n），有多个直接后继（如家谱树、目录树等等），但只有一个根结点，且子树之间互不相交。 广义表表示法 左孩子－右兄弟表示法 4.1 二叉树概念 先序遍历（DLR）：先访问根、再访问左、再访问右 中序遍历（LDR）：先访问左、再访问根、再访问右 后序遍历（LRD）：先访问左、再访问右、再访问根 二叉树的结构最简单，规律性最强。可以证明，所有树都能转为唯一对应的二叉树，不失一般性 定义：是 n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成 二叉树性质 性质1: 在二叉树的第 i 层上至多有 个结点（i&gt;0） 性质2: 深度为 k 的二叉树至多有 个结点（k&gt;0） 性质3: 对于任何一棵二叉树，若 2 度的结点数有 个，则叶子数（）必定为 （即） 满二叉树：一棵深度为 k 且有 个结点的二叉树。（特点：每层都“充满”了结点） 完全二叉树：深度为 k 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应。 理解：（k-1 层与满二叉树完全相同，第 k 层结点尽力靠左） 性质4: 具有 n 个结点的完全二叉树的深度必为 性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为 i 的结点，其左孩子编号必为 2i，其右孩子编号必为 2i + 1；其双亲的编号必为 i/2（i=1 时为根,除外） 二叉树的存储结构 1、顺序存储结构 按二叉树的结点“自上而下、从左至右”编号，用一组连续的存储单元存储。 答：一律转为完全二叉树！ 讨论：不是完全二叉树怎么办？ 方法很简单，将各层空缺处统统补上“虚结点”，其内容为空 2、链式存储结构 二叉树的表示 12345678910111213141516/*typedef struct BiTNode&#123; int data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;*/struct BiTNode&#123; int data; struct BiTNode *lchild, *rchild;&#125;;typedef struct BiTNode BiTNode;typedef struct BiTNode * BiTree; 树的三叉链表表示 12345678910111213141516171819202122232425typedef struct TriTNode &#123; int data; //左右孩子指针 struct TriTNode *lchild, *rchild; struct TriTNode *parent;&#125;TriTNode, *TriTree;双亲链表法//双亲链表#define MAX_TREE_SIZE 100typedef struct BPTNode&#123; int data; int parentPosition; //指向双亲的指针 //数组下标 char LRTag; //左右孩子标志域&#125;BPTNode;typedef struct BPTree&#123; BPTNode nodes[100]; //因为节点之间是分散的，需要把节点存储到数组中 int num_node; //节点数目 int root; //根结点的位置 //注意此域存储的是父亲节点在数组的下标&#125;BPTree;//用这个数据结构能表达出一颗树，为什么？ 二叉树的遍历 树的遍历本质剖析 4.2 二叉树编程实践12345typedef struct node&#123; int data; struct node *lchild,*rchild；&#125; NODE;NODE *root; 先序遍历算法 123456789DLR(NODE *root )&#123; if (root) //非空二叉树 &#123; printf(“%d”,root-&gt;data); //访问D DLR(root-&gt;lchild); //递归遍历左子树 DLR(root-&gt;rchild); //递归遍历右子树 &#125;&#125; 中序遍历算法 123456789LDR(NODE *root)&#123; if(root !=NULL) &#123; LDR(root-&gt;lchild); printf(“%d”,root-&gt;data); LDR(root-&gt;rchild); &#125; &#125; 后序遍历算法 123456789LRD (NODE *root)&#123; if(root !=NULL) &#123; LRD(root-&gt;lchild); LRD(root-&gt;rchild); printf(“%d”,root-&gt;data); &#125; &#125; 案例1：计算二叉树中叶子结点的数目 123456789101112131415int sum = 0; //全局变量DLR_CountLeafNum(NODE *root)//采用中序遍历的递归算法&#123; if ( root) //非空二叉树条件，还可写成if(root !=NULL ) &#123; if(!root-&gt;lchild&amp;&amp;!root-&gt;rchild) //是叶子结点则统计并打印 &#123; sum++; printf(\"%d\\n\",root-&gt;data); &#125; DLR_CountLeafNum(root-&gt;lchild); //递归遍历左子树，直到叶子处； DLR_CountLeafNum(root-&gt;rchild);&#125;//递归遍历右子树，直到叶子处； &#125; return(0); &#125; 思想： 1）求根结点左子树的叶子结点个数，累计到sum中，求根结点右子树的叶子结点个数累计到sum中。​ 2）若左子树还是树，重复步骤1；若右子树还是树，重复步骤1。​ 3）全局变量转成函数参数​ 4）按照先序、中序、后序方式计算叶子结点，===》三种遍历的本质思想强化：访问结点的路径都是一样的，计算结点的时机不同。 案例2：求二叉树的深度 思想： 1）求根结点左子树高度，根结点右子树高度，比较的子树最大高度，再 +1。 ​ 2）若左子树还是树，重复步骤 1；若右子树还是树，重复步骤 1。 案例3：完全Copy二叉树 思想： 1）malloc新结点， ​ 2）拷贝左子树，拷贝右子树，让新结点连接左子树，右子树 ​ 3）若左子树还是树，重复步骤1、2；若右子树还是树，重复步骤1、2。 案例4：树的非递归遍历(中序遍历) 中序 遍历的几种情况 分析1： 什么时候访问根、什么时候访问左子树、什么访问右子树 当左子树为空或者左子树已经访问完毕以后，再访问根 访问完毕根以后，再访问右子树。 分析2： 非递归遍历树，访问结点时，为什么是栈，而不是其他模型（比如说是队列）。 先走到的后访问、后走到的先访问，显然是栈结构 分析3：结点所有路径情况 步骤1： 如果结点有左子树，该结点入栈； 如果结点没有左子树，访问该结点； 步骤2： 如果结点有右子树，重复步骤1； 如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1 如果栈为空，表示遍历结束。 注意：入栈的结点表示，本身没有被访问过，同时右子树也没有被访问过。 分析4：有一个一直往左走入栈的操作，中序遍历的起点 作业：自己编写堆栈函数原型，实现中序遍历非递归算法 4.3 二叉树的创建中序和先序创建树 1、根据中序遍历的结果能确定一棵树吗？ 中序遍历：结果为：“12345”，这个“12345”能确定一棵树吗？ 请思考，会有多少种形状。 2、如何才能确定一棵树？ 结论： 通过中序遍历和先序遍历可以确定一个树 ​ 通过中序遍历和后续遍历可以确定一个树 ​ 通过先序遍历和后序遍历确定不了一个树。 单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。 3、根据先序和中序结果画树 算法 1、通过先序遍历找到根结点A，再通过A在中序遍历的位置找出左子树，右子树 2、在A的左子树中，找左子树的根结点（在先序中找），转步骤1 3、在A的右子树中，找右子树的根结点（在先序中找），转步骤1 讲解： 先序遍历结果：ADEBCF 中序遍历结果：DEACFB 练习： 先序遍历结果：ABDHKECFIGJ 中序遍历结果：HKDBEAIFCGJ 4、学习算法可借助工具、动画 #号法创建树 1、什么是 # 号法创建树 # 创建树，让树的每一个节点都变成度数为2的树 先序遍历：124###3## 可以唯一确定一棵树吗，为什么？ 2、# 创建树练习 先序遍历：ABDH#K###E##CFI###G#J## ,请画出树的形状 # 号法画出树关键点： 要清楚的确定左子树什么结束，右子树什么时候开始。 3、# 号法编程实践 利用前序遍历来建树（结点值陆续从键盘输入，用 DLR 为宜） 1234567891011121314151617181920212223242526272829303132Bintree createBTpre( )&#123; Bintree T; char ch; scanf(“%c”,&amp;ch); if(ch==’#’) T=NULL; else &#123; T=( Bintree )malloc(sizeof(BinTNode)); T-&gt;data=ch; T-&gt;lchild=createBTpre(); T-&gt;rchild=createBTpre(); &#125; return T;&#125;//后序遍历销毁一个树void BiTree_Free(BiTNode* T)&#123; BiTNode *tmp = NULL; if (T!= NULL) &#123; if (T-&gt;rchild != NULL) BiTree_Free(T-&gt;rchild); if (T-&gt;lchild != NULL) BiTree_Free(T-&gt;lchild); if (T != NULL) &#123; free(T); T = NULL; &#125; &#125;&#125; 4.4 二叉线索树线索化概念 1、前言 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得。 若可将遍历后对应的有关前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树了。 二叉线索树思想是干什么的？ 中序遍历这棵树===》转换成链表访问 2、线索化思想 结论： 线索化过程就是在遍历过程（假设是中序遍历）中修改空指针的过程： ​ 将空的lchild改为结点的直接前驱； ​ 将空的rchild改为结点的直接后继。 3、线索化思想训练 请将此树线索化。 1）右空指针线索化： 2）左空指针线索化 3）总结 线索化的实现 1）线索化树结点 1234567typedef struct BiThrNode /* 二叉线索存储结点结构 */&#123; char data; /* 结点数据 */ struct BiThrNode *lchild, *rchild; /* 左右孩子指针 */ int LTag; int RTag; /* 左右标志 */&#125; BiThrNode, *BiThrTree; 2）线索化思想分析 线索化的本质：让前后结点，建立关系； 1）两个辅助指针变量形成差值后：后继结点的左孩子指向前驱结点，前驱结点的右孩子指向后继结点。 2）赋值指针变量和业务操作的逻辑关系 4） 二叉树线索化树的遍历 123456789101112131415161718192021/* 中序遍历二叉线索树T(头结点)的非递归算法 */int InOrderTraverse_Thr(BiThrNode* T)&#123; BiThrNode* p; p = T-&gt;lchild; /* p指向根结点 */ while (p != T) &#123; /* 空树或遍历结束时,p==T */ while (p-&gt;LTag == Link) p = p-&gt;lchild; printf(\"%c \", p-&gt;data); while (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) &#123; p = p-&gt;rchild; printf(\"%c \", p-&gt;data); &#125; p=p-&gt;rchild; &#125; return 0;&#125; 4.5 霍夫曼树组建一个网络，耗费最小 WPL最小；这个方法是霍夫曼想出来的，称为霍夫曼树 霍夫曼树的构造 对于文本 ”BADCADFEED” 的传输而言，因为重复出现的只有 ”ABCDEF” 这6个字符，因此可以用下面的方式编码： 接收方可以根据每3个bit进行一次字符解码的方式还原文本信息。 这样的编码方式需要30个bit位才能表示10个字符 那么当传输一篇500个字符的情报时，需要15000个bit位 在战争年代，这种编码方式对于情报的发送和接受是很低效且容易出错的。 如何提高收发效率？ 要提高效率，必然要从编码方式的改进入手，要避免每个字符都占用相同的bit位 准则：任一字符的编码都不是另一个字符编码的前缀！ 也就是说：每一个字符的编码路径，都不包含另外一个字符的路径。 霍夫曼树 1、给定 n 个数值 { v1, v2, …, vn} 2、根据这 n 个数值构造二叉树集合 F F = { T1, T2, …, Tn} Ti 的数据域为 vi，左右子树为空 3、在 F 中选取两棵根结点的值最小的树作为左右子树构造一棵新的二叉树，这棵二叉树的根结点中的值为左右子树根结点中的值之和 4、在 F 中删除这两棵子树，并将构造的新二叉树加入F中 5、重复 3 和 4，直到 F 中只剩下一个树为止。这棵树即霍夫曼树 假设经过统计 ABCDEF 在需要传输的报文中出现的概率如下 霍夫曼树是一种特殊的二叉树 霍夫曼树应用于信息编码和数据压缩领域 霍夫曼树是现代压缩算法的基础 五、 排序5.1 基本概念排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。 排序数学定义： 假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：Kp1≤Kp2≤…≤Kpn 。按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序 排序的稳定性： 如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的；否则称这个排序方法是不稳定的。 多关键字排序： 排序时需要比较的关键字多余一个 排序结果首先按关键字1进行排序 当关键字1相同时按关键字2进行排序 当关键字n-1相同时按关键字n进行排序 对于多关键字排序，只需要在比较操作时同时考虑多个关键字即可！ 排序中的关键操作： 比较 任意两个数据元素通过比较操作确定先后次序 交换 数据元素之间需要交换才能得到预期结果 内排序和外排序： 内排序 整个排序过程不需要访问外存便能完成 外排序 待排序的数据元素数量很大，整个序列的排序过程不可能在内存中完成 排序的审判： 时间性能 关键性能差异体现在比较和交换的数量 辅助存储空间 为完成排序操作需要的额外的存储空间 必要时可以“空间换时间” 算法的实现复杂性 过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能 总结： 排序是数据元素从无序到有序的过程 排序具有稳定性，是选择排序算法的因素之一 比较和交换是排序的基本操作 多关键字排序与单关键字排序无本质区别 排序的时间性能是区分排序算法好坏的主要因素 5.2 选择法基本思想： 每一趟 (例如第 i 趟，i = 0, 1, …,n-2)在后面 n-i个待排的数据元素中选出关键字最小的元素, 作为有序元素序列的第 i 个元素。 排序过程： 首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换 再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第二个记录交换 重复上述操作，共进行n-1趟排序后，排序结束 5.3 插入排序基本思想： 元素1个元素， 排序过程： 整个排序过程为 n-1 趟插入，即先将序列中第 1 个记录看成是一个有序子序列，然后从第 2 个记录开始，逐个进行插入，直至整个序列有序 实质：对线性表执行 n-1 次插入操作，只是先要找到插入位置 V[0], V[1], …, V[i-1] 已经排好序。这时已经排好序。这时,用V[i]的关键字与 V[i-1], V[i-2], …的关键字进行比较, 找到插入位置即将V[i]]插入, 原来位置上的对象向后顺移。 插入排序关键点： 1、拿出一个元素，留出位置 2、符合条件的元素后移 5.4 冒泡排序 5.5 希尔排序排序过程： 先取一个正整数 d1&lt;n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2&lt;d1，重复上述分组和排序操作；直至 di=1，即所有记录放进一个组中排序为止 O(n-1.3) Q(nlogn) 希尔排序是不稳定的。 5.6 快速排序思想： 快速排序是对冒泡排序的一种改进。它的基本思想是： 通过一躺排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，基准数据排在这两个子序列的中间； 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 12345// O(n*logn)不稳定，分组，后面的有可能跑到前面去了。21 100 3 50 1 3 1 21 100 50 1 3 21 50 100 5.7 归并排序注意：一个元素，可以看做有序的，是稳定的算法 对一个数组分成两路，mid中间 设两个有序的子文件(相当于输入堆)放在同一向量中相邻的位置上：R[low..m],R[m+1..high],先将它们合并到一个局部的暂存向量R1(相当于输出堆)中,待合并完成后将R1复制回R[low..high]中。 5.8 排序总结 六、C++ 模板类与数据结构基础C++模板是容器的概念。 理论提高：所有容器提供的都是值（value）语意，而非引用（reference）语意。容器执行插入元素的操作时，内部实施拷贝动作。所以STL容器内存储的元素必须能够被拷贝（必须提供拷贝构造函数）。 加入到容器中的元素，应该可以被加入才行。 模板类设计与实现 链表类_链式存储设计与实现 栈类_链式存储设计与实现 队列类_链式存储设计与实现 链表类_顺序存储设计与实现 栈类_顺序存储设计与实现 队列类_顺序存储设计与实现","categories":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/categories/Program-C/"}],"tags":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/tags/Program-C/"}]},{"title":"Program-C 进阶","slug":"Program-C/program-c-advance","date":"2016-05-24T02:14:50.000Z","updated":"2019-06-10T08:03:35.341Z","comments":true,"path":"2016/05/24/Program-C/program-c-advance/","link":"","permalink":"http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/","excerpt":"C 语言进阶一、 内存分区栈区 由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。","text":"C 语言进阶一、 内存分区栈区 由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。 堆区 由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请。 12345678910111213141516171819#include &lt;stdlib.h&gt;void *calloc(size_t nmemb, size_t size);功能：在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存置0。参数： nmemb：所需内存单元数量 size：每个内存单元的大小（单位：字节）返回值： 成功：分配空间的起始地址 失败：NULL#include &lt;stdlib.h&gt;void *realloc(void *ptr, size_t size);功能：重新分配用malloc或者calloc函数在堆中分配内存空间的大小。realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。参数： ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致 size：为重新分配内存的大小, 单位：字节返回值： 成功：新分配的堆内存地址 失败：NULL 全局/静态区 全局静态区内的变量在编译阶段已经分配好内存空间并初始化。这块内存在程序运行期间一直存在,它主要存储全局变量、静态变量和常量。 注意： 这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。 全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。 字符串常量存储在全局/静态存储区的常量区。 12345678910int v1 = 10;//全局/静态区const int v2 = 20; //常量，一旦初始化，不可修改static int v3 = 20; //全局/静态区char *p1; //全局/静态区，编译器默认初始化为NULL//那么全局static int 和 全局int变量有什么区别？void test()&#123; static int v4 = 20; //全局/静态区&#125; 字符串常量是否可修改？字符串常量优化： ANSI C中规定：修改字符串常量，结果是未定义的。ANSI C并没有规定编译器的实现者对字符串的处理，例如：1. 有些编译器可修改字符串常量，有些编译器则不可修改字符串常量。2. 有些编译器把多个相同的字符串常量看成一个（这种优化可能出现在字符串常量中，节省空间），有些则不进行此优化。如果进行优化，则可能导致修改一个字符串常量导致另外的字符串常量也发生变化，结果不可知。所以尽量不要去修改字符串常量！ C99标准：char p = “abc”; defines p with type ‘‘pointer to char’’ and initializes it to point to an object with type ‘‘array of char’’ with length 4 whose elements are initialized with a character string literal. *If an attempt is made to use p to modify the contents of the array, the behavior is undefined**. 总结 在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等，初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。 数据区包括：堆，栈，全局/静态存储区。 全局/静态存储区包括：常量区，全局区、静态区。 常量区包括：字符串常量区、常变量区。 代码区：存放程序编译后的二进制代码，不可寻址区。 可以说，C/C++内存分区其实只有两个，即代码区和数据区。 函数调用模型： 在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。 栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面： 函数的返回地址； 函数的参数； 临时变量； 保存的上下文：包括在函数调用前后需要保持不变的寄存器。 栈的生长方向和内存存放方向： 二、指针强化指针是一种数据类型，占用内存空间，用来保存内存地址。 2.1 野指针和空指针2.1.1 空指针标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。 对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未执行任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。 不允许向NULL和非法地址拷贝内存： 123456789void test()&#123; char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, \"1111\"); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, \"2222\"); //err &#125; 2.1.2 野指针在使用指针时，要避免野指针的出现： 野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 什么情况下会导致野指针？ 指针变量未初始化 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针释放后未置空 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。 指针操作超越变量作用域 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。 操作野指针是非常危险的操作，应该规避野指针的出现： 初始化时置 NULL 指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置 NULL 当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。 用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。请看下面的例子： 1234567891011#include &lt;stdio.h&gt;int *func()&#123; int n = 100; return &amp;n;&#125;int main()&#123; int *p = func(), n; n = *p; printf(\"value = %d\\n\", n); return 0;&#125; 运行结果： 1value = 100 n 是 func() 内部的局部变量，func() 返回了指向 n 的指针，根据上面的观点，func() 运行结束后 n 将被销毁，使用 *p 应该获取不到 n 的值。但是从运行结果来看，我们的推理好像是错误的，func() 运行结束后 *p 依然可以获取局部变量 n 的值，这个上面的观点不是相悖吗？ 为了进一步看清问题的本质，不妨将上面的代码稍作修改，在第9~10行之间增加一个函数调用，看看会有什么效果： 123456789101112#include &lt;stdio.h&gt;int *func()&#123; int n = 100; return &amp;n;&#125;int main()&#123; int *p = func(), n; printf(\"c.biancheng.net\\n\"); n = *p; printf(\"value = %d\\n\", n); return 0;&#125; 运行结果： 12c.biancheng.netvalue = -2 可以看到，现在 p 指向的数据已经不是原来 n 的值了，它变成了一个毫无意义的甚至有些怪异的值。与前面的代码相比，该段代码仅仅是在 *p 之前增加了一个函数调用，这一细节的不同却导致运行结果有天壤之别，究竟是为什么呢？ 前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。 关于函数调用的原理以及函数如何占用内存的更多细节，我们将在《C语言和内存》专题中深入探讨，相信你必将有所顿悟，解开心中的谜团。 第一个例子在调用其他函数之前使用 *p 抢先获得了 n 的值并将它保存起来，第二个例子显然没有抓住机会，有其他函数被调用后才使用 *p 获取数据，这个时候已经晚了，内存已经被后来的函数覆盖了，而覆盖它的究竟是一份什么样的数据我们无从推断（一般是一个没有意义甚至有些怪异的值）。 总结： 常规程序中，函数返回的指针通常应该是： 指向静态（static）变量； 指向专门申请分配的（如用malloc）空间； 指向常量区（如指向字符串”hello”）； 指向全局变量； 指向程序代码区（如指向函数的指针）。 除这5项以外，其它怪技巧不提倡。 函数内的变量，没有关键字static修饰的变量的生命周期只在本函数内，函数结束后变量自动销毁。当返回为指针的时候需要特别注意，因为函数结束后指针所指向的地址依然存在，但是该地址可以被其他程序修改，里面的内容就不确定了，有可能后面的操作会继续用到这块地址，有可能不会用到，所以会出现时对时错的情况，如果需要返回一个指针而又不出错的话只能调用内存申请函数 2.2 间接访问操作符通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是 *。 注意：对一个int*类型指针解引用会产生一个整型值，类似地，对一个float*指针解引用会产生了一个float类型的值。 在指针声明时，* 号表示所声明的变量为指针 在指针使用时，* 号表示操作指针所指向的内存空间 * 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存 * 放在等号的左边赋值（给内存赋值，写内存） * 放在等号的右边取值（从内存中取值，读内存） 123456789101112131415161718//解引用void test01()&#123; //定义指针 int* p = NULL; //指针指向谁，就把谁的地址赋给指针 int a = 10; p = &amp;a; *p = 20;//*在左边当左值，必须确保内存可写 //*号放右面，从内存中读值 int b = *p; //必须确保内存可写 char* str = \"hello world!\"; *str = 'm'; printf(\"a:%d\\n\", a); printf(\"*p:%d\\n\", *p); printf(\"b:%d\\n\", b);&#125; 2.3 指针的步长指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。 2.4 指针的意义_间接赋值通过指针间接赋值成立的三大条件： 2个变量（一个普通变量一个指针变量、或者一个实参一个形参） 建立关系 通过 * 操作指针指向的内存 123456789void test()&#123; int a = 100; //两个变量 int *p = NULL; //建立关系 //指针指向谁，就把谁的地址赋值给指针 p = &amp;a; //通过*操作内存 *p = 22;&#125; 间接赋值：从1级指针到2级指针： 12345678910111213141516171819202122232425262728void AllocateSpace(char** p)&#123; *p = (char*)malloc(100); strcpy(*p, \"hello world!\");&#125;void FreeSpace(char** p)&#123; if (p == NULL)&#123; return; &#125; if (*p != NULL)&#123; free(*p); *p = NULL; &#125;&#125;void test()&#123; char* p = NULL; AllocateSpace(&amp;p); printf(\"%s\\n\",p); FreeSpace(&amp;p); if (p == NULL)&#123; printf(\"p内存释放!\\n\"); &#125;&#125; 间接赋值的推论： 用 1 级指针形参，去间接修改了 0 级指针(实参)的值。 用 2 级指针形参，去间接修改了 1 级指针(实参)的值。 用 3 级指针形参，去间接修改了 2 级指针(实参)的值。 用 n 级指针形参，去间接修改了 n-1 级指针(实参)的值。 2.5 指针做函数参数指针做函数参数，具备输入和输出特性： 输入：主调函数分配内存 输出：被调用函数分配内存 输入特性： 12345678910111213void fun(char *p /* in */)&#123; //给p指向的内存区域拷贝内容 strcpy(p, \"abcddsgsd\");&#125;void test(void)&#123; //输入，主调函数分配内存 char buf[100] = &#123; 0 &#125;; fun(buf); printf(\"buf = %s\\n\", buf);&#125; 输出特性： 12345678910111213141516171819202122232425void fun(char **p /* out */, int *len)&#123; char *tmp = (char *)malloc(100); if (tmp == NULL) &#123; return; &#125; strcpy(tmp, \"adlsgjldsk\"); //间接赋值 *p = tmp; *len = strlen(tmp);&#125;void test(void)&#123; //输出，被调用函数分配内存，地址传递 char *p = NULL; int len = 0; fun(&amp;p, &amp;len); if (p != NULL) &#123; printf(\"p = %s, len = %d\\n\", p, len); &#125;&#125; 2.6 字符串指针强化字符串是以0或者’\\0’结尾的字符数组，(数字0和字符’\\0’等价) 如果以字符串初始化，那么编译器默认会在字符串尾部添加’\\0’ 1char str3[] = \"hello\"; sizeof 计算数组大小，数组包含’\\0’字符 strlen 计算字符串的长度，到’\\0’结束 字符串拷贝功能实现： 1234567891011121314151617//1）应该判断下传入的参数是否为NULL//2）最好不要直接使用形参int copy_string04(char* dest, char* source)&#123; if (dest == NULL)&#123; return -1; &#125; if (source == NULL)&#123; return -2; &#125; char* src = source; char* tar = dest; while (*tar++ = *src++)&#123;&#125; return 0;&#125; 字符串的格式化： 12345678910#include &lt;stdio.h&gt;int sprintf(char *str, const char *format, ...);功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 '\\0' 为止。参数： str：字符串首地址 format：字符串格式，用法和printf()一样返回值： 成功：实际格式化的字符个数 失败： - 1 1234567891011121314151617181920212223242526272829//1. 格式化字符串char buf[1024] = &#123; 0 &#125;;sprintf(buf, \"你好,%s,欢迎加入我们!\", \"John\");printf(\"buf:%s\\n\",buf);memset(buf, 0, 1024);sprintf(buf, \"我今年%d岁了!\", 20);printf(\"buf:%s\\n\", buf);//2. 拼接字符串memset(buf, 0, 1024);char str1[] = \"hello\";char str2[] = \"world\";int len = sprintf(buf,\"%s %s\",str1,str2);printf(\"buf:%s len:%d\\n\", buf,len);//3. 数字转字符串memset(buf, 0, 1024);int num = 100;sprintf(buf, \"%d\", num);printf(\"buf:%s\\n\", buf);//设置宽度 右对齐memset(buf, 0, 1024);sprintf(buf, \"%8d\", num);printf(\"buf:%s\\n\", buf);//设置宽度 左对齐memset(buf, 0, 1024);sprintf(buf, \"%-8d\", num);printf(\"buf:%s\\n\", buf); 12345678910#include &lt;stdio.h&gt;int sscanf(const char *str, const char *format, ...);功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。参数： str：指定的字符串首地址 format：字符串格式，用法和scanf()一样返回值： 成功：实际读取的字符个数 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//1. 跳过数据void test01()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf(\"123456aaaa\", \"%*d%s\", buf); printf(\"buf:%s\\n\",buf);&#125;//2. 读取指定宽度数据void test02()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 sscanf(\"123456aaaa\", \"%7s\", buf); printf(\"buf:%s\\n\", buf);&#125;//3. 匹配a-z中任意字符void test03()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf(\"abcdefg123456\", \"%[a-z]\", buf); printf(\"buf:%s\\n\", buf);&#125;//4. 匹配aBc中的任何一个void test04()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 sscanf(\"abcdefg123456\", \"%[aBc]\", buf); printf(\"buf:%s\\n\", buf);&#125;//5. 匹配非a的任意字符void test05()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 sscanf(\"bcdefag123456\", \"%[^a]\", buf); printf(\"buf:%s\\n\", buf);&#125;//6. 匹配非a-z中的任意字符void test06()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 sscanf(\"123456ABCDbcdefag\", \"%[^a-z]\", buf); printf(\"buf:%s\\n\", buf);&#125; 2.6.1 一级指针易错点 越界 指针叠加会不断改变指针指向 p++ 返回局部变量地址 123456char *get_str()&#123; char str[] = \"abcdedsgads\"; //栈区， printf(\"[get_str]str = %s\\n\", str); return str;&#125; 同一块内存释放多次 free()函数的功能只是告诉系统 p 指向的内存可以回收了。就是说，p 指向的内存使用权交还给系统。但是，p的值还是原来的值(野指针)，p还是指向原来的内存 2.7 const使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//const修饰变量void test01()&#123; //1. const基本概念 const int i = 0; //i = 100; //错误，只读变量初始化之后不能修改 //2. 定义const变量最好初始化 const int j; //j = 100; //错误，不能再次赋值 //3. c语言的const是一个只读变量，并不是一个常量，可通过指针间接修改 const int k = 10; //k = 100; //错误，不可直接修改，我们可通过指针间接修改 printf(\"k:%d\\n\", k); int* p = &amp;k; *p = 100; printf(\"k:%d\\n\", k);&#125;//const 修饰指针void test02()&#123; int a = 10; int b = 20; //const放在*号左侧 修饰p_a指针指向的内存空间不能修改,但可修改指针的指向 const int* p_a = &amp;a; //*p_a = 100; //不可修改指针指向的内存空间 p_a = &amp;b; //可修改指针的指向 //const放在*号的右侧， 修饰指针的指向不能修改，但是可修改指针指向的内存空间 int* const p_b = &amp;a; //p_b = &amp;b; //不可修改指针的指向 *p_b = 100; //可修改指针指向的内存空间 //指针的指向和指针指向的内存空间都不能修改 const int* const p_c = &amp;a;&#125;//const指针用法struct Person&#123; char name[64]; int id; int age; int score;&#125;;//每次都对对象进行拷贝，效率低，应该用指针void printPersonByValue(struct Person person)&#123; printf(\"Name:%s\\n\", person.name); printf(\"Name:%d\\n\", person.id); printf(\"Name:%d\\n\", person.age); printf(\"Name:%d\\n\", person.score);&#125;//但是用指针会有副作用，可能会不小心修改原数据void printPersonByPointer(const struct Person *person)&#123; printf(\"Name:%s\\n\", person-&gt;name); printf(\"Name:%d\\n\", person-&gt;id); printf(\"Name:%d\\n\", person-&gt;age); printf(\"Name:%d\\n\", person-&gt;score);&#125;void test03()&#123; struct Person p = &#123; \"Obama\", 1101, 23, 87 &#125;; //printPersonByValue(p); printPersonByPointer(&amp;p);&#125; 三、指针的指针(二级指针)123int a = 12;int *b = &amp;a;int **c = &amp;b; 它在内存中的大概模样大致如下： 3.1 二级指针做形参输出特性二级指针做参数的输出特性是指由被调函数分配内存。 1234567891011121314151617181920212223242526272829303132333435363738//被调函数,由参数n确定分配多少个元素内存void allocate_space(int **arr,int n)&#123; //堆上分配n个int类型元素内存 int *temp = (int *)malloc(sizeof(int)* n); if (NULL == temp)&#123; return; &#125; //给内存初始化值 int *pTemp = temp; for (int i = 0; i &lt; n;i ++)&#123; //temp[i] = i + 100; *pTemp = i + 100; pTemp++; &#125; //指针间接赋值 *arr = temp;&#125;//打印数组void print_array(int *arr,int n)&#123; for (int i = 0; i &lt; n;i ++)&#123; printf(\"%d \",arr[i]); &#125; printf(\"\\n\");&#125;//二级指针输出特性(由被调函数分配内存)void test()&#123; int *arr = NULL; int n = 10; //给arr指针间接赋值 allocate_space(&amp;arr,n); //输出arr指向数组的内存 print_array(arr, n); //释放arr所指向内存空间的值 if (arr != NULL)&#123; free(arr); arr = NULL; &#125;&#125; 3.2 二级指针做形参输入特性二级指针做形参输入特性是指由主调函数分配内存。 123456789101112131415161718192021222324252627282930//打印数组void print_array(int **arr,int n)&#123; for (int i = 0; i &lt; n;i ++)&#123; printf(\"%d \",*(arr[i])); &#125; printf(\"\\n\");&#125;//二级指针输入特性(由主调函数分配内存)void test()&#123; int a1 = 10; int a2 = 20; int a3 = 30; int a4 = 40; int a5 = 50; int n = 5; int** arr = (int **)malloc(sizeof(int *) * n); arr[0] = &amp;a1; arr[1] = &amp;a2; arr[2] = &amp;a3; arr[3] = &amp;a4; arr[4] = &amp;a5; print_array(arr,n); free(arr); arr = NULL;&#125; 四、位运算4.1 位逻辑运算符4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(&amp;&amp; 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 按位取反~ 1234unsigned char a = 2; //00000010unsigned char b = ~a; //11111101printf(\"ret = %d\\n\", a); //ret = 2printf(\"ret = %d\\n\", b); //ret = 253 位与（AND）: &amp; 二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 位或（OR）: | 二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. 位异或: 二进制运算符 ^ 对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. 123 (10010011) ^ (00111101)= (10101110) 用法： 打开位 已知：10011010： 将位2打开 flag | 10011010 123 (10011010)| (00000100)= (10011110) 将所有位打开。 flag | ~flag 123 (10011010)| (01100101)= (11111111) 关闭位 flag &amp; ~flag 123 (10011010)&amp; (01100101)= (00000000) 转置位 转置(toggling)一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开。您可以使用位异或运算符来转置。其思想是如果b是一个位(1或0)，那么如果b为1则 b^1 为0，如果b为0，则 1^b 为1。无论b的值是0还是1, 0^b 为b. flag ^ 0xff 123 (10010011)^ (11111111)= (01101100) 交换两个数不需要临时变量 123456789101112131415161718192021222324//a ^ b = temp;//a ^ temp = b;//b ^ temp = a (10010011)^ (00100110)= (10110101) (10110101)^ (00100110) 10010011#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int a = 2, b = 6; a = a ^ b; b = b ^ a; a = a ^ b; printf(\"a = %d b = %d/n\", a, b); return 0;&#125; 4.2 移位运算符 左移 &lt;&lt; 左移运算符 &lt;&lt; 将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 左移一位相当于原值 *2. 1234567(10001010) &lt;&lt; 2(00101000) 1 &lt;&lt; 1 = 2;2 &lt;&lt; 1 = 4;4 &lt;&lt; 1 = 8;8 &lt;&lt; 2 = 32 右移 &gt;&gt; 右移运算符 &gt;&gt; 将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 12345678910//有符号值(10001010) &gt;&gt; 2(00100010) //在某些系统上的结果值(10001010) &gt;&gt; 2(11100010) //在另一些系统上的解雇//无符号值(10001010) &gt;&gt; 2(00100010) //所有系统上的结果值 用法：移位运算符： 移位运算符能够提供快捷、高效（依赖于硬件）对2的幂的乘法和除法。 number &lt;&lt; n number乘以2的n次幂 number &gt;&gt; n 如果number非负，则用number除以2的n次幂 五、多维数组5.1 一维数组 元素类型角度：数组是相同类型的变量的有序集合 内存角度：连续的一大片内存空间 请问：指针和数组是等价的吗？ 答案是否定的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下： 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。 当数组名作为&amp;操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。 12345int arr[10];//arr = NULL; //arr作为指针常量，不可修改int *p = arr; //此时arr作为指针常量来使用printf(\"sizeof(arr):%d\\n\", sizeof(arr)); //此时sizeof结果为整个数组的长度printf(\"&amp;arr type is %s\\n\", typeid(&amp;arr).name()); //int(*)[10]而不是int* 下标引用： 1int arr[] = &#123; 1, 2, 3, 4, 5, 6 &#125;; *(arr + 3) ,这个表达式是什么意思呢？ 首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的： 12*(arr + 3)arr[3] 问题 1：数组下标可否为负值？ 问题 2：请阅读如下代码，说出结果： 1234int arr[] = &#123; 5, 3, 6, 8, 2, 9 &#125;;int *p = arr + 2;printf(\"*p = %d\\n\", *p); // 6printf(\"*p = %d\\n\", p[-1]); // 3 5.1.1 数组和指针指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明 12int a[10];int *b; 声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。 因此，表达式 *a 是完全合法的，但是表达式 *b 却是非法的。*b 将访问内存中一个不确定的位置，将会导致程序终止。另一方面 b++ 可以通过编译，a++ 却不行，因为 a 是一个常量值。 5.1.2 作为函数参数的数组名当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的： 12int print_array(int *arr);int print_array(int arr[]); 我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。同样sizeof arr值是指针的长度，而不是数组的长度。 现在我们清楚了，为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数。 5.2 多维数组数组名： 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： 1int arr[3][10] 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 指向数组的指针(数组指针)： 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：int array[5] 的类型为 int[5]；C语言可通过typedef定义一个数组类型： 定义数组指针有一下三种方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方式一void test01()&#123; //先定义数组类型，再用数组类型定义数组指针 int arr[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = &amp;arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i &lt; 10;i++)&#123; printf(\"%d \",(*pArr)[i]); &#125; printf(\"\\n\");&#125;//方式二void test02()&#123; int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = &amp;arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i &lt; 10; i++)&#123; (*pArr)[i] = i + 1; &#125; for (int i = 0; i &lt; 10; i++)&#123; printf(\"%d \", (*pArr)[i]); &#125; printf(\"\\n\");&#125;//方式三void test03()&#123; int arr[10]; int(*pArr)[10] = &amp;arr; for (int i = 0; i &lt; 10; i++)&#123; (*pArr)[i] = i + 1; &#125; for (int i = 0; i &lt; 10; i++)&#123; printf(\"%d \", (*pArr)[i]); &#125; printf(\"\\n\");&#125; 5.2.1 指针数组(元素为指针)栈区指针数组： 123456789101112131415161718192021222324252627282930313233343536//数组做函数函数，退化为指针void array_sort(char** arr,int len)&#123; for (int i = 0; i &lt; len; i++)&#123; for (int j = len - 1; j &gt; i; j --)&#123; //比较两个字符串 if (strcmp(arr[j-1],arr[j]) &gt; 0)&#123; char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125;&#125;//打印数组void array_print(char** arr,int len)&#123; for (int i = 0; i &lt; len;i++)&#123; printf(\"%s\\n\",arr[i]); &#125; printf(\"----------------------\\n\");&#125;void test()&#123; //主调函数分配内存 //指针数组 char* p[] = &#123; \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"&#125;; //char** p = &#123; \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" &#125;; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len);&#125; 堆区指针数组： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//分配内存char** allocate_memory(int n)&#123; if (n &lt; 0 )&#123; return NULL; &#125; char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL)&#123; return NULL; &#125; //分别给每一个指针malloc分配内存 for (int i = 0; i &lt; n; i ++)&#123; temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); &#125; return temp;&#125;//打印数组void array_print(char** arr,int len)&#123; for (int i = 0; i &lt; len;i++)&#123; printf(\"%s\\n\",arr[i]); &#125; printf(\"----------------------\\n\");&#125;//释放内存void free_memory(char** buf,int len)&#123; if (buf == NULL)&#123; return; &#125; for (int i = 0; i &lt; len; i ++)&#123; free(buf[i]); buf[i] = NULL; &#125; free(buf);&#125;void test()&#123; int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n);&#125; 二维数组的线性存储特性式： 1234567891011121314151617181920212223242526272829void PrintArray(int* arr, int len)&#123; for (int i = 0; i &lt; len; i++)&#123; printf(\"%d \", arr[i]); &#125; printf(\"\\n\");&#125;//二维数组的线性存储void test()&#123; int arr[][3] = &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;; int arr2[][3] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i &lt; len; i++)&#123; printf(\"%d \", p[i]); &#125; printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len);&#125; 二维数组的3种形式参数： 1234567891011121314151617181920212223242526272829303132333435363738//二维数组的第一种形式void PrintArray01(int arr[3][3])&#123; for (int i = 0; i &lt; 3; i++)&#123; for (int j = 0; j &lt; 3; j++)&#123; printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); &#125; &#125;&#125;//二维数组的第二种形式void PrintArray02(int arr[][3])&#123; for (int i = 0; i &lt; 3; i++)&#123; for (int j = 0; j &lt; 3; j++)&#123; printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); &#125; &#125;&#125;//二维数组的第二种形式void PrintArray03(int(*arr)[3])&#123; for (int i = 0; i &lt; 3; i++)&#123; for (int j = 0; j &lt; 3; j++)&#123; printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); &#125; &#125;&#125;void test()&#123; int arr[][3] = &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr);&#125; 5.3 总结编程提示： 源代码的可读性几乎总是比程序的运行时效率更为重要 只要有可能，函数的指针形参都应该声明为const 在多维数组的初始值列表中使用完整的多层花括号提供可读性 内容总结： 在绝大多数表达式中，数组名的值是指向数组第1个元素的指针。这个规则只有两个例外，sizeof和对数组名&amp;。 指针和数组并不相等。当我们声明一个数组的时候，同时也分配了内存。但是声明指针的时候，只分配容纳指针本身的空间。 当数组名作为函数参数时，实际传递给函数的是一个指向数组第1个元素的指针。 我们不单可以创建指向普通变量的指针，也可创建指向数组的指针。 六、结构体6.1 结构体基础知识结构体类型的定义 123456789struct Person&#123; char name[64]; int age;&#125;;typedef struct _PERSON&#123; char name[64]; int age;&#125;Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 结构体变量的定义 1234567891011struct Person&#123; char name[64]; int age;&#125;p1; //定义类型同时定义变量struct&#123; char name[64]; int age;&#125;p2; //定义类型同时定义变量struct Person p3; //通过类型直接定义 结构体成员的使用 12345678910111213141516171819struct Person&#123; char name[64]; int age;&#125;;void test()&#123; //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-&gt;name, \"Obama\"); p2-&gt;age = 33; //如果是指针变量，通过-&gt;操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-&gt;name, p2-&gt;age);&#125; 深拷贝和浅拷贝 1234567891011121314151617181920212223242526//一个老师有N个学生typedef struct _TEACHER&#123; char* name;&#125;Teacher;void test()&#123; Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL)&#123; free(t1.name); t1.name = NULL; &#125; if (t2.name != NULL)&#123; free(t2.name); t1.name = NULL; &#125;&#125; 结构体数组 1234567891011121314151617181920212223242526272829303132struct Person&#123; char name[64]; int age;&#125;;void test()&#123; //在栈上分配空间 struct Person p1[3] = &#123; &#123; \"John\", 30 &#125;, &#123; \"Obama\", 33 &#125;, &#123; \"Edward\", 25&#125; &#125;; struct Person p2[3] = &#123; \"John\", 30, \"Obama\", 33, \"Edward\", 25 &#125;; for (int i = 0; i &lt; 3;i ++)&#123; printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); &#125; printf(\"-----------------\\n\"); for (int i = 0; i &lt; 3; i++)&#123; printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); &#125; printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i &lt; 3;i++)&#123; sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; &#125; for (int i = 0; i &lt; 3; i++)&#123; printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); &#125;&#125; 6.2 结构体嵌套指针结构体嵌套一级指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Person&#123; char* name; int age;&#125;;void allocate_memory(struct Person** person)&#123; if (person == NULL)&#123; return; &#125; struct Person* temp = (struct Person*)malloc(sizeof(struct Person)); if (temp == NULL)&#123; return; &#125; //给name指针分配内存 temp-&gt;name = (char*)malloc(sizeof(char)* 64); strcpy(temp-&gt;name, \"John\"); temp-&gt;age = 100; *person = temp;&#125;void print_person(struct Person* person)&#123; printf(\"Name:%s Age:%d\\n\",person-&gt;name,person-&gt;age);&#125;void free_memory(struct Person** person)&#123; if (person == NULL)&#123; return; &#125; struct Person* temp = *person; if (temp-&gt;name != NULL)&#123; free(temp-&gt;name); temp-&gt;name = NULL; &#125; free(temp);&#125;void test()&#123; struct Person *p = NULL; allocate_memory(&amp;p); print_person(p); free_memory(&amp;p);&#125; 结构体嵌套二级指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//一个老师有N个学生typedef struct _TEACHER&#123; char name[64]; char** students;&#125;Teacher;void create_teacher(Teacher** teacher,int n,int m)&#123; if (teacher == NULL)&#123; return; &#125; //创建老师数组 Teacher* teachers = (Teacher*)malloc(sizeof(Teacher)* n); if (teachers == NULL)&#123; return; &#125; //给每一个老师分配学生 int num = 0; for (int i = 0; i &lt; n; i ++)&#123; sprintf(teachers[i].name, \"老师_%d\", i + 1); teachers[i].students = (char**)malloc(sizeof(char*) * m); for (int j = 0; j &lt; m;j++)&#123; teachers[i].students[j] = malloc(64); sprintf(teachers[i].students[j], \"学生_%d\", num + 1); num++; &#125; &#125; *teacher = teachers; &#125;void print_teacher(Teacher* teacher,int n,int m)&#123; for (int i = 0; i &lt; n; i ++)&#123; printf(\"%s:\\n\", teacher[i].name); for (int j = 0; j &lt; m;j++)&#123; printf(\" %s\",teacher[i].students[j]); &#125; printf(\"\\n\"); &#125;&#125;void free_memory(Teacher** teacher,int n,int m)&#123; if (teacher == NULL)&#123; return; &#125; Teacher* temp = *teacher; for (int i = 0; i &lt; n; i ++)&#123; for (int j = 0; j &lt; m;j ++)&#123; free(temp[i].students[j]); temp[i].students[j] = NULL; &#125; free(temp[i].students); temp[i].students = NULL; &#125; free(temp);&#125;void test()&#123; Teacher* p = NULL; create_teacher(&amp;p,2,3); print_teacher(p, 2, 3); free_memory(&amp;p,2,3);&#125; 6.3 结构体成员偏移量123456789101112131415161718192021//一旦结构体定义下来，则结构体中的成员内存布局就定下了typedef struct Teacher &#123; char a; int b; int c; &#125; Teacher;void test()&#123; Teacher t1; Teacher*p = NULL; p = &amp;t1; int offsize1 = (int)&amp;(p-&gt;b) - (int)p; //age 相对于结构体 Teacher的偏移量 int offsize2 = (int)&amp;(((Teacher *)0)-&gt;b);//绝对0地址 age的偏移量 int offsize3 = offsetof(Teacher, b); printf(\"offsize1:%d \\n\", offsize1); printf(\"offsize2:%d \\n\", offsize2); printf(\"offsize3:%d \\n\", offsize3);&#125; 6.4 结构体字节对齐在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。 从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是内存对齐。 6.4.1 内存对齐原因我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等 内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)。如果没有对齐，为了访问一个变量可能产生二次访问。 为什么要简单内存对齐？ 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量。 某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。 6.4.2 如何内存对齐 对于标准数据类型，它的地址只要是它的长度的整数倍。 对于非标准数据类型，比如结构体，要遵循一下对齐原则： 数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为min（当前成员的大小，#pargama pack(n)）整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。 结构体总的大小，也就是sizeof的结果，必须是min（结构体内部最大成员，#pargama pack(n)）的整数倍，不足要补齐。 结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。 手动设置对齐模数: #pragma pack(show) 显示当前packing alignment的字节数，以warning message的形式被显示。 #pragma pack(push) 将当前指定的packing alignment数组进行压栈操作，这里的栈是the internal compiler stack,同事设置当前的packing alignment为n；如果n没有指定，则将当前的packing alignment数组压栈。 #pragma pack(pop) 从internal compiler stack中删除最顶端的reaord; 如果没有指定n,则当前栈顶record即为新的packing alignement数值；如果指定了n，则n成为新的packing alignment值 #pragma pack(n) 指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 内存对齐案例 123456789101112131415161718192021222324252627282930#pragma pack(4)typedef struct _STUDENT&#123; int a; char b; double c; float d;&#125;Student;typedef struct _STUDENT2&#123; char a; Student b; double c;&#125;Student2;void test01()&#123; //Student //a从偏移量0位置开始存储 //b从4位置开始存储 //c从8位置开始存储 //d从12位置开存储 //所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24 printf(\"sizeof Student:%d\\n\",sizeof(Student)); //Student2 //a从偏移量为0位置开始 8 //b从偏移量为Student内部最大成员整数倍开始，也就是8开始 24 //c从8的整数倍地方开始,也就是32开始 //所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40 printf(\"sizeof Student2:%d\\n\", sizeof(Student2));&#125; 七、文件操作文件在今天的计算机系统中作用是很重要的。文件用来存放程序、文档、数据、表格、图片和其他很多种类的信息。作为一名程序员，您必须编程来创建、写入和读取文件。编写程序从文件读取信息或者将结果写入文件是一种经常性的需求。C提供了强大的和文件进行通信的方法。使用这种方法我们可以在程序中打开文件，然后使用专门的I/O函数读取文件或者写入文件。 文件的概念 一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。 流的概念 流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。 C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。 文本流 文本流，也就是我们常说的以文本模式读取文件。文本流的有些特性在不同的系统中可能不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只使用一个换行符结尾。 标准C把文本定义为零个或者多个字符，后面跟一个表示结束的换行符(\\n).对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式和内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形势而操纵文本的能力简化了可移植程序的创建。 二进制流 二进制流中的字节将完全根据程序编写它们的形式写入到文件中，而且完全根据它们从文件或设备读取的形式读入到程序中。它们并未做任何改变。这种类型的流适用于非文本数据，但是如果你不希望I/O函数修改文本文件的行末字符，也可以把它们用于文本文件。 c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。 我们程序中，经常看到的文本方式打开文件和二进制方式打开文件仅仅体现在换行符的处理上。 比如说，在widows下，文件的换行符是 \\r\\n，而在Linux下换行符则是 \\n. 当对文件使用文本方式打开的时候，读写的windows文件中的换行符\\r\\n会被替换成\\n读到内存中，当在windows下写入文件的时候，\\n被替换成\\r\\n再写入文件。如果使用二进制方式打开文件，则不进行\\r\\n和\\n之间的转换。 那么由于Linux下的换行符就是\\n, 所以文本文件方式和二进制方式无区别。 7.1 文件的操作文件流总览 标准库函数是的我们在C程序中执行与文件相关的I/O任务非常方便。下面是关于文件I/O的一般概况。 程序为同时处于活动状态的每个文件声明一个指针变量，其类型为 FILE*。这个指针指向这个FILE结构，当它处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式(读、写、或者读写)。Fopen和操作系统验证文件或者设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放FILE结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 输入/输出函数家族 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 7.2 文件打开关闭文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 12345678FILE * fopen(const char * filename, const char * mode);功能：打开文件参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab” 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 12345678910111213141516void test()&#123; FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 &#123; //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; &#125;&#125; 注意：应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 1234567int fclose(FILE * stream);功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。参数： stream：文件指针返回值： 成功：0 失败：-1 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 文件读写函数回顾 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() 块读写函数回顾 123456789101112131415161718192021size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);功能：以数据块的方式给文件写入内容参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针返回值： 成功：实际成功写入文件数据的块数，此值和nmemb相等 失败：0size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);功能：以数据块的方式从文件中读取内容参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 格式化读写函数回顾 1234567891011121314151617int fprintf(FILE * stream, const char * format, ...);功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样返回值： 成功：实际写入文件的字符个数 失败：-1int fscanf(FILE * stream, const char * format, ...);功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样返回值： 成功：实际从文件中读取的字符个数 失败： - 1 注意：fscanf遇到空格和换行时结束。 7.3 读写配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122struct info&#123; char key[64]; char val[128];&#125;;struct config&#123; FILE *fp; //保存文件指针 struct info *list; //保存配置信息 int lines; //配置信息条数&#125;;//加载配置文件int load_file(char *path, struct config **myconfig)&#123; if (NULL == path)&#123; return -1; &#125; //以读写的方式打开文件 FILE *fp = fopen(path, \"r+\"); if (NULL ==fp)&#123; printf(\"文件打开失败!\\n\"); return -2; &#125; //配置文件信息分配内存 struct config *conf = (struct config *)malloc(sizeof(struct config)); conf-&gt;fp = fp; conf-&gt;list = NULL; //指针的间接赋值 *myconfig = conf; return 0;&#125;//统计文件行数int count_file(struct config *config)&#123; if (NULL == config)&#123; return -1; &#125; char buf[1024] = &#123; 0 &#125;; int lines = 0; while (fgets(buf, 1024, config-&gt;fp))&#123; //如果是注释则不统计 if (buf[0] == '#')&#123; continue; &#125; lines++; &#125; //将文件指针重置到开始位置 fseek(config-&gt;fp,0, SEEK_SET); return lines;&#125;//解析配置文件int parse_file(struct config *config)&#123; if (NULL == config)&#123; return -1; &#125; //获得配置文件行数 config-&gt;lines = count_file(config); //给每一行配置信息分配内存 config-&gt;list = (struct info *)malloc(sizeof(struct info) * config-&gt;lines); int index = 0; char buf[1024] = &#123; 0 &#125;; while (fgets(buf, 1024, config-&gt;fp))&#123; //去除每一行最后的\\n字符 buf[strlen(buf) - 1] = '\\0'; //如果是注释则不显示 if (buf[0] == '#')&#123; continue; &#125; memset(config-&gt;list[index].key, 0, 64); memset(config-&gt;list[index].val, 0, 128); char *delimit = strchr(buf, ':'); strncpy(config-&gt;list[index].key, buf, delimit - buf); strncpy(config-&gt;list[index].val, delimit + 1, strlen(delimit + 1)); memset(buf, 0 , 1024); index++; &#125; return 0;&#125;const char *get_file(struct config *config, char *key)&#123; if (NULL == config)&#123; return NULL; &#125; if (NULL == key)&#123; return NULL; &#125; for (int i = 0; i &lt; config-&gt;lines;i ++)&#123; if (strcmp(config-&gt;list[i].key,key) == 0)&#123; return config-&gt;list[i].val; &#125; &#125; return NULL;&#125;void destroy_file(struct config *config)&#123; if (NULL == config)&#123; return; &#125; //关闭文件指针 fclose(config-&gt;fp); config-&gt;fp = NULL; //释放配置信息 free(config-&gt;list); config-&gt;list = NULL; free(config);&#125;void test()&#123; char *path = \"./my.ini\"; struct config *conf = NULL; load_file(path, &amp;conf); parse_file(conf); printf(\"%s\\n\", get_file(conf, \"username\")); printf(\"%s\\n\", get_file(conf, \"password\")); printf(\"%s\\n\", get_file(conf, \"server_ip\")); printf(\"%s\\n\", get_file(conf, \"server_port\")); printf(\"%s\\n\", get_file(conf, \"aaaa\")); destroy_file(conf);&#125; 八、链表8.1 链表基本概念 链表是一种常用的数据结构，它通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的动态性（非顺序存储）。 数据域用来存储数据，指针域用于建立与下一个结点的联系。 建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。 链表的开销，主要是访问顺序性和组织链的空间损失。 数组和链表的区别： 数组：一次性分配一块连续的存储区域。 优点：随机访问元素效率高 缺点： 需要分配一块连续的存储区域（很大区域，有可能分配失败） 删除和插入某个元素效率低 链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。 优点： 不需要一块连续的存储区域 删除和插入某个元素效率高 缺点：随机访问元素效率低 8.1.1 有关结构体的自身引用问题1：请问结构体可以嵌套本类型的结构体变量吗？ 问题2：请问结构体可以嵌套本类型的结构体指针变量吗？ 123456789101112typedef struct _STUDENT&#123; char name[64]; int age;&#125;Student;typedef struct _TEACHER&#123; char name[64]; Student stu; //结构体可以嵌套其他类型的结构体 //Teacher stu; //struct _TEACHER teacher; //此时Teacher类型的成员还没有确定，编译器无法分配内存 struct _TEACHER* teacher; //不论什么类型的指针，都只占4个字节，编译器可确定内存分配&#125;Teacher; 结构体可以嵌套另外一个结构体的任何类型变量; 结构体嵌套本结构体普通变量（不可以）。本结构体的类型大小无法确定，类型本质：固定大小内存块别名; 结构体嵌套本结构体指针变量（可以）, 指针变量的空间能确定，32位， 4字节， 64位， 8字节; 8.1.2 链表节点大家思考一下，我们说链表是由一系列的节点组成，那么如何表示一个包含了数据域和指针域的节点呢？ 链表的节点类型实际上是结构体变量，此结构体包含数据域和指针域： 数据域用来存储数据； 指针域用于建立与下一个结点的联系，当此节点为尾节点时，指针域的值为NULL； 123456789typedef struct Node &#123; //数据域 int id; char name[50]; //指针域 struct Node *next; &#125;Node; 8.1.3 链表的分类链表分为： 静态链表 动态链表 静态链表和动态链表是线性表链式存储结构的两种不同的表示方式： 所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表称为“静态链表”。 所谓动态链表，是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。 静态链表 123456789101112131415161718192021222324typedef struct Stu &#123; int id; //数据域 char name[100]; struct Stu *next; //指针域&#125;Stu;void test() &#123; //初始化三个结构体变量 Stu s1 = &#123; 1, \"yuri\", NULL &#125;; Stu s2 = &#123; 2, \"lily\", NULL &#125;; Stu s3 = &#123; 3, \"lilei\", NULL &#125;; s1.next = &amp;s2; //s1的next指针指向s2 s2.next = &amp;s3; s3.next = NULL; //尾结点 Stu *p = &amp;s1; while (p != NULL) &#123; printf(\"id = %d, name = %s\\n\", p-&gt;id, p-&gt;name); //结点往后移动一位 p = p-&gt;next; &#125;&#125; 动态链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef struct Stu &#123; int id; //数据域 char name[100]; struct Stu *next; //指针域&#125;Stu;void test() &#123; //动态分配3个节点 Stu *s1 = (Stu *)malloc(sizeof(Stu)); s1-&gt;id = 1; strcpy(s1-&gt;name, \"yuri\"); Stu *s2 = (Stu *)malloc(sizeof(Stu)); s2-&gt;id = 2; strcpy(s2-&gt;name, \"lily\"); Stu *s3 = (Stu *)malloc(sizeof(Stu)); s3-&gt;id = 3; strcpy(s3-&gt;name, \"lilei\"); //建立节点的关系 s1-&gt;next = s2; //s1的next指针指向s2 s2-&gt;next = s3; s3-&gt;next = NULL; //尾结点 //遍历节点 Stu *p = s1; while (p != NULL)&#123; printf(\"id = %d, name = %s\\n\", p-&gt;id, p-&gt;name); //结点往后移动一位 p = p-&gt;next; &#125; //释放节点空间 p = s1; Stu *tmp = NULL; while (p != NULL) &#123; tmp = p; p = p-&gt;next; free(tmp); tmp = NULL; &#125;&#125; 带头和不带头链表 带头链表：固定一个节点作为头结点(数据域不保存有效数据)，起一个标志位的作用，以后不管链表节点如何改变，此头结点固定不变。 不带头链表：头结点不固定，根据实际需要变换头结点(如在原来头结点前插入新节点，然后，新节点重新作为链表的头结点)。 单向链表、双向链表、循环链表 单向链表： 双向链表： 循环链表： 8.2 链表基本操作8.2.1 创建链表使用结构体定义节点类型： 12345typedef struct _LINKNODE&#123; int id; //数据域 struct _LINKNODE *next; //指针域&#125;link_node; 编写函数：link_node* init_linklist() 建立带有头结点的单向链表，循环创建结点，结点数据域中的数值从键盘输入，以 -1 作为输入结束标志，链表的头结点地址由函数值返回. 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct _LINKNODE&#123; int data; struct _LINKNODE *next;&#125;link_node;link_node *init_linklist()&#123; //创建头结点指针 link_node* head = NULL; //给头结点分配内存 head = (link_node*)malloc(sizeof(link_node)); if (head == NULL)&#123; return NULL; &#125; head-&gt;data = -1; head-&gt;next = NULL; //保存当前节点 link_node* p_current = head; int data = -1; //循环向链表中插入节点 while (1)&#123; printf(\"please input data:\\n\"); scanf(\"%d\",&amp;data); //如果输入-1，则退出循环 if (data == -1)&#123; break; &#125; //给新节点分配内存 link_node* newnode = (link_node*)malloc(sizeof(link_node)); if (newnode == NULL)&#123; break; &#125; //给节点赋值 newnode-&gt;data = data; newnode-&gt;next = NULL; //新节点入链表，也就是将节点插入到最后一个节点的下一个位置 p_current-&gt;next = newnode; //更新辅助指针p_current p_current = newnode; &#125; return head;&#125; 8.2.2 遍历链表编写函数：void foreach_linklist(link_node* head) 顺序输出单向链表各项结点数据域中的内容： 12345678910111213//遍历链表void foreach_linklist(link_node* head)&#123; if (head == NULL)&#123; return; &#125; //赋值指针变量 link_node* p_current = head-&gt;next; while (p_current != NULL)&#123; printf(\"%d \",p_current-&gt;data); p_current = p_current-&gt;next; &#125; printf(\"\\n\");&#125; 8.2.3 插入节点编写函数: void insert_linklist(link_node* head,int val,int data). 在指定值后面插入数据data,如果值val不存在，则在尾部插入。 1234567891011121314151617181920212223242526272829//在值val前插入节点void insert_linklist(link_node* head, int val, int data)&#123; if (head == NULL)&#123; return; &#125; //两个辅助指针 link_node* p_prev = head; link_node* p_current = p_prev-&gt;next; while (p_current != NULL)&#123; if (p_current-&gt;data == val)&#123; break; &#125; p_prev = p_current; p_current = p_prev-&gt;next; &#125; //如果p_current为NULL，说明不存在值为val的节点 if (p_current == NULL)&#123; printf(\"不存在值为%d的节点!\\n\",val); return; &#125; //创建新的节点 link_node* newnode = (link_node*)malloc(sizeof(link_node)); newnode-&gt;data = data; newnode-&gt;next = NULL; //新节点入链表 newnode-&gt;next = p_current; p_prev-&gt;next = newnode;&#125; 8.2.4 删除节点编写函数: void remove_linklist(link_node* head,int val) 删除第一个值为val的结点. 12345678910111213141516171819202122232425262728//删除值为val的节点void remove_linklist(link_node* head,int val)&#123; if (head == NULL)&#123; return; &#125; //辅助指针 link_node* p_prev = head; link_node* p_current = p_prev-&gt;next; //查找值为val的节点 while (p_current != NULL)&#123; if (p_current-&gt;data == val)&#123; break; &#125; p_prev = p_current; p_current = p_prev-&gt;next; &#125; //如果p_current为NULL，表示没有找到 if (p_current == NULL)&#123; return; &#125; //删除当前节点： 重新建立待删除节点(p_current)的前驱后继节点关系 p_prev-&gt;next = p_current-&gt;next; //释放待删除节点的内存 free(p_current);&#125; 8.2.5 销毁链表编写函数: void destroy_linklist(link_node* head) 销毁链表，释放所有节点的空间. 1234567891011121314//销毁链表void destroy_linklist(link_node* head)&#123; if (head == NULL)&#123; return; &#125; //赋值指针 link_node* p_current = head; while (p_current != NULL)&#123; //缓存当前节点下一个节点 link_node* p_next = p_current-&gt;next; free(p_current); p_current = p_next; &#125;&#125; 九、函数指针9.1 函数类型通过什么来区分两个不同的函数？ 一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，函数名代表函数的入口地址。 函数三要素： 名称、参数、返回值。C语言中的函数有自己特定的类型。 c 语言中通过 typedef 为函数类型重命名： 12typedef int f(int, int); // f 为函数类型typedef void p(int); // p 为函数类型 这一点和数组一样，因此我们可以用一个指针变量来存放这个入口地址，然后通过该指针变量调用函数。 注意：通过函数类型定义的变量是不能够直接执行，因为没有函数体。只能通过类型定义一个函数指针指向某一个具体函数，才能调用。 123456789101112typedef int(p)(int, int);void my_func(int a,int b)&#123; printf(\"%d %d\\n\",a,b);&#125;void test()&#123; p p1; //p1(10,20); //错误，不能直接调用，只描述了函数类型，但是并没有定义函数体，没有函数体无法调用 p* p2 = my_func; p2(10,20); //正确，指向有函数体的函数入口地址&#125; 9.2 函数指针(指向函数的指针) 函数指针定义方式(先定义函数类型，根据类型定义指针变量); 先定义函数指针类型，根据类型定义指针变量; 直接定义函数指针变量; 123456789101112131415161718192021222324252627282930int my_func(int a,int b)&#123; printf(\"ret:%d\\n\", a + b); return 0;&#125;//1. 先定义函数类型，通过类型定义指针void test01()&#123; typedef int(FUNC_TYPE)(int, int); FUNC_TYPE* f = my_func; //如何调用？ (*f)(10, 20); f(10, 20);&#125;//2. 定义函数指针类型void test02()&#123; typedef int(*FUNC_POINTER)(int, int); FUNC_POINTER f = my_func; //如何调用？ (*f)(10, 20); f(10, 20);&#125;//3. 直接定义函数指针变量void test03()&#123; int(*f)(int, int) = my_func; //如何调用？ (*f)(10, 20); f(10, 20);&#125; 9.3 函数指针数组函数指针数组，每个元素都是函数指针。 1234567891011121314151617181920212223242526void func01(int a)&#123; printf(\"func01:%d\\n\",a);&#125;void func02(int a)&#123; printf(\"func02:%d\\n\", a);&#125;void func03(int a)&#123; printf(\"func03:%d\\n\", a);&#125;void test()&#123;#if 0 //定义函数指针 void(*func_array[])(int) = &#123; func01, func02, func03 &#125;;#else void(*func_array[3])(int); func_array[0] = func01; func_array[1] = func02; func_array[2] = func03;#endif for (int i = 0; i &lt; 3; i ++)&#123; func_array[i](10 + i); (*func_array[i])(10 + i); &#125;&#125; 9.4 函数指针做函数参数(回调函数)函数参数除了是普通变量，还可以是函数指针变量。 1234//形参为普通变量void fun( int x )&#123;&#125;//形参为函数指针变量void fun( int(*p)(int a) )&#123;&#125; 函数指针变量常见的用途之一是把指针作为参数传递到其他函数，指向函数的指针也可以作为参数，以实现函数地址的传递。 123456789101112131415161718192021//加法计算器int plus(int a,int b)&#123; return a + b;&#125;//减法计算器int minus(int a,int b)&#123; return a - b;&#125;//计算器#if 0int caculator(int a,int b,int(*func)(int,int))&#123; return func(a, b);&#125;#elsetypedef int(*FUNC_POINTER)(int, int);int caculator(int a, int b, FUNC_POINTER func)&#123; return func(a, b);&#125;#endif 注意：函数指针和指针函数的区别： 函数指针是指向函数的指针； 指针函数是返回类型为指针的函数； 十、预处理10.1 预处理的基本概念C 语言对源程序处理的四个步骤：预处理、编译、汇编、链接。 预处理是在程序源代码被编译之前，由预处理器（Preprocessor）对程序源代码进行的处理。这个过程并不对程序的源代码语法进行解析，但它会把源代码分割或处理成为特定的符号为下一步的编译做准备工作。 10.2 文件包含指令(#include)“文件包含处理”是指一个源文件可以将另外一个文件的全部内容包含进来。Ｃ语言提供了 #include 命令用来实现“文件包含”的操作。 #incude&lt;&gt; 和 #include”” 区别 “” 表示系统先在 file1.c 所在的当前目录找 file1.h，如果找不到，再按系统指定的目录检索。 &lt; &gt; 表示系统直接按系统指定的目录检索。 注意： ​ 1. #include &lt;&gt; 常用于包含库函数的头文件； ​ 2. #include “” 常用于包含自定义的头文件； ​ 3. 理论上 #include 可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含； 10.3 宏定义10.3.1 无参数的宏定义(宏常量)如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为： const int num = 100; 但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用： #define num 100 在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。宏定义，只在宏定义的文件中起作用。 123456#define PI 3.1415void test()&#123; double r = 10.0; double s = PI * r * r; printf(\"s = %lf\\n\", s);&#125; 说明： 1)宏名一般用大写，以便于与变量区别； 2) 宏定义可以是常数、表达式等； 3) 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错； 4) 宏定义不是C语言，不在行末加分号； 5) 宏名有效范围为从定义到本源文件结束； 6) 可以用#undef命令终止宏定义的作用域； 7) 在宏定义中，可以引用已定义的宏名； 10.3.2 带参数的宏定义(宏函数)在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。 宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来。 1234567#define SUM(x,y) ((x)+(y))void test()&#123; //仅仅只是做文本替换 下例替换为 int ret = ((10)+(20)); //不进行计算 int ret = SUM(10, 20); printf(\"ret:%d\\n\",ret);&#125; 注意: 1) 宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格； 2) 用括号括住每一个参数，并括住宏的整体定义。 3) 用大写字母表示宏的函数名。 4) 如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。 10.4 条件编译一般情况下，源程序中所有的行都参加编译。但有时希望对部分源程序行只在满足一定条件时才编译，即对这部分源程序行指定编译条件。 条件编译 防止头文件被重复包含引用； 12345678#ifndef _SOMEFILE_H#define _SOMEFILE_H//需要声明的变量、函数//宏定义//结构体#endif 10.5 一些特殊的预定宏C 编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。 123456789101112// __FILE__ 宏所在文件的源文件名 // __LINE__ 宏所在行的行号// __DATE__ 代码编译的日期// __TIME__ 代码编译的时间void test()&#123; printf(\"%s\\n\", __FILE__); printf(\"%d\\n\", __LINE__); printf(\"%s\\n\", __DATE__); printf(\"%s\\n\", __TIME__);&#125; 十一、动态库的封装和使用11.1 库的基本概念库是已经写好的、成熟的、可复用的代码。每个程序都需要依赖很多底层库，不可能每个人的代码从零开始编写代码，因此库的存在具有非常重要的意义。 在我们的开发的应用中经常有一些公共代码是需要反复使用的，就把这些代码编译为库文件。 库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。像在Windows这样的平台上，最常用的 c 语言库是由集成按开发环境所附带的运行库，这些库一般由编译厂商提供。 库：就是已经编写好的，后续可以直接使用的代码。 c++静态库：会合入到最终生成的程序，使得结果文件比较大。优点是不再有任何依赖。 c++动态库：动态库，一个文件可以多个代码同时使用内存中只有一份，节省内存，可以随主代码一起编译。缺点是需要头文件。 网友说：库就是除了main函数之外的其他代码，都可以组成库。 11.2 静态库优缺点 静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系； 程序在运行时与函数库再无瓜葛，移植方便。 浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。 内存和磁盘空间 静态链接这种方法很简单，原理上也很容易理解，在操作系统和硬件不发达的早期，绝大部门系统采用这种方案。随着计算机软件的发展，这种方法的缺点很快暴露出来，那就是静态链接的方式对于计算机内存和磁盘空间浪费非常严重。特别是多进程操作系统下，静态链接极大的浪费了内存空间。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。 程序开发和发布 空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也会带来很多麻烦。比如程序中所使用的mylib.lib是由一个第三方厂商提供的，当该厂商更新容量mylib.lib的时候，那么我们的程序就要拿到最新版的mylib.lib，然后将其重新编译链接后，将新的程序整个发布给用户。这样的做缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。 要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。 11.3 Linux 下 gcc 编译器生成和使用静态库和动态库我们通常把一些公用函数制作成函数库，供其它程序使用。函数库分为静态库和动态库两种。 静态库在程序编译时会被链接并拷贝到目标代码中，程序运行时将不再需要该静态库。 动态库在程序编译时并不会被拷贝到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要动态库存在。本质上说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。 windows 和 linux 库的二进制是不兼容的（主要是编译器、汇编器和连接器的不同）。 11.3.1 基本概念库的种类： linux下的库有两种： 静态库 共享库（动态库）。 二者区别在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。 库文件是如何产生的： 静态库的后缀是 .a，它的产生分两步: Step 1. 由源文件编译生成一堆 .o，每个 .o 里都包含这个编译单元的符号表 Step 2. ar 命令将很多 .o 转换成 .a，成为静态库 动态库的后缀是 .so，它由 gcc 加特定参数编译产生。 库文件命名规范： 库文件一般放在 /usr/local/lib，/usr/lib，/lib，或者其他自定义的 lib 下。 静态库的名字一般为 libxxxx.a，其中 xxxx 是该 lib 的名称 动态库的名字一般为 libxxxx.so.major.minor， xxxx 是该 lib 的名称，major 是主版本号， minor 是副版本号 如何知道一个可执行程序依赖哪些库： ldd 命令可以查看一个可执行程序依赖的共享库，例如： 123$ ldd /lib/i386-linux-gnu/libc.so.6/lib/ld-linux.so.2 (0xf7740000)linux-gate.so.1 =&gt; (0xf773f000) 可以看到 libc 命令依赖于 linux-gate 库和 ld-linux 库 可执行程序在执行的时候如何定位共享库文件： 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader) 对于 elf 格式的可执行程序，是由 ld-linux.so* 来完成的，它先后搜索 elf 文件的 DT_RPATH 段—环境变量 LD_LIBRARY_PATH—/etc/ld.so.cache 文件列表— /lib/,/usr/lib 目录找到库文件后将其载入内存 如：export LD_LIBRARY_PATH=’pwd’ 将当前文件目录添加为共享目录 在新安装一个库之后如何让系统能够找到他： 如果安装在 /lib 或者 /usr/lib 下，那么 ld 默认能够找到，无需其他操作。如果安装在其他目录，需要将其添加到 /etc/ld.so.cache 文件中，步骤如下： 编辑 /etc/ld.so.conf 文件，加入库文件所在目录的路径 运行 ldconfig，该命令会重建 /etc/ld.so.cache 文件 11.3.2 用 gcc 生成静态和动态链接库的示例假设有1个类 hello，和一个 main 函数。如下： hello.h 123456#ifndef HELLO_H #define HELLO_H void hello(const char *name); #endif hello.c 1234#include &lt;stdio.h&gt; void hello(const char *name) &#123; printf(\"Hello %s!\\n\", name);&#125; main.c 123456#include \"hello.h\" int main() &#123; hello(\"world!\"); return 0; &#125; hello.c 是一个没有 main 函数的 .c 程序，因此不够成一个完整的程序，如果使用 gcc –o 编译并连接它，gcc 将报错，无法通过编译。 前面提过，无论静态库，还是动态库，都是由 .o文件创建的。那么我们如何才能让 main.c 调用 hello 类呢？也就是说该如何才能将 hello.c 通过 gcc 先编译成 .o 文件，并且让 main.c 在编译时能找到它？有三种途径可以实现： 1）通过编译多个源文件，直接将目标代码合成一个 .o 文件。 2）通过创建静态链接库 libmyhello.a，使得 main 函数调用 hello 函数时可调用静态链接库。 3）通过创建动态链接库 libmyhello.so，使得 main 函数调用 hello 函数时可调用动态链接库。 11.3.2.1 途径一：编译多个源文件执行命令： 12$ gcc -c hello.c$ gcc -c main.c 这里提醒一下：gcc –o 是将 .c 源文件编译成为一个可执行的二进制代码。而 gcc –c 是使用GNU汇编器将源文件转化为目标代码。更多 gcc 编译选项的常识点这里。 这时可以看到生成了 hello.o 和 main.o 文件。 12345678910111213$ lshello.c hello.h hello.o main.c main.o# 将两个文件链接成一个 `.o` 文件：$ gcc -o sayhello main.o hello.o# 查看此时已经生成了可执行文件sayhello$ lshello.c hello.h hello.o main.c main.o sayhello# 运行$ ./sayhelloHello world!! 11.3.2.2 途径二：静态链接库静态库文件名是以 lib 为前缀，紧接着是静态库名，扩展名为 .a。例如：我们将创建的静态库名为myhello，则静态库文件名就是 libmyhello.a 。创建静态库用 ar 命令。 删除途径一中生成的3个文件，回到原始的三个文件： 1234567891011$ rm hello.o main.o sayhello$ lshello.c hello.h main.c# 开始尝试途径二，创建静态库文件libmyhello.a：$ gcc -c hello.c$ ar rcs libmyhello.a hello.o# 查看一下已经生成了：$ lshello.c hello.h hello.o libmyhello.a main.c 静态库制作完了，如何使用它内部的函数呢？ 只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明，然后在用 gcc 命令生成目标文件时指明静态库名，gcc 将会从静态库中将公用函数连接到目标文件中。 注意，gcc 会在静态库名前加上前缀 lib，然后追加扩展名 .a 得到的静态库文件名来查找静态库文件。 因此，我们在写需要连接的库时，只写静态库名就可以，如 libmyhello.a 的库，只写: -lmyhello在 main.c 中，我们已包含了该静态库的头文件 hello.h。现在在主程序 main.c 中直接调用它内部的函数： 123456789# 这里-L.告诉 gcc 先在当前目录下查找库文件。$ gcc -o sayhello main.c -static -L. -lmyhello # 查看一下，已经生成可执行文件sayhello$ lshello.c hello.h hello.o libmyhello.a main.c sayhello$ ./sayhelloHello world!! 前面提过静态库在编译过程中会被拷贝到目标程序中，运行时不再需要静态库的存在。这里可以简单验证一下：我们删除静态库文件，然后再试着调用函数 hello 看是否还能调用成功。 1234$ rm libmyhello.a$ ./sayhelloHello world!! 程序照常运行，静态库中的函数已经被复制到目标程序中了，编译完成后，静态库就没用了，执行时不再需要静态库的存在。 静态链接库的一个缺点是： 如果我们同时运行了许多程序，并且它们使用了同一个库函数，这样，在内存中会大量拷贝同一库函数。这样，就会浪费内存和存储空间。 使用了共享链接库的Linux就可以避免这个问题。共享函数库和静态函数在同一个地方，只是后缀不同。比如，在Linux系统，标准的共享数序函数库是 /usr/lib/libm.so。当一个程序使用共享函数库时，在连接阶段并不把函数代码连接进来，而只是链接函数的一个引用。当最终的函数导入内存开始真正执行时，函数引用被解析，共享函数库的代码才真正导入到内存中。这样，共享链接库的函数就可以被许多程序同时共享，并且只需存储一次就可以了。共享函数库的另一个优点是，它可以独立更新，与调用它的函数毫不影响。 11.3.2.3 途径三：动态链接库（共享函数库）动态库文件名和静态库类似，也是在动态库名增加前缀 lib，但其文件扩展名为 .so。例如：我们将创建的动态库名为 myhello，则动态库文件名就是 libmyhello.so 。用 gcc 来创建动态库。 删除途径二中生成的2个文件，回到原始的三个文件： 1234567891011121314$ rm hello.o sayhello$ lshello.c hello.h main.c# 开始尝试途径三，创建静态库文件libmyhello.so：# 按教程里，会报错：$ gcc -c hello.c$ lshello.c hello.h hello.o main.c$ gcc -shared -fPIC -o libmyhello.so hello.o/usr/bin/ld: hello.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIChello.o: could not read symbols: Bad valuecollect2: ld returned 1 exit status 正确方法是，这样就可以了： 12345$ gcc -fPIC -shared -o libmyhello.so hello.c# 已生成libmyhello.so，是绿色。$ lshello.c hello.h libmyhello.so main.c 最主要的是 GCC 命令行的选项: -shared：指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件 -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。 下面调用该动态链接库： 1234567$ gcc -o sayhello main.c -L. -lmyhello$ lshello.c hello.h libmyhello.so main.c sayhello$ ./sayhelloHello world!!成功！ 按教程里说的：他以这种方式调用动态链接库出错，找不到动态库文件 libmyhello.so： 1./sayhello: error while loading shared libraries: libmyhello.so: cannot open shared object file: No such file or directory 程序在运行时，会在 /usr/lib 和 /lib 等目录中查找需要的动态库文件。若找到，则载入动态库，否则将提示类似上述错误而终止程序运行。解决此类问题有如下三种方法： （1）我们将文件 libmyhello.so复制到目录/usr/lib中。 （2）既然连接器会搜寻LD_LIBRARY_PATH所指定的目录，那么我们只要将当前目录添加到环境变量： export LD_LIBRARY_PATH=$(pwd) （3）执行： ldconfig /usr/zhsoft/lib 说明：当用户在某个目录下面创建或拷贝了一个动态链接库，若想使其被系统共享，可以执行一下 “ldconfig 目录名” 这个命令。此命令的功能在于让 ldconfig 将指定目录下的动态链接库被系统共享起来，意即：在缓存文件 /etc/ld.so.cache 中追加进指定目录下的共享库。该命令会重建 /etc/ld.so.cache 文件。 参考教程： http://blog.csdn.net/jiayouxjh/article/details/7602729 http://blog.sina.com.cn/s/blog_54f82cc20101153x.html http://navyaijm.blog.51cto.com/4647068/809424 十二、递归函数12.1 递归函数基本概念C通过运行时堆栈来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。 12.2 普通函数调用1234567891011121314void funB(int b)&#123; printf(\"b = %d\\n\", b);&#125;void funA(int a)&#123; funB(a - 1); printf(\"a = %d\\n\", a);&#125;int main(void)&#123; funA(2); printf(\"main\\n\"); return 0;&#125; 函数的调用流程如下： 12.3 递归函数调用1234567891011121314void fun(int a)&#123; if (a == 1)&#123; printf(\"a = %d\\n\", a); return; //中断函数很重要 &#125; fun(a - 1); printf(\"a = %d\\n\", a);&#125;int main(void)&#123; fun(2); printf(\"main\\n\"); return 0;&#125; 函数的调用流程如下： 递归实现给出一个数8793，依次打印千位数字8、百位数字7、十位数字9、个位数字3。 12345678void recursion(int val)&#123; if (val == 0)&#123; return; &#125; int ret = val / 10; recursion(ret); printf(\"%d \",val % 10);&#125; 12.4 递归实现字符串反转123456789101112131415161718192021222324252627282930313233343536373839404142int reverse1(char *str)&#123; if (str == NULL)&#123; return -1; &#125; if (*str == '\\0') &#123; // 函数递归调用结束条件 return 0; &#125; reverse1(str + 1); printf(\"%c\", *str); return 0;&#125;char buf[1024] = &#123; 0 &#125;; //全局变量int reverse2(char *str)&#123; if (str == NULL) &#123; return -1; &#125; if ( *str == '\\0' ) &#123; // 函数递归调用结束条件 return 0; &#125; reverse2(str + 1); strncat(buf, str, 1); return 0;&#125;int reverse3(char *str, char *dst)&#123; if (str == NULL || dst == NULL) &#123; return -1; &#125; if (*str == '\\0') &#123; // 函数递归调用结束条件 return 0; &#125; reverse3(str + 1); strncat(dst, str, 1); return 0;&#125; 12.5 递归实现链表逆序打印TODO 十三、面向接口编程13.1 案例背景一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。 13.2 案例需求要求在企业信息系统框架中集成第三方厂商的socket通信产品和第三方厂商加密产品。软件设计要求：模块要求松、接口要求紧。 13.3 案例要求 1）能支持多个厂商的 socket 通信产品入围 2）能支持多个第三方厂商加密产品的入围 3）企业信息系统框架不轻易发生框架 13.4 编程提示 1）抽象通信接口结构体设计（CSocketProtocol） 2）框架接口设计（framework） 3） a) 通信厂商1入围（CSckImp1） b) 通信厂商2入围（CSckImp2） 4） a) 抽象加密接口结构体设计（CEncDesProtocol） b) 升级框架函数（增加加解密功能） c) 加密厂商1入围(CHwImp)、加密厂商2入围(CCiscoImp) 5）框架接口分文件","categories":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/categories/Program-C/"}],"tags":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/tags/Program-C/"}]},{"title":"Program-C 基础","slug":"Program-C/program-c","date":"2016-05-10T02:14:50.000Z","updated":"2019-06-10T08:02:59.863Z","comments":true,"path":"2016/05/10/Program-C/program-c/","link":"","permalink":"http://miaopei.github.io/2016/05/10/Program-C/program-c/","excerpt":"C 语言基础一、C 语言概述","text":"C 语言基础一、C 语言概述 二、数据类型 三、字符串处理和函数 声明变量不需要建立存储空间，如：extern int a; 定义变量需要建立存储空间，如：int b; 全局数组若不初始化，编译器将其初始化为零。局部数组若不初始化，内容为随机值。 数字 0 (和字符 ‘\\0’ 等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。 gets(str)与scanf(“%s”,str)的区别： gets(str)允许输入的字符串含有空格 scanf(“%s”,str)不允许含有空格 注意：由于scanf()和gets()无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字符数组越界(缓冲区溢出)的情况。 gets() 、puts() 123456#include &lt;stdio.h&gt;char *gets(char *s);功能：从标准输入读入字符，并保存到s指定的内存空间，直到出现换行符或读到文件结尾为止。int puts(const char *s);功能：标准设备输出s字符串，在输出完成后自动输出一个'\\n'。 fgets() 、fputs() 12345678#include &lt;stdio.h&gt;char *fgets(char *s, int size, FILE *stream);功能：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。fgets()在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。通过scanf和gets输入一个字符串的时候，不包含结尾的“\\n”，但通过fgets结尾多了“\\n”。fgets()函数是安全的，不存在缓冲区溢出的问题。int fputs(const char * str, FILE * stream);功能：将str所指定的字符串写入到stream指定的文件中， 字符串结束符 '\\0' 不写入文件。fputs()是puts()的文件操作版本，但fputs()不会自动输出一个'\\n'。 strlen() 、strcpy() 、strncpy() 、strcat() 、strncat() 、strcmp() 、strncmp() 、sprintf() 、sscanf() 、strchr() 、strstr() 、strtok() 、atoi() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;string.h&gt;size_t strlen(const char *s);功能：计算指定指定字符串s的长度，不包含字符串结束符‘\\0’char *strcpy(char *dest, const char *src);功能：把src所指向的字符串复制到dest所指向的空间中，'\\0'也会拷贝过去注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。char *strncpy(char *dest, const char *src, size_t n);功能：把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含'\\0'。char *strcat(char *dest, const char *src);功能：将src字符串连接到dest的尾部，‘\\0’也会追加过去char *strncat(char *dest, const char *src, size_t n);功能：将src字符串前n个字符连接到dest的尾部，‘\\0’也会追加过去int strcmp(const char *s1, const char *s2);功能：比较 s1 和 s2 的大小，比较的是字符ASCII码大小。int strncmp(const char *s1, const char *s2, size_t n);功能：比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小。#include &lt;stdio.h&gt;int sprintf(char *_CRT_SECURE_NO_WARNINGS, const char *format, ...);功能：根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 '\\0' 为止。#include &lt;stdio.h&gt;int sscanf(const char *str, const char *format, ...);功能：从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。#include &lt;string.h&gt;char *strchr(const char *s, int c);功能：在字符串s中查找字母c出现的位置char *strstr(const char *haystack, const char *needle);功能：在字符串haystack中查找字符串needle出现的位置char *strtok(char *str, const char *delim);功能：来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\\0 字符，当连续出现多个时只替换第一个为\\0。#include &lt;stdlib.h&gt;int atoi(const char *nptr);功能：atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符('\\0')才结束转换，并将结果返回返回值。类似的函数有：- atof()：把一个小数形式的字符串转化为一个浮点数。- atol()：将一个字符串转化为long类型 形参列表 在定义函数时指定的形参，在未出现函数调用时，它们并不占内存中的存储单元，因此称它们是形式参数或虚拟参数，简称形参，表示它们并不是实际存在的数据，所以，形参里的变量不能赋值。 如果函数返回的类型和return语句中表达式的值不一致，则以函数返回类型为准，即函数返回类型决定返回值的类型。对数值型数据，可以自动进行类型转换。 注意：如果函数返回的类型和return语句中表达式的值不一致，而它又无法自动进行类型转换，程序则会报错。 当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。 extern告诉编译器这个变量或函数在其他文档里已被定义了。 static法则： A、若全局变量仅在单个C文档中访问，则能够将这个变量修改为静态全局变量，以降低模块间的耦合度; B、若全局变量仅由单个函数访问，则能够将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； C、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题； 12// 多文件编译gcc -o 可执行程序 文件1.c 文件2.c 头文件.h 四、指针和指针变量 内存区的每一个字节都有一个编号，这就是“地址”。 如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号) 指针的实质就是内存“地址”。指针就是地址，地址就是指针。 指针是内存单元的编号，指针变量是存放地址的变量。 通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。 指针也是一种数据类型，指针变量也是一种变量 指针变量指向谁，就把谁的地址赋值给指针变量 “*” 操作符操作的是指针变量指向的内存空间 指针大小 使用sizeof()测量指针的大小，得到的总是：4或8 sizeof()测的是指针变量指向存储地址的大小 在32位平台，所有的指针（地址）都是32位(4字节) 在64位平台，所有的指针（地址）都是64位(8字节) 野指针和空指针 指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。 但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。 NULL是一个值为0的宏常量：#define NULL ((void *)0) 万能指针 void * void * 指针可以指向任意变量的内存空间： 12345678void *p = NULL;int a = 10;p = (void *)&amp;a; //指向变量时，最好转换为void *//使用指针变量指向的内存时，转换为int **( (int *)p ) = 11;printf(\"a = %d\\n\", a); const修饰的指针变量 1234567891011121314int a = 100;int b = 200;//指向常量的指针//修饰*，指针指向内存区域不能修改，指针指向可以变const int *p1 = &amp;a; //等价于int const *p1 = &amp;a;//*p1 = 111; //errp1 = &amp;b; //ok//指针常量//修饰p1，指针指向不能变，指针指向的内存可以修改int * const p2 = &amp;a;//p2 = &amp;b; //err*p2 = 222; //ok 指针操作数组元素 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main()&#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int i = 0; int n = sizeof(a) / sizeof(a[0]); for (i = 0; i &lt; n; i++) &#123; //printf(\"%d, \", a[i]); printf(\"%d, \", *(a+i)); &#125; printf(\"\\n\"); int *p = a; //定义一个指针变量保存a的地址 for (i = 0; i &lt; n; i++) &#123; p[i] = 2 * i; &#125; for (i = 0; i &lt; n; i++) &#123; printf(\"%d, \", *(p + i)); &#125; printf(\"\\n\"); return 0;&#125; 指针加减运算 指针计算不是简单的整数相加 如果是一个int *，+1的结果是增加一个int的大小 如果是一个char *，+1的结果是增加一个char大小 通过改变指针指向操作数组元素： 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int i = 0; int n = sizeof(a) / sizeof(a[0]); int *p = a; for (i = 0; i &lt; n; i++) &#123; printf(\"%d, \", *p); p++; &#125; printf(\"\\n\"); return 0;&#125; 指针数组 指针数组，它是数组，数组的每个元素都是指针类型。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123; //指针数组 int *p[3]; int a = 1; int b = 2; int c = 3; int i = 0; p[0] = &amp;a; p[1] = &amp;b; p[2] = &amp;c; for (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++ ) &#123; printf(\"%d, \", *(p[i])); &#125; printf(\"\\n\"); return 0;&#125; 多级指针 C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针。 二级指针就是指向一个一级指针变量地址的指针。 三级指针基本用不着，但考试会考。 123456789101112int a = 10;int *p = &amp;a; //一级指针*p = 100; //*p就是aint **q = &amp;p;//*q就是p//**q就是aint ***t = &amp;q;//*t就是q//**t就是p//***t就是a 数组名做函数参数 数组名做函数参数，函数的形参会退化为指针： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;//void printArrary(int a[10], int n)//void printArrary(int a[], int n)void printArrary(int *a, int n)&#123; int i = 0; for (i = 0; i &lt; n; i++) &#123; printf(\"%d, \", a[i]); &#125; printf(\"\\n\");&#125;int main()&#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int n = sizeof(a) / sizeof(a[0]); //数组名做函数参数 printArrary(a, n); return 0;&#125; 指针做为函数的返回值 12345678910111213141516#include &lt;stdio.h&gt;int a = 10;int *getA()&#123; return &amp;a;&#125;int main()&#123; *( getA() ) = 111; printf(\"a = %d\\n\", a); return 0;&#125; 指针和字符串 字符指针 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; char str[] = \"hello world\"; char *p = str; *p = 'm'; p++; *p = 'i'; printf(\"%s\\n\", str); // millo world p = \"mike jiang\"; printf(\"%s\\n\", p); // mike jiang char *q = \"test\"; printf(\"%s\\n\", q); // test return 0;&#125; const修饰的指针变量 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(void)&#123; //const修饰一个变量为只读 const int a = 10; //a = 100; //err //指针变量， 指针指向的内存， 2个不同概念 char buf[] = \"aklgjdlsgjlkds\"; //从左往右看，跳过类型，看修饰哪个字符 //如果是*， 说明指针指向的内存不能改变 //如果是指针变量，说明指针的指向不能改变，指针的值不能修改 const char *p = buf; // 等价于上面 char const *p1 = buf; //p[1] = '2'; //err p = \"agdlsjaglkdsajgl\"; //ok char * const p2 = buf; p2[1] = '3'; //p2 = \"salkjgldsjaglk\"; //err //p3为只读，指向不能变，指向的内存也不能变 const char * const p3 = buf; return 0;&#125; 五、内存管理5.1 作用域C语言变量的作用域分为： 代码块作用域(代码块是{}之间的一段代码) 函数作用域 文件作用域 局部变量也叫auto自动变量(auto可写可不写)，一般情况下代码块{}内部定义的变量都是自动变量，它有如下特点： 在一个函数内定义，只在函数范围内有效 在复合语句中定义，只在复合语句中有效 随着函数调用的结束或复合语句的结束局部变量的声明声明周期也结束 如果没有赋初值，内容为随机 123456789101112131415161718192021222324#include &lt;stdio.h&gt;void test()&#123; //auto写不写是一样的 //auto只能出现在&#123;&#125;内部 auto int b = 10; &#125;int main(void)&#123; //b = 100; //err， 在main作用域中没有b if (1) &#123; //在复合语句中定义，只在复合语句中有效 int a = 10; printf(\"a = %d\\n\", a); &#125; //a = 10; //err离开if()的复合语句，a已经不存在 return 0;&#125; 静态(static)局部变量 static局部变量的作用域也是在定义的函数内有效 static局部变量的生命周期和程序运行周期一样，同时staitc局部变量的值只初始化一次，但可以赋值多次 static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0，字符型变量赋空字符 全局变量 在函数外定义，可被本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量,须用extern声明 全局变量的生命周期和程序运行周期一样 不同文件的全局变量不可重名 静态(static)全局变量 在函数外定义,作用范围被限制在所定义的文件中 不同文件静态全局变量可以重名,但作用域不冲突 static全局变量的生命周期和程序运行周期一样，同时staitc全局变量的值只初始化一次 extern全局变量声明 extern int a; 声明一个变量，这个变量在别的文件中已经定义了，这里只是声明，而不是定义 全局函数和静态函数 在C语言中函数默认都是全局的，使用关键字static可以将函数声明为静态，函数定义为static就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数都没用。 注意： 允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰。 同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。 所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。 总结： 类型 作用域 生命周期 auto变量 一对{}内 当前函数 static局部变量 一对{}内 整个程序运行期 extern变量 整个程序 整个程序运行期 static全局变量 当前文件 整个程序运行期 extern函数 整个程序 整个程序运行期 static函数 当前文件 整个程序运行期 register变量 一对{}内 当前函数 5.2 内存布局内存分区 C代码经过预处理、编译、汇编、链接4步后生成一个可执行程序。 在 Linux 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况： 通过上图可以得知，在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（text）、数据区（data）和未初始化数据区（bss）3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。 代码区 存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。 全局初始化数据区/静态数据区（data段） 该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。 未初始化数据区（又叫 bss 区） 存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。 程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。 代码区（text segment） 加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。 未初始化数据区（BSS） 加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 全局初始化数据区/静态数据区（data segment） 加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。 栈区（stack） 栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。 堆区（heap） 堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 存储类型总结： 类型 作用域 生命周期 存储位置 auto变量 一对{}内 当前函数 栈区 static局部变量 一对{}内 整个程序运行期 初始化在data段，未初始化在BSS段 extern变量 整个程序 整个程序运行期 初始化在data段，未初始化在BSS段 static全局变量 当前文件 整个程序运行期 初始化在data段，未初始化在BSS段 extern函数 整个程序 整个程序运行期 代码区 static函数 当前文件 整个程序运行期 代码区 register变量 一对{}内 当前函数 运行时存储在CPU寄存器 字符串常量 当前文件 整个程序运行期 data段 存储类型总结内存操作函数： 123456789101112#include &lt;string.h&gt;void *memset(void *s, int c, size_t n);功能：将s的内存区域的前n个字节以参数c填入void *memcpy(void *dest, const void *src, size_t n);功能：拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。memmove()memmove()功能用法和memcpy()一样，区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比memcpy()低些。int memcmp(const void *s1, const void *s2, size_t n);功能：比较s1和s2所指向内存区域的前n个字节 堆区内存分配和释放： 123456#include &lt;stdlib.h&gt;void *malloc(size_t size);功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。void free(void *ptr);功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。 1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; int count, *array, n; printf(\"请输入要申请数组的个数:\\n\"); scanf(\"%d\", &amp;n); array = (int *)malloc(n * sizeof (int)); if (array == NULL) &#123; printf(\"申请空间失败!\\n\"); return -1; &#125; //将申请到空间清0 memset(array, 0, sizeof(int)*n); for (count = 0; count &lt; n; count++) /*给数组赋值*/ array[count] = count; for (count = 0; count &lt; n; count++) /*打印数组元素*/ printf(\"%2d\", array[count]); free(array); return 0;&#125; 返回堆区地址： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int *fun()&#123; int *tmp = NULL; tmp = (int *)malloc(sizeof(int)); *tmp = 100; return tmp;//返回堆区地址，函数调用完毕，不释放&#125;int main(int argc, char *argv[])&#123; int *p = NULL; p = fun(); printf(\"*p = %d\\n\", *p);//ok //堆区空间，使用完毕，手动释放 if (p != NULL) &#123; free(p); p = NULL; &#125; return 0;&#125; 六、复合类型(自定义类型)6.1 结构体定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 1234567891011121314151617181920212223//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;//先定义类型，再定义变量（常用）struct stu s1 = &#123; \"mike\", 18 &#125;;//定义类型同时定义变量struct stu2&#123; char name[50]; int age;&#125;s2 = &#123; \"lily\", 22 &#125;;struct&#123; char name[50]; int age;&#125;s3 = &#123; \"yuri\", 25 &#125;; 结构体成员的使用： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;string.h&gt;//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;int main()&#123; struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-&gt;操作结构体成员 strcpy((&amp;s1)-&gt;name, \"test\"); (&amp;s1)-&gt;age = 22; printf(\"(&amp;s1)-&gt;name = %s, (&amp;s1)-&gt;age = %d\\n\", (&amp;s1)-&gt;name, (&amp;s1)-&gt;age); return 0;&#125; 结构体套结构体： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;struct person&#123; char name[20]; char sex;&#125;;struct stu&#123; int id; struct person info;&#125;;int main()&#123; struct stu s[2] = &#123; 1, \"lily\", 'F', 2, \"yuri\", 'M' &#125;; int i = 0; for (i = 0; i &lt; 2; i++) &#123; printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); &#125; return 0;&#125; 结构体套一级指针： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;//结构体类型的定义struct stu&#123; char *name; //一级指针 int age;&#125;;int main()&#123; struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-&gt;name = malloc(strlen(\"test\") + 1); strcpy(p-&gt;name, \"test\"); p-&gt;age = 22; printf(\"p-&gt;name = %s, p-&gt;age=%d\\n\", p-&gt;name, p-&gt;age); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-&gt;name != NULL) &#123; free(p-&gt;name); p-&gt;name = NULL; &#125; if (p != NULL) &#123; free(p); p = NULL; &#125; return 0;&#125; 结构体普通变量做函数参数： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include &lt;string.h&gt;//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;//函数参数为结构体普通变量void set_stu(struct stu tmp)&#123; strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age);&#125;int main()&#123; struct stu s = &#123; 0 &#125;; set_stu(s); //值传递 printf(\"s.name = %s, s.age = %d\\n\", s.name, s.age); return 0;&#125; 结构体指针变量做函数参数： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include &lt;string.h&gt;//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;//函数参数为结构体指针变量void set_stu_pro(struct stu *tmp)&#123; strcpy(tmp-&gt;name, \"mike\"); tmp-&gt;age = 18;&#125;int main()&#123; struct stu s = &#123; 0 &#125;; set_stu_pro(&amp;s); //地址传递 printf(\"s.name = %s, s.age = %d\\n\", s.name, s.age); return 0;&#125; 结构体数组名做函数参数： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;//void set_stu_pro(struct stu tmp[100], int n)//void set_stu_pro(struct stu tmp[], int n)void set_stu_pro(struct stu *tmp, int n)&#123; int i = 0; for (i = 0; i &lt; n; i++) &#123; sprintf(tmp-&gt;name, \"name%d%d%d\", i, i, i); tmp-&gt;age = 20 + i; tmp++; &#125;&#125;int main()&#123; struct stu s[3] = &#123; 0 &#125;; int i = 0; int n = sizeof(s) / sizeof(s[0]); set_stu_pro(s, n); //数组名传递 for (i = 0; i &lt; n; i++) &#123; printf(\"%s, %d\\n\", s[i].name, s[i].age); &#125; return 0;&#125; 6.2 共用体(联合体) 联合union是一个能在同一个存储空间存储不同类型数据的类型； 联合体所占的内存长度等于其最长成员的长度，也有叫做共用体； 同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用； 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖； 共用体变量的地址和它的各成员的地址都是同一地址。 6.3 枚举枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。 枚举类型定义： 1234enum 枚举名&#123; 枚举值表&#125;; 在枚举值表中应列出所有可用值，也称为枚举元素。 枚举值是常量，不能在程序中用赋值语句再对它赋值。 枚举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 … 6.4 typedeftypedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，不能创建新类型。 与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值 #define发生在预处理，typedef发生在编译阶段 七、文件操作磁盘文件和设备文件 磁盘文件 指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。 设备文件 在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。 7.1 文件的打开和关闭文件指针 在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。 123456789101112typedef struct&#123; short level; //缓冲区\"满\"或者\"空\"的程度 unsigned flags; //文件状态标志 char fd; //文件描述符 unsigned char hold; //如无缓冲区不读取字符 short bsize; //缓冲区的大小 unsigned char *buffer;//数据缓冲区的位置 unsigned ar; //指针，当前的指向 unsigned istemp; //临时文件，指示器 short token; //用于有效性的检查 &#125;FILE; FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。 声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 文件的打开： 123#include &lt;stdio.h&gt;FILE * fopen(const char * filename, const char * mode);功能：打开文件 第二个参数的几种形式(打开文件的方式)： 打开模式 含义 r或rb 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） w或wb 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a或ab 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件 r+或rb+ 以可读、可写的方式打开文件(不创建新文件) w+或wb+ 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a+或ab+ 以添加方式打开文件，打开文件并在末尾更改文件,若文件不存在则创建文件 注意： b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的 Unix和Linux下所有的文本文件行都是\\n结尾，而Windows所有的文本文件行都是\\r\\n结尾 在Windows平台下，以“文本”方式打开文件，不加b： 当读取文件的时候，系统会将所有的 “\\r\\n” 转换成 “\\n” 当写入文件的时候，系统会将 “\\n” 转换成 “\\r\\n” 写入 以”二进制”方式打开文件，则读\\写都不会进行这样的转换 在Unix/Linux平台下，“文本”与“二进制”模式没有区别，”\\r\\n” 作为两个字符原样输入输出 123456789101112131415161718int main(void)&#123; FILE *fp = NULL; // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 &#123; //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; &#125; fclose(fp); return 0;&#125; 7.2 文件的顺序读写 按照字符读写文件fgetc、fputc 123456#include &lt;stdio.h&gt;int fputc(int ch, FILE * stream);功能：将ch转换为unsigned char后写入stream指定的文件中int fgetc(FILE * stream);功能：从stream指定的文件中读取一个字符 在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。#define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 123#include &lt;stdio.h&gt;int feof(FILE * stream);功能：检测是否读取到了文件结尾。**判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)**。 按照行读写文件fgets、fputs 123456#include &lt;stdio.h&gt;int fputs(const char * str, FILE * stream);功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 char * fgets(char * str, int size, FILE * stream);功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 按照格式化文件fprintf、fscanf 123456#include &lt;stdio.h&gt;int fprintf(FILE * stream, const char * format, ...);功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。int fscanf(FILE * stream, const char * format, ...);功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 按照块读写文件fread、fwrite 123456789101112131415#include &lt;stdio.h&gt;size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);功能：以数据块的方式给文件写入内容参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针返回值： 成功：实际成功写入文件数据的块数目，此值和nmemb相等 失败：0#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);功能：以数据块的方式从文件中读取内容 7.3 文件的随机读写123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int fseek(FILE *stream, long offset, int whence);功能：移动文件流（文件光标）的读写位置。参数： stream：已经打开的文件指针 offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。 whence：其取值如下： SEEK_SET：从文件开头移动offset个字节 SEEK_CUR：从当前位置移动offset个字节 SEEK_END：从文件末尾移动offset个字节返回值： 成功：0 失败：-1#include &lt;stdio.h&gt;long ftell(FILE *stream);功能：获取文件流（文件光标）的读写位置。参数： stream：已经打开的文件指针返回值： 成功：当前文件流（文件光标）的读写位置 失败：-1#include &lt;stdio.h&gt;void rewind(FILE *stream);功能：把文件流（文件光标）的读写位置移动到文件开头。参数： stream：已经打开的文件指针返回值： 无返回值 7.4 获取文件状态12345678910#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int stat(const char *path, struct stat *buf);功能：获取文件状态信息参数： path：文件名 buf：保存文件信息的结构体返回值： 成功：0 失败-1 123456789101112131415struct stat &#123; dev_t st_dev; //文件的设备编号 ino_t st_ino; //节点 mode_t st_mode; //文件的类型和存取的权限 nlink_t st_nlink; //连到该文件的硬连接数目，刚建立的文件值为1 uid_t st_uid; //用户ID gid_t st_gid; //组ID dev_t st_rdev; //(设备类型)若此文件为设备文件，则为其设备编号 off_t st_size; //文件字节数(文件大小) unsigned long st_blksize; //块大小(文件系统的I/O 缓冲区大小) unsigned long st_blocks; //块数 time_t st_atime; //最后一次访问时间 time_t st_mtime; //最后一次修改时间 time_t st_ctime; //最后一次改变时间(指属性)&#125;; 12345678910111213141516#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **args)&#123; if (argc &lt; 2) return 0; struct stat st = &#123; 0 &#125;; stat(args[1], &amp;st); int size = st.st_size;//得到结构体中的成员变量 printf(\"%d\\n\", size); return 0;&#125; 7.5 删除文件、重命名文件名123456789101112131415161718#include &lt;stdio.h&gt;int remove(const char *pathname);功能：删除文件参数： pathname：文件名返回值： 成功：0 失败：-1#include &lt;stdio.h&gt;int rename(const char *oldpath, const char *newpath);功能：把oldpath的文件名改为newpath参数： oldpath：旧文件名 newpath：新文件名返回值： 成功：0 失败： - 1 7.6 文件缓冲区ANSI C标准采用“缓冲文件系统”处理数据文件。 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 磁盘文件的存取： 磁盘文件，一般保存在硬盘、U盘等掉电不丢失的磁盘设备中，在需要时调入内存 在内存中对文件进行编辑处理后，保存到磁盘中 程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率 更新缓冲区： 12345678#include &lt;stdio.h&gt;int fflush(FILE *stream);功能：更新缓冲区，让缓冲区的数据立马写到文件中。参数：stream：文件指针返回值： 成功：0 失败：-1","categories":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/categories/Program-C/"}],"tags":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/tags/Program-C/"}]},{"title":"Program-C 交叉编译","slug":"Program-C/compile","date":"2016-05-05T02:14:50.000Z","updated":"2019-06-10T08:02:34.396Z","comments":true,"path":"2016/05/05/Program-C/compile/","link":"","permalink":"http://miaopei.github.io/2016/05/05/Program-C/compile/","excerpt":"","text":"建立ARM交叉编译环境arm-none-linux-gnueabi-gcc1234567891011121314151617181920212223242526272829303132333435363738394041# add2line：将你要找的地址转成文件和行号，它要使用 debug 信息arm-none-linux-gnueabi-addr2line # ar：产生、修改和解开一个存档文件arm-none-linux-gnueabi-ar # as：gnu的汇编器arm-none-linux-gnueabi-as # ld：gnu 的连接器arm-none-linux-gnueabi-ld # gprof：gnu 汇编器预编译器arm-none-linux-gnueabi-gprof # nm：列出目标文件的符号和对应的地址arm-none-linux-gnueabi-nm # objdump：显示目标文件的信息arm-none-linux-gnueabi-objdump # readelf：显示 elf 格式的目标文件的信息arm-none-linux-gnueabi-readelf # strings：打印出目标文件中可以打印的字符串，有个默认的长度，为4arm-none-linux-gnueabi-strings # c++filt：C++ 和 java 中有一种重载函数，所用的重载函数最后会被编译转化成汇编的标，c++filt 就是实现这种反向的转化，根据标号得到函数名arm-none-linux-gnueabi-c++filt # objcopy：将某种格式的目标文件转化成另外格式的目标文件arm-none-linux-gnueabi-objcopy # ranlib：为一个存档文件产生一个索引，并将这个索引存入存档文件中arm-none-linux-gnueabi-ranlib # size：显示目标文件各个节的大小和目标文件的大小arm-none-linux-gnueabi-size # strip：剥掉目标文件的所有的符号信息arm-none-linux-gnueabi-strip C调用C++库和C++调用C库的方法 C调用C++库和C++调用C库的方法 C++调用C的静态库/动态库C++ 调用 C 的函数比较简单，直接使用 extern &quot;C&quot; {} 告诉编译器用 C 的规则去调用 C 函数就可以了。 CAdd.h 1int cadd(int x, int y); CAdd.c 1234567#include \"CAdd.h\"#include &lt;stdio.h&gt;int cadd(int x, int y) &#123; printf(\"from C function.\\n\"); return (x + y);&#125; 编译libCAdd.a 12gcc -c CAdd.c # 生成CAdd.oar -r libCAdd.a CAdd.o # 归档生成libCAdd.a 编译动态库 libCAdd.so 1gcc -shared -o libCAdd.so CAdd.c cppmain.cpp 123456789101112#include &lt;stdio.h&gt;extern \"C\" &#123; #include \"CAdd.h\"&#125;int main()&#123; int sum = cadd(1, 2); printf(\"1+2 = %d\\n\", sum); return 0;&#125; 编译main -l 指定库名称，优先链接so动态库，没有动态库再链接 .a 静态库。 1g++ -o cppmain cppmain.cpp -L. -lCAdd 运行 如果链接的是静态库就可以直接运行了，如果链接的是动态库可能会提示 1./cppmain: error while loading shared libraries: libCAdd.so: cannot open shared object file: No such file or directory 是因为Linux系统程序和Windows不一样，Linux系统只会从系统环境变量指定的路径加载动态库，可以把生成的动态库放到系统目录，或者执行 export LD_LIBRARY_PATH=./ 设置当前路径为系统链接库目录就可以了。 *注释 * 这里是在 include 头文件的外面包裹了 extern &quot;C&quot; { }，是告诉编译器以 C 语言的命名方式去加载这个符号。还有一种比较常见的方式是在头文件中进行编译声明，如下所示，这样的话，无论 C 还是 C++ 直接正常include就可以使用了。 CAdd.h 12 C 调用 C++ 的静态库C 语言没法直接调用 C++ 的函数，但可以使用包裹函数来实现。C++ 文件 .cpp 中可以调用 C 和 C++ 的函数，但是 C 代码 .c 只能调用 C 的函数，所以可以用包裹函数去包裹C ++ 函数，然后把这个包裹函数以 C 的规则进行编译，这样 C 就可以调用这个包裹函数了。 CppAdd.h 1int cppadd(int x, int y); CppAdd.cpp 1234567#include \"CppAdd.h\"#include &lt;stdio.h&gt;int cppadd(int x, int y) &#123; printf(\"from C++ function.\\n\"); return (x + y);&#125; 编译静态库 libCppAdd.a 12g++ -c CppAdd.cppar -r libCppAdd.a CppAdd.o CppAddWrapper.h 123456789#ifdef __cplusplusextern \"C\" &#123;#endifint cppaddwrapper(int x, int y);#ifdef __cplusplus&#125;#endif CppAddWrapper.cpp 123456789#include \"CppAddWrapper.h\"#include &lt;stdio.h&gt;#include \"CppAdd.h\"int cppaddwrapper(int x, int y) &#123; printf(\"from wrapper.\\n\"); int sum = cppadd(x, y); return sum;&#125; 编译 wrapper 静态库 libCppAddWrapper.a 12g++ -c CppAddWrapper.cppar -r libCppAddWrapper.a CppAddWrapper.o main.c 123456789#include \"CppAddWrapper.h\"#include &lt;stdio.h&gt;int main()&#123; int sum = cppaddwrapper(1, 2); printf(\"1+2 = %d\\n\", sum); return 0;&#125; 编译 main，同时指定 libCppAdd.a 和 libCppAddWrapper.a。 1gcc -o main main.c -L. -lCppAddWrapper -lCppAdd 或者把 libCppAdd.a 合并到 libCppAddWrapper.a 中 1234ar -x libCppAdd.a # 提取CppAdd.oar -x libCppAddWrapper.a # 提取CppAddWrapper.oar -r libCppAddWrapper.a CppAdd.o CppAddWrapper.o # 打包libCppAddWrapper.agcc -o main main.c -L. -lCppAddWrapper # 只需要连接libCppAddWrapper.a即可 如果是 C 调用 C++ 的 so 动态库的话，类似于调用静态库的方法应该也是有效的，太麻烦我没试过。 总结C/C++ 函数符号的区别 C++ 可以兼容 C 的语法，C/C++ 主要的区别是编译函数符号规则不一样，C 语言代码编译后的函数名还是原来函数名，C++ 代码编译后的函数名带有参数信息。 做个测试来检验一下。一个简单的函数，分别用 C 和 C++ 进行编译。 hello1.c 123int test(int a, char* b)&#123; return a;&#125; hello2.cpp 123int test(int a, char* b)&#123; return a;&#125; 编译 12gcc -c hello1.c # 生成hello1.og++ -c hello1.cpp # 生成hello2.o 查看符号表 1234$ nm hello1.o0000000000000000 T test$ nm hello2.o0000000000000000 T _Z4testiPc 从上面信息可以看出，C 语言编译后的函数符号还是原函数名，而 C++ 编译后的函数符号由test变成了 _Z4testiPc，从这个符号名字可以看出 test 前面有个数字 4 应该是函数名长度，test 后面 iPc 应该就是函数的参数签名。C++ 之所以这样规定编译后的函数符号是因为对面对象的 C++ 具有函数重载功能，以此来区分不同的函数。 .so 动态库、.a 静态库和 .o 中间文件的关系 程序的运行都要经过编译和链接两个步骤。假如有文件 add.c，可以使用命令 gcc -c add.c 进行编译，生成 add.o 中间文件，使用命令 ar -r libadd.a add.o 可以生成 libadd.a 静态库文件。静态库文件其实就是对 .o 中间文件进行的封装，使用 nm libadd.a 命令可以查看其中封装的中间文件以及函数符号。 链接静态库就是链接静态库中的 .o 文件，这和直接编译多个文件再链接成可执行文件一样。 动态链接库是程序执行的时候直接调用的“插件”，使用命令 gcc -shared -o libadd.so add.c 生成 so 动态库。动态库链接的时候可以像静态库一样链接，告诉编译器函数的定义在这个静态库中（避免找不到函数定义的错误），只是不把这个 so 打包到可执行文件中。如果没有头文件的话，可以使用 dlopen/dlsum 函数手动去加载相应的动态库。详细做法参考上一篇文章《C语言调用so动态库的两种方式》。 ar nm 命令的详细解释功能说明：建立或修改备存文件，或是从备存文件中抽取文件。 语 法：ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件] 补充说明：ar 可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。 参 数： 123456789101112131415161718192021# 指令参数 -d 删除备存文件中的成员文件。 -m 变更成员文件在备存文件中的次序。 -p 显示备存文件中的成员文件内容。 -q 将问家附加在备存文件末端。 -r 将文件插入备存文件中。 -t 显示备存文件中所包含的文件。 -x 自备存文件中取出成员文件。# 选项参数 a&lt;成员文件&gt; 将文件插入备存文件中指定的成员文件之后。 b&lt;成员文件&gt; 将文件插入备存文件中指定的成员文件之前。 c 建立备存文件。 f 为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。 i&lt;成员文件&gt; 将问家插入备存文件中指定的成员文件之前。 o 保留备存文件中文件的日期。 s 若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。 S 不产生符号表。 u 只将日期较新文件插入备存文件中。 v 程序执行时显示详细的信息。 V 显示版本信息。 ar基本用法ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。 下面是ar命令的格式： 1$ ar [-]&#123;dmpqrtx&#125;[abcfilNoPsSuvV][membername] [count] archive files... 例如我们可以用ar rv libtest.a hello.o hello1.o来生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-‘字符，也可以没有。下面我们来看看命令的操作选项和任选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。 {dmpqrtx} 中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下： d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。 m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用’a’，’b’，或’I’任选项移动到指定的位置。 p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。 q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。’a’，’b’，或’I’任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用’ar s’或ranlib来更新库的符号表索引。 r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 t：显示库的模块表清单。一般只显示模块名。 x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。 下面在看看可与操作选项结合使用的任选项： a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。 b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。 c：创建一个库。不管库是否存在，都将创建。 f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。 i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。 l：暂未使用 N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。 o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。 P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。 s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。 S：不创建目标文件索引，这在创建较大的库时能加快时间。 u：一般说来，命令ar r…插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。 v：该选项用来显示执行操作选项的附加信息。 V：显示ar的版本。 nm基本用法命令nm用来列出目标文件的符号清单。下面是nm命令的格式： 1nm [-a|--debug-syms][-g|--extern-only] [-B][-C|--demangle] [-D|--dynamic][-s|--print-armap][-o|--print-file-name][-n|--numeric-sort][-p|--no-sort][-r|--reverse-sort] [--size-sort][-u|--undefined-only] [-l|--line-numbers][--help][--version][-t radix|--radix=radix][-P|--portability][-f format|--format=format][--target=bfdname][objfile...] 如果没有为 nm 命令指出目标文件，则 nm 假定目标文件是a.out。下面列出该命令的任选项，大部分支持”-“开头的短格式和”—“开头的长格式。 -A、-o或–print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。 例如nm libtest.a的输出如下： 1234567891011121314CPThread.o:00000068 T Main__8CPThreadPv00000038 T Start__8CPThread00000014 T _._8CPThread00000000 T __8CPThread00000000 ? __FRAME_BEGIN__.......................................# 则nm -A 的输出如下：libtest.a:CPThread.o:00000068 T Main__8CPThreadPvlibtest.a:CPThread.o:00000038 T Start__8CPThreadlibtest.a:CPThread.o:00000014 T _._8CPThreadlibtest.a:CPThread.o:00000000 T __8CPThreadlibtest.a:CPThread.o:00000000 ? __FRAME_BEGIN__.................................................................. -a或–debug-syms：显示调试符号。 -B：等同于–format=bsd，用来兼容MIPS的nm。 -C或–demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。 -D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。 -f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。 -g或–extern-only：仅显示外部符号。 -n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。 -p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。 -P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。 -s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。 -r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。 –size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。 -t radix或–radix=radix：使用radix进制显示符号值。radix只能为”d”表示十进制、”o”表示八进制或”x”表示十六进制。 –target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。 -u或–undefined-only：仅显示没有定义的符号(那些外部符号)。 -l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。 -V或–version：显示nm的版本号。 –help：显示nm的任选项。","categories":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/categories/Program-C/"}],"tags":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/tags/Program-C/"}]},{"title":"Linux系统编程","slug":"Program-C/Linux系统编程基础","date":"2016-05-01T02:14:50.000Z","updated":"2019-06-10T08:15:45.023Z","comments":true,"path":"2016/05/01/Program-C/Linux系统编程基础/","link":"","permalink":"http://miaopei.github.io/2016/05/01/Program-C/Linux系统编程基础/","excerpt":"Linux Note C 语言之解析局部变量返回一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。 准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。","text":"Linux Note C 语言之解析局部变量返回一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。 准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。 1. Linux 基础命令 stat命令用于显示文件的状态信息。stat命令的输出信息比 ls 命令的输出信息要更详细。 1.0 创建用户创建用户命令两条： adduser useradd 用户删除命令： userdel 两个用户创建命令之间的区别： adduser： 会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。 useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。 12345678910111213141516171819202122232425262728# 使用 adduser$ adduser apple正在添加用户\"apple\"...正在添加新组\"apple\" (1007)...正在添加新用户\"apple\" (1007) 到组\"apple\"...创建主目录\"/home/apple\"...正在从\"/etc/skel\"复制文件...输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码正在改变 apple 的用户信息请输入新值，或直接敲回车键以使用默认值 全名 []: 房间号码 []: 工作电话 []: 家庭电话 []: 其它 []: 这些信息是否正确？ [Y/n] y# 这样在创建用户名时，就创建了用户的主目录以及密码。# 默认情况下：# adduser在创建用户时会主动调用 /etc/adduser.conf；# 在创建用户主目录时默认在/home下，而且创建为 /home/用户名 # 如果主目录已经存在，就不再创建，但是此主目录虽然作为新用户的主目录，而且默认登录时会进入这个目录下，但是这个目录并不是属于新用户，当使用userdel删除新用户时，并不会删除这个主目录，因为这个主目录在创建前已经存在且并不属于这个用户。# 为用户指定shell版本为：/bin/bash 因此 adduser 常用参数选项为： --home： 指定创建主目录的路径，默认是在/home目录下创建用户名同名的目录，这里可以指定；如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。 --quiet： 即只打印警告和错误信息，忽略其他信息。 --debug： 定位错误信息。 --conf： 在创建用户时使用指定的configuration文件。 --force-badname： 默认在创建用户时会进行/etc/adduser.conf中的正则表达式检查用户名是否合法，如果想使用弱检查，则使用这个选项，如果不想检查，可以将/etc/adduser.conf中相关选项屏蔽。 12# 使用 useradd# 注意： 在使用useradd命令创建新用户时，不会为用户创建主目录，不会为用户指定shell版本，不会为用户创建密码。 为用户指定参数的 useradd 命令，常用命令行选项： -d： 指定用户的主目录 -m： 如果存在不再创建，但是此目录并不属于新创建用户；如果主目录不存在，则强制创建； -m和-d一块使用。 -s： 指定用户登录时的shell版本 -M： 不创建主目录 12345678# 解释： # -d “/home/tt\" ：就是指定/home/tt为主目录# -m 就是如果/home/tt不存在就强制创建# -s 就是指定shell版本 $ sudo useradd -d \"/home/tt\" -m -s \"/bin/bash\" tt# 修改 tt 密码：$ sudo passwd tt 删除用户命令 userdel 只删除用户： sudo userdel 用户名 连同用户主目录一块删除： sudo userdel -r 用户名 相关文件： /etc/passwd - 使 用 者 帐 号 资 讯，可以查看用户信息 /etc/shadow - 使 用 者 帐 号 资 讯 加 密 /etc/group - 群 组 资 讯 /etc/default/useradd - 定 义 资 讯 /etc/login.defs - 系 统 广 义 设 定 /etc/skel - 内 含 定 义 档 的 目 录 为组用户增加 root 权限： 12345# 修改 /etc/sudoers 文件，找到下面一行，在 root 下面添加一行，如下所示：## Allow root to run any commands anywhereroot ALL=(ALL) ALLtommy ALL=(ALL) ALL# 修改完毕，现在可以用 tommy 帐号登录，然后用命令 sudo – ，即可获得 root 权限进行操作。 1.1 ln 软硬链接硬链接 硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。可以用: ln 命令来建立硬链接。 尽管硬链接节省空间，也是Linux系统整合文件系统的传统方式，但是存在一下不足之处： （1）不可以在不同文件系统的文件间建立链接 （2）只有超级用户才可以为目录创建硬链接。 软链接（符号链接） 软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。建立软链接，只要在 ln 后面加上选项 –s 12$ ln -s abc cde # 建立 abc 的软连接$ ln abc cde # 建立 abc 的硬连接， 删除链接 12$ rm -rf symbolic_name$ unlink symbolic_name 1.2 find grep xargs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# 列出当前目录及子目录下所有文件和文件夹$ find .# 在/home目录下查找以.txt结尾的文件名 但忽略大小写$ find /home -iname \"*.txt\"# 当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件$ find . \\( -name \"*.txt\" -o -name \"*.pdf\" \\)$ find . -name \"*.txt\" -o -name \"*.pdf\"# 匹配文件路径或者文件$ find /usr/ -path \"*local*\"# 基于正则表达式匹配文件路径$ find . -regex \".*\\(\\.txt\\|\\.pdf\\)$\"# 同上，但忽略大小写$ find . -iregex \".*\\(\\.txt\\|\\.pdf\\)$\"# 找出/home下 不是 以 .txt 结尾的文件$ find /home ! -name \"*.txt\"# 根据文件类型进行搜索# 类型参数列表：# f 普通文件# l 符号连接# d 目录# c 字符设备# b 块设备# s 套接字# p Fifo$ find . -type 类型参数# 基于目录深度搜索 向下最大深度限制为3$ find . -maxdepth 3 -type f# 搜索出深度距离当前目录至少2个子目录的所有文件$ find . -mindepth 2 -type f# 根据文件时间戳进行搜索# UNIX/Linux文件系统每个文件都有三种时间戳：# - 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。# - 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。# - 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。$ find . -type f 时间戳# 搜索最近七天内被访问过的所有文件$ find . -type f -atime -7# 搜索恰好在七天前被访问过的所有文件$ find . -type f -atime 7# 搜索超过七天内被访问过的所有文件$ find . -type f -atime +7# 搜索访问时间超过10分钟的所有文件$ find . -type f -amin +10# 找出比 file.log 修改时间更长的所有文件$ find . -type f -newer file.log# 根据文件大小进行匹配# 文件大小单元：# b —— 块（512字节）# c —— 字节# w —— 字（2字节）# k —— 千字节# M —— 兆字节# G —— 吉字节$ find . -type f -size 文件大小单元# 搜索大于10KB的文件$ find . -type f -size +10k# 搜索小于10KB的文件$ find . -type f -size -10k# 搜索等于10KB的文件$ find . -type f -size 10k# 删除匹配文件 删除当前目录下所有.txt文件$ find . -type f -name \"*.txt\" -delete# 根据文件权限/所有权进行匹配 当前目录下搜索出权限为777的文件$ find . -type f -perm 777# 找出当前目录下权限不是644的php文件$ find . -type f -name \"*.php\" ! -perm 644# 找出当前目录用户tom拥有的所有文件$ find . -type f -user tom# 找出当前目录用户组sunk拥有的所有文件$ find . -type f -group sunk# 借助-exec选项与其他命令结合使用 # 找出当前目录下所有root的文件，并把所有权更改为用户tom# &#123;&#125; 用于与 -exec 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。$ find .-type f -user root -exec chown tom &#123;&#125; \\;# 找出自己家目录下所有的.txt文件并删除# -ok 和 -exec 行为一样，不过它会给出提示，是否执行相应的操作。$ find $HOME/. -name \"*.txt\" -ok rm &#123;&#125; \\;# 查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中$ find . -type f -name \"*.txt\" -exec cat &#123;&#125; \\;&gt; all.txt# 将30天前的.log文件移动到old目录中$ find . -type f -mtime +30 -name \"*.log\" -exec cp &#123;&#125; old \\;# 找出当前目录下所有.txt文件并以 “File:文件名” 的形式打印出来$ find . -type f -name \"*.txt\" -exec printf \"File: %s\\n\" &#123;&#125; \\;# 因为单行命令中 -exec 参数中无法使用多个命令，以下方法可以实现在 -exec 之后接受多条命令$ -exec ./text.sh &#123;&#125; \\;# 搜索但跳出指定的目录# 查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk$ find . -path \"./sk\" -prune -o -name \"*.txt\" -print# find其他技巧收集# 要列出所有长度为零的文件$ find . -empty# -exec 接收 find 传过来的所有内容，容易造成溢出# xargs find 的好伴侣，xargs 将 find 命令查找的结果分成若干模块输出给后面的指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# grep 内容过滤# 在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：$ grep match_pattern file_name$ grep \"match_pattern\" file_name# 输出除之外的所有行 -v 选项：$ grep -v \"match_pattern\" file_name# 标记匹配颜色 --color=auto 选项：$ grep \"match_pattern\" file_name --color=auto# 使用正则表达式 -E 选项：$ grep -E \"[1-9]+\"$ egrep \"[1-9]+\"# 只输出文件中匹配到的部分 -o 选项：$ echo this is a test line. | grep -o -E \"[a-z]+\\.\"line.$ echo this is a test line. | egrep -o \"[a-z]+\\.\"line.# 统计文件或者文本中包含匹配字符串的行数 -c 选项：$ grep -c \"text\" file_name# 输出包含匹配字符串的行数 -n 选项：$ grep \"text\" -n file_name$ cat file_name | grep \"text\" -n# 搜索多个文件并查找匹配文本在哪些文件中：$ grep -l \"text\" file1 file2 file3...# 在多级目录中对文本进行递归搜索：$ grep \"text\" . -r -n# 忽略匹配样式中的字符大小写：$ echo \"hello world\" | grep -i \"HELLO\"# 选项 -e 制动多个匹配样式：$ echo this is a text line | grep -e \"is\" -e \"line\" -oisline# 也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。cat patfileaaabbb$ echo aaa bbb ccc ddd eee | grep -f patfile -o# 在grep搜索结果中包括或者排除指定文件：# 只在目录中所有的.php和.html文件中递归搜索字符\"main()\"$ grep \"main()\" . -r --include *.&#123;php,html&#125;# 在搜索结果中排除所有README文件$ grep \"main()\" . -r --exclude \"README\"# 在搜索结果中排除filelist文件列表里的文件$ grep \"main()\" . -r --exclude-from filelist# 使用0值字节后缀的grep与xargs：# 测试文件：$ echo \"aaa\" &gt; file1$ echo \"bbb\" &gt; file2$ echo \"aaa\" &gt; file3$ grep \"aaa\" file* -lZ | xargs -0 rm# 执行后会删除 file1 和 file3，grep 输出用 -Z 选项来指定以 0 值字节作为终结符文件名（\\0），xargs -0 读取输入并用 0 值字节终结符分隔文件名，然后删除匹配文件，-Z 通常和 -l 结合使用。# grep静默输出：# 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。$ grep -q \"test\" filename# 打印出匹配文本之前或者之后的行：# 显示匹配某个结果 之后的3行，使用 -A 选项：$ seq 10 | grep \"5\" -A 3# 显示匹配某个结果 之前的3行，使用 -B 选项：$ seq 10 | grep \"5\" -B 3# 显示匹配某个结果的 前三行和后三行，使用 -C 选项：$ seq 10 | grep \"5\" -C 3 12345678910111213141516# xargs# 参数：-a file 从文件中读入作为sdtin-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。-p 当每次执行一个argument的时候询问一次用户。-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。-t 表示先打印命令，然后再执行。-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 &#123;&#125;，可以用 &#123;&#125; 代替。-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。-L num 从标准输入一次读取 num 行送给 command 命令。-l 同 -L。-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。-x exit的意思，主要是配合-s使用。。-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。 1.3 VIM设置 ~/.bashrc 添加 set -o vi – 可以直接使用 vim 的各种快捷键 VIM 快捷键： 1.4 GCCgcc 工作流程 123456789101112131415# 预处理 头文件展开 宏替换$ gcc -E hello.chello.i# 生成汇编代码$ gcc -S hello.ihello.s# 将汇编编译成二进制文件 $ gcc -c hell0.shello.o# 链接$ gcc hello.oa.out gcc 参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 指定编译输出的名字$ gcc main.c -o main# 通过 -Wall 参数启用所有警告$ gcc -Wall main.c -o main# 使用 -E 参数只产生预处理输出$ gcc -E main.c &gt; main.i# 使用 -S 参数只产生汇编代码$ gcc -S main.c &gt; main.s# 使用 -C 参数只产生编译的代码$ gcc -C main.c# 上面的代码产生main.o, 包含机器级别的代码或者编译的代码。# 使用-save-temps参数产生所有的中间步骤的文件$ gcc -save-temps main.c$ lsa.out main.c main.i main.o main.s# 使用 -l 参数链接共享库$ gcc -Wall main.c -o main -lCPPfile# 使用 -fPIC 产生位置无关的代码# 当产生共享库的时候，应该创建位置无关的代码，这会让共享库使用任意的地址而不是固定的地址，要实现这个功能，需要使用-fPIC参数。# 下面的例子产生libCfile.so动态库。$ gcc -c -Wall -Werror -fPIC Cfile.c$ gcc -shared -o libCfile.so Cfile.o# 产生共享库的时候使用了-fPIC 参数。# 注意 -shared 产生共享库。# 使用 -V 打印所有的执行命令$ gcc -Wall -v main.c -o mainUsing built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/4.6/lto-wrapper...# 使用 -D 参数可以使用编译时的宏$ gcc -Wall -D MY_MACRO main.c -o main# 使用 -Werror 将警告升级为错误$ gcc -Wall -Werror main.c -o main# 使用 @ 参数从文件中读取参数# gcc参数可以从文件中读取，通过@后跟文件名的方式提供， 多个参数可以使用空格区隔。$ cat opt_file -Wall -omain$ gcc main.c @opt_file# 使用参数 -I 指定头文件的文件夹$ gcc -I/home/codeman/include input-file.c# -I 取消前一个参数功能，一般用在 -Idir 之后。# 使用参数-std指定支持的c++/c的标准$ gcc -std=c++11 hello-world.cpp# 使用 -static 生成静态链接的文件 静态编译文件(把动态库的函数和其它依赖都编译进最终文件)$ gcc main.c -static -o main -lpthread# 相反的使用 -shared 使用动态库链接。# 使用 -g 用于 gdb 调试$ gcc main.c -static -o main -g# -lstdc++ 指定 gcc 以 c++ 方式编译$ gcc main.cpp -lstdc++ -o main# -O 优化选项， 1-3 越高优先级越高$ gcc main.cpp -lstdc++ -o main -O1# 使用 -M 生成文件关联的信息$ gcc -M main.cmain.o: main.c /usr/include/stdc-predef.h /usr/include/stdio.h \\ /usr/include/features.h /usr/include/sys/cdefs.h \\ /usr/include/bits/wordsize.h /usr/include/gnu/stubs.h \\ /usr/include/gnu/stubs-64.h \\ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h \\ /usr/include/bits/types.h /usr/include/bits/typesizes.h \\ /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \\ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdarg.h \\ /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h 1.5 库文件制作静态库制作和使用 123456789101112131415161718# 步骤# 1. 编译为 .o 文件# 2. 将 .o 文件打包：ar rcs libmycalc.a file1.0 file2.o ...# 3. 将头文件与库一起发布# 查看库信息$ nm libmycalc.a# 使用# 编译时 需要加静态库名（记得路径），-I 包含头文件$ gcc main.c -o app -I include/ -L lib/ -lmycalc# 优点：# 1. 执行快# 2. 发布应用时不需要发布库# 缺点：# 1. 执行程序体积比较大# 2. 库变更时需要重新编译应用 动态库制作和使用 123456789101112131415161718192021222324# 步骤# 1. 编译与位置无关的代码，生成 .o 关键参数 -fPIC# 2. 将 .o 文件打包， 关键参数 -shared# 3. 将库与头文件一起发布$ gcc -shared -o libcalc.so *.o# 使用# -L 指定动态库路径 -I 指定库名$ gcc main.c -o app -I include/ -L lib/ -lcalc# ldd 查看库依赖$ ldd libcalc.so# 优点：# 1. 执行程序体积小# 2. 库变更时，一般不需要重新发布动态库# 缺点：# 1. 执行时需要加载动态库，相对而言，比静态库慢# 2. 发布应用时需要同时发布动态库# 解决不能加载动态库的问题# 1. 拷贝到 /lib 下。 一般不允许# 2. 将库路径增加到环境变量 LD_LIBRARY_PATH 中，不是特别推荐# 3. 配置 /etc/ld.so.conf 文件，增加 当前项目库路径，执行 sudo ldconfig -v 1.6 Makefilemakefile 的三要素： 目标 依赖 规则命令 写法： 目标：依赖 tab键 规则命令 12app: main.c add.c sub.c div.c mul.c gcc -o app -I./include/ main.c add.c sub.c div.c mul.c 如果更改其中一个文件，所有的源码都重新编译 可以考虑编译过程分解，先生成 .o 文件，然后使用 .o 文件编程结果 规则是递归的，依赖文件如果比目标文件新，则重新生成目标文件 1234567891011121314ObjFiles=main.o add.o sub.o div.o mul.oapp: $(ObjFiles) gcc -o app -I./include/ $(ObjFiles)main.o: main.c gcc -c main.c -I./include/add.o: add.c gcc -c add.c -I./include/ sub.o: sub.c gcc -c sub.c -I./include/ div.o: div.c gcc -c div.c -I./include/mul.o: mul.c gcc -c mul.c -I./include/ makefile 的隐含规则：默认处理第一个目标 123456789# get all .c filesSrcFiles=$(wildcard *.c)# all .c files --&gt; .o fileObjFiles=$(patsubst %.c,%.o,$(SrcFiles))test: echo $(SrcFiles) echo $(ObjFiles) makefile 变量： $@ 代表目标 $^ 代表全部依赖 $&lt; 第一个依赖 $? 第一个变化的依赖 1234567891011121314151617181920212223# get all .c filesSrcFiles=$(wildcard *.c)# all .c files --&gt; .o fileObjFiles=$(patsubst %.c,%.o,$(SrcFiles))all:app# 目标文件用法 $(Var)app: $(ObjFiles) gcc -o $@ -I./include/ $(ObjFiles) # 模式匹配规则， $@ $&lt; 这样的变量，只能在规则中出现%.o:%.c gcc -c $&lt; -I./include/ -o $@# @ 在规则前代表不输出该条规则的命令# - 规则前的“-”，代表该条规则报错，仍然继续执行# .PHONY 定义伪目标，防止有歧义.PHONY:clean allclean: -@rm -f *.o -@rm -f app make -f makefile1 指定makefile文件进行编译 12345678910SrcFiles=$(wildcard *.c)TargetFiles=$(patsubst %.c,%,$(SrcFiles))all:$(TargetFiles)%:%.c gcc -o $@ %^ clean: rm -f $(TargetFiles) 1.7 gdb 调试 gdb 调试入门，大牛写的高质量指南 gdb 调试利器 启动gdb：gdb app 在gdb启动程序： r(un) – 启动 可以带参数启动 start – 启动 - 停留在main函数，分步调试 n(ent) – 下一条指令 s(tep) – 下一条指令，可以进入函数内部，库函数不能进 q(uit) – 退出 gdb b(reak) num – 指定行号，函数, 文件:行号 设置断点 b 行号 – 主函数所在文件的行 b 函数名 b 文件名:行号 l(ist) 文件：行号 – 查看代码 l – 显示主函数对应的文件 l 文件名:行号 info b – 查看断点信息 d(el) num – 删除断点 c – continue 跳到下一个断点 p(rint) – 打印参数，或者变量值 ptype 变量 – 查看变量类型 set – 设置变量的值 set argc=4 set argv[1]=“12” set argv[2] = “7” display argc – 跟踪显示参数或者变量的变化 info display undisplay num b num if xx == xx – 条件断点 gdb跟踪core 设置生成 core ：ulimit -c unlimited 取消生成 core： ulimit -c 0 设置 core 文件格式：/proc/sys/kernel/core_pattern 文件不能 vi，可以用后面的套路：echo “/corefile/core-%e-%p-%t” &gt; core_pattern core 文件如何使用： gdb app core 如果看不到在哪儿core 可以用 where 查看在哪儿产生的 core 2. 系统api与库函数的关系 3. Linux 系统编程ulimit -a 查看所有资源的上限 env 查看环境变量 echo $PATH 打印指定的环境变量 char *getenv() 获取环境变量 创建一个进程： pid_t fork(void) 返回值： 失败 -1 成功，返回两次 父进程返回子进程的 id 子进程返回 0 获得pid，进程 id，获得当前进程 pid_t getpid(void) 获得当前进程父进程的 id pid_t getppid(void) ps ajx 查看父进程和子进程相关信息 进程共享： 父子进程之间在fork后，有哪些相同和不同： 父子相同处： 全局变量 data、text、栈、堆、环境变量 用户 ID 宿主目录、进程工作目录、信号处理方式… 父子不同处： 进程 ID 父进程 ID 进程运行时间 闹钟（定时器） 未决信号集 似乎，子进程复制了父进程 0-3G 用户空间内容，以及父进程的 PCB， 但 pid 不同。真的每 fork 一个子进程都要将父进程的 0-3G 地址空间完全拷贝一份，然后在映射至屋里内存吗？当然不是，父子进程间遵循读时共享写时复制。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。 孤儿进程与僵尸进程： 孤儿进程 父进程死了，子进程被 init 进程领养 僵尸进程 子进程死了，父进程没有回收子进程的资源（PCB） 回收子进程，知道子进程的死亡原因，作用： 阻塞等待 回收子进程资源 查看死亡原因 pid_t wait(int *status) status 传出参数 返回值 成功返回终止的子进程 ID 失败 返回 -1 子进程的死亡原因： 正常死亡 WIFEXITED 如果 WIFEXITED 为真，使用 WEXITSTATUS 得到退出的状态 非正常死亡 WIFSIGNALED 如果 WIFSIGNALED 为真，使用 WTERMSIG 得到信号 pid_t waitpid(pid_t pid, int *status, int options) pid &lt; -1 组ID -1 回收任意 0 回收和调用进程组 ID 相同组内的子进程 &gt;0 回收指定的 pid option 0 与 wait 相同，也会阻塞 WNOHANG 如果当前没有子进程退出，会立刻返回 返回值 如果设置了 WNOHANG ，那么如果没有子进程退出，返回 0 如果有子进程退出返回退出的 pid 失败返回 -1 （没有子进程） 3.1 IPC 概念IPC ： 进程间通信，通过内核提供的缓存区进行数据交换的机制 IPC 通信的方式有几种： pipe 管道 – 最简单 fifo 有名管道 mmap 文件映射共享IO – 速度最快 本地 socket 最稳定 信号 携带信息量最小 共享内存 消息队列 读管道： 写端全部关闭 – read 读到 0， 想当于读到文件末尾 写端没有全部关闭 有数据 – read 读到数据 没有数据 – read 阻塞 fcntl 函数可以更改非阻塞 写管道： 读端全部关闭 – ？ 产生一个信号 SIGPIPE，程序异常终止 读端未全部关闭 管道已满 – write 阻塞 – 如果要显示现象，读端一直不读，写端狂写。 管道未满 – write 正常写入 管道缓冲区大小 可以使用 ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为： 1pipe size (512 bytes, -p) 8 也可以使用 fpathconf 函数，借助参数选项来查看。使用该宏应引入头文件&lt;unistd.h&gt; long fpathconf(int fd, int name); 成功：返回管道的大小 失败：-1，设置errno 管道的优劣 优点： 简单，相比信号，套接字实现进程间通信，简单很多。 缺点： 只能单向通信，双向通信需建立两个管道。 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。 FIFO通信 FIFO 有名管道，实现无血缘关系进程通信 创建一个管道的伪文件 mkfifo myfifo 命令创建 也可以使用函数 int mkfifo(const char *pathname, mode_t mode); 内核会针对 fifo 文件开辟一个缓存区，操作 fifo 文件，可以操作缓存区，实现进程间通信 – 实际上就是文件读写 mmap映射共享区 1void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); 返回： 成功：返回创建的映射区首地址； 失败：MAP_FAILED宏 参数： addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL length： 欲创建映射区的大小 prot： 映射区权限 PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE flags： 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区) MAP_SHARED: 会将映射区所做的操作反映到物理设备（磁盘）上。（共享的） MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。（私有的） fd： 用来建立映射区的文件描述符 offset： 映射文件的偏移(4k的整数倍) 释放映射区 1int munmap(void *addr, size_t length); 匿名映射 通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。 使用 MAP_ANONYMOUS(或 MAP_ANON )， 如: 12int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0); // \"4\"随意举例，该位置表大小，可依实际需要填写。 需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。 123456/*/dev/zero 聚宝盆，可以随意映射/dev/null 无底洞，一般错误信息重定向到这个文件中*/fd = open(\"/dev/zero\", O_RDWR);p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0); 信号的概念 信号的特点 简单，不能带大量信息，满足特定条件发生 信号的机制 进程 B 发送给进程 A ，内核产生信号，内核处理 信号的产生 按键产生 函数调用 kill、raise、abort 定时器 alarm、setitimer 命令产生 kill 硬件异常、段错误、浮点型错误、总线错误、SIGPIPE 信号的状态 产生 递达 信号到达并且处理完 未决 信号被阻塞 信号的默认处理方式 忽略 执行默认动作 捕捉 信号的 4 要素 编号 事件 名称 默认处理动作 忽略 终止 终止 + core 暂停 继续 3.2 进程和线程 进程组 会话 守护进程 创建一个会话需要注意以下 5 点注意事项： 调用进程不能是进程组组长，该进程编程新会话首进程（session header） 该进程成为一个新进程组的组长进程 新会话丢弃原有的控制终端，该会话没有控制终端 该调用进程是组长进程，则出错返回 建立会话时，先调用fork，父进程终止，子进程调用 setsid 守护进程： Daemon 进程，是 Linux 中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。 创建守护进程，最关键的一步是调用 setsid 函数创建一个新的 session 。并成为 session leader。 创建守护进程模型： 创建子进程，父进程退出 所有工作在子进程中进行形式上脱离了控制终端 在子进程中创建新会话 setsid() 函数 使子进程完全能独立出来，脱离控制 改变当前目录为根目录 chdir() 函数 防止占用可卸载的文件系统 也可以换成其他路径 重设文件权限掩码 umask() 函数 防止继承的文件创建屏蔽字拒绝某些权限 增加守护进程灵活性 关闭文件描述符 继承的打开文件不会用到，浪费系统资源，无法卸载 开始执行守护进程核心工作 守护进程退出处理程序模型 会话：进程组的更高一级，多个进程组对应一个会话 进程组：多个进程在同一个组，第一个进程默认是进程组的组长 创建会话的时候，组长不可以创建，必须是组员创建。 创建会话的步骤：创建子进程，父进程终止，子进程当会长 守护进程的步骤： 创建子进程 fork 父进程退出 子进程当会长 setsid 切换工作目录 $HOME 设置掩码 umask 关闭文件描述符，为了避免浪费资源 执行核心逻辑 退出 12int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;signal.h&gt;int main(int argc, char *argv[])&#123; char strFileName[256] = &#123;0&#125;; while (1) &#123; memset(strFileName, 0x00, sizeof(strFileName)); sprintf(strFileName, \"%s/log/Mr.Miaow.%ld\", getenv(\"HOME\"), time(NULL)); int fd = open(strFileName, O_RDWR | O_CREAT, 0666); if (fd &lt; 0) &#123; perror(\"open err\"); exit(1); &#125; close(fd); sleep(5); &#125; return 0;&#125; 扩展了解： 通过 nohup 指令也可以达到守护进程创建的效果 nohup cmd [&gt; 1.log] &amp; nohup 指令会让 cmd 收不到 SIGHUP 信号 &amp; 代表后台运行 线程是最小的执行单位，进程是最小的系统资源分配单位 查看 LWP 号：ps -Lf pid 查看指定线程的 lwp 号 线程非共享资源 线程 ID 处理器现场和栈指针（内核栈） 独立的栈空间（用户空间栈） errno 变量 信号屏蔽字 调度优先级 线程优缺点： 优点： 提高程序并发性 开销小 数据通信、共享数据方便 缺点： 库函数 不稳定 调试、编写困难 对信号支持不好 1234567891011alias echomake=`cat ~/bin/makefile.template &gt;&gt; makefile`$ cat ~/bin/makefile.template# create by Mr.Miaow `date +%Y%m%d`SrcFiles=$(wildcard *.c)TargetFiles=$(patsubst %.c,%,$(SrcFiles))all:$(TargetFiles)%:%.c gcc -o $@ %&lt; -lpthread -gclean: -rm -f $(TargetFiles) 线程退出注意事项： 在线程中使用pthread_exit 在线程中使用 return （主控线程return 代表退出进程） exit 代表退出整个进程 线程回收函数： 1int pthread_join(pthread_t thread, void **retval); 杀死线程： 1int pthread_cancel(pthread_t thread); 被pthread_cancel 杀死的线程，退出状态为 PTHREAD_CANCELED 线程分离： 1int pthread_detach(pthread_t thread); 此时不需要 pthread_join回收资源 线程 ID 在进程内部是唯一的 进程属性控制： 初始化线程属性 1int pthread_attr_init(pthread_attr_t *attr); 销毁线程属性 1int pthread_attr_destroy(pthread_attr_t *attr); 设置属性分离态 1234567int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);# attr init 初始化的属性# detachstate# - PTHREAD_CREATE_DETACHED 线程分离# - PTHREAD_CREATE_JOINABLE 允许回收int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); 查看线程库版本： 1$ getconf GNU_LIBPTHREAD_VERSION 创建多少个线程？ cpu核数 * 2 + 2 线程同步： 协调步骤，顺序执行 解决同步的问题：加锁 mutex 互斥量： 123456789pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER; // 常量初始化，此时可以使用initpthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);int pthread_mutex_destroy(pthread_mutex_t *mutex); 读写锁的特点：读共享，写独占，写优先级高 读写说任然是一把锁，有不同状态： 未加锁 读锁 写锁 123456789int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 条件变量（生产者消费者模型）： 1234567891011pthread_cond_t cond = PTHREAD_COND_INITIALIZER;int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);// 唤醒至少一个阻塞在条件变量 cond 上的线程int pthread_cond_signal(pthread_cond_t *cond);// 唤醒阻塞在条件变量 cond 上的全部线程int pthread_cond_broadcast(pthread_cond_t *cond);// 条件变量阻塞等待int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);// 超时等待int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);int pthread_cond_destroy(pthread_cond_t *cond); 信号量 加强版的互斥锁： 信号量是进化版的互斥量，允许多个线程访问共享资源 1234567891011121314151617#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value);# pshared# - 0 代表线程信号量# - 非0 代表进程信号量# value 定义信号量的个数// 申请信号量，申请成功 value--int sem_wait(sem_t *sem);// 释放信号量 value++int sem_post(sem_t *sem);int sem_trywait(sem_t *sem);int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);int sem_destroy(sem_t *sem);// Link with -pthread. 文件锁： 1234#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* arg */ );","categories":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/categories/Program-C/"}],"tags":[{"name":"Program-C","slug":"Program-C","permalink":"http://miaopei.github.io/tags/Program-C/"}]}]}