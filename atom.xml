<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Miaow Blog</title>
  
  <subtitle>天道酬勤，地道酬善，人道酬誠，商道酬信，業道酬精</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://miaopei.github.io/"/>
  <updated>2019-06-11T09:08:50.443Z</updated>
  <id>http://miaopei.github.io/</id>
  
  <author>
    <name>苗沛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FFMpeg实时美颜直播推流</title>
    <link href="http://miaopei.github.io/2019/05/19/FFmpeg/ffmpeg%E5%AE%9E%E6%97%B6%E7%BE%8E%E9%A2%9C%E6%8E%A8%E6%B5%81/"/>
    <id>http://miaopei.github.io/2019/05/19/FFmpeg/ffmpeg实时美颜推流/</id>
    <published>2019-05-19T02:14:50.000Z</published>
    <updated>2019-06-11T09:08:50.443Z</updated>
    
    <content type="html"><![CDATA[<p>实战 - 基于ffmpeg，qt5，opencv视频课程</p><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-直播推流流程分析"><a href="#1-1-直播推流流程分析" class="headerlink" title="1.1 直播推流流程分析"></a>1.1 直播推流流程分析</h3><a id="more"></a><img src="/images/imageFFmpeg/直播.png"><p>rtmp 延时一般 1-3 秒</p><img src="/images/imageFFmpeg/推流流程.png"><h3 id="1-2-直播-rtmp-协议分析"><a href="#1-2-直播-rtmp-协议分析" class="headerlink" title="1.2 直播 rtmp 协议分析"></a>1.2 直播 rtmp 协议分析</h3><img src="/images/imageFFmpeg/协议.png"><img src="/images/imageFFmpeg/传输协议.png"><img src="/images/imageFFmpeg/RTMP.png"><img src="/images/imageFFmpeg/RTMP优缺点.png"><img src="/images/imageFFmpeg/RTMP协议类型.png"><img src="/images/imageFFmpeg/握手.png"><img src="/images/imageFFmpeg/推流.png"><h2 id="2-直播服务器讲解和配置"><a href="#2-直播服务器讲解和配置" class="headerlink" title="2. 直播服务器讲解和配置"></a>2. 直播服务器讲解和配置</h2><img src="/images/imageFFmpeg/流媒体服务器.png"><h3 id="2-1-直播服务器介绍-crtmpserver-编译运行"><a href="#2-1-直播服务器介绍-crtmpserver-编译运行" class="headerlink" title="2.1 直播服务器介绍 crtmpserver 编译运行"></a>2.1 直播服务器介绍 crtmpserver 编译运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-get install wget cmake</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt-get install libssl-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget  https://codeload.github.com/j0sh/crtmpserver/zip/centosinit --no-check-certificate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> unzip centosinit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> builders/cmake</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake . </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./crtmpserver/crtmpserver ./crtmpserver/crtmpserver.lua</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -i test.flv  -f flv rtmp://192.168.1.44/live</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ʹc rtmp://192.168.1.44/live</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ʹplay ffplay rtmp://192.168.1.44/live  -fflags nobuffer</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> error</span></span><br><span class="line">CMake Error at cmake_find_modules/Find_openssl.cmake:99 (MESSAGE):</span><br><span class="line">  Looking for openssl headers - not found</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  CMakeLists.txt:46 (INCLUDE)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -DOPENSSL_ROOT_DIR=/usr/<span class="built_in">local</span>/opt/openssl -DOPENSSL_LIBRARIES=/usr/<span class="built_in">local</span>/opt/openssl/lib</span></span><br></pre></td></tr></table></figure><h3 id="2-2-下载-ffmpeg-工具推流并使用功能-vlc-拉流播放测试"><a href="#2-2-下载-ffmpeg-工具推流并使用功能-vlc-拉流播放测试" class="headerlink" title="2.2 下载 ffmpeg 工具推流并使用功能 vlc 拉流播放测试"></a>2.2 下载 ffmpeg 工具推流并使用功能 vlc 拉流播放测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://nginx.org/download/nginx-1.16.0.tar.gz --no-check-certificate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/arut/nginx-rtmp-module.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --add-module=/home/miaopei/workdir/<span class="built_in">test</span>/ffmpet-test/nginx/nginx-rtmp-module </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/ffmpeg工具推流测试.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx.conf 配置</span></span><br><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4096;</span><br><span class="line">        application live &#123;</span><br><span class="line">            live on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推流命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.mp4 -c copy -f flv rtmp://192.168.2.76/live</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网页查看推流的状态</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    location /stat&#123;</span><br><span class="line">        rtmp_stat all;</span><br><span class="line">        rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">    &#125;</span><br><span class="line">    location /stat.xsl&#123;</span><br><span class="line">        root /home/miaopei/workdir/test/ffmpet-test/nginx/nginx-rtmp-module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reload config:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s reload</span></span><br><span class="line">Reopen Logfile:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s reopen</span></span><br><span class="line">Stop process:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s stop</span></span><br><span class="line">Waiting on exit process</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s quit</span></span><br></pre></td></tr></table></figure><h2 id="3-FFMpeg-SDK-解封和推流"><a href="#3-FFMpeg-SDK-解封和推流" class="headerlink" title="3. FFMpeg SDK 解封和推流"></a>3. FFMpeg SDK 解封和推流</h2><h3 id="3-1-ffmpeg-SDK开发环境准备"><a href="#3-1-ffmpeg-SDK开发环境准备" class="headerlink" title="3.1 ffmpeg SDK开发环境准备"></a>3.1 ffmpeg SDK开发环境准备</h3><img src="/images/imageFFmpeg/使用FFMpegSDK推流.png"><img src="/images/imageFFmpeg/avformat_open_input.png"><img src="/images/imageFFmpeg/AVFormatContext.png"><img src="/images/imageFFmpeg/AVStream.png"><img src="/images/imageFFmpeg/AVPacket.png"><img src="/images/imageFFmpeg/GOP.png"><img src="/images/imageFFmpeg/基于海康或大华相机推流.png"><h2 id="4-OpencvSDK-基础"><a href="#4-OpencvSDK-基础" class="headerlink" title="4. OpencvSDK 基础"></a>4. OpencvSDK 基础</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNjQxOTAvYXJ0aWNsZS9kZXRhaWxzLzc5MTA4NjA4" title="https://blog.csdn.net/u010164190/article/details/79108608">Mac源码安装使用OpenCV<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hcmtzaW0vYXJ0aWNsZS9kZXRhaWxzLzc5MTQ2MzQ2" title="https://blog.csdn.net/marksim/article/details/79146346">在MacOS 10.13.2 下编译 OpenCV3.4.0 + OpenCV Contrib 3.4.0 成 Java 库<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hMzZkNDEyNDFhZTg=" title="https://www.jianshu.com/p/a36d41241ae8">在MacOS上安装OpenCV 3.4(c++)<i class="fa fa-external-link"></i></span></p></blockquote><details><summary>OpenCV 源码编译：</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 OpenCV 3.4.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压，进入到 opencv-3.4.0 目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p build/install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -G <span class="string">"Unix Makefiles"</span> -j8 -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_OSX_ARCHITECTURES=x86_64 -D CMAKE_INSTALL_PREFIX=/Users/miaopei/install/opencv/opencv-3.4.0/build/install ../</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j8</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib/pkgconfig</span><br><span class="line">export PKG_CONFIG_PATH</span><br><span class="line">export LD_LIBRARY_PATH=Users/miaopei/install/opencv/opencv-3.4.0/build/install/bin:SLD_LIBRARY_PATH</span><br><span class="line">export PATH=$&#123;PATH&#125;:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试demo,打印当前版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;opencv2/core/utility.hpp&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;iostream&gt;</span></span><br><span class="line">int main(int argc, const char* argv[])&#123;</span><br><span class="line">  std::cout &lt;&lt; "Welcome to OpenCV " &lt;&lt; CV_VERSION &lt;&lt; std::endl; </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Makefile</span></span><br><span class="line">CXX ?= g++</span><br><span class="line">CXXFLAGS += -c -Wall $(shell pkg-config --cflags opencv)</span><br><span class="line">LDFLAGS += $(shell pkg-config --libs --static opencv)</span><br><span class="line">all: test_version</span><br><span class="line">opencv_example: test_version.o; $(CXX) $&lt; -o $@ $(LDFLAGS)</span><br><span class="line"><span class="meta">%</span><span class="bash">.o: %.cpp; $(CXX) $&lt; -o <span class="variable">$@</span> $(CXXFLAGS)</span></span><br><span class="line">clean: ; rm -f test_version.o test_version</span><br></pre></td></tr></table></figure></details><img src="/images/imageFFmpeg/第一个例子显示图片.png"><img src="/images/imageFFmpeg/waitKey.png"><h3 id="4-1-VideoCapture打开摄像头接口讲解和源码分析"><a href="#4-1-VideoCapture打开摄像头接口讲解和源码分析" class="headerlink" title="4.1 VideoCapture打开摄像头接口讲解和源码分析"></a>4.1 VideoCapture打开摄像头接口讲解和源码分析</h3><img src="/images/imageFFmpeg/打开摄像头接口说明和源码分析.png"><img src="/images/imageFFmpeg/创建和清理mat空间.png"><img src="/images/imageFFmpeg/图像存放方式-连续.png"><img src="/images/imageFFmpeg/isContinuous.png"><img src="/images/imageFFmpeg/直接地址访问连续空间.png"><img src="/images/imageFFmpeg/读取一帧视频.png"><h2 id="5-视频采集编码推流和类封装"><a href="#5-视频采集编码推流和类封装" class="headerlink" title="5. 视频采集编码推流和类封装"></a>5. 视频采集编码推流和类封装</h2><img src="/images/imageFFmpeg/基于opencv采集推流.png"><img src="/images/imageFFmpeg/opencv采集rtsp解码.png"><img src="/images/imageFFmpeg/sws_getCachedContext.png"><img src="/images/imageFFmpeg/sws_scale.png"><img src="/images/imageFFmpeg/avcodec_find_encoder.png"><img src="/images/imageFFmpeg/avcodec_alloc_context3.png"><img src="/images/imageFFmpeg/avcodec_alloc_context3-01.png"><img src="/images/imageFFmpeg/gop-01.png"><img src="/images/imageFFmpeg/avcodec_send_frame.png"><h2 id="6-音频录制编码推流和类封装"><a href="#6-音频录制编码推流和类封装" class="headerlink" title="6. 音频录制编码推流和类封装"></a>6. 音频录制编码推流和类封装</h2><img src="/images/imageFFmpeg/音频.png"><img src="/images/imageFFmpeg/样本类型planar.png"><img src="/images/imageFFmpeg/大小端模式.png"><img src="/images/imageFFmpeg/一帧数据量.png"><p>QT音频录制接口：</p><img src="/images/imageFFmpeg/QAudioFormat.png"><img src="/images/imageFFmpeg/QAudioInput.png"><img src="/images/imageFFmpeg/QIODevice.png"><h2 id="7-音视频同步编码推流处理"><a href="#7-音视频同步编码推流处理" class="headerlink" title="7. 音视频同步编码推流处理"></a>7. 音视频同步编码推流处理</h2><img src="/images/imageFFmpeg/视频录制接口封装.png"><img src="/images/imageFFmpeg/音视频同步.png"><h2 id="8-XRtmpStreamer-项目完成（界面和美颜）"><a href="#8-XRtmpStreamer-项目完成（界面和美颜）" class="headerlink" title="8. XRtmpStreamer 项目完成（界面和美颜）"></a>8. XRtmpStreamer 项目完成（界面和美颜）</h2><p>直播推流要求实时性，一秒钟25帧，做美颜的总耗时一定要低于40ms（每帧消耗40ms）</p><p>现在视频推流一般都是1280 X 720</p><p>手机端是基于GPU 第三方库做的计算</p><p>美颜算法一般都是基于GPU做的</p><img src="/images/imageFFmpeg/使用opencv磨皮.png"><img src="/images/imageFFmpeg/bilateralFilter双边滤波-边缘平滑.png"><img src="/images/imageFFmpeg/自定义过滤器类XFilter.png"><img src="/images/imageFFmpeg/XController.png"><img src="/images/imageFFmpeg/类图.png"><p><strong>头文件尽量不用引用命名空间，因为不知道谁来调用，可能会出现问题</strong>。</p><p><strong>头文件中尽量不要引用第三方库文件，应为涉及到第三方库版本升级之类的，第三方头文件的引用应该在代码中引用</strong>。</p><h2 id="9-补充"><a href="#9-补充" class="headerlink" title="9. 补充"></a>9. 补充</h2><h3 id="9-0-流媒体协议介绍（rtp-rtcp-rtsp-rtmp-mms-hls）"><a href="#9-0-流媒体协议介绍（rtp-rtcp-rtsp-rtmp-mms-hls）" class="headerlink" title="9.0 流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）"></a>9.0 流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）</h3><p><strong>1. RTP</strong>：</p><blockquote><p>参考文档 RFC3550/RFC3551</p></blockquote><p>(Real-time Transport Protocol) 是用于 Internet 上针对多媒体数据流的一种传输层协议。RTP 协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP 协议常用于流媒体系统（配合 RTCP协议），视频会议和一键通（Push to Talk）系统（配合 H.323 或 SIP），使它成为 IP 电话产业的技术基础。<strong>RTP 协议和 RTP 控制协议 RTCP 一起使用</strong>，而且它是建立在 <strong>UDP</strong> 协议上的。</p><p><strong>RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证</strong>，它依赖于低层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。</p><p><strong>RTP 由两个紧密链接部分组成</strong>： </p><ul><li>RTP ― 传送具有实时属性的数据；</li><li>RTP 控制协议（RTCP） ― 监控服务质量并传送正在进行的会话参与者的相关信息。</li></ul><p><strong>2. RTCP</strong></p><p>实时传输控制协议（Real-time Transport Control Protocol 或 RTP Control Protocol 或简写 RTCP）是实时传输协议（RTP）的一个姐妹协议。RTCP 为 RTP 媒体流提供信道外（out-of-band）控制。<strong>RTCP 本身并不传输数据，但和 RTP 一起协作将多媒体数据打包和发送</strong>。RTCP 定期在流多媒体会话参加者之间传输控制数据。RTCP 的主要功能是为 RTP 所提供的服务质量（Quality of Service）提供反馈。</p><p>RTCP 收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等等。网络应用程序可以利用 RTCP 所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP 本身不提供数据加密或身份认证。SRTCP 可以用于此类用途。</p><p><strong>3. SRTP &amp; SRTCP</strong></p><blockquote><p>参考文档 RFC3711</p></blockquote><p>安全实时传输协议（Secure Real-time Transport Protocol 或 SRTP）是在实时传输协议（Real-time Transport Protocol 或 RTP）基础上所定义的一个协议，<strong>旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护</strong>。它是由 David Oran（思科）和 Rolf Blom（爱立信）开发的，并最早由 IETF 于 2004年3月作为 RFC3711 发布。</p><p>由于实时传输协议和可以被用来控制实时传输协议的会话的实时传输控制协议（RTP Control Protocol 或 RTCP）有着紧密的联系，安全实时传输协议同样也有一个伴生协议，它被称为安全实时传输控制协议（Secure RTCP 或 SRTCP）；安全实时传输控制协议为实时传输控制协议提供类似的与安全有关的特性，就像安全实时传输协议为实时传输协议提供的那些一样。</p><p>在使用实时传输协议或实时传输控制协议时，使不使用安全实时传输协议或安全实时传输控制协议是可选的；但即使使用了安全实时传输协议或安全实时传输控制协议，所有它们提供的特性（如加密和认证）也都是可选的，这些特性可以被独立地使用或禁用。唯一的例外是在使用安全实时传输控制协议时，必须要用到其消息认证特性。</p><p><strong>4. RTSP</strong></p><blockquote><p>参考文档 RFC2326</p></blockquote><p>是由 Real Networks 和 Netscape 共同提出的。该协议定义了一对多应用程序如何有效地通过 IP 网络传送多媒体数据。RTSP 提供了一个可扩展框架，使实时数据，如音频与视频的受控、点播成为可能。数据源包括现场数据与存储在剪辑中的数据。<strong>该协议目的在于控制多个数据发送连接，为选择发送通道，如UDP、多播UDP与TCP提供途径，并为选择基于RTP上发送机制提供方法</strong>。</p><p>RTSP（Real Time Streaming Protocol）是用来控制声音或影像的多媒体串流协议，并允许同时多个串流需求控制，传输时所用的网络通讯协定并不在其定义的范围内，服务器端可以自行选择使用 TCP 或 UDP来传送串流内容，它的语法和运作跟 HTTP 1.1 类似，<strong>但并不特别强调时间同步，所以比较能容忍网络延迟</strong>。而前面提到的允许同时多个串流需求控制（Multicast），除了可以降低服务器端的网络用量，更进而支持多方视讯会议（Video Conference）。 因为与 HTTP1.1 的运作方式相似，所以代理服务器《Proxy》的快取功能《Cache》也同样适用于 RTSP，并因 RTSP 具有重新导向功能，可视实际负载情况来转换提供服务的服务器，以避免过大的负载集中于同一服务器而造成延迟。</p><p><strong>5. RTSP 和 RTP 的关系</strong></p><p>RTP 不象 http 和 ftp 可完整的下载整个影视文件，它是以固定的数据率在网络上发送数据，客户端也是按照这种速度观看影视文件，当影视画面播放过后，就不可以再重复播放，除非重新向服务器端要求数据。</p><p>RTSP 与 RTP 最大的区别在于：RTSP 是一种双向实时数据传输协议，它允许客户端向服务器端发送请求，如回放、快进、倒退等操作。当然，RTSP 可基于 RTP 来传送数据，还可以选择 TCP、UDP、组播 UDP 等通道来发送数据，具有很好的扩展性。它是一种类似与 http 协议的网络应用层协议。目前碰到的一个应用：服务器端实时采集、编码并发送两路视频，客户端接收并显示两路视频。由于客户端不必对视频数据做任何回放、倒退等操作，可直接采用 UDP + RTP + 组播实现。</p><img src="/images/imageFFmpeg/RTSP和RTP的关系.png"><p>RTP：实时传输协议（Real-time Transport Protocol） </p><ul><li><p>RTP/RTCP 是实际传输数据的协议 </p></li><li><p>RTP 传输音频/视频数据，如果是 PLAY，Server 发送到 Client 端，如果是 RECORD，可以由Client 发送到 Server </p></li><li><p>整个 RTP 协议由两个密切相关的部分组成：</p><ul><li>RTP数据协议</li><li>RTP控制协议（即RTCP） </li></ul></li></ul><p>RTSP：实时流协议（Real Time Streaming Protocol，RTSP） </p><ul><li><p>RTSP 的请求主要有 DESCRIBE, SETUP, PLAY, PAUSE, TEARDOWN, OPTIONS 等，顾名思义可以知道起对话和控制作用 </p></li><li><p>RTSP 的对话过程中 SETUP 可以确定 RTP/RTCP 使用的端口，PLAY/PAUSE/TEARDOWN 可以开始或者停止 RTP 的发送，等等 </p></li></ul><p>RTCP： </p><ul><li>RTCP 包括 Sender Report 和 Receiver Report，用来进行音频/视频的同步以及其他用途，是一种控制协议</li></ul><p><strong>6. SDP</strong></p><p>会话描述协议（SDP）为会话通知、会话邀请和其它形式的多媒体会话初始化等目的提供了多媒体会话描述。</p><p>会话目录用于协助多媒体会议的通告，并为会话参与者传送相关设置信息。SDP 即用于将这种信息传输到接收端。<strong>SDP 完全是一种会话描述格式 ― 它不属于传输协议 ― 它只使用不同的适当的传输协议，包括会话通知协议（SAP）、会话初始协议（SIP）、实时流协议（RTSP）、MIME 扩展协议的电子邮件以及超文本传输协议（HTTP）</strong>。</p><p>SDP 的设计宗旨是通用性，它可以应用于大范围的网络环境和应用程序，而不仅仅局限于组播会话目录，<strong>但 SDP 不支持会话内容或媒体编码的协商</strong>。</p><p>在因特网组播骨干网（Mbone）中，会话目录工具被用于通告多媒体会议，并为参与者传送会议地址和参与者所需的会议特定工具信息，这由 SDP 完成。SDP 连接好会话后，传送足够的信息给会话参与者。SDP 信息发送利用了会话通知协议（SAP），它周期性地组播通知数据包到已知组播地址和端口处。这些信息是 UDP 数据包，其中包含 SAP 协议头和文本有效载荷（text payload）。这里文本有效载荷指的是 SDP 会话描述。此外信息也可以通过电子邮件或 WWW （World Wide Web） 进行发送。</p><p><strong>SDP 文本信息包括</strong>：</p><ul><li>会话名称和意图；</li><li>会话持续时间；</li><li>构成会话的媒体；</li><li>有关接收媒体的信息（地址等）。</li><li>协议结构</li></ul><p><strong>SDP 信息是文本信息，采用 UTF-8 编 码中的 ISO 10646 字符集。SDP 会话描述如下：（标注 * 符号的表示可选字段）</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v = （协议版本）</span><br><span class="line">o = （所有者/创建者和会话标识符）</span><br><span class="line">s = （会话名称）</span><br><span class="line">i = * （会话信息）</span><br><span class="line">u = * （URI 描述）</span><br><span class="line">e = * （Email 地址）</span><br><span class="line">p = * （电话号码）</span><br><span class="line">c = * （连接信息 ― 如果包含在所有媒体中，则不需要该字段）</span><br><span class="line">b = * （带宽信息）</span><br></pre></td></tr></table></figure><p>一个或更多时间描述（如下所示）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z = * （时间区域调整）</span><br><span class="line">k = * （加密密钥）</span><br><span class="line">a = * （0 个或多个会话属性行）</span><br></pre></td></tr></table></figure><p>0个或多个媒体描述（如下所示）</p><p>时间描述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = （会话活动时间）</span><br><span class="line">r = * （0或多次重复次数）</span><br></pre></td></tr></table></figure><p>媒体描述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = （媒体名称和传输地址）</span><br><span class="line">i = * （媒体标题）</span><br><span class="line">c = * （连接信息 — 如果包含在会话层则该字段可选）</span><br><span class="line">b = * （带宽信息）</span><br><span class="line">k = * （加密密钥）</span><br><span class="line">a = * （0 个或多个会话属性行）</span><br></pre></td></tr></table></figure><p><strong>7. RTMP/RTMPS</strong></p><p>RTMP(Real Time Messaging Protocol) 实时消息传送协议是 Adobe Systems 公司为 Flash 播放器和服务器之间音频、视频和数据传输 开发的开放协议。</p><p>它有三种变种：</p><blockquote><p>1) 工作在 TCP 之上的明文协议，使用端口1935；</p><p>2) RTMPT 封装在 HTTP 请求之中，可穿越防火墙；</p><p>3) RTMPS 类似 RTMPT，但使用的是 HTTPS 连接；</p></blockquote><p>RTMP 协议(Real Time Messaging Protocol)是被 Flash 用于对象, 视频, 音频的传输. <strong>这个协议建立在 TCP 协议或者轮询 HTTP 协议之上</strong>.</p><p>RTMP 协议就像一个用来装数据包的容器, 这些数据既可以是 AMF 格式的数据,也可以是 FLV 中的视/音频数据. 一个单一的连接可以通过不同的通道传输多路网络流. 这些通道中的包都是按照固定大小的包传输的.</p><p><strong>8. mms</strong></p><p>MMS (Microsoft Media Server Protocol)，中文“微软媒体服务器协议”，用来访问并流式接收 Windows Media 服务器中 <code>.asf</code> 文件的一种协议。MMS 协议用于访问 Windows Media 发布点上的单播内容。MMS 是连接 Windows Media 单播服务的默认方法。若观众在 Windows Media Player 中键入一个 URL 以连接内容，而不是通过超级链接访问内容，则他们必须使用MMS 协议引用该流。MMS的预设埠（端口）是1755</p><p>当使用 MMS 协议连接到发布点时，使用协议翻转以获得最佳连接。“协议翻转”始于试图通过 MMSU 连接客户端。 MMSU 是 MMS 协议结合 UDP 数据传送。如果 MMSU 连接不成功，则服务器试图使用 MMST。MMST 是 MMS 协议结合 TCP 数据传送。</p><p>如果连接到编入索引的 <code>.asf</code> 文件，想要快进、后退、暂停、开始和停止流，则必须使用 MMS。不能用 UNC 路径快进或后退。若您从独立的 Windows Media Player 连接到发布点，则必须指定单播内容的 URL。若内容在主发布点点播发布，则 URL 由服务器名和 <code>.asf</code> 文件名组成。例如：<code>mms://windows_media_server/sample.asf</code>。其中 windows_media_server 是 Windows Media 服务器名，sample.asf 是您想要使之转化为流的 <code>.asf</code> 文件名。</p><p>若您有实时内容要通过广播单播发布，则该 URL 由服务器名和发布点别名组成。例如：<code>mms://windows_media_server/LiveEvents</code>。这里 windows_media_server 是 Windows Media 服务器名，而 LiveEvents 是发布点名</p><p><strong>9. HLS</strong></p><p>HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在 iOS 系统，为 iOS 设备（如iPhone、iPad）提供音视频直播和点播方案。HLS 点播，基本上就是常见的分段 HTTP 点播，不同在于，它的分段非常小。</p><p>相对于常见的流媒体直播协议，例如 RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS 协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，<strong>HLS 是以点播的技术方式来实现直播</strong>。由于数据通过 HTTP 协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过 HLS 的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。　</p><p>根据以上的了解要实现 HTTP Live Streaming 直播，需要研究并实现以下技术关键点：</p><ul><li>采集视频源和音频源的数据</li><li>对原始数据进行H264编码和AAC编码</li><li>视频和音频数据封装为MPEG-TS包</li><li>HLS分段生成策略及m3u8索引文件</li><li>HTTP传输协议</li></ul><h3 id="9-1-HLS，RTSP，RTMP的区别"><a href="#9-1-HLS，RTSP，RTMP的区别" class="headerlink" title="9.1 HLS，RTSP，RTMP的区别"></a>9.1 HLS，RTSP，RTMP的区别</h3><ul><li><p>HLS （ HTTP Live Streaming）苹果公司提出的流媒体协议，直接把流媒体切片成一段段，信息保存到m3u列表文件中，可以将不同速率的版本切成相应的片；播放器可以直接使用http协议请求流数据，可以在不同速率的版本间自由切换，实现无缝播放；省去使用其他协议的烦恼。缺点是延迟大小受切片大小影响，不适合直播，适合视频点播。</p></li><li><p>RTSP （Real-Time Stream Protocol）由Real Networks 和 Netscape共同提出的，基于文本的多媒体播放控制协议。RTSP定义流格式，流数据经由RTP传输；RTSP实时效果非常好，适合视频聊天，视频监控等方向。</p></li><li><p>RTMP（Real Time Message Protocol） 有 Adobe 公司提出，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题，优势在于低延迟，稳定性高，支持所有摄像头格式，浏览器加载 flash插件就可以直接播放。</p></li></ul><p>总结：HLS 延迟大，适合视频点播；RTSP虽然实时性最好，但是实现复杂，适合视频聊天和视频监控；RTMP强在浏览器支持好，加载flash插件后就能直接播放，所以非常火，相反在浏览器里播放rtsp就很困难了。</p><h3 id="9-2-RTSP、RTCP、RTP区别"><a href="#9-2-RTSP、RTCP、RTP区别" class="headerlink" title="9.2 RTSP、RTCP、RTP区别"></a>9.2 RTSP、RTCP、RTP区别</h3><p><strong>1：RTSP实时流协议</strong></p><p>作为一个应用层协议，RTSP提供了一个可供扩展的框架，它的意义在于使得实时流媒体数据的受控和点播变得可能。总的说来，RTSP是一个流媒体表示 协议，主要用来控制具有实时特性的数据发送，但它本身并不传输数据，而是必须依赖于下层传输协议所提供的某些服务。RTSP可以对流媒体提供诸如播放、暂 停、快进等操作，它负责定义具体的控制消息、操作方法、状态码等，此外还描述了与RTP间的交互操作（RFC2326）。</p><p><strong>2：RTCP控制协议</strong></p><p>RTCP控制协议需要与RTP数据协议一起配合使用，当应用程序启动一个RTP会话时将同时占用两个端口，分别供RTP和RTCP使用。RTP本身并 不能为按序传输数据包提供可靠的保证，也不提供流量控制和拥塞控制，这些都由RTCP来负责完成。通常RTCP会采用与RTP相同的分发机制，向会话中的 所有成员周期性地发送控制信息，应用程序通过接收这些数据，从中获取会话参与者的相关资料，以及网络状况、分组丢失概率等反馈信息，从而能够对服务质量进 行控制或者对网络状况进行诊断。</p><p>RTCP协议的功能是通过不同的RTCP数据报来实现的，主要有如下几种类型：</p><ul><li><p>SR：发送端报告，所谓发送端是指发出RTP数据报的应用程序或者终端，发送端同时也可以是接收端。(SERVER定时间发送给CLIENT)。</p></li><li><p>RR：接收端报告，所谓接收端是指仅接收但不发送RTP数据报的应用程序或者终端。(SERVER接收CLIENT端发送过来的响应)。</p></li><li><p>SDES：源描述，主要功能是作为会话成员有关标识信息的载体，如用户名、邮件地址、电话号码等，此外还具有向会话成员传达会话控制信息的功能。</p></li><li><p>BYE：通知离开，主要功能是指示某一个或者几个源不再有效，即通知会话中的其他成员自己将退出会话。</p></li><li><p>APP：由应用程序自己定义，解决了RTCP的扩展性问题，并且为协议的实现者提供了很大的灵活性。</p></li></ul><p><strong>3：RTP数据协议</strong></p><p>RTP数据协议负责对流媒体数据进行封包并实现媒体流的实时传输，每一个RTP数据报都由头部（Header）和负载（Payload）两个部分组成，其中头部前12个字节的含义是固定的，而负载则可以是音频或者视频数据。</p><p>RTP用到的地方就是 PLAY ，服务器往客户端传输数据用UDP协议，RTP是在传输数据的前面加了个12字节的头(描述信息)。</p><p>RTP载荷封装设计本文的网络传输是基于IP协议，所以最大传输单元(MTU)最大为1500字节，在使用IP／UDP／RTP的协议层次结构的时候，这 其中包括至少20字节的IP头，8字节的UDP头，以及12字节的RTP头。这样，头信息至少要占用40个字节，那么RTP载荷的最大尺寸为1460字 节。以H264 为例，如果一帧数据大于1460，则需要分片打包，然后到接收端再拆包，组合成一帧数据，进行解码播放。</p><h3 id="9-3-RTSP、-RTMP、HTTP的共同点、区别"><a href="#9-3-RTSP、-RTMP、HTTP的共同点、区别" class="headerlink" title="9.3 RTSP、 RTMP、HTTP的共同点、区别"></a>9.3 RTSP、 RTMP、HTTP的共同点、区别</h3><p>共同点：</p><ul><li>RTSP RTMP HTTP都是在应用应用层。</li><li>理论上RTSP RTMPHTTP都可以做直播和点播，但一般做直播用RTSP RTMP，做点播用HTTP。做视频会议的时候原来用SIP协议，现在基本上被RTMP协议取代了。</li></ul><p>区别：</p><ul><li><p>HTTP: 即超文本传送协议(ftp即文件传输协议)。</p><ul><li><p>HTTP:（Real Time Streaming Protocol），实时流传输协议。</p></li><li><p>HTTP全称Routing Table Maintenance Protocol（路由选择表维护协议）。</p></li></ul></li><li><p>HTTP将所有的数据作为文件做处理。http协议不是流媒体协议。</p><ul><li>RTMP 和 RTSP协议是流媒体协议。</li></ul></li><li><p>RTMP协议是Adobe的私有协议,未完全公开，RTSP协议和HTTP协议是共有协议，并有专门机构做维护。</p></li><li><p>RTMP协议一般传输的是flv，f4v格式流，RTSP协议一般传输的是ts,mp4格式的流。HTTP没有特定的流。</p></li><li><p>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实战 - 基于ffmpeg，qt5，opencv视频课程&lt;/p&gt;
&lt;h2 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1. 基础知识&quot;&gt;&lt;/a&gt;1. 基础知识&lt;/h2&gt;&lt;h3 id=&quot;1-1-直播推流流程分析&quot;&gt;&lt;a href=&quot;#1-1-直播推流流程分析&quot; class=&quot;headerlink&quot; title=&quot;1.1 直播推流流程分析&quot;&gt;&lt;/a&gt;1.1 直播推流流程分析&lt;/h3&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC</title>
    <link href="http://miaopei.github.io/2019/05/14/WebRTC/webrtc/"/>
    <id>http://miaopei.github.io/2019/05/14/WebRTC/webrtc/</id>
    <published>2019-05-14T02:14:50.000Z</published>
    <updated>2019-06-11T09:10:45.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h1><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYlJUQ19BUEk=" title="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API">WebRTC API<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkv" title="http://nodejs.cn/api/">Node.js v10.15.3 文档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI1MjM1MzU5MDQw" title="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040">廖雪峰 - nodejs<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-WebRTC-介绍"><a href="#1-WebRTC-介绍" class="headerlink" title="1. WebRTC 介绍"></a>1. WebRTC 介绍</h2><a id="more"></a><ul><li>Google 开源</li><li>跨平台</li><li>用于浏览器</li><li>实时传输<ul><li>100ms 延迟 通话质量非常好</li><li>200ms 延迟 通话质量比较优质</li><li>500ms 延迟 可以接受</li><li>超过1s 非常迟滞</li></ul></li><li>音视频引擎</li></ul><p>WebRTC 应用：</p><img src="/images/imageWebRTC/webrtc应用.png"><p>WebRTC 愿景：</p><img src="/images/imageWebRTC/webrtc愿景.png"><p>学习 WebRTC 的难点：</p><img src="/images/imageWebRTC/学习WebRTC的难点.png"><p>学习路线：</p><img src="/images/imageWebRTC/学习路线.png"><p>学习内容：</p><img src="/images/imageWebRTC/学习内容.png"><p>学习收获：</p><img src="/images/imageWebRTC/学习收获.png"><p>WebRTC能做啥：</p><img src="/images/imageWebRTC/WebRTC能做啥.png"><p>能学到什么：</p><img src="/images/imageWebRTC/能学到什么.png"><p>google webrtc 示例：<span class="exturl" data-url="aHR0cHM6Ly9hcHByLnRjLw==" title="https://appr.tc/">https://appr.tc/<i class="fa fa-external-link"></i></span></p><h2 id="2-WebRTC-原理与架构"><a href="#2-WebRTC-原理与架构" class="headerlink" title="2. WebRTC 原理与架构"></a>2. WebRTC 原理与架构</h2><p>WebRTC 整体架构：</p><img src="/images/imageWebRTC/webrtc架构.png"><p>WebRTC 的目录结构图：</p><img src="/images/imageWebRTC/WebRTC目录结构-01.png"><img src="/images/imageWebRTC/WebRTC目录结构-02.png"><img src="/images/imageWebRTC/WebRTCModules目录-01.png"><img src="/images/imageWebRTC/WebRTCModules目录-02.png"><p>WebRTC 两个基本概念：轨与流</p><ul><li>Track</li><li>MediaStream</li></ul><p>WebRTC重要类：</p><ul><li>MediaStream</li><li>RTCPeerConnection</li><li>RTCDataChannel</li></ul><p>PeerConnection调用过程：</p><img src="/images/imageWebRTC/PeerConnection调用过程.png"><p>调用时序图：</p><img src="/images/imageWebRTC/调用时序图.png"><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3RoZXIvcC9teVBlZXJDb25uZWN0aW9uLmh0bWw=" title="https://www.cnblogs.com/cther/p/myPeerConnection.html">WebRTC之PeerConnection的建立过程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80Mzk1N2VlMThmMWE=" title="https://www.jianshu.com/p/43957ee18f1a">WebRTC系列（3）：PeerConnection通信建立流程<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="3-Web服务器原理与Nodejs搭建"><a href="#3-Web服务器原理与Nodejs搭建" class="headerlink" title="3. Web服务器原理与Nodejs搭建"></a>3. Web服务器原理与Nodejs搭建</h2><p>Web服务器选型：</p><ul><li>Nodejs</li><li>Nginx</li><li>Apache</li></ul><p>Web服务工作原理：</p><img src="/images/imageWebRTC/web服务工作原理.png"><p>Nodejs工作原理：</p><img src="/images/imageWebRTC/Nodejs工作原理.png"><p>JavaScript解析：</p><img src="/images/imageWebRTC/JavaScript解析.png"><p>Nodejs 事件处理：</p><img src="/images/imageWebRTC/Nodejs事件处理.png"><p>两个V8引擎：</p><img src="/images/imageWebRTC/两个V8引擎.png"><p>最简单的http服务：</p><ul><li><strong>require</strong> 引入http模块</li><li>创建http服务</li><li>侦听端口</li></ul><p>启动Nodejs服务：</p><ul><li>node app.js</li><li>nohub node app.js</li><li>forever start app.js</li><li>pm2 start app.js</li></ul><p>Https基本原理：</p><img src="/images/imageWebRTC/https基本原理.png"><p>Nodejs 搭建 https 服务：</p><ul><li>生成 HTTPS证书</li><li>引入 HTTPS模块</li><li>指定证书位置，并创建 HTTPS 服务</li></ul><p>真正的Web服务：</p><ul><li>引用 express 模块</li><li>引入 server-index 模块</li><li>指定发布目录</li></ul><h2 id="4-JavaScript-必备知识回顾"><a href="#4-JavaScript-必备知识回顾" class="headerlink" title="4. JavaScript 必备知识回顾"></a>4. JavaScript 必备知识回顾</h2><p>基础知识：</p><ul><li>变量与类型</li><li>基本运算</li><li><code>if/else</code></li><li>for循环</li><li>函数</li><li>日志打印</li></ul><p>变量与类型：</p><img src="/images/imageWebRTC/变量与类型.png"><p>基本运算：</p><img src="/images/imageWebRTC/基本运算.png"><img src="/images/imageWebRTC/ifelse.png"><img src="/images/imageWebRTC/for循环.png"><img src="/images/imageWebRTC/函数.png"><h2 id="5-WebRTC设备管理"><a href="#5-WebRTC设备管理" class="headerlink" title="5. WebRTC设备管理"></a>5. WebRTC设备管理</h2><p>enumerateDevices：</p><img src="/images/imageWebRTC/enumerateDevices.png"><p>JavaScript中的Promise：</p><img src="/images/imageWebRTC/JavaScript中的Promise.png"><h2 id="6-WebRTC音视频数据采集"><a href="#6-WebRTC音视频数据采集" class="headerlink" title="6. WebRTC音视频数据采集"></a>6. WebRTC音视频数据采集</h2><p>音视频采集API：</p><img src="/images/imageWebRTC/音视频采集API.png"><p>getUserMedia的不同实现：</p><img src="/images/imageWebRTC/getUserMedia的不同实现.png"><p>适配置不同浏览器的方法：</p><img src="/images/imageWebRTC/适配置不同浏览器的方法.png"><p><code>https://webrtc.github.io/adapter/adapter-latest.js</code></p><p>WebRTC音视频采集约束：</p><p>约束详解：</p><ul><li><p>width</p></li><li><p>height</p><p>宽高比例：<code>4:3</code>  <code>16:9</code></p></li><li><p>aspectRatio</p></li><li><p>frameRate</p></li><li><p>facingMode</p><ul><li>user - 前置摄像头</li><li>environment - 后置摄像头</li><li>left - 前置左侧摄像头</li><li>right - 前置右侧摄像头</li></ul></li><li><p>resizeMode</p></li></ul><p>音频约束详解：</p><ul><li>volume - <code>范围 0 - 1.0</code></li><li>sampleRate</li><li>sampleSize -  一般16位</li><li>echoCancellation - 回音消除</li><li>autoGainControl - 是否在原有声音基础上增加音量</li><li>noiseSuppression - 降噪</li><li>latency - 延迟大小</li><li>channelCount - 声道  乐器一般是双声道</li><li>deviceID - 作用是多个设备切换</li><li>groupID </li></ul><p>WebRTC约束例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    audio: true,</span><br><span class="line">    video: &#123;</span><br><span class="line">        width: &#123;</span><br><span class="line">            min: 300,</span><br><span class="line">            max: 640,</span><br><span class="line">        &#125;,</span><br><span class="line">        height: &#123;</span><br><span class="line">            min: 300,</span><br><span class="line">            max: 480,</span><br><span class="line">        &#125;,</span><br><span class="line">        frameRate: &#123;</span><br><span class="line">            min: 15,</span><br><span class="line">            max: 30,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器视频特效：</p><ul><li>CSS filter，<code>-webkit-filter/filter</code></li><li>如何将 video 与 filter 关联</li><li>OpenGL/Metal/…</li></ul><p>支持的特效种类：</p><img src="/images/imageWebRTC/支持的特效种类.png"><p>保存图片是实现滤镜效果，可以对 canvas.data 进行数据修改。</p><p>MediaStream API 获取视频约束：</p><img src="/images/imageWebRTC/MediaStream.png"><img src="/images/imageWebRTC/MediaStream事件.png"><h2 id="7-WebRTC音视频录制实战"><a href="#7-WebRTC音视频录制实战" class="headerlink" title="7. WebRTC音视频录制实战"></a>7. WebRTC音视频录制实战</h2><h3 id="7-1-WebRTC录制基本知识"><a href="#7-1-WebRTC录制基本知识" class="headerlink" title="7.1 WebRTC录制基本知识"></a>7.1 WebRTC录制基本知识</h3><p>MediaRecoder类：</p><img src="/images/imageWebRTC/MediaRecoder.png"><img src="/images/imageWebRTC/MediaRecorder参数.png"><img src="/images/imageWebRTC/MediaRecorderAPI-01.png"><img src="/images/imageWebRTC/MediaRecorderAPI-02.png"><img src="/images/imageWebRTC/MediaRecorder事件.png"><img src="/images/imageWebRTC/JavaScript几种存储数据的方式.png"><h3 id="7-2-WebRTC-捕获桌面"><a href="#7-2-WebRTC-捕获桌面" class="headerlink" title="7.2 WebRTC 捕获桌面"></a>7.2 WebRTC 捕获桌面</h3><img src="/images/imageWebRTC/getDisplayMedia.png"><p>捕获桌面需要设置Chrome，具体 操作：<span class="exturl" data-url="Y2hyb21lOi8vZmxhZ3MvI2VuYWJsZS1leHBlcmltZW50YWwtd2ViLXBsYXRmb3JtLWZlYXR1cmVz" title="chrome://flags/#enable-experimental-web-platform-features">chrome://flags/#enable-experimental-web-platform-features<i class="fa fa-external-link"></i></span></p><ul><li>Experimental Web Platform features 设置为 enable</li></ul><h2 id="8-WebRTC信令服务器实现"><a href="#8-WebRTC信令服务器实现" class="headerlink" title="8. WebRTC信令服务器实现"></a>8. WebRTC信令服务器实现</h2><p>如果没有信令服务器WebRTC之间是不能通信的。</p><p>两个client之间通信必须有两个信息通过信令服务器的：</p><ul><li>媒体信息， SDP</li><li>网络信息</li><li>具体的业务</li></ul><img src="/images/imageWebRTC/信令服务器的作用.png"><img src="/images/imageWebRTC/为什么要使用socketio.png"><img src="/images/imageWebRTC/socketio工作原理.png"><p>Socket.IO 发送消息：</p><ul><li><p>给本次连接发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.emit()</span><br></pre></td></tr></table></figure></li><li><p>给某个房间内所有人发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.in(room).emit()</span><br></pre></td></tr></table></figure></li><li><p>除本链接外，给某个房间内所有人发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.to(room).emit()</span><br></pre></td></tr></table></figure></li><li><p>除本链接外，给所有人发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.broadcast.emit()</span><br></pre></td></tr></table></figure></li></ul><p>Socket.IO 客户端处理消息：</p><ul><li><p>发送 action 命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>);</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送了一个 action 命令，还有 data 数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>, data);</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送了 action 命令，还有两个数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>, arg1, arg2);</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送了一个 action 命令，在 emit 方法中包含回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>, data, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)</span>&#123;...&#125;;</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, fn</span>)</span>&#123;fn(<span class="string">'a'</span>, <span class="string">'b'</span>);&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-1-实战-通过-socket-io-实现信令服务器"><a href="#8-1-实战-通过-socket-io-实现信令服务器" class="headerlink" title="8.1 [实战] 通过 socket.io 实现信令服务器"></a>8.1 [实战] 通过 socket.io 实现信令服务器</h3><p>改造服务端的基本流程：</p><ul><li>安装 socket.io</li><li>引入 socket.io</li><li>处理 connection 消息</li></ul><h2 id="9-WebRTC网络基础补充：P2P-STUN-TRUN-ICE知识"><a href="#9-WebRTC网络基础补充：P2P-STUN-TRUN-ICE知识" class="headerlink" title="9. WebRTC网络基础补充：P2P/STUN/TRUN/ICE知识"></a>9. WebRTC网络基础补充：P2P/STUN/TRUN/ICE知识</h2><h3 id="9-1-WebRTC-网络传输基本知识"><a href="#9-1-WebRTC-网络传输基本知识" class="headerlink" title="9.1 WebRTC 网络传输基本知识"></a>9.1 WebRTC 网络传输基本知识</h3><p>WebRTC 传输基本知识：</p><ul><li>NAT（Network Address Translator）</li><li>STUN（Simple Traversal of UDP Through NAT）</li><li>TURN（Travelsal Using Relays around NAT）</li><li>ICE（Interactive Connectivity Establishment）</li></ul><img src="/images/imageWebRTC/NAT.png"><p>NAT 产生的原因：</p><ul><li>由于IPv4的地址不够</li><li>处于网络安全的原因</li></ul><p>NAT 的种类：</p><ul><li>完全锥型 NAT（Full Cone NAT）</li><li>地址限制锥型 NAT（Address Restricted Cone NAT）</li><li>端口限制锥型 NAT（Port Restricted Cone NAT）</li><li>对称型 NAT（Symmetric NAT）</li></ul><h3 id="9-2-NAT-打洞原理"><a href="#9-2-NAT-打洞原理" class="headerlink" title="9.2 NAT 打洞原理"></a>9.2 NAT 打洞原理</h3><img src="/images/imageWebRTC/完全锥型NAT.png"><img src="/images/imageWebRTC/地址限制锥型NAT.png"><img src="/images/imageWebRTC/端口限制锥型NAT.png"><img src="/images/imageWebRTC/对称型NAT.png"><p>NAT 穿越原理：</p><ul><li>C1，C2 向 STUN 发消息</li><li>交换公网 IP 及 端口</li><li>C1 -&gt; C2，C2 -&gt; C1，甚至是端口猜测</li></ul><img src="/images/imageWebRTC/NAT穿越组合.png"><h3 id="9-3-NAT-类型检测"><a href="#9-3-NAT-类型检测" class="headerlink" title="9.3 NAT 类型检测"></a>9.3 NAT 类型检测</h3><img src="/images/imageWebRTC/NAT类型判断.png"><p>公网 IP：</p><img src="/images/imageWebRTC/NAT类型检测-01.png"><p>如果 Client 收到的 IP 和第一次发出去的 IP 是不一样的，则是对称型 NAT，如果是一样的需要进一步判断：</p><img src="/images/imageWebRTC/NAT类型检测-02.png"><p>Client 通过 Port2 发送消息到 STUN Port1，STUN Server 通过 Port2 给 Client 回消息，如果 Client 能收到消息，则说明是 IP 限制型的；如果不能收到，则说明是端口限制型的：</p><img src="/images/imageWebRTC/NAT类型检测-03.png"><h3 id="9-4-【协议规范】STUN-协议一"><a href="#9-4-【协议规范】STUN-协议一" class="headerlink" title="9.4 【协议规范】STUN 协议一"></a>9.4 【协议规范】STUN 协议一</h3><p>STUN 介绍：</p><ul><li>STUN 存在的目的就是进行 NAT 穿越</li><li>STUN 是典型的客户端 / 服务器模式。客户端发送请求，服务端进行响应</li></ul><p>RFC STUN 规范：</p><ul><li><p><strong>RFC3489/STUN</strong></p><p>SImple Traversal of UDP Trough NAT</p></li><li><p><strong>RFC5389/STUN</strong> — 包含UDP和TCP</p><p>Session Traversal Utilities for NAT</p></li></ul><p>STUN 协议：</p><ul><li>包括 20 字节的 STUN header</li><li>Body 中可以有 0 个或多个 Attribute</li></ul><p>STUN header（RFC3489）：</p><ul><li>其中 2 个字节（16bit）类型</li><li>2 个字节（16bit）消息长度，不包括消息头</li><li>16 个字节（128bit）事物ID，请求与响应事物 ID 相同</li></ul><p>STUN header（RFC5389）格式：</p><img src="/images/imageWebRTC/STUNHeader格式.png"><img src="/images/imageWebRTC/STUNMessageType.png"><p>M 代表请求值，C 代表分类：</p><img src="/images/imageWebRTC/STUNMessageType-01.png"><img src="/images/imageWebRTC/C0C1.png"><p>RFC5389 把私密类型去掉了：</p><img src="/images/imageWebRTC/STUN消息类型.png"><h3 id="9-5-【协议规范】STUN-协议二"><a href="#9-5-【协议规范】STUN-协议二" class="headerlink" title="9.5 【协议规范】STUN 协议二"></a>9.5 【协议规范】STUN 协议二</h3><p>Inter 机子都是小端模式：</p><img src="/images/imageWebRTC/大小端模式.png"><img src="/images/imageWebRTC/STUNMessageType-02.png"><img src="/images/imageWebRTC/TransactionID.png"><img src="/images/imageWebRTC/STUNMessageBody.png"><img src="/images/imageWebRTC/TLV.png"><img src="/images/imageWebRTC/RFC3489定义的属性.png"><img src="/images/imageWebRTC/Attribute的使用.png"><h3 id="9-6-【协议规范】TURN-协议"><a href="#9-6-【协议规范】TURN-协议" class="headerlink" title="9.6 【协议规范】TURN 协议"></a>9.6 【协议规范】TURN 协议</h3><p>TURN 介绍：</p><ul><li>其目的是解决对称 NAT 无法穿越的问题</li><li>其建立在 STUN 之上，消息格式使用 STUN 格式消息</li><li>TURN Client 要求服务端分配一个公共 IP 和 Port 用于接受 或 发送数据</li></ul><img src="/images/imageWebRTC/TURN例子.png"><img src="/images/imageWebRTC/TURN使用的传输协议.png"><img src="/images/imageWebRTC/TURNAllocate.png"><p>TURN 发送机制：</p><ul><li>Send 和 Data</li><li>Channel</li></ul><img src="/images/imageWebRTC/TURNSendAndData.png"><img src="/images/imageWebRTC/TURNChannel.png"><img src="/images/imageWebRTC/TURN的使用.png"><h3 id="9-7-【协议规范】ICE-框架"><a href="#9-7-【协议规范】ICE-框架" class="headerlink" title="9.7 【协议规范】ICE 框架"></a>9.7 【协议规范】ICE 框架</h3><img src="/images/imageWebRTC/ICE.png"><img src="/images/imageWebRTC/ICECandidate.png"><p>Candidate 类型：</p><ul><li>主机候选者</li><li>反射侯选者</li><li>中继候选者</li></ul><p>ICE 具体做些什么：</p><ul><li>收集 Candidate</li><li>对 Candidate Pair 排序</li><li>连通性检查</li></ul><img src="/images/imageWebRTC/Candidate关系图.png"><p>收集 Candidate：</p><ul><li>Host Candidate：本机所有 IP 和指定端口</li><li>Reflexive Candidate：STUN/TURN</li><li>Relay Candidate：TURN</li></ul><p>什么是 SDP：</p><ul><li><strong>SDP（Session Description Protocol）</strong> 它只是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息。</li></ul><img src="/images/imageWebRTC/SDP例子.png"><p>形成 Candidate Pair：</p><ul><li>一方收集到所有候选者后，通过信令传给对方</li><li>同样，另一方收到候选者后，也做收集工作</li><li>当双方拿到全部列表后，将侯选者形成匹配对儿</li></ul><p>连通性检查：</p><ul><li>对侯选者进行优先级排序</li><li>对每个侯选对进行发送检查</li><li>对每个侯选对进行接收检查</li></ul><img src="/images/imageWebRTC/连通性过程.png"><h3 id="9-8-网络协议分析方法-tcpdump-与-wireshark讲解"><a href="#9-8-网络协议分析方法-tcpdump-与-wireshark讲解" class="headerlink" title="9.8 网络协议分析方法 tcpdump 与 wireshark讲解"></a>9.8 网络协议分析方法 tcpdump 与 wireshark讲解</h3><p>常用工具：</p><ul><li>Linux 服务端用 tcpdump</li><li>其它端 WireShark</li></ul><img src="/images/imageWebRTC/tcpdump.png"><h3 id="9-9-网络协议分析方法-tcpdump-与-wireshark-实战"><a href="#9-9-网络协议分析方法-tcpdump-与-wireshark-实战" class="headerlink" title="9.9 网络协议分析方法 tcpdump 与 wireshark 实战"></a>9.9 网络协议分析方法 tcpdump 与 wireshark 实战</h3><p>vim 打开二进制数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：%！xxd</span><br></pre></td></tr></table></figure><p>WireShark 中的逻辑运算：</p><ul><li>与：and 或 &amp;&amp;</li><li>或：or 或 ||</li><li>非：not 或 ！</li></ul><p>WireShark 中判断语句：</p><ul><li>等于：eq 或 ==</li><li>小于：lt 或 &lt;</li><li>大于：gt 或 &gt;</li><li>小于等于：le 或 &lt;=</li><li>大于等于：ge 或 &gt;=</li><li>不等于：ne 或 !=</li></ul><p>WireShark 按协议过滤：</p><ul><li>stun</li><li>tcp</li><li>udp</li></ul><p>模拟STUN数据可以使用这个网站中的工具：<span class="exturl" data-url="aHR0cHM6Ly93ZWJydGMuZ2l0aHViLmlvL3NhbXBsZXM=" title="https://webrtc.github.io/samples">https://webrtc.github.io/samples<i class="fa fa-external-link"></i></span></p><p>Wireshark 按 IP 过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip.dst == 192.168.1.2</span><br><span class="line">ip.src == 192.168.1.2</span><br><span class="line">ip.addr == 192.168.1.2</span><br></pre></td></tr></table></figure><p>WireShark 按 port 过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == 8080</span><br><span class="line">udp.port == 3478</span><br><span class="line">udp.dstport == 3478</span><br><span class="line">udp.srcport == 3478</span><br></pre></td></tr></table></figure><p>WireShark 过滤长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">udp.length &lt; 30</span><br><span class="line">tcp.length &lt; 30</span><br><span class="line">http.content_length &lt; 30</span><br></pre></td></tr></table></figure><p>WireShark 过滤内容：</p><p>TODO</p><h2 id="10-端对端1V1传输基本流程"><a href="#10-端对端1V1传输基本流程" class="headerlink" title="10. 端对端1V1传输基本流程"></a>10. 端对端1V1传输基本流程</h2><h3 id="10-1-媒体能力协商过程"><a href="#10-1-媒体能力协商过程" class="headerlink" title="10.1 媒体能力协商过程"></a>10.1 媒体能力协商过程</h3><p>WebRTC 端对端连接：</p><p><strong>RTCPeerConnection</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc = <span class="keyword">new</span> RTCPeerConnection([configuration]);</span><br></pre></td></tr></table></figure></li></ul><p><strong>RTCPeerConnection 方法分类</strong>：</p><ul><li>媒体协商</li><li>Stream/Track</li><li>传输相关方法</li><li>统计相关方法</li></ul><img src="/images/imageWebRTC/媒体协商过程.png"><img src="/images/imageWebRTC/协商状态变化.png"><p><strong>媒体协商方法</strong>：</p><ul><li>createOffer</li><li>createAnswer</li><li>setLocakDescription</li><li>setRemoteDescription</li></ul><p><strong>createOffer</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPeerConnection.createOffer([options]);</span><br></pre></td></tr></table></figure></li></ul><p><strong>createAnswer</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPeerConnection.createAnswer([options]);</span><br></pre></td></tr></table></figure></li></ul><p><strong>setLocakDescription</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPc.setLocalDescription(sessionDescription);</span><br></pre></td></tr></table></figure></li></ul><p><strong>setRemoteDescription</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPc.setRemoteDescription(sessionDescription);</span><br></pre></td></tr></table></figure></li></ul><p><strong>Track 方法</strong>：</p><ul><li>addTrack</li><li>removeTrack</li></ul><p><strong>addTrack</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtpSender = myPc.addTrack(track, stream...);</span><br></pre></td></tr></table></figure></li><li><p>Parameters</p><img src="/images/imageWebRTC/addTrackParameters.png"></li></ul><p><strong>removeTrack</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPc.remoteTrack(rtpSender);</span><br></pre></td></tr></table></figure></li></ul><p><strong>重要事件</strong>：</p><ul><li>onnegotiationneeded  - 协商的时候触发这个事件</li><li>onicecandidate - 当收到 ICE 候选者的时候触发这个事件</li></ul><h3 id="10-2-1-1-连接的基本流程"><a href="#10-2-1-1-连接的基本流程" class="headerlink" title="10.2 1:1 连接的基本流程"></a>10.2 1:1 连接的基本流程</h3><img src="/images/imageWebRTC/端对端连接的基本流程.png"><p><strong>A 与 B 通信，大的方向分为三部分</strong>：</p><ul><li>媒体协商部分</li><li>ICE 候选者的交换、连接、检测部分</li><li>媒体数据流的通信部分</li></ul><h3 id="10-3-【实战】WebRTC-视频传输"><a href="#10-3-【实战】WebRTC-视频传输" class="headerlink" title="10.3 【实战】WebRTC 视频传输"></a>10.3 【实战】WebRTC 视频传输</h3><p>TODO</p><h3 id="10-4-【实战】显示通讯双方的-SDP-内容"><a href="#10-4-【实战】显示通讯双方的-SDP-内容" class="headerlink" title="10.4 【实战】显示通讯双方的 SDP 内容"></a>10.4 【实战】显示通讯双方的 SDP 内容</h3><p>TODO</p><h2 id="11-WebRTC核心之SDP详解"><a href="#11-WebRTC核心之SDP详解" class="headerlink" title="11. WebRTC核心之SDP详解"></a>11. WebRTC核心之SDP详解</h2><h3 id="11-1-【协议规范】SDP-规范"><a href="#11-1-【协议规范】SDP-规范" class="headerlink" title="11.1 【协议规范】SDP 规范"></a>11.1 【协议规范】SDP 规范</h3><p><strong>SDP 规范</strong>：</p><ul><li>会话层</li><li>媒体层</li></ul><p>可以把会话层看做树根，媒体层看成树干。</p><p><strong>会话层</strong>：</p><ul><li>会话的名称与目的</li><li>会话的存活时间</li><li>会话中包含多个媒体信息</li></ul><p><strong>SDP 媒体信息</strong>：</p><ul><li>媒体格式</li><li>传输协议</li><li>传输 IP 和 端口</li><li>媒体负载类型</li></ul><p><strong>SDP 格式</strong>：</p><ul><li>由多个 <code>&lt;type&gt;=&lt;value&gt;</code> 组成</li><li>一个会话级描述</li><li>多个媒体级描述</li></ul><p><strong>SDP 结构</strong>：</p><ul><li>Session Description</li><li>Time Description</li><li>Media Description</li></ul><img src="/images/imageWebRTC/SessionDescription.png"><img src="/images/imageWebRTC/TimeDescription.png"><img src="/images/imageWebRTC/MediaDescription.png"><img src="/images/imageWebRTC/字段含义-01.png"><img src="/images/imageWebRTC/字段含义-02.png"><img src="/images/imageWebRTC/字段含义-03.png"><img src="/images/imageWebRTC/字段含义-04.png"><img src="/images/imageWebRTC/字段含义-05.png"><img src="/images/imageWebRTC/字段含义-06.png"><img src="/images/imageWebRTC/字段含义-07.png"><h3 id="11-2-【协议规范】WebRTC-中的-SDP"><a href="#11-2-【协议规范】WebRTC-中的-SDP" class="headerlink" title="11.2 【协议规范】WebRTC 中的 SDP"></a>11.2 【协议规范】WebRTC 中的 SDP</h3><img src="/images/imageWebRTC/WebRTC中的SDP.png"><h3 id="11-3-【详解】WebRTC-中-Offer-Answer-SDP"><a href="#11-3-【详解】WebRTC-中-Offer-Answer-SDP" class="headerlink" title="11.3 【详解】WebRTC 中 Offer_Answer SDP"></a>11.3 【详解】WebRTC 中 Offer_Answer SDP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-实现1V1音视频实时互动直播系统"><a href="#12-实现1V1音视频实时互动直播系统" class="headerlink" title="12. 实现1V1音视频实时互动直播系统"></a>12. 实现1V1音视频实时互动直播系统</h2><h3 id="12-1-STUN-TURN-服务器搭建"><a href="#12-1-STUN-TURN-服务器搭建" class="headerlink" title="12.1 STUN/TURN 服务器搭建"></a>12.1 STUN/TURN 服务器搭建</h3><p>coTurn Download Address：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvdHVybi9jb3R1cm4=" title="https://github.com/coturn/coturn">https://github.com/coturn/coturn<i class="fa fa-external-link"></i></span></p><p>ICE 测试地址：<span class="exturl" data-url="aHR0cHM6Ly93ZWJydGMuZ2l0aHViLmlvL3NhbXBsZXM=" title="https://webrtc.github.io/samples">https://webrtc.github.io/samples<i class="fa fa-external-link"></i></span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 turn server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> turnserver -c /usr/<span class="built_in">local</span>/coturn/etc/turnserver.conf</span></span><br></pre></td></tr></table></figure><img src="/images/imageWebRTC/STUNTURN服务器选型.png"><img src="/images/imageWebRTC/coTurn服务器搭建与部署.png"><img src="/images/imageWebRTC/coTurn服务器配置.png"><img src="/images/imageWebRTC/测试turn服务.png"><h3 id="12-2-【参数介绍】再论-RTCPeerConnection"><a href="#12-2-【参数介绍】再论-RTCPeerConnection" class="headerlink" title="12.2 【参数介绍】再论 RTCPeerConnection"></a>12.2 【参数介绍】再论 RTCPeerConnection</h3><img src="/images/imageWebRTC/RTCPeerConnection-01.png"><img src="/images/imageWebRTC/Configurations-01.png"><img src="/images/imageWebRTC/Configurations-02.png"><img src="/images/imageWebRTC/Configurations-03.png"><img src="/images/imageWebRTC/Configurations-04.png"><img src="/images/imageWebRTC/addIceCandidate.png"><h3 id="12-3-直播系统中的信令及其逻辑关系"><a href="#12-3-直播系统中的信令及其逻辑关系" class="headerlink" title="12.3 直播系统中的信令及其逻辑关系"></a>12.3 直播系统中的信令及其逻辑关系</h3><p>【实战】真正的音视频传输</p><p><strong>客户端信令消息</strong>：</p><ul><li>join 加入房间</li><li>leave 离开房间</li><li>message 端到端消息</li></ul><p><strong>端到端信令消息</strong>：</p><ul><li>Offer 消息</li><li>Answer 消息</li><li>Candidate 消息</li></ul><p><strong>服务端信令消息</strong>：</p><ul><li>joined 已加入房间</li><li>otherjoin 其它用户加入房间</li><li>full 房间人数已满</li><li>leaved 已离开房间</li><li>bye 对方离开房间</li></ul><img src="/images/imageWebRTC/直播系统消息处理流程.png"><h3 id="12-4-实现-1：1-音视频实时互动信令服务器"><a href="#12-4-实现-1：1-音视频实时互动信令服务器" class="headerlink" title="12.4 实现 1：1 音视频实时互动信令服务器"></a>12.4 实现 1：1 音视频实时互动信令服务器</h3><p>信令服务器改造</p><p>TODO</p><h3 id="12-5-再论CreateOffer"><a href="#12-5-再论CreateOffer" class="headerlink" title="12.5 再论CreateOffer"></a>12.5 再论CreateOffer</h3><img src="/images/imageWebRTC/createOffer.png"><p><strong>CreateOffer 实战</strong>：</p><ul><li>接收远端音频</li><li>接收远端视频</li><li>静音检测</li><li>ICE restart</li></ul><h3 id="12-6-WebRTC-客户端状态机及处理逻辑"><a href="#12-6-WebRTC-客户端状态机及处理逻辑" class="headerlink" title="12.6 WebRTC 客户端状态机及处理逻辑"></a>12.6 WebRTC 客户端状态机及处理逻辑</h3><p>直播客户端的实现：</p><img src="/images/imageWebRTC/客户端状态机.png"><img src="/images/imageWebRTC/客户端流程图.png"><img src="/images/imageWebRTC/客户端流程图-01.png"><img src="/images/imageWebRTC/端对端连接的基本流程.png"><h3 id="12-7-WebRTC-客户端的实现"><a href="#12-7-WebRTC-客户端的实现" class="headerlink" title="12.7 WebRTC 客户端的实现"></a>12.7 WebRTC 客户端的实现</h3><img src="/images/imageWebRTC/注意要点.png"><h3 id="12-8-共享远程桌面"><a href="#12-8-共享远程桌面" class="headerlink" title="12.8 共享远程桌面"></a>12.8 共享远程桌面</h3><img src="/images/imageWebRTC/getDisplayMedia-01.png"><img src="/images/imageWebRTC/需要注意的点.png"><h2 id="13-WebRTC核心之RTP媒体控制与数据统计"><a href="#13-WebRTC核心之RTP媒体控制与数据统计" class="headerlink" title="13. WebRTC核心之RTP媒体控制与数据统计"></a>13. WebRTC核心之RTP媒体控制与数据统计</h2><h3 id="13-1-RTPPReceiver-发送器"><a href="#13-1-RTPPReceiver-发送器" class="headerlink" title="13.1 RTPPReceiver 发送器"></a>13.1 RTPPReceiver 发送器</h3><p>RTP Media</p><img src="/images/imageWebRTC/Receiver和Sender.png"><img src="/images/imageWebRTC/RTCRtpSender属性.png"><img src="/images/imageWebRTC/RTCRtpReceiver.png"><h3 id="13-2-RTPSender-发送器"><a href="#13-2-RTPSender-发送器" class="headerlink" title="13.2 RTPSender 发送器"></a>13.2 RTPSender 发送器</h3><img src="/images/imageWebRTC/RTCRtpSender.png"><img src="/images/imageWebRTC/RTPMedia.png"><img src="/images/imageWebRTC/RTCRtpTransceiver.png"><h3 id="13-3-传输速率的控制"><a href="#13-3-传输速率的控制" class="headerlink" title="13.3 传输速率的控制"></a>13.3 传输速率的控制</h3><img src="/images/imageWebRTC/RTPMedia-01.png"><img src="/images/imageWebRTC/chromeWebRTC-internals.png"><p>chrome WebRTC 状态查询地址：<span class="exturl" data-url="Y2hyb21lOi8vd2VicnRjLWludGVybmFscw==" title="chrome://webrtc-internals">chrome://webrtc-internals<i class="fa fa-external-link"></i></span></p><h3 id="13-4-【实战】WebRTC统计信息"><a href="#13-4-【实战】WebRTC统计信息" class="headerlink" title="13.4 【实战】WebRTC统计信息"></a>13.4 【实战】WebRTC统计信息</h3><p>TODO</p><h2 id="14-WebRTC非音视频数据传输"><a href="#14-WebRTC非音视频数据传输" class="headerlink" title="14. WebRTC非音视频数据传输"></a>14. WebRTC非音视频数据传输</h2><h3 id="14-1-传输非音视频数据基础知识"><a href="#14-1-传输非音视频数据基础知识" class="headerlink" title="14.1 传输非音视频数据基础知识"></a>14.1 传输非音视频数据基础知识</h3><img src="/images/imageWebRTC/createDataChannel.png"><img src="/images/imageWebRTC/option-01.png"><img src="/images/imageWebRTC/option-02.png"><img src="/images/imageWebRTC/使用Options.png"><img src="/images/imageWebRTC/DataChannel事件.png"><img src="/images/imageWebRTC/创建RTCDataChannel.png"><img src="/images/imageWebRTC/非音视频数据传输方式.png"><ul><li>Reliability：可靠性</li><li>Delivery：可达性</li><li>Transmission：传输方式</li><li>Flow control：流控</li><li>Congestion control：拥塞控制</li></ul><h3 id="14-2-端到端文本聊天"><a href="#14-2-端到端文本聊天" class="headerlink" title="14.2 端到端文本聊天"></a>14.2 端到端文本聊天</h3><p>TODO</p><h3 id="14-3-文件实时传输"><a href="#14-3-文件实时传输" class="headerlink" title="14.3 文件实时传输"></a>14.3 文件实时传输</h3><img src="/images/imageWebRTC/知识点.png"><h2 id="15-WebRTC实时数据传输网络协议详解"><a href="#15-WebRTC实时数据传输网络协议详解" class="headerlink" title="15. WebRTC实时数据传输网络协议详解"></a>15. WebRTC实时数据传输网络协议详解</h2><h3 id="15-1-【协议规范】RTP-SRTP协议头详解"><a href="#15-1-【协议规范】RTP-SRTP协议头详解" class="headerlink" title="15.1 【协议规范】RTP-SRTP协议头详解"></a>15.1 【协议规范】RTP-SRTP协议头详解</h3><img src="/images/imageWebRTC/协议栈.png"><img src="/images/imageWebRTC/传输协议.png"><img src="/images/imageWebRTC/RTP协议.png"><img src="/images/imageWebRTC/RTP字段说明.png"><h3 id="15-2-【协议规范】RTCP-中的-SR-与-RR-报文"><a href="#15-2-【协议规范】RTCP-中的-SR-与-RR-报文" class="headerlink" title="15.2 【协议规范】RTCP 中的 SR 与 RR 报文"></a>15.2 【协议规范】RTCP 中的 SR 与 RR 报文</h3><img src="/images/imageWebRTC/RTCP包.png"><img src="/images/imageWebRTC/RTCPPayloadType.png"><img src="/images/imageWebRTC/RTCPHeader.png"><img src="/images/imageWebRTC/RTCPHeader说明.png"><img src="/images/imageWebRTC/RTCPSenderReport.png"><img src="/images/imageWebRTC/SenderInfomationBlock.png"><img src="/images/imageWebRTC/SenderInfo说明.png"><img src="/images/imageWebRTC/ReportBlock.png"><img src="/images/imageWebRTC/ReceiveReportBlock.png"><img src="/images/imageWebRTC/RTCPReceiverReport.png"><img src="/images/imageWebRTC/RTCPSR-RR发送时机.png"><img src="/images/imageWebRTC/RTCPSDES.png"><img src="/images/imageWebRTC/SDESitem.png"><img src="/images/imageWebRTC/SDES说明.png"><img src="/images/imageWebRTC/RTCPBYE.png"><img src="/images/imageWebRTC/RTCPAPP.png"><img src="/images/imageWebRTC/RTCPAPP字段说明.png"><h3 id="15-3-【协议规范】DTSL"><a href="#15-3-【协议规范】DTSL" class="headerlink" title="15.3 【协议规范】DTSL"></a>15.3 【协议规范】DTSL</h3><img src="/images/imageWebRTC/DTLS.png"><img src="/images/imageWebRTC/SRTP.png"><h3 id="15-4-wireshark-分析-rtp-rtcp-包"><a href="#15-4-wireshark-分析-rtp-rtcp-包" class="headerlink" title="15.4 wireshark 分析 rtp-rtcp 包"></a>15.4 wireshark 分析 rtp-rtcp 包</h3><p>TODO</p><h2 id="16-Android端与浏览器互通"><a href="#16-Android端与浏览器互通" class="headerlink" title="16. Android端与浏览器互通"></a>16. Android端与浏览器互通</h2><h3 id="16-1-Android-与浏览器互通"><a href="#16-1-Android-与浏览器互通" class="headerlink" title="16.1 Android 与浏览器互通"></a>16.1 Android 与浏览器互通</h3><img src="/images/imageWebRTC/主要内容.png"><img src="/images/imageWebRTC/需要权限.png"><img src="/images/imageWebRTC/Android权限管理.png"><img src="/images/imageWebRTC/引入库.png"><img src="/images/imageWebRTC/信令处理.png"><img src="/images/imageWebRTC/AndroidSocketio.png"><img src="/images/imageWebRTC/socketio接收消息.png"><h3 id="16-2-WebRTCNative-开发逻辑"><a href="#16-2-WebRTCNative-开发逻辑" class="headerlink" title="16.2 WebRTCNative 开发逻辑"></a>16.2 WebRTCNative 开发逻辑</h3><img src="/images/imageWebRTC/结构图.png"><img src="/images/imageWebRTC/呼叫端时序图.png"><img src="/images/imageWebRTC/被叫端时序图.png"><img src="/images/imageWebRTC/关闭时序图.png"><img src="/images/imageWebRTC/webrtc处理流程.png"><img src="/images/imageWebRTC/重要类-01.png"><img src="/images/imageWebRTC/重要类-02.png"><img src="/images/imageWebRTC/两个观察者.png"><h3 id="16-3-实战-权限申请-库的引入与界面"><a href="#16-3-实战-权限申请-库的引入与界面" class="headerlink" title="16.3 实战-权限申请-库的引入与界面"></a>16.3 实战-权限申请-库的引入与界面</h3><img src="/images/imageWebRTC/权限库界面.png"><h3 id="16-4-实战-通过-socket-io-实现信令收发"><a href="#16-4-实战-通过-socket-io-实现信令收发" class="headerlink" title="16.4 实战-通过 socket.io 实现信令收发"></a>16.4 实战-通过 socket.io 实现信令收发</h3><img src="/images/imageWebRTC/收发信令.png"><h3 id="16-5-实战-Android-与浏览器互通"><a href="#16-5-实战-Android-与浏览器互通" class="headerlink" title="16.5 实战-Android 与浏览器互通"></a>16.5 实战-Android 与浏览器互通</h3><p>创建 PeerConnection：</p><ul><li>音视频数据采集</li><li>创建 PeerConnection</li></ul><p>媒体能力协商：</p><ul><li>协商媒体能力</li><li>Candidate 连通</li><li>视频渲染</li></ul><h2 id="17-iOS端与浏览器互通"><a href="#17-iOS端与浏览器互通" class="headerlink" title="17. iOS端与浏览器互通"></a>17. iOS端与浏览器互通</h2><h3 id="17-1-IOS权限获取"><a href="#17-1-IOS权限获取" class="headerlink" title="17.1 IOS权限获取"></a>17.1 IOS权限获取</h3><img src="/images/imageWebRTC/主要内容-01.png"><img src="/images/imageWebRTC/主要内容-02.png"><h3 id="17-2-IOS引入WebRTC库"><a href="#17-2-IOS引入WebRTC库" class="headerlink" title="17.2 IOS引入WebRTC库"></a>17.2 IOS引入WebRTC库</h3><img src="/images/imageWebRTC/引入WebRTC库的方式.png"><img src="/images/imageWebRTC/引入WebRTC库.png"><img src="/images/imageWebRTC/Podfile.png"><h3 id="17-3-IOS端SocketIO的使用"><a href="#17-3-IOS端SocketIO的使用" class="headerlink" title="17.3 IOS端SocketIO的使用"></a>17.3 IOS端SocketIO的使用</h3><img src="/images/imageWebRTC/socketio的使用.png"><img src="/images/imageWebRTC/连接服务器.png"><img src="/images/imageWebRTC/发送消息.png"><img src="/images/imageWebRTC/注册侦听消息.png"><h3 id="17-4-IOS界面布局"><a href="#17-4-IOS界面布局" class="headerlink" title="17.4 IOS界面布局"></a>17.4 IOS界面布局</h3><p>TODO</p><h3 id="17-5-IOS本地视频采集与展示"><a href="#17-5-IOS本地视频采集与展示" class="headerlink" title="17.5 IOS本地视频采集与展示"></a>17.5 IOS本地视频采集与展示</h3><p>TODO</p><h3 id="17-6-IOS端RTCPeerConnection"><a href="#17-6-IOS端RTCPeerConnection" class="headerlink" title="17.6 IOS端RTCPeerConnection"></a>17.6 IOS端RTCPeerConnection</h3><p>TODO</p><h3 id="17-7-IOS媒体协商"><a href="#17-7-IOS媒体协商" class="headerlink" title="17.7 IOS媒体协商"></a>17.7 IOS媒体协商</h3><img src="/images/imageWebRTC/媒体协商.png"><img src="/images/imageWebRTC/信令时序图.png"><h3 id="17-8-IOS远端视频渲染"><a href="#17-8-IOS远端视频渲染" class="headerlink" title="17.8 IOS远端视频渲染"></a>17.8 IOS远端视频渲染</h3><img src="/images/imageWebRTC/RTCPeerConnection委托.png"><h2 id="18-课程总结"><a href="#18-课程总结" class="headerlink" title="18. 课程总结"></a>18. 课程总结</h2><img src="/images/imageWebRTC/小结.png"><img src="/images/imageWebRTC/信令服务器.png"><img src="/images/imageWebRTC/JS客户端实现.png"><img src="/images/imageWebRTC/JS客户端实现-01.png"><img src="/images/imageWebRTC/进阶.png"><img src="/images/imageWebRTC/进阶-01.png"><img src="/images/imageWebRTC/行业痛点.png"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzUxMTIxOWU1MWQ0NTUyMmMzMDY2Yzk=" title="https://juejin.im/post/5c511219e51d45522c3066c9">JavaScript 是如何工作的:WebRTC 和对等网络的机制！<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTQwMzU5Nw==" title="https://segmentfault.com/a/1190000011403597">深入理解WebRTC<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2htYWkvYXJ0aWNsZS9kZXRhaWxzLzY5NjgxNTk1" title="https://blog.csdn.net/fishmai/article/details/69681595">WebRTC架构简介<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFycmV0bGVlLmNvbS9ibG9nLzIwMTUvMTAvMDUvaG93LXRvLWJ1aWxkLWEtaHR0cHMtc2VydmVyLw==" title="https://www.barretlee.com/blog/2015/10/05/how-to-build-a-https-server/">HTTPS证书生成原理和部署细节<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85MDkxZWJkNDM5YTA=" title="https://www.jianshu.com/p/9091ebd439a0">SSL证书生成流程<i class="fa fa-external-link"></i></span></p></blockquote><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ncmFkbGUub3JnL2luc3RhbGwv" title="https://gradle.org/install/">Gradle官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3Rvb2xzLmFuZHJvaWQtc3R1ZGlvLm9yZy9pbmRleC5waHAvOS10b29scy8xMDktYW5kcm9pZC10b29scy1kb3dubG9hZA==" title="http://tools.android-studio.org/index.php/9-tools/109-android-tools-download">Gradle 包<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zNmU1NjljMWJiMTI=" title="https://www.jianshu.com/p/36e569c1bb12">Mac下AndroidStudio中手动配置Gradle<i class="fa fa-external-link"></i></span></p></blockquote><p>WebRTC的分层协议图：</p><img src="/images/imageWebRTC/webrtc分层协议图.png"><p>信令，会话和协议：</p><img src="/images/imageWebRTC/信令会话协议.png"><h2 id="问题解决里程"><a href="#问题解决里程" class="headerlink" title="问题解决里程"></a>问题解决里程</h2><p>node 启动 server 报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">events.js:141</span><br><span class="line">      throw er; // Unhandled 'error' event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EACCES 0.0.0.0:443</span><br><span class="line">    at Object.exports._errnoException (util.js:870:11)</span><br><span class="line">    at exports._exceptionWithHostPort (util.js:893:20)</span><br><span class="line">    at Server._listen2 (net.js:1224:19)</span><br><span class="line">    at listen (net.js:1273:10)</span><br><span class="line">    at net.js:1382:9</span><br><span class="line">    at nextTickCallbackWith3Args (node.js:452:9)</span><br><span class="line">    at process._tickCallback (node.js:358:17)</span><br><span class="line">    at Function.Module.runMain (module.js:444:11)</span><br><span class="line">    at startup (node.js:136:18)</span><br><span class="line">    at node.js:966:3</span><br><span class="line"><span class="meta">[Solve]$</span><span class="bash"> sudo <span class="built_in">setcap</span> <span class="string">'cap_net_bind_service=+ep'</span> $(readlink -f $(<span class="built_in">which</span> node))</span></span><br></pre></td></tr></table></figure><p>查询端口是否别占用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -ntpl | grep 443</span></span><br></pre></td></tr></table></figure><h2 id="VIM-快捷键温习"><a href="#VIM-快捷键温习" class="headerlink" title="VIM 快捷键温习"></a>VIM 快捷键温习</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93eG5hY3kuY29tLzIwMTcvMDkvMjIvdmltLXBsdWdpbi10ZXJuLw==" title="https://wxnacy.com/2017/09/22/vim-plugin-tern/">Vim 插件 tern_for_vim Javascript 自动补全<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hcmNoaXZlLzIwMTIvMDYvMTQvdmltX25vdGVzLmh0bWwjaWQxMDc=" title="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107">最全的vim快捷键<i class="fa fa-external-link"></i></span></p></blockquote><p>vim 格式化文本，调整缩进：</p><blockquote><p>= 是格式化文本的快捷方法， 当你发现代码缩进的不整齐的，可以用这个快速对齐它们。</p><p>直接按＝号就可以，不能进入命令模式（以 “:” 冒号开始的命令行）。</p><p>gg=G ：从头格到尾，爽。</p><p>＝＝ 格式化一行</p><p>如要格式化一段代码，可以先选中这些代码，再按＝号。</p><p>调整缩进还有个比较慢的办法，按＞＞，向右缩进一格，＜＜向左缩进一格。</p></blockquote><p>vim常用快捷键总结：</p><ul><li><p>光标移动到行首：0</p></li><li><p>光标移动到行尾：$</p></li><li><p>光标移动到文件开始：GG</p></li><li><p>光标移动到文件末尾：shift +G</p></li><li><p>先前翻页：Ctrl+f</p></li><li><p>向后翻页：Ctrl+b</p></li><li><p>删至行首：d0</p></li><li><p>删至行尾：d$</p></li><li><p>删除当前行及其后面n-1行：ndd</p></li><li><p>删除当前字符：x</p></li><li><p>删除当前字符的前一个字符：X</p></li><li><p>删除当前字符：dl</p></li><li><p>删除到第三个字符的结尾位置：d3w</p></li><li><p>删除到某个单词的末尾：dw</p></li><li><p>删除到某个单词的开始：db</p></li><li><p>删除当前行到文件的末尾：dG</p></li><li><p>删除当前行到文件第一行：dH</p></li><li><p>删除知道屏幕上最后一行：dL</p></li><li><p>替换当前行所有temp为hehe：:s/temp/hehe/g</p></li><li><p>替换每行中第一个#include为hehe：:%s/#include/hehe/</p></li><li><p>替换每行中所有的#include为hehe：:%s/#include/hehe/g</p></li><li><p>替换第n行开始到最后一行中每一行的第一个#include为hehe：:n,$s/#include/hehe/</p></li><li><p>替换第n行开始到最后一行中每一行的所有#include为hehe：:n,$s/#include/hehe/g</p></li><li><p>替换当前行到末尾的所有#include为hehe：:.,$s/#include/hehe/g</p></li><li><p>替换正文中所有出现的#include为hehe：:1,$s/#include/hehe/g</p></li><li><p>回复上一步操作：u</p></li><li><p>全部回复操作：shift + u</p></li><li><p>重做上一步操作：Ctrl + r</p></li><li><p>把下一行合并到当前行尾：J</p></li><li><p>选中当前行及其后面的n-1行：nV</p></li><li><p>复制当前光标到此单词末尾：yw</p></li><li><p>批量添加注释：Ctrl+v可视模式，上、下、左、右移动光标选择若干行开头；Shift+i进入插入模式；输入// 者；按Esc</p></li><li><p>批量去掉注释：Ctrl+v可视模式，上、下、左、右移动关闭选择要删除的注释符，如//或#；按d删除</p></li><li><p>横向打开另一个窗口：:sp 文件名</p></li><li><p>竖向打开另一个窗口：:vsp 文件名</p></li><li><p>关闭当前打开的所有窗口：:qa</p></li><li><p>选择当前字符所在的单词：Ctrl+v可视模式，然后a+w或i+w</p></li><li><p>选择当前字符所在的段落：Ctrl+v可视模视，然后i+p或a+p</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WebRTC&quot;&gt;&lt;a href=&quot;#WebRTC&quot; class=&quot;headerlink&quot; title=&quot;WebRTC&quot;&gt;&lt;/a&gt;WebRTC&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYlJUQ19BUEk=&quot; title=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API&quot;&gt;WebRTC API&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL25vZGVqcy5jbi9hcGkv&quot; title=&quot;http://nodejs.cn/api/&quot;&gt;Node.js v10.15.3 文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI1MjM1MzU5MDQw&quot; title=&quot;https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040&quot;&gt;廖雪峰 - nodejs&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-WebRTC-介绍&quot;&gt;&lt;a href=&quot;#1-WebRTC-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. WebRTC 介绍&quot;&gt;&lt;/a&gt;1. WebRTC 介绍&lt;/h2&gt;
    
    </summary>
    
      <category term="WebRTC" scheme="http://miaopei.github.io/categories/WebRTC/"/>
    
    
      <category term="WebRTC" scheme="http://miaopei.github.io/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg编程基础和一些常见问题的解答</title>
    <link href="http://miaopei.github.io/2019/05/09/FFmpeg/ffmpeg%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94/"/>
    <id>http://miaopei.github.io/2019/05/09/FFmpeg/ffmpeg编程基础和一些常见问题的解答/</id>
    <published>2019-05-09T02:14:50.000Z</published>
    <updated>2019-06-10T07:29:14.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMTcwMDUvYXJ0aWNsZS9kZXRhaWxzLzUxMDgzNzQ1" title="https://blog.csdn.net/u010317005/article/details/51083745">ffmpeg编程基础和一些常见问题的解答<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="FFMpeg-编程的大致框架"><a href="#FFMpeg-编程的大致框架" class="headerlink" title="FFMpeg 编程的大致框架"></a>FFMpeg 编程的大致框架</h2><a id="more"></a><img src="/images/imageFFmpeg/ffmpeg编程大致框架.png"><p><strong>进一步的详解，具体到函数调用级别</strong></p><img src="/images/imageFFmpeg/ffmpeg函数调用级别.png"><p>详细步骤：</p><ul><li><p>注册所有容器格式和 <code>CODEC:av_register_all(）</code></p></li><li><p>打开文件: <code>av_open_input_file()</code></p></li><li><p>从文件中提取流信息 : <code>av_find_stream_info()</code></p></li><li><p>穷举所有的流，查找其中种类为 <code>CODEC_TYPE_VIDEO</code></p></li><li><p>查找对应的解码器 : <code>avcodec_find_decoder()</code></p></li><li><p>打开编解码器 : <code>avcodec_open()</code></p></li><li><p>为解码帧分配内存 : <code>avcodec_alloc_frame()</code></p></li><li><p>不停地从码流中提取出帧数据 : <code>av_read_frame()</code></p></li><li><p>判断帧的类型，对于视频帧调用 : <code>avcodec_decode_video()</code></p></li><li><p>解码完后，释放解码器 : <code>avcodec_close()</code></p></li><li><p>关闭输入文件 : <code>av_close_input_file()</code></p></li></ul><p>首先第一件事情就是<strong>开一个视频文件并从中得到流</strong>。</p><p>我们要做的第一件事情就是<strong>使用</strong> <code>av_register_all()</code> ;来初始化 <code>libavformat/libavcodec</code> :</p><p>这一步注册库中含有的所有可用的文件格式和编码器，这样当打开一个文件时，它们才能够自动选择相应的文件格式和编码器。<code>av_register_all()</code> 只需调用一次，所以，要放在初始化代码中。也可以仅仅注册个人的文件格式和编码。</p><p>下一步，<strong>打开文件</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *pFormatCtx;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>      *filename = <span class="string">"myvideo.mpg"</span>;</span><br><span class="line">av_open_input_file(&amp;pFormatCtx, filename, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)；   <span class="comment">// 打开视频文件</span></span><br></pre></td></tr></table></figure><p>最后三个参数描述了文件格式，缓冲区大小（<em>size</em>）和格式参数；我们通过简单地指明<em>NULL</em>或<em>0</em>告诉 <code>libavformat</code> 去自动探测文件格式并且使用默认的缓冲区大小。这里的格式参数指的是视频输出参数，比如宽高的坐标。</p><p>下一步，我们需要<strong>取出包含在文件中的流信息</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">av_find_stream_info(pFormatCtx)；  <span class="comment">// 取出流信息</span></span><br><span class="line">dump_format(pFormatCtx, <span class="number">0</span>, filename, <span class="literal">false</span>);  <span class="comment">//我们可以使用这个函数把获取到得参数全部输出。</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)  <span class="comment">//区分视频流和音频流</span></span><br><span class="line"><span class="keyword">if</span>(pFormatCtx-&gt;streams-&gt;codec.codec_type == CODEC_TYPE_VIDEO) <span class="comment">//找到视频流，这里也可以换成音频</span></span><br><span class="line">&#123;</span><br><span class="line">   videoStream = i;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就需要<strong>寻找解码器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVCodec *pCodec;</span><br><span class="line">pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">avcodec_open(pCodecCtx, pCodec)；    <span class="comment">// 打开解码器</span></span><br></pre></td></tr></table></figure><p><strong>给视频帧分配空间以便存储解码后的图片</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVFrame *pFrame;</span><br><span class="line">pFrame = avcodec_alloc_frame();</span><br></pre></td></tr></table></figure><p><strong>////////////////////////////////////////开始解码///////////////////////////////////////////</strong></p><p>第一步当然是<strong>读数据</strong>：</p><p>我们将要做的是通过读取包来读取整个视频流，然后把它解码成帧，最后转换格式并且保存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="number">0</span>) &#123;  <span class="comment">//读数据</span></span><br><span class="line"><span class="keyword">if</span>(packet.stream_index==videoStream)&#123;      <span class="comment">//判断是否视频流</span></span><br><span class="line">avcodec_decode_video(pCodecCtx, pFrame, &amp;frameFinished, packet.data, packet.size);   <span class="comment">//解码</span></span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">if</span>(frameFinished) &#123;</span><br><span class="line">img_convert((AVPicture *)pFrameRGB, PIX_FMT_RGB24,(AVPicture*)pFrame, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-          &gt;height); <span class="comment">//转换   </span></span><br><span class="line">&#125;</span><br><span class="line">SaveFrame(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, i); <span class="comment">//保存数据</span></span><br><span class="line">av_free_packet(&amp;packet);  <span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>av_read_frame()</code> 读取一个包并且把它保存到 <code>AVPacket</code> 结构体中。这些数据可以在后面通过 <code>av_free_packet()</code> 来释放。函数 <code>avcodec_decode_video()</code> 把包转换为帧。然而当解码一个包的时候，我们可能没有得到我们需要的关于帧的信息。因此，当我们得到下一帧的时候， <code>avcodec_decode_video()</code> 为我们设置了帧结束标志 <code>frameFinished</code>。最后，我们使用  <code>img_convert()</code> 函数来把帧从原始格式（<code>pCodecCtx-&gt;pix_fmt</code>）转换成为 <code>RGB</code> 格式。要记住，你可以把一个 <code>AVFrame</code> 结构体的指针转换为 <code>AVPicture</code> 结构体的指针。最后，我们把帧和高度宽度信息传递给我们的 <code>SaveFrame</code> 函数。</p><p>到此解码完毕，显示过程使用 <code>SDL</code> 完成考虑到我们以后会使用 <code>firmware</code> 进行显示操作，<code>SDL</code> 忽略不讲。</p><h2 id="音视频同步"><a href="#音视频同步" class="headerlink" title="音视频同步"></a>音视频同步</h2><p><strong><em>DTS</em>（解码时间戳）和 <em>PTS</em>（显示时间戳）</strong></p><p>当我们调用 <code>av_read_frame()</code> 得到一个包的时候，<strong><em>PTS</em></strong> 和 <strong><em>DTS</em></strong> 的信息也会保存在包中。但是我们真正想要的 <strong><em>PTS</em></strong> 是我们刚刚解码出来的原始帧的 <strong><em>PTS</em></strong>，这样我们才能知道什么时候来显示它。然而，我们从 <code>avcodec_decode_video()</code> 函数中得到的帧只是一个 <code>AVFrame</code>，其中并没有包含有用的 <strong><em>PTS</em></strong> 值（注意：<code>AVFrame</code> 并没有包含时间戳信息，但当我们等到帧的时候并不是我们想要的样子）。</p><p>我们保存一帧的第一个包的 <strong><em>PTS</em></strong>：这将作为整个这一帧的 <strong><em>PTS</em></strong>。我们可以通过函数 <code>avcodec_decode_video()</code> 来计算出哪个包是一帧的第一个包。</p><p>怎样实现呢？任何时候当一个包开始一帧的时候，<code>avcodec_decode_video()</code> 将调用一个函数来为一帧申请一个缓冲。当然，<code>ffmpeg</code> 允许我们重新定义那个分配内存的函数。计算前一帧和现在这一帧的时间戳来预测出下一个时间戳的时间。同时，我们需要同步视频到音频。我们将设置一个音频时间 <code>audioclock</code>；一个内部值记录了我们正在播放的音频的位置。就像从任意的 <em>mp3</em> 播放器中读出来的数字一样。既然我们把视频同步到音频，视频线程使用这个值来算出是否太快还是太慢。</p><p><strong>用 FFMPEG SDK 进行视频转码压缩时解决音视频不同步问题的方法:</strong></p><p>用 <em>FFMPEG SDK</em> 进行视频转码压缩的时候，转码成功后去看视频的内容，发现音视频是不同步的。这个的确是一个恼火的事情。我在用 <em>FFMPEG SDK</em> 做 <em>h264</em> 格式的 <em>FLV</em> 文件编码 <em>Filter</em> 的时候就碰到了这个问题。</p><p>经过研究发现，<em>FFMPEG SDK</em> 写入视频的时候有两个地方用来控制写入的时间戳，一个是 <code>AvPacket</code> 一个是 <code>AvFrame</code> 。在调用 <code>avcodec_encode_video</code> 的时候需要传入 <code>AvFrame</code> 的对象指针，也就是传入一帧未压缩的视频进行压缩处理，<code>AvFrame</code> 包含一个 <strong><em>pts</em></strong> 的参数，这个参数就是当前帧将来在还原播放的时候的时间戳。而 <code>AvPacket</code> 里面也有 <strong><em>pts</em></strong>，还有 <strong><em>dts</em></strong>。说起这个就必须要说明一下 <code>I , P , B</code> 三种视频压缩帧。<code>I</code> 帧就是关键帧，不依赖于其他视频帧，<code>P</code> 帧是向前预测的帧，只依赖于前面的视频帧，而 <code>B</code> 帧是双向预测视频帧，依赖于前后视频帧。由于 <code>B</code> 帧的存在，因为它是双向的，必须知道前面的视频帧和后面的视频帧的详细内容后，才能知道本 <code>B</code> 帧最终该呈现什么图像。而 <strong><em>pts</em></strong> 和 <strong><em>dts</em></strong> 两个参数就是用来控制视频帧的显示和解码的顺序。</p><p><strong><em>pts</em></strong> 就是帧显示的顺序。<strong><em>dts</em></strong> 就是帧被读取进行解码的顺序。如果没有 <code>B</code> 帧存在，<strong><em>dts</em></strong> 和 <strong><em>pts</em></strong> 是相同的。反之，则是不相同的。关于这个的详细介绍可以参考一下 <em>mpeg</em> 的原理。</p><p><strong>AvPacket 包含的 pts 和 dts 两个到底该设置什么值？</strong></p><p><strong><em>pts</em></strong> 和 <strong><em>dts</em></strong> 需要设置的就是视频帧解码和显示的顺序。每增加一帧就加一，并不是播放视频的时间戳。但是实践证明经过 <em>rmvb</em> 解码的视频有时候并不是固定帧率的，而是变帧率的，这样，如果每压缩一帧，<strong><em>pts</em></strong> 和 <strong><em>dts</em></strong> 加一的方案为导致音视频不同步。</p><p><strong>那怎么来解决音视频同步的问题呢？</strong></p><p>请看如下代码段。</p><p><code>lTimeStamp</code> 是通过 <code>directshow</code> 获取的当前的视频帧的时间戳。<code>m_llframe_index</code> 为当前已经经过压缩处理的帧的数量。</p><p>首先 <code>av_rescale</code> 计算得到当前压缩处理已经需要处理什么时间戳的视频帧，如果该时间戳尚未到达 <code>directshow</code> 当前提供的视频帧的时间戳，则将该帧丢弃掉。</p><p>否则进行压缩操作。并设置 <code>AVPacket</code> 的 <strong><em>pts</em></strong> 和 <strong><em>dts</em></strong>。这里假设 <code>B</code> 帧不存在。</p><p>因为在将来播放的时候视频以我们设定的固定播放帧率进行播放，所以需要根据设定的播放帧率计算得到的视频帧时间戳和 <code>directshow</code> 提供的当前视频帧的时间戳进行比较，设定是否需要进行实施延缓播放的策略。如果需要延缓播放，则将 <strong><em>pts</em></strong> 增加步长 <code>2</code>，否则以普通速度播放，则设置为 <code>1.dts</code> 与之相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__int64 x =av_rescale(m_llframe_index,AV_TIME_BASE*(<span class="keyword">int64_t</span>)c-&gt;time_base.num,c-&gt;time_base.den);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( x &gt; lTimeStamp )&#123;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">m_pVideoFrame2-&gt;pts = lTimeStamp;</span><br><span class="line">m_pVideoFrame2-&gt;pict_type = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> out_size = avcodec_encode_video( c, m_pvideo_outbuf, video_outbuf_size,m_pVideoFrame2 );</span><br><span class="line"><span class="comment">/* if zero size, it means the image was buffered */</span></span><br><span class="line"><span class="keyword">if</span> (out_size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      AVPacket pkt;</span><br><span class="line">      av_init_packet(&amp;pkt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( x &gt; lTimeStamp )</span><br><span class="line">&#123;</span><br><span class="line">   pkt.pts = pkt.dts = m_llframe_index;</span><br><span class="line">   pkt.duration = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">   pkt.duration = (lTimeStamp - x)*c-&gt;time_base.den/<span class="number">1000000</span> + <span class="number">1</span>;</span><br><span class="line">   pkt.pts = m_llframe_index;</span><br><span class="line">   pkt.dts = pkt.pts;</span><br><span class="line">   m_llframe_index += pkt.duration;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//pkt.pts = lTimeStamp * (__int64)frame_rate.den / 1000;</span></span><br><span class="line"><span class="keyword">if</span>( c-&gt;coded_frame &amp;&amp; c-&gt;coded_frame-&gt;key_frame )&#123;</span><br><span class="line">    pkt.flags |= PKT_FLAG_KEY;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">pkt.stream_index= m_pVideoStream-&gt;index;</span><br><span class="line">pkt.data= m_pvideo_outbuf;</span><br><span class="line">pkt.size= out_size;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* write the compressed frame in the media file */</span></span><br><span class="line">ret = av_interleaved_write_frame( m_pAvFormatContext, &amp;pkt );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>avcodec_decode_video 解码的帧为什么后面的比前面的 pts 小呢？</strong></p><p>请问如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( av_read_frame(pFormatCtxSource,&amp;packet)&gt;=<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( packet.stream_index == videoStream )&#123;</span><br><span class="line">        <span class="keyword">int</span> out_size = avcodec_decode_video(pCodecCtxSource, pFrameSource, &amp;bFrameFinished, packet.data, packet.size);</span><br><span class="line">        <span class="keyword">if</span>( bFrameFinished )&#123;</span><br><span class="line">            pFrameSource-&gt;pts = av_rescale_q(packet.pts, pCodecCtxSource-&gt;time_base, pStCodec-&gt;time_base);</span><br><span class="line">            <span class="keyword">int</span> out_size = avcodec_encode_video(pStCodec, video_buffer, <span class="number">200000</span>, pFrameSource); <span class="comment">// Encodeto output</span></span><br><span class="line">            <span class="keyword">if</span>( out_size&gt;<span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    av_free_packet(&amp;packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我<em>Decode</em>的时候，第一帧得到的 <em>pFrameSource-&gt;pts</em> 是<em>96</em>，再解第二帧的时候，<em>pFrameSource-&gt;pts</em>计算完后就成了<em>80</em>几，后几帧也是比<em>96</em>小，过一会又会解出来一个<em>100</em>多的，接下来又是比<em>100</em>多小的，这是为什么？在<em>Encode</em>的时候，先<em>Encode</em>一个<em>pts=96</em>的，再去<em>Encode</em>比<em>96</em>小的帧就返回<em>-1</em>了，直到找到一个比<em>96</em>大的。</p><p><strong>理解：</strong></p><p><em>Decoder</em>后<em>output</em>的<em>pts</em>是按正常的顺序，即显示的顺序输出的，如果有<em>B</em>帧，<em>decoder</em>会缓存。</p><p>但<em>encoder</em>后，输出的是按<em>dts</em>输出的。</p><p><em>Pts,dts</em>并不是时间戳，而更应该理解为<em>frame</em>的顺序序列号。由于每帧<em>frame</em>的帧率并不一定是一致的，可能会变化的。转换为时间戳的话，应该是（<em>pts</em> 帧率）。为加深理解</p><p>可以将<em>pts</em>比做是第<em>pts</em>帧<em>frame</em>，假设每帧的帧率不变的话，则显示的时间戳为（<em>pts**帧率），如果考虑帧率变化的，则要想办法将（</em>pts 当前的帧率）累加到后面。</p><p>可以看出有的<em>pts</em>是<em>+1</em>累加，有的是加了很多，但都是按顺序累加的。当传人<em>decoder</em>前的<em>packet</em>有<em>pts</em>时，则<em>decoder</em>后获取的<em>frame</em>将会赋值<em>packet</em>的<em>pts</em>；当传人的<em>packet</em>只是一帧的部分数据或是<em>B</em>帧，由于<em>decoder</em>出来的<em>frame</em>要按正常的<em>pts</em>顺序输出，有可能<em>decoder</em>不会获取到<em>frame</em>，或<em>decoder</em>内部会缓存也不会输出<em>frame</em>，即<em>frame</em>的<em>pts</em>会为空。<em>Frame pts</em>（即<em>opaque</em>）为空的话则会看<em>frame-&gt;dts,dts</em>都没有的话才认为<em>frame-&gt;pts</em>为<em>0.</em></p><p>对于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pts *= av_q2d(is-&gt;video_st-&gt;time_base);  <span class="comment">// 即pts帧率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Did we get avideo frame?</span></span><br><span class="line"><span class="keyword">if</span>(frameFinished) &#123;</span><br><span class="line">pts=synchronize_video(is, pFrame, pts);</span><br></pre></td></tr></table></figure><p><em>synchronize_video</em> 考虑了 3中情况：</p><p><em>1.    pts</em> 拿到的话就用该<em>pts</em></p><p><em>2.    pts</em>没有拿到的话就用前一帧的<em>pts</em>时间</p><p><em>3.</em>    如果该帧要重复显示，则将显示的<code>数量 * 帧率</code>，再加到前面的 <em>pts</em> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;<span class="comment">/////传人decoder后的帧队列中，以便后续去获取show。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">synchronize_video</span><span class="params">(VideoState *is, AVFrame*src_frame, <span class="keyword">double</span> pts)</span> </span>&#123; </span><br><span class="line">  doubleframe_delay; </span><br><span class="line">  <span class="keyword">if</span>(pts != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* if we havepts, set video clock to it */</span></span><br><span class="line">    is-&gt;video_clock = pts;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* if we aren'tgiven a pts, set it to the clock */</span></span><br><span class="line">    pts =is-&gt;video_clock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* update thevideo clock */</span></span><br><span class="line">   <span class="comment">/////很关键：前面传进来的pts已经是时间戳了，是当前frame开始播放的时间戳，</span></span><br><span class="line">   <span class="comment">/////下面frame_delay是该帧显示完将要花费的时间，（pts+frame_delay）也即是/////预测的下一帧将要播放的时间戳。</span></span><br><span class="line">  frame_delay =av_q2d(is-&gt;video_st-&gt;codec-&gt;time_base);</span><br><span class="line">  <span class="comment">/* if we arerepeating a frame, adjust clock accordingly */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//////重复多帧的话要累加上</span></span><br><span class="line">  frame_delay +=src_frame-&gt;repeat_pict * (frame_delay * <span class="number">0.5</span>);</span><br><span class="line">  is-&gt;video_clock += frame_delay;</span><br><span class="line">  <span class="keyword">return</span> pts;<span class="comment">/////此时返回的值即为下一帧将要开始显示的时间戳。</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">///////开定时器去显示帧队列中的已经decode过的数据，按前面的分析我们已经知道帧队列中的数据已经是按pts顺序插入到队列中的。Timer的作用就是有帧率不一致及重复帧的情况造成时间戳不是线性的，有快有慢，从而tutorial5才有timer的方式来播放追赶</span></span><br></pre></td></tr></table></figure><p>以下是一个网友很直观浅显的例子解释：</p><p><code>if(packet-&gt;dts == AV_NOPTS_VALUE</code> 是不是就是没有获取到 <em>dts</em> 的情况？</p><p>就是有一把尺子一只蚂蚁跟着一个标杆走</p><p>标杆是匀速的蚂蚁或快或慢</p><p>慢了你就抽让他跑起来快了就拽它</p><p>这样音（标杆）视频（蚂蚁）就能同步了</p><p>这里最大的问题就是音频是匀速的视频是非线性的</p><p>另外：此时 <em>vp–&gt;pts</em> 获取到的 <em>pts</em> 已经转化为时间戳了，这个时间戳为就是当前帧显示结束的时间戳，也即是下一帧将显示的预测时间戳。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">video_refresh_timer</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">  VideoState *is = (VideoState*)userdata;</span><br><span class="line">  VideoPicture *vp;</span><br><span class="line">  <span class="keyword">double</span> actual_delay, delay,sync_threshold, ref_clock, diff;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(is-&gt;video_st) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;pictq_size == <span class="number">0</span>) &#123;</span><br><span class="line">      schedule_refresh(is, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vp =&amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line">      delay = vp-&gt;pts -is-&gt;frame_last_pts; <span class="comment">/* the pts from last time */</span>  <span class="comment">////这是当前要显示的frame和下一副                                                        //////将要显示的frame的间隔时间</span></span><br><span class="line">      <span class="keyword">if</span>(delay &lt;= <span class="number">0</span> || delay&gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">         <span class="comment">/* if incorrect delay, useprevious one */</span></span><br><span class="line">         delay =is-&gt;frame_last_delay;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* save for next time */</span></span><br><span class="line">      is-&gt;frame_last_delay =delay;</span><br><span class="line">      is-&gt;frame_last_pts =vp-&gt;pts;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* update delay to sync toaudio */</span></span><br><span class="line">      ref_clock = get_audio_clock(is);<span class="comment">/////获取到声音当前播放的时间戳。</span></span><br><span class="line">      diff = vp-&gt;pts -ref_clock;<span class="comment">////// vp-&gt;pts实际上是预测的下一帧将要播放的开始时间,</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">//也就是说在diff这段时间中声音是匀速发生的，但是在delay这段时间frame的显示可能就会有快//////////慢的区别。   </span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Skip or repeat the frame.Take delay into account</span></span><br><span class="line"><span class="comment">          FFPlay still doesn't "know if this is thebest guess." */</span></span><br><span class="line">      sync_threshold = (delay &gt;AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">         <span class="keyword">if</span>(diff &lt;=-sync_threshold) &#123;</span><br><span class="line">           delay = <span class="number">0</span>;<span class="comment">//////下一帧画面显示的时间和当前的声音很近的话加快显示下一帧（即后面video_display显示完当前帧后开启定时器很快          去显示下一帧）</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span>(diff &gt;=sync_threshold) &#123;</span><br><span class="line">           delay = <span class="number">2</span> * delay;       <span class="comment">//////下一帧开始显示的时间和当前声音的时间隔的比较长则延缓，即两帧画面间话的显示的时间长度大于两帧画面  间的声音播放的时间，则我们将两帧画显示的时候加倍拖长点，比如帧1和帧2的时间显示间隔为40ms，但帧1和帧2的声音播放时间为55ms，怎么办呢？我们不可能去打乱声音的质量的，则我们采用的方法是：将两帧画面的播放间隔加大，本来是过30ms就要开始播下一帧的，我们改成60ms后才播下一帧。</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="comment">///当然如果diff大于AV_NOSYNC_THRESHOLD，即快进的模式了，画面跳动太大，不存在音视频同步的问题了。</span></span><br><span class="line"> </span><br><span class="line">      is-&gt;frame_timer += delay;</span><br><span class="line">      <span class="comment">/* computer the REAL delay*/</span></span><br><span class="line">      actual_delay =is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line">      <span class="keyword">if</span>(actual_delay &lt; <span class="number">0.010</span>)&#123;</span><br><span class="line">         <span class="comment">/* Really it should skipthe picture instead */</span></span><br><span class="line">         actual_delay = <span class="number">0.010</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      schedule_refresh(is,(<span class="keyword">int</span>)(actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));<span class="comment">////开定时器去显示下一帧</span></span><br><span class="line">      <span class="comment">/* show the picture! */</span></span><br><span class="line">      video_display(is);<span class="comment">////立马显示当前帧</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">/* update queue for nextpicture! */</span></span><br><span class="line">      <span class="keyword">if</span>(++is-&gt;pictq_rindex ==VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">         is-&gt;pictq_rindex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">      is-&gt;pictq_size--;</span><br><span class="line">     SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">     SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    schedule_refresh(is, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMTcwMDUvYXJ0aWNsZS9kZXRhaWxzLzUxMDgzNzQ1&quot; title=&quot;https://blog.csdn.net/u010317005/article/details/51083745&quot;&gt;ffmpeg编程基础和一些常见问题的解答&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;FFMpeg-编程的大致框架&quot;&gt;&lt;a href=&quot;#FFMpeg-编程的大致框架&quot; class=&quot;headerlink&quot; title=&quot;FFMpeg 编程的大致框架&quot;&gt;&lt;/a&gt;FFMpeg 编程的大致框架&lt;/h2&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg命令大全</title>
    <link href="http://miaopei.github.io/2019/05/04/FFmpeg/FFmpeg%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://miaopei.github.io/2019/05/04/FFmpeg/FFmpeg命令大全/</id>
    <published>2019-05-04T02:14:50.000Z</published>
    <updated>2019-06-05T04:03:57.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p><p>本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。</p><a id="more"></a><h2 id="2-FFMPEG-目录及作用"><a href="#2-FFMPEG-目录及作用" class="headerlink" title="2. FFMPEG 目录及作用"></a>2. FFMPEG 目录及作用</h2><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各类工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h2 id="3-FFMPEG-基本概念"><a href="#3-FFMPEG-基本概念" class="headerlink" title="3. FFMPEG 基本概念"></a>3. FFMPEG 基本概念</h2><p>在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。</p><ul><li><p>音／视频流</p><p>在音视频领域，我们把一路音／视频称为一路<strong>流</strong>。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p></li><li><p>容器</p><p>我们一般把 MP4､ FLV、MOV 等文件格式称之为<strong>容器</strong>。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p></li><li><p>channel</p><p>channel 是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p></li></ul><h2 id="4-FFMPEG-命令"><a href="#4-FFMPEG-命令" class="headerlink" title="4. FFMPEG 命令"></a>4. FFMPEG 命令</h2><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解 / 复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><img src="/images/imageFFmpeg/音视频处理流程.png"><p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。</p><p>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。</p><p>您可以通过使用 <code>-vn / -an / -sn / -dn</code> 选项来禁用某些默认设置。 要进行全面的手动控制，请使用 <code>-map</code>选项，该选项禁用刚描述的默认设置。</p><p>下面我们就来详细介绍一下这些命令。</p><h2 id="5-基本信息查询命令"><a href="#5-基本信息查询命令" class="headerlink" title="5. 基本信息查询命令"></a>5. 基本信息查询命令</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 <code>ffmpeg -filters</code> 来查询。详细参数说明如下：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-version</td><td>显示版本。</td></tr><tr><td>-formats</td><td>显示可用的格式（包括设备）。</td></tr><tr><td>-demuxers</td><td>显示可用的demuxers。</td></tr><tr><td>-muxers</td><td>显示可用的muxers。</td></tr><tr><td>-devices</td><td>显示可用的设备。</td></tr><tr><td>-codecs</td><td>显示libavcodec已知的所有编解码器。</td></tr><tr><td>-decoders</td><td>显示可用的解码器。</td></tr><tr><td>-encoders</td><td>显示所有可用的编码器。</td></tr><tr><td>-bsfs</td><td>显示可用的比特流filter。</td></tr><tr><td>-protocols</td><td>显示可用的协议。</td></tr><tr><td>-filters</td><td>显示可用的libavfilter过滤器。</td></tr><tr><td>-pix_fmts</td><td>显示可用的像素格式。</td></tr><tr><td>-sample_fmts</td><td>显示可用的采样格式。</td></tr><tr><td>-layouts</td><td>显示channel名称和标准channel布局。</td></tr><tr><td>-colors</td><td>显示识别的颜色名称。</td></tr></tbody></table><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。</p><h2 id="6-命令基本格式及参数"><a href="#6-命令基本格式及参数" class="headerlink" title="6. 命令基本格式及参数"></a>6. 命令基本格式及参数</h2><p>下面是 FFMPEG 的基本命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ...</span></span><br><span class="line">                         &#123;[output_file_options] output_url&#125; ...</span><br></pre></td></tr></table></figure><p>ffmpeg 通过 <code>-i</code> 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等），并写入任意数量的输出“文件”。</p><p>原则上，每个输入 / 输出“文件”都可以包含任意数量的不同类型的视频流（视频 / 音频 / 字幕 / 附件 / 数据）。 <strong>流的数量和 / 或类型是由容器格式来限制</strong>。 选择从哪个输入进入到哪个输出将自动完成或使用 <code>-map</code> 选项。</p><p>要引用选项中的输入文件，您必须使用它们的索引（从 0 开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 <strong>例如： 2：3 是指第三个输入文件中的第四个流</strong>。</p><p>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p><h3 id="6-1-主要参数"><a href="#6-1-主要参数" class="headerlink" title="6.1 主要参数"></a>6.1 主要参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-f fmt（输入/输出）</td><td>强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。</td></tr><tr><td>-i url（输入）</td><td>输入文件的网址</td></tr><tr><td>-y（全局参数）</td><td>覆盖输出文件而不询问。</td></tr><tr><td>-n（全局参数）</td><td>不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。</td></tr><tr><td>-c [：stream_specifier] codec（输入/输出，每个流）</td><td>选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：<code>ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT</code></td></tr><tr><td>-codec [：stream_specifier]编解码器（输入/输出，每个流）</td><td>同 -c</td></tr><tr><td>-t duration（输入/输出）</td><td>当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</td></tr><tr><td>-ss位置（输入/输出）</td><td>当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</td></tr><tr><td>-frames [：stream_specifier] framecount（output，per-stream）</td><td>停止在帧计数帧之后写入流。</td></tr><tr><td>-filter [：stream_specifier] filtergraph（output，per-stream）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</td></tr></tbody></table><h3 id="6-2-视频参数"><a href="#6-2-视频参数" class="headerlink" title="6.2 视频参数"></a>6.2 视频参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-vframes num（输出）</td><td>设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。</td></tr><tr><td>-r [：stream_specifier] fps（输入/输出，每个流）</td><td>设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。</td></tr><tr><td>-s [：stream_specifier]大小（输入/输出，每个流）</td><td>设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。</td></tr><tr><td>-aspect [：stream_specifier] 宽高比（输出，每个流）</td><td>设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。</td></tr><tr><td>-vn（输出）</td><td>禁用视频录制。</td></tr><tr><td>-vcodec编解码器（输出）</td><td>设置视频编解码器。这是 <code>-codec：v</code> 的别名。</td></tr><tr><td>-vf filtergraph（输出）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><h3 id="6-3-音频参数"><a href="#6-3-音频参数" class="headerlink" title="6.3 音频参数"></a>6.3 音频参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-aframes（输出）</td><td>设置要输出的音频帧的数量。这是 <code>-frames：a</code> 的一个过时的别名。</td></tr><tr><td>-ar [：stream_specifier] freq（输入/输出，每个流）</td><td>设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td>-ac [：stream_specifier]通道（输入/输出，每个流）</td><td>设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td>-an（输出）</td><td>禁用录音。</td></tr><tr><td>-acodec编解码器（输入/输出）</td><td>设置音频编解码器。这是-codec的别名：a。</td></tr><tr><td>-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</td><td>设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。</td></tr><tr><td>-af filtergraph（输出）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><p>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p><h2 id="7-录制"><a href="#7-录制" class="headerlink" title="7. 录制"></a>7. 录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -list_devices <span class="literal">true</span> -i <span class="string">""</span></span></span><br></pre></td></tr></table></figure><p><strong>录屏</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span></span><br></pre></td></tr></table></figure><ul><li><p>-f 指定使用 avfoundation 采集数据。</p></li><li><p>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</p></li><li><p>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而 -r 用于限制输出。</p></li></ul><p>注意：桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</p><p><strong>录屏+声音</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</span></span><br></pre></td></tr></table></figure><ul><li><p>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</p></li><li><p>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</p></li><li><p>-crf 是 x264 的参数。 0 表式无损压缩。</p></li><li><p>-c:a 与参数 -acodec 一样，表示音频编码器。</p></li><li><p>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</p></li><li><p>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</p></li></ul><p><strong>录视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</p></li><li><p>-f 指定使用 avfoundation 采集数据。</p></li><li><p>-i 指定视频设备的索引号。</p></li></ul><p><strong>视频+音频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</span></span><br></pre></td></tr></table></figure><p><strong>录音</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -i :0 out.wav</span></span><br></pre></td></tr></table></figure><p><strong>录制音频裸数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</span></span><br></pre></td></tr></table></figure><h2 id="8-分解与复用"><a href="#8-分解与复用" class="headerlink" title="8. 分解与复用"></a>8. 分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p><img src="/images/imageFFmpeg/分解与复用.png"><p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p><p><strong>抽取音频流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -acodec copy -vn out.aac</span></span><br></pre></td></tr></table></figure><ul><li><p>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</p></li><li><p>vn: v 代表视频，n 代表 no 也就是无视频的意思。</p></li></ul><p><strong>抽取视频流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -vcodec copy -an out.h264</span></span><br></pre></td></tr></table></figure><ul><li><p>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</p></li><li><p>an: a 代表视频，n 代表 no 也就是无音频的意思。</p></li></ul><p><strong>转格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span></span><br></pre></td></tr></table></figure><p>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了 flv。</p><p><strong>音视频合并</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</span></span><br></pre></td></tr></table></figure><h2 id="9-处理原始数据"><a href="#9-处理原始数据" class="headerlink" title="9. 处理原始数据"></a>9. <strong>处理原始数据</strong></h2><p><strong>提取YUV数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffplay -s wxh out.yuv</span></span><br></pre></td></tr></table></figure><ul><li><p>-c:v rawvideo 指定将视频转成原始数据</p></li><li><p>-pixel_format yuv420p 指定转换格式为 yuv420p</p></li></ul><p><strong>YUV 转 H264</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</span></span><br></pre></td></tr></table></figure><p><strong>提取 PCM 数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</span></span><br></pre></td></tr></table></figure><p><strong>PCM 转 WAV</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</span></span><br></pre></td></tr></table></figure><h2 id="10-滤镜"><a href="#10-滤镜" class="headerlink" title="10. 滤镜"></a>10. <strong>滤镜</strong></h2><p>在编码之前，ffmpeg 可以使用 libavfilter 库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg 区分两种类型的过滤器图形：简单和复杂。</p><h3 id="10-1-简单滤镜"><a href="#10-1-简单滤镜" class="headerlink" title="10.1 简单滤镜"></a>10.1 简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p><img src="/images/imageFFmpeg/简单滤镜.png"><p>简单的 filtergraphs 配置了 per-stream-filter 选项（分别为视频和音频使用 <code>-vf</code> 和 <code>-af</code> 别名）。 一个简单的视频 filtergraph 可以看起来像这样的例子：</p><img src="/images/imageFFmpeg/简单滤镜-01.png"><p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的 fps 过滤器会改变帧数，但不会触及帧内容。 另一个例子是 setpts 过滤器，它只设置时间戳，否则不改变帧。</p><h3 id="10-2-复杂滤镜"><a href="#10-2-复杂滤镜" class="headerlink" title="10.2 复杂滤镜"></a>10.2 复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p><img src="/images/imageFFmpeg/复杂滤镜.png"><p>复杂的过滤器图使用 <code>-filter_complex</code> 选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。</p><p><code>-lavfi</code> 选项等同于 <code>-filter_complex</code>。</p><p>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是 amix 滤波器。</p><p><strong>添加水印</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4  -vf <span class="string">"movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]"</span> water.mp4</span></span><br></pre></td></tr></table></figure><ul><li>-vf 中的 movie 指定 logo 位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。</li></ul><p><strong>删除水印</strong></p><p>先通过 ffplay 找到要删除 LOGO 的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -i test.flv -vf delogo=x=806:y=20:w=70:h=80:show=1</span></span><br></pre></td></tr></table></figure><p>使用 delogo 滤镜删除 LOGO</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.flv -vf delogo=x=806:y=20:w=70:h=80 output.flv</span></span><br></pre></td></tr></table></figure><p><strong>视频缩小一倍</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4</span></span><br></pre></td></tr></table></figure><ul><li>-vf scale 指定使用简单过滤器 scale，<code>iw/2:-1</code> 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</li></ul><p><strong>视频裁剪</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i VR.mov  -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</span></span><br></pre></td></tr></table></figure><p>crop 格式：<code>crop=out_w:out_h:x:y</code></p><ul><li><p>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</p></li><li><p>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</p></li><li><p>x : X坐标</p></li><li><p>y : Y坐标</p></li></ul><p>如果 x 和 y 设置为 0, 说明从左上角开始裁剪。如果不写是从中心点裁剪。</p><p><strong>倍速播放</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -filter_complex <span class="string">"[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]"</span> -map <span class="string">"[v]"</span> -map <span class="string">"[a]"</span> speed2.0.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-filter_complex 复杂滤镜，<code>[0:v]</code> 表示第一个（文件索引号是 0）文件的视频作为输入。<code>setpts=0.5*PTS</code> 表示每帧视频的 pts 时间戳都乘 0.5 ，也就是差少一半。<code>[v]</code> 表示输出的别名。音频同理就不详述了。</p></li><li><p>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</p></li></ul><p><strong>对称视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -i out.mp4 -filter_complex <span class="string">"[0:v]pad=w=2*iw[a];[0:v]hflip[b];[a][b]overlay=x=w"</span> duicheng.mp4</span></span><br></pre></td></tr></table></figure><ul><li>hflip 水平翻转</li></ul><p>如果要修改为垂直翻转可以用 vflip。</p><p><strong>画中画</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -i out1.mp4 -filter_complex <span class="string">"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart new.mp4</span></span><br></pre></td></tr></table></figure><p><strong>录制画中画</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation -i <span class="string">"0:0"</span> </span></span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast </span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 </span><br><span class="line">-filter_complex "[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[a];[0:v][a]overlay=x=W-w-10:y=0[out]" </span><br><span class="line">-map "[out]" -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure><p><strong>多路视频拼接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation   -i <span class="string">"0:0"</span> -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex <span class="string">"[0:v]scale=320:240[a];[a]pad=640:240[b];[b][1:v]overlay=320:0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart  -map 1:a  c.mp4</span></span><br></pre></td></tr></table></figure><h2 id="11-音视频的拼接与裁剪"><a href="#11-音视频的拼接与裁剪" class="headerlink" title="11. 音视频的拼接与裁剪"></a>11. <strong>音视频的拼接与裁剪</strong></h2><p><strong>裁剪</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-ss 指定裁剪的开始时间，精确到秒</p></li><li><p>-t 被裁剪后的时长。</p></li></ul><p><strong>合并</strong></p><p>首先创建一个 inputs.txt 文件，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'1.flv'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'2.flv'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'3.flv'</span></span></span><br></pre></td></tr></table></figure><p>然后执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f concat -i inputs.txt -c copy output.flv</span></span><br></pre></td></tr></table></figure><p><strong>hls切片</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</span></span><br></pre></td></tr></table></figure><ul><li><p>-strict -2 指明音频使有AAC。</p></li><li><p>-f hls 转成 m3u8 格式。</p></li></ul><h2 id="12-视频图片互转"><a href="#12-视频图片互转" class="headerlink" title="12. 视频图片互转"></a>12. 视频图片互转</h2><p><strong>视频转 JPEG</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</span></span><br></pre></td></tr></table></figure><p><strong>视频转 gif</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</span></span><br></pre></td></tr></table></figure><p><strong>图片转视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</span></span><br></pre></td></tr></table></figure><h2 id="13-直播相关"><a href="#13-直播相关" class="headerlink" title="13. 直播相关"></a>13. <strong>直播相关</strong></h2><p><strong>推流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span></span><br></pre></td></tr></table></figure><p><strong>拉流保存</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><p><strong>转流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream</span></span><br></pre></td></tr></table></figure><p><strong>实时推流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 15 -f avfoundation -i <span class="string">"1"</span> -s 1280x720 -c:v libx264  -f  flv rtmp://localhost:1935/live/room</span></span><br></pre></td></tr></table></figure><h2 id="14-ffplay"><a href="#14-ffplay" class="headerlink" title="14. ffplay"></a>14. <strong>ffplay</strong></h2><p><strong>播放 YUV 数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -pix_fmt nv12 -s 192x144 1.yuv</span></span><br></pre></td></tr></table></figure><p><strong>播放 YUV 中的 Y 平面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes=<span class="string">'y'</span> 1.yuv</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。&lt;/p&gt;
&lt;p&gt;本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频核心技术</title>
    <link href="http://miaopei.github.io/2019/04/30/FFmpeg/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>http://miaopei.github.io/2019/04/30/FFmpeg/音视频核心技术/</id>
    <published>2019-04-30T06:14:50.000Z</published>
    <updated>2019-06-12T06:47:34.994Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><img src="/images/imageFFmpeg/FFmpeg音视频架构-01.png"><img src="/images/imageFFmpeg/FFmpeg音视频架构-02.png"><h2 id="1-学习大纲"><a href="#1-学习大纲" class="headerlink" title="1. 学习大纲"></a>1. 学习大纲</h2><p><strong>FFmpeg 常用命令</strong>：</p><ul><li>视频录制命令</li><li>多媒体文件的分解/复用命令</li><li>裁剪与合并命令</li><li>图片/视频互转命令</li><li>直播相关命令</li><li>各种滤镜命令</li></ul><p><strong>FFmpeg 基本开发</strong>：</p><ul><li>C 语言回顾</li><li>FFmpeg 核心概念与常用结构体</li><li>实战 - 多媒体文件的分解与复用</li><li>实战 - 多媒体格式的互转</li><li>实战 - 从 MP4 裁剪一段视频</li><li>作业 - 实现一个简单的小咖秀</li></ul><p><strong>音视频编解码实战</strong>：</p><ul><li>实战 - H264 解码</li><li>实战 - H264 编码</li><li>实战 - 音频 AAC 解码</li><li>实战 - 音频 AAC 编码</li><li>实战 - 视频转图片</li></ul><p><strong>音视频渲染实战</strong>：</p><ul><li>SDL 事件处理</li><li>SDL 视频文理渲染</li><li>SDL 音频渲染</li><li>实战1 - 实现 YUV 视频播放</li><li>实战2 - YUV 视频倍数播放</li><li>实战3 - 实现 PCM 播放器</li></ul><p><strong>FFmpeg 开发播放器核心功能</strong>：</p><ul><li>实战 - 实现 MP4 文件的视频播放</li><li>实战 - 实现 MP4 文件的音频播放</li><li>实战 - 实现一个初级播放器</li><li>实战 - 音视频同步</li><li>实战 - 实现播放器内核</li></ul><p><strong>Android 中实战 FFmpeg</strong>：</p><ul><li>编译 Android 端可以使用的 FFmpeg</li><li>Java 与 C 语言相互调用</li><li>实战 - Android 调用 FFmpeg</li></ul><p><strong>学习建议</strong>：</p><ul><li>牢牢抓住音视频的处理机制，了解其本质</li><li>勤加练习，熟能生巧</li><li>待着问题去学习，事半功倍</li></ul><p><strong>音视频的广泛应用</strong>：</p><ul><li>直播类：音视频会议、教育直播、娱乐/游戏直播</li><li>短视频：抖音、快手、小咖秀</li><li>网络视频：优酷、腾讯视频、爱奇艺等</li><li>音视频通话：微信、QQ、Skype等</li><li>视频监控</li><li>人工智能：人脸识别，智能音箱等，更关注算法</li></ul><p><strong>播放器架构</strong>：</p><img src="/images/imageFFmpeg/播放器架构.png"><p><strong>渲染流程</strong>：</p><img src="/images/imageFFmpeg/渲染流程.png"><p><strong>FFmpeg 都能做啥</strong>：</p><ul><li>FFmpeg 是一个非常优秀的多媒体框架</li><li>FFmpeg 可以运行在 Linux、Mac、Windows 等平台上</li><li>能够解码、编码、转码、复用、解复用、过滤音视频数据</li></ul><p><strong>FFmpeg 下载与安装</strong>：</p><details><summary>FFMpeg 下载与安装</summary> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://git.ffmpeg.org/ffmpeg.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> config -- <span class="built_in">help</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure></details><h2 id="2-FFmpeg-常用命令实战"><a href="#2-FFmpeg-常用命令实战" class="headerlink" title="2. FFmpeg 常用命令实战"></a>2. FFmpeg 常用命令实战</h2><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解 / 复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><img src="/images/imageFFmpeg/FFmpeg处理音视频流程.png"><img src="/images/imageFFmpeg/FFmpeg基本信息查询命令.png"><img src="/images/imageFFmpeg/FFmpeg录屏命令.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -s 2560x1600 -pix_fmt uyvy422 out.yuv</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/分解与复用-01.png"><img src="/images/imageFFmpeg/多媒体格式转换.png"><h2 id="3-初级开发内容"><a href="#3-初级开发内容" class="headerlink" title="3. 初级开发内容"></a>3. 初级开发内容</h2><ul><li>FFmpeg 日志的使用及目录的操作</li><li>介绍 FFmpeg 的基本概念及常用的结构体</li><li>对复用/解复用及流程操作的各种实践</li></ul><p>FFmpeg 代码结构：</p><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各类工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h3 id="3-1-FFmpeg-日志系统"><a href="#3-1-FFmpeg-日志系统" class="headerlink" title="3.1 FFmpeg 日志系统"></a>3.1 FFmpeg 日志系统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">av_log_set_level(AV_LOG_DEBUG)</span><br><span class="line">    </span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"...%s\n"</span>, op)</span><br></pre></td></tr></table></figure><ul><li>AV_LOG_ERROR</li><li>AV_LOG_WARNING</li><li>AV_LOG_INFO</li></ul><details><summary>FFmpeg日志系统使用</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line"></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"hello world: %s!\n"</span>, <span class="string">"aaa"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="3-2-FFmpeg-文件与目录操作"><a href="#3-2-FFmpeg-文件与目录操作" class="headerlink" title="3.2 FFmpeg 文件与目录操作"></a>3.2 FFmpeg 文件与目录操作</h3><p>文件的删除与重命名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">avpriv_io_delete()</span><br><span class="line">    </span><br><span class="line">avpriv_io_move(src, dst)</span><br></pre></td></tr></table></figure><details><summary>FFmpeg文件与目录操作</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = avpriv_io_delete(<span class="string">"./mytestfile.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to delete file mytestfile.txt\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = avpriv_io_move(<span class="string">"111.txt"</span>, <span class="string">"222.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Filed to rename\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --libs libavformat`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pkg-config --libs libavformat 指令可以搜索libavformat库所在路径</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> pkg-config --libs libavformat</span></span><br><span class="line">-L/usr/local/ffmpeg/lib -lavformat</span><br></pre></td></tr></table></figure></details><h3 id="3-3-FFmpeg-操作目录重要函数"><a href="#3-3-FFmpeg-操作目录重要函数" class="headerlink" title="3.3 FFmpeg 操作目录重要函数"></a>3.3 FFmpeg 操作目录重要函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avio_open_dir()</span><br><span class="line">avio_read_dir()</span><br><span class="line">avio_close_dir()</span><br></pre></td></tr></table></figure><p>操作目录重要结构体：</p><ul><li><p>AVIODirContext</p><p>操作目录的上下文</p></li><li><p>AVIODirEntry</p><p>目录项。用于存放文件名，文件大小等信息</p></li></ul><details><summary>FFmpeg操作目录</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVIODirContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVIODirEntry *entry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = avio_open_dir(&amp;ctx, <span class="string">"./"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant open dir:%s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = avio_read_dir(ctx, &amp;entry);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant read dir: %s\n"</span>, av_err2str(ret));</span><br><span class="line">            <span class="keyword">goto</span> __fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"%l2"</span>PRId64<span class="string">" %s\n"</span>,</span><br><span class="line">               entry-&gt;size,</span><br><span class="line">               entry-&gt;name);</span><br><span class="line"></span><br><span class="line">        avio_free_directory_entry(&amp;entry);</span><br><span class="line">    &#125;</span><br><span class="line">__fail:</span><br><span class="line">    avio_close_dir(&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o list ffmpeg_list.c `pkg-config --libs libavformat libavutil`</span></span><br></pre></td></tr></table></figure></details><h3 id="3-4-多媒体文件的基本概念"><a href="#3-4-多媒体文件的基本概念" class="headerlink" title="3.4 多媒体文件的基本概念"></a>3.4 多媒体文件的基本概念</h3><ul><li>多媒体文件其实是个容器</li><li>在容器里有很多流（Stream/Track)</li><li>每种流是由不同的编码器编码的</li><li>从流中读出的数据称为包</li><li>在一个包中包含着一个或多个帧</li></ul><p>几个重要的结构体：</p><ul><li>AVFormatContext</li><li>AVStream</li><li>AVPacket</li></ul><p>FFmpeg 操作流数据的基本步骤：</p><p>解复用 —&gt; 获取流 —&gt; 读取数据包 —&gt;  释放资源</p><h3 id="3-5-实战-打印音-视频信息"><a href="#3-5-实战-打印音-视频信息" class="headerlink" title="3.5 [实战] 打印音/视频信息"></a>3.5 [实战] 打印音/视频信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_register_all()</span><br><span class="line">avformat_open_input() / avformat_close_input()</span><br><span class="line">av_dump_format()</span><br></pre></td></tr></table></figure><details><summary>[实战] 打印音/视频信息</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    ret = avformat_open_input(&amp;fmt_ctx, <span class="string">"./test.mp4"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open file: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, <span class="string">"./test.mp4"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;fmt_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="3-6-实战-抽取音频数据"><a href="#3-6-实战-抽取音频数据" class="headerlink" title="3.6 [实战] 抽取音频数据"></a>3.6 [实战] 抽取音频数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_init_packet()</span><br><span class="line">av_find_best_stream()</span><br><span class="line">av_read_frame() / av_packet_unref()</span><br></pre></td></tr></table></figure><details><summary>[实战] 抽取音频数据</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> audio_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *src = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *dst = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. read two params form console</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"eg: %s in_file out_file\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    src = argv[<span class="number">1</span>];</span><br><span class="line">    dst = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (!src || !dst) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"src or dst is null\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = avformat_open_input(&amp;fmt_ctx, src, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open file: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *dst_fd = fopen(dst, <span class="string">"wb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dst_fd) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open out file!\n"</span>);</span><br><span class="line">        avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, src, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. get stream</span></span><br><span class="line">    ret = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't find the best stream!\n"</span>);</span><br><span class="line">        avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">        fclose(dst_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_index = ret;</span><br><span class="line">    av_init_packet(&amp;pkt);</span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(fmt_ctx, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt.stream_index == audio_index) &#123;</span><br><span class="line">            <span class="comment">// 3. write audio data to aac file.</span></span><br><span class="line">            len = fwrite(pkt.data, <span class="number">1</span>, pkt.size, dst_fd);</span><br><span class="line">            <span class="keyword">if</span> (len != pkt.size) &#123;</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">"warning, length of data is not equal size of pkt!\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">    <span class="keyword">if</span> (dst_fd) &#123;</span><br><span class="line">        fclose(dst_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lang -g -o extra_audio extra_audio.c `pkg-config --libs libavutil libavformat`</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./extra_audio test.mp4 killer.aa</span></span><br></pre></td></tr></table></figure></details><h3 id="3-7-实战-抽取视频数据"><a href="#3-7-实战-抽取视频数据" class="headerlink" title="3.7 [实战] 抽取视频数据"></a>3.7 [实战] 抽取视频数据</h3><ul><li>Start code</li><li>SPS/PPS</li><li>codec -&gt; extradata</li></ul><h3 id="3-8-实战-将-MP4-转成-FLV-格式"><a href="#3-8-实战-将-MP4-转成-FLV-格式" class="headerlink" title="3.8 [实战] 将 MP4 转成 FLV 格式"></a>3.8 [实战] 将 MP4 转成 FLV 格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">avformat_alloc_output_context2() / avformat_free_context();</span><br><span class="line">avformat_new_stream();</span><br><span class="line">avcodec_parameters_copy();</span><br><span class="line">avformat_write_header();</span><br><span class="line">av_write_frame() / av_interleaved_write_frame();</span><br><span class="line">av_write_trailer()</span><br></pre></td></tr></table></figure><h3 id="3-9-实战-从-MP4-截取一段视频"><a href="#3-9-实战-从-MP4-截取一段视频" class="headerlink" title="3.9 [实战] 从 MP4 截取一段视频"></a>3.9 [实战] 从 MP4 截取一段视频</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_seek_frame()</span><br></pre></td></tr></table></figure><details><summary>从 MP4 截取一段视频代码:</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_packet</span><span class="params">(<span class="keyword">const</span> AVFormatContext *fmt_ctx, <span class="keyword">const</span> AVPacket *pkt, <span class="keyword">const</span> <span class="keyword">char</span> *tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVRational *time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\n"</span>,</span><br><span class="line">           tag,</span><br><span class="line">           av_ts2str(pkt-&gt;pts), av_ts2timestr(pkt-&gt;pts, time_base),</span><br><span class="line">           av_ts2str(pkt-&gt;dts), av_ts2timestr(pkt-&gt;dts, time_base),</span><br><span class="line">           av_ts2str(pkt-&gt;duration), av_ts2timestr(pkt-&gt;duration, time_base),</span><br><span class="line">           pkt-&gt;stream_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_video</span><span class="params">(<span class="keyword">double</span> from_seconds, <span class="keyword">double</span> end_seconds, <span class="keyword">const</span> <span class="keyword">char</span>* in_filename, <span class="keyword">const</span> <span class="keyword">char</span>* out_filename)</span> </span>&#123;</span><br><span class="line">    AVOutputFormat *ofmt = <span class="literal">NULL</span>;</span><br><span class="line">    AVFormatContext *ifmt_ctx = <span class="literal">NULL</span>, *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    <span class="keyword">int</span> ret, i;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = avformat_open_input(&amp;ifmt_ctx, in_filename, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open input file '%s'"</span>, in_filename);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = avformat_find_stream_info(ifmt_ctx, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to retrieve input stream information"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_dump_format(ifmt_ctx, <span class="number">0</span>, in_filename, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, out_filename);</span><br><span class="line">    <span class="keyword">if</span> (!ofmt_ctx) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not create output context\n"</span>);</span><br><span class="line">        ret = AVERROR_UNKNOWN;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ofmt = ofmt_ctx-&gt;oformat;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *in_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        AVStream *out_stream = avformat_new_stream(ofmt_ctx, in_stream-&gt;codec-&gt;codec);</span><br><span class="line">        <span class="keyword">if</span> (!out_stream) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed allocating output stream\n"</span>);</span><br><span class="line">            ret = AVERROR_UNKNOWN;</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ret = avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy context from input to output stream codec context\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        out_stream-&gt;codec-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)</span><br><span class="line">            out_stream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line">    av_dump_format(ofmt_ctx, <span class="number">0</span>, out_filename, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">        ret = avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open output file '%s'"</span>, out_filename);</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error occurred when opening output file\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    int indexs[8] = &#123;0&#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    int64_t start_from = 8*AV_TIME_BASE;</span></span><br><span class="line">    ret = av_seek_frame(ifmt_ctx, <span class="number">-1</span>, from_seconds*AV_TIME_BASE, AVSEEK_FLAG_ANY);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error seek\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int64_t</span> *dts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="built_in">memset</span>(dts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="keyword">int64_t</span> *pts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="built_in">memset</span>(pts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        AVStream *in_stream, *out_stream;</span><br><span class="line">    </span><br><span class="line">        ret = av_read_frame(ifmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">        in_stream  = ifmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">        out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">    </span><br><span class="line">        log_packet(ifmt_ctx, &amp;pkt, <span class="string">"in"</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (av_q2d(in_stream-&gt;time_base) * pkt.pts &gt; end_seconds) &#123;</span><br><span class="line">            av_free_packet(&amp;pkt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (dts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            dts_start_from[pkt.stream_index] = pkt.dts;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"dts_start_from: %s\n"</span>, av_ts2str(dts_start_from[pkt.stream_index]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            pts_start_from[pkt.stream_index] = pkt.pts;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"pts_start_from: %s\n"</span>, av_ts2str(pts_start_from[pkt.stream_index]));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* copy packet */</span></span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts - pts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts - dts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);</span><br><span class="line">        <span class="keyword">if</span> (pkt.pts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.pts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pkt.dts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.dts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pkt.duration = (<span class="keyword">int</span>)av_rescale_q((<span class="keyword">int64_t</span>)pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line">        log_packet(ofmt_ctx, &amp;pkt, <span class="string">"out"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">        ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error muxing packet\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        av_free_packet(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(dts_start_from);</span><br><span class="line">    <span class="built_in">free</span>(pts_start_from);</span><br><span class="line">    </span><br><span class="line">    av_write_trailer(ofmt_ctx);</span><br><span class="line">    </span><br><span class="line">end:</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* close output */</span></span><br><span class="line">    <span class="keyword">if</span> (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">        avio_closep(&amp;ofmt_ctx-&gt;pb);</span><br><span class="line">    avformat_free_context(ofmt_ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error occurred: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: \</span></span><br><span class="line"><span class="string">                command startime, endtime, srcfile, outfile"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> startime = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">double</span> endtime = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    cut_video(startime, endtime, argv[<span class="number">3</span>], argv[<span class="number">4</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="3-10-实战-一个简单的小咖秀"><a href="#3-10-实战-一个简单的小咖秀" class="headerlink" title="3.10 [实战] 一个简单的小咖秀"></a>3.10 [实战] 一个简单的小咖秀</h3><ul><li><p>将两个媒体文件中分别抽取音频与视频轨</p></li><li><p>将音频与视频轨合并成一个新文件</p></li><li><p>对音频与视频轨进行裁剪</p><h2 id="4-FFmpeg-中级开发内容"><a href="#4-FFmpeg-中级开发内容" class="headerlink" title="4. FFmpeg 中级开发内容"></a>4. FFmpeg 中级开发内容</h2></li><li><p>FFmpeg H264 解码</p></li><li><p>FFmpeg H264 编码</p></li><li><p>FFmpeg AAC 解码</p></li><li><p>FFmpeg AAC 编码</p></li></ul><h3 id="4-1-FFmpeg-H264-解码"><a href="#4-1-FFmpeg-H264-解码" class="headerlink" title="4.1 FFmpeg H264 解码"></a>4.1 FFmpeg H264 解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>常用数据结构：</p><ul><li><p>AVCodec 编码器结构体</p></li><li><p>AVCodecContext 编码器上下文</p></li><li><p>AVFrame 解码后的帧</p><p>结构体内存的分配与释放：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_frame_alloc / av_frame_free();</span><br><span class="line">avcodec_alloc_context3();</span><br><span class="line">avcodec_free_context();</span><br></pre></td></tr></table></figure><p>解码步骤：</p><ul><li>查找解码器（avcodec_find_decoder）</li><li>打开解码器（avcodec_open2）</li><li>解码（avcodec_decode_video2）</li></ul><h3 id="4-2-FFmpeg-H264-编码"><a href="#4-2-FFmpeg-H264-编码" class="headerlink" title="4.2 FFmpeg H264 编码"></a>4.2 FFmpeg H264 编码</h3><p>H264编码流程：</p><ul><li>查找编码器（avcodec_find_encoder_by_name）</li><li>设置参数，打开编码器（avcondec_open2）</li><li>编码（avcondec_encode_video2）</li></ul><h3 id="4-3-视频转图片"><a href="#4-3-视频转图片" class="headerlink" title="4.3 视频转图片"></a>4.3 视频转图片</h3><p>TODO</p><h3 id="4-4-FFmpeg-AAC-编码"><a href="#4-4-FFmpeg-AAC-编码" class="headerlink" title="4.4 FFmpeg AAC 编码"></a>4.4 FFmpeg AAC 编码</h3><ul><li>编码流程与视频相同</li><li>编码函数 avcodec_encodec_audio2</li></ul><h2 id="5-SDL-介绍"><a href="#5-SDL-介绍" class="headerlink" title="5. SDL 介绍"></a>5. SDL 介绍</h2><blockquote><p><a href="[http://www.libsdl.org](http://www.libsdl.org/)">SDL 官网</a></p></blockquote><ul><li>SDL（Simple DirectMedia Layer） 是一套<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTk2JThCJUU2JTk0JUJFJUU1JThFJTlGJUU1JUE3JThCJUU3JUEyJUJD" title="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%8E%9F%E5%A7%8B%E7%A2%BC">开放源代码<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUE4JUU1JUI5JUIzJUU1JThGJUIw" title="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JTlBJUU1JUFBJTkyJUU5JUFCJTk0" title="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E9%AB%94">多媒体<i class="fa fa-external-link"></i></span>开发<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg3JUJEJUU1JUJDJThGJUU1JUJBJUFC" title="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">库<i class="fa fa-external-link"></i></span></li><li>由 C 语言实现的跨平台的媒体开源库</li><li>多用于开发游戏、模拟器、媒体播放器等多媒体应用领域</li></ul><p>语法与子系统：</p><p>SDL将功能分成下列数个子系统（subsystem）：</p><ul><li><strong>Video（图像）</strong>—图像控制以及线程（thread）和事件管理（event）。</li><li><strong>Audio（声音）</strong>—声音控制</li><li><strong>Joystick（摇杆）</strong>—游戏摇杆控制</li><li><strong>CD-ROM（光盘驱动器）</strong>—光盘媒体控制</li><li><strong>Window Management（视窗管理）</strong>－与视窗程序设计集成</li><li><strong>Event（事件驱动）</strong>－处理事件驱动</li></ul><p>以下是一支用C语言写成、非常简单的SDL示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Headers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SDL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize SDL</span></span><br><span class="line">    <span class="keyword">if</span>(SDL_Init(SDL_INIT_EVERYTHING) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delay 2 seconds</span></span><br><span class="line">    SDL_Delay(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Quit SDL</span></span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序会加载所有SDL子系统（出错则退出程序），然后暂停两秒，最后关闭SDL并退出程序。</p><h3 id="5-1-SDL-编译与安装"><a href="#5-1-SDL-编译与安装" class="headerlink" title="5.1 SDL 编译与安装"></a>5.1 SDL 编译与安装</h3><ul><li>下载 SDL 源码</li><li>生成Makefile configure –prefix=/usr/local</li><li>安装 sudo make -j 8 &amp;&amp; make install</li></ul><h3 id="5-2-使用-SDL-基本步骤"><a href="#5-2-使用-SDL-基本步骤" class="headerlink" title="5.2 使用 SDL 基本步骤"></a>5.2 使用 SDL 基本步骤</h3><ul><li>添加头文件 #include &lt;SDL.h&gt;</li><li>初始化 SDL</li><li>退出 SDL</li></ul><p>SDL 渲染窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_Init() / SDL_Quit();</span><br><span class="line">SDL_CreateWindow() / SDL_DestoryWindow();</span><br><span class="line">SDL_CreateRender();  <span class="comment">// 创建渲染器</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o first_sdl first_sdl.c `pkg-config --libs sdl2`</span></span><br></pre></td></tr></table></figure><p>SDL 渲染窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateRender() / SDL_DestoryRenderer();</span><br><span class="line">SDL_RenderClear();</span><br><span class="line">SDL_RenderPresent();</span><br></pre></td></tr></table></figure><h3 id="5-3-SDL-事件基本原理"><a href="#5-3-SDL-事件基本原理" class="headerlink" title="5.3 SDL 事件基本原理"></a>5.3 SDL 事件基本原理</h3><ul><li>SDL 将所有的事件都存放在一个队列中</li><li>所有对事件的操作，其实就是队列的操作</li></ul><p>SDL 事件种类：</p><ul><li>SDL_WindowEvent：窗口事件</li><li>SDL_KeyboardEvent：键盘事件</li><li>SDL_MouseMotionEvent：鼠标事件</li><li>自定义事件</li></ul><p>SDL 事件处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_PollEvent(); <span class="comment">// 轮询检测</span></span><br><span class="line">SDL_WaitEvent(); <span class="comment">// 常用的方式</span></span><br><span class="line">SDL_WaitEventTimeout();</span><br></pre></td></tr></table></figure><h3 id="5-4-文理渲染"><a href="#5-4-文理渲染" class="headerlink" title="5.4 文理渲染"></a>5.4 文理渲染</h3><p>SDL 渲染基本原理：</p><img src="/images/imageFFmpeg/SDL渲染基本原理.png"><p>SDL 文理相关 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateTexture();</span><br><span class="line">- format: YUV, RGB</span><br><span class="line">- access: Texture 类型， Target， Stream</span><br><span class="line"></span><br><span class="line">SDL_DestroyTexture();</span><br></pre></td></tr></table></figure><p>SDL 渲染相关 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_SetRenderTarget();</span><br><span class="line">SDL_RenderClear();</span><br><span class="line">SDL_RenderCopy();</span><br><span class="line">SDL_RenderPresent();</span><br></pre></td></tr></table></figure><h3 id="5-5-实战-YUV-视频播放器"><a href="#5-5-实战-YUV-视频播放器" class="headerlink" title="5.5 [实战] YUV 视频播放器"></a>5.5 [实战] YUV 视频播放器</h3><p>创建线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateThread();</span><br><span class="line">- fn: 线程执行函数</span><br><span class="line">- name: 线程名</span><br><span class="line">- data: 执行函数参数</span><br></pre></td></tr></table></figure><p>SDL 更新文理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_UpdateTexture();</span><br><span class="line">SDL_UpdateYUVTexture();</span><br></pre></td></tr></table></figure><h3 id="5-6-SDL-播放音频"><a href="#5-6-SDL-播放音频" class="headerlink" title="5.6 SDL 播放音频"></a>5.6 SDL 播放音频</h3><p>播放音频基本流程：</p><img src="/images/imageFFmpeg/播放音频基本流程.png"><p>播放音频的基本原则：</p><ul><li>声卡向你要数据而不是你主动推给声卡</li><li>数据的多少由音频参数决定的</li></ul><p>SDL 音频 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_OpenAudio() / SDL_CloseAudio();</span><br><span class="line">SDL_PauseAudio();</span><br><span class="line">SDL_MixAudio();</span><br></pre></td></tr></table></figure><h3 id="5-7-实现-PCM-播放器"><a href="#5-7-实现-PCM-播放器" class="headerlink" title="5.7 实现 PCM 播放器"></a>5.7 实现 PCM 播放器</h3><p>TODO</p><h2 id="6-最简单的播放器"><a href="#6-最简单的播放器" class="headerlink" title="6. 最简单的播放器"></a>6. 最简单的播放器</h2><ul><li>该播放器只实现视频播放</li><li>将 FFmpeg 与 SDL 结合到一起</li><li>通过 FFmpeg 解码视频数据</li><li>通过 SDL 进行渲染</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o player2 player2.c `pkg-config --cflags --libs sdl2 libavformat libavutil libswscale libavcodec libswresample`</span></span><br></pre></td></tr></table></figure><p>最简单的播放器之二：</p><ul><li>可以同时播放音频与视频</li><li>使用队列存放音频包</li></ul><h3 id="6-1-多线程与锁"><a href="#6-1-多线程与锁" class="headerlink" title="6.1 多线程与锁"></a>6.1 多线程与锁</h3><p>为什么要用多线程：</p><ul><li>多线程的好处</li><li>多线程带来的问题</li></ul><p>线程的互斥与同步：</p><ul><li><p>互斥</p></li><li><p>同步</p><p>大的任务分为很多小任务通过信号协调</p></li></ul><p>锁与信号量：</p><ul><li>锁的种类</li><li>通过信号进行同步</li></ul><p>锁的中种类：</p><ul><li>读写锁</li><li>自旋锁</li><li>可重入锁</li></ul><p>SDL 线程的创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateThread();</span><br><span class="line">SDL_WaitThread();</span><br></pre></td></tr></table></figure><p>SDL 锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateMutex() / SDL_DestroyMutex();  <span class="comment">// 创建互斥量</span></span><br><span class="line">SDL_LockMutex() / SDL_UnlockMutex(); <span class="comment">// 锁互斥量于解锁互斥量</span></span><br></pre></td></tr></table></figure><p>SDL 条件变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateCond() / SDL_DestroyCond();</span><br><span class="line">SDL_CondWait() / SDL_CondSignal();</span><br></pre></td></tr></table></figure><h3 id="6-2-锁与条件变量的使用"><a href="#6-2-锁与条件变量的使用" class="headerlink" title="6.2 锁与条件变量的使用"></a>6.2 锁与条件变量的使用</h3><p>TODO</p><h3 id="6-3-播放器线程模型"><a href="#6-3-播放器线程模型" class="headerlink" title="6.3 播放器线程模型"></a>6.3 播放器线程模型</h3><img src="/images/imageFFmpeg/播放器线程模型.png"><h3 id="6-4-线程的退出机制"><a href="#6-4-线程的退出机制" class="headerlink" title="6.4 线程的退出机制"></a>6.4 线程的退出机制</h3><ul><li>主线程接收到退出事件</li><li>解复用线程在循环分流时对 quit 进行判断</li><li>视频解码线程从视频流队列中取包时对 quit 进行判断</li><li>音视解码从音频流队列中取包时对 quit 进行判断</li><li>音视循环解码时对 quit 进行判断</li><li>在收到信号变量消息时对 quit 进行判断</li></ul><h3 id="6-5-音视频同步"><a href="#6-5-音视频同步" class="headerlink" title="6.5 音视频同步"></a>6.5 音视频同步</h3><p>时间戳：</p><ul><li>PTS：Presentation timestamp  渲染时间戳</li><li>DTS：Decoding timestamp 解码时间戳</li><li>I（intra）/ B（bidirectional）/ P（predicted）帧</li></ul><p>时间戳顺序：</p><ul><li>实际帧顺序：I B B P</li><li>存放帧顺序：I P B B</li><li>解码时间戳：1 4 2 3</li><li>展示时间戳：1 2 3 4</li></ul><p>从哪儿获得 PTS：</p><ul><li>AVPacket 中的 PTS</li><li>AVFrame 中的 PTS</li><li>av_frame_get_best_effort_timestamp()</li></ul><p>时间基：</p><ul><li>tbr：帧率</li><li>tbn：time base of stream 流的时间基</li><li>tbc：time base of codec 解码的时间基</li></ul><p>计算当前帧的 PTS：</p><ul><li><code>PTS = PTS * av_q2d(video_stream-&gt;time_base)</code></li><li><code>av_q2d(AVRotional a){ return a.num / (double)a.den; }</code></li></ul><p>计算下一帧的 PTS：</p><ul><li>video_clock：预测的下一帧视频的 PTS</li><li>frame_delay：1/tbr</li><li>audio_clock：音频当前播放的时间戳</li></ul><p>音视频同步方式：</p><ul><li>视频同步到音频</li><li>音频同步到视频</li><li>音频和视频都同步到系统时钟  </li></ul><p>视频播放的基本思路：</p><ul><li>一般的做法，展示第一帧视频帧后，获得要显示的下一个视频帧的 PTS，然后设置一个定时器，当定时器超时时后，刷新新的视屏帧，如此反复操作。</li></ul><details><summary>最简单的播放器：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compatibility with newer API</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> av_frame_free avcodec_free_frame</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000 <span class="comment">//channels(2) * data_size(2) * sample_rate(48000)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_AUDIO_MASTER <span class="comment">//AV_SYNC_VIDEO_MASTER</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span></span><br><span class="line">AVPacketList *first_pkt, *last_pkt;</span><br><span class="line">    <span class="keyword">int</span> nb_packets;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    SDL_mutex *mutex;</span><br><span class="line">    SDL_cond *cond;</span><br><span class="line">&#125; PacketQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoPicture</span> &#123;</span></span><br><span class="line">    AVPicture *bmp;</span><br><span class="line">    <span class="keyword">int</span> width, height; <span class="comment">/* source height &amp; width */</span></span><br><span class="line">    <span class="keyword">int</span> allocated;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">&#125; VideoPicture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoState</span> &#123;</span></span><br><span class="line">    <span class="comment">//multi-media file</span></span><br><span class="line">    <span class="keyword">char</span>            filename[<span class="number">1024</span>];</span><br><span class="line">    AVFormatContext *pFormatCtx;</span><br><span class="line">    <span class="keyword">int</span>             videoStream, audioStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sync</span></span><br><span class="line">    <span class="keyword">int</span>             av_sync_type;</span><br><span class="line">    <span class="keyword">double</span>          external_clock; <span class="comment">/* external clock base */</span></span><br><span class="line">    <span class="keyword">int64_t</span>         external_clock_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>          audio_diff_cum; <span class="comment">/* used for AV difference average computation */</span></span><br><span class="line">    <span class="keyword">double</span>          audio_diff_avg_coef;</span><br><span class="line">    <span class="keyword">double</span>          audio_diff_threshold;</span><br><span class="line">    <span class="keyword">int</span>             audio_diff_avg_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>          audio_clock;</span><br><span class="line">    <span class="keyword">double</span>          frame_timer;</span><br><span class="line">    <span class="keyword">double</span>          frame_last_pts;</span><br><span class="line">    <span class="keyword">double</span>          frame_last_delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>          video_clock; <span class="comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span></span><br><span class="line">    <span class="keyword">double</span>          video_current_pts; <span class="comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span></span><br><span class="line">    <span class="keyword">int64_t</span>         video_current_pts_time;  <span class="comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//audio</span></span><br><span class="line">    AVStream        *audio_st;</span><br><span class="line">    AVCodecContext  *audio_ctx;</span><br><span class="line">    PacketQueue     audioq;</span><br><span class="line">    <span class="keyword">uint8_t</span>         audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="number">3</span>) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    audio_buf_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    audio_buf_index;</span><br><span class="line">    AVFrame         audio_frame;</span><br><span class="line">    AVPacket        audio_pkt;</span><br><span class="line">    <span class="keyword">uint8_t</span>         *audio_pkt_data;</span><br><span class="line">    <span class="keyword">int</span>             audio_pkt_size;</span><br><span class="line">    <span class="keyword">int</span>             audio_hw_buf_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//video</span></span><br><span class="line">    AVStream        *video_st;</span><br><span class="line">    AVCodecContext  *video_ctx;</span><br><span class="line">    PacketQueue     videoq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">video_sws_ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_swr_ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];</span><br><span class="line">    <span class="keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;</span><br><span class="line">    SDL_mutex       *pictq_mutex;</span><br><span class="line">    SDL_cond        *pictq_cond;</span><br><span class="line"></span><br><span class="line">    SDL_Thread      *parse_tid;</span><br><span class="line">    SDL_Thread      *video_tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>             quit;</span><br><span class="line">&#125; VideoState;</span><br><span class="line"></span><br><span class="line">SDL_mutex    *text_mutex;</span><br><span class="line">SDL_Window   *win = <span class="literal">NULL</span>;</span><br><span class="line">SDL_Renderer *renderer;</span><br><span class="line">SDL_Texture  *texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    AV_SYNC_AUDIO_MASTER,</span><br><span class="line">    AV_SYNC_VIDEO_MASTER,</span><br><span class="line">    AV_SYNC_EXTERNAL_MASTER,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE *yuvfd = <span class="literal">NULL</span>;</span><br><span class="line">FILE *audiofd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Since we only have one decoding thread, the Big Struct</span></span><br><span class="line"><span class="comment">   can be global in case we need it. */</span></span><br><span class="line">VideoState *global_video_state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_queue_init</span><span class="params">(PacketQueue *q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span>(PacketQueue));</span><br><span class="line">    q-&gt;mutex = SDL_CreateMutex();</span><br><span class="line">    q-&gt;cond = SDL_CreateCond();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">packet_queue_put</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span> </span>&#123;</span><br><span class="line">    AVPacketList *pkt1;</span><br><span class="line">    <span class="keyword">if</span>(av_dup_packet(pkt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pkt1 = av_malloc(<span class="keyword">sizeof</span>(AVPacketList));</span><br><span class="line">    <span class="keyword">if</span> (!pkt1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pkt1-&gt;pkt = *pkt;</span><br><span class="line">    pkt1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    SDL_LockMutex(q-&gt;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;last_pkt)</span><br><span class="line">        q-&gt;first_pkt = pkt1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q-&gt;last_pkt-&gt;next = pkt1;</span><br><span class="line">    q-&gt;last_pkt = pkt1;</span><br><span class="line">    q-&gt;nb_packets++;</span><br><span class="line">    q-&gt;size += pkt1-&gt;pkt.size;</span><br><span class="line">    </span><br><span class="line">    SDL_CondSignal(q-&gt;cond);</span><br><span class="line">    SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVPacketList *pkt1;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    SDL_LockMutex(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(global_video_state-&gt;quit) &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt1 = q-&gt;first_pkt;</span><br><span class="line">        <span class="keyword">if</span> (pkt1) &#123;</span><br><span class="line">            q-&gt;first_pkt = pkt1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!q-&gt;first_pkt)</span><br><span class="line">                q-&gt;last_pkt = <span class="literal">NULL</span>;</span><br><span class="line">            q-&gt;nb_packets--;</span><br><span class="line">            q-&gt;size -= pkt1-&gt;pkt.size;</span><br><span class="line">            *pkt = pkt1-&gt;pkt;</span><br><span class="line">            av_free(pkt1);</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SDL_CondWait(q-&gt;cond, q-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_audio_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">    <span class="keyword">int</span> hw_buf_size, bytes_per_sec, n;</span><br><span class="line"></span><br><span class="line">    pts = is-&gt;audio_clock; <span class="comment">/* maintained in the audio thread */</span></span><br><span class="line">    hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">    bytes_per_sec = <span class="number">0</span>;</span><br><span class="line">    n = is-&gt;audio_ctx-&gt;channels * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;audio_st) &#123;</span><br><span class="line">        bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bytes_per_sec) &#123;</span><br><span class="line">        pts -= (<span class="keyword">double</span>)hw_buf_size / bytes_per_sec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_video_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> delta;</span><br><span class="line">    delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="keyword">return</span> is-&gt;video_current_pts + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_external_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_master_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> get_video_clock(is);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> get_audio_clock(is);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get_external_clock(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add or subtract samples to get a better sync, return new</span></span><br><span class="line"><span class="comment">   audio buffer size */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">synchronize_audio</span><span class="params">(VideoState *is, <span class="keyword">short</span> *samples,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> samples_size, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> ref_clock;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">        <span class="keyword">double</span> diff, avg_diff;</span><br><span class="line">        <span class="keyword">int</span> wanted_size, min_size, max_size <span class="comment">/*, nb_samples */</span>;</span><br><span class="line"></span><br><span class="line">        ref_clock = get_master_clock(is);</span><br><span class="line">        diff = get_audio_clock(is) - ref_clock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// accumulate the diffs</span></span><br><span class="line">            is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef</span><br><span class="line">                * is-&gt;audio_diff_cum;</span><br><span class="line">            <span class="keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) &#123;</span><br><span class="line">                is-&gt;audio_diff_avg_count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                avg_diff = is-&gt;audio_diff_cum * (<span class="number">1.0</span> - is-&gt;audio_diff_avg_coef);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123;</span><br><span class="line">                    wanted_size = samples_size + ((<span class="keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);</span><br><span class="line">                    min_size = samples_size * ((<span class="number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>);</span><br><span class="line">                    max_size = samples_size * ((<span class="number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">if</span>(wanted_size &lt; min_size) &#123;</span><br><span class="line">                        wanted_size = min_size;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wanted_size &gt; max_size) &#123;</span><br><span class="line">                        wanted_size = max_size;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(wanted_size &lt; samples_size) &#123;</span><br><span class="line">                        <span class="comment">/* remove samples */</span></span><br><span class="line">                        samples_size = wanted_size;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wanted_size &gt; samples_size) &#123;</span><br><span class="line">                        <span class="keyword">uint8_t</span> *samples_end, *q;</span><br><span class="line">                        <span class="keyword">int</span> nb;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* add samples by copying final sample*/</span></span><br><span class="line">                        nb = (samples_size - wanted_size);</span><br><span class="line">                        samples_end = (<span class="keyword">uint8_t</span> *)samples + samples_size - n;</span><br><span class="line">                        q = samples_end + n;</span><br><span class="line">                        <span class="keyword">while</span>(nb &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">memcpy</span>(q, samples_end, n);</span><br><span class="line">                            q += n;</span><br><span class="line">                            nb -= n;</span><br><span class="line">                        &#125;</span><br><span class="line">                        samples_size = wanted_size;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* difference is TOO big; reset diff stuff */</span></span><br><span class="line">            is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">            is-&gt;audio_diff_cum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> samples_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">audio_decode_frame</span><span class="params">(VideoState *is, <span class="keyword">uint8_t</span> *audio_buf, </span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> buf_size, <span class="keyword">double</span> *pts_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1, data_size = <span class="number">0</span>;</span><br><span class="line">    AVPacket *pkt = &amp;is-&gt;audio_pkt;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">            len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);</span><br><span class="line">            <span class="keyword">if</span>(len1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* if error, skip frame */</span></span><br><span class="line">                is-&gt;audio_pkt_size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data_size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(got_frame) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">data_size = av_samples_get_buffer_size(NULL, </span></span><br><span class="line"><span class="comment">       is-&gt;audio_ctx-&gt;channels,</span></span><br><span class="line"><span class="comment">       is-&gt;audio_frame.nb_samples,</span></span><br><span class="line"><span class="comment">       is-&gt;audio_ctx-&gt;sample_fmt,</span></span><br><span class="line"><span class="comment">       1);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">                data_size = <span class="number">2</span> * is-&gt;audio_frame.nb_samples * <span class="number">2</span>;</span><br><span class="line">                assert(data_size &lt;= buf_size);</span><br><span class="line"></span><br><span class="line">                swr_convert(is-&gt;audio_swr_ctx,</span><br><span class="line">                            &amp;audio_buf,</span><br><span class="line">                            MAX_AUDIO_FRAME_SIZE*<span class="number">3</span>/<span class="number">2</span>,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)is-&gt;audio_frame.data,</span><br><span class="line">                            is-&gt;audio_frame.nb_samples);</span><br><span class="line"></span><br><span class="line">                fwrite(audio_buf, <span class="number">1</span>, data_size, audiofd);</span><br><span class="line">                <span class="comment">//memcpy(audio_buf, is-&gt;audio_frame.data[0], data_size);</span></span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_pkt_data += len1;</span><br><span class="line">            is-&gt;audio_pkt_size -= len1;</span><br><span class="line">            <span class="keyword">if</span>(data_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* No data yet, get more frames */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pts = is-&gt;audio_clock;</span><br><span class="line">            *pts_ptr = pts;</span><br><span class="line">            n = <span class="number">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class="line">            is-&gt;audio_clock += (<span class="keyword">double</span>)data_size /</span><br><span class="line">                (<span class="keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class="line">            <span class="comment">/* We have data, return it and come back for more later */</span></span><br><span class="line">            <span class="keyword">return</span> data_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pkt-&gt;data)</span><br><span class="line">            av_free_packet(pkt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* next packet */</span></span><br><span class="line">        <span class="keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        is-&gt;audio_pkt_data = pkt-&gt;data;</span><br><span class="line">        is-&gt;audio_pkt_size = pkt-&gt;size;</span><br><span class="line">        <span class="comment">/* if update, update the audio clock w/pts */</span></span><br><span class="line">        <span class="keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">audio_callback</span><span class="params">(<span class="keyword">void</span> *userdata, Uint8 *stream, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *)userdata;</span><br><span class="line">    <span class="keyword">int</span> len1, audio_size;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">            <span class="comment">/* We have already sent all our data; get more */</span></span><br><span class="line">            audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);</span><br><span class="line">            <span class="keyword">if</span>(audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* If error, output silence */</span></span><br><span class="line">                is-&gt;audio_buf_size = <span class="number">1024</span> * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">memset</span>(is-&gt;audio_buf, <span class="number">0</span>, is-&gt;audio_buf_size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                audio_size = synchronize_audio(is, (<span class="keyword">int16_t</span> *)is-&gt;audio_buf, audio_size, pts);</span><br><span class="line">                is-&gt;audio_buf_size = audio_size;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len)</span><br><span class="line">            len1 = len;</span><br><span class="line">        SDL_MixAudio(stream,(<span class="keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME);</span><br><span class="line">        <span class="comment">//memcpy(stream, (uint8_t *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span></span><br><span class="line">        len -= len1;</span><br><span class="line">        stream += len1;</span><br><span class="line">        is-&gt;audio_buf_index += len1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Uint32 <span class="title">sdl_refresh_timer_cb</span><span class="params">(Uint32 interval, <span class="keyword">void</span> *opaque)</span> </span>&#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    event.type = FF_REFRESH_EVENT;</span><br><span class="line">    event.user.data1 = opaque;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 0 means stop timer */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* schedule a video refresh in 'delay' ms */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_refresh</span><span class="params">(VideoState *is, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">    SDL_AddTimer(delay, sdl_refresh_timer_cb, is);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">video_display</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    SDL_Rect rect;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    <span class="keyword">float</span> aspect_ratio;</span><br><span class="line">    <span class="keyword">int</span> w, h, x, y;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line">    <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line"></span><br><span class="line">        SDL_UpdateYUVTexture(texture, <span class="literal">NULL</span>, </span><br><span class="line">                             vp-&gt;bmp-&gt;data[<span class="number">0</span>], vp-&gt;bmp-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                             vp-&gt;bmp-&gt;data[<span class="number">1</span>], vp-&gt;bmp-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                             vp-&gt;bmp-&gt;data[<span class="number">2</span>], vp-&gt;bmp-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        rect.x = <span class="number">0</span>;</span><br><span class="line">        rect.y = <span class="number">0</span>;</span><br><span class="line">        rect.w = is-&gt;video_ctx-&gt;width;</span><br><span class="line">        rect.h = is-&gt;video_ctx-&gt;height;</span><br><span class="line">        SDL_LockMutex(text_mutex);</span><br><span class="line">        SDL_RenderClear( renderer );</span><br><span class="line">        SDL_RenderCopy( renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">        SDL_RenderPresent( renderer );</span><br><span class="line">        SDL_UnlockMutex(text_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">video_refresh_timer</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *)userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    <span class="keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;video_st) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;pictq_size == <span class="number">0</span>) &#123;</span><br><span class="line">            schedule_refresh(is, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//fprintf(stderr, "no picture in the queue!!!\n");</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//fprintf(stderr, "get picture from queue!!!\n");</span></span><br><span class="line">            vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line"></span><br><span class="line">            is-&gt;video_current_pts = vp-&gt;pts;</span><br><span class="line">            is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line">            delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="comment">/* the pts from last time */</span></span><br><span class="line">            <span class="keyword">if</span>(delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="comment">/* if incorrect delay, use previous one */</span></span><br><span class="line">                delay = is-&gt;frame_last_delay;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* save for next time */</span></span><br><span class="line">            is-&gt;frame_last_delay = delay;</span><br><span class="line">            is-&gt;frame_last_pts = vp-&gt;pts;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update delay to sync to audio if not master source */</span></span><br><span class="line">            <span class="keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">                ref_clock = get_master_clock(is);</span><br><span class="line">                diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Skip or repeat the frame. Take delay into account</span></span><br><span class="line"><span class="comment">       FFPlay still doesn't "know if this is the best guess." */</span></span><br><span class="line">                sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(diff &lt;= -sync_threshold) &#123;</span><br><span class="line">                        delay = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(diff &gt;= sync_threshold) &#123;</span><br><span class="line">                        delay = <span class="number">2</span> * delay;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;frame_timer += delay;</span><br><span class="line">            <span class="comment">/* computer the REAL delay */</span></span><br><span class="line">            actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line">            <span class="keyword">if</span>(actual_delay &lt; <span class="number">0.010</span>) &#123;</span><br><span class="line">                <span class="comment">/* Really it should skip the picture instead */</span></span><br><span class="line">                actual_delay = <span class="number">0.010</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            schedule_refresh(is, (<span class="keyword">int</span>)(actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* show the picture! */</span></span><br><span class="line">            video_display(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update queue for next picture! */</span></span><br><span class="line">            <span class="keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">                is-&gt;pictq_rindex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">            is-&gt;pictq_size--;</span><br><span class="line">            SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">            SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        schedule_refresh(is, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc_picture</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *)userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line"></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line">    <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line">        <span class="comment">// we already have one make another, bigger/smaller</span></span><br><span class="line">        avpicture_free(vp-&gt;bmp);</span><br><span class="line">        <span class="built_in">free</span>(vp-&gt;bmp);</span><br><span class="line">        vp-&gt;bmp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a place to put our YUV image on that screen</span></span><br><span class="line">    SDL_LockMutex(text_mutex);</span><br><span class="line"></span><br><span class="line">    vp-&gt;bmp = (AVPicture*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVPicture));</span><br><span class="line">    ret = avpicture_alloc(vp-&gt;bmp, AV_PIX_FMT_YUV420P, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate temporary picture: %s\n"</span>, av_err2str(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_UnlockMutex(text_mutex);</span><br><span class="line"></span><br><span class="line">    vp-&gt;width = is-&gt;video_ctx-&gt;width;</span><br><span class="line">    vp-&gt;height = is-&gt;video_ctx-&gt;height;</span><br><span class="line">    vp-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_picture</span><span class="params">(VideoState *is, AVFrame *pFrame, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until we have space for a new pic */</span></span><br><span class="line">    SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    <span class="keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;</span><br><span class="line">          !is-&gt;quit) &#123;</span><br><span class="line">        SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;quit)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// windex is set to 0 initially</span></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate or resize the buffer! */</span></span><br><span class="line">    <span class="keyword">if</span>(!vp-&gt;bmp ||</span><br><span class="line">       vp-&gt;width != is-&gt;video_ctx-&gt;width ||</span><br><span class="line">       vp-&gt;height != is-&gt;video_ctx-&gt;height) &#123;</span><br><span class="line"></span><br><span class="line">        vp-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">        alloc_picture(is);</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have a place to put our picture on the queue */</span></span><br><span class="line">    <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line">        vp-&gt;pts = pts;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert the image into YUV format that SDL uses</span></span><br><span class="line">        sws_scale(is-&gt;video_sws_ctx, (<span class="keyword">uint8_t</span> <span class="keyword">const</span> * <span class="keyword">const</span> *)pFrame-&gt;data,</span><br><span class="line">                  pFrame-&gt;linesize, <span class="number">0</span>, is-&gt;video_ctx-&gt;height,</span><br><span class="line">                  vp-&gt;bmp-&gt;data, vp-&gt;bmp-&gt;linesize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* now we inform our display thread that we have a pic ready */</span></span><br><span class="line">        <span class="keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">            is-&gt;pictq_windex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        is-&gt;pictq_size++;</span><br><span class="line">        SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">synchronize_video</span><span class="params">(VideoState *is, AVFrame *src_frame, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> frame_delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pts != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* if we have pts, set video clock to it */</span></span><br><span class="line">        is-&gt;video_clock = pts;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* if we aren't given a pts, set it to the clock */</span></span><br><span class="line">        pts = is-&gt;video_clock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* update the video clock */</span></span><br><span class="line">    frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);</span><br><span class="line">    <span class="comment">/* if we are repeating a frame, adjust clock accordingly */</span></span><br><span class="line">    frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="number">0.5</span>);</span><br><span class="line">    is-&gt;video_clock += frame_delay;</span><br><span class="line">    <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode_video_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *)arg;</span><br><span class="line">    AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line">    <span class="keyword">int</span> frameFinished;</span><br><span class="line">    AVFrame *pFrame;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// means we quit getting packets</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decode video frame</span></span><br><span class="line">        avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) != AV_NOPTS_VALUE) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Did we get a video frame?</span></span><br><span class="line">        <span class="keyword">if</span>(frameFinished) &#123;</span><br><span class="line">            pts = synchronize_video(is, pFrame, pts);</span><br><span class="line">            <span class="keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stream_component_open</span><span class="params">(VideoState *is, <span class="keyword">int</span> stream_index)</span> </span>&#123;</span><br><span class="line">    AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;</span><br><span class="line">    AVCodecContext *codecCtx = <span class="literal">NULL</span>;</span><br><span class="line">    AVCodec *codec = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_AudioSpec wanted_spec, spec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stream_index &lt; <span class="number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codecCtx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = avcodec_parameters_to_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codecpar);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span>(!codec) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unsupported codec!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">        <span class="comment">// Set audio settings from codec info</span></span><br><span class="line">        wanted_spec.freq = codecCtx-&gt;sample_rate;</span><br><span class="line">        wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">        wanted_spec.channels = <span class="number">2</span>;<span class="comment">//codecCtx-&gt;channels;</span></span><br><span class="line">        wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">        wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</span><br><span class="line">        wanted_spec.callback = audio_callback;</span><br><span class="line">        wanted_spec.userdata = is;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"wanted spec: channels:%d, sample_fmt:%d, sample_rate:%d \n"</span>,</span><br><span class="line">                <span class="number">2</span>, AUDIO_S16SYS, codecCtx-&gt;sample_rate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        is-&gt;audio_hw_buf_size = spec.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unsupported codec!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(codecCtx-&gt;codec_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            is-&gt;audioStream = stream_index;</span><br><span class="line">            is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">            is-&gt;audio_ctx = codecCtx;</span><br><span class="line">            is-&gt;audio_buf_size = <span class="number">0</span>;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="number">0</span>, <span class="keyword">sizeof</span>(is-&gt;audio_pkt));</span><br><span class="line">            packet_queue_init(&amp;is-&gt;audioq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Out Audio Param</span></span><br><span class="line">            <span class="keyword">uint64_t</span> out_channel_layout=AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//AAC:1024  MP3:1152</span></span><br><span class="line">            <span class="keyword">int</span> out_nb_samples= is-&gt;audio_ctx-&gt;frame_size;</span><br><span class="line">            <span class="comment">//AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> out_sample_rate=is-&gt;audio_ctx-&gt;sample_rate;</span><br><span class="line">            <span class="keyword">int</span> out_channels=av_get_channel_layout_nb_channels(out_channel_layout);</span><br><span class="line">            <span class="comment">//Out Buffer Size</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int out_buffer_size=av_samples_get_buffer_size(NULL,</span></span><br><span class="line"><span class="comment">                                                   out_channels,</span></span><br><span class="line"><span class="comment">                                                   out_nb_samples,</span></span><br><span class="line"><span class="comment">                                                   AV_SAMPLE_FMT_S16,</span></span><br><span class="line"><span class="comment">                                                   1);</span></span><br><span class="line"><span class="comment">                                                   */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//uint8_t *out_buffer=(uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE*2);</span></span><br><span class="line">            <span class="keyword">int64_t</span> in_channel_layout=av_get_default_channel_layout(is-&gt;audio_ctx-&gt;channels);</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_convert_ctx</span>;</span></span><br><span class="line">            audio_convert_ctx = swr_alloc();</span><br><span class="line">            swr_alloc_set_opts(audio_convert_ctx,</span><br><span class="line">                               out_channel_layout,</span><br><span class="line">                               AV_SAMPLE_FMT_S16,</span><br><span class="line">                               out_sample_rate,</span><br><span class="line">                               in_channel_layout,</span><br><span class="line">                               is-&gt;audio_ctx-&gt;sample_fmt,</span><br><span class="line">                               is-&gt;audio_ctx-&gt;sample_rate,</span><br><span class="line">                               <span class="number">0</span>,</span><br><span class="line">                               <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"swr opts: out_channel_layout:%lld, out_sample_fmt:%d, out_sample_rate:%d, in_channel_layout:%lld, in_sample_fmt:%d, in_sample_rate:%d"</span>,</span><br><span class="line">                    out_channel_layout, </span><br><span class="line">                    AV_SAMPLE_FMT_S16, </span><br><span class="line">                    out_sample_rate, </span><br><span class="line">                    in_channel_layout, </span><br><span class="line">                    is-&gt;audio_ctx-&gt;sample_fmt, </span><br><span class="line">                    is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class="line">            swr_init(audio_convert_ctx);</span><br><span class="line">            is-&gt;audio_swr_ctx = audio_convert_ctx;</span><br><span class="line"></span><br><span class="line">            SDL_PauseAudio(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            is-&gt;videoStream = stream_index;</span><br><span class="line">            is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">            is-&gt;video_ctx = codecCtx;</span><br><span class="line"></span><br><span class="line">            is-&gt;frame_timer = (<span class="keyword">double</span>)av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">            is-&gt;frame_last_delay = <span class="number">40e-3</span>;</span><br><span class="line">            is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line"></span><br><span class="line">            packet_queue_init(&amp;is-&gt;videoq);</span><br><span class="line">            is-&gt;video_sws_ctx = sws_getContext(</span><br><span class="line">                is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">                        is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,</span><br><span class="line">                        is-&gt;video_ctx-&gt;height, AV_PIX_FMT_YUV420P,</span><br><span class="line">                        SWS_BILINEAR, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            is-&gt;video_tid = SDL_CreateThread(decode_video_thread, <span class="string">"decode_video_thread"</span>, is);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">demux_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err_code;</span><br><span class="line">    <span class="keyword">char</span> errors[<span class="number">1024</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *)arg;</span><br><span class="line">    AVFormatContext *pFormatCtx;</span><br><span class="line">    AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> video_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> audio_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    is-&gt;videoStream=<span class="number">-1</span>;</span><br><span class="line">    is-&gt;audioStream=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    global_video_state = is;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open input file, and allocate format context */</span></span><br><span class="line">    <span class="keyword">if</span> ((err_code=avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_strerror(err_code, errors, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open source file %s, %d(%s)\n"</span>, is-&gt;filename, err_code, errors);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    is-&gt;pFormatCtx = pFormatCtx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve stream information</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Couldn't find stream information</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dump information about file onto standard error</span></span><br><span class="line">    av_dump_format(pFormatCtx, <span class="number">0</span>, is-&gt;filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the first video stream</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">           video_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            video_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">           audio_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            audio_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(audio_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, audio_index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(video_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, video_index);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;videoStream &lt; <span class="number">0</span> || is-&gt;audioStream &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: could not open codecs\n"</span>, is-&gt;filename);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//creat window from SDL</span></span><br><span class="line">    win = SDL_CreateWindow(<span class="string">"Media Player"</span>,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">                           SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);</span><br><span class="line">    <span class="keyword">if</span>(!win) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SDL: could not set video mode - exiting\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer = SDL_CreateRenderer(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IYUV: Y + U + V  (3 planes)</span></span><br><span class="line">    <span class="comment">//YV12: Y + V + U  (3 planes)</span></span><br><span class="line">    Uint32 pixformat= SDL_PIXELFORMAT_IYUV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create texture for render</span></span><br><span class="line">    texture = SDL_CreateTexture(renderer,</span><br><span class="line">                                pixformat,</span><br><span class="line">                                SDL_TEXTUREACCESS_STREAMING,</span><br><span class="line">                                is-&gt;video_ctx-&gt;width,</span><br><span class="line">                                is-&gt;video_ctx-&gt;height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main decode loop</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// seek stuff goes here</span></span><br><span class="line">        <span class="keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||</span><br><span class="line">           is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) &#123;</span><br><span class="line">            SDL_Delay(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="number">0</span>) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">100</span>); <span class="comment">/* no error; wait for user input */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Is this a packet from the video stream?</span></span><br><span class="line">        <span class="keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            av_free_packet(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* all done - wait for it */</span></span><br><span class="line">    <span class="keyword">while</span>(!is-&gt;quit) &#123;</span><br><span class="line">        SDL_Delay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        SDL_Event event;</span><br><span class="line">        event.type = FF_QUIT_EVENT;</span><br><span class="line">        event.user.data1 = is;</span><br><span class="line">        SDL_PushEvent(&amp;event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    SDL_Event       event;</span><br><span class="line">    VideoState      *is;</span><br><span class="line"></span><br><span class="line">    is = av_mallocz(<span class="keyword">sizeof</span>(VideoState));</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: test &lt;file&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yuvfd = fopen(<span class="string">"testout.yuv"</span>, <span class="string">"wb+"</span>);</span><br><span class="line">    audiofd = fopen(<span class="string">"testout.pcm"</span>, <span class="string">"wb+"</span>);</span><br><span class="line">    <span class="comment">// Register all formats and codecs</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    text_mutex = SDL_CreateMutex();</span><br><span class="line">    av_strlcpy(is-&gt;filename, argv[<span class="number">1</span>], <span class="keyword">sizeof</span>(is-&gt;filename));</span><br><span class="line">    is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class="line">    is-&gt;pictq_cond = SDL_CreateCond();</span><br><span class="line"></span><br><span class="line">    schedule_refresh(is, <span class="number">40</span>);</span><br><span class="line">    is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;</span><br><span class="line">    is-&gt;parse_tid = SDL_CreateThread(demux_thread,<span class="string">"demux_thread"</span>, is);</span><br><span class="line">    <span class="keyword">if</span>(!is-&gt;parse_tid) &#123;</span><br><span class="line">        av_free(is);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        SDL_WaitEvent(&amp;event);</span><br><span class="line">        <span class="keyword">switch</span>(event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> FF_QUIT_EVENT:</span><br><span class="line">            <span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">                is-&gt;quit = <span class="number">1</span>;</span><br><span class="line">                SDL_Quit();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FF_REFRESH_EVENT:</span><br><span class="line">                video_refresh_timer(event.user.data1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(yuvfd);</span><br><span class="line">    fclose(audiofd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="7-如何在-Android-下使用-FFmpeg"><a href="#7-如何在-Android-下使用-FFmpeg" class="headerlink" title="7. 如何在 Android 下使用 FFmpeg"></a>7. 如何在 Android 下使用 FFmpeg</h2><p>Android 架构：</p><img src="/images/imageFFmpeg/Android架构.png"><p>内容：</p><ul><li>Java 与 C 之间的相互调用</li><li>Android 下 FFmpeg 的编译</li><li>Android 下如何使用FFmpeg</li></ul><p>第一个 JNI 程序：</p><p>TODO</p><p>JNI 基本概念：</p><ul><li>JNIEnv</li><li>JavaVM  一个Android APP只有一个 JavaVM， 一个 JavaVM 可以有多个JNIEnv</li><li>线程  一个线程对应一个JNIEnv</li></ul><p>Java调用C/C++ 方法一：</p><ul><li><p>在Java层定义 native 关键字函数</p></li><li><p>方法一：在C/C++层创建</p><p>Java_packname_classname_methodname 函数</p></li></ul><p>Java调用C/C++方法二：</p><img src="/images/imageFFmpeg/java调用c方法二.png"><img src="/images/imageFFmpeg/注册Native方法的最佳时机.png"><p>什么是Signature：</p><ul><li>Java与C/C++ 相互调用时，表式函数参数的描述符</li><li>输入参数放在（）内，输出参数放在（）外</li><li>多个参数之间顺序存放，且用 “；” 分割</li></ul><img src="/images/imageFFmpeg/原始类型的Signature.png"><img src="/images/imageFFmpeg/类的Signature.png"> <img src="/images/imageFFmpeg/例子.png"><p>C/C++ 调用 Java 方法：</p><ul><li>FindClass</li><li>GetMethodID / GetFieldID</li><li>NewObject</li><li><code>Call&lt;TYPE&gt;Method / [G/S]et&lt;type&gt;Field</code></li></ul><h3 id="7-1-实战-Android-下的播放器"><a href="#7-1-实战-Android-下的播放器" class="headerlink" title="7.1 [实战] Android 下的播放器"></a>7.1 [实战] Android 下的播放器</h3><p>TODO</p><h2 id="8-IOS-下使用-FFmpeg"><a href="#8-IOS-下使用-FFmpeg" class="headerlink" title="8. IOS 下使用 FFmpeg"></a>8. IOS 下使用 FFmpeg</h2><p>TODO</p><h2 id="9-音视频进阶"><a href="#9-音视频进阶" class="headerlink" title="9. 音视频进阶"></a>9. 音视频进阶</h2><ul><li>FFmpeg Filter 的使用 </li><li>FFmpeg 裁剪与优化</li><li>视频渲染（OpenGL / Metal）</li><li>声音的特效</li><li>网络传输</li><li>Webrtc - 实时互动、直播、P2P音视频传输</li><li>AR技术</li><li>OpenCV</li></ul><p>行业痛点：</p><ul><li>回音消除</li><li>降噪</li><li>视频秒开</li><li>多人多视频实时互动</li><li>PC端/APP/网页实时视频互通</li><li>实时互动与大并发负载</li></ul><h2 id="FFmpeg音视频同步原理与实现"><a href="#FFmpeg音视频同步原理与实现" class="headerlink" title="FFmpeg音视频同步原理与实现"></a>FFmpeg音视频同步原理与实现</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaG95cy9hcmNoaXZlLzIwMTEvMDYvMDgvMjA3NTE1OS5odG1s" title="https://www.cnblogs.com/hoys/archive/2011/06/08/2075159.html">音视频同步解决方案<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy54bWwtZGF0YS5vcmcvR0RHWURYWEIvaHRtbC8yMDE3MDQxMS5odG0=" title="http://www.xml-data.org/GDGYDXXB/html/20170411.htm">一种基于FFMPEG的音视频同步算法<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="音视频同步原理"><a href="#音视频同步原理" class="headerlink" title="音视频同步原理"></a>音视频同步原理</h3><p>如果简单的按照音频的采样率与视频的帧率去播放，由于机器运行速度，解码效率等种种造成时间差异的因素影响，很难同步，音视频时间差将会呈现线性增长。所以要做音视频的同步，有三种方式：</p><p>参考一个外部时钟，将音频与视频同步至此时间。我首先想到这种方式，但是并不好，由于某些生物学的原理，人对声音的变化比较敏感，但是对视觉变化不太敏感。所以频繁的去调整声音的播放会有些刺耳或者杂音吧影响用户体验。（ps：顺便科普生物学知识，自我感觉好高大上_）。</p><ul><li>以视频为基准，音频去同步视频的时间。不采用，理由同上。</li><li>以音频为基准，视频去同步音频的时间。 所以这个办法了。</li></ul><p>所以，原理就是以音频时间为基准，判断视频快了还是慢了，从而调整视频速度。其实是一个动态的追赶与等待的过程。</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>音视频中都有 <code>DTS</code> 与 <code>PTS</code>。</p><ul><li>DTS ，Decoding Time Stamp，解码时间戳，告诉解码器packet的解码顺序。</li><li>PTS ，Presentation Time Stamp，显示时间戳，指示从packet中解码出来的数据的显示顺序。</li><li>音频中二者是相同的，但是视频由于B帧（双向预测）的存在，会造成解码顺序与显示顺序并不相同，也就是视频中 DTS 与 PTS 不一定相同。</li></ul><p>时间基 : 看 FFmpeg 源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVRational time_base;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* rational number numerator/denominator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> num; <span class="comment">///&lt; numerator</span></span><br><span class="line">   <span class="keyword">int</span> den; <span class="comment">///&lt; denominator</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><p>个人理解，其实就是 ffmpeg中 的用分数表示时间单位，num 为分子，den 为分母。并且 ffmpeg 提供了计算方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Convert rational to double.</span></span><br><span class="line"><span class="comment">* @param a rational to convert</span></span><br><span class="line"><span class="comment">* @return (double) a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">av_q2d</span><span class="params">(AVRational a)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a.num / (<span class="keyword">double</span>) a.den;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 视频中某帧的显示时间 计算方式为(单位为妙)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time = pts * av_q2d(time_base);</span><br></pre></td></tr></table></figure><h3 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h3><p><strong>音频部分</strong></p><p>clock 为音频的播放时长（从开始到当前的时间）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (packet-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    audio-&gt;clock = av_q2d(audio-&gt;time_base) * packet-&gt;pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后加上此 packet 中数据需要播放的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> time = datalen/((<span class="keyword">double</span>) <span class="number">44100</span> *<span class="number">2</span> * <span class="number">2</span>);</span><br><span class="line">audio-&gt;clock = audio-&gt;clock +time;</span><br></pre></td></tr></table></figure><p>datalen 为数据长度。采样率为 44100，采样位数为 16，通道数为 2。所以 数据长度 / 每秒字节数。</p><p>ps：此处计算方式不是很完美，有很多问题，回头研究在再补上。</p><p><strong>视频部分</strong></p><details><summary>先定义几个值：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>  last_play  <span class="comment">//上一帧的播放时间</span></span><br><span class="line">   ,play             <span class="comment">//当前帧的播放时间</span></span><br><span class="line">   , last_delay    <span class="comment">// 上一次播放视频的两帧视频间隔时间</span></span><br><span class="line">   ,delay         <span class="comment">//两帧视频间隔时间</span></span><br><span class="line">   ,audio_clock <span class="comment">//音频轨道 实际播放时间</span></span><br><span class="line">   ,diff   <span class="comment">//音频帧与视频帧相差时间</span></span><br><span class="line">   ,sync_threshold <span class="comment">//合理的范围</span></span><br><span class="line">   ,start_time  <span class="comment">//从第一帧开始的绝对时间</span></span><br><span class="line">   ,pts</span><br><span class="line">   ,actual_delay<span class="comment">//真正需要延迟时间</span></span><br><span class="line">   start_time = av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line"><span class="comment">//        获取pts</span></span><br><span class="line">       <span class="keyword">if</span> ((pts = av_frame_get_best_effort_timestamp(frame)) == AV_NOPTS_VALUE) &#123;</span><br><span class="line">           pts = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       play = pts * av_q2d(vedio-&gt;time_base);</span><br><span class="line"><span class="comment">//        纠正时间</span></span><br><span class="line">       play = vedio-&gt;synchronize(frame, play);</span><br><span class="line">       delay = play - last_play;</span><br><span class="line">       <span class="keyword">if</span> (delay &lt;= <span class="number">0</span> || delay &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           delay = last_delay;</span><br><span class="line">       &#125;</span><br><span class="line">       audio_clock = vedio-&gt;audio-&gt;clock;</span><br><span class="line">       last_delay = delay;</span><br><span class="line">       last_play = play;</span><br><span class="line"><span class="comment">//音频与视频的时间差</span></span><br><span class="line">       diff = vedio-&gt;clock - audio_clock;</span><br><span class="line"><span class="comment">//        在合理范围外  才会延迟  加快</span></span><br><span class="line">       sync_threshold = (delay &gt; <span class="number">0.01</span> ? <span class="number">0.01</span> : delay);</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">fabs</span>(diff) &lt; <span class="number">10</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (diff &lt;= -sync_threshold) &#123;</span><br><span class="line">               delay = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold) &#123;</span><br><span class="line">               delay = <span class="number">2</span> * delay;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       start_time += delay;</span><br><span class="line">       actual_delay = start_time - av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">       <span class="keyword">if</span> (actual_delay &lt; <span class="number">0.01</span>) &#123;</span><br><span class="line">           actual_delay = <span class="number">0.01</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//  休眠时间 ffmpeg 建议这样写  为什么 要这样写 有待研究</span></span><br><span class="line">       av_usleep(actual_delay * <span class="number">1000000.0</span> + <span class="number">6000</span>);</span><br><span class="line">纠正play （播放时间）的方法 repeat_pict / (<span class="number">2</span> * fps) 是ffmpeg注释里教的</span><br><span class="line">synchronize(AVFrame *frame, <span class="keyword">double</span> play) &#123;</span><br><span class="line">   <span class="comment">//clock是当前播放的时间位置</span></span><br><span class="line">   <span class="keyword">if</span> (play != <span class="number">0</span>)</span><br><span class="line">       clock=play;</span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//pst为0 则先把pts设为上一帧时间</span></span><br><span class="line">       play = clock;</span><br><span class="line">   <span class="comment">//可能有pts为0 则主动增加clock</span></span><br><span class="line">   <span class="comment">//需要求出扩展延时：</span></span><br><span class="line">   <span class="keyword">double</span> repeat_pict = frame-&gt;repeat_pict;</span><br><span class="line">   <span class="comment">//使用AvCodecContext的而不是stream的</span></span><br><span class="line">   <span class="keyword">double</span> frame_delay = av_q2d(codec-&gt;time_base);</span><br><span class="line">   <span class="comment">//fps </span></span><br><span class="line">   <span class="keyword">double</span> fps = <span class="number">1</span> / frame_delay;</span><br><span class="line">   <span class="comment">//pts 加上 这个延迟 是显示时间  </span></span><br><span class="line">   <span class="keyword">double</span> extra_delay = repeat_pict / (<span class="number">2</span> * fps);</span><br><span class="line">   <span class="keyword">double</span> delay = extra_delay + frame_delay;</span><br><span class="line">   clock += delay;</span><br><span class="line">   <span class="keyword">return</span> play;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="FFmpeg-痛点解决"><a href="#FFmpeg-痛点解决" class="headerlink" title="FFmpeg 痛点解决"></a>FFmpeg 痛点解决</h2><p><strong>回音消除解决方案：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoYW9nL2FydGljbGUvZGV0YWlscy83MTE1Mjc0Mw==" title="https://blog.csdn.net/shichaog/article/details/71152743">语音自适应回声消除（AEC）算法<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmdiZWk5MDI5L2FydGljbGUvZGV0YWlscy84MTIzNzQwMg==" title="https://blog.csdn.net/longbei9029/article/details/81237402">回声消除(AEC)原理<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9RT3A0SU9hb19ESko2ZU5zSU9YcA==" title="https://www.infoq.cn/article/QOp4IOao_DJJ6eNsIOXp">音频降噪在 58 直播中的研究与实现<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>视频秒开：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoYXJlVXMvYXJ0aWNsZS9kZXRhaWxzLzc5MTE1ODE2" title="https://blog.csdn.net/ShareUs/article/details/79115816">直播视频秒开及视频优化<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGVhZjQ5YThkNmQ4MTAwNjE4YmMyMzg=" title="https://juejin.im/post/58eaf49a8d6d8100618bc238">视频直播秒开背后的技术与优化经验<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDQwNTkxMw==" title="https://segmentfault.com/a/1190000014405913">短视频“秒播”那点事<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy52b2lkY24uY29tL2FydGljbGUvcC1xa2R2dHR1ZS1ibWQuaHRtbA==" title="http://www.voidcn.com/article/p-qkdvttue-bmd.html">百度LSS 音视频直播 秒开<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDE1OTkxMA==" title="https://zhuanlan.zhihu.com/p/34159910">播放器的“妥协”造就了视频“秒开”的实现！<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>多人视频实时互动：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Y2IwMDhjMjZmYjlhMDY4NTQ3MzQ1ZWI=" title="https://juejin.im/post/5cb008c26fb9a068547345eb">WebRTC现状以及多人视频通话分析<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5wb2x5di5uZXQvbmV3cy8yMDE5LzAyL2h5MDM5Ni8=" title="http://www.polyv.net/news/2019/02/hy0396/">多人视频连麦——直播高效互动方式<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>实时互动与大并发负载：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy5tZWRpYXByby5jYy9ydHDovazlj5HmnI3liqHlmagv" title="http://www.mediapro.cc/rtp转发服务器/">RTP直播分发服务器集群方案<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzA1NTY1OQ==" title="https://zhuanlan.zhihu.com/p/23055659">海量用户实时互动直播架构探索<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuaXRwdWIubmV0LzY5OTA3OTgxL3ZpZXdzcGFjZS0yNTY0NDc5Lw==" title="http://blog.itpub.net/69907981/viewspace-2564479/">直播开发过程中关于直播技术的架构问题<i class="fa fa-external-link"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;img src=&quot;/images/imageFFmpeg/FFmpeg音视频架构-01.png&quot;&gt;

&lt;img src=&quot;/images/imageFFmpeg/FFmpeg音视频架构-02.png&quot;&gt;

&lt;h2 id=&quot;1-学习大纲&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频入门知识</title>
    <link href="http://miaopei.github.io/2019/04/23/FFmpeg/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8/"/>
    <id>http://miaopei.github.io/2019/04/23/FFmpeg/移动端音视频入门/</id>
    <published>2019-04-23T02:14:50.000Z</published>
    <updated>2019-06-13T02:01:37.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85N2I0ZGM4YzdmMDA=" title="https://www.jianshu.com/p/97b4dc8c7f00">H264基本原理<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-万人直播架构讲解"><a href="#1-万人直播架构讲解" class="headerlink" title="1. 万人直播架构讲解"></a>1. 万人直播架构讲解</h2><p>直播产品的种类：</p><ul><li><p>泛娱乐化直播</p><p>花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播</p></li><li><p>实时互动直播</p><p>音视频会议、教育直播等，像 思科、全时、声网</p></li></ul><a id="more"></a><p>泛娱乐化直播架构</p><blockquote><p>信令服务器：创建房间、聊天、礼物。。。。</p><p>美女主播 –信令–&gt; 信令服务器</p><p>信令服务器–rtmp流地址–&gt;美女主播</p><p>美女主播 –推流–&gt; 流媒体云CDN</p><p>观众 –信令–&gt; 信令服务器：将观众加入到美女主播间</p><p>信令服务器–rmtp流地址–&gt; 观众</p><p>观众 &lt;–拉流–&gt; 流媒体云CDN</p></blockquote><p>泛娱乐化直播架构</p><p>基于TCP协议实现</p><ol><li>发送信令到信令服务器, 服务器收到\执行后, 返回给共享端一个流媒体云的地址</li><li>共享端采集自己音视频数据, 形成rtmp流, 推送到CDN网络(推流)</li><li>获取流媒体云地址</li><li>拉流</li></ol><img src="/images/imageFFmpeg/泛娱乐化直播架构.png"><p>实时互动直播架构</p><p>基于UDP实现</p><ol><li>自有网络: UDP没有自有网络, 需自己搭建</li><li>多个节点: 为了保障服务的稳定性以及负载均衡</li><li>控制中心: 每个节点定期(心跳)向控制中心报告健康程度, 控制中心根据响应的数据做出决策</li><li>内总线: 数据安全性\吞吐量等可靠性得以保障</li><li>媒体服务器: 将RTP协议的数据转换成RTMP协议的数据</li><li>CDN网络: 根据用户需求进行拉流</li></ol><img src="/images/imageFFmpeg/实时互动直播架构.png"><h2 id="2-CDN网络介绍"><a href="#2-CDN网络介绍" class="headerlink" title="2. CDN网络介绍"></a>2. CDN网络介绍</h2><blockquote><p>CDN网络是为了解决什么问题而出现的？</p><p>总结为一句话：CDN网络是为了解决用户访问网络资源慢而出现的一个技术，两个原因：</p><ol><li>网络链路太长</li><li>人为因素（南电信北联通，利益相关）</li></ol></blockquote><p>CDN构成：</p><p>边缘结点：用户从边缘节点上获取数据</p><p>二级节点：主干网节点，主要用于缓存、减转源站压力</p><p>源站：CP(内容提供方)将内容放到源站</p><p>查找顺序：边缘结点-&gt;二级节点-&gt;源站</p><img src="/images/imageFFmpeg/CDN网络.png"><h2 id="3-亲手搭建一套简单的直播系统"><a href="#3-亲手搭建一套简单的直播系统" class="headerlink" title="3. 亲手搭建一套简单的直播系统"></a>3. 亲手搭建一套简单的直播系统</h2><p>安装nginx 配置rtmp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install nginx-full --with-rtmp-module</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">(这一步卡了我好久，安装nginx提示一直找不到nginx-full,网上相关的教程没更新，原因在于nginx仓库已搬迁)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew tap denji/nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nginx -s reload 重启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nginx  启动</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/nginx-trmp配置.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/FFMPEG直播命令.png"><img src="/images/imageFFmpeg/测试流媒体服务器.png"><h2 id="4-音频基础知识"><a href="#4-音频基础知识" class="headerlink" title="4. 音频基础知识"></a>4. 音频基础知识</h2><img src="/images/imageFFmpeg/声音三要素.png"><p>图一音量：甲乙的振动频率相同、振幅不同。图二音调：甲乙振幅相同、频率不同</p><img src="/images/imageFFmpeg/音量与音调.png"><img src="/images/imageFFmpeg/音色.png"><img src="/images/imageFFmpeg/人类听觉范围.png"><img src="/images/imageFFmpeg/听觉-发声范围.png"><h2 id="5-音频的量化与编码"><a href="#5-音频的量化与编码" class="headerlink" title="5. 音频的量化与编码"></a>5. 音频的量化与编码</h2><p>模拟信号进行采样，采样时分频率的从模拟信号获取数据波形值，采样后，进行数据量化，量化后进行编码，把采样的十进制转化为计算机的二进制，也就是数字信号。</p><p>模拟数据——》采样——》量化——》编码——》数字信号</p><img src="/images/imageFFmpeg/音频量化过程.png"><p>采样大小决定了音频的振幅的高度，采样时指一个采样用多少bit存放，常用的是16bit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bit：位     一个二进制数据0或1，是1bit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> byte：字节  存储空间的基本计量单位，如：MySQL中定义 VARCHAR(45) 即是指 45个字节；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 Byte = 8 Bit = 1 字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2^8 = 256, 2^16 = 65535</span></span><br></pre></td></tr></table></figure><p>aac通常44.1k采样率</p><p>采样率:采样频率8k/秒、16k/秒、32k/秒、44.1k/秒、48k/秒</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzUxNjky" title="https://www.zhihu.com/question/20351692">什么是音频的采样率？采样率和音质有没有关系？<i class="fa fa-external-link"></i></span> - 知乎</p></blockquote><img src="/images/imageFFmpeg/量化基本概念.png"><p>人能听到的声音范围是20hz-2whz</p><p>码率 = 采样率 x 采样大小 x 声道数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 宽带速率的单位用 bps(或b/s)表示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 B = 8 b   1 B/s = 8 b/s</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/码率计算.png"><p>原始的wav文件，大小是1411.2Kb/s</p><p>做完aaclc的编码，大小是128Kb/s</p><p>如果是aache-vr这种编码，大小是32Kb/s</p><h2 id="6-音频压缩技术讲解"><a href="#6-音频压缩技术讲解" class="headerlink" title="6. 音频压缩技术讲解"></a>6. 音频压缩技术讲解</h2><p>音频压缩技术</p><p>1、消除冗余数据（有损压缩技术）。</p><p>压缩的主要方法是去除采集到的音频冗余信息，所谓冗余信息包括人耳听觉范围外的音频信号以及被掩蔽掉的音频信号</p><p>信号的掩蔽可分为频域掩蔽和时域掩蔽</p><p>频域掩蔽：一个强纯音会掩蔽在其附近同时发声的弱纯音。也称同时掩蔽</p><p>时域掩蔽：在时间上相邻的声音之间也有掩蔽现象，主要原因是人的大脑处理信息需要花费时间。</p><p>同步掩蔽效应和不同频率声音的频率和相对竟是有关，而时间掩蔽则仅仅和时间有关。如果两个声音在时间上特别接近，分辨会有困难（如两个声音音量相差较大且两个声音间隔时间低于5毫秒，则其中弱的那个声音会听不到）。</p><p>2、哈夫曼无损编码</p><img src="/images/imageFFmpeg/音频压缩技术.png"><p>音频压缩：频域，时域。</p><ul><li><p>频域: 截取人耳能听到的频率范围，滤掉响度低的声音，去掉某个高频周围低频的声音；</p></li><li><p>时域: 滤掉某个长时间说话中的低音</p></li></ul><img src="/images/imageFFmpeg/音频冗余信息.png"><img src="/images/imageFFmpeg/频域掩蔽效应.png"><img src="/images/imageFFmpeg/时域掩蔽效应.png"><img src="/images/imageFFmpeg/音频编码过程.png"><h2 id="7-音频编解码器选型"><a href="#7-音频编解码器选型" class="headerlink" title="7. 音频编解码器选型"></a>7. 音频编解码器选型</h2><p>网上测评结果：音频编解码器 opus &gt; aac &gt; vorbis </p><p>音频编解码器：</p><p>1：opus，</p><ul><li>口模型：实时互动，对实时性要求非常高 </li><li>耳模型：高保真，对质量要求非常高</li></ul><p>至于什么时候使用那个模型，由opus自己内部来决定，同时，他是性能最好的，压缩率最好。</p><p>2：AAC，经常用于泛娱乐化直播，因为其对实时性要求不是很高但是对音质要求可能较高，所以，选用AAC，当然也可以选用opus的耳模型</p><p>3：sppex，最大的特点就是不仅可以编码音频，还可以对音频进行降噪，优化，尽可能的获取原音频数据</p><p>4：G.711(722)，主要用于音视频会议，为了和固话进行相应的融合</p><img src="/images/imageFFmpeg/常见的音频编码器.png"><img src="/images/imageFFmpeg/音频编码器性能对比.png"><h2 id="8-AAC-讲解"><a href="#8-AAC-讲解" class="headerlink" title="8. AAC 讲解"></a>8. AAC 讲解</h2><p>cdn，rtmp  支持 aac</p><p>AAC 产生的目的是取代 MP3 格式：</p><p>AAC 相对优点：压缩率高，损耗低</p><img src="/images/imageFFmpeg/AAC介绍.png"><img src="/images/imageFFmpeg/AAC规格.png"><p>aac 三种类型<br>aac<br>aacv1: aac+sbr(频率复用-高频部分采样率高，低频部分采样率低)<br>aacv2: aac+sbr+ps(声道关联，一个声道采集全部，一个声道只采集相对不同的声音)</p><p>AAC规格描述（AAC、AAC HE、AAC HE V2）–&gt; AAC+SBR=AAC HE V1, AAC + SBR + PS = AAC HE V2</p><img src="/images/imageFFmpeg/AAC规格描述.png"><p>AAC格式：</p><p>1、ADIF(Audio Data Interchange Format):只能从头开始解码，常用在磁盘文件中。</p><p>2、ADTS(Audio Data Transport Stream)：这种格式每一帧都有一个同步字，可以在音频流的任何位置开始解码，它似于数据流格式（缺点：文件比ADIF大，优点:每个帧都可以被单独解码播放）</p><img src="/images/imageFFmpeg/AAC格式.png"><p>aac 编码库 ffmpeg AAC，libfdk AAC</p><img src="/images/imageFFmpeg/AAC编码库那个好.png"><h2 id="9-视频基本知识"><a href="#9-视频基本知识" class="headerlink" title="9. 视频基本知识"></a>9. 视频基本知识</h2><p>I帧：关键帧，采用帧内压缩技术</p><p>P帧：向前参考帧，压缩时只参考前一个帧，属于帧间压缩技术</p><p>B帧：双向参考帧，压缩时即参考前一帧也参考后一帧，属于帧间压缩技术</p><p>一般实时互动都不会使用 B 帧</p><img src="/images/imageFFmpeg/H264基本概念.png"><p>GOF(group of frame): 一组帧，可以将一段时间内画面变化不大的所有帧划为一组帧</p><img src="/images/imageFFmpeg/GOF.png"><p>SPS与PPS（这两种都划为 I 帧）：</p><ul><li><p>SPS(Sequence Parameter Set): </p><p>序列参数集，存放帧数、参考帧数目、解码图像尺寸、帧场编码模式选择标识等。</p></li><li><p>PPS(Picture Parameter Set):</p><p>图像参数集，存放熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系统数调整标识等</p></li></ul><img src="/images/imageFFmpeg/SPS与PPS.png"><p>视频花屏/卡顿原因：</p><p>1、如果 GOP 分组中的 P 帧丢失会造成解码端的图像发生错误（于是形成了花屏）。</p><p>2、为了避免花屏问题的发生，一般如果发现 P 帧或者I帧丢失，就不显示本 GOP 内的所有帧，直到下一个 I 帧来后重新刷新图像（因为丢了一组数据，所以形成了卡顿）</p><img src="/images/imageFFmpeg/视频花屏卡顿的原因.png"><p>视频编码器：</p><p>1、x264/x265。</p><p>2、openH264(支持 SVC（分层传输） 技术)。</p><p>3、vp8/vp9</p><img src="/images/imageFFmpeg/视频都有哪些视频编码器.png"><h2 id="10-H264-宏块的划分与帧分组"><a href="#10-H264-宏块的划分与帧分组" class="headerlink" title="10. H264 宏块的划分与帧分组"></a>10. H264 宏块的划分与帧分组</h2><p>H264压缩技术</p><ol><li>帧内预测压缩，解决的是空域数据冗余问题（将一幅图里的人眼不是很敏感的色彩、光亮等数据剔除）</li><li>帧间预测压缩，解决的是时域数据冗余问题（将一组图里面连续的重复性高的帧剔除）</li><li>整数离散余弦变换(DCT)，将空间上的相关性变为频域上无关的数据然后进行量化</li><li>CABAC压缩，也叫上下文适应无损压缩</li></ol><img src="/images/imageFFmpeg/H264压缩技术.png"><p>宏块的划分与分组：</p><p>H264宏块划分与子块划分：宏块里面可以再包含很多子块</p><img src="/images/imageFFmpeg/H264宏块划分.png"><img src="/images/imageFFmpeg/宏块划分完成.png"><p>子块划分：</p><img src="/images/imageFFmpeg/子块划分.png"><p>帧分组(一组连续的图片，一幅图片为一帧)</p><img src="/images/imageFFmpeg/帧分组.png"><h2 id="11-视频压缩技术详解"><a href="#11-视频压缩技术详解" class="headerlink" title="11. 视频压缩技术详解"></a>11. 视频压缩技术详解</h2><ul><li><p>帧间预测: </p><p>解决时间数据冗余，比较相邻两帧不同给出运动矢量 + 残差值</p></li><li><p>帧内预测: </p><p>解决空间数据冗余，每一个宏块有一个预测模式，然后讲预测后的图像与原图比较算差值，最后存储预测模式和差值即可。帧内压缩是针对于 I 帧的</p></li></ul><h3 id="11-1-帧间预测"><a href="#11-1-帧间预测" class="headerlink" title="11.1 帧间预测"></a>11.1 帧间预测</h3><p>组内宏块查找：</p><img src="/images/imageFFmpeg/组内宏块查找.png"><img src="/images/imageFFmpeg/运动估算.png"><img src="/images/imageFFmpeg/运动矢量与补偿压缩.png"><h3 id="11-2-帧内预测"><a href="#11-2-帧内预测" class="headerlink" title="11.2 帧内预测"></a>11.2 帧内预测</h3><img src="/images/imageFFmpeg/帧内预测.png"><img src="/images/imageFFmpeg/计算帧内预测残差值.png"><img src="/images/imageFFmpeg/预测模式与残差值压缩.png"><h3 id="11-3-DCT-压缩"><a href="#11-3-DCT-压缩" class="headerlink" title="11.3 DCT 压缩"></a>11.3 DCT 压缩</h3><img src="/images/imageFFmpeg/DCT压缩.png"><img src="/images/imageFFmpeg/压缩后的结果.png"><h3 id="11-4-VLC-压缩"><a href="#11-4-VLC-压缩" class="headerlink" title="11.4 VLC 压缩"></a>11.4 VLC 压缩</h3><img src="/images/imageFFmpeg/VLC压缩.png"><h3 id="11-5-CABAC-压缩"><a href="#11-5-CABAC-压缩" class="headerlink" title="11.5 CABAC 压缩"></a>11.5 CABAC 压缩</h3><img src="/images/imageFFmpeg/CABAC压缩.png"><h2 id="12-H264-结构与码流"><a href="#12-H264-结构与码流" class="headerlink" title="12. H264 结构与码流"></a>12. H264 结构与码流</h2><p>H264编码分层：</p><p>1、NAL层（Network Abstraction Layer）, 视频数据网络抽象层。</p><p>2、VCL层（Video Coding Layer），视频数据编码层，对原始数据进行压缩</p><p>码流基本概念：</p><p>1、SODB（String Of Data Bits）,原始数据比特流，长度不一定是8的倍数，它是由VCL层产生的。</p><p>2、RBSP（Raw Byte Sequence Payload,SODB+trailing bits），算法是在SODB最后一位补1，不按字节对齐则补0。</p><p>3、EBSP(Encapsulate Byte Sequence Payload)，需到两个连续的0x00就增加一个0x03。</p><p>4、NALU，NAL Header(1B)+EBSP</p><img src="/images/imageFFmpeg/H264结构图.png"><p>以太网最大传输字节 1500 字节。</p><img src="/images/imageFFmpeg/H264编码分层.png"><img src="/images/imageFFmpeg/码流基本概念一.png"><img src="/images/imageFFmpeg/码流基本概念二.png"><p>一个H264帧最少要有一个切片(NAL Unit)</p><img src="/images/imageFFmpeg/NALUnit.png"><p>切片与宏块的关系：</p><ul><li>每个切片都包括切片头和切片数据，</li><li>每个切片数据又包括了很多宏块，</li><li>每个宏块又包括了宏块的类型、宏块的预测、编码的残渣数据等</li></ul><img src="/images/imageFFmpeg/切片与宏.png"><img src="/images/imageFFmpeg/H264切片.png"><img src="/images/imageFFmpeg/H264码流分层.png"><h2 id="13-NAL-单元详解"><a href="#13-NAL-单元详解" class="headerlink" title="13. NAL 单元详解"></a>13. NAL 单元详解</h2><img src="/images/imageFFmpeg/NALHeader.png"><p>5 - 关键帧</p><p>7- SPS 序列参数集</p><p>8- PPS 图像参数集</p><img src="/images/imageFFmpeg/NALType一.png"><img src="/images/imageFFmpeg/NALType二.png"><img src="/images/imageFFmpeg/NAL类型介绍.png"><img src="/images/imageFFmpeg/单一NALU的RTP包.png"><img src="/images/imageFFmpeg/组合NALU的RTP包.png"><p>如：</p><p>P帧B帧很多都是单一类型。</p><p>SPS和PPS这两个NAL单元一般放在同一个RTP包里头</p><img src="/images/imageFFmpeg/分片NALU的RTP包.png"><img src="/images/imageFFmpeg/FUHeader.png"><h2 id="14-YUV-讲解"><a href="#14-YUV-讲解" class="headerlink" title="14. YUV 讲解"></a>14. YUV 讲解</h2><img src="/images/imageFFmpeg/图像除了RGB还是有YUV.png"><img src="/images/imageFFmpeg/YUV.png"><p>YUV常见格式：YUV4:2:0、YUV4:2:2、YUV4:4:4</p><p>RGB8:8:8</p><img src="/images/imageFFmpeg/YUV常见格式.png"><img src="/images/imageFFmpeg/YUV420.png"><ul><li>UV 混存则为packed(打包存储)，</li><li>UV分开存则为planar(平面存储) </li></ul><img src="/images/imageFFmpeg/YUV存储格式.png"><h2 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h2><img src="/images/imageFFmpeg/小结.png"><img src="/images/imageFFmpeg/音频小结.png"><img src="/images/imageFFmpeg/视频小结.png"><p>rtmp 实时消息传输: tcp/ip 应用层协议  推送/直播  基本数据单元为消息</p><p>1B 消息类型  2B 长度  3B 时间 4B  流id 消息体</p><p>传输时 消息回被拆分成消息块 chunk chunk header + chunk data</p><p>flv: 大块音视频 加入标记头信息   延迟表现和大规模并发成熟 </p><p>HLS：分成5-10s 用m3u8索引管理 用于朋友圈分享  </p><p>m3u8索引： 直播信号源–视频编码器（后台视频处理）–流切片器–各种ts媒体文件（分发模块）–索引文件（数据库）–客户端</p><p>cdn网络 为了解决用户访问资源慢出现的技术</p><p>边缘节点  二级节点（大城市） 源站</p><p>搭建流媒体服务：</p><p>准备流媒体服务器 linux max 编译安装nginx服务  配置rtmp服务并启动nginx服务</p><p>声音三要素：音调 音量 音色</p><p>音频量化(模数转换)：模拟数据 采样  量化 编码  数字信号  == 0101001110</p><p>码率 = 采样率（1.6w/44.1/48k）x 采样大小(8位-电话/16位-常见) x 声道数（单/双）</p><p>音频压缩： 有损消除冗余数据   哈夫曼无损编码</p><p>音频编码： 时域转频域—心里声学模型—量化编码—比特流格式化—比特流</p><p>音频编解码 ： opus（口 耳 实时互动 最快）  aac(直播用 次快)  speed(回音 降噪等)   g.711（固话）</p><p>aac : 取代mp3 加入 sir ps 技术  </p><p>aac lc 128k / aac he v2 64k /  aac he v2 32k/</p><p>aac 格式 ： adif 从头开始解码，用在磁盘文件中  adts 每一帧都有一个同步字，可以在任何位置解码</p><p>aac 编码库 ： libfdk_aac &gt; ffmpeg aac &gt;libfaac&gt; libvo_aacenc</p><p>H264： I帧 关键 帧内压缩  / p帧 向前参考1帧 / B帧 双向参考帧</p><p>sps: 序列参数集/pps:图像参数集 </p><p>GOF： 一组帧数  p帧丢失 会花屏卡顿</p><p>视频编码器： x264/x265 /open h264(svc)/vp8/vp9</p><p>h264 压缩技术-编码原理： 帧内预测压缩，空域冗余数据/帧间预测压缩，时域冗余数据/dcp整数离散余炫变换，傅立叶变换/cabac压缩</p><p>h264结构：视频序列–图像–片–宏块–子快</p><p>h264编码分层：nal 视频数据网络抽象层–vcl 视频数据编码层</p><p>码率：sodb 原始比特流 / rbsp sodb最后补1 / ebsp 起始码增加一个起始位0x03 /  nalu nal+ebsp</p><p>nal unit = nalu 头部 + 一个切片（头/数据） 切片 </p><p>yuv格式：4：4:4/4:4:2/4：2:0 （平坦编码 /半平坦编码）</p><img src="/images/imageFFmpeg/后续.png"><img src="/images/imageFFmpeg/音视频知识01.png"><img src="/images/imageFFmpeg/音视频知识02.png"><img src="/images/imageFFmpeg/音视频知识03.png"><img src="/images/imageFFmpeg/行业痛点-01.png"><img src="/images/imageFFmpeg/行业痛点-02.png">]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85N2I0ZGM4YzdmMDA=&quot; title=&quot;https://www.jianshu.com/p/97b4dc8c7f00&quot;&gt;H264基本原理&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-万人直播架构讲解&quot;&gt;&lt;a href=&quot;#1-万人直播架构讲解&quot; class=&quot;headerlink&quot; title=&quot;1. 万人直播架构讲解&quot;&gt;&lt;/a&gt;1. 万人直播架构讲解&lt;/h2&gt;&lt;p&gt;直播产品的种类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;泛娱乐化直播&lt;/p&gt;
&lt;p&gt;花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实时互动直播&lt;/p&gt;
&lt;p&gt;音视频会议、教育直播等，像 思科、全时、声网&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Vim 快捷键</title>
    <link href="http://miaopei.github.io/2018/03/20/vimHotKey/"/>
    <id>http://miaopei.github.io/2018/03/20/vimHotKey/</id>
    <published>2018-03-20T08:53:46.000Z</published>
    <updated>2019-06-13T06:43:59.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamlxaW5nd3UvYXJjaGl2ZS8yMDEyLzA2LzE0L3ZpbV9ub3Rlcy5odG1s" title="https://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html">Vim使用笔记<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-文档操作"><a href="#1-文档操作" class="headerlink" title="1. 文档操作"></a>1. 文档操作</h2><ul><li><code>:e</code> – 重新加载当前文档。</li><li><code>:e!</code> – 重新加载当前文档，并丢弃已做的改动。</li><li><code>:e file</code> – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。</li><li><code>:e! file</code> – 放弃对当前文件的修改，编辑新的文件。</li><li><code>:e# 或 ctrl+^</code> – 回到刚才编辑的文件，很实用。</li><li><code>gf</code> – 打开以光标所在字符串为文件名的文件。</li><li><code>:saveas newfilename</code> – 另存为</li></ul><a id="more"></a><h2 id="2-光标的移动"><a href="#2-光标的移动" class="headerlink" title="2. 光标的移动"></a>2. 光标的移动</h2><ul><li><code>gj</code> : 移动到一段内的下一行；</li><li><code>gk</code> : 移动到一段内的上一行；</li><li><code>w</code> : 前移一个单词，光标停在下一个单词开头；</li><li><code>b</code> : 后移一个单词，光标停在上一个单词开头；</li><li><code>(</code> : 前移1句。</li><li><code>)</code> : 后移1句。</li><li><code>{</code> : 前移1段。</li><li><code>}</code> : 后移1段。</li><li><code>fc</code> : 把光标移到同一行的下一个 c 字符处</li><li><code>Fc</code> : 把光标移到同一行的上一个 c 字符处</li><li><code>tc</code> : 把光标移到同一行的下一个 c 字符前</li><li><code>Tc</code> : 把光标移到同一行的上一个 c 字符后</li><li><code>;</code> : 配合 <code>f &amp; t</code> 使用，重复一次</li><li><code>,</code> : 配合 <code>f &amp; t</code> 使用，反向重复一次</li></ul><p>上面的操作都可以配合 n 使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动 3 个字符。</p><ul><li><code>0</code> : 移动到行首。</li><li><code>g0</code> : 移到光标所在屏幕行行首。</li><li><code>^</code> : 移动到本行第一个非空白字符。</li><li><code>g^</code>: 同 <code>^</code> ，但是移动到当前屏幕行第一个非空字符处。</li><li><code>$</code> : 移动到行尾。</li><li><code>g$</code> : 移动光标所在屏幕行行尾。</li><li><code>n|</code> : 把光标移到递 n 列上。</li><li><code>nG</code> : 到文件第 n 行。</li><li><code>:n&lt;cr&gt;</code> : 移动到第 n 行。</li><li><code>:$&lt;cr&gt;</code> : 移动到最后一行。</li><li><code>H</code> : 把光标移到屏幕最顶端一行。</li><li><code>M</code> : 把光标移到屏幕中间一行。</li><li><code>L</code> : 把光标移到屏幕最底端一行。</li><li><code>gg</code> : 到文件头部。</li><li><code>G</code> : 到文件尾部。</li></ul><h3 id="2-1-翻屏"><a href="#2-1-翻屏" class="headerlink" title="2.1 翻屏"></a>2.1 翻屏</h3><ul><li><code>ctrl+f</code> : 下翻一屏。</li><li><code>ctrl+b</code> : 上翻一屏。</li><li><code>ctrl+d</code> : 下翻半屏。</li><li><code>ctrl+u</code> : 上翻半屏。</li><li><code>ctrl+e</code> : 向下滚动一行。</li><li><code>ctrl+y</code> : 向上滚动一行。</li><li><code>n%</code> : 到文件 <code>n%</code> 的位置。</li><li><code>zz</code> : 将当前行移动到屏幕中央。</li><li><code>zt</code> : 将当前行移动到屏幕顶端。</li><li><code>zb</code> : 将当前行移动到屏幕底端。</li></ul><h3 id="2-2-标记"><a href="#2-2-标记" class="headerlink" title="2.2 标记"></a>2.2 标记</h3><p>使用标记可以快速移动。到达标记后，可以用 <code>Ctrl+o</code> 返回原来的位置。 <code>Ctrl+o</code> 和 <code>Ctrl+i</code> 很像浏览器上的 <em>后退</em> 和 <em>前进</em> 。</p><ul><li><code>m{a-z}</code> : 标记光标所在位置，局部标记，只用于当前文件。</li><li><code>m{A-Z}</code> : 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li><li>``{a-z}` : 移动到标记位置。</li><li><code>&#39;{a-z}</code> : 移动到标记行的行首。</li><li>``{0-9}` ：回到上[2-10]次关闭vim时最后离开的位置。</li><li>``: 移动到上次编辑的位置。’’ 也可以，不过``精确到列，而 ‘’ 精确到行 。如果想跳转到更老的位置，可以按 C-o，跳转到更新的位置用 C-i。</li><li>`” : 移动到上次离开的地方。</li><li>`. : 移动到最后改动的地方。</li><li><code>:marks</code> – 显示所有标记。</li><li><code>:delmarks a b</code> – 删除标记 a 和 b。</li><li><code>:delmarks a-c</code> – 删除标记 a、b 和 c。</li><li><code>:delmarks a c-f</code> – 删除标记 a、c、d、e、f。</li><li><code>:delmarks!</code> – 删除当前缓冲区的所有标记。</li><li><code>:help mark-motions</code>  – 查看更多关于 mark 的知识。</li></ul><h2 id="3-插入文本"><a href="#3-插入文本" class="headerlink" title="3. 插入文本"></a>3. 插入文本</h2><h3 id="3-1-基本插入"><a href="#3-1-基本插入" class="headerlink" title="3.1 基本插入"></a>3.1 基本插入</h3><ul><li><code>i</code> : 在光标前插入；一个小技巧：按 8，再按 <code>i</code>，进入插入模式，输入 <code>=</code>， 按 <code>esc</code> 进入命令模式，就会出现 8 个 <code>=</code> 。 这在插入分割线时非常有用，如<code>30i+&lt;esc&gt;</code> 就插入了 36 个 <code>+</code> 组成的分割线。</li><li><code>:r filename</code> : 在当前位置插入另一个文件的内容。</li><li><code>:r !date</code> :  在光标处插入当前日期与时间。同理，<code>:r !command</code> 可以将其它 shell 命令的输出插入当前文档。</li></ul><h3 id="3-2-改写插入"><a href="#3-2-改写插入" class="headerlink" title="3.2 改写插入"></a>3.2 改写插入</h3><ul><li><code>c[n]w</code> : 改写光标后 1(n) 个词。</li><li><code>c[n]l</code> : 改写光标后 n 个字母。</li><li><code>c[n]h</code> : 改写光标前 n 个字母。</li><li><code>[n]cc</code> : 修改当前 [n] 行。</li><li><code>[n]s</code> : 以输入的文本替代光标之后 1(n) 个字符，相当于 <code>c[n]l</code>。</li><li><code>[n]S</code> : 删除指定数目的行，并以所输入文本代替之。</li></ul><p>注意，类似 <code>cnw,dnw,ynw</code> 的形式同样可以写为 <code>ncw,ndw,nyw</code>。</p><h2 id="4-剪切复制和寄存器"><a href="#4-剪切复制和寄存器" class="headerlink" title="4. 剪切复制和寄存器"></a>4. 剪切复制和寄存器</h2><h3 id="4-1-剪切和复制、粘贴"><a href="#4-1-剪切和复制、粘贴" class="headerlink" title="4.1 剪切和复制、粘贴"></a>4.1 剪切和复制、粘贴</h3><ul><li><code>[n]x</code> : 剪切光标右边 n 个字符，相当于 <code>d[n]l</code>。</li><li><code>[n]X</code> : 剪切光标左边 n 个字符，相当于 <code>d[n]h</code>。</li><li><code>y</code> : 复制在可视模式下选中的文本。</li><li><code>yy or Y</code> : 复制整行文本。</li><li><code>y[n]w</code> : 复制一 (n) 个词。</li><li><code>y[n]l</code> : 复制光标右边 1(n) 个字符。</li><li><code>y[n]h</code> : 复制光标左边 1(n) 个字符。</li><li><code>y$</code> : 从光标当前位置复制到行尾。</li><li><code>y0</code> : 从光标当前位置复制到行首。</li><li><code>:m,ny&lt;cr&gt;</code> : 复制 m 行到 n 行的内容。</li><li><code>y1G 或 ygg</code> : 复制光标以上的所有行。</li><li><code>yG</code> : 复制光标以下的所有行。</li><li><code>yaw 和 yas</code>：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</li><li><code>d</code> : 删除（剪切）在可视模式下选中的文本。</li><li><code>d$ or D</code> : 删除（剪切）当前位置到行尾的内容。</li><li><code>d[n]w</code>: 删除（剪切）1(n)个单词</li><li><code>d[n]l</code>: 删除（剪切）光标右边 1(n) 个字符。</li><li><code>d[n]h</code>: 删除（剪切）光标左边 1(n) 个字符。</li><li><code>d0</code>: 删除（剪切）当前位置到行首的内容</li><li><code>[n] dd</code>: 删除（剪切）1(n) 行。</li><li><code>:m,nd&lt;cr&gt;</code> : 剪切 m 行到 n 行的内容。</li><li><code>d1G 或 dgg</code> : 剪切光标以上的所有行。</li><li><code>dG</code> : 剪切光标以下的所有行。</li><li><code>daw 和 das</code>：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li><li><code>d/f&lt;cr&gt;</code>：这是一个比较高级的组合命令，它将删除当前位置 到下一个 f 之间的内容。</li><li><code>p</code>: 在光标之后粘贴。</li><li><code>P</code> : 在光标之前粘贴。</li></ul><h3 id="4-2-文本对象"><a href="#4-2-文本对象" class="headerlink" title="4.2 文本对象"></a>4.2 文本对象</h3><ul><li><code>aw</code>：一个词</li><li><code>as</code>：一句。</li><li><code>ap</code>：一段。</li><li><code>ab</code>：一块（包含在圆括号中的）。</li></ul><p><code>y, d, c, v</code> 都可以跟文本对象。</p><h3 id="4-3-寄存器"><a href="#4-3-寄存器" class="headerlink" title="4.3 寄存器"></a>4.3 寄存器</h3><ul><li><code>a-z</code>：都可以用作寄存器名。<code>&quot;ayy</code> 把当前行的内容放入 a 寄存器。</li><li><code>A-Z</code>：用大写字母索引寄存器，可以在寄存器中追加内容。 如 <code>&quot;Ayy</code> 把当前行的内容追加到 a 寄存器中。</li><li><code>:reg</code> : 显示所有寄存器的内容。</li><li><code>&quot;&quot;</code>：不加寄存器索引时，默认使用的寄存器。</li><li><code>&quot;*</code>：当前选择缓冲区，<code>&quot;*yy</code> 把当前行的内容放入当前选择缓冲区。</li><li><code>&quot;+</code>：系统剪贴板。<code>&quot;+yy</code> 把当前行的内容放入系统剪贴板。</li></ul><h2 id="5-查找与替换"><a href="#5-查找与替换" class="headerlink" title="5. 查找与替换"></a>5. 查找与替换</h2><h3 id="5-1-查找"><a href="#5-1-查找" class="headerlink" title="5.1 查找"></a>5.1 查找</h3><ul><li><code>/something</code> : 在后面的文本中查找 something。</li><li><code>?something</code> : 在前面的文本中查找 something。</li><li><code>/pattern/+number</code> : 将光标停在包含 pattern 的行后面第 number 行上。</li><li><code>/pattern/-number</code> : 将光标停在包含 pattern 的行前面第 number 行上。</li><li><code>n</code> : 向后查找下一个。</li><li><code>N</code> : 向前查找下一个。</li></ul><p>可以用 grep 或 vimgrep 查找一个模式都在哪些地方出现过，其中 <code>:grep</code> 是调用外部的 grep 程序，而 <code>:vimgrep</code> 是 vim 自己的查找算法。</p><p>用法为： <code>:vim[grep]/pattern/[g] [j] files</code></p><ul><li><p><code>g</code> 的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p></li><li><p><code>j</code> 的含义是 grep 结束后，结果停在第 j 项，默认是停在第一项。</p></li></ul><p>vimgrep 前面可以加数字限定搜索结果的上限，如 <code>:1vim/pattern/ %</code> 只查找那个模式在本文件中的第一个出现。</p><p>其实 vimgrep 在读纯文本电子书时特别有用，可以生成导航的目录。</p><p>比如电子书中每一节的标题形式为：<code>n. xxxx</code>。你就可以这样：<code>:vim/^d{1,}./ %</code> 然后用 <code>:cw</code> 或 <code>:copen</code> 查看结果，可以用 <code>C-w H</code> 把 quickfix 窗口移到左侧，就更像个目录了。</p><h3 id="5-2-替换"><a href="#5-2-替换" class="headerlink" title="5.2 替换"></a>5.2 替换</h3><ul><li><code>:s/old/new</code> – 用 new 替换当前行第一个 old。</li><li><code>:s/old/new/g</code> – 用 new 替换当前行所有的 old。</li><li><code>:n1,n2s/old/new/g</code> – 用 new 替换文件 n1 行到 n2 行所有的 old。</li><li><code>:%s/old/new/g</code> – 用 new 替换文件中所有的 old。</li><li><code>:%s/^/xxx/g</code> – 在每一行的行首插入 xxx，<code>^</code> 表示行首。</li><li><code>:%s/$/xxx/g</code> – 在每一行的行尾插入 xxx，<code>$</code> 表示行尾。</li><li>所有替换命令末尾加上 c，每个替换都将需要用户确认。 如：<code>%s/old/new/gc</code>，加上i则忽略大小写(ignore)。</li></ul><p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p><p>语法为 <code>:[range]g/pattern/command</code></p><p>例如 <code>: %g/^ xyz/normal dd</code>。</p><p>表示对于以一个空格和 xyz 开头的行执行 normal 模式下的 dd 命令。</p><p>关于 range 的规定为：</p><ul><li>如果不指定 range，则表示当前行。</li><li><code>m,n</code> : 从 m 行到 n 行。</li><li><code>0</code> : 最开始一行（可能是这样）。</li><li><code>$</code> : 最后一行</li><li><code>.</code> : 当前行</li><li><code>%</code> : 所有行</li></ul><h3 id="5-3-正则表达式"><a href="#5-3-正则表达式" class="headerlink" title="5.3 正则表达式"></a>5.3 正则表达式</h3><p>高级的查找替换就要用到正则表达式。</p><ul><li><code>\d</code> : 表示十进制数（我猜的）</li><li><code>\s</code> : 表示空格</li><li><code>\S</code> : 非空字符</li><li><code>\a</code> : 英文字母</li><li><code>\|</code> : 表示 或</li><li><code>\.</code> : 表示.</li><li><code>{m,n}</code> : 表示 m 到 n 个字符。这要和 <code>\s</code> 与 <code>\a</code> 等连用，如 <code>\a\{m,n}</code> 表示 m 到 n 个英文字母。</li><li><code>{m,}</code>: 表示 m 到无限多个字符。</li><li><code>**</code>: 当前目录下的所有子目录。</li></ul><p><code>:help pattern</code> 得到更多帮助。</p><h2 id="6-编辑多个文件"><a href="#6-编辑多个文件" class="headerlink" title="6. 编辑多个文件"></a>6. 编辑多个文件</h2><h3 id="6-1-一次编辑多个文件"><a href="#6-1-一次编辑多个文件" class="headerlink" title="6.1 一次编辑多个文件"></a>6.1 一次编辑多个文件</h3><p>我们可以一次打开多个文件，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi a.txt b.txt c.txt</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>:next(:n)</code> 编辑下一个文件。</li><li><code>:2n</code> 编辑下 2 个文件。</li><li>使用 <code>:previous或:N</code> 编辑上一个文件。</li><li>使用 <code>:wnext</code>，保存当前文件，并编辑下一个文件。</li><li>使用 <code>:wprevious</code>，保存当前文件，并编辑上一个文件。</li><li>使用 <code>:args</code> 显示文件列表。</li><li><code>:n filenames 或 :args filenames</code> 指定新的文件列表。</li><li><code>vi -o filenames</code> 在水平分割的多个窗口中编辑多个文件。</li><li><code>vi -O filenames</code> 在垂直分割的多个窗口中编辑多个文件。</li></ul><h3 id="6-2-多标签编辑"><a href="#6-2-多标签编辑" class="headerlink" title="6.2 多标签编辑"></a>6.2 多标签编辑</h3><ul><li><code>vim -p files</code> : 打开多个文件，每个文件占用一个标签页。</li><li><code>:tabe, tabnew</code> – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li><li><code>^w gf</code> – 在新的标签页里打开光标下路径指定的文件。</li><li><code>:tabn</code> – 切换到下一个标签。<code>Control + PageDown</code>，也可以。</li><li><code>:tabp</code> – 切换到上一个标签。<code>Control + PageUp</code>，也可以。</li><li><code>[n] gt</code> – 切换到下一个标签。如果前面加了 n ， 就切换到第 n 个标签。第一个标签的序号就是 1。</li><li><code>:tab split</code> – 将当前缓冲区的内容在新页签中打开。</li><li><code>:tabc[lose]</code> – 关闭当前的标签页。</li><li><code>:tabo[nly]</code> – 关闭其它的标签页。</li><li><code>:tabs</code> – 列出所有的标签页和它们包含的窗口。</li><li><code>:tabm[ove] [N]</code> – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li></ul><h3 id="6-3-缓冲区"><a href="#6-3-缓冲区" class="headerlink" title="6.3 缓冲区"></a>6.3 缓冲区</h3><ul><li><code>:buffers 或 :ls 或 :files</code> 显示缓冲区列表。</li><li><code>ctrl+^</code>：在最近两个缓冲区间切换。</li><li><code>:bn</code> – 下一个缓冲区。</li><li><code>:bp</code> – 上一个缓冲区。</li><li><code>:bl</code> – 最后一个缓冲区。</li><li><code>:b[n] 或 :[n]b</code> – 切换到第 n 个缓冲区。</li><li><code>:nbw(ipeout)</code> – 彻底删除第 n 个缓冲区。</li><li><code>:nbd(elete)</code> – 删除第 n 个缓冲区，并未真正删除，还在 unlisted 列表中。</li><li><code>:ba[ll]</code> – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li></ul><h2 id="7-分屏编辑"><a href="#7-分屏编辑" class="headerlink" title="7. 分屏编辑"></a>7. 分屏编辑</h2><ul><li><code>vim -o file1 file2</code> : 水平分割窗口，同时打开 file1 和 file2</li><li><code>vim -O file1 file2</code> : 垂直分割窗口，同时打开 file1 和 file2</li></ul><h3 id="7-1-水平分割"><a href="#7-1-水平分割" class="headerlink" title="7.1 水平分割"></a>7.1 水平分割</h3><ul><li><code>:split(:sp)</code> – 把当前窗水平分割成两个窗口。(<code>CTRL-W s</code> 或 <code>CTRL-W CTRL-S</code>) 注意如果在终端下，<code>CTRL-S</code> 可能会冻结终端，请按 <code>CTRL-Q</code> 继续。</li><li><code>:split filename</code> – 水平分割窗口，并在新窗口中显示另一个文件。</li><li><code>:nsplit(:nsp)</code> – 水平分割出一个 n 行高的窗口。</li><li><code>:[N]new</code> – 水平分割出一个N行高的窗口，并编辑一个新文件。 ( <code>CTRL-W n</code> 或  <code>CTRL-W CTRL-N</code>)</li><li><code>ctrl+w f</code> –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li><li><code>C-w C-^</code> – 水平分割一个窗口，打开刚才编辑的文件。</li></ul><h3 id="7-2-垂直分割"><a href="#7-2-垂直分割" class="headerlink" title="7.2 垂直分割"></a>7.2 垂直分割</h3><ul><li><code>:vsplit(:vsp)</code> – 把当前窗口分割成水平分布的两个窗口。 (<code>CTRL-W v</code> 或 <code>CTRL CTRL-V</code>)</li><li><code>:[N]vne[w]</code> – 垂直分割出一个新窗口。</li><li><code>:vertical 水平分割的命令</code>： 相应的垂直分割。</li></ul><h3 id="7-3-关闭子窗口"><a href="#7-3-关闭子窗口" class="headerlink" title="7.3 关闭子窗口"></a>7.3 关闭子窗口</h3><ul><li><code>:qall</code> – 关闭所有窗口，退出 vim。</li><li><code>:wall</code> – 保存所有修改过的窗口。</li><li><code>:only</code> – 只保留当前窗口，关闭其它窗口。(<code>CTRL-W o</code>)</li><li><code>:close</code> – 关闭当前窗口，<code>CTRL-W c</code>能实现同样的功能。 (象 <code>:q :x</code> 同样工作 )</li></ul><h3 id="7-4-调整窗口大小"><a href="#7-4-调整窗口大小" class="headerlink" title="7.4 调整窗口大小"></a>7.4 调整窗口大小</h3><ul><li><code>ctrl+w +</code> –当前窗口增高一行。也可以用 n 增高 n 行。</li><li><code>ctrl+w -</code> –当前窗口减小一行。也可以用 n 减小 n 行。</li><li><code>ctrl+w _</code> –当前窗口扩展到尽可能的大。也可以用 n 设定行数。</li><li><code>:resize n</code> – 当前窗口 n 行高。</li><li><code>ctrl+w =</code> – 所有窗口同样高度。</li><li><code>n ctrl+w _</code> – 当前窗口的高度设定为 n 行。</li><li><code>ctrl+w &lt;</code> –当前窗口减少一列。也可以用 n 减少 n 列。</li><li><code>ctrl+w &gt;</code> –当前窗口增宽一列。也可以用 n 增宽 n 列。</li><li><code>ctrl+w |</code> –当前窗口尽可能的宽。也可以用 n 设定列数。</li></ul><h3 id="7-5-切换和移动窗口"><a href="#7-5-切换和移动窗口" class="headerlink" title="7.5 切换和移动窗口"></a>7.5 切换和移动窗口</h3><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p><ul><li><code>ctrl+w ctrl+w</code> : 切换到下一个窗口。或者是 <code>ctrl+w w</code>。</li><li><code>ctrl+w p</code> : 切换到前一个窗口。</li><li><code>ctrl+w h(l,j,k)</code> :切换到左（右，下，上）的窗口。</li><li><code>ctrl+w t(b)</code> :切换到最上（下）面的窗口。</li><li><code>ctrl+w H(L,K,J)</code> : 将当前窗口移动到最左（右、上、下）面。</li><li><code>ctrl+w r</code>：旋转窗口的位置。</li><li><code>ctrl+w T</code> : 将当前的窗口移动到新的标签页上。</li></ul><h2 id="8-快速编辑"><a href="#8-快速编辑" class="headerlink" title="8. 快速编辑"></a>8. 快速编辑</h2><h3 id="8-1-改变大小写"><a href="#8-1-改变大小写" class="headerlink" title="8.1 改变大小写"></a>8.1 改变大小写</h3><ul><li><code>~</code> : 反转光标所在字符的大小写。</li><li>可视模式下的 U 或 u：把选中的文本变为大写或小写。</li><li><code>gu(U)</code> 接范围（如<code>$</code>，或 <code>G</code>），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如<code>ggguG</code>，就是把开头到最后一行之间的字母全部变为小 写。再如 <code>gu5j</code>，把当前行和下面四行全部变成小写。</li></ul><h3 id="8-2-替换（normal模式）"><a href="#8-2-替换（normal模式）" class="headerlink" title="8.2 替换（normal模式）"></a>8.2 替换（normal模式）</h3><ul><li><code>r</code> : 替换光标处的字符，同样支持汉字。</li><li><code>R</code> : 进入替换模式，按 <code>esc</code> 回到正常模式。</li></ul><h3 id="8-3-撤消与重做（normal模式）"><a href="#8-3-撤消与重做（normal模式）" class="headerlink" title="8.3 撤消与重做（normal模式）"></a>8.3 撤消与重做（normal模式）</h3><ul><li><code>[n] u</code> : 取消一(n)个改动。</li><li><code>:undo 5</code> – 撤销 5 个改变。</li><li><code>:undolist</code> – 你的撤销历史。</li><li><code>ctrl + r</code> : 重做最后的改动。</li><li><code>U</code> : 取消当前行中所有的改动。</li><li><code>:earlier 4m</code> – 回到 4 分钟前</li><li><code>:later 55s</code> – 前进 55 秒</li></ul><h3 id="8-4-宏"><a href="#8-4-宏" class="headerlink" title="8.4 宏"></a>8.4 宏</h3><ul><li><code>.</code> –重复上一个编辑动作</li><li><code>qa</code>：开始录制宏 a（键盘操作记录）</li><li><code>q</code>：停止录制</li><li><code>@a</code>：播放宏 a</li></ul><h2 id="9-编辑特殊文件"><a href="#9-编辑特殊文件" class="headerlink" title="9. 编辑特殊文件"></a>9. 编辑特殊文件</h2><h3 id="9-1-文件加解密"><a href="#9-1-文件加解密" class="headerlink" title="9.1 文件加解密"></a>9.1 文件加解密</h3><ul><li><code>vim -x file</code> : 开始编辑一个加密的文件。</li><li><code>:X</code> – 为当前文件设置密码。</li><li><code>:set key=</code> – 去除文件的密码。</li></ul><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hZG1pbi92aW0tcXVpY2stZWRpdC5odG1s" title="http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html">这里是<i class="fa fa-external-link"></i></span> 滇狐总结的比较高级的 vi 技巧。</p><h3 id="9-2-文件的编码"><a href="#9-2-文件的编码" class="headerlink" title="9.2 文件的编码"></a>9.2 文件的编码</h3><ul><li><code>:e ++enc=utf8 filename</code>, 让 vim 用 utf-8 的编码打开这个文件。</li><li><code>:w ++enc=gbk</code>，不管当前文件什么编码，把它转存成 gbk 编码。</li><li><code>:set fenc 或 :set fileencoding</code>，查看当前文件的编码。</li><li>在 vimrc 中添加 <code>set fileencoding=ucs-bom,utf-8,cp936</code>，vim 会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936 对应于 gbk 编码。 ucs-bom 对应于 windows 下的文件格式。</li></ul><p>让 vim 正确处理文件格式和文件编码，有赖于 <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hZG1pbi92aW1yYy5odG1s" title="http://www.cnblogs.com/jiqingwu/admin/vimrc.html">~/.vimrc的正确配置<i class="fa fa-external-link"></i></span></p><h3 id="9-3-文件格式"><a href="#9-3-文件格式" class="headerlink" title="9.3 文件格式"></a>9.3 文件格式</h3><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p><ul><li><code>:e ++ff=dos filename</code>, 让 vim 用 dos 格式打开这个文件。</li><li><code>:w ++ff=mac filename</code>, 以 mac 格式存储这个文件。</li><li><code>:set ff</code>，显示当前文件的格式。</li><li>在 vimrc 中添加 <code>set fileformats=unix,dos,mac</code>，让 vim 自动识别文件格式。</li></ul><h2 id="10-编程辅助"><a href="#10-编程辅助" class="headerlink" title="10. 编程辅助"></a>10. 编程辅助</h2><h3 id="10-1-一些按键"><a href="#10-1-一些按键" class="headerlink" title="10.1 一些按键"></a>10.1 一些按键</h3><ul><li><code>gd</code> : 跳转到局部变量的定义处；</li><li><code>gD</code> : 跳转到全局变量的定义处，从当前文件开头开始搜索；</li><li><code>g;</code> : 上一个修改过的地方；</li><li><code>g,</code> : 下一个修改过的地方；</li><li><code>[[</code> : 跳转到上一个函数块开始，需要有单独一行的 {。</li><li><code>]]</code> : 跳转到下一个函数块开始，需要有单独一行的 {。</li><li><code>[]</code> : 跳转到上一个函数块结束，需要有单独一行的 }。</li><li><code>][</code> : 跳转到下一个函数块结束，需要有单独一行的 }。</li><li><code>[{</code> : 跳转到当前块开始处；</li><li><code>]}</code> : 跳转到当前块结束处；</li><li><code>[/</code> : 跳转到当前注释块开始处；</li><li><code>]/</code> : 跳转到当前注释块结束处；</li><li><code>%</code> : 不仅能移动到匹配的 <code>(),{} 或 []</code>上，而且能在 <code>#if，#else， #endif</code> 之间跳跃。</li></ul><p>下面的括号匹配对编程很实用的。</p><ul><li><code>ci&#39;, di&#39;, yi&#39;</code>：修改、剪切或复制 <code>&#39;</code> 之间的内容。</li><li><code>ca&#39;, da&#39;, ya&#39;</code>：修改、剪切或复制 <code>&#39;</code> 之间的内容，包含 <code>&#39;</code>。</li><li><code>ci&quot;, di&quot;, yi&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容。</li><li><code>ca&quot;, da&quot;, ya&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容，包含 <code>&quot;</code>。</li><li><code>ci(, di(, yi(</code>：修改、剪切或复制 <code>()</code>之间的内容。</li><li><code>ca(, da(, ya(</code>：修改、剪切或复制 <code>()</code> 之间的内容，包含 <code>()</code>。</li><li><code>ci[, di[, yi[</code>：修改、剪切或复制 <code>[]</code> 之间的内容。</li><li><code>ca[, da[, ya[</code>：修改、剪切或复制 <code>[]</code>之间的内容，包含 <code>[]</code>。</li><li><code>ci{, di{, yi{</code>：修改、剪切或复制 <code>{}</code> 之间的内容。</li><li><code>ca{, da{, ya{</code>：修改、剪切或复制 <code>{}</code> 之间的内容，包含 <code>{}</code>。</li><li><code>ci&lt;, di&lt;, yi&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容。</li><li><code>ca&lt;, da&lt;, ya&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容，包含<code>&lt;&gt;</code>。</li></ul><h3 id="10-2-ctags"><a href="#10-2-ctags" class="headerlink" title="10.2 ctags"></a>10.2 ctags</h3><table><thead><tr><th align="left"><code>Ctrl + ]</code></th><th>找到光标所在位置的标签定义的地方</th></tr></thead><tbody><tr><td align="left"><code>Ctrl + t</code></td><td>回到跳转之前的标签处</td></tr><tr><td align="left"><code>Ctrl + o</code></td><td>退回原来的地方</td></tr><tr><td align="left"><code>[I</code></td><td>查找全局标识符. Vim会列出它所找出的匹配行，<br>不仅在当前文件内查找，还会在所有的包含文件中查找</td></tr><tr><td align="left"><code>[i</code></td><td>从当前文件起始位置开始查找第一处包含光标所指关键字的位置</td></tr><tr><td align="left"><code>]i</code></td><td>类似上面的 <code>[i</code>，但这里是从光标当前位置开始往下搜索</td></tr><tr><td align="left"><code>[{</code></td><td>转到上一个位于第一列的”{“。（前提是 “{” 和 “}” 都在第一列。）</td></tr><tr><td align="left"><code>]}</code></td><td>转到下一个位于第一列的”}”</td></tr><tr><td align="left"><code>Ctrl+＼+ s</code></td><td>会出现所有调用、定义该函数的地方，输入索引号，回车即可</td></tr><tr><td align="left"><code>[ + ctrl + i</code></td><td>跳转到函数、变量和 <code>#define</code>   用 <code>ctrl+o</code> 返回</td></tr><tr><td align="left"><code>[ + ctrl + d</code></td><td>跳转到 <code>#define</code> 处用 <code>ctrl+o</code> 返回</td></tr></tbody></table><ul><li><code>ctags -R</code> : 生成 tag 文件，<code>-R</code> 表示也为子目录中的文件生成 tags</li><li><code>:set tags=path/tags</code> – 告诉 ctags 使用哪个 tag 文件</li><li><code>:tag xyz</code> – 跳到 xyz 的定义处，或者将光标放在 xyz 上按 <code>C-]</code>，返回用 <code>C-t</code></li><li><code>:stag xyz</code> – 用分割的窗口显示 xyz 的定义，或者 <code>C-w ]</code>， 如果用 <code>C-w n ]</code>，就会打开一个 n 行高的窗口</li><li><code>:ptag xyz</code> – 在预览窗口中打开 xyz 的定义，热键是 <code>C-w }</code>。</li><li><code>:pclose</code> – 关闭预览窗口。热键是 <code>C-w z</code>。</li><li><code>:pedit abc.h</code> – 在预览窗口中编辑 abc.h</li><li><code>:psearch abc</code> – 搜索当前文件和当前文件 include 的文件，显示包含 abc 的行。</li></ul><p>有时一个 tag 可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p><ul><li><code>:[n]tnext</code> – 下一 <code>[n]</code> 个匹配。</li><li><code>:[n]tprev</code> – 上一 <code>[n]</code>个匹配。</li><li><code>:tfirst</code> – 第一个匹配</li><li><code>:tlast</code> – 最后一个匹配</li><li><code>:tselect tagname</code> – 打开选择列表</li></ul><p>tab 键补齐</p><ul><li><code>:tag xyz&lt;tab&gt;</code> – 补齐以 xyz 开头的 tag 名，继续按 tab 键，会显示其他的。</li><li><code>:tag /xyz&lt;tab&gt;</code> – 会用名字中含有 xyz 的 tag 名补全。</li></ul><p><strong>ctags 对 c++ 生成 tags</strong> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q</span><br></pre></td></tr></table></figure><p>每个参数解释如下：</p><ul><li><p><code>-R</code> : ctags 循环生成子目录的 tags</p></li><li><p><code>--c++-kinds=+px</code> : ctags 记录 c++ 文件中的函数声明和各种外部和前向声明</p></li><li><p><code>--fields=+iaS</code> : ctags 要求描述的信息</p><ul><li>其中 <code>i</code> 表示如果有继承，则标识出父类；</li><li><code>a</code> 表示如果元素是类成员的话，要标明其调用权限（即是 public 还是 private）；</li><li><code>S</code> 表示如果是函数，则标识函数的 signature。</li></ul></li><li><p><code>--extra=+q</code> : 强制要求 ctags 做如下操作—如果某个语法元素是类的一个成员，ctags 默认会给其记录一行，可以要求 ctags 对同一个语法元斯屹记一行，这样可以保证在 VIM 中多个同名函数可以通过路径不同来区分。</p></li></ul><h3 id="10-3-cscope"><a href="#10-3-cscope" class="headerlink" title="10.3 cscope"></a>10.3 cscope</h3><p>查看阅读 c++ 代码</p><p>cscope 缺省只解析 C 文件 (<code>.c</code> 和 <code>.h</code>)、lex 文件( <code>.l</code> )和 yacc 文件( <code>.y</code> )，虽然它也可以支持 C++ 以及 Java，但它在扫描目录时会跳过 C++ 及  Java 后缀的文件。如果希望 <code>cscope</code> 解析 C++ 或 Java 文件，需要把这些文件的名字和路径保存在一个名为 cscope.files 的文件。当 cscope 发现在当前目录中存在 cscope.files 时，就会为 cscope.files 中列出的所有文件生成索引数据库。</p><p>下面的命令会查找当前目录及子目录中所有后缀名为 <code>&quot;.h&quot;, &quot;.c&quot;, &quot;cc&quot;</code> 和 <code>&quot;.cpp&quot;</code> 的文件，并把查找结果重定向到文件 cscope.files 中。然后 cscope 根据 cscope.files 中的所有文件，生成符号索引文件。最后一条命令使用 ctags 命令，生成一个 tags 文件，在 vim 中执行 <code>&quot;:help tags&quot;</code> 命令查询它的用法。它可以和 cscope 一起使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"*.h"</span> -o -name <span class="string">"*.c"</span> -o -name <span class="string">"*.cc"</span> -o <span class="string">"*.cpp"</span> &gt; cscope.files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cscope -bkq -i cscope.files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ctags -R</span></span><br></pre></td></tr></table></figure><p>​    </p><ul><li><code>cscope -Rbq</code> : 生成 cscope.out 文件</li><li><code>:cs add /path/to/cscope.out /your/work/dir</code></li><li><code>:cs find c func</code> – 查找 func 在哪些地方被调用<ul><li>s: 查找 C 语言符号，即查找函数名、宏、枚举值等出现的地方</li><li>g: 查找函数、宏、枚举等定义的位置，类似 ctags 所提供的功能</li><li>d: 查找本函数调用的函数</li><li>c: 查找调用本函数的函数</li><li>t: 查找指定的字符串</li><li>e: 查找 egrep 模式，相当于 egrep 功能，但查找速度快多了</li><li>f: 查找并打开文件，类似 vim 的 find 功能</li><li>i: 查找包含本文件的文件</li></ul></li><li><code>:cw</code> – 打开 quickfix 窗口查看结果</li></ul><h3 id="10-4-gtags"><a href="#10-4-gtags" class="headerlink" title="10.4 gtags"></a>10.4 gtags</h3><p>Gtags 综合了 ctags 和 cscope 的功能。 使用 Gtags 之前，你需要安装 GNU Gtags。 然后在工程目录运行 gtags 。</p><ul><li><code>:Gtags funcname</code> 定位到 funcname 的定义处。</li><li><code>:Gtags -r funcname</code> 查询 funcname被引用的地方。</li><li><code>:Gtags -s symbol</code> 定位 symbol 出现的地方。</li><li><code>:Gtags -g string</code> Goto string 出现的地方。 <code>:Gtags -gi string</code> 忽略大小写。</li><li><code>:Gtags -f filename</code> 显示 filename 中的函数列表。 你可以用 <code>:Gtags -f %</code> 显示当前文件。</li><li><code>:Gtags -P pattern</code> 显示路径中包含特定模式的文件。 如 <code>:Gtags -P .h$</code> 显示所有头文件， <code>:Gtags -P /vm/</code> 显示 vm 目录下的文件。</li></ul><h3 id="10-5-编译"><a href="#10-5-编译" class="headerlink" title="10.5 编译"></a>10.5 编译</h3><p>vim 提供了 <code>:make</code> 来编译程序，默认调用的是 make， 如果你当前目录下有 makefile，简单地 <code>:make</code> 即可。</p><p>如果你没有 make 程序，你可以通过配置 makeprg 选项来更改 make 调用的程序。 如果你只有一个 abc.java 文件，你可以这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set makeprg=javac\ abc.java</span><br></pre></td></tr></table></figure><p>然后 <code>:make</code> 即可。如果程序有错，可以通过 quickfix 窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让 vim 识别错误信息。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure><p><code>%f</code> 表示文件名，<code>%l</code> 表示行号， <code>%m</code> 表示错误信息，其它的还不能理解。 请参考 <code>:help errorformat</code>。</p><h3 id="10-6-快速修改窗口"><a href="#10-6-快速修改窗口" class="headerlink" title="10.6 快速修改窗口"></a>10.6 快速修改窗口</h3><p>其实是 quickfix 插件提供的功能， 对编译调试程序非常有用 </p><ul><li><code>:copen</code> – 打开快速修改窗口。</li><li><code>:cclose</code> – 关闭快速修改窗口。</li></ul><p>快速修改窗口在 make 程序时非常有用，当 make 之后：</p><ul><li><code>:cl</code> – 在快速修改窗口中列出错误。</li><li><code>:cn</code> – 定位到下一个错误。</li><li><code>:cp</code> – 定位到上一个错误。</li><li><code>:cr</code> – 定位到第一个错误。</li></ul><h3 id="10-7-自动补全"><a href="#10-7-自动补全" class="headerlink" title="10.7 自动补全"></a>10.7 自动补全</h3><ul><li><code>C-x C-s</code> – 拼写建议。</li><li><code>C-x C-v</code> – 补全 vim 选项和命令。</li><li><code>C-x C-l</code> – 整行补全。</li><li><code>C-x C-f</code> – 自动补全文件路径。弹出菜单后，按 <code>C-f</code> 循环选择，当然也可以按 <code>C-n 和 C-p</code>。</li><li><code>C-x C-p 和C-x C-n</code> – 用文档中出现过的单词补全当前的词。 直接按 <code>C-p 和 C-n</code>也可以。</li><li><code>C-x C-o</code> – 编程时可以补全关键字和函数名啊。</li><li><code>C-x C-i</code> – 根据头文件内关键字补全。</li><li><code>C-x C-d</code> – 补全宏定义。</li><li><code>C-x C-n</code> – 按缓冲区中出现过的关键字补全。 直接按 <code>C-n 或 C-p</code> 即可。</li></ul><p>当弹出补全菜单后：</p><ul><li><code>C-p</code> 向前切换成员；</li><li><code>C-n</code> 向后切换成员；</li><li><code>C-e</code> 退出下拉菜单，并退回到原来录入的文字；</li><li><code>C-y</code> 退出下拉菜单，并接受当前选项。</li></ul><h3 id="10-8-多行缩进缩出"><a href="#10-8-多行缩进缩出" class="headerlink" title="10.8 多行缩进缩出"></a>10.8 多行缩进缩出</h3><ul><li>正常模式下，按两下 <code>&gt;;</code> 光标所在行会缩进。</li><li>如果先按了 n，再按两下 <code>&gt;;</code>，光标以下的 n 行会缩进。</li><li>对应的，按两下 <code>&lt;;</code>，光标所在行会缩出。</li><li>如果在编辑代码文件，可以用 <code>=</code> 进行调整。</li><li>在可视模式下，选择要调整的代码块，按 <code>=</code>，代码会按书写规则缩排好。</li><li>或者 <code>n =</code>，调整 n 行代码的缩排。</li></ul><h3 id="10-9-折叠"><a href="#10-9-折叠" class="headerlink" title="10.9 折叠"></a>10.9 折叠</h3><ul><li><code>zf</code> – 创建折叠的命令，可以在一个可视区域上使用该命令；</li><li><code>zd</code> – 删除当前行的折叠；</li><li><code>zD</code> – 删除当前行的折叠；</li><li><code>zfap</code> – 折叠光标所在的段；</li><li><code>zo</code> – 打开折叠的文本；</li><li><code>zc</code> – 收起折叠；</li><li><code>za</code> – 打开/关闭当前折叠；</li><li><code>zr</code> – 打开嵌套的折行；</li><li><code>zm</code> – 收起嵌套的折行；</li><li><code>zR (zO)</code> – 打开所有折行；</li><li><code>zM (zC)</code> – 收起所有折行；</li><li><code>zj</code> – 跳到下一个折叠处；</li><li><code>zk</code> – 跳到上一个折叠处；</li><li><code>zi -- enable/disable fold</code>;</li></ul><h2 id="11-其它"><a href="#11-其它" class="headerlink" title="11. 其它"></a>11. 其它</h2><h3 id="11-1-工作目录"><a href="#11-1-工作目录" class="headerlink" title="11.1 工作目录"></a>11.1 工作目录</h3><ul><li><code>:pwd</code> 显示vim的工作目录。</li><li><code>:cd path</code> 改变 vim 的工作目录。</li><li><code>:set autochdir</code>  可以让 vim 根据编辑的文件自动切换工作目录。</li></ul><h3 id="11-2-一些快捷键（收集中）"><a href="#11-2-一些快捷键（收集中）" class="headerlink" title="11.2 一些快捷键（收集中）"></a>11.2 一些快捷键（收集中）</h3><ul><li><code>K</code> : 打开光标所在词的 manpage。</li><li><code>*</code> : 向下搜索光标所在词。</li><li><code>g*</code> : 同上，但部分符合即可。</li><li><code>\#</code> : 向上搜索光标所在词。</li><li><code>g#</code> : 同上，但部分符合即可。</li><li><code>g C-g</code> : 统计全文或统计部分的字数。</li></ul><h3 id="11-3-在线帮助"><a href="#11-3-在线帮助" class="headerlink" title="11.3 在线帮助"></a>11.3 在线帮助</h3><ul><li><code>:h(elp) 或 F1</code> 打开总的帮助。</li><li><code>:help user-manual</code> 打开用户手册。</li><li>命令帮助的格式为<code>：</code>第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li><li><code>:helptags somepath</code> 为 somepath 中的文档生成索引。</li><li><code>:helpgrep</code> 可以搜索整个帮助文档，匹配的列表显示在 quickfix 窗口中。</li><li><code>Ctrl+]</code> 跳转到 tag 主题，<code>Ctrl+t</code> 跳回。</li><li><code>:ver</code> 显示版本信息。</li></ul><p>高亮所有搜索模式匹配</p><ul><li><p><code>shift + *</code> 向后搜索光标所在位置的单词</p></li><li><p><code>shift + #</code> 向前搜索光标所在位置的单词</p></li><li><p>n 和 N 可以继续向后或者向前搜索匹配的字符串</p></li><li><p><code>:set hlsearch</code>  高亮所有匹配的字符串</p></li><li><p><code>:nohlsearch</code> 临时关闭</p></li><li><p><code>:set nohlsearch</code> 彻底关闭，只有重新 <code>:set hlsearch</code> 才可以高亮搜索</p></li><li><p>vim 高亮显示光标所在的单词，在单词的地方输入 <code>gd</code></p></li></ul><p>语法高亮</p><ul><li><p>syntax on</p></li><li><p>syntax off</p></li></ul><p>vim自动补全</p><ul><li><code>ctrl + n</code> 或者 <code>ctrl + p</code></li></ul><p>复制 vim 文件中所有内容</p><ul><li><p><code>gg</code> 回到文件首</p></li><li><p><code>shift + v</code> 进入 VISUAL LINE 模式</p></li><li><p><code>shift + g</code>  全选所有内容</p></li><li><p><code>ctrl + insert</code> 复制所选的内容</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamlxaW5nd3UvYXJjaGl2ZS8yMDEyLzA2LzE0L3ZpbV9ub3Rlcy5odG1s&quot; title=&quot;https://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html&quot;&gt;Vim使用笔记&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-文档操作&quot;&gt;&lt;a href=&quot;#1-文档操作&quot; class=&quot;headerlink&quot; title=&quot;1. 文档操作&quot;&gt;&lt;/a&gt;1. 文档操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:e&lt;/code&gt; – 重新加载当前文档。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e!&lt;/code&gt; – 重新加载当前文档，并丢弃已做的改动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e file&lt;/code&gt; – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e! file&lt;/code&gt; – 放弃对当前文件的修改，编辑新的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e# 或 ctrl+^&lt;/code&gt; – 回到刚才编辑的文件，很实用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gf&lt;/code&gt; – 打开以光标所在字符串为文件名的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:saveas newfilename&lt;/code&gt; – 另存为&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://miaopei.github.io/categories/Vim/"/>
    
    
      <category term="vim" scheme="http://miaopei.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket教程</title>
    <link href="http://miaopei.github.io/2017/05/16/WebSocket%E6%95%99%E7%A8%8B/"/>
    <id>http://miaopei.github.io/2017/05/16/WebSocket教程/</id>
    <published>2017-05-16T06:15:08.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<p>转自<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDUvd2Vic29ja2V0Lmh0bWw=" title="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰网络编程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3dlYnNvY2tldC5vcmcv" title="http://websocket.org/">WebSocket<i class="fa fa-external-link"></i></span> 是一种网络通信协议，很多高级功能都需要它。</p><h2 id="为什么需要-WebSocker"><a href="#为什么需要-WebSocker" class="headerlink" title="为什么需要 WebSocker"></a>为什么需要 WebSocker</h2><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><a id="more"></a><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p><img src="http://i.imgur.com/5mUfWtm.jpg" alt></p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<span class="exturl" data-url="aHR0cHM6Ly93d3cucHVibnViLmNvbS9ibG9nLzIwMTQtMTItMDEtaHR0cC1sb25nLXBvbGxpbmcv" title="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”<i class="fa fa-external-link"></i></span>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVzaF90ZWNobm9sb2d5" title="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术<i class="fa fa-external-link"></i></span>的一种。</p><p><img src="http://i.imgur.com/Qutxs2j.png" alt></p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是 <code>ws</code>（如果加密，则为 <code>wss</code> ），服务器网址就是 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/UWC2xr3.jpg" alt></p><h2 id="客户端的简单示例"><a href="#客户端的简单示例" class="headerlink" title="客户端的简单示例"></a>客户端的简单示例</h2><p>WebSocket 的用法相当简单。</p><p>下面是一个网页脚本的例子（点击<span class="exturl" data-url="aHR0cDovL2pzYmluLmNvbS9tdXFhbWlxaW11L2VkaXQ/anMsY29uc29sZQ==" title="http://jsbin.com/muqamiqimu/edit?js,console">这里<i class="fa fa-external-link"></i></span>看运行结果），基本上一眼就能明白。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>); </span><br><span class="line">  ws.send(<span class="string">"Hello WebSockets!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"Received Message: "</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="客户端的-API"><a href="#客户端的-API" class="headerlink" title="客户端的 API"></a>客户端的 API</h2><p>WebSocket 客户端的 API 如下。</p><h3 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。</p><p>实例对象的所有属性和方法清单，参见<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldA==" title="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">这里<i class="fa fa-external-link"></i></span>。</p><h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p><code>readyState</code> 属性返回实例对象的当前状态，共有四种。</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><p>下面是一个示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的 <code>onopen</code> 属性，用于指定连接成功后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要指定多个回调函数，可以使用addEventListener`方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h3><p>实例对象的 <code>onmessage</code> 属性，用于指定收到服务器数据后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，服务器数据可能是文本，也可能是二进制数据（ <code>blob</code> 对象或 <code>Arraybuffer</code> 对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received data string"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received arraybuffer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"blob"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send( )"></a>webSocket.send( )</h3><p>实例对象的 <code>send( )</code> 方法用于向服务器发送数据。</p><p>发送文本的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">'your message'</span>);</span><br></pre></td></tr></table></figure><p>发送 Blob 对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">'input[type="file"]'</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure><p>发送 ArrayBuffer 对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure><h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的 <code>bufferedAmount</code> 属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>WebSocket 服务器的实现，可以查看维基百科的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcGFyaXNvbl9vZl9XZWJTb2NrZXRfaW1wbGVtZW50YXRpb25z" title="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">列表<i class="fa fa-external-link"></i></span>。</p><p>常用的 Node 实现有以下三种。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VXZWJTb2NrZXRzL3VXZWJTb2NrZXRz" title="https://github.com/uWebSockets/uWebSockets">µWebSockets<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvY2tldC5pby8=" title="http://socket.io/">Socket.IO<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2Rl" title="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node<i class="fa fa-external-link"></i></span></li></ul><p>具体的用法请查看它们的文档，这里不详细介绍了。</p><h2 id="WebSocketd"><a href="#WebSocketd" class="headerlink" title="WebSocketd"></a>WebSocketd</h2><p>下面，我要推荐一款非常特别的 WebSocket 服务器：<span class="exturl" data-url="aHR0cDovL3dlYnNvY2tldGQuY29tLw==" title="http://websocketd.com/">Websocketd<i class="fa fa-external-link"></i></span>。</p><p>它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。</p><p><img src="http://i.imgur.com/a51CR69.png" alt></p><p>举例来说，下面是一个 Bash 脚本 <code>counter.sh</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 2</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 3</span><br></pre></td></tr></table></figure><p>命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bash ./counter.sh</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>现在，启动<code>websocketd</code>，指定这个脚本作为服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 bash ./counter.sh</span><br></pre></td></tr></table></figure><p>上面的命令会启动一个 WebSocket 服务器，端口是 <code>8080</code> 。每当客户端连接这个服务器，就会执行 <code>counter.sh</code> 脚本，并将它的输出推送给客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/'</span>);</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。</p><p>有了它，就可以很方便地将命令行的输出，发给浏览器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 ls</span><br></pre></td></tr></table></figure><p>上面的命令会执行<code>ls</code>命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWItdm1zdGF0cw==" title="https://github.com/joewalnes/web-vmstats">代码<i class="fa fa-external-link"></i></span>）。</p><p><img src="http://i.imgur.com/WMUStsh.jpg" alt></p><p>更多的用法可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL3RyZWUvbWFzdGVyL2V4YW1wbGVzL2Jhc2g=" title="https://github.com/joewalnes/websocketd/tree/master/examples/bash">官方示例<i class="fa fa-external-link"></i></span>。</p><ul><li>Bash 脚本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2Jhc2gvZ3JlZXRlci5zaA==" title="https://github.com/joewalnes/websocketd/blob/master/examples/bash/greeter.sh">读取客户端输入<i class="fa fa-external-link"></i></span>的例子</li><li>五行代码实现一个最简单的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2Jhc2gvY2hhdC5zaA==" title="https://github.com/joewalnes/websocketd/blob/master/examples/bash/chat.sh">聊天服务器<i class="fa fa-external-link"></i></span></li></ul><p><img src="http://i.imgur.com/KfZKSmD.png" alt></p><p>websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL25vZGVqcy9ncmVldGVyLmpz" title="https://github.com/joewalnes/websocketd/blob/master/examples/nodejs/greeter.js"><code>greeter.js</code><i class="fa fa-external-link"></i></span>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">'data: '</span> + chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动这个脚本的命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 node ./greeter.js</span><br></pre></td></tr></table></figure><p>官方仓库还有其他<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL3RyZWUvbWFzdGVyL2V4YW1wbGVz" title="https://github.com/joewalnes/websocketd/tree/master/examples">各种语言<i class="fa fa-external-link"></i></span>的例子。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><span class="exturl" data-url="aHR0cDovL2NqaWhyaWcuY29tL2Jsb2cvaG93LXRvLXVzZS13ZWJzb2NrZXRzLw==" title="http://cjihrig.com/blog/how-to-use-websockets/">How to Use WebSockets<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL3dlYnNvY2tldHMvd2Vic29ja2V0c19zZW5kX3JlY2VpdmVfbWVzc2FnZXMuaHRt" title="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">WebSockets - Send &amp; Receive Messages<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL3dlYnNvY2tldHMvYmFzaWNzLw==" title="https://www.html5rocks.com/en/tutorials/websockets/basics/">Introducing WebSockets: Bringing Sockets to the Web<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDUvd2Vic29ja2V0Lmh0bWw=&quot; title=&quot;http://www.ruanyifeng.com/blog/2017/05/websocket.html&quot;&gt;阮一峰网络编程&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3dlYnNvY2tldC5vcmcv&quot; title=&quot;http://websocket.org/&quot;&gt;WebSocket&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt; 是一种网络通信协议，很多高级功能都需要它。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要-WebSocker&quot;&gt;&lt;a href=&quot;#为什么需要-WebSocker&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 WebSocker&quot;&gt;&lt;/a&gt;为什么需要 WebSocker&lt;/h2&gt;&lt;p&gt;初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://miaopei.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="WebSocket" scheme="http://miaopei.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>定制支持串口安装的ubuntu系统镜像</title>
    <link href="http://miaopei.github.io/2017/05/15/%E5%AE%9A%E5%88%B6%E6%94%AF%E6%8C%81%E4%B8%B2%E5%8F%A3%E5%AE%89%E8%A3%85%E7%9A%84ubuntu%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/"/>
    <id>http://miaopei.github.io/2017/05/15/定制支持串口安装的ubuntu系统镜像/</id>
    <published>2017-05-15T07:48:06.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、所需环境："><a href="#1、所需环境：" class="headerlink" title="1、所需环境："></a>1、所需环境：</h2><p><strong>硬件环境：</strong></p><ul><li>笔记本</li><li>串口调试线缆</li><li>光盘</li><li>显示器</li><li>FWA产品的任一机型（此次使用的是FWA-4210）</li><li>SATA或者USB光驱×1</li></ul><a id="more"></a><p><strong>软件环境：</strong></p><ul><li>带有genisoimage(旧版是mkisofs)的linux发行版（此次使用的是Ubuntu 16.04 server版）</li><li>Ubuntu官网通用镜像ISO文件</li></ul><h2 id="2、操作过程："><a href="#2、操作过程：" class="headerlink" title="2、操作过程："></a>2、操作过程：</h2><h3 id="2-1-开机进入系统，将光盘挂载到Ubuntu系统"><a href="#2-1-开机进入系统，将光盘挂载到Ubuntu系统" class="headerlink" title="2.1 开机进入系统，将光盘挂载到Ubuntu系统"></a>2.1 开机进入系统，将光盘挂载到Ubuntu系统</h3><p>CLI命令如下；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -o loop ubuntu-16.04.2-server-amd64.iso /mnt/temp</span><br></pre></td></tr></table></figure><h3 id="2-2-更改配置"><a href="#2-2-更改配置" class="headerlink" title="2.2 更改配置"></a>2.2 更改配置</h3><p>相关配置文件（menu.cfg、txt.cfg、isolinux.cfg此文件不是必须要修改，具体见下边解释）。将光盘文件，拷贝到临时目录（家目录或者自己新建目录均可，但建议拷贝到/var或/temp目录下），具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -rf /mnt/temp/ /var/mycdrom</span><br></pre></td></tr></table></figure><p>因为 <code>/mnt</code> 目录的默认权限是 <code>333</code> ，所以在此使用 <code>-r</code> 和 <code>-f</code> 参数，<code>-r</code> 代表递归，即文件夹下所有文件都拷贝，<code>-f</code> 代表强制执行；</p><p>更改 <code>menu.cfg</code> 文件，如下图，主要是注释掉标准安装的配置文件，以便可以定制安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/mycdrom/temp/isolinux</span><br><span class="line"></span><br><span class="line">$ vi menu.cfg</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><blockquote><p>vi有三种模式，普通模式、编辑模式、命令行模式；</p><p>I o a进入编辑模式，</p><p>普通模式下数字+yy复制</p><p>P黏贴</p><p>命令行模式：w写入，q离开，！强制执行</p></blockquote><p>注释 <code>menu.cfg</code> 内容如下红框所示：</p><p><img src="http://i.imgur.com/JM99sFZ.png" alt></p><p>更改 <code>txt.cfg</code> 文件，主要用于定制串口安装（如下图）：</p><p><img src="http://i.imgur.com/pA7ruhP.png" alt></p><p>更改 <code>isolinux.cfg</code> 文件，主要修改grub菜单等待时间（如下图），也可不修改；</p><p><img src="http://i.imgur.com/jE4zoMG.png" alt></p><h3 id="2-3-重新打包ISO文件"><a href="#2-3-重新打包ISO文件" class="headerlink" title="2.3 重新打包ISO文件"></a>2.3 重新打包ISO文件</h3><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ genisoimage -o ubuntu-16.04.2-server-adm64-console_115200.iso -r -J -no-emul-boot -boot-load-size 4 -boot-info-table -b isolinux/isolinux.bin -c isolinux/boot.cat /var/mycdrom/temp</span><br></pre></td></tr></table></figure><p><code>genisoimage</code> 是linux各大发行版制作ISO镜像比较流行的工具，若要定制系统，最好在linux下更改相关配置，并使用此工具重新打包；若在Windows平台使用UltraISO等工具解压更改重新打包会出现不稳定的情况（无法找到镜像，无法找到安装源等）。</p><ul><li><code>-o</code> ：是output缩写，用来指定输出镜像名称</li><li><code>-r</code> ： 即rational-rock，用来开放ISO文件所有权限（r、w、x） </li><li><code>-J</code> ： 即Joliet，一种ISO9600扩展格式，用来增加兼容性，最好加上</li><li><code>-no-emul-boot</code>  <code>-boot-load-size 4</code>  <code>-boot-info-table</code> ：指定兼容模式下虚拟扇区的数量，若不指定，有些BISO会出现一些问题</li><li><code>-b</code> ：指定开机映像文件</li><li><code>-c</code> ：具体开机配置文件</li><li>最后加上输出目录</li></ul><p>Reboot系统U盘启动，即可安装系统。</p><h2 id="3、文本安装系统注意事项"><a href="#3、文本安装系统注意事项" class="headerlink" title="3、文本安装系统注意事项"></a>3、文本安装系统注意事项</h2><h3 id="3-1-进入安装模式"><a href="#3-1-进入安装模式" class="headerlink" title="3.1 进入安装模式"></a>3.1 进入安装模式</h3><p>关闭系统插入U盘，启动系统，看到如下提示按F12进入安装系统模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Press  F12  for  boot  menu..</span><br></pre></td></tr></table></figure><p>选择U盘所在的选项。</p><h3 id="3-2-分区"><a href="#3-2-分区" class="headerlink" title="3.2 分区"></a>3.2 分区</h3><p>若是硬盘已有linux发行版系统，那在如下界面，必须umount分区，才能将更改写入分区表</p><h3 id="3-3-自动更新"><a href="#3-3-自动更新" class="headerlink" title="3.3 自动更新"></a>3.3 自动更新</h3><p>如下界面，若有特许需求（需要安装一些特许软件apache、weblogic等）可以选择自动更新（需要联网），一般情况不选则自动更新</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、所需环境：&quot;&gt;&lt;a href=&quot;#1、所需环境：&quot; class=&quot;headerlink&quot; title=&quot;1、所需环境：&quot;&gt;&lt;/a&gt;1、所需环境：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;硬件环境：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;笔记本&lt;/li&gt;
&lt;li&gt;串口调试线缆&lt;/li&gt;
&lt;li&gt;光盘&lt;/li&gt;
&lt;li&gt;显示器&lt;/li&gt;
&lt;li&gt;FWA产品的任一机型（此次使用的是FWA-4210）&lt;/li&gt;
&lt;li&gt;SATA或者USB光驱×1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="http://miaopei.github.io/categories/Ubuntu/"/>
    
    
      <category term="ubuntu" scheme="http://miaopei.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本攻略笔记</title>
    <link href="http://miaopei.github.io/2017/05/15/Shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://miaopei.github.io/2017/05/15/Shell脚本攻略笔记/</id>
    <published>2017-05-15T07:40:41.000Z</published>
    <updated>2019-06-03T08:50:47.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><h3 id="1-1-shell-格式输出"><a href="#1-1-shell-格式输出" class="headerlink" title="1.1 shell 格式输出"></a>1.1 shell 格式输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'Hello world !'</span></span><br><span class="line">-n<span class="comment"># 忽略结尾的换行符</span></span><br><span class="line">-e<span class="comment"># 激活转义字符</span></span><br><span class="line">-E<span class="comment"># disable转义字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>打印彩色输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 彩色文本</span></span><br><span class="line"><span class="comment"># 重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;31m This is red text \e[0m"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 彩色背景</span></span><br><span class="line"><span class="comment"># 重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;42m Green Background \e[0m"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4s\n"</span> No Name Mark</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p><code>%-5s</code> 指明了一个格式为左对齐且宽度为5的字符串替换（ <code>-</code>表示左对齐）。如果不用 <code>-</code> 指定对齐方式，字符串就采用右对齐形式。</p><p><code>%s</code> 、 <code>%c</code> 、<code>%d</code> 和 <code>%f</code> 都是格式替换符（format substitution character），其所对应的参数可以置于带引号的格式字符串之后。 </p><h3 id="1-2-替换命令-tr"><a href="#1-2-替换命令-tr" class="headerlink" title="1.2 替换命令 tr"></a>1.2 替换命令 tr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tr 是 translate的简写</span></span><br><span class="line">$ tr <span class="string">'\0'</span> <span class="string">'\n'</span><span class="comment"># 将 \0 替换成 \n</span></span><br><span class="line">$ tr [选项]… 集合1 [集合2]</span><br><span class="line">选项说明：</span><br><span class="line">-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。</span><br><span class="line">-d, –delete 删除集合1中的字符而不是转换</span><br><span class="line">-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。</span><br><span class="line">-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符</span><br><span class="line"></span><br><span class="line">字符集合的范围：</span><br><span class="line">\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)</span><br><span class="line">\\ 反斜杠</span><br><span class="line">\a Ctrl-G 铃声</span><br><span class="line">\b Ctrl-H 退格符</span><br><span class="line">\f Ctrl-L 走行换页</span><br><span class="line">\n Ctrl-J 新行</span><br><span class="line">\r Ctrl-M 回车</span><br><span class="line">\t Ctrl-I tab键</span><br><span class="line">\v Ctrl-X 水平制表符</span><br><span class="line">CHAR1-CHAR2 从CHAR1 到 CHAR2的所有字符按照ASCII字符的顺序</span><br><span class="line">[CHAR*] <span class="keyword">in</span> SET2, copies of CHAR until length of SET1</span><br><span class="line">[CHAR*REPEAT] REPEAT copies of CHAR, REPEAT octal <span class="keyword">if</span> starting with 0</span><br><span class="line">[:alnum:] 所有的字母和数字</span><br><span class="line">[:alpha:] 所有字母</span><br><span class="line">[:blank:] 水平制表符，空白等</span><br><span class="line">[:cntrl:] 所有控制字符</span><br><span class="line">[:digit:] 所有的数字</span><br><span class="line">[:graph:] 所有可打印字符，不包括空格</span><br><span class="line">[:lower:] 所有的小写字符</span><br><span class="line">[:<span class="built_in">print</span>:] 所有可打印字符，包括空格</span><br><span class="line">[:punct:] 所有的标点字符</span><br><span class="line">[:space:] 所有的横向或纵向的空白</span><br><span class="line">[:upper:] 所有大写字母</span><br></pre></td></tr></table></figure><h3 id="1-3-打印变量"><a href="#1-3-打印变量" class="headerlink" title="1.3 打印变量"></a>1.3 打印变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ var=<span class="string">"value"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">或者</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-设置环境变量"><a href="#1-4-设置环境变量" class="headerlink" title="1.4 设置环境变量"></a>1.4 设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在PATH中添加一条新路径</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:/home/user/bin"</span></span><br><span class="line">也可以使用：</span><br><span class="line">$ PATH=<span class="string">"<span class="variable">$PATH</span>:/home/user/bin"</span></span><br><span class="line">$ <span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure><h3 id="1-5-Shell中三种引号的用法"><a href="#1-5-Shell中三种引号的用法" class="headerlink" title="1.5 Shell中三种引号的用法"></a>1.5 Shell中三种引号的用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="comment"># 使用单引号时，变量不会被扩展（expand），将依照原样显示。</span></span><br><span class="line">$ var=<span class="string">"123"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'$var'</span> will <span class="built_in">print</span> <span class="variable">$var</span></span><br><span class="line">结果为：<span class="string">'$var'</span> will <span class="built_in">print</span> 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="comment"># 输出引号中的内容，若存在命令、变量等，会先执行命令解析出结果再输出</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span> will <span class="built_in">print</span> <span class="variable">$var</span></span><br><span class="line">结果为：123 will <span class="built_in">print</span> 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反引号</span></span><br><span class="line"><span class="comment"># 命令替换</span></span><br><span class="line">$ var=`whoami`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">结果为：root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备注：反引号和$()作用相同</span></span><br></pre></td></tr></table></figure><h3 id="1-6-获得字符串的长度"><a href="#1-6-获得字符串的长度" class="headerlink" title="1.6 获得字符串的长度"></a>1.6 获得字符串的长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法</span></span><br><span class="line">$ length=<span class="variable">$&#123;#var&#125;</span></span><br><span class="line"></span><br><span class="line">$ var=12345678901234567890</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="1-7-识别当前shell"><a href="#1-7-识别当前shell" class="headerlink" title="1.7 识别当前shell"></a>1.7 识别当前shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">也可以使用：</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br></pre></td></tr></table></figure><h3 id="1-8-使用shell进行数学运算"><a href="#1-8-使用shell进行数学运算" class="headerlink" title="1.8 使用shell进行数学运算"></a>1.8 使用shell进行数学运算</h3><p>在Bash shell环境中，可以利用 <code>let</code>、<code>(( ))</code> 和<code>[]</code> 执行基本的算术操作。而在进行高级操作时，<code>expr</code> 和 <code>bc</code> 这两个工具也会非常有用。</p><p>使用 <code>let</code> 时，变量名之前不需要再添加 <code>$</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ no1=4</span><br><span class="line">$ <span class="built_in">let</span> no1++</span><br><span class="line">$ <span class="built_in">let</span> no1+=6<span class="comment"># 等同于let no=no+6</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 操作符[]的使用方法和let命令类似</span></span><br><span class="line">$ result=$[ no1 + no2 ]</span><br><span class="line"><span class="comment"># 在[]中也可以使用$前缀</span></span><br><span class="line">$ result=$[ <span class="variable">$no1</span> + 5 ]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用(())时，变量名之前需要加上$</span></span><br><span class="line">$ result=$(( no1 + 50 ))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># expr同样可以用于基本算术操作</span></span><br><span class="line">$ result=`expr 3 + 4`</span><br><span class="line">$ result=$(expr <span class="variable">$no1</span> + 5)</span><br></pre></td></tr></table></figure><p>bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项 。此处不多介绍。</p><h3 id="1-9-shell中各种括号的作用-、-、-、-、"><a href="#1-9-shell中各种括号的作用-、-、-、-、" class="headerlink" title="1.9 shell中各种括号的作用()、(())、[]、[[]]、{}"></a>1.9 shell中各种括号的作用()、(())、[]、[[]]、{}</h3><h4 id="1-9-1-小括号，圆括号（）"><a href="#1-9-1-小括号，圆括号（）" class="headerlink" title="1.9.1 小括号，圆括号（）"></a>1.9.1 小括号，圆括号（）</h4><p>1、单小括号 ( )</p><ul><li><strong>命令组。</strong>括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。</li><li><strong>命令替换。</strong>等同于<code>cmd</code>，shell扫描一遍命令行，发现了<code>$(cmd)结构</code> ，便将 <code>$(cmd)</code> 中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</li><li><strong>用于初始化数组。</strong>如：array=(a b c d)。</li></ul><p>2、双小括号 (( ))</p><ul><li><strong>整数扩展。</strong>这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。</li><li><strong>只要括号中的运算符、表达式符合C语言运算规则，都可用在 <code>$((exp))</code>中，甚至是三目运算符</strong>。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)。</li><li><strong>单纯用 (( )) 也可重定义变量值</strong>，比如 a=5; ((a++)) 可将 $a 重定义为6。</li><li><strong>常用于算术运算比较，双括号中的变量可以不使用<code>$</code> 符号前缀</strong>。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i&lt;5;i++)), 如果不使用双括号, 则为for i in <code>seq 0 4</code>或者for i in {0..4}。再如可以直接使用 <code>if (($i&lt;5))</code> , 如果不使用双括号, 则为 <code>if [ $i -lt 5 ]</code> 。</li></ul><h4 id="1-9-2-中括号，方括号"><a href="#1-9-2-中括号，方括号" class="headerlink" title="1.9.2 中括号，方括号[]"></a>1.9.2 中括号，方括号[]</h4><p>1、单中括号 []</p><ul><li>bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</li><li>Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</li><li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</li><li>在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</li></ul><p>2、双中括号 [[ ]]</p><ul><li>[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</li><li>支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</li><li>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用 <code>if [[ $a != 1 &amp;&amp; $a != 2 ]]</code> , 如果不适用双括号, 则为 <code>if [ $a -ne 1] &amp;&amp; [ $a != 2 ]</code>或者 <code>if [ $a -ne 1 -a $a != 2 ]</code> 。</li><li>bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</li></ul><h4 id="1-9-3-大括号、花括号"><a href="#1-9-3-大括号、花括号" class="headerlink" title="1.9.3 大括号、花括号 {}"></a>1.9.3 大括号、花括号 {}</h4><p>1）常规用法</p><ul><li>大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt</li><li>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</li></ul><p>2）几种特殊的替换结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var:-string&#125;</span>,<span class="variable">$&#123;var:+string&#125;</span>,<span class="variable">$&#123;var:=string&#125;</span>,<span class="variable">$&#123;var:?string&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>${var:-string}</code> 和 <code>${var:=string}:</code> 若变量var为空，则用在命令行中用string来替换 <code>${var:-string}</code>，否则变量var不为空时，则用变量var的值来替换 <code>${var:-string}</code> ；对于 <code>${var:=string}</code> 的替换规则和 <code>${var:-string}</code> 是一样的，所不同之处是 <code>${var:=string}</code> 若var为空时，用string替换 <code>${var:=string}</code> 的同时，把string赋给变量 <code>var： ${var:=string}</code> 很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</li><li><code>${var:+string}</code> 的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 。</li><li><code>${var:?string}</code> 替换规则为：若变量var不为空，则用变量var的值来替换 <code>${var:?string}</code> ；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。</li></ul><p>补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p><p>3）四种模式匹配替换结构</p><p>模式匹配记忆方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 是去掉左边(在键盘上#在$之左边)</span><br><span class="line">% 是去掉右边(在键盘上%在$之右边)</span><br><span class="line">#和%中的单一符号是最小匹配，两个相同符号是最大匹配。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var%pattern&#125;</span>,<span class="variable">$&#123;var%%pattern&#125;</span>,<span class="variable">$&#123;var#pattern&#125;</span>,<span class="variable">$&#123;var##pattern&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第一种模式：<code>${variable%pattern}</code> ，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式</li></ul><ul><li>第二种模式：<code>${variable%%pattern}</code>，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</li><li>第三种模式：<code>${variable#pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式</li><li>第四种模式：<code>${variable##pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</li></ul><p>这四种模式中都不会改变variable的值，其中，只有在pattern中使用了匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。</p><p>4）字符串提取和替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var:num&#125;</span>,<span class="variable">$&#123;var:num1:num2&#125;</span>,<span class="variable">$&#123;var/pattern/pattern&#125;</span>,<span class="variable">$&#123;var//pattern/pattern&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第一种模式：<code>${var:num}</code> ，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如 <code>${var: -2}</code> 、<code>${var:1-3}</code> 或 <code>${var:(-2)}</code>。         </li><li>第二种模式：<code>${var:num1:num2}</code>，num1是位置，num2是长度。表示从 <code>$var字符串的第$num1</code> 个位置开始提取长度为$num2的子串。不能为负数。</li><li>第三种模式：<code>${var/pattern/pattern}</code>表示将var字符串的第一个匹配的pattern替换为另一个pattern。。         </li><li>第四种模式：<code>${var//pattern/pattern}</code> 表示将var字符串中的所有能匹配的pattern替换为另一个pattern。</li></ul><h4 id="1-9-4-符号-后的括号"><a href="#1-9-4-符号-后的括号" class="headerlink" title="1.9.4 符号$后的括号"></a>1.9.4 符号$后的括号</h4><ul><li><code>${a}</code> 变量a的值, 在不引起歧义的情况下可以省略大括号。</li><li><code>$(cmd)</code>  命令替换，和<code>cmd</code>效果相同，结果为shell命令cmd的输，过某些Shell版本不支持 <code>$()</code> 形式的命令替换, 如tcsh。</li><li><code>$((expression))</code> 和<code>exprexpression</code>效果相同, 计算数学表达式exp的数值, 其中exp只要符合<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2M=" title="http://lib.csdn.net/base/c">C语言<i class="fa fa-external-link"></i></span>的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。</li></ul><h4 id="1-9-5-多条命令执行"><a href="#1-9-5-多条命令执行" class="headerlink" title="1.9.5 多条命令执行"></a>1.9.5 多条命令执行</h4><ul><li>单小括号，<code>(cmd1;cmd2;cmd3)</code>  新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。</li><li>单大括号，<code>{ cmd1;cmd2;cmd3;}</code>  在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。</li></ul><p>对 <code>{}</code> 和 <code>()</code> 而言, 括号中的重定向符只影响该条命令，而括号外的重定向符影响到括号中的所有命令。</p><h3 id="1-10-Shell特殊变量-0-和命令行参数"><a href="#1-10-Shell特殊变量-0-和命令行参数" class="headerlink" title="1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数"></a>1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数</h3><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名。</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n是一个数字，表示几个参数。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有采纳数。被双引号(“ “)包含是，与$* 稍有不同。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前shell进程ID。对于shell脚本，就是这个脚本所在的进程ID。</td></tr></tbody></table><h4 id="1-10-1-命令行参数"><a href="#1-10-1-命令行参数" class="headerlink" title="1.10.1 命令行参数"></a>1.10.1 命令行参数</h4><p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 <code>$n</code> 表示，例如，<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数，依次类推。</p><h4 id="1-10-2-和-的区别"><a href="#1-10-2-和-的区别" class="headerlink" title="1.10.2 $* 和 $@ 的区别"></a>1.10.2 <code>$*</code> 和 <code>$@</code> 的区别</h4><p><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</p><p>但是当它们被双引号(“ “)包含时，<code>&quot;$*&quot;</code> 会将所有的参数作为一个整体，以<code>&quot;$1 $2 … $n&quot;</code> 的形式输出所有参数；<code>&quot;$@&quot;</code> 会将各个参数分开，以 <code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code>的形式输出所有参数。</p><h4 id="1-10-3-退出状态"><a href="#1-10-3-退出状态" class="headerlink" title="1.10.3 退出状态"></a>1.10.3 退出状态</h4><p><code>$?</code> 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。</p><p>退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</p><p>不过，也有一些命令返回其他值，表示不同类型的错误。</p><p><code>$?</code> 也可以表示函数的返回值，此处不展开。</p><h3 id="1-11-Shell重定向"><a href="#1-11-Shell重定向" class="headerlink" title="1.11 Shell重定向"></a>1.11 Shell重定向</h3><p>1、重定向符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;               输出重定向到一个文件或设备 覆盖原来的文件</span><br><span class="line">&gt;!              输出重定向到一个文件或设备 强制覆盖原来的文件</span><br><span class="line">&gt;&gt;              输出重定向到一个文件或设备 追加原来的文件</span><br><span class="line">&lt;               输入重定向到一个程序</span><br></pre></td></tr></table></figure><p>2、标准输入刷出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 bash 命令执行的过程中，主要有三种输出入的状况，分别是：</span><br><span class="line">1. 标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt;</span><br><span class="line">2. 标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt;</span><br><span class="line">3. 错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt;</span><br></pre></td></tr></table></figure><p>3、使用实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。</span></span><br><span class="line"><span class="comment"># 1&gt;&amp;2 意思是把标准输出重定向到标准错误.</span></span><br><span class="line"><span class="comment"># 2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。</span></span><br><span class="line"><span class="comment"># &amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中</span></span><br><span class="line"></span><br><span class="line">$ cmd &lt;&gt; file<span class="comment"># 以读写方式打开文件 file</span></span><br><span class="line">$ cmd &gt;&amp;n<span class="comment"># 将 cmd 的输出发送到文件描述符 n</span></span><br><span class="line">$ cmd m&gt;&amp;n<span class="comment"># 将本该输出到文件描述符 m 的内容, 发送到文件描述符 n</span></span><br><span class="line">$ cmd m&lt;&amp;n <span class="comment"># 除了本该从文件描述符 m 处获取输入，改为从文件描述符 n 处获取</span></span><br><span class="line">$ cmd &gt;&amp;-<span class="comment"># 关闭标准输出</span></span><br><span class="line">$ cmd &lt;&amp;-<span class="comment"># 关闭标准输入</span></span><br><span class="line">$ cmd  &gt;&amp; file<span class="comment"># 将标准输出和标准错误都发送到文件 file </span></span><br><span class="line">$ cmd  &amp;&gt; file<span class="comment"># 作用同上, 更好的格式</span></span><br></pre></td></tr></table></figure><p>要在终端中打印stdout，同时将它重定向到一个文件中，那么可以这样使用tee 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法：command | tee FILE1 FILE2</span></span><br><span class="line">$ cat a* | tee out.txt | cat -n</span><br><span class="line"><span class="comment"># 默认情况下， tee命令会将文件覆盖，但它提供了一个-a选项，用于追加内容</span></span><br><span class="line">$ cat a* | tee -a out.txt | cat –n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以使用stdin作为命令参数。只需要将-作为命令的文件名参数即可</span></span><br><span class="line"><span class="comment"># 用法：$ cmd1 | cmd2 | cmd -</span></span><br><span class="line">$ <span class="built_in">echo</span> who is this | tee -</span><br></pre></td></tr></table></figure><h3 id="1-12-Shell数组和关联数组"><a href="#1-12-Shell数组和关联数组" class="headerlink" title="1.12 Shell数组和关联数组"></a>1.12 Shell数组和关联数组</h3><h4 id="1-12-1-简介"><a href="#1-12-1-简介" class="headerlink" title="1.12.1 简介"></a>1.12.1 简介</h4><p>数组是Shell脚本非常重要的组成部分，它借助索引将多个独立的独立的数据存储为一个集合。普通数组只能使用整数作为数组索引，关联数组不仅可以使用整数作为索引，也可以使用字符串作为索引。通常情况下，使用字符串做索引更容易被人们理解。Bash从4.0之后开始引入关联数组。</p><h4 id="1-12-2-定义打印普通数组"><a href="#1-12-2-定义打印普通数组" class="headerlink" title="1.12.2 定义打印普通数组"></a>1.12.2 定义打印普通数组</h4><p>数组的方法有如下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在一行上列出所有元素</span></span><br><span class="line">$ array_var=(1 2 3 4 5 6)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以“索引-值”的形式一一列出</span></span><br><span class="line">$ array_var[0]=<span class="string">"test1"</span></span><br><span class="line">$ array_var[1]=<span class="string">"test2"</span></span><br><span class="line">$ array_var[2]=<span class="string">"test3"</span></span><br></pre></td></tr></table></figure><p>注意：第一种方法要使用圆括号，否则后面会报错。</p><p>数组元素的方法有如下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[0]&#125;</span>         <span class="comment">#输出结果为 test1</span></span><br><span class="line">$ index=2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[$index]&#125;</span>    <span class="comment">#输出结果为 test3</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[*]&#125;</span>         <span class="comment">#输出所有数组元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[@]&#125;</span>         <span class="comment">#输出所有数组元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#array_var[*]&#125;</span>        <span class="comment">#输出值为 3</span></span><br></pre></td></tr></table></figure><p>注意：在ubuntu 14.04中，shell脚本要以#!/bin/bash开头，且执行脚本的方式为 bash test.sh。</p><h4 id="1-12-3-定义打印关联数组"><a href="#1-12-3-定义打印关联数组" class="headerlink" title="1.12.3 定义打印关联数组"></a>1.12.3 定义打印关联数组</h4><p>定义关联数组<br>在关联数组中，可以使用任何文本作为数组索引。定义关联数组时，首先需要使用声明语句将一个变量声明为关联数组，然后才可以在数组中添加元素，过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -A ass_array                           <span class="comment">#声明一个关联数组</span></span><br><span class="line">$ ass_array=([<span class="string">"index1"</span>]=index1 [<span class="string">"index2"</span>]=index2)<span class="comment">#内嵌“索引-值”列表法</span></span><br><span class="line">$ ass_array[<span class="string">"index3"</span>]=index3</span><br><span class="line">$ ass_array[<span class="string">"index4"</span>]=index4</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;ass_array["index1"]&#125;</span>                    <span class="comment">#输出为index1</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;ass_array["index4"]&#125;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[*]&#125;</span>                          <span class="comment">#输出索引列表</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[@]&#125;</span>                          <span class="comment">#输出索引列表</span></span><br></pre></td></tr></table></figure><p>注意：对于普通数组，使用上面的方法依然可以列出索引列表，在声明关联数组以及添加数组元素时，都不能在前面添加美元符$。</p><h3 id="1-13-使用别名"><a href="#1-13-使用别名" class="headerlink" title="1.13 使用别名"></a>1.13 使用别名</h3><p>alias命令的作用只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名设置一直保持作用，可以将它放入~/.bashrc文件中。因为每当一个新的shell进程生成时，都会执行 ~/.bashrc中的命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> install=<span class="string">'sudo apt-get install'</span></span><br></pre></td></tr></table></figure><h3 id="1-14-获取、设置日期和延时"><a href="#1-14-获取、设置日期和延时" class="headerlink" title="1.14 获取、设置日期和延时"></a>1.14 获取、设置日期和延时</h3><p>时间方面 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% : 印出</span><br><span class="line">% %n : 下一行</span><br><span class="line">%t : 跳格</span><br><span class="line">%H : 小时(00..23)</span><br><span class="line">%I : 小时(01..12)</span><br><span class="line">%k : 小时(0..23)</span><br><span class="line">%l : 小时(1..12)</span><br><span class="line">%M : 分钟(00..59)</span><br><span class="line">%p : 显示本地 AM 或 PM</span><br><span class="line">%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</span><br><span class="line">%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数 %S : 秒(00..61)</span><br><span class="line">%T : 直接显示时间 (24 小时制)</span><br><span class="line">%X : 相当于 %H:%M:%S</span><br><span class="line">%Z : 显示时区</span><br></pre></td></tr></table></figure><p>日期方面 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%a : 星期几 (Sun..Sat)</span><br><span class="line">%A : 星期几 (Sunday..Saturday)</span><br><span class="line"></span><br><span class="line">%b : 月份 (Jan..Dec)</span><br><span class="line">%B : 月份 (January..December)</span><br><span class="line"></span><br><span class="line">%y : 年份的最后两位数字 (00.99)</span><br><span class="line">%Y : 完整年份 (0000..9999)</span><br><span class="line"></span><br><span class="line">%c : 直接显示日期与时间</span><br><span class="line">%d : 日 (01..31)</span><br><span class="line">%D : 直接显示日期 (mm/dd/yy)</span><br><span class="line">%h : 同 %b</span><br><span class="line">%j : 一年中的第几天 (001..366)</span><br><span class="line">%m : 月份 (01..12)</span><br><span class="line">%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)</span><br><span class="line">%w : 一周中的第几天 (0..6)</span><br><span class="line">%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)</span><br><span class="line">%x : 直接显示日期 (mm/dd/yy)</span><br></pre></td></tr></table></figure><p>若是不以加号作为开头，则表示要设定时间，而时间格式为 <code>MMDDhhmm[[CC]YY][.ss]</code>，其中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MM 为月份，</span><br><span class="line">DD 为日，</span><br><span class="line">hh 为小时，</span><br><span class="line">mm 为分钟，</span><br><span class="line">CC 为年份前两位数字，</span><br><span class="line">YY 为年份后两位数字，</span><br><span class="line">ss 为秒数</span><br></pre></td></tr></table></figure><p>参数 :</p><p>-d datestr : 显示 datestr 中所设定的时间 (非系统时间)</p><p>–help : 显示辅助讯息</p><p>-s datestr : 将系统时间设为 datestr 中所设定的时间</p><p>-u : 显示目前的格林威治时间</p><p>–version : 显示版本编号</p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ date<span class="comment"># 获取日期</span></span><br><span class="line">$ date +%s<span class="comment"># 打印纪元时</span></span><br><span class="line">$ date <span class="string">"+%d %B %Y"</span><span class="comment"># 用格式串结合 + 作为date命令的参数，可以按照你的选择打印出对应格式的日期</span></span><br><span class="line">20 May 2010</span><br><span class="line">$ date -s <span class="string">"21 June 2009 11:01:22"</span> <span class="comment"># 设置日期和时间</span></span><br></pre></td></tr></table></figure><h3 id="1-15-脚本调试"><a href="#1-15-脚本调试" class="headerlink" title="1.15 脚本调试"></a>1.15 脚本调试</h3><h4 id="1-15-1使用选项–x，启用shell脚本的跟踪调试功能"><a href="#1-15-1使用选项–x，启用shell脚本的跟踪调试功能" class="headerlink" title="1.15.1使用选项–x，启用shell脚本的跟踪调试功能"></a>1.15.1使用选项–x，启用shell脚本的跟踪调试功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash -x script.sh</span><br></pre></td></tr></table></figure><h4 id="1-15-2-使用set-x和set-x对脚本进行部分调试"><a href="#1-15-2-使用set-x和set-x对脚本进行部分调试" class="headerlink" title="1.15.2 使用set -x和set +x对脚本进行部分调试"></a>1.15.2 使用set -x和set +x对脚本进行部分调试</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#文件名: debug.sh</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.6</span>&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">set</span> -x</span><br><span class="line">echo $i</span><br><span class="line"><span class="keyword">set</span> +x</span><br><span class="line">done</span><br><span class="line">echo <span class="string">"Script executed"</span></span><br></pre></td></tr></table></figure><ul><li>set –x：在执行时显示参数和命令。 </li><li>set +x：禁止调试。 </li><li>set –v：当命令进行读取时显示输入。 </li><li>set +v：禁止打印输入。 </li></ul><h4 id="1-15-3-通过传递-DEBUG环境变量调试"><a href="#1-15-3-通过传递-DEBUG环境变量调试" class="headerlink" title="1.15.3 通过传递 _DEBUG环境变量调试"></a>1.15.3 通过传递 _DEBUG环境变量调试</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DEBUG</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">[ <span class="string">"$_DEBUG"</span> == <span class="string">"on"</span> ] &amp;&amp; $@ || :</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.10</span>&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">DEBUG echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>可以将调试功能置为”on”来运行上面的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ _DEBUG=on ./script.sh</span><br></pre></td></tr></table></figure><p>我们在每一个需要打印调试信息的语句前加上DEBUG。如果没有把 _DEBUG=on传递给脚本，那么调试信息就不会打印出来。在Bash中，命令 <code>:</code> 告诉shell不要进行任何操作。 </p><h4 id="1-15-4-利用shebang来进行调试"><a href="#1-15-4-利用shebang来进行调试" class="headerlink" title="1.15.4 利用shebang来进行调试"></a>1.15.4 利用shebang来进行调试</h4><p>shebang的妙用<br>把shebang从 <code>#!/bin/bash</code> 改成 <code>#!/bin/bash -xv</code>，这样一来，不用任何其他选项就可以启用调试功能了。 </p><h3 id="1-16-函数参数"><a href="#1-16-函数参数" class="headerlink" title="1.16 函数参数"></a>1.16 函数参数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$<span class="number">0</span> # 脚本名</span><br><span class="line">$<span class="number">1</span># 第一个参数</span><br><span class="line">$<span class="number">2</span># 第二个参数</span><br><span class="line">$n# 第n个参数</span><br><span class="line"><span class="string">"$@"</span># 被扩展成 <span class="string">"$1"</span> <span class="string">"$2"</span> <span class="string">"$3"</span>等</span><br><span class="line"><span class="string">"$*"</span># 被扩展成 <span class="string">"$1c$2c$3"</span>，其中c是IFS的第一个字符</span><br><span class="line"><span class="string">"$@"</span> 要比<span class="string">"$*"</span>用得多。由于 <span class="string">"$*"</span>将所有的参数当做单个字符串，因此它很少被使用。</span><br></pre></td></tr></table></figure><p><strong>导出函数：</strong></p><p>函数也能像环境变量一样用export导出，如此一来，函数的作用域就可以扩展到子进程中，例如： </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> -f fname</span><br></pre></td></tr></table></figure><h3 id="1-17-read命令"><a href="#1-17-read命令" class="headerlink" title="1.17 read命令"></a>1.17 read命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从输入中读取n个字符并存入变量</span></span><br><span class="line">$ <span class="built_in">read</span> -n 2 var</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用无回显的方式读取密码</span></span><br><span class="line">$ <span class="built_in">read</span> -s var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示提示信息</span></span><br><span class="line">$ <span class="built_in">read</span> -p <span class="string">"Enter input:"</span> var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在特定时(秒)限内读取输入</span></span><br><span class="line">$ <span class="built_in">read</span> -t timeout var</span><br></pre></td></tr></table></figure><h3 id="1-18-条件比较与测试"><a href="#1-18-条件比较与测试" class="headerlink" title="1.18 条件比较与测试"></a>1.18 条件比较与测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if条件</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># else if和else</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> condition <span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>if的条件判断部分可能会变得很长，但可以用逻辑运算符将它变得简洁一些： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition ] &amp;&amp; action <span class="comment"># 如果condition为真，则执行action</span></span><br><span class="line">[ condition ] || action <span class="comment"># 如果condition为假，则执行action</span></span><br></pre></td></tr></table></figure><p><code>&amp;&amp;</code> 是逻辑与运算符， <code>||</code> 是逻辑或运算符。编写Bash脚本时，这是一个很有用的技巧。现在来了解一下条件和比较操作。 </p><p>算术比较：</p><ul><li><code>-gt</code> ：大于。 </li><li><code>-lt</code> ：小于。 </li><li><code>-ge</code> ：大于或等于。 </li><li><code>-le</code> ：小于或等于。 </li></ul><p>可以按照下面的方法结合多个条件进行测试： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="variable">$var1</span> -ne 0 -a <span class="variable">$var2</span> -gt 2 ] <span class="comment">#使用逻辑与-a</span></span><br><span class="line">[ <span class="variable">$var1</span> -ne 0 -o var2 -gt 2 ] <span class="comment">#逻辑或 -o</span></span><br></pre></td></tr></table></figure><p>文件系统相关测试：</p><p>我们可以使用不同的条件标志测试不同的文件系统相关的属性。 </p><ul><li><code>[ -f $file_var ]</code> ：如果给定的变量包含正常的文件路径或文件名，则返回真。 </li><li><code>[ -x $var ]</code> ：如果给定的变量包含的文件可执行，则返回真。 </li><li><code>[ -d $var ]</code> ：如果给定的变量包含的是目录，则返回真。 </li><li><code>[ -e $var ]</code> ：如果给定的变量包含的文件存在，则返回真。 </li><li><code>[ -c $var ]</code> ：如果给定的变量包含的是一个字符设备文件的路径，则返回真。 </li><li><code>[ -b $var ]</code> ：如果给定的变量包含的是一个块设备文件的路径，则返回真。 </li><li><code>[ -w $var ]</code> ：如果给定的变量包含的文件可写，则返回真。 </li><li><code>[ -r $var ]</code> ：如果给定的变量包含的文件可读，则返回真。 </li><li><code>[ -L $var ]</code> ：如果给定的变量包含的是一个符号链接，则返回真。 </li></ul><p>字符串比较：</p><p style="color: red;">使用字符串比较时，最好用双中括号，因为有时候采用单个中括号会产生错误，所以最好避开它们。 </p><p>可以用下面的方法检查两个字符串，看看它们是否相同。 </p><ul><li><code>[[ $str1 = $str2 ]]</code>：当str1等于str2时，返回真。也就是说， str1和str2包含<br>的文本是一模一样的。 </li><li><code>[[ $str1 == $str2 ]]</code> ：这是检查字符串是否相等的另一种写法。 </li></ul><p>也可以检查两个字符串是否不同。 </p><ul><li><code>[[ $str1 != $str2 ]]</code> ：如果str1和str2不相同，则返回真。 </li></ul><p>我们还可以检查字符串的字母序情况，具体如下所示。 </p><ul><li><code>[[ $str1 &gt; $str2 ]]</code> ：如果str1的字母序比str2大，则返回真。 </li><li><code>[[ $str1 &lt; $str2 ]]</code> ：如果str1的字母序比str2小，则返回真。 </li><li><code>[[ -z $str1 ]]</code> ：如果str1包含的是空字符串，则返回真。 </li><li><code>[[ -n $str1 ]]</code> ：如果str1包含的是非空字符串，则返回真。 </li></ul><p>使用逻辑运算符 &amp;&amp; 和 || 能够很容易地将多个条件组合起来： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$str1</span> ]] &amp;&amp; [[ -z <span class="variable">$str2</span> ]] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>test命令可以用来执行条件检测。用test可以避免使用过多的括号。之前讲过的[]中的测试条件同样可以用于test命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> -eq 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"True"</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 也可以写成：</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$var</span> -eq 0 ; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"True"</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><h4 id="1-利用子shell生成一个独立的进程"><a href="#1-利用子shell生成一个独立的进程" class="headerlink" title="1. 利用子shell生成一个独立的进程"></a>1. 利用子shell生成一个独立的进程</h4><p>子shell本身就是独立的进程。可以使用 <code>( )</code>操作符来定义一个子shell ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd;</span><br><span class="line">(cd /bin; ls);</span><br><span class="line">pwd;</span><br></pre></td></tr></table></figure><h4 id="2-无限循环的实例"><a href="#2-无限循环的实例" class="headerlink" title="2. 无限循环的实例"></a>2. 无限循环的实例</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> $@ &amp;&amp; <span class="keyword">return</span>; done &#125;</span><br></pre></td></tr></table></figure><p>工作原理：</p><p>函数repeat，它包含了一个无限while循环，该循环执行以参数形式（通过 <code>$@</code> 访问）传入函数的命令。如果命令执行成功，则返回，进而退出循环。 </p><p><strong>一种更快的做法 ：</strong></p><p>在大多数现代系统中， <code>true</code> 是作为 <code>/bin</code> 中的一个二进制文件来实现的。</p><p style="color: red;">这就意味着每执行一次while循环， shell就不得不生成一个进程。</p>如果不想这样，可以使用shell内建的 <code>:</code>命令，它总是会返回为0的退出码： <p></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; <span class="keyword">while</span> :; <span class="keyword">do</span> $@ &amp;&amp; <span class="keyword">return</span>; done &#125;</span><br></pre></td></tr></table></figure><p>尽管可读性不高，但是肯定比第一种方法快。 </p><h2 id="2-命令之乐"><a href="#2-命令之乐" class="headerlink" title="2. 命令之乐"></a>2. 命令之乐</h2><h3 id="2-1-cat命令"><a href="#2-1-cat命令" class="headerlink" title="2.1 cat命令"></a>2.1 cat命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摆脱多余的空白行</span></span><br><span class="line">$ cat -s file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示行号</span></span><br><span class="line">$ cat -n file</span><br><span class="line"><span class="comment"># -n甚至会为空白行加上行号。如果你想跳过空白行，那么可以使用选项-b。</span></span><br></pre></td></tr></table></figure><h3 id="2-2-find命令"><a href="#2-2-find命令" class="headerlink" title="2.2 find命令"></a>2.2 find命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录及子目录下所有的文件和文件夹</span></span><br><span class="line">$ find base_path</span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># -print指明打印出匹配文件的文件名（路径）。当使用 -print时， '\n'作为用于对输出的文件名进行分隔。就算你忽略-print， find命令仍会打印出文件名。</span></span><br><span class="line"><span class="comment"># -print0指明使用'\0'作为匹配的文件名之间的定界符。</span></span><br></pre></td></tr></table></figure><p>1、find命令有一个选项 <code>-iname</code>（忽略字母大小写） </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">example.txt EXAMPLE.txt file.txt</span><br><span class="line">$ find . -iname <span class="string">"example*"</span> -<span class="built_in">print</span></span><br><span class="line">./example.txt</span><br><span class="line">./EXAMPLE.txt</span><br></pre></td></tr></table></figure><p>2、如果想匹配多个条件中的一个，可以采用OR条件操作 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">new.txt some.jpg text.pdf</span><br><span class="line">$ find . \( -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span> \) -<span class="built_in">print</span></span><br><span class="line">./text.pdf</span><br><span class="line">./new.txt</span><br></pre></td></tr></table></figure><p>3、选项-path的参数可以使用通配符来匹配文件路径。 <code>-name</code> 总是用给定的文件名进行匹配。<code>-path</code> 则将文件路径作为一个整体进行匹配。例如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find /home/users -path <span class="string">"*/slynux/*"</span> -<span class="built_in">print</span></span><br><span class="line">/home/users/list/slynux.txt</span><br><span class="line">/home/users/slynux/eg.css</span><br></pre></td></tr></table></figure><p>4、选项 <code>-regex</code> 的参数和 <code>-path</code> 的类似，只不过 <code>-regex</code> 是基于正则表达式来匹配文件路径的。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">new.PY next.jpg test.py</span><br><span class="line">$ find . -regex <span class="string">".*\(\.py\|\.sh\)$"</span></span><br><span class="line">./test.py</span><br><span class="line"><span class="comment"># 类似地， -iregex可以让正则表达式忽略大小写。例如：</span></span><br><span class="line">$ find . -iregex <span class="string">".*\(\.py\|\.sh\)$"</span></span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure><p>5、find也可以用“!”否定参数的含义。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">list.txt new.PY new.txt next.jpg test.py</span><br><span class="line">$ find . ! -name <span class="string">"*.txt"</span> -<span class="built_in">print</span></span><br><span class="line">.</span><br><span class="line">./next.jpg</span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure><p>6、基于目录深度的搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 深度选项-maxdepth和 -mindepth来限制find命令遍历的目录深度</span></span><br><span class="line"><span class="comment"># 下列命令将find命令向下的最大深度限制为1:</span></span><br><span class="line">$ find . -maxdepth 1 -name <span class="string">"f*"</span> -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出深度距离当前目录至少两个子目录的所有文件:</span></span><br><span class="line">$ find . -mindepth 2 -name <span class="string">"f*"</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>-maxdepth和-mindepth应该作为find的第三个参数出现。如果作为第4个或之后的参数，就可能会影响到find的效率，因为它不得不进行一些不必要的检查。 </p><p>根据文件类型搜索</p><p>7、根据文件类型搜索</p><p><code>-type</code> 可以对文件搜索进行过滤 </p><table><thead><tr><th>文件类型</th><th>类型参数</th></tr></thead><tbody><tr><td>普通文件</td><td>f</td></tr><tr><td>符号链接</td><td>l</td></tr><tr><td>目录</td><td>d</td></tr><tr><td>字符设备</td><td>c</td></tr><tr><td>块设备</td><td>b</td></tr><tr><td>套接字</td><td>s</td></tr><tr><td>FIFO</td><td>p</td></tr></tbody></table><p>8、根据文件时间进行搜索</p><ul><li>访问时间（-atime）：用户最近一次访问文件的时间。</li><li>修改时间（-mtime）：文件内容最后一次被修改的时间。</li><li>变化时间（-ctime）：文件元数据（例如权限或所有权）最后一次改变的时间。</li></ul><blockquote><p>-atime、 -mtime、 -ctime可作为find的时间选项。它们可以用整数值指定，单位是天。这些整数值通常还带有 - 或 + ： - 表示小于， + 表示大于。 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出在最近7天内被访问过的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime -7 -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出恰好在7天前被访问过的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime 7 -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出访问时间超过7天的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime +7 -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>-atime、 -mtime以及-ctime都是基于时间的参数，其计量单位是“天”。还有其他一些基于时间的参数是以分钟作为计量单位的。这些参数包括： </p><ul><li>-amin（访问时间）</li><li>-mmin（修改时间）</li><li>-cmin（变化时间）</li></ul><p>使用 <code>-newer</code> ，我们可以指定一个用于比较时间戳的参考文件，然后找出比参考文件更新的（更近的修改时间）所有文件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出比file.txt修改时间更近的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -newer file.txt -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>9、基于文件大小的搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -size +2k</span><br><span class="line"><span class="comment"># 大于2KB的文件</span></span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -size -2k</span><br><span class="line"><span class="comment"># 小于2KB的文件</span></span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -size 2k</span><br><span class="line"><span class="comment"># 大小等于2KB的文件</span></span><br></pre></td></tr></table></figure><ul><li>b —— 块（512字节）</li><li>c —— 字节</li><li>w —— 字（2字节）</li><li>k —— 1024字节</li><li>M —— 1024k字节</li><li>G —— 1024M字节</li></ul><p>10、删除匹配的文件</p><p><code>-delete</code> 可以用来删除find查找到的匹配文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除当前目录下所有的 .swp文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.swp"</span> -delete</span><br></pre></td></tr></table></figure><p>11、基于文件权限和所有权的匹配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -perm 644 -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印出权限为644的文件</span></span><br></pre></td></tr></table></figure><p>-perm指明find应该只匹配具有特定权限值的文件。 </p><p>12、利用find执行命令或动作 </p><p>find命令可以借助选项-exec与其他命名进行结合。 -exec算得上是find最强大的特性之一。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> chown slynux &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#125;是一个与 -exec选项搭配使用的特殊字符串。对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名。</span></span><br></pre></td></tr></table></figure><p><code>-exec</code> 结合多个命令 :</p><p>我们无法在-exec参数中直接使用多个命令。它只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个shell脚本中（例如command.sh），然后在-exec中使用这个脚本：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec ./commands.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>13、让find跳过特定的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find devel/source_path \( -name <span class="string">".git"</span> -prune \) -o \( -<span class="built_in">type</span> f -<span class="built_in">print</span> \)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令打印出不包括在.git目录中的所有文件的名称（路径）。</span></span><br></pre></td></tr></table></figure><p><code>\( -name &quot;.git&quot; -prune \)</code> 的作用是用于进行排除，它指明了 .git目录应该被排除在外，而<code>\( -type f -print \)</code> 指明了需要执行的动作。这些动作需要被放置在第二个语句块中（打印出所有文件的名称和路径）。 </p><h3 id="2-3-玩转xargs"><a href="#2-3-玩转xargs" class="headerlink" title="2.3 玩转xargs"></a>2.3 玩转xargs</h3><p><code>xargs</code> 擅长将标准输入数据转换成命令行参数。</p><p><code>xargs</code> 命令把从 stdin接收到的数据重新格式化，再将其作为参数提供给其他命令。 </p><h4 id="2-3-1-将多行输入转换成单行输出"><a href="#2-3-1-将多行输入转换成单行输出" class="headerlink" title="2.3.1 将多行输入转换成单行输出"></a>2.3.1 将多行输入转换成单行输出</h4><p>只需要将换行符移除，再用” “（空格）进行代替，就可以实现多行输入的转换。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.txt <span class="comment"># 样例文件</span></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">7 8 9 10</span><br><span class="line">11 12</span><br><span class="line">$ cat example.txt | xargs</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12</span><br></pre></td></tr></table></figure><h4 id="2-3-2-将单行输入转换成多行输出"><a href="#2-3-2-将单行输入转换成多行输出" class="headerlink" title="2.3.2 将单行输入转换成多行输出"></a>2.3.2 将单行输入转换成多行输出</h4><p>指定每行最大的参数数量 <code>n</code>，我们可以将任何来自stdin的文本划分成多行，每行 <code>n</code> 个参数。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.txt | xargs -n 3</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">10 11 12</span><br></pre></td></tr></table></figure><h4 id="2-3-3-定制定界符"><a href="#2-3-3-定制定界符" class="headerlink" title="2.3.3 定制定界符"></a>2.3.3 定制定界符</h4><p>用 <code>-d</code> 选项为输入指定一个定制的定界符： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X</span><br><span class="line">split split split split</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X -n 2</span><br><span class="line">split split</span><br><span class="line">split split</span><br></pre></td></tr></table></figure><p>在这里，我们明确指定X作为输入定界符，而在默认情况下， xargs采用内部字段分隔符（空格）作为输入定界符。 </p><h4 id="2-3-4-读取stdin，将格式化参数传递给命令"><a href="#2-3-4-读取stdin，将格式化参数传递给命令" class="headerlink" title="2.3.4 读取stdin，将格式化参数传递给命令"></a>2.3.4 读取stdin，将格式化参数传递给命令</h4><p><code>-I</code> 指定替换字符串，这个字符串在xargs扩展时会被替换掉。如果将 <code>-I</code> 与 <code>xargs</code> 结合使用，对于每一个参数，命令都会被执行一次。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat args.txt</span><br><span class="line">arg1</span><br><span class="line">arg2</span><br><span class="line">arg3</span><br><span class="line">$ cat args.txt | xargs -I &#123;&#125; ./cecho.sh -p &#123;&#125; -l</span><br><span class="line">-p arg1 -l <span class="comment">#</span></span><br><span class="line">-p arg2 -l <span class="comment">#</span></span><br><span class="line">-p arg3 -l <span class="comment">#</span></span><br></pre></td></tr></table></figure><p><code>-I {}</code> 指定了替换字符串。对于每一个命令参数，字符串 <code>{}</code> 都会被从stdin读取到的参数替换掉。 </p><p>使用 <code>-I</code> 的时候，命令以循环的方式执行。 </p><p>xargs和find算是一对死党。两者结合使用可以让任务变得更轻松。 不过人们通常却是以一种错误的组合方式使用它们。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">print</span> | xargs rm -f</span><br></pre></td></tr></table></figure><p>这样做很危险。 有时可能会删除不必要删除的文件。 </p><p>只要我们把 <code>find</code> 的输出作为 <code>xargs</code> 的输入，就必须将 <code>-print0</code> 与 <code>find</code> 结合使用，以字符<code>null（&#39;\0&#39;）</code>来分隔输出。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -print0 | xargs -0 rm -f</span><br><span class="line"><span class="comment"># xargs -0将\0作为输入定界符。</span></span><br><span class="line"></span><br><span class="line">$ find source_code_dir_path -<span class="built_in">type</span> f -name <span class="string">"*.c"</span> -print0 | xargs -0 wc -l</span><br><span class="line"><span class="comment"># 统计源代码目录中所有C程序文件的行数</span></span><br></pre></td></tr></table></figure><h3 id="2-4-校验和与核实"><a href="#2-4-校验和与核实" class="headerlink" title="2.4 校验和与核实"></a>2.4 校验和与核实</h3><p>校验和（checksum）程序用来从文件中生成校验和密钥，然后利用这个校验和密钥核实文件的完整性。文件可以通过网络或任何存储介质分发到不同的地点。 </p><p>最知名且使用最为广泛的校验和技术是md5sum和SHA-1。它们对文件内容使用相应的算法来生成校验和。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum filename</span><br><span class="line">68b329da9893e34099c7d8ad5cb9c940 filename</span><br><span class="line"></span><br><span class="line">$ md5sum filename &gt; file_sum.md5</span><br><span class="line"></span><br><span class="line">$ md5sum file1 file2 file3 ..</span><br><span class="line"></span><br><span class="line">$ md5sum -c file_sum.md5</span><br><span class="line"><span class="comment"># 这个命令会输出校验和是否匹配的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要用所有的.md5信息来检查所有的文件，可以使用：</span></span><br><span class="line">$ md5sum -c *.md5</span><br></pre></td></tr></table></figure><p>计算SAH-1串的命令是sha1sum。其用法和md5sum的非常相似。只需要把先前讲过的那些命令中的md5sum替换成sha1sum就行了，记住将输入文件名从file_sum.md5改为file_sum.sha1。 </p><p>对目录进行校验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ md5deep -rl directory_path &gt; directory.md5</span><br><span class="line"><span class="comment"># -r使用递归的方式</span></span><br><span class="line"><span class="comment"># -l使用相对路径。默认情况下， md5deep会输出文件的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者也可以结合find来递归计算校验和：</span></span><br><span class="line">$ find directory_path -<span class="built_in">type</span> f -print0 | xargs -0 md5sum &gt;&gt; directory.md5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的命令进行核实：</span></span><br><span class="line">$ md5sum -c directory.md5</span><br></pre></td></tr></table></figure><h4 id="2-4-1-加密工具与散列"><a href="#2-4-1-加密工具与散列" class="headerlink" title="2.4.1 加密工具与散列"></a>2.4.1 加密工具与散列</h4><p><code>crypt</code>、 <code>gpg</code>、 <code>base64</code>、 <code>md5sum</code>、 <code>sha1sum</code> 以及 <code>openssl</code> 的用法。 </p><p>1）crypt是一个简单的加密工具，它从stdin接受一个文件以及口令作为输入，然后将加密数据输出到Stdout（因此要对输入、输出文件使用重定向）。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ crypt &lt;input_file &gt;output_file</span><br><span class="line">Enter passphrase:</span><br><span class="line"><span class="comment"># 它会要求输入一个口令。我们也可以通过命令行参数来提供口令。</span></span><br><span class="line"></span><br><span class="line">$ crypt PASSPHRASE &lt;input_file &gt;encrypted_file</span><br><span class="line"><span class="comment"># 如果需要解密文件，可以使用：</span></span><br><span class="line">$ crypt PASSPHRASE -d &lt;encrypted_file &gt;output_file</span><br></pre></td></tr></table></figure><p>2）gpg（GNU隐私保护）是一种应用广泛的工具，它使用加密技术来保护文件，以确保数据在送达目的地之前无法被读取。这里我们讨论如何加密、解密文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用gpg加密文件：</span></span><br><span class="line">$ gpg -c filename</span><br><span class="line"><span class="comment"># 该命令采用交互方式读取口令，并生成filename.gpg。使用以下命令解密gpg文件：</span></span><br><span class="line">$ gpg filename.gpg</span><br><span class="line"><span class="comment"># 该命令读取口令，然后对文件进行解密。</span></span><br></pre></td></tr></table></figure><p>3）Base64是一组相似的编码方案，它将ASCII字符转换成以64为基数的形式，以可读的ASCII字符串来描述二进制数据。 base64命令可以用来编码/解码Base64字符串。要将文件编码为Base64格式，可以使用： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ base64 filename &gt; outputfile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat file | base64 &gt; outputfile</span><br><span class="line"><span class="comment"># base64可以从stdin中进行读取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码Base64数据：</span></span><br><span class="line">$ base64 -d file &gt; outputfile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat base64_file | base64 -d &gt; outputfile</span><br></pre></td></tr></table></figure><p>4）md5sum与sha1sum都是单向散列算法，均无法逆推出原始数据。它们通常用于验证数据完整性或为特定数据生成唯一的密钥： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum file</span><br><span class="line">8503063d5488c3080d4800ff50850dc9 file</span><br><span class="line">$ sha1sum file</span><br><span class="line">1ba02b66e2e557fede8f61b7df282cd0a27b816b file</span><br></pre></td></tr></table></figure><p>这种类型的散列算法是存储密码的理想方案。密码使用其对应的散列值来存储。如果某个用户需要进行认证，读取该用户提供的密码并转换成散列值，然后将其与之前存储的散列值进行比对。如果相同，用户就通过认证，被允许访问；否则，就会被拒绝访问。 </p><p>5）openssl</p><p>用openssl生成shadow密码。 shadow密码通常都是salt密码。所谓SALT就是额外的一个字符串，用来起一个混淆的作用，使加密更加不易被破解。 salt由一些随机位组成，被用作密钥生成函数的输入之一，以生成密码的salt散列值。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ opensslpasswd -1 -salt SALT_STRING PASSWORD</span><br><span class="line"><span class="variable">$1</span><span class="variable">$SALT_STRING</span><span class="variable">$323VkWkSLHuhbt1zkSsUG</span>.</span><br><span class="line"><span class="comment"># 将SALT_STRING替换为随机字符串，并将PASSWORD替换成你想要使用的密码。</span></span><br></pre></td></tr></table></figure><h3 id="2-5-排序、唯一与重复"><a href="#2-5-排序、唯一与重复" class="headerlink" title="2.5 排序、唯一与重复"></a>2.5 排序、唯一与重复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对一组文件进行排序：</span></span><br><span class="line">$ sort file1.txt file2.txt &gt; sorted.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照数字顺序进行排序：</span></span><br><span class="line">$ sort -n file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照逆序进行排序：</span></span><br><span class="line">$ sort -r file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照月份进行排序（依照一月，二月，三月……）：</span></span><br><span class="line">$ sort -M months.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两个已排序过的文件：</span></span><br><span class="line">$ sort -m sorted1 sorted2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出已排序文件中不重复的行：</span></span><br><span class="line">$ sort file1.txt file2.txt | uniq</span><br></pre></td></tr></table></figure><p>检查文件是否已经排序过：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#功能描述：排序</span><br><span class="line">sort -C filename ;</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ]; then</span><br><span class="line">echo Sorted;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo Unsorted;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><code>-k</code> 指定了排序应该按照哪一个键（key）来进行。键指的是列号，而列号就是执行排序时的依据。 <code>-r</code> 告诉sort命令按照逆序进行排序。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依据第1列，以逆序形式排序</span></span><br><span class="line">$ sort -nrk 1 data.txt</span><br><span class="line">4 linux 1000</span><br><span class="line">3 bsd 1000</span><br><span class="line">2 winxp 4000</span><br><span class="line">1 mac 2000</span><br><span class="line"><span class="comment"># -nr表明按照数字，采用逆序形式排序</span></span><br><span class="line"><span class="comment"># 依据第2列进行排序</span></span><br><span class="line">$ sort -k 2 data.txt</span><br><span class="line">3 bsd 1000</span><br><span class="line">4 linux 1000</span><br><span class="line">1 mac 2000</span><br><span class="line">2 winxp 4000</span><br></pre></td></tr></table></figure><p>有时文本中可能会包含一些像空格之类的不必要的多余字符。如果需要忽略这些字符，并以字典序进行排序，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sort -bd unsorted.txt</span><br><span class="line"><span class="comment"># 选项-b用于忽略文件中的前导空白行，选项-d用于指明以字典序进行排序。</span></span><br></pre></td></tr></table></figure><p>sort选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-b：忽略每行前面开始出的空格字符；</span><br><span class="line"></span><br><span class="line">-c：检查文件是否已经按照顺序排序； </span><br><span class="line"></span><br><span class="line">-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符； </span><br><span class="line"></span><br><span class="line">-f：排序时，将小写字母视为大写字母； </span><br><span class="line"></span><br><span class="line">-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</span><br><span class="line"></span><br><span class="line">-m：将几个排序号的文件进行合并； </span><br><span class="line"></span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序； </span><br><span class="line"></span><br><span class="line">-n：依照数值的大小排序； </span><br><span class="line"></span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件； </span><br><span class="line"></span><br><span class="line">-r：以相反的顺序来排序； </span><br><span class="line"></span><br><span class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符； </span><br><span class="line"></span><br><span class="line">+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</span><br></pre></td></tr></table></figure><p>uniq选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：在每列旁边显示该行重复出现的次数； </span><br><span class="line"></span><br><span class="line">-d或--repeated：仅显示重复出现的行列； </span><br><span class="line"></span><br><span class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位； </span><br><span class="line"></span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符； </span><br><span class="line"></span><br><span class="line">-u或——unique：仅显示出一次的行列； </span><br><span class="line"></span><br><span class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。</span><br></pre></td></tr></table></figure><p>wc选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-c或--bytes或——chars：只显示Bytes数； <span class="comment"># 统计字符数</span></span><br><span class="line"></span><br><span class="line">-l或——lines：只显示列数； <span class="comment"># 统计行数</span></span><br><span class="line"></span><br><span class="line">-w或——words：只显示字数。<span class="comment"># 统计单词数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当不使用任何选项执行wc时，它会分别打印出文件的行数、单词数和字符数：</span></span><br><span class="line">$ wc file</span><br><span class="line">1435 15763 112200</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-L选项打印出文件中最长一行的长度：</span></span><br><span class="line">$ wc file -L</span><br><span class="line">205</span><br></pre></td></tr></table></figure><h3 id="2-6-临时文件命名与随机数"><a href="#2-6-临时文件命名与随机数" class="headerlink" title="2.6 临时文件命名与随机数"></a>2.6 临时文件命名与随机数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建临时文件：</span></span><br><span class="line">$ filename=`mktemp`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$filename</span></span><br><span class="line">/tmp/tmp.8xvhkjF5fH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时目录：</span></span><br><span class="line">$ dirname=`mktemp -d`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$dirname</span></span><br><span class="line">tmp.NI8xzW7VRX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果仅仅是想生成文件名，又不希望创建实际的文件或目录，方法如下：</span></span><br><span class="line">$ tmpfile=`mktemp -u`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$tmpfile</span></span><br><span class="line">/tmp/tmp.RsGmilRpcT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模板创建临时文件名：</span></span><br><span class="line"><span class="variable">$mktemp</span> test.XXX</span><br><span class="line">test.2tc</span><br></pre></td></tr></table></figure><p>如果提供了定制模板， X会被随机的字符（字母或数字）替换。注意， mktemp正常工作的前提是保证模板中只少要有3个X。 </p><h3 id="2-7-split-分割文件和数据"><a href="#2-7-split-分割文件和数据" class="headerlink" title="2.7 split 分割文件和数据"></a>2.7 split 分割文件和数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件分割成多个大小为10KB的文件</span></span><br><span class="line">$ split -b 10k data.file</span><br><span class="line">$ ls</span><br><span class="line">data.file xaa xab xac xad xae xaf xag xah xai xaj</span><br></pre></td></tr></table></figure><p>上面的命令将data.file分割成多个文件，每一个文件大小为10KB。这些文件以xab、 xac、 xad的形式命名。这表明它们都有一个字母后缀。如果想以数字为后缀，可以另外使用-d参数。此外，使用 -a length可以指定后缀长度： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 10k data.file -d -a 4</span><br><span class="line">$ ls</span><br><span class="line">data.file x0009 x0019 x0029 x0039 x0049 x0059 x0069 x0079</span><br></pre></td></tr></table></figure><p>除了k（KB）后缀，我们还可以使用M（MB）、 G（GB）、 c（byte）、 w（word）等后缀。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为分割后的文件指定文件名前缀 </span></span><br><span class="line">$ split -b 10k data.file -d -a 4 split_file</span><br><span class="line">$ ls</span><br><span class="line">data.file   split_file0002 split_file0005 split_file0008 strtok.c</span><br><span class="line">split_file0000 split_file0003 split_file0006 split_file0009</span><br><span class="line">split_file0001 split_file0004 split_file0007</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想按照数据块大小，而是需要根据行数来分割文件的话，可以使用 -l no_of_lines：</span></span><br><span class="line">$ split -l 10 data.file</span><br><span class="line"><span class="comment"># 分割成多个文件，每个文件包含10行</span></span><br></pre></td></tr></table></figure><p>csplit。它能够依据指定的条件和字符串匹配选项对日志文件进行分割。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat server.log</span><br><span class="line">SERVER-1</span><br><span class="line">[connection] 192.168.0.1 success</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 success</span><br><span class="line">SERVER-2</span><br><span class="line">[connection] 192.168.0.1 failed</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 success</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line">SERVER-3</span><br><span class="line">[connection] 192.168.0.1 pending</span><br><span class="line">[connection] 192.168.0.2 pending</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line">$ csplit server.log /SERVER/ -n 2 -s &#123;*&#125; -f server -b <span class="string">"%02d.log"</span> ; rm server00.log</span><br><span class="line">$ ls</span><br><span class="line">server01.log server02.log server03.log server.log</span><br></pre></td></tr></table></figure><p>有关这个命令的详细说明如下。 </p><ul><li>/SERVER/ 用来匹配某一行，分割过程即从此处开始。 </li><li>/[REGEX]/ 表示文本样式。包括从当前行（第一行）直到（但不包括）包含“SERVER”的匹配行。 </li><li>{*} 表示根据匹配重复执行分割，直到文件末尾为止。可以用{整数}的形式来指定分割执行的次数。 </li><li>-s 使命令进入静默模式，不打印其他信息。 </li><li>-n 指定分割后的文件名后缀的数字个数，例如01、 02、 03等。 </li><li>-f 指定分割后的文件名前缀（在上面的例子中， server就是前缀）。 </li><li>-b 指定后缀格式。例如%02d.log，类似于C语言中printf的参数格式。在这里文件名=前缀+后缀=server + %02d.log。 </li></ul><p>因为分割后的第一个文件没有任何内容（匹配的单词就位于文件的第一行中），所以我们删除了server00.log。 </p><h4 id="2-7-1-根据扩展名切分文件名-、"><a href="#2-7-1-根据扩展名切分文件名-、" class="headerlink" title="2.7.1 根据扩展名切分文件名$、"></a>2.7.1 根据扩展名切分文件名$、</h4><p>借助 <code>%</code> 操作符可以轻松将名称部分从 “名称.扩展名” 这种格式中提取出来。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">name=$&#123;file_jpg%.*&#125;</span><br><span class="line">echo File name is: $name</span><br><span class="line">输出结果：</span><br><span class="line">File name is: sample</span><br></pre></td></tr></table></figure><p>将文件名的扩展名部分提取出来，这可以借助 # 操作符实现。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension=$&#123;file_jpg#*.&#125;</span><br><span class="line">echo Extension is: jpg</span><br><span class="line">输出结果：</span><br><span class="line">Extension is: jpg</span><br></pre></td></tr></table></figure><p><code>${VAR%.*}</code>  的含义如下所述： </p><ul><li>从 $VAR中删除位于 % 右侧的通配符（在前例中是.*）所匹配的字符串。通配符从右向左进行匹配。 </li><li>给VAR赋值， VAR=sample.jpg。那么，通配符从右向左就会匹配到.jpg，因此，从 $VAR中删除匹配结果，就会得到输出sample。 </li></ul><p>%属于非贪婪（non-greedy）操作。它从右到左找出匹配通配符的最短结果。还有另一个操作符 %%，这个操作符与%相似，但行为模式却是贪婪的，这意味着它会匹配符合条件的最长的字符串。 </p><p>操作符%%则用.*从右向左执行贪婪匹配（.fun.book.txt）。 </p><p><code>${VAR#*.}</code> 的含义如下所述：<br>从$VAR中删除位于#右侧的通配符（即在前例中使用的*.）所匹配的字符串。通配<br>符从左向右进行匹配。<br>和 %% 类似， #也有一个相对应的贪婪操作符 ##。</p><p><code>##</code>从左向右进行贪婪匹配，并从指定变量中删除匹配结果。</p><p>这里有个能够提取域名不同部分的实用案例。假定 <code>URL=&quot;www.google.com&quot;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL%.*&#125;</span> <span class="comment"># 移除.*所匹配的最右边的内容</span></span><br><span class="line">www.google</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL%%.*&#125;</span> <span class="comment"># 将从右边开始一直匹配到最左边的*.移除（贪婪操作符）</span></span><br><span class="line">www</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL#*.&#125;</span> <span class="comment"># 移除*.所匹配的最左边的内容</span></span><br><span class="line">google.com</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL##*.&#125;</span> <span class="comment"># 将从左边开始一直匹配到最右边的*.移除（贪婪操作符）</span></span><br><span class="line">com</span><br></pre></td></tr></table></figure><h3 id="2-8-批量重命名和移动"><a href="#2-8-批量重命名和移动" class="headerlink" title="2.8 批量重命名和移动"></a>2.8 批量重命名和移动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 *.JPG更名为 *.jpg：</span></span><br><span class="line">$ rename *.JPG *.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件名中的空格替换成字符“_”：</span></span><br><span class="line">$ rename <span class="string">'s/ /_/g'</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换文件名的大小写：</span></span><br><span class="line">$ rename <span class="string">'y/A-Z/a-z/'</span> *</span><br><span class="line">$ rename <span class="string">'y/a-z/A-Z/'</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的 .mp3文件移入给定的目录：</span></span><br><span class="line">$ find path -<span class="built_in">type</span> f -name <span class="string">"*.mp3"</span> -<span class="built_in">exec</span> mv &#123;&#125; target_dir \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有文件名中的空格替换为字符“_”：</span></span><br><span class="line">$ find path -<span class="built_in">type</span> f -<span class="built_in">exec</span> rename <span class="string">'s/ /_/g'</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="3-以文件之名"><a href="#3-以文件之名" class="headerlink" title="3 以文件之名"></a>3 以文件之名</h2><h3 id="3-1-生成任意大小的文件"><a href="#3-1-生成任意大小的文件" class="headerlink" title="3.1 生成任意大小的文件"></a>3.1 生成任意大小的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=junk.data bs=1M count=1</span><br></pre></td></tr></table></figure><p>该命令会创建一个1MB大小的文件junk.data。来看一下命令参数： if代表输入文件（input file），of代表输出文件（output file）， bs代表以字节为单位的块大小（block size）， count代表需要被复制的块数。</p><p>使用dd命令时一定得留意，该命令运行在设备底层。要是你不小心出了岔子，搞不好会把磁盘清空或是损坏数据。所以一定要反复检查dd命令所用的语法是否正确，尤其是参数of=。 </p><table><thead><tr><th>单元大小</th><th>代码</th></tr></thead><tbody><tr><td>字节（1B）</td><td>c</td></tr><tr><td>字（2B）</td><td>w</td></tr><tr><td>块（512B）</td><td>b</td></tr><tr><td>千字节（1024B）</td><td>k</td></tr><tr><td>兆字节（1024KB）</td><td>M</td></tr><tr><td>吉字节（1024MB）</td><td>G</td></tr></tbody></table><p><code>ls -lS</code> 对当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息。  </p><h3 id="3-2-文件权限、所有权和粘滞位"><a href="#3-2-文件权限、所有权和粘滞位" class="headerlink" title="3.2 文件权限、所有权和粘滞位"></a>3.2 文件权限、所有权和粘滞位</h3><p>用命令ls -l可以列出文件的权限： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 slynux slynux 2497 2010-02-28 11:22 bot.py</span><br><span class="line">drwxr-xr-x 2 slynux slynux 4096 2010-05-27 14:31 a.py</span><br><span class="line">-rw-r--r-- 1 slynux slynux 539 2010-02-10 09:11 cl.pl</span><br></pre></td></tr></table></figure><ul><li><code>-</code>—— 普通文件。 </li><li>d —— 目录。 </li><li>c —— 字符设备。 </li><li>b —— 块设备。 </li><li>l —— 符号链接。 </li><li>s —— 套接字。 </li><li>p —— 管道。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改所有权</span></span><br><span class="line">$ chown user.group filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置粘滞位</span></span><br><span class="line"><span class="comment"># 要设置粘滞位，利用chmod将 +t应用于目录：</span></span><br><span class="line">$ chmod a+t directory_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以递归的方式设置权限</span></span><br><span class="line">$ chmod 777 . -R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以递归的方式设置所有权</span></span><br><span class="line">$ chown user.group . -R</span><br></pre></td></tr></table></figure><h3 id="3-3-创建不可修改的文件"><a href="#3-3-创建不可修改的文件" class="headerlink" title="3.3 创建不可修改的文件"></a>3.3 创建不可修改的文件</h3><p>chattr能够将文件设置为不可修改。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用下列命令将一个文件设置为不可修改：</span></span><br><span class="line">$ chattr +i file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要使文件恢复可写状态，移除不可修改属性即可：</span></span><br><span class="line">$ chattr -i file</span><br></pre></td></tr></table></figure><h3 id="3-4-查找符号链接及其指向目标"><a href="#3-4-查找符号链接及其指向目标" class="headerlink" title="3.4 查找符号链接及其指向目标"></a>3.4 查找符号链接及其指向目标</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符号链接：</span></span><br><span class="line">$ ln -s target symbolic_link_name</span><br><span class="line">例如：</span><br><span class="line">$ ln -l -s /var/www/ ~/web</span><br><span class="line"><span class="comment">#这个命令在已登录用户的home目录中创建了一个名为Web的符号链接。该链接指向/var/www。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的命令来验证是否创建链接：</span></span><br><span class="line">$ ls -l web</span><br><span class="line">lrwxrwxrwx 1 slynux slynux 8 2010-06-25 21:34 web -&gt; /var/www</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出当前目录下的符号链接：</span></span><br><span class="line">$ ls -l | grep <span class="string">"^l"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用find打印当前目录以及子目录下的符号链接：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> l -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用readlink打印出符号链接所指向的目标路径：</span></span><br><span class="line">$ readlink web</span><br><span class="line">/var/www</span><br></pre></td></tr></table></figure><h3 id="3-5-列举文件类型统计信息"><a href="#3-5-列举文件类型统计信息" class="headerlink" title="3.5 列举文件类型统计信息"></a>3.5 列举文件类型统计信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用下面的命令打印文件类型信息：</span></span><br><span class="line">$ file filename</span><br><span class="line">$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印不包括文件名在内的文件类型信息：</span></span><br><span class="line">$ file -b filename</span><br><span class="line">ASCII text</span><br></pre></td></tr></table></figure><h3 id="3-6-使用环回文件"><a href="#3-6-使用环回文件" class="headerlink" title="3.6 使用环回文件"></a>3.6 使用环回文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令可以创建一个1GB大小的文件：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=loobackfile.img bs=1G count=1</span><br><span class="line">1024+0 records <span class="keyword">in</span></span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 37.3155 s, 28.8 MB/s</span><br><span class="line"><span class="comment"># 你会发现创建好的文件大小超过了1GB。这是因为硬盘作为块设备，其分配存储空间时是按照块大小的整数倍来进行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用mkfs命令将1GB的文件格式化成ext4文件系统：</span></span><br><span class="line">$ mkfs.ext4 loopbackfile.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的命令检查文件系统：</span></span><br><span class="line">$ file loobackfile.img</span><br><span class="line">loobackfile.img: Linux rev 1.0 ext4 filesystem data,</span><br><span class="line">UUID=c9d56c42-f8e6-4cbd-aeab-369d5056660a (extents) (large files) (huge files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在就可以挂载环回文件了：</span></span><br><span class="line">$ mkdir /mnt/loopback</span><br><span class="line">$ mount -o loop loopbackfile.img /mnt/loopback</span><br><span class="line"><span class="comment"># -o loop用来挂载环回文件系统。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以手动来操作：</span></span><br><span class="line">$ losetup /dev/loop1 loopbackfile.img</span><br><span class="line">$ mount /dev/loop1 /mnt/loopback</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的方法进行卸载（umount）：</span></span><br><span class="line">$ umount mount_point</span><br></pre></td></tr></table></figure><h3 id="3-7-生成-ISO-文件及混合型-ISO"><a href="#3-7-生成-ISO-文件及混合型-ISO" class="headerlink" title="3.7 生成 ISO 文件及混合型 ISO"></a>3.7 生成 ISO 文件及混合型 ISO</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用下面的命令从/dev/cdrom创建一个ISO镜像：</span></span><br><span class="line">$ cat /dev/cdrom &gt; image.iso</span><br><span class="line"></span><br><span class="line"><span class="comment">#尽管可以奏效。但创建ISO镜像最好的方法还是使用dd工具：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/cdrom of=image.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># mkisofs命令用于创建ISO文件系统。</span></span><br><span class="line">$ mkisofs -V <span class="string">"Label"</span> -o image.iso source_dir/</span><br><span class="line"><span class="comment"># 选项 -o指定了ISO文件的路径。 source_dir是作为ISO文件内容来源的目录路径，选项 -V指定了ISO文件的卷标。</span></span><br></pre></td></tr></table></figure><h3 id="3-8-diff命令"><a href="#3-8-diff命令" class="headerlink" title="3.8 diff命令"></a>3.8 diff命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- 　<span class="comment"># 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。</span></span><br><span class="line">-a或--text 　<span class="comment"># diff预设只会逐行比较文本文件。</span></span><br><span class="line">-b或--ignore-space-change 　<span class="comment"># 不检查空格字符的不同。</span></span><br><span class="line">-B或--ignore-blank-lines 　 <span class="comment"># 不检查空白行。</span></span><br><span class="line">-c 　<span class="comment"># 显示全部内文，并标出不同之处。</span></span><br><span class="line">-C或--context <span class="comment"># 与执行"-c-"指令相同。</span></span><br><span class="line">-d或--minimal <span class="comment"># 使用不同的演算法，以较小的单位来做比较。</span></span><br><span class="line">-D或ifdef<span class="comment"># 此参数的输出格式可用于前置处理器巨集。</span></span><br><span class="line">-e或--ed<span class="comment"># 此参数的输出格式可用于ed的script文件。</span></span><br><span class="line">-f或-forward-ed<span class="comment"># 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span></span><br><span class="line">-H或--speed-large-files 　<span class="comment"># 比较大文件时，可加快速度。</span></span><br><span class="line">-l或--ignore-matching-lines 　<span class="comment"># 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</span></span><br><span class="line">-i或--ignore-case 　<span class="comment"># 不检查大小写的不同。</span></span><br><span class="line">-l或--paginate   <span class="comment"># 将结果交由pr程序来分页。</span></span><br><span class="line">-n或--rcs 　  <span class="comment"># 将比较结果以RCS的格式来显示。</span></span><br><span class="line">-N或--new-file 　  <span class="comment"># 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span></span><br><span class="line">-p 　  <span class="comment"># 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span></span><br><span class="line">-P或--unidirectional-new-file 　<span class="comment"># 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span></span><br><span class="line">-q或--brief 　<span class="comment"># 仅显示有无差异，不显示详细的信息。</span></span><br><span class="line">-r或--recursive 　<span class="comment"># 比较子目录中的文件。</span></span><br><span class="line">-s或--report-identical-files 　<span class="comment"># 若没有发现任何差异，仍然显示信息。</span></span><br><span class="line">-S或--starting-file 　<span class="comment"># 在比较目录时，从指定的文件开始比较。</span></span><br><span class="line">-t或--expand-tabs 　<span class="comment"># 在输出时，将tab字符展开。</span></span><br><span class="line">-T或--initial-tab 　<span class="comment"># 在每行前面加上tab字符以便对齐。</span></span><br><span class="line">-u,-U或--unified= 　<span class="comment"># 以合并的方式来显示文件内容的不同。</span></span><br><span class="line">-v或--version 　<span class="comment"># 显示版本信息。</span></span><br><span class="line">-w或--ignore-all-space 　<span class="comment"># 忽略全部的空格字符。</span></span><br><span class="line">-W或--width 　<span class="comment"># 在使用-y参数时，指定栏宽。</span></span><br><span class="line">-x或--exclude 　<span class="comment"># 不比较选项中所指定的文件或目录。</span></span><br><span class="line">-X或--exclude-from 　 <span class="comment"># 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件。</span></span><br><span class="line">-y或--side-by-side 　 <span class="comment"># 以并列的方式显示文件的异同之处。</span></span><br><span class="line">--<span class="built_in">help</span> 　 <span class="comment"># 显示帮助。</span></span><br><span class="line">--left-column 　<span class="comment"># 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</span></span><br><span class="line">--suppress-common-lines 　<span class="comment"># 在使用-y参数时，仅显示不同之处。</span></span><br></pre></td></tr></table></figure><p>生成目录的差异信息 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diff -Naur directory1 directory2</span><br></pre></td></tr></table></figure><ul><li>-N：将所有缺失的文件视为空文件。 </li><li>-a：将所有文件视为文本文件。 </li><li>-u：生成一体化输出。 </li><li>-r：遍历目录下的所有文件。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成patch文件</span></span><br><span class="line">$ diff -u version1.txt version2.txt &gt; version.patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下列命令来进行修补：</span></span><br><span class="line">$ patch -p1 version1.txt &lt; version.patch</span><br><span class="line">patching file version1.txt</span><br><span class="line"><span class="comment"># version1.txt的内容现在和verson2.txt的内容一模一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令可以撤销做出的修改：</span></span><br><span class="line">$ patch -p1 version1.txt &lt; version.patch</span><br><span class="line">patching file version1.txt</span><br><span class="line">Reversed (or previously applied) patch detected! Assume -R? [n] y</span><br><span class="line"><span class="comment"># 修改被撤销</span></span><br></pre></td></tr></table></figure><h3 id="3-9-more、less、head与tail命令"><a href="#3-9-more、less、head与tail命令" class="headerlink" title="3.9 more、less、head与tail命令"></a>3.9 more、less、head与tail命令</h3><h4 id="3-9-1-more文件内容输出查看工具"><a href="#3-9-1-more文件内容输出查看工具" class="headerlink" title="3.9.1 more文件内容输出查看工具"></a>3.9.1 more文件内容输出查看工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ more [参数选项] [文件] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数如下： </span></span><br><span class="line">+num   <span class="comment"># 从第num行开始显示； </span></span><br><span class="line">-num   <span class="comment"># 定义屏幕大小，为num行； </span></span><br><span class="line">+/pattern   <span class="comment"># 从pattern 前两行开始显示； </span></span><br><span class="line">-c   <span class="comment"># 从顶部清屏然后显示； </span></span><br><span class="line">-d   <span class="comment"># 提示Press space to continue, 'q' to quit.（按空格键继续，按q键退出），禁用响铃功能； </span></span><br><span class="line">-l    <span class="comment"># 忽略Ctrl+l （换页）字符； </span></span><br><span class="line">-p    <span class="comment"># 通过清除窗口而不是滚屏来对文件进行换页。和-c参数有点相似； </span></span><br><span class="line">-s    <span class="comment"># 把连续的多个空行显示为一行； </span></span><br><span class="line">-u    <span class="comment"># 把文件内容中的下划线去掉退出more的动作指令是q</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示提示，并从终端或控制台顶部显示；</span></span><br><span class="line">$ more -dc /etc/profile </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从profile的第4行开始显示；</span></span><br><span class="line">$ more +4 /etc/profile     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每屏显示4行；</span></span><br><span class="line">$ more -4 /etc/profile    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从profile中的第一个MAIL单词的前两行开始显示；</span></span><br><span class="line">$ more +/MAIL /etc/profile</span><br></pre></td></tr></table></figure><p>more 的动作指令：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter       # 向下n行，需要定义，默认为<span class="number">1</span>行； </span><br><span class="line">Ctrl+f    # 向下滚动一屏； </span><br><span class="line">空格键 # 向下滚动一屏； </span><br><span class="line">Ctrl+b  # 返回上一屏； </span><br><span class="line">=         # 输出当前行的行号； </span><br><span class="line">:f      # 输出文件名和当前行的行号； </span><br><span class="line">v      # 调用vi编辑器； </span><br><span class="line">! 命令          # 调用Shell，并执行命令； </span><br><span class="line">q     # 退出more当我们查看某一文件时，想调用vi来编辑它，不要忘记了v动作指令，这是比较方便的；</span><br></pre></td></tr></table></figure><p>其它命令通过管道和more结合的运用例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /etc |more</span><br></pre></td></tr></table></figure><h4 id="3-9-2-less查看文件内容工具"><a href="#3-9-2-less查看文件内容工具" class="headerlink" title="3.9.2 less查看文件内容工具"></a>3.9.2 less查看文件内容工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-c <span class="comment"># 从顶部（从上到下）刷新屏幕，并显示文件内容。而不是通过底部滚动完成刷新； </span></span><br><span class="line">-f <span class="comment"># 强制打开文件，二进制文件显示时，不提示警告； </span></span><br><span class="line">-i <span class="comment"># 搜索时忽略大小写；除非搜索串中包含大写字母； </span></span><br><span class="line">-I <span class="comment"># 搜索时忽略大小写，除非搜索串中包含小写字母； </span></span><br><span class="line">-m <span class="comment"># 显示读取文件的百分比； </span></span><br><span class="line">-M <span class="comment"># 显法读取文件的百分比、行号及总行数； </span></span><br><span class="line">-N <span class="comment"># 在每行前输出行号； </span></span><br><span class="line">-p <span class="comment"># pattern 搜索pattern；比如在/etc/profile搜索单词MAIL，就用 less -p MAIL /etc/profile </span></span><br><span class="line">-s <span class="comment"># 把连续多个空白行作为一个空白行显示； </span></span><br><span class="line">-Q <span class="comment"># 在终端下不响铃；</span></span><br></pre></td></tr></table></figure><p>less的动作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">回车键 <span class="comment"># 向下移动一行； </span></span><br><span class="line">y   <span class="comment"># 向上移动一行； </span></span><br><span class="line">空格键 <span class="comment"># 向下滚动一屏； </span></span><br><span class="line">b   <span class="comment"># 向上滚动一屏； </span></span><br><span class="line">d   <span class="comment"># 向下滚动半屏； </span></span><br><span class="line">h   <span class="comment"># less的帮助； </span></span><br><span class="line">u   <span class="comment"># 向上洋动半屏； </span></span><br><span class="line">w   <span class="comment"># 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示； </span></span><br><span class="line">g   <span class="comment"># 跳到第一行； </span></span><br><span class="line">G   <span class="comment"># 跳到最后一行； </span></span><br><span class="line">p   <span class="comment"># n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示； </span></span><br><span class="line">/pattern  <span class="comment"># 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词； </span></span><br><span class="line">v   <span class="comment"># 调用vi编辑器； </span></span><br><span class="line">q   <span class="comment"># 退出less </span></span><br><span class="line">!<span class="built_in">command</span>  <span class="comment"># 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件；</span></span><br></pre></td></tr></table></figure><h4 id="3-9-3-head"><a href="#3-9-3-head" class="headerlink" title="3.9.3 head"></a>3.9.3 head</h4><p>head 是显示一个文件的内容的前多少行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ head -n 10 /etc/profile</span><br></pre></td></tr></table></figure><h4 id="3-9-4-tail"><a href="#3-9-4-tail" class="headerlink" title="3.9.4 tail"></a>3.9.4 tail</h4><p>tail 是显示一个文件的内容的最后多少行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -n 5 /etc/profile</span><br></pre></td></tr></table></figure><h3 id="3-10-getopts-参数解析"><a href="#3-10-getopts-参数解析" class="headerlink" title="3.10 getopts 参数解析"></a>3.10 getopts 参数解析</h3><h4 id="3-10-1-getopts（shell内置命令）"><a href="#3-10-1-getopts（shell内置命令）" class="headerlink" title="3.10.1 getopts（shell内置命令）"></a>3.10.1 getopts（shell内置命令）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> getopt</span><br><span class="line">getopt 是 /usr/bin/getopt</span><br><span class="line">$ <span class="built_in">type</span> <span class="built_in">getopts</span> </span><br><span class="line"><span class="built_in">getopts</span> 是 shell 内建</span><br></pre></td></tr></table></figure><p>getopts不能直接处理长的选项（如：–prefix=/home等）</p><p>关于getopts的使用方法，可以man bash  搜索getopts。</p><p>getopts有两个参数，第一个参数是一个字符串，包括字符和“：”，每一个字符都是一个有效的选项，如果字符后面带有“：”，表示这个字符有自己的参数。getopts从命令中获取这些参数，并且删去了“-”，并将其赋值在第二个参数中，如果带有自己参数，这个参数赋值在 <code>$OPTARG</code>中。提供getopts的shell内置了 <code>$OPTARG</code> 这个变变，getopts修改了这个变量。</p><p>这里变量 <code>$OPTARG</code> 存储相应选项的参数，而 <code>$OPTIND</code> 总是存储原始 <code>$*</code> 中下一个要处理的元素位置。<code>while getopts &quot;:a:bc&quot; opt</code>   #第一个冒号表示忽略错误；字符后面的冒号表示该选项必须有自己的参数</p><p>getopts后面的字符串就是可以使用的选项列表，每个字母代表一个选项，后面带:的意味着选项除了定义本身之外，还会带上一个参数作为选项的值，比如d:在实际的使用中就会对应-d 30，选项的值就是30；getopts字符串中没有跟随:的是开关型选项，不需要再指定值，相当于true/false，只要带了这个参数就是true。如果命令行中包含了没有在getopts列表中的选项，会有警告信息，如果在整个getopts字符串前面也加上个:，就能消除警告信息了。</p><p>两个特殊变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$OPTIND</span>     <span class="comment"># 特殊变量，option index，会逐个递增, 初始值为1</span></span><br><span class="line"><span class="variable">$OPTARG</span>     <span class="comment"># 特殊变量，option argument，不同情况下有不同的值</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">echo $*</span><br><span class="line"><span class="keyword">while</span> getopts <span class="string">":a:bc"</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> $opt <span class="keyword">in</span></span><br><span class="line">                a ) echo $OPTARG</span><br><span class="line">                    echo $OPTIND;;</span><br><span class="line">                b ) echo <span class="string">"b $OPTIND"</span>;;</span><br><span class="line">                c ) echo <span class="string">"c $OPTIND"</span>;;</span><br><span class="line">                ? ) echo <span class="string">"error"</span></span><br><span class="line">                    exit <span class="number">1</span>;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo $OPTIND</span><br><span class="line">shift $(($OPTIND - <span class="number">1</span>))</span><br><span class="line">#通过shift $(($OPTIND - <span class="number">1</span>))的处理，$*中就只保留了除去选项内容的参数，可以在其后进行正常的shell编程处理了。</span><br><span class="line">echo $<span class="number">0</span></span><br><span class="line">echo $*</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./getopts.sh -a 11 -b -c</span><br><span class="line">-a 11 -b -c</span><br><span class="line">11</span><br><span class="line">3</span><br><span class="line">b 4</span><br><span class="line">c 5</span><br><span class="line">5</span><br><span class="line">./getopts.sh</span><br></pre></td></tr></table></figure><h4 id="3-10-2-getopt（一个外部工具）"><a href="#3-10-2-getopt（一个外部工具）" class="headerlink" title="3.10.2 getopt（一个外部工具）"></a>3.10.2 getopt（一个外部工具）</h4><p>具体用用法可以 man getopt</p><p><code>-o</code> 表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，如 <code>-carg</code> 而不能是 <code>-c arg</code>。</p><p><code>--long</code> 表示长选项</p><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"></span><br><span class="line"># A small example program <span class="keyword">for</span> using the <span class="keyword">new</span> getopt(<span class="number">1</span>) program.</span><br><span class="line"># This program will only work <span class="keyword">with</span> bash(<span class="number">1</span>)</span><br><span class="line"># An similar program using the tcsh(<span class="number">1</span>) script. language can be found</span><br><span class="line"># <span class="keyword">as</span> parse.tcsh</span><br><span class="line"></span><br><span class="line"># Example input and output (<span class="keyword">from</span> the bash prompt):</span><br><span class="line"># ./parse.bash -a par1 <span class="string">'another arg'</span> --c-long <span class="string">'wow!*\?'</span> -cmore -b <span class="string">" very long "</span></span><br><span class="line"># Option a</span><br><span class="line"># Option c, no argument</span><br><span class="line"># Option c, argument <span class="string">`more'</span></span><br><span class="line"><span class="string"># Option b, argument `</span> very long <span class="string">'</span></span><br><span class="line"><span class="string"># Remaining arguments:</span></span><br><span class="line"><span class="string"># --&gt; `par1'</span></span><br><span class="line"># --&gt; <span class="string">`another arg'</span></span><br><span class="line"><span class="string"># --&gt; `</span>wow!*\?<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note that we use `"$@"'</span> to <span class="keyword">let</span> each command-line parameter expand to a</span><br><span class="line"># separate word. The quotes around <span class="string">`$@' are essential!</span></span><br><span class="line"><span class="string"># We need TEMP as the `</span><span class="built_in">eval</span> <span class="keyword">set</span> --<span class="string">' would nuke the return value of getopt.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项</span></span><br><span class="line"><span class="string">#如-carg 而不能是-c arg</span></span><br><span class="line"><span class="string">#--long表示长选项</span></span><br><span class="line"><span class="string">#"$@"在上面解释过</span></span><br><span class="line"><span class="string"># -n:出错时的信息</span></span><br><span class="line"><span class="string"># -- ：举一个例子比较好理解：</span></span><br><span class="line"><span class="string">#我们要创建一个名字为 "-f"的目录你会怎么办？</span></span><br><span class="line"><span class="string"># mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用</span></span><br><span class="line"><span class="string"># mkdir -- -f 这样-f就不会被作为选项。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \</span></span><br><span class="line"><span class="string">     -n '</span>example.bash<span class="string">' -- "$@"`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if [ $? != 0 ] ; then echo "Terminating..." &gt;&amp;2 ; exit 1 ; fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note the quotes around `$TEMP'</span>: they are essential!</span><br><span class="line">#<span class="keyword">set</span> 会重新排列参数的顺序，也就是改变$<span class="number">1</span>,$<span class="number">2.</span>..$n的值，这些值在getopt中重新排列过了</span><br><span class="line"><span class="built_in">eval</span> <span class="keyword">set</span> -- <span class="string">"$TEMP"</span></span><br><span class="line"></span><br><span class="line">#经过getopt的处理，下面处理具体选项。</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"$1"</span> <span class="keyword">in</span></span><br><span class="line">                -a|--a-long) echo <span class="string">"Option a"</span> ; shift ;;</span><br><span class="line">                -b|--b-long) echo <span class="string">"Option b, argument \`$2'"</span> ; shift <span class="number">2</span> ;;</span><br><span class="line">                -c|--c-long)</span><br><span class="line">                        # c has an optional argument. As we are <span class="keyword">in</span> quoted mode,</span><br><span class="line">                        # an empty parameter will be generated <span class="keyword">if</span> its optional</span><br><span class="line">                        # argument is not found.</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"$2"</span> <span class="keyword">in</span></span><br><span class="line">                                <span class="string">""</span>) echo <span class="string">"Option c, no argument"</span>; shift <span class="number">2</span> ;;</span><br><span class="line">                                *)  echo <span class="string">"Option c, argument \`$2'"</span> ; shift <span class="number">2</span> ;;</span><br><span class="line">                        esac ;;</span><br><span class="line">                --) shift ; <span class="keyword">break</span> ;;</span><br><span class="line">                *) echo <span class="string">"Internal error!"</span> ; exit <span class="number">1</span> ;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo <span class="string">"Remaining arguments:"</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">do</span></span><br><span class="line">   echo <span class="string">'--&gt; '</span><span class="string">"\`$arg'"</span> ;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./getopt.sh --b-long abc -a -c33 remain</span><br><span class="line">Option b, argument `abc<span class="string">'</span></span><br><span class="line"><span class="string">Option a</span></span><br><span class="line"><span class="string">Option c, argument `33'</span></span><br><span class="line">Remaining arguments:</span><br><span class="line">--&gt; `remain<span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="3-11-只列出目录的各种方法"><a href="#3-11-只列出目录的各种方法" class="headerlink" title="3.11 只列出目录的各种方法"></a>3.11 只列出目录的各种方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ls –d：</span></span><br><span class="line">$ ls -d */</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用grep结合ls –F：</span></span><br><span class="line">$ ls -F | grep <span class="string">"/$"</span></span><br><span class="line"><span class="comment"># 当使用-F时，所有的输出项都会添加上一个代表文件类型的字符，如@、 *、 |等。目录对应的是 / 字符。我们用grep只过滤那些以 /$ 作为行尾标记的输出项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用grep结合ls –l：</span></span><br><span class="line">$ ls -l | grep <span class="string">"^d"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用find：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> d -maxdepth 1 -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><h3 id="3-12-使用pushd和popd进行快速定位"><a href="#3-12-使用pushd和popd进行快速定位" class="headerlink" title="3.12 使用pushd和popd进行快速定位"></a>3.12 使用pushd和popd进行快速定位</h3><p>使用pushd和popd时，可以无视cd命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压入并切换路径：</span></span><br><span class="line">$ <span class="built_in">pushd</span> /var/www</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再压入下一个目录路径：</span></span><br><span class="line">$ <span class="built_in">pushd</span> /usr/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的命令查看栈内容：</span></span><br><span class="line">$ <span class="built_in">dirs</span></span><br><span class="line">/usr/src /var/www ~ /usr/share /etc</span><br><span class="line">0 1   2 3 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当你想切换到列表中任意一个路径时，将每条路径从0到n进行编号，然后使用你希望切换到的路径编号，例如：</span></span><br><span class="line">$ <span class="built_in">pushd</span> +3</span><br><span class="line"><span class="comment"># 这条命令会将栈进行翻转并切换到目录 /use/share。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除最后添加的路径并把当前目录更改为上一级目录，可以使用以下命令：</span></span><br><span class="line">$ <span class="built_in">popd</span></span><br><span class="line"><span class="comment"># 用popd +num可以从列表中移除特定的路径。num是从左到右，从0到n开始计数的。</span></span><br></pre></td></tr></table></figure><h3 id="3-13-tree打印目录树"><a href="#3-13-tree打印目录树" class="headerlink" title="3.13 tree打印目录树"></a>3.13 tree打印目录树</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重点标记出匹配某种样式的文件：</span></span><br><span class="line">$ tree PATH -P <span class="string">"*.sh"</span> <span class="comment"># 用一个目录路径代替PATH</span></span><br><span class="line">|-- home</span><br><span class="line">| |-- packtpub</span><br><span class="line">| | `-- automate.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重点标记出除符合某种样式之外的那些文件：</span></span><br><span class="line">$ tree path -I PATTERN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -h选项同时打印出文件和目录的大小：</span></span><br><span class="line">$ tree -h</span><br></pre></td></tr></table></figure><h2 id="4-让文件飞"><a href="#4-让文件飞" class="headerlink" title="4 让文件飞"></a>4 让文件飞</h2><h3 id="4-1-正则表达式"><a href="#4-1-正则表达式" class="headerlink" title="4.1 正则表达式"></a>4.1 正则表达式</h3><table><thead><tr><th>正则表达式</th><th>描述</th><th align="left">示例</th></tr></thead><tbody><tr><td>^</td><td>行起始标记</td><td align="left">^tux 匹配以tux起始的行</td></tr><tr><td>$</td><td>行尾标记</td><td align="left">tux$ 匹配以tux结尾的行</td></tr><tr><td>.</td><td>匹配任意一个字符</td><td align="left">Hack.匹配Hackl和Hacki，它只能匹配单个字符</td></tr><tr><td>[ ]</td><td>匹配包含在 [字符] 之中的任意一个字符</td><td align="left">coo[kl] 匹配cook或cool</td></tr><tr><td>[ ^ ]</td><td>匹配除 <code>[^字符]</code> 之外的任意一个字符</td><td align="left"><code>9[^01]</code>匹配92、 93，但是不匹配91或90</td></tr><tr><td>[ - ]</td><td>匹配 [ ] 中指定范围内的任意一个字符</td><td align="left">[1-5] 匹配从1～5的任意一个数字</td></tr><tr><td>?</td><td>匹配之前的项1次或0次</td><td align="left">colou?r 匹配color或colour，但是不能匹配colouur</td></tr><tr><td>+</td><td>匹配之前的项1次或多次</td><td align="left">Rollno-9+ 匹配Rollno-99、Rollno-9，但是不能匹配Rollno-</td></tr><tr><td>*</td><td>匹配之前的项0次或多次</td><td align="left">co*l 匹配cl、 col、 coool等</td></tr><tr><td>( )</td><td>创建一个用于匹配的子串</td><td align="left">ma(tri)?x 匹配max或maxtrix</td></tr><tr><td>{n}</td><td>匹配之前的项n次</td><td align="left">[0-9]{3} 匹 配 任 意 一 个 三 位 数 ， [0-9]{3} 可 以 扩 展 为<code>[0-9][0-9][0-9]</code></td></tr><tr><td>{n, }</td><td>之前的项至少需要匹配n次</td><td align="left">[0-9]{2,} 匹配任意一个两位或更多位的数字</td></tr><tr><td>{n, m}</td><td>指定之前的项所必需匹配的最小次数和最大次数</td><td align="left">[0-9]{2,5} 匹配从两位数到五位数之间的任意一个数字</td></tr><tr><td>|</td><td>交替——匹配 | 两边的任意一项</td><td align="left">Oct  (1st | 2nd) 匹配Oct 1st或Oct 2nd</td></tr><tr><td>\</td><td>转义符可以将上面介绍的特殊字符进行转义</td><td align="left"><code>a\.b</code> 匹配a.b，但不能匹配ajb。通过在 . 之间加上前缀 \ ，从而忽略了 . 的特殊意义</td></tr></tbody></table><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>所有的字母和数字</td></tr><tr><td>[:alpha:]</td><td>所有字母</td></tr><tr><td>[:blank:]</td><td>水平制表符，空白等</td></tr><tr><td>[:cntrl:]</td><td>所有控制字符</td></tr><tr><td>[:digit:]</td><td>所有的数字</td></tr><tr><td><code>[:graph:]</code></td><td>所有可打印字符，不包括空格</td></tr><tr><td>[:lower:]</td><td>所有的小写字符</td></tr><tr><td>[:print:]</td><td>所有可打印字符，包括空格</td></tr><tr><td>[:punct:]</td><td>所有的标点字符</td></tr><tr><td>[:space:]</td><td>所有的横向或纵向的空白</td></tr><tr><td>[:upper:]</td><td>所有大写字母</td></tr></tbody></table><h3 id="4-2-grep命令"><a href="#4-2-grep命令" class="headerlink" title="4.2 grep命令"></a>4.2 grep命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-a<span class="comment"># 不要忽略二进制的数据。</span></span><br><span class="line">-A&lt;显示列数&gt;  <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之后的内容。</span></span><br><span class="line">-b<span class="comment"># 在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。</span></span><br><span class="line">-B&lt;显示列数&gt; <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前的内容。</span></span><br><span class="line">-c<span class="comment"># 计算符合范本样式的列数。</span></span><br><span class="line">-C&lt;显示列数&gt;或-&lt;显示列数&gt;<span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span></span><br><span class="line">-d&lt;进行动作&gt; <span class="comment"># 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</span></span><br><span class="line">-e&lt;范本样式&gt; <span class="comment"># 指定字符串做为查找文件内容的范本样式。</span></span><br><span class="line">-E<span class="comment"># 将范本样式为延伸的普通表示法来使用。</span></span><br><span class="line">-f&lt;范本文件&gt; <span class="comment"># 指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。</span></span><br><span class="line">-F<span class="comment"># 将范本样式视为固定字符串的列表。</span></span><br><span class="line">-G<span class="comment"># 将范本样式视为普通的表示法来使用。</span></span><br><span class="line">-h<span class="comment"># 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span></span><br><span class="line">-H<span class="comment"># 在显示符合范本样式的那一列之前，表示该列所属的文件名称。</span></span><br><span class="line">-i<span class="comment"># 忽略字符大小写的差别。</span></span><br><span class="line">-l<span class="comment"># 列出文件内容符合指定的范本样式的文件名称。</span></span><br><span class="line">-L<span class="comment"># 列出文件内容不符合指定的范本样式的文件名称。</span></span><br><span class="line">-n<span class="comment"># 在显示符合范本样式的那一列之前，标示出该列的列数编号。</span></span><br><span class="line">-q<span class="comment"># 不显示任何信息。</span></span><br><span class="line">-r<span class="comment"># 此参数的效果和指定“-d recurse”参数相同。</span></span><br><span class="line">-s<span class="comment"># 不显示错误信息。</span></span><br><span class="line">-v<span class="comment"># 反转查找。</span></span><br><span class="line">-V<span class="comment"># 显示版本信息。</span></span><br><span class="line">-w<span class="comment"># 只显示全字符合的列。</span></span><br><span class="line">-x<span class="comment"># 只显示全列符合的列。</span></span><br><span class="line">-o <span class="comment"># 只输出文件中匹配到的部分。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个grep命令也可以对多个文件进行搜索：</span></span><br><span class="line">$ grep <span class="string">"match_text"</span> file1 file2 file3 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># grep -E选项——这意味着使用扩展（extended）正则表达式：</span></span><br><span class="line">$ grep -E <span class="string">"[a-z]+"</span> filename</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ egrep <span class="string">"[a-z]+"</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只输出文件中匹配到的文本部分，可以使用选项 -o：</span></span><br><span class="line">$ <span class="built_in">echo</span> this is a line. | egrep -o <span class="string">"[a-z]+\."</span></span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印除包含match_pattern行之外的所有行，选项-v可以将匹配结果进行反转（invert）。可使用：</span></span><br><span class="line">$ grep -v match_pattern file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件或文本中包含匹配字符串的行数：</span></span><br><span class="line">$ grep -c <span class="string">"text"</span> filename</span><br><span class="line">10</span><br><span class="line"><span class="comment"># 需要注意的是-c只是统计匹配行的数量，并不是匹配的次数。。例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1 2 3 4\nhello\n5 6"</span> | egrep -c <span class="string">"[0-9]"</span></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要文件中统计匹配项的数量，可以使用下面的技巧：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1 2 3 4\nhello\n5 6"</span> | egrep -o <span class="string">"[0-9]"</span> | wc -l</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模式匹配所位于的字符或字节偏移：</span></span><br><span class="line">$ <span class="built_in">echo</span> gnu is not unix | grep -b -o <span class="string">"not"</span></span><br><span class="line">7:not</span><br><span class="line"><span class="comment"># 选项 -b总是和 -o配合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索多个文件并找出匹配文本位于哪一个文件中：</span></span><br><span class="line">$ grep -l linux sample1.txt sample2.txt</span><br><span class="line">sample1.txt</span><br><span class="line">sample2.txt</span><br><span class="line"><span class="comment"># 和-l相反的选项是-L，它会返回一个不匹配的文件列表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep的选项-R和-r功能一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略样式中的大小写</span></span><br><span class="line">$ <span class="built_in">echo</span> hello world | grep -i <span class="string">"HELLO"</span></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># grep匹配多个样式</span></span><br><span class="line">$ <span class="built_in">echo</span> this is a line of text | grep -e <span class="string">"this"</span> -e <span class="string">"line"</span> -o</span><br><span class="line">this</span><br><span class="line">line</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在grep搜索中指定或排除文件</span></span><br><span class="line">$ grep <span class="string">"main()"</span> . -r --include *.&#123;c,cpp&#125; <span class="comment"># 目录中递归搜索所有的 .c和 .cpp文件</span></span><br><span class="line"><span class="comment"># 如果需要排除目录，可以使用 --exclude-dir选项。</span></span><br><span class="line"><span class="comment"># 如果需要从文件中读取所需排除的文件列表，使用--exclude-from FILE。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用0值字节作为后缀的grep与xargs，为了指明输入的文件名是以0值字节（\0）作为终止符，需要在xargs中使用-0。</span></span><br><span class="line"><span class="comment"># grep使用-Z选项输出以0值字节作为终结符的文件名（\0）。</span></span><br><span class="line">$ grep <span class="string">"test"</span> file* -lZ | xargs -0 rm</span><br><span class="line"><span class="comment"># -Z通常和 -l结合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep的静默输出</span></span><br><span class="line"><span class="comment"># grep的静默选项（-q）来实现。在静默模式中， grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之后的3行，使用 -A选项：</span></span><br><span class="line">$ seq 10 | grep 5 -A 3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之前的3行，使用 -B选项：</span></span><br><span class="line">$ seq 10 | grep 5 -B 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之前以及之后的3行，使用-C选项：</span></span><br><span class="line">$ seq 10 | grep 5 -C 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有多个匹配，那么使用--作为各部分之间的定界符：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"a\nb\nc\na\nb\nc"</span> | grep a -A 1</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h3 id="4-3-cut-按列切分文件"><a href="#4-3-cut-按列切分文件" class="headerlink" title="4.3 cut 按列切分文件"></a>4.3 cut 按列切分文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示第2列和第3列：</span></span><br><span class="line">$ cut -f 2,3 filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>记法</th><th>范围</th></tr></thead><tbody><tr><td>N -</td><td>从第N个字节，字符或字段到行尾</td></tr><tr><td>N - M</td><td>从第N个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td></tr><tr><td>- M</td><td>第1个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td></tr></tbody></table><p>结合下列选项将字段指定为某个范围内的字节或字符 ：</p><ul><li>-b ：表示字节</li><li>-c ：表示字符</li><li>-f ：用于定义字段</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat range_fields.txt</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印第1个到第5个字符：</span></span><br><span class="line">$ cut -c1-5 range_fields.txt</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line"><span class="comment"># 打印前2个字符：</span></span><br><span class="line">$ cut range_fields.txt -c -2</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br></pre></td></tr></table></figure><h3 id="4-4-sed-进行文本替换"><a href="#4-4-sed-进行文本替换" class="headerlink" title="4.4 sed 进行文本替换"></a>4.4 sed 进行文本替换</h3><p>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-e &lt;script&gt;<span class="comment"># 以选项中指定的script来处理输入的文本文件</span></span><br><span class="line">-f &lt;script&gt;<span class="comment"># 以选项中指定的script文件来处理输入的文本文件</span></span><br><span class="line">-h<span class="comment"># 显示帮助</span></span><br><span class="line">-n<span class="comment"># 仅显示script处理后的结果</span></span><br><span class="line">-V<span class="comment"># 显示版本信息</span></span><br></pre></td></tr></table></figure><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a\ <span class="comment"># 在当前行下面插入文本。</span></span><br><span class="line">i\ <span class="comment"># 在当前行上面插入文本。</span></span><br><span class="line">c\ <span class="comment"># 把选定的行改为新的文本。 </span></span><br><span class="line">d <span class="comment"># 删除，删除选择的行。 </span></span><br><span class="line">D <span class="comment"># 删除模板块的第一行。</span></span><br><span class="line">s <span class="comment"># 替换指定字符 h 拷贝模板块的内容到内存中的缓冲区。 </span></span><br><span class="line">H <span class="comment"># 追加模板块的内容到内存中的缓冲区。 </span></span><br><span class="line">g <span class="comment"># 获得内存缓冲区的内容，并替代当前模板块中的文本。 </span></span><br><span class="line">G <span class="comment"># 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 </span></span><br><span class="line">l <span class="comment"># 列表不能打印字符的清单。 </span></span><br><span class="line">n <span class="comment"># 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 </span></span><br><span class="line">N <span class="comment"># 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 </span></span><br><span class="line">p <span class="comment"># 打印模板块的行。 P(大写) 打印模板块的第一行。 </span></span><br><span class="line">q <span class="comment"># 退出Sed。 </span></span><br><span class="line">b lable <span class="comment"># 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 </span></span><br><span class="line">r file <span class="comment"># 从file中读行。 </span></span><br><span class="line">t label <span class="comment"># if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 </span></span><br><span class="line">T label <span class="comment"># 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span></span><br><span class="line">w file <span class="comment"># 写并追加模板块到file末尾。 </span></span><br><span class="line">W file <span class="comment"># 写并追加模板块的第一行到file末尾。 </span></span><br><span class="line">! <span class="comment"># 表示后面的命令对所有没有被选定的行发生作用。 </span></span><br><span class="line">= <span class="comment"># 打印当前行号码。 </span></span><br><span class="line"><span class="comment"># 把注释扩展到下一个换行符以前。</span></span><br></pre></td></tr></table></figure><p>sed 替换标记：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g <span class="comment"># 表示行内全面替换。</span></span><br><span class="line">p <span class="comment"># 表示打印行。 </span></span><br><span class="line">w <span class="comment"># 表示把行写入一个文件。 </span></span><br><span class="line">x <span class="comment"># 表示互换模板块中的文本和缓冲区中的文本。 </span></span><br><span class="line">y <span class="comment"># 表示把一个字符翻译为另外的字符（但是不用于正则表达式） </span></span><br><span class="line">\1 <span class="comment"># 子串匹配标记 </span></span><br><span class="line">&amp; <span class="comment"># 已匹配字符串标记</span></span><br></pre></td></tr></table></figure><p>sed 元字符集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">^ <span class="comment"># 匹配行开始，如：/^sed/匹配所有以sed开头的行。</span></span><br><span class="line">$ <span class="comment"># 匹配行结束，如：/sed$/匹配所有以sed结尾的行。 </span></span><br><span class="line">. <span class="comment"># 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 </span></span><br><span class="line">* <span class="comment"># 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 </span></span><br><span class="line">[] <span class="comment"># 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 </span></span><br><span class="line">[^] <span class="comment"># 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/ 匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</span></span><br><span class="line">\(..\) <span class="comment"># 匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。 </span></span><br><span class="line">&amp; <span class="comment"># 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 </span></span><br><span class="line">\&lt;  <span class="comment"># 匹配单词的开始，如:/\&lt;love/匹配包含以开头的单词的行。</span></span><br><span class="line">\&gt;<span class="comment"># 匹配单词的结束，如:/love\&gt;/匹配包含以love结尾的单词的行。</span></span><br><span class="line">x\&#123;m\&#125; <span class="comment"># 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。 </span></span><br><span class="line">x\&#123;m,\&#125; <span class="comment"># 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。 </span></span><br><span class="line">x\&#123;m,n\&#125; <span class="comment"># 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed可以替换给定文本中的字符串。</span></span><br><span class="line">$ sed <span class="string">'s/pattern/replace_string/'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要在替换的同时保存更改，可以使用-i选项</span></span><br><span class="line">$ sed -i <span class="string">'s/text/replace/'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后缀/g意味着sed会替换每一处匹配。但是有时候我们只需要从第n处匹配开始替换。对此，可以使用/Ng选项。</span></span><br><span class="line">$ sed <span class="string">'s/pattern/replace_string/g'</span> file</span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/2g'</span></span><br><span class="line">thisTHISTHISTHIS</span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/3g'</span></span><br><span class="line">thisthisTHISTHIS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符/在sed中被作为定界符使用。我们可以像下面一样使用任意的定界符：</span></span><br><span class="line">$ sed <span class="string">'s:text:replace:g'</span></span><br><span class="line">$ sed <span class="string">'s|text|replace|g'</span></span><br><span class="line"><span class="comment"># 当定界符出现在样式内部时，我们必须用前缀\对它进行转义：</span></span><br><span class="line">$ sed <span class="string">'s|te\|xt|replace|g'</span></span><br><span class="line"><span class="comment"># \|是一个出现在样式内部并经过转义的定界符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除空白行</span></span><br><span class="line">$ sed <span class="string">'/^$/d'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已匹配字符串标记（&amp;）在sed中，我们可以用 &amp;标记匹配样式的字符串，这样就能够在替换字符串时使用已匹配的内容。</span></span><br><span class="line">$ <span class="built_in">echo</span> this is an example | sed <span class="string">'s/\w\+/[&amp;]/g'</span></span><br><span class="line">[this] [is] [an] [example]</span><br><span class="line"><span class="comment"># 正则表达式 \w\+ 匹配每一个单词，然后我们用[&amp;]替换它。 &amp; 对应于之前所匹配到的单词。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合多个表达式</span></span><br><span class="line">$ sed <span class="string">'expression'</span> | sed <span class="string">'expression'</span></span><br><span class="line"><span class="comment"># 它等价于</span></span><br><span class="line">$ sed <span class="string">'expression; expression'</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ sed -e <span class="string">'expression'</span> -e expression<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 引用。sed表达式通常用单引号来引用。双引号会通过对表达式求值来对其进行扩展。</span></span><br><span class="line"><span class="string">$ text=hello</span></span><br><span class="line"><span class="string">$ echo hello world | sed "s/$text/HELLO/"</span></span><br><span class="line"><span class="string">HELLO world</span></span><br></pre></td></tr></table></figure><h3 id="4-5-awk-进行高级文本处理"><a href="#4-5-awk-进行高级文本处理" class="headerlink" title="4.5 awk 进行高级文本处理"></a>4.5 awk 进行高级文本处理</h3><h4 id="4-5-1-awk-常用命令选项"><a href="#4-5-1-awk-常用命令选项" class="headerlink" title="4.5.1 awk 常用命令选项"></a>4.5.1 awk 常用命令选项</h4><ul><li><code>-F fs</code>        fs指定输入分隔符，fs可以是字符串或正则表达式，如<code>-F:</code><ul><li><code>-v var=value</code>   赋值一个用户定义变量，将外部变量传递给awk </li></ul></li><li><code>-f scripfile</code>      从脚本文件中读取awk命令 </li><li><code>-m[fr] val</code>          对val值设置内在限制，<code>-mf</code> 选项限制分配给val的最大块数目；<code>-mr</code> 选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li></ul><h4 id="4-5-2-awk-脚本基本结构"><a href="#4-5-2-awk-脚本基本结构" class="headerlink" title="4.5.2 awk 脚本基本结构"></a>4.5.2 awk 脚本基本结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; print "start" &#125; pattern&#123; commands &#125; END&#123; print "end" &#125;'</span> file</span><br><span class="line"><span class="comment"># 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;'</span> filename </span><br><span class="line">$ awk <span class="string">"BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;"</span> filename</span><br></pre></td></tr></table></figure><h4 id="4-5-3-awk-的工作原理"><a href="#4-5-3-awk-的工作原理" class="headerlink" title="4.5.3 awk 的工作原理"></a>4.5.3 awk 的工作原理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;'</span></span><br></pre></td></tr></table></figure><ul><li>第一步：执行 <code>BEGIN{ commands }</code> 语句块中的语句</li><li>第二步：从文件或标准输入(stdin)读取一行，然后执行 <code>pattern{ commands }</code> 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕</li><li>第三步：当读至输入流末尾时，执行 <code>END{ commands }</code> 语句块</li></ul><h4 id="4-5-4-awk-内置变量（预定义变量）"><a href="#4-5-4-awk-内置变量（预定义变量）" class="headerlink" title="4.5.4 awk 内置变量（预定义变量）"></a>4.5.4 awk 内置变量（预定义变量）</h4><p><strong>说明：</strong>  <code>[A][N][P][G]</code>表示第一个支持变量的工具，<code>[A]=awk</code>、<code>[N]=nawk</code>、<code>[P]=POSIXawk</code>、<code>[G]=gawk</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$n</span> <span class="comment"># 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 </span></span><br><span class="line"><span class="variable">$0</span> <span class="comment"># 这个变量包含执行过程中当前行的文本内容。 </span></span><br><span class="line">[N] ARGC <span class="comment"># 命令行参数的数目。 </span></span><br><span class="line">[G] ARGIND <span class="comment"># 命令行中当前文件的位置（从0开始算）。 </span></span><br><span class="line">[N] ARGV <span class="comment"># 包含命令行参数的数组。 </span></span><br><span class="line">[G] CONVFMT <span class="comment"># 数字转换格式（默认值为%.6g）。 </span></span><br><span class="line">[P] ENVIRON <span class="comment"># 环境变量关联数组。 </span></span><br><span class="line">[N] ERRNO <span class="comment"># 最后一个系统错误的描述。 </span></span><br><span class="line">[G] FIELDWIDTHS <span class="comment"># 字段宽度列表（用空格键分隔）。 </span></span><br><span class="line">[A] FILENAME <span class="comment"># 当前输入文件的名。 </span></span><br><span class="line">[P] FNR <span class="comment"># 同NR，但相对于当前文件。 </span></span><br><span class="line">[A] FS <span class="comment"># 字段分隔符（默认是任何空格）。 </span></span><br><span class="line">[G] IGNORECASE <span class="comment"># 如果为真，则进行忽略大小写的匹配。 </span></span><br><span class="line">[A] NF <span class="comment"># 表示字段数，在执行过程中对应于当前的字段数。 </span></span><br><span class="line">[A] NR <span class="comment"># 表示记录数，在执行过程中对应于当前的行号。 </span></span><br><span class="line">[A] OFMT <span class="comment"># 数字的输出格式（默认值是%.6g）。 </span></span><br><span class="line">[A] OFS <span class="comment"># 输出字段分隔符（默认值是一个空格）。 </span></span><br><span class="line">[A] ORS <span class="comment"># 输出记录分隔符（默认值是一个换行符）。 </span></span><br><span class="line">[A] RS <span class="comment"># 记录分隔符（默认是一个换行符）。 </span></span><br><span class="line">[N] RSTART <span class="comment"># 由match函数所匹配的字符串的第一个位置。 </span></span><br><span class="line">[N] RLENGTH <span class="comment"># 由match函数所匹配的字符串的长度。 </span></span><br><span class="line">[N] SUBSEP <span class="comment"># 数组下标分隔符（默认值是34）。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3nline2 f4 f5nline3 f6 f7"</span> | awk <span class="string">'&#123;print "Line No:"NR", No of fields:"NF, "$0="$0, "$1="$1, "$2="$2, "$3="$3&#125;'</span> </span><br><span class="line">Line No:1, No of fields:3 <span class="variable">$0</span>=line1 f2 f3 <span class="variable">$1</span>=line1 <span class="variable">$2</span>=f2 <span class="variable">$3</span>=f3 </span><br><span class="line">Line No:2, No of fields:3 <span class="variable">$0</span>=line2 f4 f5 <span class="variable">$1</span>=line2 <span class="variable">$2</span>=f4 <span class="variable">$3</span>=f5 </span><br><span class="line">Line No:3, No of fields:3 <span class="variable">$0</span>=line3 f6 f7 <span class="variable">$1</span>=line3 <span class="variable">$2</span>=f6 <span class="variable">$3</span>=f7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3n line2 f4 f5"</span> | awk <span class="string">'&#123;print $NF&#125;'</span> </span><br><span class="line">f3</span><br><span class="line">f5</span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3n line2 f4 f5"</span> | awk <span class="string">'&#123;print $(NF-1)&#125;'</span> </span><br><span class="line">f2 </span><br><span class="line">f4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每一行的第二和第三个字段：</span></span><br><span class="line">$ awk <span class="string">'&#123; print $2,$3 &#125;'</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件中的行数：</span></span><br><span class="line">$ awk <span class="string">'END&#123; print NR &#125;'</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个每一行中第一个字段值累加的例子：</span></span><br><span class="line">$ seq 5 | awk <span class="string">'BEGIN&#123; sum=0; print "总和：" &#125; &#123; print $1"+"; sum+=$1 &#125; END&#123; print "等于"; print sum &#125;'</span> </span><br><span class="line">总和： </span><br><span class="line">1+ </span><br><span class="line">2+ </span><br><span class="line">3+ </span><br><span class="line">4+ </span><br><span class="line">5+ </span><br><span class="line">等于 </span><br><span class="line">15</span><br></pre></td></tr></table></figure><h4 id="4-5-5-将外部变量值传递给awk"><a href="#4-5-5-将外部变量值传递给awk" class="headerlink" title="4.5.5 将外部变量值传递给awk"></a>4.5.5 将外部变量值传递给awk</h4><p>借助 <code>-v</code> 选项，可以将外部值（并非来自stdin）传递给awk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ VAR=10000 </span><br><span class="line">$ <span class="built_in">echo</span> | awk -v VARIABLE=<span class="variable">$VAR</span> <span class="string">'&#123; print VARIABLE &#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种传递外部变量方法：</span></span><br><span class="line">$ var1=<span class="string">"aaa"</span> </span><br><span class="line">$ var2=<span class="string">"bbb"</span> </span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当输入来自于文件时使用：</span></span><br><span class="line">$ awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span> filename</span><br></pre></td></tr></table></figure><h4 id="4-5-6-awk-运算与判断"><a href="#4-5-6-awk-运算与判断" class="headerlink" title="4.5.6 awk 运算与判断"></a>4.5.6 awk 运算与判断</h4><p><strong>算数运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+ -</td><td>加、减</td></tr><tr><td>* / &amp;</td><td>乘，除与求余</td></tr><tr><td>+ - !</td><td>一元加、减和逻辑非</td></tr><tr><td>^ ***</td><td>求幂</td></tr><tr><td>++ –</td><td>增加或减少，作为前缀或后缀</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";print a++,++a;&#125;'</span> </span><br><span class="line">0 2</span><br></pre></td></tr></table></figure><p style="color=red">**注意：**所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</p><p><strong>赋值运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>= += -= <em>= /= %= ^= *</em>=</td><td>赋值语句</td></tr></tbody></table><p><strong>逻辑运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>||</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);&#125;'</span></span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><p><strong>正则运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>~  ~!</td><td>匹配正则表达式和不匹配正则表达式</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="100testa";if(a ~ /^100*/)&#123;print "ok";&#125;&#125;'</span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><strong>关系运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&lt;  &lt;=  &gt;  &gt;=  !=  ==</td><td>关系运算符</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a=11;if(a &gt;= 9)&#123;print "ok";&#125;&#125;'</span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p style="color=red">**注意：**>  < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。</p><p><strong>其他运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>字段引用</td></tr><tr><td>空格</td><td>字符串连接符</td></tr><tr><td>? :</td><td>C条件表达式</td></tr><tr><td>in</td><td>数组中是否存在某键值</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";print a=="b"?"ok":"err";&#125;'</span> </span><br><span class="line">ok </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";arr[0]="b";arr[1]="c";print (a in arr);&#125;'</span> </span><br><span class="line">0 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";arr[0]="b";arr["b"]="c";print (a in arr);&#125;'</span> </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>运算级优先级表：</p><table><thead><tr><th>级别</th><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>=, +=, -=, *=, /=, %=, &amp;=, ^=, |=, &lt;&lt;=, &gt;&gt;=</td><td>赋值、运算</td></tr><tr><td>2</td><td>||</td><td>逻辑或</td></tr><tr><td>3</td><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>4</td><td>|</td><td>按位或</td></tr><tr><td>5</td><td>^</td><td>按位异或</td></tr><tr><td>6</td><td>&amp;</td><td>按位与</td></tr><tr><td>7</td><td>==, !=</td><td>等于、不等于</td></tr><tr><td>8</td><td>&lt;=, &gt;=, &lt;, &gt;</td><td>小于等于、大于等于、小于、大于</td></tr><tr><td>9</td><td>&lt;&lt;, &gt;&gt;</td><td>按位左移，按位右移</td></tr><tr><td>10</td><td>+, -</td><td>加、减</td></tr><tr><td>11</td><td>*, /, %</td><td>乘、除、取模</td></tr><tr><td>12</td><td>!, ~</td><td>逻辑非、按位取反或补码</td></tr><tr><td>13</td><td>-, +</td><td>正、负</td></tr></tbody></table><p>级别越高越优先</p><h4 id="4-5-7-awk-高级输入输出"><a href="#4-5-7-awk-高级输入输出" class="headerlink" title="4.5.7 awk 高级输入输出"></a>4.5.7 awk 高级输入输出</h4><p><strong>读取下一条记录：</strong></p><p>awk中 <code>next</code> 语句使用：在循环逐行匹配，如果遇到 <code>next</code>，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。net语句一般用于多行合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt </span><br><span class="line">a </span><br><span class="line">b </span><br><span class="line">c </span><br><span class="line">d </span><br><span class="line">e </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;'</span> text.txt </span><br><span class="line">2 b </span><br><span class="line">4 d</span><br></pre></td></tr></table></figure><p>当记录行号除以2余1，就跳过当前行。下面的 <code>print NR,$0</code> 也不会执行。下一行开始，程序有开始判断 <code>NR%2</code> 值。这个时候记录行号是 <code>：2</code>  ，就会执行下面语句块：<code>&#39;print NR,$0&#39;</code> </p><p>分析发现需要将包含有 “web” 行进行跳过，然后需要将内容与下面行合并为一行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt </span><br><span class="line">web01[192.168.2.100] </span><br><span class="line">httpd ok </span><br><span class="line">tomcat ok </span><br><span class="line">sendmail ok </span><br><span class="line">web02[192.168.2.101] </span><br><span class="line">httpd ok </span><br><span class="line">postfix ok </span><br><span class="line">web03[192.168.2.102] </span><br><span class="line">mysqld ok </span><br><span class="line">httpd ok </span><br><span class="line">0 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'/^web/&#123;T=$0;next;&#125;&#123;print T":t"$0;&#125;'</span> test.txt </span><br><span class="line">web01[192.168.2.100]: httpd ok </span><br><span class="line">web01[192.168.2.100]: tomcat ok </span><br><span class="line">web01[192.168.2.100]: sendmail ok </span><br><span class="line">web02[192.168.2.101]: httpd ok </span><br><span class="line">web02[192.168.2.101]: postfix ok </span><br><span class="line">web03[192.168.2.102]: mysqld ok </span><br><span class="line">web03[192.168.2.102]: httpd ok</span><br></pre></td></tr></table></figure><p><strong>简单地读取一条记录：</strong></p><p><code>awk getline</code> 用法：输出重定向需用到 <code>getline函数</code>。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。</p><p style="color=red">如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。 </p><p></p><blockquote><p>getline语法：getline var，变量var包含了特定行的内容。 </p></blockquote><p>awk getline从整体上来说，用法说明：</p><ul><li><strong>当其左右<p style="color=red">无</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline作用于当前文件，读入当前文件的第一行给其后跟的变量 <code>var</code> 或 <code>$0</code>（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。</li><li><strong>当其左右<p style="color=red">有</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; "date" | getline out; print out &#125;'</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，split函数把变量out转化成数组mon，然后打印数组mon的第二个元素：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; "date" | getline out; split(out,mon); print mon[2] &#125;'</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; while( "ls" | getline) print &#125;'</span></span><br></pre></td></tr></table></figure><p><strong>关闭文件：</strong></p><p>awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(<span class="string">"filename"</span>)</span><br></pre></td></tr></table></figure><p>filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。</p><p><strong>输出到一个文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt; "datafile"&#125;'</span></span><br><span class="line">或 </span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt;&gt; "datafile"&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="4-5-8-设置字段定界符"><a href="#4-5-8-设置字段定界符" class="headerlink" title="4.5.8 设置字段定界符"></a>4.5.8 设置字段定界符</h4><p style="color=red">默认的字段定界符是空格</p>，可以使用 `-F "定界符"` 明确指定一个定界符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F: <span class="string">'&#123; print $NF &#125;'</span> /etc/passwd </span><br><span class="line">或 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123; FS=":" &#125; &#123; print $NF &#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>在 <code>BEGIN语句块</code> 中则可以用 <code>OFS=“定界符”</code> 设置输出字段的定界符。</p><h4 id="4-5-9-流程控制语句"><a href="#4-5-9-流程控制语句" class="headerlink" title="4.5.9 流程控制语句"></a>4.5.9 流程控制语句</h4><p><strong>条件判断语句：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100; </span></span><br><span class="line"><span class="string">if(test&gt;90)&#123; </span></span><br><span class="line"><span class="string">print "very good"; </span></span><br><span class="line"><span class="string">&#125; else if(test&gt;60)&#123; </span></span><br><span class="line"><span class="string">print "good"; </span></span><br><span class="line"><span class="string">&#125; else&#123; </span></span><br><span class="line"><span class="string">print "no pass"; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">very good</span><br></pre></td></tr></table></figure><p>每条命令语句后面可以用 <code>;</code> </p><p style="color=red">分号</p>结尾。<p></p><p><strong>循环语句：</strong></p><p>while语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">while(i&lt;=test)&#123; </span></span><br><span class="line"><span class="string">total+=i; i++; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>for循环：</p><p>格式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(k in ENVIRON)&#123; </span></span><br><span class="line"><span class="string">print k"="ENVIRON[k]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line">TERM=linux </span><br><span class="line">G_BROKEN_FILENAMES=1 </span><br><span class="line">SHLVL=1 </span><br><span class="line"><span class="built_in">pwd</span>=/root/text </span><br><span class="line">... </span><br><span class="line">logname=root </span><br><span class="line">HOME=/root </span><br><span class="line">SSH_CLIENT=192.168.1.21 53087 22</span><br></pre></td></tr></table></figure><p><strong>注：</strong>ENVIRON是awk常量，是子典型数组。</p><p>格式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">for(i=0;i&lt;=100;i++)&#123; </span></span><br><span class="line"><span class="string">total+=i; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>do循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">i=0; </span></span><br><span class="line"><span class="string">do &#123;</span></span><br><span class="line"><span class="string">total+=i;i++;</span></span><br><span class="line"><span class="string">&#125; while(i&lt;=100) </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p><strong>其他语句：</strong></p><ul><li><strong>break</strong>          当 break 语句用于 while 或 for 语句时，导致退出程序循环</li><li><strong>continue</strong>       当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代</li><li><strong>next</strong>               能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程</li><li><strong>exit</strong>                 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行</li></ul><h4 id="4-5-10-数组应用"><a href="#4-5-10-数组应用" class="headerlink" title="4.5.10 数组应用"></a>4.5.10 数组应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到数组长度</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";lens=split(info,tA," ");print length(tA),lens;&#125;'</span> </span><br><span class="line">4 4</span><br><span class="line"><span class="comment"># length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># asort对数组进行排序，返回数组长度。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";split(info,tA," ");print asort(tA);&#125;'</span> </span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组内容（无序，有序输出）：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";split(info,tA," ");for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">4 <span class="built_in">test</span> </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line"></span><br><span class="line"><span class="comment"># for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";tlen=split(info,tA," ");for(k=1;k&lt;=tlen;k++)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line">4 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 注意：数组下标是从1开始，与C数组不一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断键值存在以及删除键值：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";if( "c" in tB)&#123;print "ok";&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;'</span> </span><br><span class="line">a a1 </span><br><span class="line">b b1</span><br><span class="line"><span class="comment"># 删除键值： </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";delete tB["a"];for(k in tB)&#123;print k,tB[k];&#125;&#125;'</span> </span><br><span class="line">b b1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维、多维数组使用</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(i=1;i&lt;=9;i++)&#123; </span></span><br><span class="line"><span class="string">for(j=1;j&lt;=9;j++)&#123; </span></span><br><span class="line"><span class="string">tarr[i,j]=i*j; </span></span><br><span class="line"><span class="string">print i,"*",j,"=",tarr[i,j]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line">1 * 1 = 1 </span><br><span class="line">1 * 2 = 2 </span><br><span class="line">1 * 3 = 3 </span><br><span class="line">1 * 4 = 4 </span><br><span class="line">1 * 5 = 5 </span><br><span class="line">1 * 6 = 6 </span><br><span class="line">... </span><br><span class="line">9 * 6 = 54 </span><br><span class="line">9 * 7 = 63 </span><br><span class="line">9 * 8 = 72 </span><br><span class="line">9 * 9 = 81</span><br><span class="line"><span class="comment"># 可以通过array[k,k2]引用获得数组内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方法：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(i=1;i&lt;=9;i++)&#123; </span></span><br><span class="line"><span class="string">for(j=1;j&lt;=9;j++)&#123; </span></span><br><span class="line"><span class="string">tarr[i,j]=i*j; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">for(m in tarr)&#123; </span></span><br><span class="line"><span class="string">split(m,tarr2,SUBSEP); print tarr2[1],"*",tarr2[2],"=",tarr[m]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="4-5-11-内置函数"><a href="#4-5-11-内置函数" class="headerlink" title="4.5.11 内置函数"></a>4.5.11 内置函数</h4><p>awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数。</p><p><strong>算数函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>atan2( y, x )</td><td>返回 y/x 的反正切</td></tr><tr><td>cos( x )</td><td>返回 x 的余弦；x 是弧度</td></tr><tr><td>sin( x )</td><td>返回 x 的正弦；x 是弧度</td></tr><tr><td>exp( x )</td><td>返回 x 幂函数</td></tr><tr><td>log( x )</td><td>返回 x 的自然对数</td></tr><tr><td>sqrt( x )</td><td>返回 x 平方根</td></tr><tr><td>int( x )</td><td>返回 x 的截断至整数的值</td></tr><tr><td>rand( )</td><td>返回任意数字 n，其中 0 &lt;= n &lt; 1</td></tr><tr><td>srand( [expr] )</td><td>将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;OFMT="%.3f";fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;&#125;'</span> </span><br><span class="line">0.841 22026.466 2.303 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得随机数：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">78 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">31 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">41</span><br></pre></td></tr></table></figure><p><strong>字符串函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>gsub( Ere, Repl, [ In ] )</td><td>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行</td></tr><tr><td>sub( Ere, Repl, [ In ] )</td><td>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）</td></tr><tr><td>index( String1, String2 )</td><td>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）</td></tr><tr><td>length [(String)]</td><td>返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td></tr><tr><td>blength [(String)]</td><td>返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td></tr><tr><td>substr( String, M, [ N ] )</td><td>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度</td></tr><tr><td>match( String, Ere )</td><td>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）</td></tr><tr><td>split( String, A, [Ere] )</td><td>将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建</td></tr><tr><td>tolower( String )</td><td>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td></tr><tr><td>toupper( String )</td><td>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td></tr><tr><td>sprintf(Format, Expr, Expr, . . . )</td><td>根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串</td></tr></tbody></table><p><strong>注：</strong>Ere都可以是正则表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gsub,sub使用 </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";gsub(/[0-9]+/,"!",info);print info&#125;'</span> </span><br><span class="line">this is a <span class="built_in">test</span>!<span class="built_in">test</span>!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找字符串（index使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print index(info,"test")?"ok":"no found";&#125;'</span> </span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式匹配查找(match使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print match(info,/[0-9]+/)?"ok":"no found";&#125;'</span> </span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取字符串(substr使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print substr(info,4,10);&#125;'</span> </span><br><span class="line">s is a tes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串分割（split使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test";split(info,tA," ");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">4 </span><br><span class="line">4 <span class="built_in">test</span> </span><br><span class="line">1 this </span><br><span class="line">2 is </span><br><span class="line">3 a</span><br></pre></td></tr></table></figure><p><strong>格式化字符串输出（sprintf使用）</strong> </p><p>格式化字符串格式：</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%d</td><td>十进制有符号整数</td></tr><tr><td>%u</td><td>十进制无符号整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%c</td><td>单个字符</td></tr><tr><td>%p</td><td>指针的值</td></tr><tr><td>%e</td><td>指数形式的浮点数</td></tr><tr><td>%x</td><td>%X 无符号以十六进制表示的整数</td></tr><tr><td>%o</td><td>无符号以八进制表示的整数</td></tr><tr><td>%g</td><td>自动选择合适的表示法</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;n1=124.113;n2=-1.224;n3=1.2345; printf("%.2f,%.2u,%.2g,%X,%on",n1,n2,n3,n1,n1);&#125;'</span> </span><br><span class="line">124.11,18446744073709551615,1.2,7C,174</span><br></pre></td></tr></table></figure><p><strong>一般函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>close( Expression )</td><td>用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的</td></tr><tr><td>system(command )</td><td>执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程</td></tr><tr><td>Expression | getline [ Variable ]</td><td>从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td></tr><tr><td>getline [ Variable ] &lt; Expression</td><td>从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td></tr><tr><td>getline [ Variable ]</td><td>将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开外部文件（close用法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;while("cat /etc/passwd"|getline)&#123;print $0;&#125;;close("/etc/passwd");&#125;'</span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐行读取外部文件(getline使用方法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;while(getline &lt; "/etc/passwd")&#123;print $0;&#125;;close("/etc/passwd");&#125;'</span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin </span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;print "Enter your name:";getline name;print name;&#125;'</span> </span><br><span class="line">Enter your name: </span><br><span class="line">chengmo </span><br><span class="line">chengmo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用外部应用程序(system使用方法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;b=system("ls -al");print b;&#125;'</span> </span><br><span class="line">total 42092 </span><br><span class="line">drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 . </span><br><span class="line">drwxr-xr-x 95 root root 4096 10-08 14:01 .. </span><br><span class="line"><span class="comment"># b返回值，是执行结果。</span></span><br></pre></td></tr></table></figure><p><strong>时间函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>函数名</td><td>说明</td></tr><tr><td>mktime( YYYY MM dd HH MM ss[ DST])</td><td>生成时间格式</td></tr><tr><td>strftime([format [, timestamp]])</td><td>格式化时间输出，将时间戳转为时间字符串 具体格式，见下表.</td></tr><tr><td>systime()</td><td>得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建指定时间(mktime使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp=mktime("2001 01 01 12 12 12");print strftime("%c",tstamp);&#125;'</span> </span><br><span class="line">2001年01月01日 星期一 12时12分12秒 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=mktime("2001 02 01 0 0 0");print tstamp2-tstamp1;&#125;'</span> </span><br><span class="line">2634468 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 求2个时间段中间时间差，介绍了strftime使用方法 </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=systime();print tstamp2-tstamp1;&#125;'</span> </span><br><span class="line">308201392</span><br></pre></td></tr></table></figure><p>strftime日期和时间格式说明符</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%a</td><td>星期几的缩写（Sun）</td></tr><tr><td>%A</td><td>星期几的完整写法（Sunday）</td></tr><tr><td>%b</td><td>月名的缩写（Oct）</td></tr><tr><td>%B</td><td>月名的完整写法（October）</td></tr><tr><td>%c</td><td>本地日期和时间</td></tr><tr><td>%d</td><td>十进制日期</td></tr><tr><td>%D</td><td>日期 08/20/99</td></tr><tr><td>%e</td><td>日期，如果只有一位会补上一个空格</td></tr><tr><td>%H</td><td>用十进制表示24小时格式的时间</td></tr><tr><td>%I</td><td>用十进制表示12小时格式的时间</td></tr><tr><td>%j</td><td>从1月1日期一年中的第几天</td></tr><tr><td>%m</td><td>十进制表示的月份</td></tr><tr><td>%M</td><td>十进制表示的分钟</td></tr><tr><td>%p</td><td>12小时表示法（AM/PM）</td></tr><tr><td>%S</td><td>十进制表示的秒</td></tr><tr><td>%U</td><td>十进制表示的一年中的第几个星期（星期天作为一个星期的开始）</td></tr><tr><td>%w</td><td>十进制表示的星期几（星期天是0）</td></tr><tr><td>%W</td><td>十进制表示的一年中的第几个星期（星期一作为一个星期的开始）</td></tr><tr><td>%x</td><td>重新设置本地日期（08/20/99）</td></tr><tr><td>%X</td><td>重新设置本地时间（12 : 00 : 00）</td></tr><tr><td>%y</td><td>两位数字表示的年（99）</td></tr><tr><td>%Y</td><td>当前月份</td></tr><tr><td>%Z</td><td>时区（PDT）</td></tr><tr><td>%%</td><td>百分号（%）</td></tr></tbody></table><h3 id="4-6-find-对目录中的所有文件进行文本替换"><a href="#4-6-find-对目录中的所有文件进行文本替换" class="headerlink" title="4.6 find 对目录中的所有文件进行文本替换"></a>4.6 find 对目录中的所有文件进行文本替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有.cpp文件中的Copyright替换成Copyleft：</span></span><br><span class="line">$ find . -name *.cpp -print0 | xargs -I&#123;&#125; -0 sed -i <span class="string">'s/Copyright/Copyleft/g'</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-exec实现同样的效果：</span></span><br><span class="line">$ find . -name *.cpp -<span class="built_in">exec</span> sed -i <span class="string">'s/Copyright/Copyleft/g'</span> \&#123;\&#125; \;</span><br></pre></td></tr></table></figure><h2 id="5-一团乱麻"><a href="#5-一团乱麻" class="headerlink" title="5 一团乱麻"></a>5 一团乱麻</h2><h3 id="5-1-wget命令"><a href="#5-1-wget命令" class="headerlink" title="5.1 wget命令"></a>5.1 wget命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-a&lt;日志文件&gt;：<span class="comment"># 在指定的日志文件中记录资料的执行过程； </span></span><br><span class="line">-A&lt;后缀名&gt;： <span class="comment"># 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔； </span></span><br><span class="line">-b：   <span class="comment"># 进行后台的方式运行wget； </span></span><br><span class="line">-B&lt;连接地址&gt;：<span class="comment"># 设置参考的连接地址的基地地址； </span></span><br><span class="line">-c：   <span class="comment"># 继续执行上次终端的任务； </span></span><br><span class="line">-C&lt;标志&gt;： <span class="comment"># 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； </span></span><br><span class="line">-d：   <span class="comment"># 调试模式运行指令； </span></span><br><span class="line">-D&lt;域名列表&gt;：    <span class="comment"># 设置顺着的域名列表，域名之间用“，”分隔； </span></span><br><span class="line">-e&lt;指令&gt;： <span class="comment"># 作为文件“.wgetrc”中的一部分执行指定的指令； </span></span><br><span class="line">-h：   <span class="comment"># 显示指令帮助信息； </span></span><br><span class="line">-i&lt;文件&gt;： <span class="comment"># 从指定文件获取要下载的URL地址； </span></span><br><span class="line">-l&lt;目录列表&gt;：<span class="comment"># 设置顺着的目录列表，多个目录用“，”分隔； </span></span><br><span class="line">-L：   <span class="comment"># 仅顺着关联的连接； </span></span><br><span class="line">-r：   <span class="comment"># 递归下载方式； </span></span><br><span class="line">-nc：   <span class="comment"># 文件存在时，下载文件不覆盖原有文件； </span></span><br><span class="line">-nv：   <span class="comment"># 下载时只显示更新和出错信息，不显示指令的详细执行过程； </span></span><br><span class="line">-q：   <span class="comment"># 不显示指令执行过程； </span></span><br><span class="line">-nh：   <span class="comment"># 不查询主机名称； </span></span><br><span class="line">-v：   <span class="comment"># 显示详细执行过程； </span></span><br><span class="line">-V：   <span class="comment"># 显示版本信息； </span></span><br><span class="line">--passive-ftp：   <span class="comment"># 使用被动模式PASV连接FTP服务器； </span></span><br><span class="line">--follow-ftp：   <span class="comment"># 从HTML文件中下载FTP连接文件。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget下载单个文件 </span></span><br><span class="line">$ wget http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并以不同的文件名保存 </span></span><br><span class="line">$ wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># wget限速下载 </span></span><br><span class="line">$ wget --<span class="built_in">limit</span>-rate=300k http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用wget断点续传 </span></span><br><span class="line">$ wget -c http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用wget后台下载 </span></span><br><span class="line">$ wget -b http://www.linuxde.net/testfile.zip </span><br><span class="line">Continuing <span class="keyword">in</span> background, pid 1840. </span><br><span class="line">Output will be written to `wget-log<span class="string">'.</span></span><br><span class="line"><span class="string"># 对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载，你可以使用以下命令来察看下载进度： </span></span><br><span class="line"><span class="string">$ tail -f wget-log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 伪装代理名称下载 </span></span><br><span class="line"><span class="string">$ wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.linuxde.net/testfile.zip</span></span><br><span class="line"><span class="string"># 有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装。</span></span><br></pre></td></tr></table></figure><p><strong>测试下载链接：</strong></p><p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --spider URL</span><br></pre></td></tr></table></figure><p>如果下载链接正确，将会显示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spider mode enabled. Check if remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 200 OK </span><br><span class="line">Length: unspecified [text/html] </span><br><span class="line">Remote file exists and could contain further links, </span><br><span class="line">but recursion is disabled -- not retrieving.</span><br></pre></td></tr></table></figure><p>这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget --spider url </span><br><span class="line">Spider mode enabled. Check <span class="keyword">if</span> remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 404 Not Found </span><br><span class="line">Remote file does not exist -- broken link!!!</span><br></pre></td></tr></table></figure><p>你可以在以下几种情况下使用–spider参数：</p><ul><li>定时下载之前进行检查</li><li>间隔检测网站是否可用</li><li>检查网站页面的死链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加重试次数 </span></span><br><span class="line">$ wget --tries=40 URL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载多个文件 </span></span><br><span class="line">$ wget -i filelist.txt </span><br><span class="line"><span class="comment"># 首先，保存一份下载链接文件： </span></span><br><span class="line">$ cat &gt; filelist.txt </span><br><span class="line">url1 </span><br><span class="line">url2 </span><br><span class="line">url3 </span><br><span class="line">url4 </span><br><span class="line"><span class="comment"># 接着使用这个文件和参数-i下载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤指定格式下载 </span></span><br><span class="line">$ wget --reject=gif ur </span><br><span class="line"><span class="comment"># 下载一个网站，但你不希望下载图片，可以使用这条命令。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把下载信息存入日志文件 </span></span><br><span class="line">$ wget -o download.log URL </span><br><span class="line"><span class="comment"># 不希望下载信息直接显示在终端而是在一个日志文件，可以使用。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制总下载文件大小 </span></span><br><span class="line">$ wget -Q5m -i filelist.txt </span><br><span class="line"><span class="comment"># 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</span></span><br></pre></td></tr></table></figure><p><strong>镜像网站：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --mirror -p --convert-links -P ./LOCAL URL</span><br></pre></td></tr></table></figure><p>下载整个网站到本地。</p><ul><li>–mirror 开户镜像下载</li><li>-p 下载所有为了html页面显示正常的文件</li><li>–convert-links 下载后，转换成本地的链接</li><li>-P ./LOCAL URL 保存所有文件和目录到本地指定目录</li></ul><p><strong>下载指定格式文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -A.pdf url</span><br></pre></td></tr></table></figure><p>可以在以下情况使用该功能：</p><ul><li>下载一个网站的所有图片</li><li>下载一个网站的所有视频</li><li>下载一个网站的所有PDF文件</li></ul><p><strong>FTP下载：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp-url </span><br><span class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><p>可以使用wget来完成ftp链接的下载。 </p><p>使用wget匿名ftp下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp-url</span><br></pre></td></tr></table></figure><p>使用wget用户名和密码认证的ftp下载： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><h3 id="5-2-curl-命令"><a href="#5-2-curl-命令" class="headerlink" title="5.2 curl 命令"></a>5.2 curl 命令</h3><p>常见参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-A/--user-agent &lt;string&gt;              <span class="comment"># 设置用户代理发送给服务器</span></span><br><span class="line">-b/--cookie &lt;name=string/file&gt;      <span class="comment"># cookie字符串或文件读取位置</span></span><br><span class="line">-c/--cookie-jar &lt;file&gt;                <span class="comment"># 操作结束后把cookie写入到这个文件中</span></span><br><span class="line">-C/--<span class="built_in">continue</span>-at &lt;offset&gt;             <span class="comment"># 断点续转</span></span><br><span class="line">-D/--dump-header &lt;file&gt;               <span class="comment"># 把header信息写入到该文件中</span></span><br><span class="line">-e/--referer                          <span class="comment"># 来源网址</span></span><br><span class="line">-f/--fail                             <span class="comment"># 连接失败时不显示http错误</span></span><br><span class="line">-o/--output                           <span class="comment"># 把输出写到该文件中</span></span><br><span class="line">-O/--remote-name                      <span class="comment"># 把输出写到该文件中，保留远程文件的文件名</span></span><br><span class="line">-r/--range &lt;range&gt;                    <span class="comment"># 检索来自HTTP/1.1或FTP服务器字节范围</span></span><br><span class="line">-s/--silent                           <span class="comment"># 静音模式。不输出任何东西</span></span><br><span class="line">-T/--upload-file &lt;file&gt;               <span class="comment"># 上传文件</span></span><br><span class="line">-u/--user &lt;user[:password]&gt;           <span class="comment"># 设置服务器的用户和密码</span></span><br><span class="line">-w/--write-out [format]               <span class="comment"># 什么输出完成后</span></span><br><span class="line">-x/--proxy &lt;host[:port]&gt;              <span class="comment"># 在给定的端口上使用HTTP代理</span></span><br><span class="line">-<span class="comment">#/--progress-bar                     # 进度条显示当前的传送状态</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不显示进度信息使用--silent选项。</span></span><br><span class="line">$ curl URL --silent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用选项 -O 将下载的数据写入到文件，必须使用文件的绝对地址：</span></span><br><span class="line">$ curl http://man.linuxde.net/text.iso --silent -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条：</span></span><br><span class="line">$ curl http://man.linuxde.net/test.iso -o filename.iso --progress</span><br><span class="line"><span class="comment">######################################### 100.0%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断点续传</span></span><br><span class="line">$ curl URL/File -C 偏移量 </span><br><span class="line"><span class="comment"># 偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -： </span></span><br><span class="line">$ curl -C -URL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--referer选项指定参照页字符串： </span></span><br><span class="line">$ curl --referer http://www.google.com http://man.linuxde.net </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl设置cookies 使用--cookie "COKKIES"选项来指定cookie，多个cookie使用分号分隔： </span></span><br><span class="line">$ curl http://man.linuxde.net --cookie <span class="string">"user=root;pass=123456"</span> </span><br><span class="line"><span class="comment"># 将cookie另存为一个文件，使用--cookie-jar选项： </span></span><br><span class="line">$ curl URL --cookie-jar cookie_file </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl设置用户代理字符串 有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用--user-agent或者-A选项：</span></span><br><span class="line">$ curl URL --user-agent <span class="string">"Mozilla/5.0"</span> curl URL -A <span class="string">"Mozilla/5.0"</span> </span><br><span class="line"><span class="comment"># 其他HTTP头部信息也可以使用curl来发送，使用-H"头部信息" 传递多个头部信息，例如： </span></span><br><span class="line">$ curl -H <span class="string">"Host:man.linuxde.net"</span> -H <span class="string">"accept-language:zh-cn"</span> URL </span><br><span class="line"></span><br><span class="line"><span class="comment"># curl的带宽控制和下载配额 使用--limit-rate限制curl的下载速度： </span></span><br><span class="line">$ curl URL --<span class="built_in">limit</span>-rate 50k </span><br><span class="line"><span class="comment"># 命令中用k（千字节）和m（兆字节）指定下载速度限制。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--max-filesize指定可下载的最大文件大小： </span></span><br><span class="line">$ curl URL --max-filesize bytes </span><br><span class="line"><span class="comment"># 如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl进行认证 使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码： </span></span><br><span class="line">$ curl -u user:<span class="built_in">pwd</span> http://man.linuxde.net </span><br><span class="line">$ curl -u user http://man.linuxde.net </span><br><span class="line"></span><br><span class="line"><span class="comment"># 只打印响应头部信息 通过-I或者-head可以只打印出HTTP头部信息： </span></span><br><span class="line">$ curl -I http://man.linuxde.net </span><br><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Server: nginx/1.2.5 </span><br><span class="line">date: Mon, 10 Dec 2012 09:24:34 GMT </span><br><span class="line">Content-Type: text/html; charset=UTF-8 </span><br><span class="line">Connection: keep-alive </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Pingback: http://man.linuxde.net/xmlrpc.php</span><br></pre></td></tr></table></figure><p>其他参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">-a/--append                    <span class="comment"># 上传文件时，附加到目标文件</span></span><br><span class="line">--anyauth                      <span class="comment"># 可以使用“任何”身份验证方法</span></span><br><span class="line">--basic                        <span class="comment"># 使用HTTP基本验证</span></span><br><span class="line">-B/--use-ascii                 <span class="comment"># 使用ASCII文本传输</span></span><br><span class="line">-d/--data &lt;data&gt;               <span class="comment"># HTTP POST方式传送数据</span></span><br><span class="line">--data-ascii &lt;data&gt;            <span class="comment"># 以ascii的方式post数据</span></span><br><span class="line">--data-binary &lt;data&gt;           <span class="comment"># 以二进制的方式post数据</span></span><br><span class="line">--negotiate                    <span class="comment"># 使用HTTP身份验证</span></span><br><span class="line">--digest                       <span class="comment"># 使用数字身份验证</span></span><br><span class="line">--<span class="built_in">disable</span>-eprt                 <span class="comment"># 禁止使用EPRT或LPRT</span></span><br><span class="line">--<span class="built_in">disable</span>-epsv                 <span class="comment"># 禁止使用EPSV</span></span><br><span class="line">--egd-file &lt;file&gt;              <span class="comment"># 为随机数据(SSL)设置EGD socket路径</span></span><br><span class="line">--tcp-nodelay                  <span class="comment"># 使用TCP_NODELAY选项</span></span><br><span class="line">-E/--cert &lt;cert[:passwd]&gt;      <span class="comment"># 客户端证书文件和密码 (SSL)</span></span><br><span class="line">--cert-type &lt;<span class="built_in">type</span>&gt;             <span class="comment"># 证书文件类型 (DER/PEM/ENG) (SSL)</span></span><br><span class="line">--key &lt;key&gt;                    <span class="comment"># 私钥文件名 (SSL)</span></span><br><span class="line">--key-type &lt;<span class="built_in">type</span>&gt;              <span class="comment"># 私钥文件类型 (DER/PEM/ENG) (SSL)</span></span><br><span class="line">--pass  &lt;pass&gt;                 <span class="comment"># 私钥密码 (SSL)</span></span><br><span class="line">--engine &lt;eng&gt;                 <span class="comment"># 加密引擎使用 (SSL). "--engine list" for list</span></span><br><span class="line">--cacert &lt;file&gt;                <span class="comment"># CA证书 (SSL)</span></span><br><span class="line">--capath &lt;directory&gt;           <span class="comment"># CA目   (made using c_rehash) to verify peer against (SSL)</span></span><br><span class="line">--ciphers &lt;list&gt;               <span class="comment"># SSL密码</span></span><br><span class="line">--compressed                   <span class="comment"># 要求返回是压缩的形势 (using deflate or gzip)</span></span><br><span class="line">--connect-timeout &lt;seconds&gt;    <span class="comment"># 设置最大请求时间</span></span><br><span class="line">--create-dirs                  <span class="comment"># 建立本地目录的目录层次结构</span></span><br><span class="line">--crlf                         <span class="comment"># 上传是把LF转变成CRLF</span></span><br><span class="line">--ftp-create-dirs              <span class="comment"># 如果远程目录不存在，创建远程目录</span></span><br><span class="line">--ftp-method [multicwd/nocwd/singlecwd]    <span class="comment"># 控制CWD的使用</span></span><br><span class="line">--ftp-pasv                     <span class="comment"># 使用 PASV/EPSV 代替端口</span></span><br><span class="line">--ftp-skip-pasv-ip             <span class="comment"># 使用PASV的时候,忽略该IP地址</span></span><br><span class="line">--ftp-ssl                      <span class="comment"># 尝试用 SSL/TLS 来进行ftp数据传输</span></span><br><span class="line">--ftp-ssl-reqd                 <span class="comment"># 要求用 SSL/TLS 来进行ftp数据传输</span></span><br><span class="line">-F/--form &lt;name=content&gt;       <span class="comment"># 模拟http表单提交数据</span></span><br><span class="line">-form-string &lt;name=string&gt;     <span class="comment"># 模拟http表单提交数据</span></span><br><span class="line">-g/--globoff                   <span class="comment"># 禁用网址序列和范围使用&#123;&#125;和[]</span></span><br><span class="line">-G/--get                       <span class="comment"># 以get的方式来发送数据</span></span><br><span class="line">-h/--<span class="built_in">help</span>                      <span class="comment"># 帮助</span></span><br><span class="line">-H/--header &lt;line&gt;             <span class="comment"># 自定义头信息传递给服务器</span></span><br><span class="line">--ignore-content-length        <span class="comment"># 忽略的HTTP头信息的长度</span></span><br><span class="line">-i/--include                   <span class="comment"># 输出时包括protocol头信息</span></span><br><span class="line">-I/--head                      <span class="comment"># 只显示文档信息</span></span><br><span class="line">-j/--junk-session-cookies      <span class="comment"># 读取文件时忽略session cookie</span></span><br><span class="line">--interface &lt;interface&gt;        <span class="comment"># 使用指定网络接口/地址</span></span><br><span class="line">--krb4 &lt;level&gt;                 <span class="comment"># 使用指定安全级别的krb4</span></span><br><span class="line">-k/--insecure                  <span class="comment"># 允许不使用证书到SSL站点</span></span><br><span class="line">-K/--config                    <span class="comment"># 指定的配置文件读取</span></span><br><span class="line">-l/--list-only                 <span class="comment"># 列出ftp目录下的文件名称</span></span><br><span class="line">--<span class="built_in">limit</span>-rate &lt;rate&gt;            <span class="comment"># 设置传输速度</span></span><br><span class="line">--<span class="built_in">local</span>-port&lt;NUM&gt;              <span class="comment"># 强制使用本地端口号</span></span><br><span class="line">-m/--max-time &lt;seconds&gt;        <span class="comment"># 设置最大传输时间</span></span><br><span class="line">--max-redirs &lt;num&gt;             <span class="comment"># 设置最大读取的目录数</span></span><br><span class="line">--max-filesize &lt;bytes&gt;         <span class="comment"># 设置最大下载的文件总量</span></span><br><span class="line">-M/--manual                    <span class="comment"># 显示全手动</span></span><br><span class="line">-n/--netrc                     <span class="comment"># 从netrc文件中读取用户名和密码</span></span><br><span class="line">--netrc-optional               <span class="comment"># 使用 .netrc 或者 URL来覆盖-n</span></span><br><span class="line">--ntlm                         <span class="comment"># 使用 HTTP NTLM 身份验证</span></span><br><span class="line">-N/--no-buffer                 <span class="comment"># 禁用缓冲输出</span></span><br><span class="line">-p/--proxytunnel               <span class="comment"># 使用HTTP代理</span></span><br><span class="line">--proxy-anyauth                <span class="comment"># 选择任一代理身份验证方法</span></span><br><span class="line">--proxy-basic                  <span class="comment"># 在代理上使用基本身份验证</span></span><br><span class="line">--proxy-digest                 <span class="comment"># 在代理上使用数字身份验证</span></span><br><span class="line">--proxy-ntlm                   <span class="comment"># 在代理上使用ntlm身份验证</span></span><br><span class="line">-P/--ftp-port &lt;address&gt;        <span class="comment"># 使用端口地址，而不是使用PASV</span></span><br><span class="line">-Q/--quote &lt;cmd&gt;               <span class="comment"># 文件传输前，发送命令到服务器</span></span><br><span class="line">--range-file                   <span class="comment"># 读取（SSL）的随机文件</span></span><br><span class="line">-R/--remote-time               <span class="comment"># 在本地生成文件时，保留远程文件时间</span></span><br><span class="line">--retry &lt;num&gt;                  <span class="comment"># 传输出现问题时，重试的次数</span></span><br><span class="line">--retry-delay &lt;seconds&gt;        <span class="comment"># 传输出现问题时，设置重试间隔时间</span></span><br><span class="line">--retry-max-time &lt;seconds&gt;     <span class="comment"># 传输出现问题时，设置最大重试时间</span></span><br><span class="line">-S/--show-error                <span class="comment"># 显示错误</span></span><br><span class="line">--socks4 &lt;host[:port]&gt;         <span class="comment"># 用socks4代理给定主机和端口</span></span><br><span class="line">--socks5 &lt;host[:port]&gt;         <span class="comment"># 用socks5代理给定主机和端口</span></span><br><span class="line">-t/--telnet-option &lt;OPT=val&gt;   <span class="comment"># Telnet选项设置</span></span><br><span class="line">--trace &lt;file&gt;                 <span class="comment"># 对指定文件进行debug</span></span><br><span class="line">--trace-ascii &lt;file&gt;           <span class="comment"># Like --跟踪但没有hex输出</span></span><br><span class="line">--trace-time                   <span class="comment"># 跟踪/详细输出时，添加时间戳</span></span><br><span class="line">--url &lt;URL&gt;                    <span class="comment"># Spet URL to work with</span></span><br><span class="line">-U/--proxy-user &lt;user[:password]&gt;  <span class="comment"># 设置代理用户名和密码</span></span><br><span class="line">-V/--version                   <span class="comment"># 显示版本信息</span></span><br><span class="line">-X/--request &lt;<span class="built_in">command</span>&gt;         <span class="comment"># 指定什么命令</span></span><br><span class="line">-y/--speed-time                <span class="comment"># 放弃限速所要的时间。默认为30</span></span><br><span class="line">-Y/--speed-limit               <span class="comment"># 停止传输速度的限制，速度时间'秒</span></span><br><span class="line">-z/--time-cond                 <span class="comment"># 传送时间设置</span></span><br><span class="line">-0/--http1.0                   <span class="comment"># 使用HTTP 1.0</span></span><br><span class="line">-1/--tlsv1                     <span class="comment"># 使用TLSv1（SSL）</span></span><br><span class="line">-2/--sslv2                     <span class="comment"># 使用SSLv2的（SSL）</span></span><br><span class="line">-3/--sslv3                     <span class="comment"># 使用的SSLv3（SSL）</span></span><br><span class="line">--3p-quote                     <span class="comment"># like -Q for the source URL for 3rd party transfer</span></span><br><span class="line">--3p-url                       <span class="comment"># 使用url，进行第三方传送</span></span><br><span class="line">--3p-user                      <span class="comment"># 使用用户名和密码，进行第三方传送</span></span><br><span class="line">-4/--ipv4                      <span class="comment"># 使用IP4</span></span><br><span class="line">-6/--ipv6                      <span class="comment"># 使用IP6</span></span><br></pre></td></tr></table></figure><h3 id="5-3-curl-wget两种方法模拟http的get-post请求"><a href="#5-3-curl-wget两种方法模拟http的get-post请求" class="headerlink" title="5.3 curl wget两种方法模拟http的get post请求"></a>5.3 curl wget两种方法模拟http的get post请求</h3><p><strong>get请求：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用curl命令：</span></span><br><span class="line">$ curl <span class="string">"http://www.baidu.com"</span>  <span class="comment"># 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span></span><br><span class="line">$ curl -i <span class="string">"http://www.baidu.com"</span>  <span class="comment"># 显示全部信息</span></span><br><span class="line">$ curl -l <span class="string">"http://www.baidu.com"</span> <span class="comment"># 只显示头部信息</span></span><br><span class="line">$ curl -v <span class="string">"http://www.baidu.com"</span> <span class="comment"># 显示get请求全过程解析</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget命令：</span></span><br><span class="line">$ wget <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure><p><strong>post请求：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用curl命令(通过-d参数，把访问参数放在里面)：</span></span><br><span class="line">$ curl -d <span class="string">"param1=value1&amp;param2=value2"</span> <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget命令：（--post-data参数来实现）</span></span><br><span class="line">$ wget --post-data <span class="string">'user=foo&amp;password=bar'</span>  http://server.com/auth.PHP</span><br></pre></td></tr></table></figure><h2 id="6-B计划"><a href="#6-B计划" class="headerlink" title="6 B计划"></a>6 B计划</h2><h3 id="6-1-用tar归档"><a href="#6-1-用tar归档" class="headerlink" title="6.1 用tar归档"></a>6.1 用tar归档</h3><p>tar支持的参数包括： <code>A</code>、 <code>c</code>、 <code>d</code>、 <code>r</code>、 <code>u</code>、 <code>x</code>、 <code>f</code> 和 <code>v</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用tar对文件进行归档：</span></span><br><span class="line">$ tar -cf output.tar file1 file2 file3 folder1 ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用选项-t列出归档文件中所包含的文件：</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要在归档或列出归档文件列表时获知更多的细节信息，可以使用-v或-vv参数</span></span><br><span class="line">$ $ tar -tvf archive.tar</span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file1</span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file2</span><br><span class="line"><span class="comment"># 文件名必须紧跟在-f之后，而且-f应该是选项中的最后一个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向归档文件中添加文件,追加选项-r</span></span><br><span class="line">$ tar -rvf original.tar new_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的方法列出归档文件中的内容：</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档文件中提取文件或文件夹, -x 表示提取</span></span><br><span class="line">$ tar -xf archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用选项-C来指定需要将文件提取到哪个目录：</span></span><br><span class="line">$ tar -xf archive.tar -C /path/to/extraction_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过将文件名指定为命令行参数来提取特定的文件：</span></span><br><span class="line">$ tar -xvf file.tar file1 file4</span><br><span class="line"><span class="comment"># 上面的命令只提取file1和file4，忽略其他文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在tar中使用stdin和stdout</span></span><br><span class="line">$ tar cvf - files/ | ssh user@example.com <span class="string">"tar xv -C Documents/"</span></span><br><span class="line"><span class="comment"># 在上面的例子中，对files目录中的内容进行了归档并输出到stdout（由'-'指明）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接两个归档文件, -A 选项轻松地合并多个tar文件</span></span><br><span class="line">$ tar -Af file1.tar file2.tar</span><br><span class="line"><span class="comment"># 查看内容，验证操作是否成功：</span></span><br><span class="line">$ tar -tvf file1.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过检查时间戳来更新归档文件中的内容</span></span><br><span class="line"><span class="comment"># 可以用更新选项-u指明：只有比归档文件中的同名文件更新时才会被添加。</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅当filea自上次被加入archive.tar后出现了变动才对其进行追加，可以使用：</span></span><br><span class="line">$ tar -uf archive.tar filea</span><br><span class="line"><span class="comment"># 如果两个filea的时间戳相同，则什么都不会发生。</span></span><br><span class="line"><span class="comment"># 可用touch命令修改文件的时间戳，然后再用tar命令：</span></span><br><span class="line">$ tar -uvvf archive.tar filea</span><br><span class="line">-rw-r--r-- slynux/slynux 0 2010-08-14 17:53 filea</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较归档文件与文件系统中的内容, 选项 -d 可以打印出两者之间的差别：</span></span><br><span class="line">$ tar -df archive.tar</span><br><span class="line">afile: Mod time differs</span><br><span class="line">afile: Size differs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档文件中删除文件, --delete选项从给定的归档文件中删除文件</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"><span class="comment"># 删除filea：</span></span><br><span class="line">$ tar --delete --file archive.tar filea</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">fileb</span><br><span class="line">filec</span><br></pre></td></tr></table></figure><p><strong>压缩tar归档文件：</strong></p><p>归档文件通常被压缩成下列格式之一： </p><ul><li>file.tar.gz </li><li>file.tar.bz2 </li><li>file.tar.lzma </li></ul><p>不同的tar选项可以用来指定不同的压缩格式： </p><ul><li>-j 指定bunzip2格式； </li><li>-z 指定gzip格式； </li><li>–lzma 指定lzma格式。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了让tar支持根据扩展名自动进行压缩，使用 -a或 --auto-compress选项：</span></span><br><span class="line">$ tar acvf archive.tar.gz filea fileb filec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档中排除部分文件,  --exclude [PATTERN]排除匹配通配符样式的文件</span></span><br><span class="line">$ tar -cf arch.tar * --exclude <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># 样式应该使用双引号来引用，避免shell对其进行扩展。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以将需要排除的文件列表放入文件中，同时配合选项 -X：</span></span><br><span class="line">$ cat list</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">$ tar -cf arch.tar * -X list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排除版本控制目录， 可以使用tar的 --exclude-vcs选项。例如：</span></span><br><span class="line">$ tar --exclude-vcs -czvvf source_code.tar.gz eye_of_gnome_svn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印总字节数，用–totals就可以在归档完成之后打印出总归档字节数：</span></span><br><span class="line">$ tar -cf arc.tar * --exclude <span class="string">"*.txt"</span> --totals</span><br><span class="line">Total bytes written: 20480 (20KiB, 12MiB/s)</span><br></pre></td></tr></table></figure><h3 id="6-2-用cpio归档"><a href="#6-2-用cpio归档" class="headerlink" title="6.2 用cpio归档"></a>6.2 用cpio归档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试文件：</span></span><br><span class="line">$ touch file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将测试文件按照下面的方法进行归档：</span></span><br><span class="line">$ <span class="built_in">echo</span> file1 file2 file3 | cpio -ov &gt; archive.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出cpio归档文件中的内容：</span></span><br><span class="line">$ cpio -it &lt; archive.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从cpio归档文件中提取文件：</span></span><br><span class="line">$ cpio -id &lt; archive.cpio</span><br></pre></td></tr></table></figure><p>对于归档命令： </p><ul><li>-o 指定了输出； </li><li>-v 用来打印归档文件列表。 </li></ul><p>在列出给定cpio归档文件所有内容的命令中： </p><ul><li>-i 用于指定输入； </li><li>-t 表示列出归档文件中的内容。 </li></ul><p>当使用命令进行提取时， -d用来表示提取。 cpio在覆盖文件时不会发出提示。 </p><h3 id="6-3-使用gzip压缩数据"><a href="#6-3-使用gzip压缩数据" class="headerlink" title="6.3 使用gzip压缩数据"></a>6.3 使用gzip压缩数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要使用gzip压缩文件，可以使用下面的命令：</span></span><br><span class="line">$ gzip filename</span><br><span class="line">$ ls</span><br><span class="line">filename.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将gzip文件解压缩的方法如下：</span></span><br><span class="line">$ gunzip filename.gz</span><br><span class="line">$ ls</span><br><span class="line">file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩文件的属性信息：</span></span><br><span class="line">$ gzip -l test.txt.gz</span><br><span class="line">compressed uncompressed ratio uncompressed_name</span><br><span class="line">35 6 -33.3% test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip命令可以从stdin中读入文件，也可以将压缩文件写出到stdout，选项 -c用来将输出指定到stdout。</span></span><br><span class="line">$ cat file | gzip -c &gt; file.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以指定gzip的压缩级别。用 --fast或 --best选项分别提供最低或最高的压缩比。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩归档文件</span></span><br><span class="line"><span class="comment"># 方法 1</span></span><br><span class="line">$ tar -czvvf archive.tar.gz [FILES]</span><br><span class="line">或者</span><br><span class="line">$ tar -cavvf archive.tar.gz [FILES]</span><br><span class="line"><span class="comment"># 选项 -a表明从文件扩展名自动推断压缩格式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 2</span></span><br><span class="line"><span class="comment"># 首先，创建一个tar归档文件：</span></span><br><span class="line">$ tar -cvvf archive.tar [FILES]</span><br><span class="line"><span class="comment"># 压缩tar归档文件：</span></span><br><span class="line">$ gzip archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># zcat——无需解压缩，直接读取gzip格式文件</span></span><br><span class="line">$ ls</span><br><span class="line">test.gz</span><br><span class="line">$ zcat test.gz</span><br><span class="line">A <span class="built_in">test</span> file</span><br><span class="line"><span class="comment"># 文件test包含了一行文本"A test file"</span></span><br><span class="line">$ ls</span><br><span class="line">test.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩率</span></span><br><span class="line"><span class="comment"># 我们可以指定压缩率，它共有9级，其中：</span></span><br><span class="line"><span class="comment"># 1级的压缩率最低，但是压缩速度最快；</span></span><br><span class="line"><span class="comment"># 9级的压缩率最高，但是压缩速度最慢。</span></span><br><span class="line">$ gzip -5 test.img</span><br><span class="line"><span class="comment"># 这应该能在压缩速度和压缩比之间获得一个不错的平衡。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bzip2，唯一的不同在于bzip2的压缩效率比gzip更高，但花费的时间比gzip更长</span></span><br><span class="line">$ bzip2 filename</span><br><span class="line"><span class="comment"># 解压缩bzip2格式的文件：</span></span><br><span class="line">$ bunzip2 filename.bz2</span><br><span class="line"><span class="comment"># 生成tar.bz2文件并从中提取内容的方法同之前介绍的tar.gz类似：</span></span><br><span class="line">$ tar -xjvf archive.tar.bz2</span><br><span class="line"><span class="comment"># 其中-j表明该归档文件是bzip2格式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用lzma</span></span><br><span class="line"><span class="comment"># lzma是另一种压缩工具，它的压缩率甚至比gzip和bzip2更好。</span></span><br><span class="line">$ lzma filename</span><br><span class="line"><span class="comment"># 解压缩lzma文件：</span></span><br><span class="line">$ unlzma filename.lzma</span><br><span class="line"><span class="comment"># 可以使用tar命令的--lzma选项对生成的tar归档文件进行压缩或提取：</span></span><br><span class="line">$ tar -cvvf --lzma archive.tar.lzma [FILES]</span><br><span class="line">或者</span><br><span class="line">$ tar -cavvf archive.tar.lzma [FILES]</span><br><span class="line"><span class="comment"># 如果要将经过lzma压缩过的tar归档文件中的内容提取到指定的目录中，可以使用：</span></span><br><span class="line">$ tar -xvvf --lzma archive.tar.lzma -C extract_directory</span><br><span class="line"><span class="comment"># 其中， -x用于提取内容， --lzma指定使用lzma对归档文件进行解压缩。</span></span><br><span class="line"><span class="comment"># 我们也可以用：</span></span><br><span class="line">$ tar -xavvf archive.tar.lzma -C extract_directory</span><br></pre></td></tr></table></figure><h3 id="6-4-用-zip-归档和压缩"><a href="#6-4-用-zip-归档和压缩" class="headerlink" title="6.4 用 zip 归档和压缩"></a>6.4 用 zip 归档和压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对归档文件采用ZIP格式进行压缩：</span></span><br><span class="line">$ zip file.zip file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对目录和文件进行递归操作, -r 用于指定递归操作：</span></span><br><span class="line">$ zip -r archive.zip folder1 folder2</span><br><span class="line"></span><br><span class="line"><span class="comment">#  要从ZIP文件中提取内容，可以使用：</span></span><br><span class="line">$ unzip file.zip</span><br><span class="line"><span class="comment"># 在完成提取操作之后， unzip并不会删除file.zip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要更新压缩文件中的内容，使用选项 -u：</span></span><br><span class="line">$ zip file.zip -u newfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从压缩文件中删除内容，则使用-d：</span></span><br><span class="line">$ zip -d arc.zip file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩文件中的内容：</span></span><br><span class="line">$ unzip -l archive.zip</span><br></pre></td></tr></table></figure><h3 id="6-5-更快的归档工具-pbzip2"><a href="#6-5-更快的归档工具-pbzip2" class="headerlink" title="6.5 更快的归档工具 pbzip2"></a>6.5 更快的归档工具 pbzip2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩单个文件：</span></span><br><span class="line">$ pbzip2 myfile.tar</span><br><span class="line"><span class="comment"># pbzip2会自动检测系统中处理器核心的数量，然后将myfile.tar压缩成myfile.tar.bz2。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将多个文件或目录进行归档及压缩，可以使用tar配合pbzip2来实现：</span></span><br><span class="line">$ tar cf myfile.tar.bz2 --use-compress-prog=pbzip2 dir_to_compress/</span><br><span class="line">或者</span><br><span class="line">$ tar -c directory_to_compress/ | pbzip2 -c &gt; myfile.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从pbzip2格式的文件中进行提取。</span></span><br><span class="line"><span class="comment"># 如果是tar.bz2文件，我们可以一次性完成解压缩和提取工作：</span></span><br><span class="line">$ pbzip2 -dc myfile.tar.bz2 | tar x</span><br><span class="line"><span class="comment"># 如果是经过pbzip2压缩过的归档文件，可以使用：</span></span><br><span class="line">$ pbzip2 -d myfile.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动指定处理器数量, 使用pbzip2的-p选项来手动指定处理器核心的数量</span></span><br><span class="line">$ pbzip2 -p4 myfile.tar</span><br><span class="line"><span class="comment"># 上面的命令告诉pbzip2使用4个处理器核心。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定压缩比</span></span><br><span class="line"><span class="comment"># 像其他压缩工具一样，我们可以使用从1到9的选项来分别指定最快和最优的压缩比。</span></span><br></pre></td></tr></table></figure><h3 id="6-6-创建压缩文件系统"><a href="#6-6-创建压缩文件系统" class="headerlink" title="6.6 创建压缩文件系统"></a>6.6 创建压缩文件系统</h3><p>squashfs是一种具有超高压缩率的只读型文件系统，这种文件系统能够将2GB~3GB的数据压缩成一个700MB的文件。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加源目录和文件，创建一个squashfs文件：</span></span><br><span class="line">$ sudo mksquashfs /etc test.squashfs</span><br><span class="line">Parallel mksquashfs: Using 2 processors</span><br><span class="line">Creating 4.0 filesystem on test.squashfs, block size 131072.</span><br><span class="line">[=======================================] 1867/1867 100%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用环回形式挂载squashfs文件：</span></span><br><span class="line">$ mkdir /mnt/squash</span><br><span class="line">$ mount -o loop compressedfs.squashfs /mnt/squash</span><br><span class="line"><span class="comment"># 你可以访问/mnt/squashfs访问其中的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在创建squashfs文件时排除部分文件, 选项-e，将需要排除的文件列表以命令行参数的方式来指定。例如：</span></span><br><span class="line">$ sudo mksquashfs /etc test.squashfs -e /etc/passwd /etc/shadow</span><br><span class="line"><span class="comment"># 也可以将需要排除的文件名列表写入文件，然后用 -ef指定该文件：</span></span><br><span class="line">$ cat excludelist</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line">$ sudo mksquashfs /etc test.squashfs -ef excludelist</span><br></pre></td></tr></table></figure><h3 id="6-7-使用-rsync-备份系统快照"><a href="#6-7-使用-rsync-备份系统快照" class="headerlink" title="6.7 使用 rsync 备份系统快照"></a>6.7 使用 rsync 备份系统快照</h3><p>rsync可以对位于不同位置的文件和目录进行同步，它利用差异计算以及压缩技术来最小化数据传输量。 </p><p>rsync也支持压缩、加密等多种特性。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将源目录复制到目的端：</span></span><br><span class="line">$ rsync -av /home/slynux/data slynux@192.168.0.6:/home/backups/data</span><br><span class="line"><span class="comment"># 其中：</span></span><br><span class="line"> -a表示要进行归档；</span><br><span class="line"> -v表示在stdout上打印出细节信息或进度。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据备份到远程服务器或主机：</span></span><br><span class="line">$ rsync -av source_dir username@host:PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的方法将远程主机上的数据恢复到本地主机：</span></span><br><span class="line">$ rsync -av username@host:PATH destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过网络进行传输时，压缩数据能够明显改善传输效率。我们可以用rsync的选项 -z 指定在网络传输时压缩数据。例如：</span></span><br><span class="line">$ rsync -avz <span class="built_in">source</span> destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个目录中的内容同步到另一个目录：</span></span><br><span class="line">$ rsync -av /home/<span class="built_in">test</span>/ /home/backups</span><br><span class="line"><span class="comment"># 这条命令将源目录（/home/test）中的内容（不包括目录本身）复制到现有的backups目录中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在使用rsync进行归档的过程中排除部分文件</span></span><br><span class="line">$ rsync -avz /home/code/some_code /mnt/disk/backup/code --exclude <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># 或者我们可以通过一个列表文件指定需要排除的文件。</span></span><br><span class="line"><span class="comment"># 这可以利用--exclude-from FILEPATH。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在更新rsync备份时，删除不存在的文件, rsync并不会在目的端删除那些在源端已不存在的文件</span></span><br><span class="line">$ rsync -avz SOURCE DESTINATION --delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定期进行备份</span></span><br><span class="line">$ crontab -ev</span><br><span class="line"><span class="comment"># 添加上这么一行：</span></span><br><span class="line">0 */10 * * * rsync -avz /home/code user@IP_ADDRESS:/home/backups</span><br><span class="line"><span class="comment"># 上面的crontab条目将rsync调度为每10个小时运行一次。</span></span><br></pre></td></tr></table></figure><h3 id="6-8-用-fsarchiver-创建全盘镜像"><a href="#6-8-用-fsarchiver-创建全盘镜像" class="headerlink" title="6.8 用 fsarchiver 创建全盘镜像"></a>6.8 用 fsarchiver 创建全盘镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件系统/分区备份。</span></span><br><span class="line"><span class="comment"># 使用fsarchiver的savefs选项：</span></span><br><span class="line">$ fsarchiver savefs backup.fsa /dev/sda1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时备份多个分区。</span></span><br><span class="line">$ fsarchiver savefs backup.fsa /dev/sda1 /dev/sda2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份归档中恢复分区。</span></span><br><span class="line">$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1</span><br><span class="line"><span class="comment"># id=0 表 明 我 们 希 望 从 备 份 归 档 中 提 取 第 一 个 分 区 的 内 容 ， 将 其 恢 复 到 由 dest=/dev/sda1所指定的分区中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份归档中恢复多个分区。</span></span><br><span class="line"><span class="comment"># 像之前一样，使用restfs选项：</span></span><br><span class="line">$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1 id=1,dest=/dev/sdb1</span><br></pre></td></tr></table></figure><h2 id="7-无网不利"><a href="#7-无网不利" class="headerlink" title="7 无网不利"></a>7 无网不利</h2><h3 id="7-1-设置网络"><a href="#7-1-设置网络" class="headerlink" title="7.1 设置网络"></a>7.1 设置网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动设置网络接口的IP地址：</span></span><br><span class="line">$ ifconfig wlan0 192.168.0.80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用以下命令设置比IP地址的子网掩码：</span></span><br><span class="line">$ ifconfig wlan0 192.168.0.80 netmask 255.255.252.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动配置网络接口</span></span><br><span class="line">$ dhclient eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印网络接口列表</span></span><br><span class="line">$ ifconfig | cut -c-10 | tr -d <span class="string">' '</span> | tr -s <span class="string">'\n'</span></span><br><span class="line">lo</span><br><span class="line">wlan0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示IP地址</span></span><br><span class="line">$ ifconfig wlan0 | egrep -o <span class="string">"inet addr:[^ ]*"</span> | grep -o <span class="string">"[0-9.]*"</span></span><br><span class="line">192.168.0.82</span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬件地址（MAC地址）欺骗</span></span><br><span class="line">$ ifconfig eth0 hw ether 00:1c:bf:87:25:d5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 名字服务器与DNS（域名服务）</span></span><br><span class="line">$ cat /etc/resolv.conf</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line"><span class="comment"># 我们可以像下面这样手动添加名字服务器：</span></span><br><span class="line">$ <span class="built_in">echo</span> nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS查找</span></span><br><span class="line">$ host google.com</span><br><span class="line">google.com has address 64.233.181.105</span><br><span class="line">google.com has address 64.233.181.99</span><br><span class="line">google.com has address 64.233.181.147</span><br><span class="line">google.com has address 64.233.181.106</span><br><span class="line">google.com has address 64.233.181.103</span><br><span class="line">google.com has address 64.233.181.104</span><br><span class="line"></span><br><span class="line">$ nslookup google.com</span><br><span class="line">Server: 8.8.8.8</span><br><span class="line">Address: 8.8.8.8<span class="comment">#53</span></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.105</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.99</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.147</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.106</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.103</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.104</span><br><span class="line">Server: 8.8.8.8</span><br><span class="line"><span class="comment"># 上面最后一行对应着用于DNS解析的默认名字服务器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用DNS服务器，也可以为IP地址解析添加符号名，这只需要向文件 /etc/hosts中加入条目即可。</span></span><br><span class="line"><span class="comment"># 用下面的方法进行添加：</span></span><br><span class="line">$ <span class="built_in">echo</span> IP_ADDRESS symbolic_name &gt;&gt; /etc/hosts</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> 192.168.0.9 backupserver &gt;&gt; /etc/hosts</span><br><span class="line"><span class="comment"># 添加了条目之后，任何时候解析backupserver，都会返回192.168.0.9。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示路由表信息</span></span><br><span class="line">$ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref UseIface</span><br><span class="line">192.168.0.0 * 255.255.252.0 U 2 0 0wlan0</span><br><span class="line">link-local * 255.255.0.0 U 1000 0 0wlan0</span><br><span class="line">default p4.local 0.0.0.0 UG 0 0 0wlan0</span><br><span class="line"><span class="comment"># 也可以使用：</span></span><br><span class="line">$ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref Use Iface</span><br><span class="line">192.168.0.0 0.0.0.0 255.255.252.0 U 2 0 0 wlan0</span><br><span class="line">169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 wlan0</span><br><span class="line">0.0.0.0 192.168.0.4 0.0.0.0 UG 0 0 0 wlan0</span><br><span class="line"><span class="comment"># -n指定以数字形式显示地址。如果使用-n， route会以数字形式的IP地址显示每一个条目；否则，如果IP地址具有对应的DNS条目，就会显示符号形式的主机名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认网关：</span></span><br><span class="line">$ route add default gw 192.168.0.1 wlan0</span><br></pre></td></tr></table></figure><h3 id="7-2-traceroute-命令"><a href="#7-2-traceroute-命令" class="headerlink" title="7.2 traceroute 命令"></a>7.2 traceroute 命令</h3><p>traceroute，它可以显示分组途径的所有网关的地址。 traceroute信息可以帮助我们搞明白分组到达目的地需要经过多少跳（hop）。中途的网关或路由器的数量给出了一个测量网络上两个节点之间距离的度量<br>（metric）。 traceroute的输出如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ traceroute google.com</span><br><span class="line">traceroute to google.com (74.125.77.104), 30 hops max, 60 byte packets</span><br><span class="line">1 gw-c6509.lxb.as5577.net (195.26.4.1) 0.313 ms 0.371 ms 0.457 ms</span><br><span class="line">2 40g.lxb-fra.as5577.net (83.243.12.2) 4.684 ms 4.754 ms 4.823 ms</span><br><span class="line">3 de-cix10.net.google.com (80.81.192.108) 5.312 ms 5.348 ms 5.327 ms</span><br><span class="line">4 209.85.255.170 (209.85.255.170) 5.816 ms 5.791 ms 209.85.255.172</span><br><span class="line">(209.85.255.172) 5.678 ms</span><br><span class="line">5 209.85.250.140 (209.85.250.140) 10.126 ms 9.867 ms 10.754 ms</span><br><span class="line">6 64.233.175.246 (64.233.175.246) 12.940 ms 72.14.233.114</span><br><span class="line">(72.14.233.114) 13.736 ms 13.803 ms</span><br><span class="line">7 72.14.239.199 (72.14.239.199) 14.618 ms 209.85.255.166</span><br><span class="line">(209.85.255.166) 12.755 ms 209.85.255.143 (209.85.255.143) 13.803 ms</span><br><span class="line">8 209.85.255.98 (209.85.255.98) 22.625 ms 209.85.255.110</span><br><span class="line">(209.85.255.110) 14.122 ms</span><br><span class="line">*</span><br><span class="line">9 ew-in-f104.1e100.net (74.125.77.104) 13.061 ms 13.256 ms 13.484 ms</span><br></pre></td></tr></table></figure><h3 id="7-3-列出网络上所有的活动主机-fping"><a href="#7-3-列出网络上所有的活动主机-fping" class="headerlink" title="7.3 列出网络上所有的活动主机 (fping)"></a>7.3 列出网络上所有的活动主机 (fping)</h3><p>fping的选项如下： </p><ul><li>选项 -a指定打印出所有活动主机的IP地址； </li><li>选项 -u指定打印出所有无法到达的主机； </li><li>选项 -g指定从 “IP地址/子网掩码”记法或者”IP地址范围”记法中生成一组IP地址； </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ fping -a 192.160.1/24 -g</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ fping -a 192.160.1 192.168.0.255 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以用已有的命令行工具来查询网络上的主机状态：</span></span><br><span class="line">$ fping -a 192.160.1/24 -g 2&gt; /dev/null</span><br><span class="line">192.168.0.1</span><br><span class="line">192.168.0.90</span><br><span class="line"><span class="comment"># 或者，使用：</span></span><br><span class="line">$ fping -a 192.168.0.1 192.168.0.255 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;/dev/null将由于主机无法到达所产生的错误信息打印到null设备。</span></span><br><span class="line">$ fping -a 192.168.0.1 192.168.0.5 192.168.0.6</span><br><span class="line"><span class="comment"># 将IP地址作为参数传递</span></span><br><span class="line">$ fping -a &lt; ip.list</span><br><span class="line"><span class="comment"># 从文件中传递一组IP地址</span></span><br></pre></td></tr></table></figure><h3 id="7-4-ssh-命令"><a href="#7-4-ssh-命令" class="headerlink" title="7.4 ssh 命令"></a>7.4 ssh 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SSH的压缩功能,选项-C启用这一功能：</span></span><br><span class="line">$ ssh -C user@hostname COMMANDS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据重定向至远程shell命令的stdin</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'text'</span> | ssh user@remote_host <span class="string">'echo'</span></span><br><span class="line">text</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 将文件中的数据进行重定向</span></span><br><span class="line">$ ssh user@remote_host <span class="string">'echo'</span> &lt; file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在远程主机中执行图形化命令</span></span><br><span class="line"><span class="comment"># 对此，你需要像这样设置变量$DISPLAY：</span></span><br><span class="line">$ ssh user@host <span class="string">"export DISPLAY=:0 ; command1; command2"</span><span class="string">""</span></span><br><span class="line"><span class="comment"># 这将启用远程主机上的图形化输出。如果你想在本地主机上也显示图形化输出，使用SSH的X11转发选项（forwarding option）：</span></span><br><span class="line">$ ssh -X user@host <span class="string">"command1; command2</span></span><br></pre></td></tr></table></figure><h3 id="7-5-通过网络传输文件"><a href="#7-5-通过网络传输文件" class="headerlink" title="7.5 通过网络传输文件"></a>7.5 通过网络传输文件</h3><p>计算机联网的主要目的就是资源共享。在资源共享方面，使用最多的是文件共享。有多种方法可以用来在网络中传输文件。这则攻略就讨论了如何用常见的协议FTP、 SFTP、 RSYNC和SCP传输文件。 </p><p>通过FTP传输文件可以使用lftp命令，通过SSH连接传输文件可以使用sftp， RSYNC使用SSH与rsync命令， scp通过SSH进行传输。 </p><p><strong>文件传输协议（File Transfer Protocol， FTP） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要连接FTP服务器传输文件，可以使用：</span></span><br><span class="line">$ lftp username@ftphost</span><br><span class="line"><span class="comment"># 它会提示你输入密码，然后显示一个像下面那样的登录提示符：</span></span><br><span class="line">lftp username@ftphost:~&gt;</span><br></pre></td></tr></table></figure><p>你可以在提示符后输入命令，如下所示。 </p><ul><li>用cd directory改变目录。 </li><li>用lcd改变本地主机的目录。 </li><li>用mkdir创建目录。 </li><li>列出远程机器当前目录下的文件使用Is。 </li><li>用get filename下载文件：<br><code>lftp username@ftphost:~&gt; get filename</code></li><li>用put filename从当前目录上传文件：<br><code>lftp username@ftphost:~&gt; put filename</code></li><li>用quit退出lftp会话。 </li></ul><p><strong>FTP自动传输 ：</strong></p><p>ftp是另一个可用于FTP文件传输的命令。相比较而言， lftp的用法更灵活。 lftp和ftp为用户启动一个交互式会话（通过显示消息来提示用户输入）。 </p><p><strong>SFTP（Secure FTP，安全FTP） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/slynux</span><br><span class="line">$ put testfile.jpg</span><br><span class="line">$ get serverfile.jpg</span><br><span class="line"><span class="comment"># 运行sftp：</span></span><br><span class="line">$ sftp user@domainname</span><br></pre></td></tr></table></figure><p><strong>rsync命令 ：</strong></p><p>rsync广泛用于网络文件复制及系统备份。 </p><p><strong>SCP（Secure Copy Program，安全复制程序） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp filename user@remotehost:/home/path</span><br><span class="line"></span><br><span class="line">$ scp user@remotehost:/home/path/filename filename</span><br></pre></td></tr></table></figure><p>用SCP进行递归复制 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r /home/slynux user@remotehost:/home/backups</span><br><span class="line"><span class="comment"># 将目录/home/slynux递归复制到远程主机中</span></span><br><span class="line"><span class="comment"># scp的 -p 选项能够在复制文件的同时保留文件的权限和模式。</span></span><br></pre></td></tr></table></figure><h3 id="7-6-连接网线网络"><a href="#7-6-连接网线网络" class="headerlink" title="7.6 连接网线网络"></a>7.6 连接网线网络</h3><p>我们需要用ifconfig分配IP地址和子网掩码才能连接上有线网络。对于无线网络来说，还需要其他工具（如iwconfig和iwlist）来配置更多的参数。 </p><p>iwlist工具扫描并列出可用的无线网络。用下面的命令进行扫描： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ iwlist scan</span><br><span class="line">wlan0 Scan completed :</span><br><span class="line">Cell 01 - Address: 00:12:17:7B:1C:65</span><br><span class="line">Channel:11</span><br><span class="line">Frequency:2.462 GHz (Channel 11)</span><br><span class="line">Quality=33/70 Signal level=-77 dBm</span><br><span class="line">                    Encryption key:on</span><br><span class="line">ESSID:<span class="string">"model-2"</span></span><br></pre></td></tr></table></figure><h3 id="7-7-在本地挂载点上挂载远程驱动器"><a href="#7-7-在本地挂载点上挂载远程驱动器" class="headerlink" title="7.7 在本地挂载点上挂载远程驱动器"></a>7.7 在本地挂载点上挂载远程驱动器</h3><p>sshfs允许你将远程文件系统挂载到本地挂载点上。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将位于远程主机上的文件系统挂载到本地挂载点上：</span></span><br><span class="line">$ sshfs -o allow_other user@remotehost:/home/path /mnt/mountpoint</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成任务后，可用下面的方法卸载：</span></span><br><span class="line">$ umount /mnt/mountpoint</span><br></pre></td></tr></table></figure><h3 id="7-8-网络流量与端口分析"><a href="#7-8-网络流量与端口分析" class="headerlink" title="7.8 网络流量与端口分析"></a>7.8 网络流量与端口分析</h3><p>列出系统中的开放端口以及运行在端口上的服务的详细信息，可以使用以下命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要列出本地主机当前的开放端口，可以使用：</span></span><br><span class="line">$ lsof -i | grep <span class="string">":[0-9]\+-&gt;"</span> -o | grep <span class="string">"[0-9]\+"</span> -o | sort | uniq</span><br></pre></td></tr></table></figure><p>用netstat查看开放端口与服务 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -tnp列出开放端口与服务：</span></span><br><span class="line">$ netstat -tnp</span><br></pre></td></tr></table></figure><h3 id="7-9-创建套接字"><a href="#7-9-创建套接字" class="headerlink" title="7.9 创建套接字"></a>7.9 创建套接字</h3><p>最简单的方法就是使用netcat命令（或nc）。我们需要两个套接字：一个用来侦听，一个用来连接。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置侦听套接字：</span></span><br><span class="line">$ nc -l 1234</span><br><span class="line"><span class="comment"># 这会在本地主机的端口1234上创建一个侦听套接字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到该套接字：</span></span><br><span class="line">$ nc HOST 1234</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想发送消息，只需要在执行第2步操作的主机终端中输入信息并按回车键就行了。消息会出现在执行第1步操作的主机终端中。</span></span><br></pre></td></tr></table></figure><p>在网络上进行快速文件复制 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在接收端执行下列命令：</span></span><br><span class="line">$ nc -l 1234 &gt; destination_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在发送端执行下列命令：</span></span><br><span class="line">$ nc HOST 1234 &lt; source_filename</span><br></pre></td></tr></table></figure><h3 id="7-10-iptables防火墙设置"><a href="#7-10-iptables防火墙设置" class="headerlink" title="7.10 iptables防火墙设置"></a>7.10 iptables防火墙设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阻塞发送到特定IP地址的流量：</span></span><br><span class="line">$ iptables -A OUTPUT -d 8.8.8.8 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞发送到特定端口的流量：</span></span><br><span class="line">$ iptables -A OUTPUT -p tcp -dport 21 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment">#  iptables中的第一个选项-A表明向链（chain）中添加一条新的规则，该规则由后续参数给出。OUTPUT链，它可以对所有出站（outgoing）的流量进行控制。-d指定了所要匹配的分组目的地址。-j来使iptables丢弃（DROP）符合条件的分组。-p指定该规则是适用于TCP， -dport指定了对应的端口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除对iptables链所做出的所有改动。</span></span><br><span class="line">$ iptables --flush</span><br></pre></td></tr></table></figure><h2 id="8-当个好管家"><a href="#8-当个好管家" class="headerlink" title="8 当个好管家"></a>8 当个好管家</h2><h3 id="8-1-监视磁盘使用情况"><a href="#8-1-监视磁盘使用情况" class="headerlink" title="8.1 监视磁盘使用情况"></a>8.1 监视磁盘使用情况</h3><p><code>df</code> 是disk free的缩写， <code>du</code> 是disk usage的缩写。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出某个文件（或多个文件）占用的磁盘空间：</span></span><br><span class="line">$ du file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要获得某个目录中所有文件的磁盘使用情况，并在每一行中显示各个文件的磁盘占用详情，可以使用：</span></span><br><span class="line">$ du -a DIRECTORY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以KB、 MB或块（block）为单位显示磁盘使用情况</span></span><br><span class="line">$ du -h FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示磁盘使用总计, -c 可以输出作为命令参数的所有文件和目录的磁盘使用情况</span></span><br><span class="line">$ du -c process_log.shpcpu.sh</span><br><span class="line">4 process_log.sh</span><br><span class="line">4 pcpu.sh</span><br><span class="line">8 total</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s（summarize，合计）则只输出合计数据。它可以配合 -h打印出人们易读的格式。</span></span><br><span class="line">$ du -sh slynux</span><br><span class="line">680K slynux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以字节（默认输出）为单位的文件大小：</span></span><br><span class="line">$ du -b FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以KB为单位的文件大小：</span></span><br><span class="line">$ du -k FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以MB为单位的文件大小：</span></span><br><span class="line">$ du -m FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以指定块为单位的文件大小：</span></span><br><span class="line">$ du -B BLOCK_SIZE FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从磁盘使用统计中排除部分文件</span></span><br><span class="line">$ du --exclude <span class="string">"*.txt"</span> FILES(s)</span><br><span class="line"><span class="comment"># 排除所有的.txt文件</span></span><br><span class="line">$ du --exclude-from EXCLUDE.txt DIRECTORY</span><br><span class="line"><span class="comment"># EXCLUDE.txt包含了需要排除的文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --max-depth指定du应该遍历的目录层次的最大深度。</span></span><br><span class="line">$ du --max-depth 2 DIRECTORY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出指定目录中最大的10个文件</span></span><br><span class="line">$ du -ak /home/slynux | sort -nrk 1 | head -n 4</span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> du -k &#123;&#125; \; | sort -nrk 1 | head</span><br></pre></td></tr></table></figure><p>du提供磁盘使用情况信息，而df提供磁盘可用空间信息。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem Size Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1 9.2G 2.2G 6.6G 25% /</span><br><span class="line">none 497M 240K 497M 1% /dev</span><br><span class="line">none 502M 168K 501M 1% /dev/shm</span><br><span class="line">none 502M 88K 501M 1% /var/run</span><br><span class="line">none 502M 0 502M 0% /var/lock</span><br><span class="line">none 502M 0 502M 0% /lib/init/rw</span><br><span class="line">none 9.2G 2.2G 6.6G 25% /var/lib/ureadahead/debugfs</span><br></pre></td></tr></table></figure><h3 id="8-2-计算命令执行时间"><a href="#8-2-计算命令执行时间" class="headerlink" title="8.2 计算命令执行时间"></a>8.2 计算命令执行时间</h3><ul><li>real: %e </li><li>user: %U </li><li>sys: %S </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ time COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用选项-o filename将相关的时间统计信息写入文件：</span></span><br><span class="line">$ /usr/bin/time -o output.txt COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将命令执行时间添加到文件而不影响其原有内容，使用选项-a以及-o：</span></span><br><span class="line">$ /usr/bin/time -a -o output.txt COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建格式化输出：</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Time: %U"</span> -a -o timing.log uname</span><br><span class="line">Linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用错误重定向操作符（2&gt;）对时间信息重定向。</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Time: %U"</span> uname&gt; command_output.txt 2&gt;time.log</span><br><span class="line">$ cat time.log</span><br><span class="line">Time: 0.00</span><br><span class="line">$ cat command_output.txt</span><br><span class="line">Linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用参数%Z显示系统页面大小：</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Page size: %Z bytes"</span> ls&gt; /dev/null</span><br><span class="line">Page size: 4096 bytes</span><br></pre></td></tr></table></figure><p>三种不同类型的时：</p><ul><li>Real时间指的是挂钟时间（wall clock time），也就是命令从开始执行到结束的时间。这段时间包括其他进程所占用的时间片（time slice）以及进程被阻塞时所花费的时间（例如，为等待I/O操作完成所用的时间）。 </li><li>User时间是指进程花费在用户模式（内核之外）中的CPU时间。这是唯一真正用于执行进程所花费的时间。执行其他进程以及花费在阻塞状态中的时间并没有计算在内。 </li><li>Sys时间是指进程花费在内核中的CPU时间。它代表在内核中执行系统调用所使用的时间，这和库代码（library code）不同，后者仍旧运行在用户空间。与“user时间”类似，这也是真正由进程使用的CPU时间。 </li></ul><p>time命令 一些可以使用的参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>%C</td><td>进行计时的命令名称以及命令行参数</td></tr><tr><td>%D</td><td>进程非共享数据区域的大小，以KB为单位</td></tr><tr><td>%E</td><td>进程使用的real时间（挂钟时间），显示格式为[小时:]分钟:秒</td></tr><tr><td>%x</td><td>命令的退出状态</td></tr><tr><td>%k</td><td>进程接收到的信号数量</td></tr><tr><td>%W</td><td>进程被交换出主存的次数</td></tr><tr><td>%Z</td><td>系统的页面大小。这是一个系统常量，但在不同的系统中，这个常量值也不同</td></tr><tr><td>%P</td><td>进程所获得的CPU时间百分比。这个值等于user+system时间除以总运行时间。结果以百分比形式显示</td></tr><tr><td>%K</td><td>进程的平均总（data+stack+text）内存使用量，以KB为单位</td></tr><tr><td>%w</td><td>进程主动进行上下文切换的次数，例如等待I/O操作完成</td></tr><tr><td>%c</td><td>进程被迫进行上下文切换的次数（由于时间片到期）</td></tr></tbody></table><h3 id="8-3-收集与当前登录用户、启动日志及启动故障的相关信息"><a href="#8-3-收集与当前登录用户、启动日志及启动故障的相关信息" class="headerlink" title="8.3 收集与当前登录用户、启动日志及启动故障的相关信息"></a>8.3 收集与当前登录用户、启动日志及启动故障的相关信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前登录用户的相关信息：</span></span><br><span class="line">$ who</span><br><span class="line">slynux pts/0 2010-09-29 05:24 (slynuxs-macbook-pro.local)</span><br><span class="line">slynux tty7 2010-09-29 07:08 (:0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得有关登录用户更详细的信息：</span></span><br><span class="line">$ w</span><br><span class="line">  07:09:05 up 1:45, 2 users, load average: 0.12, 0.06, 0.02</span><br><span class="line">USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</span><br><span class="line">slynux pts/0 slynuxs 05:24 0.00s 0.65s 0.11s sshd: slynux</span><br><span class="line">slynux tty7 :007:08 1:45m 3.28s 0.26s gnome-session</span><br><span class="line"><span class="comment"># 第一行列出了当前时间，系统运行时间，当前登录的用户数量以及过去的1分钟、 5分钟、 15分钟内的系统平均负载。接下来的每一行显示了每一个登录用户的详细信息，其中包括登录名、 TTY、远程主机、登录时间、空闲时间、自该用户登录后所使用的总CPU时间、当前运行进程所使用的CPU时间以及进程所对应的命令行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录主机的用户列表：</span></span><br><span class="line">$ users</span><br><span class="line">slynux slynux slynux hacker</span><br><span class="line">$ users | tr <span class="string">' '</span> <span class="string">'\n'</span> | sort | uniq</span><br><span class="line">slynux</span><br><span class="line">hacker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统已经加电运行了多长时间：</span></span><br><span class="line">$ uptime</span><br><span class="line">21:44:33 up 3:17, 8 users, load average: 0.09, 0.14, 0.09</span><br><span class="line">$ uptime | grep -Po <span class="string">'\d&#123;2&#125;\:\d&#123;2&#125;\:\d&#123;2&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取上一次启动以及用户登录会话的信息：</span></span><br><span class="line">$ last</span><br><span class="line">slynux tty7 :0 Tue Sep 28 18:27 still logged <span class="keyword">in</span></span><br><span class="line">reboot system boot 2.6.32-21-generic Tue Sep 28 18:10 - 21:46 (03:35)</span><br><span class="line">slynux pts/0 :0.0 Tue Sep 28 05:31 - crash (12:39)</span><br><span class="line"><span class="comment"># last命令可以提供登录会话信息。它实际上是一个系统登录日志，包括了登录tty、登录时间、状态等信息。</span></span><br><span class="line"><span class="comment"># last命令以日志文件/var/log/wtmp作为输入日志数据。它也可以用选项-f明确地指定日志文件。例如：</span></span><br><span class="line">$ last -f /var/<span class="built_in">log</span>/wtmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个用户登录会话的信息：</span></span><br><span class="line">$ last USER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取重启会话（reboot session）信息：</span></span><br><span class="line">$ last reboot</span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 18:10 - 21:48 (03:37)</span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 05:14 - 21:48 (16:33)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取失败的用户登录会话信息：</span></span><br><span class="line">$ lastb</span><br><span class="line"><span class="built_in">test</span> tty8 :0 Wed Dec 15 03:56 - 03:56 (00:00)</span><br><span class="line">slynux tty8 :0 Wed Dec 15 03:55 - 03:55 (00:00)</span><br></pre></td></tr></table></figure><h3 id="8-4-使用-watch-监视命令输出"><a href="#8-4-使用-watch-监视命令输出" class="headerlink" title="8.4 使用 watch 监视命令输出"></a>8.4 使用 watch 监视命令输出</h3><p>watch命令可以用来在终端中以固定的间隔监视命令输出。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ watch ls</span><br><span class="line"></span><br><span class="line">$ watch <span class="string">'ls -l | grep "^d"'</span></span><br><span class="line"><span class="comment"># 只列出目录</span></span><br><span class="line"><span class="comment"># 命令默认每2秒更新一次输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -n SECOND指定更新输出的时间间隔。例如：</span></span><br><span class="line">$ watch -n 5 <span class="string">'ls -l'</span></span><br><span class="line"><span class="comment"># 以5秒为间隔，监视ls -l的输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 突出标示watch输出中的差异, -d 可以启用这一功能：</span></span><br><span class="line">$ watch -d <span class="string">'COMMANDS'</span></span><br></pre></td></tr></table></figure><h3 id="8-5-用-logrotate-管理日志文件"><a href="#8-5-用-logrotate-管理日志文件" class="headerlink" title="8.5 用 logrotate 管理日志文件"></a>8.5 用 logrotate 管理日志文件</h3><p>用一种被称为轮替（rotation）的技术来限制日志文件的体积，一旦它超过了限定的大小，就对其内容进行抽取（strip），同时将 日志文件中的旧条目存储到日志目录中的归档文件内。旧的日志文件就会得以保存以便随后参阅。 </p><p><code>logrotate</code> 的配置目录位于/etc/logrotate.d。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/logrotate.d/program</span><br><span class="line">/var/<span class="built_in">log</span>/program.log &#123;</span><br><span class="line">missingok</span><br><span class="line">notifempty</span><br><span class="line">size 30k</span><br><span class="line">compress</span><br><span class="line">weekly</span><br><span class="line">rotate 5</span><br><span class="line">create 0600 root root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中各个参数的含义：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>missingok</td><td>如果日志文件丢失，则忽略；然后返回（不对日志文件进行轮替）</td></tr><tr><td>notifempty</td><td>仅当源日志文件非空时才对其进行轮替</td></tr><tr><td>size 30k</td><td>限制实施轮替的日志文件的大小。可以用1M表示1MB</td></tr><tr><td>compress</td><td>允许用gzip压缩较旧的日志</td></tr><tr><td>weekly</td><td>指定进行轮替的时间间隔。可以是weekly、 yearly或daily</td></tr><tr><td>rotate 5</td><td>这是需要保留的旧日志文件的归档数量。在这里指定的是5，所以这些文件名将会是program.log.1.gz、 program.log.2.gz等直到program.log.5.gz</td></tr><tr><td>create 0600 root root</td><td>指定所要创建的归档文件的模式、用户以及用户组</td></tr></tbody></table><h3 id="8-6-用-syslog-记录日志"><a href="#8-6-用-syslog-记录日志" class="headerlink" title="8.6 用 syslog 记录日志"></a>8.6 用 syslog 记录日志</h3><p>每一个标准应用进程都可以利用syslog记录日志信息。 </p><p>使用命令logger通过syslogd记录日志。 </p><p>Linux中一些重要的日志文件 ：</p><table><thead><tr><th>日志文件</th><th>描述</th></tr></thead><tbody><tr><td>/var/log/boot.log</td><td>系统启动信息</td></tr><tr><td>/var/log/httpd</td><td>Apache Web服务器日志</td></tr><tr><td>/var/log/messages</td><td>发布内核启动信息</td></tr><tr><td>/var/log/auth.log</td><td>用户认证日志</td></tr><tr><td>/var/log/dmesg</td><td>系统启动信息</td></tr><tr><td>/var/log/mail.log</td><td>邮件服务器日志</td></tr><tr><td>/var/log/Xorg.0.log</td><td>X服务器日志</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向系统日志文件/var/log/message中写入日志信息：</span></span><br><span class="line">$ logger This is a <span class="built_in">test</span> <span class="built_in">log</span> line</span><br><span class="line">$ tail -n 1 /var/<span class="built_in">log</span>/messages</span><br><span class="line">Sep 29 07:47:44 slynux-laptop slynux: This is a <span class="built_in">test</span> <span class="built_in">log</span> line</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果要记录特定的标记（tag），可以使用：</span></span><br><span class="line">$ logger -t TAG This is a message</span><br><span class="line">$ tail -n 1 /var/<span class="built_in">log</span>/messages</span><br><span class="line">Sep 29 07:48:42 slynux-laptop TAG: This is a message</span><br><span class="line"><span class="comment"># 但是当logger发送消息时，它用标记字符串来确定应该记录到哪一个日志文件中。 syslogd使用与日志相关联的TAG来决定应该将其记录到哪一个文件中。你可以从/etc/rsyslog.d/目录下的配置文件中看到标记字符串以及与其相关联的日志文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将另一个日志文件的最后一行记录到系统日志中，可以使用：</span></span><br><span class="line">$ logger -f /var/<span class="built_in">log</span>/source.log</span><br></pre></td></tr></table></figure><h3 id="8-7-通过监视用户登录找出入侵者"><a href="#8-7-通过监视用户登录找出入侵者" class="headerlink" title="8.7 通过监视用户登录找出入侵者"></a>8.7 通过监视用户登录找出入侵者</h3><p>入侵者定义为：屡次试图登入系统达两分钟以上，并且期间的登录过程全部失败。凡是这类用户都应该被检测出来并生成包含以下细节信息的报告： </p><ul><li>试图登录的账户 </li><li>试图登录的次数 </li><li>攻击者的IP地址 </li><li>IP地址所对应的主机 </li><li>进行登录的时间段 </li></ul><p>为了处理SSH登录失败的情况，还得知道用户认证会话日志会被记录在日志文件/var/log/auth.log中。脚本需要扫描这个日志文件来检测出失败的登录信息，执行各种检查来获取所需要的数据。我们可以用host命令找出IP地址所对应的主机。 </p><h3 id="8-8-监视磁盘活动"><a href="#8-8-监视磁盘活动" class="headerlink" title="8.8 监视磁盘活动"></a>8.8 监视磁盘活动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互式监视, iotop的-o选项只显示出那些正在进行I/O活动的进程：</span></span><br><span class="line">$ iotop -o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于shell脚本的非交互式用法：</span></span><br><span class="line">$ iotop -b -n 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视特定进程</span></span><br><span class="line">$ iotop -p PID</span><br></pre></td></tr></table></figure><h3 id="8-9-检查磁盘及文件系统错误"><a href="#8-9-检查磁盘及文件系统错误" class="headerlink" title="8.9 检查磁盘及文件系统错误"></a>8.9 检查磁盘及文件系统错误</h3><p>使用fsck的各种选项对文件系统错误进行检查和修复。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要检查分区或文件系统的错误，只需要将路径作为fsck的参数：</span></span><br><span class="line">$ fsck /dev/sdb3</span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">e2fsck 1.42.5 (29-Jul-2012)</span><br><span class="line">HDD2 has been mounted 26 <span class="built_in">times</span> without being checked, check forced.</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">HDD2: 75540/16138240 files (0.7% non-contiguous), 48756390/64529088 blocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查/etc/fstab中所配置的所有文件系统：</span></span><br><span class="line">$ fsck -A</span><br><span class="line"><span class="comment"># 该命令会依次检查/etc/fstab中列出的文件系统。 fstab文件对磁盘及其挂载点之间的映射关系进行了配置，以便于更便捷地挂载文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定fsck自动修复错误，无需询问是否进行修复：</span></span><br><span class="line">$ fsck -a /dev/sda2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟fsck要执行的操作：</span></span><br><span class="line">$ fsck -AN</span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /] fsck.ext4 /dev/sda8</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /home] fsck.ext4 /dev/sda7</span><br><span class="line">[/sbin/fsck.ext3 (1) -- /media/Data] fsck.ext3 /dev/sda6</span><br></pre></td></tr></table></figure><h2 id="9-管理重任"><a href="#9-管理重任" class="headerlink" title="9 管理重任"></a>9 管理重任</h2><h3 id="9-1-收集进程信息"><a href="#9-1-收集进程信息" class="headerlink" title="9.1 收集进程信息"></a>9.1 收集进程信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了包含更多的信息，可以使用-f（表示full）来显示多列，如下所示：</span></span><br><span class="line">$ ps -f</span><br><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">slynux 1220 1219 0 18:18 pts/0 00:00:00 -bash</span><br><span class="line">slynux 1587 1220 0 18:59 pts/0 00:00:00 ps -f</span><br><span class="line"><span class="comment"># 使用选项 -e（every）。选项-ax（all）也可以生成同样的输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行如下命令之一： ps –e， ps –ef， ps -ax或ps –axf。</span></span><br><span class="line">$ ps -e | head</span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1 ? 00:00:00 init</span><br><span class="line">2 ? 00:00:00 kthreadd</span><br><span class="line">3 ? 00:00:00 migration/0</span><br><span class="line">4 ? 00:00:00 ksoftirqd/0</span><br><span class="line">5 ? 00:00:00 watchdog/0</span><br><span class="line">6 ? 00:00:00 events/0</span><br><span class="line">7 ? 00:00:00 cpuset</span><br><span class="line">8 ? 00:00:00 khelper</span><br><span class="line">9 ? 00:00:00 netns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 -o 来指定想要显示的列，以便只打印出我们需要的内容。</span></span><br><span class="line"><span class="comment"># -o 的参数以逗号操作符（,）作为定界符。值得注意的是，逗号操作符与它分隔的参数之间是没有空格的。</span></span><br><span class="line"><span class="comment"># -e和过滤器结合使用没有任何实际效果，依旧会显示所有的进程。</span></span><br><span class="line"><span class="comment"># 示例如下，其中comm表示COMMAND， pcpu表示CPU占用率：</span></span><br><span class="line">$ ps -eo comm,pcpu | head</span><br><span class="line">COMMAND %CPU</span><br><span class="line">init 0.0</span><br><span class="line">kthreadd 0.0</span><br><span class="line">migration/0 0.0</span><br><span class="line">ksoftirqd/0 0.0</span><br><span class="line">watchdog/0 0.0</span><br><span class="line">events/0 0.0</span><br><span class="line">cpuset 0.0</span><br><span class="line">khelper 0.0</span><br><span class="line">netns 0.0</span><br></pre></td></tr></table></figure><p>选项-o可以使用不同的参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pcpu</td><td>CPU占用率</td></tr><tr><td>pid</td><td>进程ID</td></tr><tr><td>ppid</td><td>父进程ID</td></tr><tr><td>pmem</td><td>内存使用率</td></tr><tr><td>comm</td><td>可执行文件名</td></tr><tr><td>cmd</td><td>简单命令</td></tr><tr><td>user</td><td>启动进程的用户</td></tr><tr><td>nice</td><td>优先级</td></tr><tr><td>time</td><td>累计的CPU时间</td></tr><tr><td>etime</td><td>进程启动后流逝的时间</td></tr><tr><td>tty</td><td>所关联的TTY设备</td></tr><tr><td>euid</td><td>有效用户ID</td></tr><tr><td>stat</td><td>进程状态</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top, 默认会输出一个占用CPU最多的进程列表。输出结果每隔几秒就会更新。</span></span><br><span class="line">$ top</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据参数对ps输出进行排序</span></span><br><span class="line">$ ps -eo comm,pcpu --sort -pcpu | head</span><br><span class="line">COMMAND %CPU</span><br><span class="line">Xorg 0.1</span><br><span class="line">hald-addon-stor 0.0</span><br><span class="line">ata/0 0.0</span><br><span class="line">scsi_eh_0 0.0</span><br><span class="line">gnome-settings- 0.0</span><br><span class="line">init 0.0</span><br><span class="line">hald 0.0</span><br><span class="line">pulseaudio 0.0</span><br><span class="line">gdm-simple-gree 0.0</span><br><span class="line">$ ps -eo comm,pid,pcpu,pmem | grep bash</span><br><span class="line">bash 1255 0.0 0.3</span><br><span class="line">bash 1680 5.5 0.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出给定命令名所对应的进程ID，在参数后加上=就可以移除列名。</span></span><br><span class="line">$ ps -C bash -o pid=</span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line">$ pgrep bash</span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用换行符作为定界符，而是要自行指定可以像下面这样：</span></span><br><span class="line">$ pgrep bash -d <span class="string">":"</span></span><br><span class="line">1255:1680</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定进程的用户（拥有者）列表：</span></span><br><span class="line">$ pgrep -u root,slynux COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据真实用户或ID以及有效用户或ID过滤ps输出</span></span><br><span class="line"> 用 -u EUSER1,EUSER2 …，指定有效用户列表；</span><br><span class="line"> 用 -U RUSER1,RUSER2 …，指定真实用户列表</span><br><span class="line">$ ps -u root -U root -o user,pcpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用TTY过滤ps输出, 可以通过指定进程所属的TTY选择ps的输出。用选项 -t指定TTY列表：</span></span><br><span class="line">$ ps -t pts/0,pts/1</span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1238 pts/0 00:00:00 bash</span><br><span class="line">1835 pts/1 00:00:00 bash</span><br><span class="line">1864 pts/0 00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程线程的相关信息</span></span><br><span class="line"><span class="comment"># 通常与进程线程相关的信息在ps输出中是看不到的。我们可以用选项 –L 在ps输出中显示线程的相关信息。这会显示出两列： NLWP和NLP。 NLWP是进程的线程数量， NLP是ps输出中每个条目的线程ID。例如：</span></span><br><span class="line">$ ps -eLf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出宽度以及所要显示的列</span></span><br><span class="line"><span class="comment"># 可以按照你自己的使用方式来进行应用。尝试以下选项:</span></span><br><span class="line"> -f ps –ef</span><br><span class="line"> u ps -e u</span><br><span class="line"> ps ps -e w（w表示宽松输出）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示进程的环境变量</span></span><br><span class="line"><span class="comment"># 了解某个进程依赖哪些环境变量，这类信息我们通常都用得着。进程的运行方式可能极其依赖某组环境变量。我们可以利用环境变量调试并修复与进程相关的问题。</span></span><br><span class="line">$ ps -eo pid,cmd e | tail -n 3</span><br><span class="line">1162 hald-addon-acpi: listening on acpid socket /var/run/acpid.socket</span><br><span class="line">1172 sshd: slynux [priv]</span><br><span class="line">1237 sshd: slynux@pts/0</span><br><span class="line">1238 -bash USER=slynux LOGNAME=slynux HOME=/home/slynux</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</span><br><span class="line">MAIL=/var/mail/slynux SHELL=/bin/bash SSH_CLIENT=10.211.55.2 49277 22</span><br><span class="line">SSH_CONNECTION=10.211.55.2 49277 10.211.55.4 22 SSH_TTY=/dev/pts/0 TERM=xterm-color</span><br><span class="line">LANG=en_IN XDG_SESSION_COOKIE=d1e96f5cc8a7a3bc3a0a73e44c95121a-1286499339.</span><br><span class="line">592429-1573657095</span><br></pre></td></tr></table></figure><h3 id="9-2-which、-whereis、-file、-whatis与平均负载"><a href="#9-2-which、-whereis、-file、-whatis与平均负载" class="headerlink" title="9.2 which、 whereis、 file、 whatis与平均负载"></a>9.2 which、 whereis、 file、 whatis与平均负载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># which, which命令用来找出某个命令的位置。</span></span><br><span class="line">$ <span class="built_in">which</span> ls</span><br><span class="line">/bin/ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis</span></span><br><span class="line"><span class="comment"># whereis与which命令类似，但它不仅返回命令的路径，还能够打印出其对应的命令手册的位置以及命令源代码的路径（如果有的话）</span></span><br><span class="line">$ whereis ls</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># file</span></span><br><span class="line">$ file FILENAME</span><br><span class="line"><span class="comment"># 该命令会打印出与该文件类型相关的细节信息。</span></span><br><span class="line">$ file /bin/ls</span><br><span class="line">/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked</span><br><span class="line">(uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.15, stripped</span><br><span class="line"></span><br><span class="line"><span class="comment"># whatis, whatis命令会输出作为参数的命令的简短描述信息。</span></span><br><span class="line">$ whatis ls</span><br><span class="line">ls (1) - list directory contents</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平均负载</span></span><br><span class="line">$ uptime</span><br><span class="line">12:40:53 up 6:16, 2 users, load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure><h3 id="9-3-杀死进程以及发送或响应信号"><a href="#9-3-杀死进程以及发送或响应信号" class="headerlink" title="9.3 杀死进程以及发送或响应信号"></a>9.3 杀死进程以及发送或响应信号</h3><p>信号是Linux中的一种进程间通信机制。 当进程接收到一个信号时，它会通过执行对应的信号处理程序（signal handler）来进行响应。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有可用的信号：</span></span><br><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止进程：</span></span><br><span class="line">$ <span class="built_in">kill</span> PROCESS_ID_LIST</span><br><span class="line"><span class="comment"># kill命令默认发出一个TERM信号。进程ID列表使用空格作为进程ID之间的定界符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要通过kill命令向进程发送指定的信号，可以使用：</span></span><br><span class="line">$ <span class="built_in">kill</span> -s SIGNAL PID</span><br><span class="line"><span class="comment"># 参数SIGNAL要么是信号名称，要么是信号编号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们经常要强行杀死进程，可以使用：</span></span><br><span class="line">$ <span class="built_in">kill</span> -s SIGKILL PROCESS_ID</span><br><span class="line">或者</span><br><span class="line">$ <span class="built_in">kill</span> -9 PROCESS_ID</span><br></pre></td></tr></table></figure><p>常用到的信号量：</p><ul><li>SIGHUP 1——对控制进程或终端的终结进行挂起检测（hangup detection）</li><li>SIGINT 2——当按下Ctrl + C时发送该信号 </li><li>SIGKILL 9——用于强行杀死进程 </li><li>SIGTERM 15——默认用于终止进程 </li><li>SIGTSTP 20——当按下Ctrl + Z时发送该信号 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># killall命令通过命令名终止进程：</span></span><br><span class="line">$ killall process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称向进程发送信号：</span></span><br><span class="line">$ killall -s SIGNAL process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称强行杀死进程：</span></span><br><span class="line">$ killall -9 process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># pkill命令和kill命令类似，不过默认情况下pkill接受的是进程名，而非进程ID。例如：</span></span><br><span class="line">$ pkill process_name</span><br><span class="line">$ pkill -s SIGNAL process_name</span><br><span class="line"><span class="comment"># pkill不支持信号名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕捉并响应信号</span></span><br><span class="line"><span class="comment"># trap命令在脚本中用来为信号分配信号处理程序。</span></span><br><span class="line">$ <span class="built_in">trap</span> <span class="string">'signal_handler_function_name'</span> SIGNAL LIST</span><br></pre></td></tr></table></figure><h3 id="9-4-向用户终端发送消息"><a href="#9-4-向用户终端发送消息" class="headerlink" title="9.4 向用户终端发送消息"></a>9.4 向用户终端发送消息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wall命令用来向当前所有登录用户的终端写入消息。</span></span><br><span class="line">$ cat message | wall</span><br><span class="line">或者</span><br><span class="line">$ wall&lt; message</span><br><span class="line">Broadcast Message from slynux@slynux-laptop</span><br><span class="line">(/dev/pts/1) at 12:54 ...</span><br><span class="line">This is a messag</span><br></pre></td></tr></table></figure><h3 id="9-5-采集系统信息"><a href="#9-5-采集系统信息" class="headerlink" title="9.5 采集系统信息"></a>9.5 采集系统信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印当前系统的主机名：</span></span><br><span class="line">$ hostname</span><br><span class="line">或者</span><br><span class="line">$ uname -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印Linux内核版本、硬件架构等详细信息：</span></span><br><span class="line">$ uname -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内核发行版本：</span></span><br><span class="line">$ uname -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印主机类型：</span></span><br><span class="line">$ uname -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印CPU相关信息：</span></span><br><span class="line">$ cat /proc/cpuinfo</span><br><span class="line"><span class="comment"># 获取处理器名称：</span></span><br><span class="line">$ cat /proc/cpuinfo | sed -n 5p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内存的详细信息：</span></span><br><span class="line">$ cat /proc/meminfo</span><br><span class="line"><span class="comment"># 打印系统可用内存总量：</span></span><br><span class="line">$ cat /proc/meminfo | head -1</span><br><span class="line">MemTotal: 1026096 kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出系统的分区信息：</span></span><br><span class="line">$ cat /proc/partitions</span><br><span class="line">或者</span><br><span class="line">$ fdisk -l <span class="comment">#如果没有输出，切换到root用户执行该命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取系统的详细信息：</span></span><br><span class="line">$ lshw <span class="comment">#建议以root用户来执行</span></span><br></pre></td></tr></table></figure><h3 id="9-6-使用-proc-采集信息"><a href="#9-6-使用-proc-采集信息" class="headerlink" title="9.6 使用 proc 采集信息"></a>9.6 使用 proc 采集信息</h3><p>以Bash为例，它的进程ID是4295（pgrep bash），那么就会有一个对应的目录/proc/4295。进程对应的目录中包含了大量有关进程的信息。 /proc/PID中一些重要的文件如下所示。 </p><ul><li><p>environ：包含与进程相关的环境变量。使用cat /proc/4295/environ，可以显示所有传递给该进程的环境变量 </p></li><li><p>cwd： 是一个到进程工作目录（working directory）的符号链接 </p></li><li><p>exe：是一个到当前进程所对应的可执行文件的符号链接 </p><p>$ readlink /proc/4295/exe<br>/bin/bash</p></li><li><p>fd：包含了进程所使用的文件描述符 </p></li></ul><h3 id="9-7-用-cron-进行调度"><a href="#9-7-用-cron-进行调度" class="headerlink" title="9.7 用 cron 进行调度"></a>9.7 用 cron 进行调度</h3><p><strong>crontab任务配置基本格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  *　 *　 *　   *　　command</span><br><span class="line">分钟(0-59)　小时(0-23)　日期(1-31)　 月份(1-12)　星期(0-6,0代表星期天)　  命令</span><br></pre></td></tr></table></figure><p>cron表中的每一个条目都由6部分组成，并按照下列顺序排列： </p><ul><li>分钟（0～59） </li><li>小时（0～23） </li><li>天（1～31） </li><li>月份（1～12） </li><li>工作日（0～6） </li><li>命令（在指定时间执行的脚本或命令） </li></ul><p>星号（*）指定命令应该在每个时间段执行。 </p><p>除了数字还有几个个特殊的符号就是 <code>&quot;*&quot;</code> 、<code>&quot;/&quot;</code> 和 <code>&quot;-&quot;</code> 、<code>&quot;,&quot;</code> ，<code>*</code> 代表所有的取值范围内的数字，<code>&quot;/&quot;</code> 代表每的意思, <code>&quot;*/5&quot;</code> 表示每5个单位，<code>&quot;-&quot;</code> 代表从某个数字到某个数字, <code>&quot;,&quot;</code> 分开几个离散的数字。以下举几个例子说明问题： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定每小时的第5分钟执行一次ls命令</span></span><br><span class="line">5 * * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每天的 5:30 执行ls命令</span></span><br><span class="line">30 5 * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每月8号的7：30分执行ls命令</span></span><br><span class="line">30 7 8 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每年的6月8日5：30执行ls命令</span></span><br><span class="line">30 5 8 6 * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每星期日的6:30执行ls命令 [ 注：0表示星期天，1表示星期1，以此类推，也可以用英文来表示，sun表示星期天，mon表示星期一等。 ]</span></span><br><span class="line">30 6 * * 0 ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月10号及20号的3：30执行ls命令 [注：“，”用来连接多个不连续的时段 ]</span></span><br><span class="line">30 3 10,20 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天8-11点的第25分钟执行ls命令 [注：“-”用来连接连续的时段 ]</span></span><br><span class="line">25 8-11 * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每15分钟执行一次ls命令 [即每个小时的第0 15 30 45 60分钟执行ls命令 ]</span></span><br><span class="line">*/15 * * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个月中，每隔10天6:30执行一次ls命令[即每月的1、11、21、31日是的6：30执行一次ls命令。 ]</span></span><br><span class="line">30 6 */10 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天7：50以root 身份执行/etc/cron.daily目录中的所有可执行文件</span></span><br><span class="line">50 7 * * * root run-parts /etc/cron.daily   <span class="comment"># [ 注：run-parts参数表示，执行后面目录中的所有可执行文件。 ]</span></span><br></pre></td></tr></table></figure><p><strong>配置用户定时任务的语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ crontab [-u user]file</span><br><span class="line"></span><br><span class="line">$ crontab -u user[-i]</span><br></pre></td></tr></table></figure><p>参数与说明：</p><ul><li>crontab -u        //设定某个用户的cron服务</li><li>crontab -l        //列出某个用户cron服务的详细内容</li><li>crontab -r              //删除没个用户的cron服务</li><li>crontab -e             //编辑某个用户的cron服务</li></ul><h3 id="9-8-从终端截图"><a href="#9-8-从终端截图" class="headerlink" title="9.8 从终端截图"></a>9.8 从终端截图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取整个屏幕：</span></span><br><span class="line">$ import -window root screenshot.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动选择部分区域进行抓取：</span></span><br><span class="line">$ import screenshot.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取特定窗口：</span></span><br><span class="line">$ import -window window_id screenshot.png</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本命令&quot;&gt;&lt;a href=&quot;#1-基本命令&quot; class=&quot;headerlink&quot; title=&quot;1. 基本命令&quot;&gt;&lt;/a&gt;1. 基本命令&lt;/h2&gt;&lt;h3 id=&quot;1-1-shell-格式输出&quot;&gt;&lt;a href=&quot;#1-1-shell-格式输出&quot; class=&quot;headerlink&quot; title=&quot;1.1 shell 格式输出&quot;&gt;&lt;/a&gt;1.1 shell 格式输出&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Hello world !&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n	&lt;span class=&quot;comment&quot;&gt;# 忽略结尾的换行符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-e	&lt;span class=&quot;comment&quot;&gt;# 激活转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-E	&lt;span class=&quot;comment&quot;&gt;# disable转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; -e &lt;span class=&quot;string&quot;&gt;&quot;1\t2\t3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://miaopei.github.io/categories/Shell/"/>
    
    
      <category term="shell" scheme="http://miaopei.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令eval的用法</title>
    <link href="http://miaopei.github.io/2017/04/13/Linux%E5%91%BD%E4%BB%A4eval%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://miaopei.github.io/2017/04/13/Linux命令eval的用法/</id>
    <published>2017-04-13T11:50:19.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eval-command-line"><a href="#eval-command-line" class="headerlink" title="eval command-line"></a>eval command-line</h2><p>其中command－line是在终端上键入的一条普通命令行。<strong>然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次</strong>。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pipe=<span class="string">"|"</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> ls <span class="variable">$pipe</span> wc -l</span><br></pre></td></tr></table></figure><p>shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。</p><a id="more"></a><p><strong>如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（；｜ &amp;），I／o重定向符（&lt; &gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。</strong></p><h2 id="eval-echo-取得最后一个参数"><a href="#eval-echo-取得最后一个参数" class="headerlink" title="eval echo $# 取得最后一个参数"></a>eval echo $# 取得最后一个参数</h2><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat last</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $<span class="variable">$#</span></span><br><span class="line"></span><br><span class="line">$ ./last one two three four</span><br><span class="line">four</span><br></pre></td></tr></table></figure><p>第一遍扫描后，shell把反斜杠去掉了。当shell再次扫描该行时，它替换了$4的值，并执行echo命令</p><h2 id="以下示意如何用eval命令创建指向变量的“指针”："><a href="#以下示意如何用eval命令创建指向变量的“指针”：" class="headerlink" title="以下示意如何用eval命令创建指向变量的“指针”："></a>以下示意如何用eval命令创建指向变量的“指针”：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ x=100</span><br><span class="line"></span><br><span class="line">$ ptrx=x</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> <span class="built_in">echo</span> $<span class="variable">$ptrx</span>  <span class="comment">#指向ptrx，用这里的方法可以理解b中的例子</span></span><br><span class="line">100 打印100</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> <span class="variable">$ptrx</span>=50  <span class="comment">#将50存到ptrx指向的变量中。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">50 打印50</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;eval-command-line&quot;&gt;&lt;a href=&quot;#eval-command-line&quot; class=&quot;headerlink&quot; title=&quot;eval command-line&quot;&gt;&lt;/a&gt;eval command-line&lt;/h2&gt;&lt;p&gt;其中command－line是在终端上键入的一条普通命令行。&lt;strong&gt;然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次&lt;/strong&gt;。如：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pipe=&lt;span class=&quot;string&quot;&gt;&quot;|&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;eval&lt;/span&gt; ls &lt;span class=&quot;variable&quot;&gt;$pipe&lt;/span&gt; wc -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。&lt;/p&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://miaopei.github.io/categories/Shell/"/>
    
    
      <category term="Linux Shell" scheme="http://miaopei.github.io/tags/Linux-Shell/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议原理分析</title>
    <link href="http://miaopei.github.io/2017/04/13/HTTP%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://miaopei.github.io/2017/04/13/HTTP协议原理分析/</id>
    <published>2017-04-13T04:26:05.000Z</published>
    <updated>2019-06-03T08:10:56.878Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1oMTI1MDYvYXJ0aWNsZS9kZXRhaWxzLzc3OTQ1MTI=" title="http://blog.csdn.net/lmh12506/article/details/7794512">深入理解HTTP协议、HTTP协议原理分析<i class="fa fa-external-link"></i></span></p><h3 id="基础概念篇"><a href="#基础概念篇" class="headerlink" title="基础概念篇"></a>基础概念篇</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。</p><a id="more"></a><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><h4 id="在TCP-IP协议栈中的位置"><a href="#在TCP-IP协议栈中的位置" class="headerlink" title="在TCP/IP协议栈中的位置"></a>在TCP/IP协议栈中的位置</h4><p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：</p><p><img src="http://i.imgur.com/mvKKFdQ.jpg" alt></p><p>默认HTTP的端口号为80，HTTPS的端口号为443。</p><h4 id="HTTP的请求响应模型"><a href="#HTTP的请求响应模型" class="headerlink" title="HTTP的请求响应模型"></a>HTTP的请求响应模型</h4><p>HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：</p><p><img src="http://i.imgur.com/1p1vQjT.jpg" alt></p><p>这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p><p>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><p>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</p><p>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p><p>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p><p>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p><h4 id="使用Wireshark抓TCP、http包"><a href="#使用Wireshark抓TCP、http包" class="headerlink" title="使用Wireshark抓TCP、http包"></a>使用Wireshark抓TCP、http包</h4><p>打开Wireshark，选择工具栏上的“Capture”-&gt;“Options”。</p><p>一般读者只需要选择最上边的下拉框，选择合适的Device，而后点击“Capture Filter”，此处选择的是“HTTP TCP port（80）”，选择后点击上图的“Start”开始抓包。</p><p>例如在浏览器中打开 <span class="exturl" data-url="aHR0cDovL2ltYWdlLmJhaWR1LmNvbS/vvIzmipPljIXlpoLkuIvlm77miYDnpLrvvJo=" title="http://image.baidu.com/，抓包如下图所示：">http://image.baidu.com/，抓包如下图所示：<i class="fa fa-external-link"></i></span></p><p><img src="http://i.imgur.com/1Ss1ckI.jpg" alt></p><p>在上图中，可清晰的看到客户端浏览器（ip为192.168.2.33）与服务器的交互过程：</p><p>1）No1：浏览器（192.168.2.33）向服务器（220.181.50.118）发出连接请求。此为TCP三次握手第一步，此时从图中可以看出，为SYN，seq:X （x=0）</p><p>2）No2：服务器（220.181.50.118）回应了浏览器（192.168.2.33）的请求，并要求确认，此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）。此为三次握手的第二步；</p><p>3）No3：浏览器（192.168.2.33）回应了服务器（220.181.50.118）的确认，连接成功。为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。此为三次握手的第三步；</p><p>4）No4：浏览器（192.168.2.33）发出一个页面HTTP请求；</p><p>5）No5：服务器（220.181.50.118）确认；</p><p>6）No6：服务器（220.181.50.118）发送数据；</p><p>7）No7：客户端浏览器（192.168.2.33）确认；</p><p>8）No14：客户端（192.168.2.33）发出一个图片HTTP请求；</p><p>9）No15：服务器（220.181.50.118）发送状态响应码200 OK</p><p>……</p><h4 id="头域"><a href="#头域" class="headerlink" title="头域"></a>头域</h4><p>每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p><p>在抓包的图中，No14点开可看到如下图所示：</p><p><img src="http://i.imgur.com/p2B4j3L.jpg" alt></p><p>回应的消息如下图所示：</p><p><img src="http://i.imgur.com/W0pbbs1.jpg" alt></p><h5 id="host头域"><a href="#host头域" class="headerlink" title="host头域"></a>host头域</h5><p>Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。</p><p>上图中host那行为：</p><p><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-6.jpg" alt="img"> </p><h5 id="Referer头域"><a href="#Referer头域" class="headerlink" title="Referer头域"></a>Referer头域</h5><p>Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。</p><p>在图4中，Referer行的内容为：<br>   <img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-7.jpg" alt="img"></p><h5 id="User-Agent头域"><a href="#User-Agent头域" class="headerlink" title="User-Agent头域"></a>User-Agent头域</h5><p>User-Agent头域的内容包含发出请求的用户信息。</p><p>在图4中，User-Agent行的内容为：</p><p><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-8.jpg" alt="img"></p><h5 id="Cache-Control头域"><a href="#Cache-Control头域" class="headerlink" title="Cache-Control头域"></a>Cache-Control头域</h5><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。</p><p>在图5中的该头域为：<br><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-9.jpg" alt="img"> </p><h5 id="Date头域"><a href="#Date头域" class="headerlink" title="Date头域"></a>Date头域</h5><p>Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p><p>图5中，该头域如下图所示：<br><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-10.jpg" alt="img"> </p><h4 id="HTTP的几个重要概念"><a href="#HTTP的几个重要概念" class="headerlink" title="HTTP的几个重要概念"></a>HTTP的几个重要概念</h4><h5 id="连接：connection"><a href="#连接：connection" class="headerlink" title="连接：connection"></a>连接：connection</h5><p>一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。</p><p>在http1.1，request和reponse头中都有可能出现一个connection的头，此header的含义是当client和server通信时对于长链接如何进行处理。</p><p>在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</p><h5 id="消息：Message"><a href="#消息：Message" class="headerlink" title="消息：Message"></a>消息：Message</h5><p>HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。</p><h5 id="请求：Request"><a href="#请求：Request" class="headerlink" title="请求：Request"></a>请求：Request</h5><p>一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号。</p><h5 id="响应：Response"><a href="#响应：Response" class="headerlink" title="响应：Response"></a>响应：Response</h5><p>一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。</p><h5 id="资源：Resource"><a href="#资源：Resource" class="headerlink" title="资源：Resource"></a>资源：Resource</h5><p>由URI标识的网络数据对象或服务。</p><h5 id="实体：Entity"><a href="#实体：Entity" class="headerlink" title="实体：Entity"></a>实体：Entity</h5><p>数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。</p><h5 id="客户机：Client"><a href="#客户机：Client" class="headerlink" title="客户机：Client"></a>客户机：Client</h5><p>一个为发送请求目的而建立连接的应用程序。</p><h5 id="用户代理：UserAgent"><a href="#用户代理：UserAgent" class="headerlink" title="用户代理：UserAgent"></a>用户代理：UserAgent</h5><p>初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。</p><h5 id="服务器：Server"><a href="#服务器：Server" class="headerlink" title="服务器：Server"></a>服务器：Server</h5><p>一个接受连接并对请求返回信息的应用程序。</p><h5 id="源服务器：Originserver"><a href="#源服务器：Originserver" class="headerlink" title="源服务器：Originserver"></a>源服务器：Originserver</h5><p>是一个给定资源可以在其上驻留或被创建的服务器。</p><h5 id="代理：Proxy"><a href="#代理：Proxy" class="headerlink" title="代理：Proxy"></a>代理：Proxy</h5><p>一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。</p><p>代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p><h5 id="网关：Gateway"><a href="#网关：Gateway" class="headerlink" title="网关：Gateway"></a>网关：Gateway</h5><p>一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。</p><p>网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</p><h5 id="通道：Tunnel"><a href="#通道：Tunnel" class="headerlink" title="通道：Tunnel"></a>通道：Tunnel</h5><p>是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p><h5 id="缓存：Cache"><a href="#缓存：Cache" class="headerlink" title="缓存：Cache"></a>缓存：Cache</h5><p>反应信息的局域存储。</p><h4 id="附录：参考资料"><a href="#附录：参考资料" class="headerlink" title="附录：参考资料"></a>附录：参考资料</h4><p><a href="[http://baike.baidu.com/view/9472.htm](http://baike.baidu.com/view/9472.htm)">ttp_百度百科</a></p><p><a href="[http://blog.tieniu1980.cn/archives/377](http://blog.tieniu1980.cn/archives/377)">结果编码和http状态响应码</a></p><p><a href="[http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763104c8c711923d030678197027fa3c215cc7905141130a8e5747e0d548d9](http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763104c8c711923d030678197027fa3c215cc7905141130a8e5747e0d548d98297a5ae91e03f7f63772315477e3cacdd94cdbbdc42225d82c36734f844315c419d891007a9f34d507a9f916a2e1b065d2f48193864353bb15543897f1fb4d711edd1b86033093b1e94e022e67adec40728e2e605f983431c5508fe4&p=c6769a46c5820efd08e2973b42&user=baidu)">分析TCP的三次握手</a></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuMTYzLmNvbS93YW5nYm9fdGVzdGVyL2Jsb2cvc3RhdGljLzEyODA2NzkyMTIwMDk4MTc0MTYyMjg4Lw==" title="http://blog.163.com/wangbo_tester/blog/static/12806792120098174162288/">使用Wireshark来检测一次HTTP连接过程<i class="fa fa-external-link"></i></span></p><p><a href="[http://nc.mofcom.gov.cn/news/10819972.html](http://nc.mofcom.gov.cn/news/10819972.html)">http协议的几个重要概念</a></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFyZm9vL2FyY2hpdmUvMjAwOC8wNi8wNS8yNTE0NjY3LmFzcHg=" title="http://blog.csdn.net/barfoo/archive/2008/06/05/2514667.aspx">http协议中connection头的作用<i class="fa fa-external-link"></i></span></p><h3 id="协议详解篇"><a href="#协议详解篇" class="headerlink" title="协议详解篇"></a>协议详解篇</h3><h4 id="HTTP-1-0和HTTP-1-1的比较"><a href="#HTTP-1-0和HTTP-1-1的比较" class="headerlink" title="HTTP/1.0和HTTP/1.1的比较"></a>HTTP/1.0和HTTP/1.1的比较</h4><p>RFC 1945定义了HTTP/1.0版本，RFC 2616定义了HTTP/1.1版本。</p><p>笔者在blog上提供了这两个RFC中文版的下载地址。</p><p>RFC1945下载地址：</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ibG9namF2YVsuTmV0XShodHRwOi8vbGliLmNzZG4ubmV0L2Jhc2UvZG90bmV0KS9GaWxlcy9hbWlnb3hpZS9SRkMxOTQ1" title="http://www.blogjava[.Net](http://lib.csdn.net/base/dotnet)/Files/amigoxie/RFC1945">（HTTP）中文版.rar<i class="fa fa-external-link"></i></span></p><p>RFC2616下载地址：</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ibG9namF2YS5uZXQvRmlsZXMvYW1pZ294aWUvUkZDMjYxNg==" title="http://www.blogjava.net/Files/amigoxie/RFC2616">（HTTP）中文版.rar<i class="fa fa-external-link"></i></span></p><h5 id="建立连接方面"><a href="#建立连接方面" class="headerlink" title="建立连接方面"></a>建立连接方面</h5><p>HTTP/1.0 每次请求都需要建立新的TCP连接，连接不能复用。HTTP/1.1 新的请求可以在上次请求建立的TCP连接之上发送，连接可以复用。优点是减少重复进行TCP三次握手的开销，提高效率。</p><p>注意：在同一个TCP连接中，新的请求需要等上次请求收到响应后，才能发送。</p><h5 id="Host域"><a href="#Host域" class="headerlink" title="Host域"></a>Host域</h5><p>HTTP1.1在Request消息头里头多了一个Host域, HTTP1.0则没有这个域。</p><p>Eg：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">    GET /pub/WWW/TheProject.html HTTP/1.1<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">    Host: <span class="exturl" data-url="aHR0cDovL3d3dy53My5vcmc=" title="http://www.w3.org">www.w3.org<i class="fa fa-external-link"></i></span></p><p>​    可能HTTP1.0的时候认为，建立TCP连接的时候已经指定了IP地址，这个IP地址上只有一个host。</p><h5 id="日期时间戳"><a href="#日期时间戳" class="headerlink" title="日期时间戳"></a>日期时间戳</h5><p>(接收方向)</p><p>无论是HTTP1.0还是HTTP1.1，都要能解析下面三种date/time stamp：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Sun, 06 Nov 1994 08:49:37 GMT ; RFC 822, updated by RFC 1123<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Sun Nov 6 08:49:37 1994       ; ANSI C’s asctime() format</p><p>(发送方向)</p><p>HTTP1.0要求不能生成第三种asctime格式的date/time stamp；</p><p>HTTP1.1则要求只生成RFC 1123(第一种)格式的date/time stamp。</p><h5 id="状态响应码"><a href="#状态响应码" class="headerlink" title="状态响应码"></a>状态响应码</h5><p>状态响应码100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p><p>客户端在Request头部中包含</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Expect: 100-continue</p><p>​       Server看到之后呢如果回100 (Continue) 这个状态代码，客户端就继续发request body。这个是HTTP1.1才有的。</p><p>另外在HTTP/1.1中还增加了101、203、205等等性状态响应码</p><h5 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h5><p>HTTP1.1增加了OPTIONS, PUT, DELETE, TRACE, CONNECT这些Request方法.</p><p>​       Method         = “<strong>OPTIONS</strong>“                ; Section 9.2</p><p>​                      | “GET”                    ; Section 9.3</p><p>​                      | “HEAD”                   ; Section 9.4</p><p>​                      | “POST”                   ; Section 9.5</p><p>​                      | “<strong>PUT</strong>“                    ; Section 9.6</p><p>​                      | “<strong>DELETE</strong>“                 ; Section 9.7</p><p>​                      | “<strong>TRACE</strong>“                  ; Section 9.8</p><p>​                      | “<strong>CONNECT</strong>“                ; Section 9.9</p><p>​                      | extension-method</p><p>​       extension-method = token</p><h4 id="HTTP请求消息"><a href="#HTTP请求消息" class="headerlink" title="HTTP请求消息"></a>HTTP请求消息</h4><h5 id="请求消息格式"><a href="#请求消息格式" class="headerlink" title="请求消息格式"></a>请求消息格式</h5><p>请求消息格式如下所示：</p><blockquote><p> 请求行</p></blockquote><blockquote><p> 通用信息头|请求头|实体头</p></blockquote><blockquote><p> CRLF(回车换行)</p></blockquote><blockquote><p> 实体内容</p></blockquote><blockquote><p> 其中“请求行”为：请求行 = 方法 [空格] 请求URI [空格] 版本号 [回车换行]</p></blockquote><p>请求行实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Eg1：</span><br><span class="line">GET /index.html HTTP/1.1</span><br><span class="line"></span><br><span class="line">Eg2：</span><br><span class="line">POST http://192.168.2.217:8080/index.jsp HTTP/1.1</span><br><span class="line"></span><br><span class="line">HTTP请求消息实例：</span><br><span class="line">GET /hello.htm HTTP/1.1</span><br><span class="line">Accept: /</span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">If-Modified-Since: Wed, 17 Oct 2007 02:15:55 GMT</span><br><span class="line">If-None-Match: W/&quot;158-1192587355000&quot;</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)</span><br><span class="line">Host: 192.168.2.162:8080</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>HTTP的请求方法包括如下几种：</p><p><strong><code>GET</code></strong></p><p><strong><code>POST</code></strong></p><p><strong><code>HEAD</code></strong></p><p><strong><code>PUT</code></strong></p><p><strong><code>DELETE</code></strong></p><p><strong><code>OPTIONS</code></strong></p><p><strong><code>TRACE</code></strong></p><p><strong><code>CONNECT</code></strong></p><h4 id="HTTP响应消息"><a href="#HTTP响应消息" class="headerlink" title="HTTP响应消息"></a>HTTP响应消息</h4><h5 id="响应消息格式"><a href="#响应消息格式" class="headerlink" title="响应消息格式"></a>响应消息格式</h5><p>HTTP响应消息的格式如下所示：</p><blockquote><p> 状态行</p></blockquote><blockquote><p> 通用信息头|响应头|实体头</p></blockquote><blockquote><p> CRLF</p></blockquote><blockquote><p> 实体内容</p></blockquote><blockquote><p> 其中：状态行 = 版本号 [空格] 状态码 [空格] 原因 [回车换行]</p></blockquote><p>状态行举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Eg1：</span><br><span class="line">HTTP/1.0 200 OK </span><br><span class="line"></span><br><span class="line">Eg2：</span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">     </span><br><span class="line">HTTP响应消息实例如下所示：</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">ETag: W/&quot;158-1192590101000&quot;</span><br><span class="line">Last-Modified: Wed, 17 Oct 2007 03:01:41 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 158</span><br><span class="line">Date: Wed, 17 Oct 2007 03:01:59 GMT</span><br><span class="line">Server: Apache-Coyote/1.1</span><br></pre></td></tr></table></figure><h5 id="htpp的状态响应码"><a href="#htpp的状态响应码" class="headerlink" title="htpp的状态响应码"></a>htpp的状态响应码</h5><h6 id="1-：请求收到，继续处理"><a href="#1-：请求收到，继续处理" class="headerlink" title="1**：请求收到，继续处理"></a>1**：请求收到，继续处理</h6><p>100——客户必须继续发出请求</p><p>101——客户要求服务器根据请求转换HTTP协议版本</p><h6 id="2-：操作成功收到，分析、接受"><a href="#2-：操作成功收到，分析、接受" class="headerlink" title="2**：操作成功收到，分析、接受"></a>2**：操作成功收到，分析、接受</h6><p>200——交易成功</p><p>201——提示知道新文件的URL</p><p>202——接受和处理、但处理未完成</p><p>203——返回信息不确定或不完整</p><p>204——请求收到，但返回信息为空</p><p>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</p><p>206——服务器已经完成了部分用户的GET请求</p><h6 id="3-：完成此请求必须进一步处理"><a href="#3-：完成此请求必须进一步处理" class="headerlink" title="3**：完成此请求必须进一步处理"></a>3**：完成此请求必须进一步处理</h6><p>300——请求的资源可在多处得到</p><p>301——删除请求数据</p><p>302——在其他地址发现了请求数据</p><p>303——建议客户访问其他URL或访问方式</p><p>304——客户端已经执行了GET，但文件未变化</p><p>305——请求的资源必须从服务器指定的地址得到</p><p>306——前一版本HTTP中使用的代码，现行版本中不再使用</p><p>307——申明请求的资源临时性删除</p><h6 id="4-：请求包含一个错误语法或者不能完成"><a href="#4-：请求包含一个错误语法或者不能完成" class="headerlink" title="4**：请求包含一个错误语法或者不能完成"></a>4**：请求包含一个错误语法或者不能完成</h6><p>400——错误请求，如语法错误</p><p>401——未授权</p><p>HTTP 401.1 - 未授权：登录失败</p><p>　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败</p><p>　　HTTP 401.3 - ACL 禁止访问资源</p><p>　　HTTP 401.4 - 未授权：授权被筛选器拒绝</p><p>HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</p><p>402——保留有效ChargeTo头响应</p><p>403——禁止访问</p><p>HTTP 403.1 禁止访问：禁止可执行访问</p><p>　　HTTP 403.2 - 禁止访问：禁止读访问</p><p>　　HTTP 403.3 - 禁止访问：禁止写访问</p><p>　　HTTP 403.4 - 禁止访问：要求 SSL</p><p>　　HTTP 403.5 - 禁止访问：要求 SSL 128</p><p>　　HTTP 403.6 - 禁止访问：IP 地址被拒绝</p><p>　　HTTP 403.7 - 禁止访问：要求客户证书</p><p>　　HTTP 403.8 - 禁止访问：禁止站点访问</p><p>　　HTTP 403.9 - 禁止访问：连接的用户过多</p><p>　　HTTP 403.10 - 禁止访问：配置无效</p><p>　　HTTP 403.11 - 禁止访问：密码更改</p><p>　　HTTP 403.12 - 禁止访问：映射器拒绝访问</p><p>　　HTTP 403.13 - 禁止访问：客户证书已被吊销</p><p>　　HTTP 403.15 - 禁止访问：客户访问许可过多</p><p>　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效</p><p>HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</p><p>404——没有发现文件、查询或URl</p><p>405——用户在Request-Line字段定义的方法不允许</p><p>406——根据用户发送的Accept拖，请求资源不可访问</p><p>407——类似401，用户必须首先在代理服务器上得到授权</p><p>408——客户端没有在用户指定的饿时间内完成请求</p><p>409——对当前资源状态，请求不能完成</p><p>410——服务器上不再有此资源且无进一步的参考地址</p><p>411——服务器拒绝用户定义的Content-Length属性请求</p><p>412——一个或多个请求头字段在当前请求中错误</p><p>413——请求的资源大于服务器允许的大小</p><p>414——请求的资源URL长于服务器允许的长度</p><p>415——请求资源不支持请求项目格式</p><p>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</p><p>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p><h6 id="5-：服务器执行一个完全有效请求失败"><a href="#5-：服务器执行一个完全有效请求失败" class="headerlink" title="5**：服务器执行一个完全有效请求失败"></a>5**：服务器执行一个完全有效请求失败</h6><p>HTTP 500 - 内部服务器错误</p><p>HTTP 500.100 - 内部服务器错误 - ASP 错误</p><p>HTTP 500-11 服务器关闭</p><p>HTTP 500-12 应用程序重新启动</p><p>HTTP 500-13 - 服务器太忙</p><p>HTTP 500-14 - 应用程序无效</p><p>HTTP 500-15 - 不允许请求 global.asa</p><p>Error 501 - 未实现</p><p>HTTP 502 - 网关错误</p><h4 id="使用Telnet进行http测试"><a href="#使用Telnet进行http测试" class="headerlink" title="使用Telnet进行http测试"></a>使用Telnet进行http测试</h4><p> 在Windows下，可使用命令窗口进行http简单<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL3NvZnR3YXJldGVzdA==" title="http://lib.csdn.net/base/softwaretest">测试<i class="fa fa-external-link"></i></span>。</p><p>输入cmd进入命令窗口，在命令行键入如下命令后按回车：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ telnet www.baicu.com 80</span><br></pre></td></tr></table></figure><p>而后在窗口中按下“Ctrl+]”后按回车可让返回结果回显。</p><p>接着开始发请求消息，例如发送如下请求消息请求baidu的首页消息，使用的HTTP协议为HTTP/1.1：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">GET /index.html HTTP/1.1</p><p>   注意：copy如上的消息到命令窗口后需要按两个回车换行才能得到响应的消息，第一个回车换行是在命令后键入回车换行，是HTTP协议要求的。第二个是确认输入，发送请求。</p><p>可看到返回了200 OK的消息，如下图所示：</p><p><img src="http://i.imgur.com/LcFwiM2.jpg" alt></p><p>可看到，当采用HTTP/1.1时，连接不是在请求结束后就断开的。若采用HTTP1.0，在命令窗口键入：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">GET /index.html HTTP/1.0</p><p>此时可以看到请求结束之后马上断开。</p><p>读者还可以尝试在使用GET或POST等时，带上头域信息，例如键入如下信息：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">GET /index.html HTTP/1.1<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">connection: close<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Host: <span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20=" title="http://www.baidu.com">www.baidu.com<i class="fa fa-external-link"></i></span></p><h4 id="常用的请求方式"><a href="#常用的请求方式" class="headerlink" title="常用的请求方式"></a>常用的请求方式</h4><p>常用的请求方式是GET和POST.</p><blockquote><p> <strong>GET方式</strong>：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。</p><p> <strong>POST方式</strong>：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能：</p><blockquote><p>1：对现有资源的解释；</p><p>2：向电子公告栏、新闻组、邮件列表或类似讨论组发信息；</p><p>3：提交数据块；</p><p>4：通过附加操作来扩展<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL215c3Fs" title="http://lib.csdn.net/base/mysql">数据库<i class="fa fa-external-link"></i></span> 。</p></blockquote></blockquote><p>从上面描述可以看出，Get是向服务器发索取数据的一种请求；而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。</p><p>GET与POST方法有以下区别：</p><p>（1）   在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。</p><p>（2）   GET方式提交的数据最多只能有1024字节，而POST则没有此限制。</p><p>（3）   安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。</p><p>（4）   安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比方说文章下面出现一条注解）。</p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>HTTP最常见的请求头如下：</p><p><strong><code>Accept</code></strong>：浏览器可接受的MIME类型；</p><p><strong><code>Accept-Charset</code></strong>：浏览器可接受的字符集；</p><p><strong><code>Accept-Encoding</code></strong>：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间；</p><p><strong><code>Accept-Language</code></strong>：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到；</p><p><strong><code>Authorization</code></strong>：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；</p><p><strong><code>Connection</code></strong>：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；</p><p><strong><code>Content-Length</code></strong>：表示请求消息正文的长度；</p><p><strong><code>Cookie</code></strong>：这是最重要的请求头信息之一；</p><p><strong><code>From</code></strong>：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它；</p><p><strong><code>Host</code></strong>：初始URL中的主机和端口；</p><p><strong><code>If-Modified-Since</code></strong>：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答；</p><p><strong><code>Pragma</code></strong>：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；</p><p><strong><code>Referer</code></strong>：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p><p><strong><code>User-Agent</code></strong>：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用；</p><p><strong><code>UA-Pixels，UA-Color，UA-OS，UA-CPU</code></strong>：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL29wZXJhdGluZ3N5c3RlbQ==" title="http://lib.csdn.net/base/operatingsystem">操作系统<i class="fa fa-external-link"></i></span>和CPU类型。</p><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>HTTP最常见的响应头如下所示：</p><p><strong><code>Allow</code></strong>：服务器支持哪些请求方法（如GET、POST等）；</p><p><strong><code>Content-Encoding</code></strong>：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2phdmFzZQ==" title="http://lib.csdn.net/base/javase">Java<i class="fa fa-external-link"></i></span>的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面；</p><p><strong><code>Content-Length</code></strong>：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容；</p><p><strong><code>Content-Type</code></strong>： 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系；</p><p><strong><code>Date</code></strong>：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦；</p><p><strong><code>Expires</code></strong>：指明应该在什么时候认为文档已经过期，从而不再缓存它。</p><p><strong><code>Last-Modified</code></strong>：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置；</p><p><strong><code>Location</code></strong>：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；</p><p><strong><code>Refresh</code></strong>：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=””)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的&lt;META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=””&gt;实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是&lt;META HTTP-EQUIV=”Refresh” …&gt;。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p><h4 id="实体头"><a href="#实体头" class="headerlink" title="实体头"></a>实体头</h4><p>实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。</p><p><strong><code>Allow</code></strong>：GET,POST</p><p><strong><code>Content-Encoding</code></strong>：文档的编码（Encode）方法，例如：gzip，见“2.5 响应头”；</p><p><strong><code>Content-Language</code></strong>：内容的语言类型，例如：zh-cn；</p><p><strong><code>Content-Length</code></strong>：表示内容长度，eg：80，可参考“2.5响应头”；</p><p><strong><code>Content-Location</code></strong>：表示客户应当到哪里去提取文档，例如：<span class="exturl" data-url="aHR0cDovL3d3dy5kZmRmLm9yZy9kZmRmLmh0bWzvvIzlj6/lj4LogIPigJwyLjXlk43lupTlpLTigJ3vvJs=" title="http://www.dfdf.org/dfdf.html，可参考“2.5响应头”；">http://www.dfdf.org/dfdf.html，可参考“2.5响应头”；<i class="fa fa-external-link"></i></span></p><p><strong><code>Content-MD5</code></strong>：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5: &lt;base64 of 128 MD5 digest&gt;。Eg2：dfdfdfdfdfdfdff==；</p><p><strong><code>Content-Range</code></strong>：随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898</p><p><strong><code>Content-Type</code></strong>：标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312       主类型/子类型；</p><p><strong><code>Expires</code></strong>：为0证明不缓存；</p><p><strong>`Last-Modified</strong>`：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT<strong>.</strong></p><h4 id="扩展头"><a href="#扩展头" class="headerlink" title="扩展头"></a>扩展头</h4><p>在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。</p><p>现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。</p><p><strong><code>Refresh</code></strong>：1;url=<span class="exturl" data-url="aHR0cDovL3d3dy5kZmRmLm9yZw==" title="http://www.dfdf.org">http://www.dfdf.org<i class="fa fa-external-link"></i></span>  //过1秒跳转到指定位置；</p><p><strong><code>Content-Disposition</code></strong>：头字段,可参考“2.5响应头”；</p><p><strong><code>Content-Type</code></strong>：WEB 服务器告诉浏览器自己响应的对象的类型。</p><p>eg1：Content-Type：application/xml ；</p><p>eg2：applicaiton/octet-stream；</p><p><strong>Content-Disposition</strong>：attachment; filename=aaa.zip。</p><h4 id="附录：参考资料-1"><a href="#附录：参考资料-1" class="headerlink" title="附录：参考资料"></a>附录：参考资料</h4><p><a href="[http://blog.csdn.net/yanghehong/archive/2009/05/28/4222594.aspx](http://blog.csdn.net/yanghehong/archive/2009/05/28/4222594.aspx)">HTTP1.1和HTTP1.0的区别</a></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ibG9namF2YS5uZXQvaG9uZXliZWUvYXJ0aWNsZXMvMTY0MDA4Lmh0bWw=" title="http://www.blogjava.net/honeybee/articles/164008.html">HTTP请求（GET和POST区别）和响应<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3poaWRhby5iYWlkdS5jb20vcXVlc3Rpb24vMzI1MTc0MjcuaHRtbA==" title="http://zhidao.baidu.com/question/32517427.html">HTTP请求头概述_百度知道<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS90b25nemhpeW9uZy9hcmNoaXZlLzIwMDgvMDMvMTYvMTEwODc3Ni5odG1s" title="http://www.cnblogs.com/tongzhiyong/archive/2008/03/16/1108776.html">实体头和扩展头实体头和扩展头<i class="fa fa-external-link"></i></span></p><h3 id="深入了解篇"><a href="#深入了解篇" class="headerlink" title="深入了解篇"></a>深入了解篇</h3><h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><p>Cookie和Session都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决HTTP无状态的问题而所做的努力。</p><p>Session可以用Cookie来实现，也可以用URL回写的机制来实现。用Cookie来实现的Session可以认为是对Cookie更高级的应用。</p><h5 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h5><p>Cookie和Session有以下明显的不同点：</p><p>1）Cookie将状态保存在客户端，Session将状态保存在服务器端；</p><p>2）Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。Cookie最早在RFC2109中实现，后续RFC2965做了增强。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。Session并没有在HTTP的协议中定义；</p><p>3）Session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器；</p><p>4）就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的SESSION机制更安全些.因为它不会任意读取客户存储的信息。</p><h5 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h5><p>Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p><p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为 session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个 session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id将被在本次响应中返回给客户端保存。</p><h5 id="Session的实现机制"><a href="#Session的实现机制" class="headerlink" title="Session的实现机制"></a>Session的实现机制</h5><h6 id="使用Cookie来实现"><a href="#使用Cookie来实现" class="headerlink" title="使用Cookie来实现"></a>使用Cookie来实现</h6><p>服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。</p><p>当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID。这样服务器能够找到这个客户端对应的Session。</p><p>流程如下图所示：</p><p><img src="http://i.imgur.com/88bVlwm.jpg" alt></p><h6 id="使用URL回显来实现"><a href="#使用URL回显来实现" class="headerlink" title="使用URL回显来实现"></a>使用URL回显来实现</h6><p>URL回写是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带会服务器。</p><p>如果直接在浏览器输入服务端资源的url来请求该资源，那么Session是匹配不到的。</p><p>Tomcat对Session的实现，是一开始同时使用Cookie和URL回写机制，如果发现客户端支持Cookie，就继续使用Cookie，停止使用URL回写。如果发现Cookie被禁用，就一直使用URL回写。jsp开发处理到Session的时候，对页面中的链接记得使用response.encodeURL() 。</p><h5 id="在J2EE项目中Session失效的几种情况"><a href="#在J2EE项目中Session失效的几种情况" class="headerlink" title="在J2EE项目中Session失效的几种情况"></a>在J2EE项目中Session失效的几种情况</h5><p>1）Session超时：Session在指定时间内失效，例如30分钟，若在30分钟内没有操作，则Session会失效，例如在web.xml中进行了如下设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span> //单位：分钟</span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）使用 <code>session.invalidate()</code> 明确的去掉Session。</p><h5 id="与Cookie相关的HTTP扩展头"><a href="#与Cookie相关的HTTP扩展头" class="headerlink" title="与Cookie相关的HTTP扩展头"></a>与Cookie相关的HTTP扩展头</h5><p>1）<strong>Cookie</strong>：客户端将服务器设置的Cookie返回到服务器；</p><p>2）<strong>Set-Cookie</strong>：服务器向客户端设置Cookie；</p><p>3）<strong>Cookie2</strong> (RFC2965)）：客户端指示服务器支持Cookie的版本；</p><p>4）<strong>Set-Cookie2</strong> (RFC2965)：服务器向客户端设置Cookie。</p><h5 id="Cookie的流程"><a href="#Cookie的流程" class="headerlink" title="Cookie的流程"></a>Cookie的流程</h5><p>服务器在响应消息中用Set-Cookie头将Cookie的内容回送给客户端，客户端在新的请求中将相同的内容携带在Cookie头中发送给服务器。从而实现会话的保持。</p><p>流程如下图所示：</p><p><img src="http://i.imgur.com/FqfZ73s.jpg" alt></p><h4 id="缓存的实现原理"><a href="#缓存的实现原理" class="headerlink" title="缓存的实现原理"></a>缓存的实现原理</h4><h5 id="什么是Web缓存"><a href="#什么是Web缓存" class="headerlink" title="什么是Web缓存"></a>什么是Web缓存</h5><p>WEB缓存(cache)位于Web服务器和客户端之间。</p><p>缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p><p>HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。</p><h5 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a>缓存的优点</h5><blockquote><p> <strong>减少相应延迟</strong>：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让web服务器看上去相应更快。</p></blockquote><blockquote><p> <strong>减少网络带宽消耗</strong>：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。</p></blockquote><h5 id="与缓存相关的HTTP扩展消息头"><a href="#与缓存相关的HTTP扩展消息头" class="headerlink" title="与缓存相关的HTTP扩展消息头"></a>与缓存相关的HTTP扩展消息头</h5><blockquote><p> <strong>Expires</strong>：指示响应内容过期的时间，格林威治时间GMT</p></blockquote><blockquote><p> <strong>Cache-Control</strong>：更细致的控制缓存的内容</p></blockquote><blockquote><p> <strong>Last-Modified</strong>：响应中资源最后一次修改的时间</p></blockquote><blockquote><p> <strong>ETag</strong>：响应中资源的校验值，在服务器上某个时段是唯一标识的。</p></blockquote><blockquote><p> <strong>Date</strong>：服务器的时间</p></blockquote><blockquote><p> <strong>If-Modified-Since</strong>：客户端存取的该资源最后一次修改的时间，同Last-Modified。</p></blockquote><blockquote><p> <strong>If-None-Match</strong>：客户端存取的该资源的检验值，同ETag。</p></blockquote><h5 id="客户端缓存生效的常见流程"><a href="#客户端缓存生效的常见流程" class="headerlink" title="客户端缓存生效的常见流程"></a>客户端缓存生效的常见流程</h5><p>服务器收到请求时，会在200OK中回送该资源的Last-Modified和ETag头，客户端将该资源保存在cache中，并记录这两个属性。当客户端需要发送相同的请求时，会在请求中携带If-Modified-Since和If-None-Match两个头。两个头的值分别是响应中Last-Modified和ETag头的值。服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回304响应。常见流程如下图所示：</p><p><img src="http://i.imgur.com/VsalGBW.jpg" alt></p><h5 id="Web缓存机制"><a href="#Web缓存机制" class="headerlink" title="Web缓存机制"></a>Web缓存机制</h5><p>HTTP/1.1中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。前者减少了网络回路的数量；HTTP利用一个“过期（expiration）”机制来为此目的。后者减少了网络应用的带宽；HTTP用“验证（validation）”机制来为此目的。</p><p>HTTP定义了3种缓存机制：</p><p>1）<strong>Freshness</strong>：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。例如，Expires回应头给了一个文档不可用的时间。Cache-Control中的max-age标识指明了缓存的最长时间；</p><p>2）<strong>Validation</strong>：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个Last-Modified回应头，缓存能够使用If-Modified-Since来判断是否已改变，以便判断根据情况发送请求；</p><p>3）<strong>Invalidation：</strong> 在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个URL关联到一个缓存回应，但是其后跟着POST、PUT和DELETE的请求的话，缓存就会过期。</p><h4 id="断点续传和多线程下载的实现原理"><a href="#断点续传和多线程下载的实现原理" class="headerlink" title="断点续传和多线程下载的实现原理"></a>断点续传和多线程下载的实现原理</h4><blockquote><p> HTTP协议的GET方法，支持只请求某个资源的某一部分；</p></blockquote><blockquote><p> 206 Partial Content 部分内容响应；</p></blockquote><blockquote><p> Range 请求的资源范围；</p></blockquote><blockquote><p> Content-Range 响应的资源范围；</p></blockquote><blockquote><p> 在连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，来实现断点续传。</p></blockquote><p>分块请求资源实例：</p><p>Eg1：*<em>Range: bytes=306302- *</em>：请求这个资源从306302个字节到末尾的部分；</p><p>Eg2：<strong>Content-Range: bytes 306302-604047/604048</strong>：响应中指示携带的是该资源的第306302-604047的字节，该资源共604048个字节；</p><p>客户端通过并发的请求相同资源的不同片段，来实现对某个资源的并发分块下载。从而达到快速下载的目的。目前流行的FlashGet和迅雷基本都是这个原理。</p><p>多线程下载的原理：</p><blockquote><p> 下载工具开启多个发出HTTP请求的线程；</p></blockquote><blockquote><p> 每个http请求只请求资源文件的一部分：Content-Range: bytes 20000-40000/47000；</p></blockquote><blockquote><p> 合并每个线程下载的文件。</p></blockquote><h4 id="https通信过程"><a href="#https通信过程" class="headerlink" title="https通信过程"></a>https通信过程</h4><h5 id="什么是https"><a href="#什么是https" class="headerlink" title="什么是https"></a>什么是https</h5><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容请看SSL。</p><p>见下图：</p><p><img src="http://i.imgur.com/mvKKFdQ.jpg" alt></p><p>https所用的端口号是443。</p><h5 id="https的实现原理"><a href="#https的实现原理" class="headerlink" title="https的实现原理"></a>https的实现原理</h5><p>有两种基本的加解密<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2RhdGFzdHJ1Y3R1cmU=" title="http://lib.csdn.net/base/datastructure">算法<i class="fa fa-external-link"></i></span>类型：</p><p>1）<strong>对称加密</strong>：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p><p>2）<strong>非对称加密</strong>：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p><p>下面看一下https的通信过程：</p><p><img src="http://i.imgur.com/Oh4J5PJ.jpg" alt></p><p>https通信的优点：</p><p>1）客户端产生的密钥只有客户端和服务器端能得到；</p><p>2）加密的数据只有客户端和服务器端才能得到明文；</p><p>3）客户端到服务端的通信是安全的。</p><h4 id="http代理"><a href="#http代理" class="headerlink" title="http代理"></a>http代理</h4><h5 id="http代理服务器"><a href="#http代理服务器" class="headerlink" title="http代理服务器"></a>http代理服务器</h5><p>代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。</p><p>代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p><p>而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。</p><p>更重要的是：Proxy Server(代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI)模型的对话层。</p><h5 id="http代理服务器的主要功能"><a href="#http代理服务器的主要功能" class="headerlink" title="http代理服务器的主要功能"></a>http代理服务器的主要功能</h5><p>主要功能如下：</p><p>1）突破自身IP访问限制，访问国外站点。如：教育网、169网等网络用户可以通过代理访问国外网站；</p><p>2）访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育 网开放的各类FTP下载上传，以及各类资料查询共享等服务；</p><p>3）突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国 外的代理服务器试试；</p><p>4）提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度；</p><p>5）隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p><h5 id="http代理图示"><a href="#http代理图示" class="headerlink" title="http代理图示"></a>http代理图示</h5><p>http代理的图示见下图：</p><p><img src="http://i.imgur.com/cuHWPm5.jpg" alt></p><p>对于客户端浏览器而言，http代理服务器相当于服务器。</p><p>而对于Web服务器而言，http代理服务器又担当了客户端的角色。</p><h4 id="虚拟主机的实现"><a href="#虚拟主机的实现" class="headerlink" title="虚拟主机的实现"></a>虚拟主机的实现</h4><h5 id="什么是虚拟主机"><a href="#什么是虚拟主机" class="headerlink" title="什么是虚拟主机"></a>什么是虚拟主机</h5><p><strong>虚拟主机</strong>：是在<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzgxMy5odG0=" title="http://baike.baidu.com/view/813.htm">网络服务器<i class="fa fa-external-link"></i></span>上划分出一定的磁盘空间供用户放置<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzM5MTEwOS5odG0=" title="http://baike.baidu.com/view/391109.htm">站点<i class="fa fa-external-link"></i></span>、应用组件等，提供必要的站点功能与数据存放、传输功能。  </p><p>所谓虚拟主机，也叫“<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzQwODUxLmh0bQ==" title="http://baike.baidu.com/view/40851.htm">网站空间<i class="fa fa-external-link"></i></span>”就是把一台运行在互联网上的服务器划分成多个“虚拟”的服务器，每一个虚拟主机都<strong>具有独立的域名和完整的Internet服务器</strong>（支持<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzE0NTMuaHRt" title="http://baike.baidu.com/view/1453.htm">WWW<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzM2OS5odG0=" title="http://baike.baidu.com/view/369.htm">FTP<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3Lzg0MDkuaHRt" title="http://baike.baidu.com/view/8409.htm">E-mail<i class="fa fa-external-link"></i></span>等）功能。一台服务器上的不同虚拟主机是各自独立的，并由用户自行管理。但一台服务器主机只能够支持一定数量的虚拟主机，当超过这个数量时，用户将会感到性能急剧下降。</p><h5 id="虚拟主机的实现原理"><a href="#虚拟主机的实现原理" class="headerlink" title="虚拟主机的实现原理"></a>虚拟主机的实现原理</h5><p>虚拟主机是用同一个WEB服务器，为不同域名网站提供服务的技术。Apache、Tomcat等均可通过配置实现这个功能。</p><p>相关的HTTP消息头：Host。</p><p>例如：Host: <span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20v" title="http://www.baidu.com/">www.baidu.com<i class="fa fa-external-link"></i></span></p><p>客户端发送HTTP请求的时候，会携带Host头，Host头记录的是客户端输入的域名。这样服务器可以根据Host头确认客户要访问的是哪一个域名。</p><h4 id="附录：参考资料-2"><a href="#附录：参考资料-2" class="headerlink" title="附录：参考资料"></a>附录：参考资料</h4><p><a href="[http://sumongh.javaeye.com/blog/82498](http://sumongh.javaeye.com/blog/82498)">理解Cookie和Session机制</a></p><p><a href="[http://203.208.39.132/search?q=cache:CdXly_88gjIJ:www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html+http%E5%8D%8F%E8%AE%AE+web%E7%BC%93%E5%AD%98&cd=27&hl=zh-CN&ct=clnk&gl=cn&st_usg=ALhdy2-vzOcP8XTG1h7lcRr2GJrkTbH2Cg](http://203.208.39.132/search?q=cache:CdXly_88gjIJ:www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html+http%E5%8D%8F%E8%AE%AE+web%E7%BC%93%E5%AD%98&cd=27&hl=zh-CN&ct=clnk&gl=cn&st_usg=ALhdy2-vzOcP8XTG1h7lcRr2GJrkTbH2Cg)">浅析HTTP协议</a></p><p><a href="[http://baike.baidu.com/view/1159398.htm](http://baike.baidu.com/view/1159398.htm)">http代理_百度百科</a></p><p><a href="[http://baike.baidu.com/view/7383.htm](http://baike.baidu.com/view/7383.htm)">虚拟主机_百度百科</a></p><p><a href="[http://baike.baidu.com/view/14121.htm](http://baike.baidu.com/view/14121.htm)">https_百度百科</a></p><p><span class="exturl" data-url="aHR0cHM6Ly9tLmJhaWR1LmNvbS9mcm9tPTg0NGIvYmRfcGFnZV90eXBlPTEvc3NpZD0wL3VpZD0wL3B1PXVzbSU0MDElMkNzeiU0MDEzMjBfMjAwMSUyQ3RhJTQwaXBob25lXzFfMTAuMl8zXzYwMi9iYWlkdWlkPTA5RDU2NkE5M0EwMEI2MDk4RDlBOTA5NEUxQjQwODc1L3c9MF8xMF8vdD1pcGhvbmUvbD0zL3RjP3JlZj13d3dfaXBob25lJmxpZD05MTk2MTkxMDUwMzUyNDIwODgxJm9yZGVyPTImZm09YWxvcCZ0aj13d3dfbm9ybWFsXzJfMF8xMF90aXRsZSZ2aXQ9b3NyZXMmbT04JnNyZD0xJmNsdGo9Y2xvdWRfdGl0bGUmYXNyZXM9MSZudD13bm9yJnRpdGxlPUhUVFAlRTQlQjglOEVIVFRQUyVFNyU5QSU4NCVFNSU4QyVCQSVFNSU4OCVBQi0lRTklQTklQUMlRTYlQjUlQjclRTclQTUlQTUlRTUlOEQlOUElRTUlQUUlQTImZGljdD0zMCZ3X3FkPUlsUFQyQUVwdHlvQV95aXhDRk94V3lrZ3F4TEkmc2VjPTE5Nzc5JmRpPWYyZmZhOGZlYjg5NGI3MDcmYmRlbmM9MSZuc3JjPUlsUFQyQUVwdHlvQV95aXhDRk94WG5BTmVkVDYydjNJRVFHR195RlpfamU4bFVTN2hQT2xJdGdmRUZYN0xtdVRFVWZ3c0NQUXB4OUR3OE8tUnlKcmxL" title="https://m.baidu.com/from=844b/bd_page_type=1/ssid=0/uid=0/pu=usm%401%2Csz%401320_2001%2Cta%40iphone_1_10.2_3_602/baiduid=09D566A93A00B6098D9A9094E1B40875/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&lid=9196191050352420881&order=2&fm=alop&tj=www_normal_2_0_10_title&vit=osres&m=8&srd=1&cltj=cloud_title&asres=1&nt=wnor&title=HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%A9%AC%E6%B5%B7%E7%A5%A5%E5%8D%9A%E5%AE%A2&dict=30&w_qd=IlPT2AEptyoA_yixCFOxWykgqxLI&sec=19779&di=f2ffa8feb894b707&bdenc=1&nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_yFZ_je8lUS7hPOlItgfEFX7LmuTEUfwsCPQpx9Dw8O-RyJrlK">HTTP与HTTPS的区别<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGE4ZjMyOTVjNDk3ZDAwNWZiZDU4YjE=" title="https://juejin.im/post/58a8f3295c497d005fbd58b1">HTTPS 为什么更安全，先看这些<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章来自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1oMTI1MDYvYXJ0aWNsZS9kZXRhaWxzLzc3OTQ1MTI=&quot; title=&quot;http://blog.csdn.net/lmh12506/article/details/7794512&quot;&gt;深入理解HTTP协议、HTTP协议原理分析&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础概念篇&quot;&gt;&lt;a href=&quot;#基础概念篇&quot; class=&quot;headerlink&quot; title=&quot;基础概念篇&quot;&gt;&lt;/a&gt;基础概念篇&lt;/h3&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://miaopei.github.io/categories/http/"/>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HTTP思维导图</title>
    <link href="http://miaopei.github.io/2017/04/12/HTTP%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://miaopei.github.io/2017/04/12/HTTP思维导图/</id>
    <published>2017-04-12T07:41:58.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自<span class="exturl" data-url="aHR0cDovL3lycTExMC5tZS8yMDE3LzAzLzA0LzIwMTcwMzA0LWh0dHAtbWluZG1hcC8=" title="http://yrq110.me/2017/03/04/20170304-http-mindmap/">HTTP思维导图<i class="fa fa-external-link"></i></span>。</p><p>HTTP mindmap整理</p><p>source from 《HTTP权威指南》</p><a id="more"></a><h3 id="概述-Summary"><a href="#概述-Summary" class="headerlink" title="概述-Summary"></a>概述-Summary</h3><img src="/images/imageHttp/HTTP-1.svg"><h3 id="报文-Message"><a href="#报文-Message" class="headerlink" title="报文-Message"></a>报文-Message</h3><img src="/images/imageHttp/HTTP-2.svg"><h3 id="连接-Connection"><a href="#连接-Connection" class="headerlink" title="连接-Connection"></a>连接-Connection</h3><img src="/images/imageHttp/HTTP-3.svg"><h3 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理-Proxy"></a>代理-Proxy</h3><img src="/images/imageHttp/HTTP-4.svg"><h3 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存-Cache"></a>缓存-Cache</h3><img src="/images/imageHttp/HTTP-5.svg"><h3 id="网关、隧道与中继-Gateway、Tunnel-and-Relay"><a href="#网关、隧道与中继-Gateway、Tunnel-and-Relay" class="headerlink" title="网关、隧道与中继-Gateway、Tunnel and Relay"></a>网关、隧道与中继-Gateway、Tunnel and Relay</h3><img src="/images/imageHttp/HTTP-6.svg"><h3 id="识别-Identification"><a href="#识别-Identification" class="headerlink" title="识别-Identification"></a>识别-Identification</h3><img src="/images/imageHttp/HTTP-7.svg"><h3 id="认证-Authentication"><a href="#认证-Authentication" class="headerlink" title="认证-Authentication"></a>认证-Authentication</h3><img src="/images/imageHttp/HTTP-8.svg"><h3 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全-Security"></a>安全-Security</h3><img src="/images/imageHttp/HTTP-9.svg"><h3 id="实体与编码-Entity-and-Encoding"><a href="#实体与编码-Entity-and-Encoding" class="headerlink" title="实体与编码-Entity and Encoding"></a>实体与编码-Entity and Encoding</h3><img src="/images/imageHttp/HTTP-10.svg">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章来自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3lycTExMC5tZS8yMDE3LzAzLzA0LzIwMTcwMzA0LWh0dHAtbWluZG1hcC8=&quot; title=&quot;http://yrq110.me/2017/03/04/20170304-http-mindmap/&quot;&gt;HTTP思维导图&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;HTTP mindmap整理&lt;/p&gt;
&lt;p&gt;source from 《HTTP权威指南》&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://miaopei.github.io/categories/http/"/>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Webpack创建、运行vue.js项目及其目录结构详解</title>
    <link href="http://miaopei.github.io/2017/04/10/Webpack%E5%88%9B%E5%BB%BA%E3%80%81%E8%BF%90%E8%A1%8Cvue-js%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://miaopei.github.io/2017/04/10/Webpack创建、运行vue-js项目及其目录结构详解/</id>
    <published>2017-04-10T10:18:27.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目环境搭建："><a href="#项目环境搭建：" class="headerlink" title="项目环境搭建："></a>项目环境搭建：</h3><p>1.安装node</p><p>进入<a href="[https://nodejs.org/en/](https://nodejs.org/en/">node官网</a>进行下载。</p><p>版本查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v6.10.1</span><br></pre></td></tr></table></figure><p style="color:red;">**注意：**node版本最好新一点，推介6.0以上。 </p><a id="more"></a><p>2.全局安装vue-cli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g vue-cli</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果安装失败可能需要root权限重新安装。</p><p>3.创建一个基于 <code>webpack</code> 模板的新项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vue init webpack project-name <span class="comment">#(默认安装2.0版本)</span></span><br><span class="line">$ vue init webpack<span class="comment">#1.0 project-name #(安装1.0版本)</span></span><br></pre></td></tr></table></figure><h3 id="项目目录结构："><a href="#项目目录结构：" class="headerlink" title="项目目录结构："></a>项目目录结构：</h3><p><img src="http://i.imgur.com/P64Q8uK.png" alt></p><p><img src="http://i.imgur.com/beLRmUA.png" alt></p><ul><li><p>main.js是入口文件，主要作用是初始化vue实例并使用需要的插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。其实你也可以理解为所有的路由也是App.vue的子组件。所以我将router标示为App.vue的子组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;hello&gt;&lt;/hello&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Hello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>index.html文件入口</p></li><li><p>src放置组件和入口文件</p></li><li><p>node_modules为依赖的模块</p></li><li><p>config中配置了路径端口值等</p></li><li><p>build中配置了webpack的基本配置、开发环境配置、生产环境配置等</p></li></ul><h3 id="运行项目："><a href="#运行项目：" class="headerlink" title="运行项目："></a>运行项目：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> project-name</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br><span class="line"><span class="comment"># 上述步骤都完成后在浏览器输入：localhost:8080</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;项目环境搭建：&quot;&gt;&lt;a href=&quot;#项目环境搭建：&quot; class=&quot;headerlink&quot; title=&quot;项目环境搭建：&quot;&gt;&lt;/a&gt;项目环境搭建：&lt;/h3&gt;&lt;p&gt;1.安装node&lt;/p&gt;
&lt;p&gt;进入&lt;a href=&quot;[https://nodejs.org/en/](https://nodejs.org/en/&quot;&gt;node官网&lt;/a&gt;进行下载。&lt;/p&gt;
&lt;p&gt;版本查看：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ node -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v6.10.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p style=&quot;color:red;&quot;&gt;**注意：**node版本最好新一点，推介6.0以上。 &lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://miaopei.github.io/categories/Docker/"/>
    
    
      <category term="webpack" scheme="http://miaopei.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>lighttpd 配置https</title>
    <link href="http://miaopei.github.io/2017/03/31/lighttpd-%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://miaopei.github.io/2017/03/31/lighttpd-配置https/</id>
    <published>2017-03-31T04:34:28.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="确定安装的lighttpd支持ssl"><a href="#确定安装的lighttpd支持ssl" class="headerlink" title="确定安装的lighttpd支持ssl"></a>确定安装的lighttpd支持ssl</h3><p>版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lighttpd -v</span><br><span class="line">lighttpd/1.4.35 (ssl) - a light and fast webserver</span><br><span class="line">Build-Date: Apr 25 2017 10:25:18</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h3><p>完整的ssl证书分为四个部分：</p><ul><li>CA根证书（root CA）</li><li>中级证书（Intermediate Certificate）</li><li>域名证书</li><li>证书秘钥（仅由开发者提供）</li></ul><p>证书相当于公钥，pem相当于私钥。</p><p>Self-Signed Certificates：包含公钥和私钥的结合体，证书（公钥）会在连接请求的时候发给浏览器，以便浏览器解密和加密。</p><p>创建Self-Signed Certificates：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><p>上边的命令生成一个server.pem文件。</p><h3 id="lighttpd-conf-配置"><a href="#lighttpd-conf-配置" class="headerlink" title="lighttpd.conf 配置"></a>lighttpd.conf 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SERVER</span>[<span class="string">"socket"</span>] == <span class="string">"[::]:443"</span> &#123;  </span><br><span class="line">     ssl.engine      = <span class="string">"enable"</span></span><br><span class="line">     ssl.pemfile     = <span class="string">"/mnt/flash/server.pem"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制定向到HTTPS"><a href="#强制定向到HTTPS" class="headerlink" title="强制定向到HTTPS"></a>强制定向到HTTPS</h3><p>下面是 <code>lighttpd.conf</code> 文件中关于强制 HTTP 定向到 HTTPS 的部分配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HTTP</span>[<span class="string">"scheme"</span>] == <span class="string">"http"</span> &#123;</span><br><span class="line">    <span class="comment"># capture vhost name with regex conditiona -&gt; %0 in redirect pattern</span></span><br><span class="line">    <span class="comment"># must be the most inner block to the redirect rule</span></span><br><span class="line">    <span class="variable">$HTTP</span>[<span class="string">"host"</span>] =~ <span class="string">".*"</span> &#123;</span><br><span class="line">        url.redirect = (<span class="string">".*"</span> =&gt; <span class="string">"https://%0<span class="variable">$0</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此功能需要lighttpd <code>mod_redirect</code> 模块支持。使用此功能前确保模块已经安装。</p><h3 id="lighttpd安全配置"><a href="#lighttpd安全配置" class="headerlink" title="lighttpd安全配置"></a>lighttpd安全配置</h3><p><strong>禁用 SSL Compression (抵御 CRIME 攻击)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.use-compression = <span class="string">"disable"</span></span><br></pre></td></tr></table></figure><p><strong>禁用 SSLv2 及 SSLv3</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl.use-sslv2 = <span class="string">"disable"</span></span><br><span class="line">ssl.use-sslv3 = <span class="string">"disable"</span></span><br></pre></td></tr></table></figure><p><strong>抵御 Poodle 和 SSL downgrade 攻击</strong></p><p>需要支持 <code>TLS-FALLBACK-SCSV</code> 以自动开启此功能。下列 openSSL 版本包含对 <code>TLS-FALLBACK-SCSV</code> 的支持，lighttpd 会自动启用此特性。</p><ul><li>OpenSSL <strong>1.0.1</strong> 在 <code>1.0.1j</code> 及之后的版本中支持</li><li>OpenSSL <strong>1.0.0</strong> 在 <code>1.0.0o</code> 及之后的版本中支持</li><li>OpenSSL <strong>0.9.8</strong> 在 <code>0.9.8zc</code> 及之后的版本中支持</li></ul><p><strong>加密及交换算法</strong></p><p>一份推介的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.cipher-list = <span class="string">"EECDH+AESGCM:EDH+AESGCM:AES128+EECDH:AES128+EDH"</span></span><br></pre></td></tr></table></figure><p>如果您需要兼容一些老式系统和浏览器 (例如 Windows XP 和 IE6)，请使用下面的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.cipher-list = <span class="string">"EECDH+AESGCM:EDH+AESGCM:ECDHE-RSA-AES128-GCM-SHA256:AES256+EECDH:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4"</span></span><br></pre></td></tr></table></figure><p><strong>配置 Forward Secrecy 和 DHE 参数</strong></p><p>生成强 DHE 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/ssl/certs</span><br><span class="line">$ openssl dhparam -out dhparam.pem 4096</span><br></pre></td></tr></table></figure><p><strong>建议您使用性能强劲的平台生成此文件</strong>，例如最新版的至强物理机。如果您只有一台小型 VPS，请使用 <code>openssl dhparam -out dhparam.pem 2048</code> 命令生成 2048bit 的参数文件。</p><p>添加到 SSL 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl.dh-file = <span class="string">"/etc/ssl/certs/dhparam.pem"</span></span><br><span class="line">ssl.ec-curve = <span class="string">"secp384r1"</span></span><br></pre></td></tr></table></figure><p><strong>启用 HSTS</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.modules += ( <span class="string">"mod_setenv"</span> )</span><br><span class="line"><span class="variable">$HTTP</span>[<span class="string">"scheme"</span>] == <span class="string">"https"</span> &#123;</span><br><span class="line">    setenv.add-response-header  = ( <span class="string">"Strict-Transport-Security"</span> =&gt; <span class="string">"max-age=63072000; includeSubdomains; preload"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0xpZ2h0dHBk" title="https://wiki.archlinux.org/index.php/Lighttpd">Lighttpd<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;确定安装的lighttpd支持ssl&quot;&gt;&lt;a href=&quot;#确定安装的lighttpd支持ssl&quot; class=&quot;headerlink&quot; title=&quot;确定安装的lighttpd支持ssl&quot;&gt;&lt;/a&gt;确定安装的lighttpd支持ssl&lt;/h3&gt;&lt;p&gt;版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ lighttpd -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lighttpd/1.4.35 (ssl) - a light and fast webserver&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Build-Date: Apr 25 2017 10:25:18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
      <category term="lighttpd" scheme="http://miaopei.github.io/tags/lighttpd/"/>
    
  </entry>
  
  <entry>
    <title>lighttpd+fastcgi</title>
    <link href="http://miaopei.github.io/2017/03/31/lighttpd-fastcgi/"/>
    <id>http://miaopei.github.io/2017/03/31/lighttpd-fastcgi/</id>
    <published>2017-03-31T04:34:28.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>lighttpd</code> 提供了一种外部程序调用的接口，即 <code>FastCGI</code> 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。</p><p>这就意味着能够在 <code>Apache</code> 服务器上运行的 <code>FastCGI</code> 程序，也一定可以无缝的在 <code>lighttpd</code> 上使用。</p><a id="more"></a><h3 id="FastCGI介绍"><a href="#FastCGI介绍" class="headerlink" title="FastCGI介绍"></a>FastCGI介绍</h3><p>1）就像 <code>CGI</code> 一样，<code>FastCGI</code> 也是独立于编程语言的。<br>2）就像 <code>CGI</code> 一样，<code>FastCGI</code> 程序运行在完全独立于核心 <code>Web Server</code> 之外的进程中，和 <code>API</code> 方式相比，提供了很大的安全性。（API会将程序代码与核心Web Server挂接在一起，这就意味着基于问题API的应用程序可能会使整个Web Server或另一个应用程序崩溃；一个恶意API还可以从核心Web Server或另一个应用程序中盗取安全密钥）</p><p>3) 虽然 <code>FastCGI</code> 不能一夜之间复制CGI的所有功能，但是 <code>FastCGI</code> 一直宣扬开放，这也使得我们拥有很多免费的 <code>FastCGI</code> 应用程序库（C/C++、Java、Perl、TCL）和免费的Server模块（Apache、ISS、Lighttpd）。</p><p>4) 就像 <code>CGI</code> 一样，<code>FastCGI</code> 并不依附于任何 <code>Web Server</code> 的内部架构，因此即使 <code>Server</code> 的技术实现变动，<code>FastCGI</code> 仍然非常稳定；而 <code>API</code> 设计是反映 <code>Web Server</code> 内部架构的，因此，一旦架构改变，API要随之变动。</p><p>5) <code>FastCGI</code> 程序可以运行在任何机器上，完全可以和 <code>Web Server</code> 不在一台机器上。这种分布式计算的思想可以确保可扩展性、提高系统可用性和安全性。</p><p>6) <code>CGI</code> 程序主要是对 <code>HTTP</code> 请求做计算处理，而 <code>FastCGI</code> 却还可以做得更多，例如模块化认证、授权检查、数据类型转换等等。在未来，<code>FastCGI</code> 还会有能力扮演更多角色。</p><p>7) <code>FastCGI</code> 移除了 <code>CGI</code> 程序的许多弊端。例如，针对每一个新请求，<code>WebServer</code> 都必须重启 <code>CGI</code> 程序来处理新请求，这导致 <code>WebServer</code> 的性能会大受影响。而 <code>FastCGI</code> 通过保持进程处理运行状态并持续处理请求的方式解决了该问题，这就将进程创建和销毁的时间节省了出来。</p><p>8) <code>CGI</code> 程序需要通过管道（pipe）方式与 <code>Web Server</code> 通信，而 <code>FastCGI</code> 则是通过 <code>Unix-Domain-Sockets</code> 或 <code>TCP/IP</code> 方式来实现与 <code>Web Server</code> 的通信。这确保了 <code>FastCGI</code> 可以运行在 <code>Web Server</code> 之外的服务器上。<code>FastCGI</code> 提供了 <code>FastCGI</code> 负载均衡器，它可以有效控制多个独立的 <code>FastCGI Server</code> 的负载，这种方式比 <code>load-balancer+apache+mod_php</code> 方式能够承担更多的流量。</p><h3 id="FastCGI-模块"><a href="#FastCGI-模块" class="headerlink" title="FastCGI 模块"></a>FastCGI 模块</h3><p>若要 <code>lighttpd</code> 支持 <code>fastcgi</code>，则需要配置如下内容：</p><p>在 <code>fastcgi.conf</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.modules += ( &quot;mod_fastcgi&quot; )</span><br></pre></td></tr></table></figure><p>及在 <code>module.conf</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;conf.d/fastcgi.conf&quot;</span><br></pre></td></tr></table></figure><h3 id="FastCGI-配置选项"><a href="#FastCGI-配置选项" class="headerlink" title="FastCGI 配置选项"></a>FastCGI 配置选项</h3><p><code>lighttpd</code> 通过 <code>fastcgi</code> 模块的方式实现了对 <code>fastcgi</code> 的支持，并且在配置文件中提供了三个相关的选项：</p><p>1） fastcgi.debug</p><p>可以设置一个从0到65535的值，用于设定 <code>FastCGI</code> 模块的调试等级。当前仅有0和1可用。<strong>1表示开启调试（会输出调试信息），0表示禁用</strong>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.debug = 1</span><br></pre></td></tr></table></figure><p>2） fastcgi.map-extentsions</p><p>同一个 <code>fastcgi server</code> 能够映射多个扩展名，如 <code>.php3</code> 和 <code>.php4</code> 都对应 <code>.php</code>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot; )</span><br></pre></td></tr></table></figure><p>or for multiple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot;, &quot;.php4&quot; =&gt; &quot;.php&quot; )</span><br></pre></td></tr></table></figure><p>3） fastcgi.server</p><p>这个配置是告诉 <code>Web Server</code> 将 <code>FastCGI</code> 请求发送到哪里，其中每一个文件扩展名可以处理一个类型的请求。负载均衡器可以实现对同一扩展名的多个对象的负载均衡。</p><p><code>fastcgi.server</code> 的结构语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">( &lt;extension&gt; =&gt;</span><br><span class="line">  ( [ &lt;name&gt; =&gt; ]</span><br><span class="line">    ( <span class="comment"># Be careful: lighty does *not* warn you if it doesn't know a specified option here (make sure you have no typos)</span></span><br><span class="line">      <span class="string">"host"</span> =&gt; &lt;string&gt; ,</span><br><span class="line">      <span class="string">"port"</span> =&gt; &lt;<span class="built_in">integer</span>&gt; ,</span><br><span class="line">      <span class="string">"socket"</span> =&gt; &lt;string&gt;,                 <span class="comment"># either socket or host+port</span></span><br><span class="line">      <span class="string">"bin-path"</span> =&gt; &lt;string&gt;,               <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"bin-environment"</span> =&gt; &lt;array&gt;,         <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"bin-copy-environment"</span> =&gt; &lt;array&gt;,    <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"mode"</span> =&gt; &lt;string&gt;,                   <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"docroot"</span> =&gt; &lt;string&gt; ,               <span class="comment"># optional if "mode" is not "authorizer"</span></span><br><span class="line">      <span class="string">"check-local"</span> =&gt; &lt;string&gt;,            <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"max-procs"</span> =&gt; &lt;<span class="built_in">integer</span>&gt;,             <span class="comment"># optional - when omitted, default is 4</span></span><br><span class="line">      <span class="string">"broken-scriptfilename"</span> =&gt; &lt;boolean&gt;, <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"kill-signal"</span> =&gt; &lt;<span class="built_in">integer</span>&gt;,           <span class="comment"># optional, default is SIGTERM(15) (v1.4.14+)</span></span><br><span class="line">    ),</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; ...</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中：</p><blockquote><p><strong>extentsion</strong> ：文件名后缀或以”/”开头的前缀（也可为文件名）<br><strong>name</strong> ：这是一个可选项，表示handler的名称，在mod_status中用于统计功能，可以清晰的分辨出是哪一个handler处理了<extension>。<strong>host</strong> ：FastCGI进程监听的IP地址。此处不支持hostname形式。<br><strong>port</strong> ：FastCGI进程所监听的TCP端口号<br><strong>bin-path</strong> ：本地FastCGI二进制程序的路径，当本地没有FastCGI正在运行时，会启动这个FastCGI程序。<br><strong>socket</strong> ：unix-domain-socket所在路径。<br><strong>mode</strong> ：可以选择FastCGI协议的模式，默认是“responder”，还可以选择authorizer。<br><strong>docroot</strong> ：这是一个可选项，对于responder模式来讲，表示远程主机docroot；对于authorizer模式来说，它表示MANDATORY，并且指向授权请求的docroot。<br><strong>check_local</strong> ：这是一个可选项，默认是enable。如果是enable，那么server会首先在本地（server.document-root）目录中检查被请求的文件是否存在，如果不存在，则给用户返回404（Not Found），而不会把这个请求传递给FastCGI。如果是disable，那么server不会检查本地文件，而是直接将请求转发给FastCGI。（disable的话，server从某种意义上说就变为了一个转发器）<br><strong>broken-scriptfilename</strong> ：以类似PHP抽取PATH_INFO的方式，抽取URL中的SCRIPT_FILENAME。</extension></p></blockquote><p>如果 <code>bin-path</code> 被设置了，那么：</p><blockquote><p><strong>max-procs</strong> ：设置多少个FastCGI进程被启动<br><strong>bin-environment</strong> ：在FastCGI进程启动时设置一个环境变量<br><strong>bin-copy-environment</strong> ：清除环境，并拷贝指定的变量到全新的环境中。<br><strong>kill-signal</strong> ：默认的话，在停止FastCGI进程时，lighttpd会发送SIGTERM(-15)信号给子进程。此处可以设置发送的信号。</p></blockquote><p><strong>举例</strong> ：</p><p>使用前缀来对应主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = (</span><br><span class="line">  <span class="string">"/remote_scripts/"</span> =&gt;</span><br><span class="line">  (( <span class="string">"host"</span> =&gt; <span class="string">"192.168.0.3"</span>,</span><br><span class="line">     <span class="string">"port"</span> =&gt; 9000,</span><br><span class="line">     <span class="string">"check-local"</span> =&gt; <span class="string">"disable"</span>,</span><br><span class="line">     <span class="string">"docroot"</span> =&gt; <span class="string">"/"</span> <span class="comment"># remote server may use</span></span><br><span class="line">                      <span class="comment"># it's own docroot</span></span><br><span class="line">  ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果有一个请求 “<span class="exturl" data-url="aHR0cDovL215LmV4YW1wbGUub3JnL3JlbW90ZV9zY3JpcHRzL3Rlc3QuY2dpJnF1b3Q777yM6YKj5LmIc2VydmVy5Lya5bCG5YW26L2s5Y+R57uZMTkyLjE2OC4wLjPnmoQ5MDAw56uv5Y+j77yM5bm25LiU" title="http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且">http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且<i class="fa fa-external-link"></i></span> <code>SCRIPT_NAME</code> 会被赋值为 <code>“/remote_scripts/test.cgi”</code>。如果所设置的 <code>handler</code> 的末尾不是 <code>“/”</code> ，那么会被认为是一个文件。</p><p><strong>负载均衡</strong> ：</p><p><code>FastCGI</code> 模块提供了一种在多台 <code>FastCGI</code> 服务器间负载均衡的方法。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = ( <span class="string">".php"</span> =&gt;</span><br><span class="line">  (</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; <span class="string">"10.0.0.2"</span>,</span><br><span class="line">      <span class="string">"port"</span> =&gt; 1030</span><br><span class="line">    ),</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; <span class="string">"10.0.0.3"</span>,</span><br><span class="line">      <span class="string">"port"</span> =&gt; 1030 )</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>为了更好的理解负载均衡实现的原理，建议你置 <code>fastcgi.debug</code> 为 <code>1</code> 。即使对于本机的多个 <code>FastCGI</code> ，你也会获得如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proc: 127.0.0.1 1031  1 1 1 31454</span><br><span class="line">proc: 127.0.0.1 1028  1 1 1 31442</span><br><span class="line">proc: 127.0.0.1 1030  1 1 1 31449</span><br><span class="line">proc: 127.0.0.1 1029  1 1 2 31447</span><br><span class="line">proc: 127.0.0.1 1026  1 1 2 31438</span><br><span class="line">got proc: 34 31454</span><br><span class="line">release proc: 40 31438</span><br><span class="line">proc: 127.0.0.1 1026  1 1 1 31438</span><br><span class="line">proc: 127.0.0.1 1028  1 1 1 31442</span><br><span class="line">proc: 127.0.0.1 1030  1 1 1 31449</span><br><span class="line">proc: 127.0.0.1 1031  1 1 2 31454</span><br><span class="line">proc: 127.0.0.1 1029  1 1 2 31447</span><br></pre></td></tr></table></figure><p>上述信息显示出了IP地址，端口号、当前链接数（也就是负载）（倒数第二列）、进程ID（倒数第一列）等等。整个输出信息总是以负载域来从小到大排序的。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><span class="exturl" data-url="aHR0cDovL3JlZG1pbmUubGlnaHR0cGQubmV0L3Byb2plY3RzLzEvd2lraS9Eb2NzOk1vZEZhc3RDR0k=" title="http://redmine.lighttpd.net/projects/1/wiki/Docs:ModFastCGI"><i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5mYXN0Y2dpLmNvbQ==" title="http://www.fastcgi.com"><i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3JvY2xpbnV4LmNuLz9wPTIzNDc=" title="http://roclinux.cn/?p=2347">说说lighttpd的fastcgi<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3luZXQvcC80MTczNDUwLmh0bWw=" title="http://www.cnblogs.com/skynet/p/4173450.html">Nginx + CGI/FastCGI + C/Cpp<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDAwNjU5Ng==" title="https://segmentfault.com/a/1190000004006596">FastCGI+lighttpd开发之介绍和环境搭建<i class="fa fa-external-link"></i></span></p><h3 id="附：QC-V3-PP-版本-lighttpd-conf"><a href="#附：QC-V3-PP-版本-lighttpd-conf" class="headerlink" title="附：QC V3 PP 版本 lighttpd.conf"></a>附：QC V3 PP 版本 lighttpd.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/qtilighttpd.conf </span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Copyright (c) 2016 Qualcomm Technologies, Inc.</span></span><br><span class="line"><span class="comment"># All Rights Reserved.</span></span><br><span class="line"><span class="comment"># Confidential and Proprietary - Qualcomm Technologies, Inc.</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">server.document-root = <span class="string">"/opt/qcom/www"</span></span><br><span class="line"></span><br><span class="line">server.port    = 80</span><br><span class="line">server.username    = <span class="string">"apps"</span></span><br><span class="line">server.groupname  = <span class="string">"apps"</span></span><br><span class="line">server.bind    = <span class="string">"0.0.0.0"</span></span><br><span class="line">server.tag    = <span class="string">"lighttpd"</span></span><br><span class="line"><span class="variable">$SERVER</span>[<span class="string">"socket"</span>] == <span class="string">"[::]:80"</span> &#123;  &#125;</span><br><span class="line"></span><br><span class="line">server.errorlog-use-syslog  = <span class="string">"enable"</span></span><br><span class="line">accesslog.use-syslog    = <span class="string">"enable"</span></span><br><span class="line"></span><br><span class="line">server.modules    = (</span><br><span class="line">  <span class="string">"mod_access"</span>,<span class="string">"mod_accesslog"</span>, <span class="string">"mod_cgi"</span>, <span class="string">"mod_fastcgi"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fastcgi.debug = 1</span><br><span class="line">fastcgi.server = (</span><br><span class="line">    <span class="string">"/fsmoam"</span> =&gt; (</span><br><span class="line">    <span class="string">"fsmoam.fcgi.handler"</span> =&gt; (</span><br><span class="line">        <span class="string">"socket"</span> =&gt; <span class="string">"/tmp/fsmoam.fcgi.socket"</span>,</span><br><span class="line">        <span class="string">"check-local"</span> =&gt; <span class="string">"disable"</span>,</span><br><span class="line">        <span class="string">"bin-path"</span> =&gt; <span class="string">"/opt/qcom/bin/tests/fsmWebServer --default-log-level=DEBUG"</span>,</span><br><span class="line">        <span class="string">"max-procs"</span> =&gt; 1)</span><br><span class="line">     )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mimetype mapping</span></span><br><span class="line">mimetype.assign    = (</span><br><span class="line">  <span class="string">".pdf"</span>    =&gt;  <span class="string">"application/pdf"</span>,</span><br><span class="line">  <span class="string">".sig"</span>    =&gt;  <span class="string">"application/pgp-signature"</span>,</span><br><span class="line">  <span class="string">".spl"</span>    =&gt;  <span class="string">"application/futuresplash"</span>,</span><br><span class="line">  <span class="string">".class"</span>  =&gt;  <span class="string">"application/octet-stream"</span>,</span><br><span class="line">  <span class="string">".ps"</span>    =&gt;  <span class="string">"application/postscript"</span>,</span><br><span class="line">  <span class="string">".torrent"</span>  =&gt;  <span class="string">"application/x-bittorrent"</span>,</span><br><span class="line">  <span class="string">".dvi"</span>    =&gt;  <span class="string">"application/x-dvi"</span>,</span><br><span class="line">  <span class="string">".gz"</span>    =&gt;  <span class="string">"application/x-gzip"</span>,</span><br><span class="line">  <span class="string">".pac"</span>    =&gt;  <span class="string">"application/x-ns-proxy-autoconfig"</span>,</span><br><span class="line">  <span class="string">".swf"</span>    =&gt;  <span class="string">"application/x-shockwave-flash"</span>,</span><br><span class="line">  <span class="string">".tar.gz"</span>  =&gt;  <span class="string">"application/x-tgz"</span>,</span><br><span class="line">  <span class="string">".tgz"</span>    =&gt;  <span class="string">"application/x-tgz"</span>,</span><br><span class="line">  <span class="string">".tar"</span>    =&gt;  <span class="string">"application/x-tar"</span>,</span><br><span class="line">  <span class="string">".zip"</span>    =&gt;  <span class="string">"application/zip"</span>,</span><br><span class="line">  <span class="string">".mp3"</span>    =&gt;  <span class="string">"audio/mpeg"</span>,</span><br><span class="line">  <span class="string">".m3u"</span>    =&gt;  <span class="string">"audio/x-mpegurl"</span>,</span><br><span class="line">  <span class="string">".wma"</span>    =&gt;  <span class="string">"audio/x-ms-wma"</span>,</span><br><span class="line">  <span class="string">".wax"</span>    =&gt;  <span class="string">"audio/x-ms-wax"</span>,</span><br><span class="line">  <span class="string">".ogg"</span>    =&gt;  <span class="string">"audio/x-wav"</span>,</span><br><span class="line">  <span class="string">".wav"</span>    =&gt;  <span class="string">"audio/x-wav"</span>,</span><br><span class="line">  <span class="string">".gif"</span>    =&gt;  <span class="string">"image/gif"</span>,</span><br><span class="line">  <span class="string">".jpg"</span>    =&gt;  <span class="string">"image/jpeg"</span>,</span><br><span class="line">  <span class="string">".jpeg"</span>    =&gt;  <span class="string">"image/jpeg"</span>,</span><br><span class="line">  <span class="string">".png"</span>    =&gt;  <span class="string">"image/png"</span>,</span><br><span class="line">  <span class="string">".xbm"</span>    =&gt;  <span class="string">"image/x-xbitmap"</span>,</span><br><span class="line">  <span class="string">".xpm"</span>    =&gt;  <span class="string">"image/x-xpixmap"</span>,</span><br><span class="line">  <span class="string">".xwd"</span>    =&gt;  <span class="string">"image/x-xwindowdump"</span>,</span><br><span class="line">  <span class="string">".css"</span>    =&gt;  <span class="string">"text/css"</span>,</span><br><span class="line">  <span class="string">".html"</span>    =&gt;  <span class="string">"text/html"</span>,</span><br><span class="line">  <span class="string">".htm"</span>    =&gt;  <span class="string">"text/html"</span>,</span><br><span class="line">  <span class="string">".js"</span>    =&gt;  <span class="string">"text/javascript"</span>,</span><br><span class="line">  <span class="string">".asc"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".c"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".conf"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".text"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".txt"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".dtd"</span>    =&gt;  <span class="string">"text/xml"</span>,</span><br><span class="line">  <span class="string">".xml"</span>    =&gt;  <span class="string">"text/xml"</span>,</span><br><span class="line">  <span class="string">".mpeg"</span>    =&gt;  <span class="string">"video/mpeg"</span>,</span><br><span class="line">  <span class="string">".mpg"</span>    =&gt;  <span class="string">"video/mpeg"</span>,</span><br><span class="line">  <span class="string">".mov"</span>    =&gt;  <span class="string">"video/quicktime"</span>,</span><br><span class="line">  <span class="string">".qt"</span>    =&gt;  <span class="string">"video/quicktime"</span>,</span><br><span class="line">  <span class="string">".avi"</span>    =&gt;  <span class="string">"video/x-msvideo"</span>,</span><br><span class="line">  <span class="string">".asf"</span>    =&gt;  <span class="string">"video/x-ms-asf"</span>,</span><br><span class="line">  <span class="string">".asx"</span>    =&gt;  <span class="string">"video/x-ms-asf"</span>,</span><br><span class="line">  <span class="string">".wmv"</span>    =&gt;  <span class="string">"video/x-ms-wmv"</span>,</span><br><span class="line">  <span class="string">".bz2"</span>    =&gt;  <span class="string">"application/x-bzip"</span>,</span><br><span class="line">  <span class="string">".tbz"</span>    =&gt;  <span class="string">"application/x-bzip-compressed-tar"</span>,</span><br><span class="line">  <span class="string">".tar.bz2"</span>  =&gt;  <span class="string">"application/x-bzip-compressed-tar"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">index-file.names = ( <span class="string">"index.html"</span> )</span><br><span class="line"></span><br><span class="line">cgi.assign = ( <span class="string">".sh"</span> =&gt; <span class="string">"/bin/sh"</span> )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;lighttpd&lt;/code&gt; 提供了一种外部程序调用的接口，即 &lt;code&gt;FastCGI&lt;/code&gt; 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。&lt;/p&gt;
&lt;p&gt;这就意味着能够在 &lt;code&gt;Apache&lt;/code&gt; 服务器上运行的 &lt;code&gt;FastCGI&lt;/code&gt; 程序，也一定可以无缝的在 &lt;code&gt;lighttpd&lt;/code&gt; 上使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="lighttpd" scheme="http://miaopei.github.io/tags/lighttpd/"/>
    
      <category term="FastCGI" scheme="http://miaopei.github.io/tags/FastCGI/"/>
    
  </entry>
  
  <entry>
    <title>svn 常用操作命令</title>
    <link href="http://miaopei.github.io/2017/03/29/svn-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://miaopei.github.io/2017/03/29/svn-常用操作命令/</id>
    <published>2017-03-29T08:23:27.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span><br><span class="line">$ svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名</span><br><span class="line"><span class="comment"># 也可以使用缩写</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">$ svn co http://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>注</strong> ：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。 不指定本地目录全路径，则检出到当前目录下。</p><h2 id="导出（导出一个干净的不带-svn文件夹的目录树）"><a href="#导出（导出一个干净的不带-svn文件夹的目录树）" class="headerlink" title="导出（导出一个干净的不带.svn文件夹的目录树）"></a>导出（导出一个干净的不带.svn文件夹的目录树）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn  <span class="built_in">export</span>  [-r 版本号]  http://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">$ svn  <span class="built_in">export</span>  [-r 版本号]  svn://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">$ svn  <span class="built_in">export</span>  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn <span class="built_in">export</span> svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">$ svn <span class="built_in">export</span> svn://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br><span class="line">$ svn <span class="built_in">export</span> /home/testapp /home/testtools</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：第一种从版本库导出干净工作目录树的形式是指定URL，</p><p>​     如果指定了修订版本号，会导出相应的版本，</p><p>​     如果没有指定修订版本，则会导出最新的，导出到指定位置。</p><p>​     如果省略 本地目录全路径，URL的最后一部分会作为本地目录的名字。</p><p>​     第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留，</p><p>​     但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。</p><h2 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn　add　文件名</span><br><span class="line"><span class="comment"># 注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn add test.php  <span class="comment"># 添加test.php </span></span><br><span class="line">$ svn commit -m <span class="string">"添加我的测试用test.php"</span> test.php</span><br><span class="line">$ svn add *.php  <span class="comment"># 添加当前目录下所有的php文件</span></span><br><span class="line">$ svn commit -m <span class="string">"添加我的测试用全部php文件"</span> *.php</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ svn　commit　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line">$ svn　ci　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line"><span class="comment"># 必须带上-m参数，参数可以为空，但是必须写上-m</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn commit -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> *   <span class="comment"># 注意这个*表示全部文件</span></span><br><span class="line">$ svn commit -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">$ svn commit -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php   <span class="comment"># 保持锁就用–no-unlock开关</span></span><br><span class="line">$ svn ci -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> *   <span class="comment"># 注意这个*表示全部文件</span></span><br><span class="line">$ svn ci -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">$ svn ci -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php   <span class="comment"># 保持锁就用–no-unlock开关</span></span><br></pre></td></tr></table></figure><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ svn　update</span><br><span class="line">$ svn　update　-r　修正版本　文件名</span><br><span class="line">$ svn　update　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span></span><br><span class="line">$ svn update </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将版本库中的文件 test.cpp 还原到修正版本（revision）200</span></span><br><span class="line">$ svn update -r 200 test.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新与版本库同步。提交的时候提示过期冲突，需要先 update 修改文件，然后清除svn resolved，最后再提交commit。</span></span><br><span class="line">$ svn update test.php</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ svn　delete　svn://路径(目录或文件的全路径) -m <span class="string">"删除备注信息文本"</span></span><br><span class="line"><span class="comment"># 推荐如下操作：</span></span><br><span class="line">$ svn　delete　文件名 </span><br><span class="line">$ svn　ci　-m　<span class="string">"删除备注信息文本"</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn delete svn://localhost/testapp/test.php -m <span class="string">"删除测试文件test.php"</span></span><br><span class="line"><span class="comment"># 推荐如下操作：</span></span><br><span class="line">$ svn delete test.php </span><br><span class="line">$ svn ci -m <span class="string">"删除测试文件test.php"</span></span><br></pre></td></tr></table></figure><h2 id="加锁-解锁"><a href="#加锁-解锁" class="headerlink" title="加锁 / 解锁"></a>加锁 / 解锁</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svn　lock　-m　<span class="string">"加锁备注信息文本"</span>　[--force]　文件名 </span><br><span class="line">$ svn　unlock　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn lock -m <span class="string">"锁信测试用test.php文件"</span> test.php </span><br><span class="line">$ svn unlock test.php</span><br></pre></td></tr></table></figure><h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ svn　diff　文件名 </span><br><span class="line">$ svn　diff　-r　修正版本号m:修正版本号n　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 将修改的文件与基础版本比较</span></span><br><span class="line">$ svn diff test.php </span><br><span class="line"></span><br><span class="line"><span class="comment"># 对修正版本号200 和 修正版本号201 比较差异</span></span><br><span class="line">$ svn diff -r 200:201 test.php</span><br></pre></td></tr></table></figure><h2 id="查看文件或者目录状态"><a href="#查看文件或者目录状态" class="headerlink" title="查看文件或者目录状态"></a>查看文件或者目录状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ svn st 目录路径/名</span><br><span class="line"><span class="comment"># 目录下的文件和子目录的状态，正常状态不显示.</span></span><br><span class="line"><span class="comment"># 【?：不在svn的控制中；  M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 </span></span><br><span class="line">$ svn status 目录路径/名　　　　　</span><br><span class="line">$ svn -v 目录路径/名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件和子目录状态</span></span><br><span class="line"><span class="comment"># 【第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人】</span></span><br><span class="line">$ svn status -v 目录路径/名</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。</p><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ svn　<span class="built_in">log</span>　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 显示这个文件的所有修改记录，及其版本号的变化</span></span><br><span class="line">$ svn <span class="built_in">log</span> test.php</span><br></pre></td></tr></table></figure><h2 id="查看文件详细信息"><a href="#查看文件详细信息" class="headerlink" title="查看文件详细信息"></a>查看文件详细信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ svn　info　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn info test.php</span><br></pre></td></tr></table></figure><h2 id="SVN-帮助"><a href="#SVN-帮助" class="headerlink" title="SVN 帮助"></a>SVN 帮助</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全部功能选项</span></span><br><span class="line">$ svn　<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 具体功能的说明</span></span><br><span class="line">$ svn　<span class="built_in">help</span>　ci</span><br></pre></td></tr></table></figure><h2 id="查看版本库下的文件和目录列表"><a href="#查看版本库下的文件和目录列表" class="headerlink" title="查看版本库下的文件和目录列表"></a>查看版本库下的文件和目录列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn　list　svn://路径(目录或文件的全路径)</span><br><span class="line">$ svn　ls　svn://路径(目录或文件的全路径)</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn list svn://localhost/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示svn://localhost/test目录下的所有属于版本库的文件和目录</span></span><br><span class="line">$ svn ls svn://localhost/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="创建纳入版本控制下的新目录"><a href="#创建纳入版本控制下的新目录" class="headerlink" title="创建纳入版本控制下的新目录"></a>创建纳入版本控制下的新目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svn　mkdir　目录名</span><br><span class="line">$ svn　mkdir　-m　<span class="string">"新增目录备注文本"</span>　http://目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn mkdir newdir</span><br><span class="line">$ svn mkdir -m <span class="string">"Making a new dir."</span> svn://localhost/<span class="built_in">test</span>/newdir</span><br></pre></td></tr></table></figure><p><strong>注</strong> ： 添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn update</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：如果手工在checkout出来的目录里创建了一个新文件夹newsubdir，</p><p>​     再用svn mkdir newsubdir命令后，SVN会提示：</p><p>​     svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？</p><p>​     svn: 无法创建目录“hello”: 文件已经存在</p><pre><code> 此时，用如下命令解决：svn add --non-recursive newsubdir</code></pre><p>​     在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录</p><p>​     再用 svn mkdir -m “添hello功能模块文件” <span class="exturl" data-url="c3ZuOi8vbG9jYWxob3N0L3Rlc3QvbmV3ZGlyL25ld3N1YmRpcg==" title="svn://localhost/test/newdir/newsubdir">svn://localhost/test/newdir/newsubdir<i class="fa fa-external-link"></i></span> 命令，</p><p>​     SVN提示：</p><p>​     svn: File already exists: filesystem ‘/data/svnroot/test/db’, transaction ‘4541-1’,</p><p>​     path ‘/newdir/newsubdir ‘</p><h2 id="恢复本地修改"><a href="#恢复本地修改" class="headerlink" title="恢复本地修改"></a>恢复本地修改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ svn　revert　[--recursive]　文件名</span><br><span class="line"><span class="comment"># 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 丢弃对一个文件的修改</span></span><br><span class="line">$ svn revert foo.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复一整个目录的文件，. 为当前目录</span></span><br><span class="line">$ svn revert --recursive .</span><br></pre></td></tr></table></figure><h2 id="把工作拷贝更新到别的URL"><a href="#把工作拷贝更新到别的URL" class="headerlink" title="把工作拷贝更新到别的URL"></a>把工作拷贝更新到别的URL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ svn　switch　http://目录全路径　本地目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># (原为123的分支)当前所在目录分支到localhost/test/456</span></span><br><span class="line">$ svn switch http://localhost/<span class="built_in">test</span>/456 .</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ svn　resolved　[本地目录全路径]</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn update</span><br><span class="line">C foo.c</span><br><span class="line">Updated to revision 31.</span><br><span class="line"><span class="comment"># 如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span></span><br><span class="line">$ ls</span><br><span class="line">foo.c</span><br><span class="line">foo.c.mine</span><br><span class="line">foo.c.r30</span><br><span class="line">foo.c.r31</span><br><span class="line"><span class="comment"># 当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span></span><br><span class="line"><span class="comment"># 你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</span></span><br></pre></td></tr></table></figure><h2 id="不checkout而查看输出特定文件或URL的内容"><a href="#不checkout而查看输出特定文件或URL的内容" class="headerlink" title="不checkout而查看输出特定文件或URL的内容"></a>不checkout而查看输出特定文件或URL的内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ svn　cat　http://文件全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn cat http://localhost/<span class="built_in">test</span>/readme.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支copy</span></span><br><span class="line"><span class="comment"># 从branchA拷贝出一个新分支branchB</span></span><br><span class="line">$ svn copy branchA branchB  -m <span class="string">"make B branch"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并内容到分支merge</span></span><br><span class="line"><span class="comment"># 把对branchA的修改合并到分支branchB</span></span><br><span class="line">$ svn merge branchA branchB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;检出&quot;&gt;&lt;a href=&quot;#检出&quot; class=&quot;headerlink&quot; title=&quot;检出&quot;&gt;&lt;/a&gt;检出&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 也可以使用缩写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 例子：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn co http://localhost/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;/testapp --username wzhnsc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="svn" scheme="http://miaopei.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>hexo 使用指南</title>
    <link href="http://miaopei.github.io/2017/03/28/hexo-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://miaopei.github.io/2017/03/28/hexo-使用指南/</id>
    <published>2017-03-28T08:53:46.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装、初始化和配置"><a href="#安装、初始化和配置" class="headerlink" title="安装、初始化和配置"></a>安装、初始化和配置</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>git</li><li>node.js</li><li>github</li></ul><a id="more"></a><h3 id="安装和初始化"><a href="#安装和初始化" class="headerlink" title="安装和初始化"></a>安装和初始化</h3><p>首先确定已经安装好了 <code>nodejs</code> 和 <code>npm</code> 以及 <code>git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAw" title="http://localhost:4000">http://localhost:4000<i class="fa fa-external-link"></i></span>，会看到生成好的博客。</p><h3 id="主目录结构"><a href="#主目录结构" class="headerlink" title="主目录结构"></a>主目录结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-- _config.yml</span><br><span class="line">|-- package.json</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source</span><br><span class="line">   |-- _posts</span><br><span class="line">|-- themes</span><br><span class="line">|-- .gitignore</span><br><span class="line">|-- package.json</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。</p><p><strong>package.json</strong></p><p>hexo框架的参数和所依赖插件，如下：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"3.2.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.10"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>scaffold</strong></p><p>scaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。</p><p><strong>_config.yml文件</strong></p><p>_config.yml 采用YAML语法格式，<span class="exturl" data-url="aHR0cDovL215Lm9zY2hpbmEubmV0L3UvMTg2MTgzNy9ibG9nLzUyNjE0Mj9wPSU3QiU3QnRvdGFsUGFnZSU3RCU3RA==" title="http://my.oschina.net/u/1861837/blog/526142?p=%7B%7BtotalPage%7D%7D">具体语法自行学习<i class="fa fa-external-link"></i></span> 。<br>具体配置可以参考<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbi5odG1s" title="https://hexo.io/zh-cn/docs/configuration.html">官方文档<i class="fa fa-external-link"></i></span>，_config.yml 文件中的内容，并对主要参数做简单的介绍</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span>   <span class="comment">#网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span>     <span class="comment">#网站副标题</span></span><br><span class="line"><span class="attr">description:</span>  <span class="comment">#网站描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span>  <span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span>    <span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span>    <span class="comment">#网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://yoursite.com</span>   <span class="comment">#你的站点Url</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                    <span class="comment">#站点的根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>   <span class="comment">#文章的 永久链接 格式   </span></span><br><span class="line"><span class="attr">permalink_defaults:</span>    <span class="comment">#永久链接中各部分的默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory   </span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span>         <span class="comment">#资源文件夹，这个文件夹用来存放内容</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span>         <span class="comment">#公共文件夹，这个文件夹用于存放生成的站点文件。</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span>              <span class="comment">#标签文件夹     </span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span>      <span class="comment">#归档文件夹</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span>   <span class="comment">#分类文件夹</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span>   <span class="comment">#Include code 文件夹</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span>            <span class="comment">#国际化（i18n）文件夹</span></span><br><span class="line"><span class="attr">skip_render:</span>               <span class="comment">#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>   <span class="comment">#新文章的文件名称</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>       <span class="comment">#预设布局</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span>           <span class="comment">#把标题转换为 title case</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span>        <span class="comment">#在新标签中打开链接</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span>           <span class="comment">#把文件名称转换为 (1) 小写或 (2) 大写</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span>       <span class="comment">#是否显示草稿</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span>   <span class="comment">#是否启动 Asset 文件夹</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span>       <span class="comment">#把链接改为与根目录的相对位址    </span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span>               <span class="comment">#显示未来的文章</span></span><br><span class="line"><span class="attr">highlight:</span>                 <span class="comment">#内容中代码块的设置    </span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span>          <span class="comment">#分类别名</span></span><br><span class="line"><span class="attr">tag_map:</span>               <span class="comment">#标签别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span>         <span class="comment">#日期格式</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span>           <span class="comment">#时间格式    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span>    <span class="comment">#分页数量</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span>   <span class="comment">#主题名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="comment">#  部署部分的设置</span></span><br><span class="line"><span class="attr">deploy:</span>     </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span>  <span class="comment">#类型，常用的git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/nanshanyi/nanshanyi.github.io.git</span> <span class="comment">#github仓库的地址</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>如果页面中出现中文，应以UTF-8无BOM编码格式，所以不要用win自带的记事本，而是用notepad++这种支持编码转换的编辑器。</strong></p><p>由于google在天朝大陆被墙，进入 <code>themes\landscape\layout\_partial</code> ，打开 <code>head.ejs</code> ，删掉第31行 <code>fonts.googleapis.com</code> 的链接。</p><p>下载下来 <code>jQuery-2.0.3.min.js</code> ，放到 <code>themes\landscape\source\js</code> 文件夹中。之后进入 <code>themes\landscape\layout\_partial</code> ，打开 <code>after-footer.ejs</code> ，将第17行的路径替换为 <code>/js/jquery-2.0.3.min.js</code> 。</p><p>至此大功告成。</p><h2 id="写文章-amp-草稿"><a href="#写文章-amp-草稿" class="headerlink" title="写文章&amp;草稿"></a>写文章&amp;草稿</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p>命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post <span class="string">"new article"</span></span><br></pre></td></tr></table></figure><p>之后在 <code>soource/_posts</code> 目录下面多了一个 <code>new-article.md</code> 的文件。</p><h3 id="文章属性"><a href="#文章属性" class="headerlink" title="文章属性"></a>文章属性</h3><table><thead><tr><th>Setting</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>layout</td><td>Layout</td><td>post或page</td></tr><tr><td>title</td><td>文章的标题</td><td></td></tr><tr><td>date</td><td>穿件日期</td><td>文件的创建日期</td></tr><tr><td>updated</td><td>修改日期</td><td>文件的修改日期</td></tr><tr><td>comments</td><td>是否开启评论</td><td>true</td></tr><tr><td>tags</td><td>标签</td><td></td></tr><tr><td>categories</td><td>分类</td><td></td></tr><tr><td>permalink</td><td>url中的名字</td><td>文件名</td></tr><tr><td>toc</td><td>是否开启目录</td><td>true</td></tr><tr><td>reward</td><td>是否开启打赏</td><td>true</td></tr></tbody></table><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - 日记</span><br><span class="line">tags:</span><br><span class="line">  - Hexo</span><br><span class="line">  - node.js</span><br></pre></td></tr></table></figure><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><code>&lt;!--more--&gt;</code> 之上的内容为摘要。</p><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>草稿相当于很多博客都有的“私密文章”功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"new draft"</span></span><br></pre></td></tr></table></figure><p>会在 <code>source/_drafts</code> 目录下生成一个 <code>new-draft.md</code> 文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到 <code>_drafts</code> 目录之中。</p><p>如果你希望强行预览草稿，更改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render_drafts: true</span><br></pre></td></tr></table></figure><p>或者，如下方式启动server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server --drafts</span><br></pre></td></tr></table></figure><p>下面这条命令可以把草稿变成文章，或者页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">$ hexo publish drafts hexo-使用指南</span><br></pre></td></tr></table></figure><h2 id="Blog中出入图片和音乐"><a href="#Blog中出入图片和音乐" class="headerlink" title="Blog中出入图片和音乐"></a>Blog中出入图片和音乐</h2><p>文章推介：<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzUzZTBkMmE2MTdkYQ==" title="http://www.jianshu.com/p/53e0d2a617da">Hexo 博客中插入音乐/视频<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cDovL2Jsb2cuc2hpcWljaGFuLmNvbS91c2UtcWluaXUtc3RvcmUtaW1hZ2UtZm9yLWhleG8v" title="http://blog.shiqichan.com/use-qiniu-store-image-for-hexo/">使用七牛为Hexo存储图片<i class="fa fa-external-link"></i></span></p><pre><code>[hexo主题中添加相册功能](http://www.cnblogs.com/xljzlw/p/5137622.html)</code></pre><p>​           <span class="exturl" data-url="aHR0cDovL3d1Y2hvbmcubWUvYmxvZy8yMDE0LzEyLzEzL2hleG8tdGhlbWUtY3JlYXRpbmctaW1hZ2Utc3R5bGVzLz91dG1fc291cmNlPXR1aWNvb2wmdXRtX21lZGl1bT1yZWZlcnJhbCM=" title="http://wuchong.me/blog/2014/12/13/hexo-theme-creating-image-styles/?utm_source=tuicool&utm_medium=referral#">为 Hexo 主题添加多种图片样式(主题不错考虑移植)<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzg2MDc=" title="https://yq.aliyun.com/articles/8607">Hexo折腾记——基本配置篇<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qYXJzb24tNzQyNi9wLzU1MTU4NzAuaHRtbA==" title="http://www.cnblogs.com/jarson-7426/p/5515870.html">hexo博客进阶－相册和独立域名<i class="fa fa-external-link"></i></span></p><p>插入图片基本分为两种办法** ：</p><p>（1） 放在本地文件</p><p>首先在根目录下确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。<br>在 hexo 目录，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>之后再使用 <code>hexo new &#39;new&#39;</code>创建新博客的时候，会在 <code>source/_posts</code> 里面创建 <code>.md</code> 文件的同时生成一个相同的名字的文件夹。把该文章中需要使用的图片放在该文件夹下即可。<br>使用的时候</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">“图片描述”（可以不写）</span>](<span class="link">/文件夹名/你的图片名字.JPG</span>)</span><br><span class="line">例如：</span><br><span class="line">！[ ] (new/text.jpg)</span><br></pre></td></tr></table></figure><p>（2）放在<span class="exturl" data-url="aHR0cHM6Ly9wb3J0YWwucWluaXUuY29tL3NpZ251cD9jb2RlPTNsZ2xhczZwZ2kycWE=" title="https://portal.qiniu.com/signup?code=3lglas6pgi2qa">七牛<i class="fa fa-external-link"></i></span>上，需要先注册，上传图片生成链接，直接在文章中使用链接即可。</p><p><strong>插入音乐</strong> ：</p><p>可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器；复制代码，直接粘贴到博文中即可。这样会显示一个网易的播放器，可以把</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">298</span> <span class="attr">height</span>=<span class="string">52</span> <span class="attr">src</span>=<span class="string">"http://music.163.com/outchain/player?type=2&amp;id=32192436&amp;auto=1&amp;height=32"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">//其中的width=298 height=52 均改为0就看不到了，依然可以播放音乐</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/Y60twn8.png" alt></p><p><img src="http://i.imgur.com/i42cvBI.png" alt></p><h2 id="代码高亮highlight-js支持"><a href="#代码高亮highlight-js支持" class="headerlink" title="代码高亮highlight.js支持"></a>代码高亮highlight.js支持</h2><p><span class="exturl" data-url="aHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcv" title="https://highlightjs.org/">highlightjs官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvc3RhdGljL2RlbW8v" title="https://highlightjs.org/static/demo/">highlightjs主题风格<i class="fa fa-external-link"></i></span></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy55ZWhiZWF0cy5jb20vMjAxNS8wNC8wOC9oZXhvLXNlYXJjaC8=" title="http://www.yehbeats.com/2015/04/08/hexo-search/">Hexo，Yilia主题添加站内搜索功能<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2t1YW5ncWkubWUvdHJpY2tzL2VuYWJsZS10YWJsZS1vZi1jb250ZW50cy1vbi1oZXhvLw==" title="http://kuangqi.me/tricks/enable-table-of-contents-on-hexo/">为Hexo博客添加目录<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9hcnRpY2xlLzE5OTYyNA==" title="http://www.ituring.com.cn/article/199624">Hexo站点中添加文章目录以及归档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2NyZXNjZW50bW9vbi5pbmZvLzIwMTQvMTIvMTEvcG9wdWxhci13aWRnZXQv" title="http://crescentmoon.info/2014/12/11/popular-widget/">使用LeanCloud平台为Hexo博客添加文章浏览量统计组件<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy50dWljb29sLmNvbS9hcnRpY2xlcy9BQkZuMnFV" title="http://www.tuicool.com/articles/ABFn2qU">使用hexo搭建静态博客<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9hcnRpY2xlLzE5OTAzNT91dG1fc291cmNlPXR1aWNvb2wmdXRtX21lZGl1bT1yZWZlcnJhbA==" title="http://www.ituring.com.cn/article/199035?utm_source=tuicool&utm_medium=referral">Hexo Docs中文 ： （二）基本用法<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装、初始化和配置&quot;&gt;&lt;a href=&quot;#安装、初始化和配置&quot; class=&quot;headerlink&quot; title=&quot;安装、初始化和配置&quot;&gt;&lt;/a&gt;安装、初始化和配置&lt;/h2&gt;&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;node.js&lt;/li&gt;
&lt;li&gt;github&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://miaopei.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>nodejs+webpack+vuejs 搭建开发环境学习套路</title>
    <link href="http://miaopei.github.io/2017/03/27/nodejs-webpack-vuejs-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AD%A6%E4%B9%A0%E5%A5%97%E8%B7%AF/"/>
    <id>http://miaopei.github.io/2017/03/27/nodejs-webpack-vuejs-搭建开发环境学习套路/</id>
    <published>2017-03-27T10:02:52.000Z</published>
    <updated>2017-03-28T10:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><span class="exturl" data-url="aHR0cDovL3Z1ZWpzLm9yZy92Mi9ndWlkZS8=" title="http://vuejs.org/v2/guide/">官方手册<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv" title="https://cn.vuejs.org/">中文官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly92dWVmZS5jbi92Mi9ndWlkZS8=" title="https://vuefe.cn/v2/guide/">vuejs 2.0 中文文档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=" title="http://es6.ruanyifeng.com/">ECMAScript 6 入门<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Nub2RlanMub3JnL3RvcGljLzUyOGM5YTM4ZDJiMzg5M2YyYWJiNmVlYg==" title="http://cnodejs.org/topic/528c9a38d2b3893f2abb6eeb">node.js相关的中文文档及教程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkv" title="http://nodejs.cn/api/">Node.js中文网API<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3dlYnBhY2tkb2MuY29tLw==" title="http://webpackdoc.com/">Webpack 中文指南<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3dlYnBhY2syLw==" title="http://www.css88.com/doc/webpack2/">webpack2.2中文文档<i class="fa fa-external-link"></i></span></p><p>以上是提供的一些官方资料，下面开始我们的套路吧：</p><a id="more"></a><h3 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建"></a>环境构建</h3><p>1.新建一个目录<code>vuepro</code><br>2.初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vuepro</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化的时候可以一路回车，在最后输入"yes"后会生成package.json文件</span></span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>3.安装模块，先装这么多，有需要再安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install vue webpack babel-loader babel-core babel-preset-env babel-cli babel-preset-es2015 html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>4.创建良好的目录层级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir src</span><br><span class="line">$ <span class="built_in">cd</span> src &amp;&amp; mkdir -p html jssrc webapp</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/qkj7kJd.png" alt>    </p><p><code>html</code>放置模板文件，<code>jssrc</code>放置js文件，最终编译好的文件放置在<code>webapp</code>目录里，这个目录也就是我们网站的目录。</p><p>5.在项目根目录下创建webpack配置文件：<code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack=<span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports =</span><br><span class="line">&#123;</span><br><span class="line">    entry:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//入口文件</span></span><br><span class="line">        <span class="string">"index"</span>:__dirname+<span class="string">'/src/jssrc/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname+<span class="string">'/src/webapp/js'</span>,  <span class="comment">//输出文件夹</span></span><br><span class="line">        filename:<span class="string">'[name].js'</span>   <span class="comment">//最终打包生成的文件名(只是文件名，不带路径的哦)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*resolve: &#123;</span></span><br><span class="line"><span class="comment">        alias: &#123;</span></span><br><span class="line"><span class="comment">            vue: 'vue/dist/vue.js'</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;,*/</span></span><br><span class="line">    externals: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,<span class="attr">loader</span>:<span class="string">"babel-loader"</span>,<span class="attr">query</span>:&#123;<span class="attr">compact</span>:<span class="literal">true</span>&#125;&#125;,</span><br><span class="line">            <span class="comment">//这里肯定要加入n个loader 譬如vue-loader、babel-loader、css-loader等等</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            filename: __dirname+<span class="string">'/src/webapp/index.html'</span>,   <span class="comment">//目标文件</span></span><br><span class="line">            template: __dirname+<span class="string">'/src/html/index.html'</span>, <span class="comment">//模板文件</span></span><br><span class="line">            inject:<span class="string">'body'</span>,</span><br><span class="line">            hash:<span class="literal">true</span>,  <span class="comment">//代表js文件后面会跟一个随机字符串,解决缓存问题</span></span><br><span class="line">            chunks:[<span class="string">"index"</span>]</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.同样在根目录下创建babel配置文件：<code>.babelrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot; : [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在webpack里面配置loader，我们上面webpack配置中已经写了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loaders:[</span><br><span class="line">           &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,<span class="attr">loader</span>:<span class="string">"babel-loader"</span>,<span class="attr">query</span>:&#123;<span class="attr">compact</span>:<span class="literal">true</span>&#125;&#125;,</span><br><span class="line">  <span class="comment">// 经过测试旧版用的是loader:"babel",在新版中用的是loader:"babel-loader"</span></span><br><span class="line">       ]</span><br></pre></td></tr></table></figure><p>这句话意思就是：凡是 <code>.js</code> 文件都使用 <code>babel-loader</code> , 并且压缩。</p><h3 id="学习vue最简单的一个套路"><a href="#学习vue最简单的一个套路" class="headerlink" title="学习vue最简单的一个套路"></a>学习vue最简单的一个套路</h3><p>思考：数据如何渲染？</p><p>套路如下：</p><p>首先要有个数据块标记</p><p>vue里面可以像模板引擎一样写上 <code>{\{name\}}</code></p><p>其中 <code>name</code> 就是变量名</p><h3 id="接下来进行实战练习"><a href="#接下来进行实战练习" class="headerlink" title="接下来进行实战练习"></a>接下来进行实战练习</h3><p><img src="http://i.imgur.com/UhW18FI.png" alt>    </p><p>index.htm l如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"me"</span>&gt;</span></span><br><span class="line">        我的年龄是&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index.js 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>; <span class="comment">//会去node_modules\vue\package.json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#me"</span>,</span><br><span class="line">    data:&#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此，我们需要用 <code>webpack</code> 打包，打包到 <code>webapp</code> 目录下。 </p><p>需要修改2个地方： </p><p>(1)因为我们的 <code>webpack</code> 不是全局安装的，所以不能直接执行 <code>webpack</code> 命令，我们这里借助 <code>npm</code> 来执行。所以需要修改项目根目录下的 <code>package.json</code> 文件，加入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">  "build": "webpack"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>表示：执行build，就会去node_modules.bin\下去寻找webpack命令。<code>build</code> 这个名字是自定义的。</p><p>(2)还需要修改 webpack 配置文件：<code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            vue: <span class="string">'vue/dist/vue.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>我们之前把这个注释掉了，现在打开。此处的意义是找到 <code>node_modules/vue/dist/vue.js</code></p><p>最后，我们就来打包，看看结果是怎样的？ </p><p>终端里还是cd到项目根目录下，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/wmjrYdu.png" alt>    </p><p><code>index.html</code>  就是打包之后的模板文件，<code>js/index.js</code> 就是打包之后的js文件，在 <code>index.html</code> 被引用了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"me"</span>&gt;</span></span><br><span class="line">        我的年龄是&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/index.js?43c73980e35f1569ef72"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预览一下index.html: </p><p><img src="http://i.imgur.com/6kHwB4L.png" alt></p><p>这样就完成了 <code>vueJS</code> 的一个简单案列</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3Z1ZWpzLm9yZy92Mi9ndWlkZS8=&quot; title=&quot;http://vuejs.org/v2/guide/&quot;&gt;官方手册&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jbi52dWVqcy5vcmcv&quot; title=&quot;https://cn.vuejs.org/&quot;&gt;中文官网&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly92dWVmZS5jbi92Mi9ndWlkZS8=&quot; title=&quot;https://vuefe.cn/v2/guide/&quot;&gt;vuejs 2.0 中文文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=&quot; title=&quot;http://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Nub2RlanMub3JnL3RvcGljLzUyOGM5YTM4ZDJiMzg5M2YyYWJiNmVlYg==&quot; title=&quot;http://cnodejs.org/topic/528c9a38d2b3893f2abb6eeb&quot;&gt;node.js相关的中文文档及教程&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL25vZGVqcy5jbi9hcGkv&quot; title=&quot;http://nodejs.cn/api/&quot;&gt;Node.js中文网API&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3dlYnBhY2tkb2MuY29tLw==&quot; title=&quot;http://webpackdoc.com/&quot;&gt;Webpack 中文指南&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3dlYnBhY2syLw==&quot; title=&quot;http://www.css88.com/doc/webpack2/&quot;&gt;webpack2.2中文文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上是提供的一些官方资料，下面开始我们的套路吧：&lt;/p&gt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://miaopei.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 支持的语言</title>
    <link href="http://miaopei.github.io/2017/03/23/Markdown-%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%AD%E8%A8%80/"/>
    <id>http://miaopei.github.io/2017/03/23/Markdown-支持的语言/</id>
    <published>2017-03-23T15:15:37.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown支持的语言"><a href="#Markdown支持的语言" class="headerlink" title="Markdown支持的语言"></a>Markdown支持的语言</h2><a id="more"></a><table><thead><tr><th align="left">名称</th><th>关键字</th><th>调用的js</th></tr></thead><tbody><tr><td align="left">AppleScript</td><td>applescript</td><td>shBrushAppleScript.js</td></tr><tr><td align="left">ActionScript 3.0</td><td>actionscript3 , as3</td><td>shBrushAS3.js</td></tr><tr><td align="left">Shell</td><td>bash , shell</td><td>shBrushBash.js</td></tr><tr><td align="left">ColdFusion</td><td>coldfusion , cf</td><td>shBrushColdFusion.js</td></tr><tr><td align="left">C</td><td>cpp , c</td><td>shBrushCpp.js</td></tr><tr><td align="left">C#</td><td>c# , c-sharp , csharp</td><td>shBrushCSharp.js</td></tr><tr><td align="left">CSS</td><td>css</td><td>shBrushCss.js</td></tr><tr><td align="left">Delphi</td><td>delphi , pascal , pas</td><td>shBrushDelphi.js</td></tr><tr><td align="left">diff&amp;patch</td><td>diff patch</td><td>shBrushDiff.js</td></tr><tr><td align="left">Erlang</td><td>erl , erlang</td><td>shBrushErlang.js</td></tr><tr><td align="left">Groovy</td><td>groovy</td><td>shBrushGroovy.js</td></tr><tr><td align="left">Java</td><td>java</td><td>shBrushJava.js</td></tr><tr><td align="left">JavaFX</td><td>jfx , javafx</td><td>shBrushJavaFX.js</td></tr><tr><td align="left">JavaScript</td><td>js , jscript , javascript</td><td>shBrushJScript.js</td></tr><tr><td align="left">Perl</td><td>perl , pl , Perl</td><td>shBrushPerl.js</td></tr><tr><td align="left">PHP</td><td>php</td><td>shBrushPhp.js</td></tr><tr><td align="left">text</td><td>text , plain</td><td>shBrushPlain.js</td></tr><tr><td align="left">Python</td><td>py , python</td><td>shBrushPython.js</td></tr><tr><td align="left">Ruby</td><td>ruby , rails , ror , rb</td><td>shBrushRuby.js</td></tr><tr><td align="left">SASS&amp;SCSS</td><td>sass , scss</td><td>shBrushSass.js</td></tr><tr><td align="left">Scala</td><td>scala</td><td>shBrushScala.js</td></tr><tr><td align="left">SQL</td><td>sql</td><td>shBrushSql.js</td></tr><tr><td align="left">Visual Basic</td><td>vb , vbnet</td><td>shBrushVb.js</td></tr><tr><td align="left">XML</td><td>xml , xhtml , xslt , html</td><td>shBrushXml.js</td></tr><tr><td align="left">Objective C</td><td>objc , obj-c</td><td>shBrushObjectiveC.js</td></tr><tr><td align="left">F#</td><td>f# f-sharp , fsharp</td><td>shBrushFSharp.js</td></tr><tr><td align="left">R</td><td>r , s , splus</td><td>shBrushR.js</td></tr><tr><td align="left">matlab</td><td>matlab</td><td>shBrushMatlab.js</td></tr><tr><td align="left">swift</td><td>swift</td><td>shBrushSwift.js</td></tr><tr><td align="left">GO</td><td>go , golang</td><td>shBrushGo.js</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Markdown支持的语言&quot;&gt;&lt;a href=&quot;#Markdown支持的语言&quot; class=&quot;headerlink&quot; title=&quot;Markdown支持的语言&quot;&gt;&lt;/a&gt;Markdown支持的语言&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Markdown" scheme="http://miaopei.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;深入解析Go&gt;&gt; 很棒的GitBook</title>
    <link href="http://miaopei.github.io/2017/03/21/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go-%E5%BE%88%E6%A3%92%E7%9A%84GitBook/"/>
    <id>http://miaopei.github.io/2017/03/21/深入解析Go-很棒的GitBook/</id>
    <published>2017-03-21T11:39:42.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<p>很不错的golang剖析，建议有golang基础的再看，讲解的非常详细。<br><span class="exturl" data-url="aHR0cHM6Ly90aWFuY2FpYW1hby5naXRib29rcy5pby9nby1pbnRlcm5hbHMvY29udGVudC96aC8=" title="https://tiancaiamao.gitbooks.io/go-internals/content/zh/">深入解析Go<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很不错的golang剖析，建议有golang基础的再看，讲解的非常详细。&lt;br&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly90aWFuY2FpYW1hby5naXRib29rcy5pby9nby1pbnRlcm5hbHMvY29udG
      
    
    </summary>
    
    
      <category term="golang" scheme="http://miaopei.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Google Rss 加载失败解决</title>
    <link href="http://miaopei.github.io/2017/03/21/Google-Rss-%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3/"/>
    <id>http://miaopei.github.io/2017/03/21/Google-Rss-加载失败解决/</id>
    <published>2017-03-20T19:46:09.000Z</published>
    <updated>2019-06-03T08:10:56.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>博客在google浏览器中使用RSS会出现RSS源码，原因是google浏览器没有安装RSS插件。<br>解决办法，到google网上应用店安装 <b style="color: red">RSS Subscription Extension</b> 即可解决问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;博客在google浏览器中使用RSS会出现RSS源码，原因是google浏览器没有安装RSS插件。&lt;br&gt;解决办法，到google网上应用店安装 &lt;b style=&quot;color: red&quot;&gt;RSS Subscription Extension&lt;/b
      
    
    </summary>
    
    
      <category term="rss" scheme="http://miaopei.github.io/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github 博客多终端同步</title>
    <link href="http://miaopei.github.io/2017/03/20/Hexo-Github-%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/"/>
    <id>http://miaopei.github.io/2017/03/20/Hexo-Github-博客多终端同步/</id>
    <published>2017-03-19T20:20:57.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9ua2V5X0xaTC9hcnRpY2xlL2RldGFpbHMvNjA4NzA4OTE=" title="http://blog.csdn.net/Monkey_LZL/article/details/60870891">原文链接<i class="fa fa-external-link"></i></span></p><p>主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解：</p><a id="more"></a><h2 id="1-准备条件"><a href="#1-准备条件" class="headerlink" title="1. 准备条件"></a>1. 准备条件</h2><p>安装了Node.js,Git,Hexo环境<br>完成Github与本地Hexo的对接<br>这部分大家可以参考<span class="exturl" data-url="aHR0cHM6Ly94dWFud28ub3JnLzIwMTUvMDMvMjYvaGV4by1pbnRvci8=" title="https://xuanwo.org/2015/03/26/hexo-intor/">史上最详细的Hexo博客搭建图文教程<i class="fa fa-external-link"></i></span></p><p>配置好这些，就可以捋起袖子大干一场了！</p><h2 id="2-在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上"><a href="#2-在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上" class="headerlink" title="2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上"></a>2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上</h2><p>在利用Github+Hexo搭建自己的博客时，新建了一个Hexo的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到Github项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件</span></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line">$ git commit -m <span class="string">"Blog Source Hexo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建hexo分支</span></span><br><span class="line">$ git branch hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到hexo分支上</span></span><br><span class="line">$ git checkout hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地与Github项目对接</span></span><br><span class="line">$ git remote add origin https://github.com/yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># push到Github项目的hexo分支上</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure><p>这样你的github项目中就会多出一个Hexo分支，这个就是用于多终端同步关键的部分。</p><h2 id="3-另一终端完成clone和push更新"><a href="#3-另一终端完成clone和push更新" class="headerlink" title="3. 另一终端完成clone和push更新"></a>3. 另一终端完成clone和push更新</h2><p>此时在另一终端更新博客，只需要将Github的hexo分支clone下来，进行初次的相关配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将Github中hexo分支clone到本地</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b hexo https://github.com/yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到刚刚clone的文件夹内</span></span><br><span class="line">$ <span class="built_in">cd</span> yourname.github.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># cheackout 远程代码到本地hexo分支</span></span><br><span class="line">$ git checkout -b hexo origin/hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init</span></span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个.md文件，并编辑完成自己的博客内容</span></span><br><span class="line">$ hexo new post <span class="string">"new blog name"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客</span></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line">$ git commit -m <span class="string">"XX"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新分支</span></span><br><span class="line">$ git push origin hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master</span></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><h2 id="4-不同终端间愉快地玩耍"><a href="#4-不同终端间愉快地玩耍" class="headerlink" title="4. 不同终端间愉快地玩耍"></a>4. 不同终端间愉快地玩耍</h2><p>在不同的终端已经做完配置，就可以愉快的分享自己更新的博客<br>进入自己相应的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先pull完成本地与远端的融合</span></span><br><span class="line">$ git pull origin hexo</span><br><span class="line"></span><br><span class="line">$ hexo new post <span class="string">" new blog name"</span></span><br><span class="line"></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"XX"</span></span><br><span class="line"></span><br><span class="line">$ git push origin hexo</span><br><span class="line"></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9ua2V5X0xaTC9hcnRpY2xlL2RldGFpbHMvNjA4NzA4OTE=&quot; title=&quot;http://blog.csdn.net/Monkey_LZL/article/details/60870891&quot;&gt;原文链接&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解：&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://miaopei.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Git分支管理策略</title>
    <link href="http://miaopei.github.io/2017/01/27/git-branch/"/>
    <id>http://miaopei.github.io/2017/01/27/git-branch/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>如果你严肃对待编程，就必定会使用”版本管理系统”（Version Control System）。</p><p>眼下最流行的”版本管理系统”，非Git莫属。</p><a id="more"></a><p>相比同类软件，Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称”快照”）的指针，因此非常快捷易用。</p><p>但是，太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。</p><p>Vincent Driessen提出了一个分支管理的策略，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用，Git只是用来举例而已。如果你不熟悉Git，跳过举例部分就可以了。</p><h2 id="一、主分支Master"><a href="#一、主分支Master" class="headerlink" title="一、主分支Master"></a>一、主分支Master</h2><p>首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。</p><p><img src="http://i.imgur.com/CxJhyfD.png" alt></p><p>Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p><h2 id="二、开发分支Develop"><a href="#二、开发分支Develop" class="headerlink" title="二、开发分支Develop"></a>二、开发分支Develop</h2><p>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。</p><p><img src="http://i.imgur.com/TQ5k5sO.png" alt></p><p>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。</p><p>Git创建Develop分支的命令：</p><pre><code>git checkout -b develop master</code></pre><p>将Develop分支发布到Master分支的命令：</p><pre><code># 切换到Master分支git checkout master# 对Develop分支进行合并git merge --no-ff develop</code></pre><p>这里稍微解释一下，上一条命令的 <code>--no-ff</code> 参数是什么意思。默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。</p><p>使用 <code>--no-ff</code> 参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。</p><p><img src="http://i.imgur.com/X97wbk9.png" alt></p><h2 id="三、临时性分支"><a href="#三、临时性分支" class="headerlink" title="三、临时性分支"></a>三、临时性分支</h2><p>前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。</p><p>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p><pre><code>* 功能（feature）分支* 预发布（release）分支* 修补bug（fixbug）分支</code></pre><p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p><h2 id="四、功能分支"><a href="#四、功能分支" class="headerlink" title="四、功能分支"></a>四、功能分支</h2><p>接下来，一个个来看这三种”临时性分支”。</p><p>第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。</p><p><img src="http://i.imgur.com/OyWvBLR.png" alt></p><p>功能分支的名字，可以采用 <code>feature-*</code> 的形式命名。</p><p>创建一个功能分支：</p><pre><code>git checkout -b feature-x develop</code></pre><p>开发完成后，将功能分支合并到develop分支：</p><pre><code>git checkout developgit merge --no-ff feature-x</code></pre><p>删除feature分支：</p><pre><code>git branch -d feature-x</code></pre><h2 id="五、预发布分支"><a href="#五、预发布分支" class="headerlink" title="五、预发布分支"></a>五、预发布分支</h2><p>第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。</p><p>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用 <code>release-*</code> 的形式。</p><p>创建一个预发布分支：</p><pre><code>git checkout -b release-1.2 develop</code></pre><p>确认没有问题后，合并到master分支：</p><pre><code>git checkout mastergit merge --no-ff release-1.2# 对合并生成的新节点，做一个标签git tag -a 1.2</code></pre><p>再合并到develop分支：</p><pre><code>git checkout developgit merge --no-ff release-1.2</code></pre><p>最后，删除预发布分支：</p><pre><code>git branch -d release-1.2</code></pre><h2 id="六、修补bug分支"><a href="#六、修补bug分支" class="headerlink" title="六、修补bug分支"></a>六、修补bug分支</h2><p>最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。</p><p><strong>修补bug分支是从Master分支上面分出来的</strong>。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用 <code>fixbug-*</code> 的形式。</p><p><img src="http://i.imgur.com/gQoDYSK.png" alt></p><p>创建一个修补bug分支：</p><pre><code>git checkout -b fixbug-0.1 master</code></pre><p>修补结束后，合并到master分支：</p><pre><code>git checkout mastergit merge --no-ff fixbug-0.1git tag -a 0.1.1</code></pre><p>再合并到develop分支：</p><pre><code>git checkout developgit merge --no-ff fixbug-0.1</code></pre><p>最后，删除”修补bug分支”：</p><pre><code>git branch -d fixbug-0.1</code></pre>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git工作流程</title>
    <link href="http://miaopei.github.io/2017/01/27/git-workflow/"/>
    <id>http://miaopei.github.io/2017/01/27/git-workflow/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<p>Git 作为一个源码管理系统，不可避免涉及到多人协作。</p><p>协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。</p><a id="more"></a><p><img src="http://i.imgur.com/KCRatZr.png" alt></p><p>本文介绍三种广泛使用的工作流程：</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow</li></ul><h2 id="一、功能驱动"><a href="#一、功能驱动" class="headerlink" title="一、功能驱动"></a>一、功能驱动</h2><p>本文的三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。</p><p>它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。</p><h2 id="二、Git-Flow"><a href="#二、Git-Flow" class="headerlink" title="二、Git Flow"></a>二、Git Flow</h2><p>最早诞生、并得到广泛采用的一种工作流程，就是Git flow 。</p><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><p>它最主要的特点有两个。</p><p><img src="http://i.imgur.com/8RTngnI.png" alt></p><p>首先，项目存在两个长期分支。</p><ul><li>主分支 <code>master</code></li><li>开发分支 <code>develop</code></li></ul><p>前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放最新的开发版。</p><p>其次，项目存在三种短期分支。</p><ul><li>功能分支（feature branch）</li><li>补丁分支（hotfix branch）</li><li>预发分支（release branch）</li></ul><p>一旦完成开发，它们就会被合并进 <code>develop</code> 或 <code>master</code> ，然后被删除。</p><h3 id="2-2-评价"><a href="#2-2-评价" class="headerlink" title="2.2 评价"></a>2.2 评价</h3><p>Git flow的优点是清晰可控，缺点是相对复杂，需要同时维护两个长期分支。大多数工具都将 <code>master</code> 当作默认分支，可是开发是在 <code>develop</code> 分支进行的，这导致经常要切换分支，非常烦人。</p><p>更大问题在于，这个模式是基于”版本发布”的，目标是一段时间以后产出一个新版本。但是，很多网站项目是”持续发布”，代码一有变动，就部署一次。这时， <code>master</code> 分支和 <code>develop</code> 分支的差别不大，没必要维护两个长期分支。</p><h2 id="三、Github-flow"><a href="#三、Github-flow" class="headerlink" title="三、Github flow"></a>三、Github flow</h2><p>Github flow 是Git flow的简化版，专门配合”持续发布”。它是 Github.com 使用的工作流程。</p><h3 id="3-1-流程"><a href="#3-1-流程" class="headerlink" title="3.1 流程"></a>3.1 流程</h3><p>它只有一个长期分支，就是 <code>master</code> ，因此用起来非常简单。</p><p>官方推荐的流程如下。</p><p><img src="http://i.imgur.com/d7sDto2.png" alt></p><pre><code>第一步：根据需求，从 master 拉出新分支，不区分功能分支或补丁分支。第二步：新分支开发完成后，或者需要讨论的时候，就向 master 发起一个 pull request（简称PR）。第三步：Pull Request 既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。第四步：你的 Pull Request 被接受，合并进 master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</code></pre><h3 id="3-2-评价"><a href="#3-2-评价" class="headerlink" title="3.2 评价"></a>3.2 评价</h3><p>Github flow 的最大优点就是简单，对于”持续发布”的产品，可以说是最合适的流程。</p><p>问题在于它的假设：<code>master</code> 分支的更新与产品的发布是一致的。也就是说，<code>master</code> 分支的最新代码，默认就是当前的线上代码。</p><p>可是，有些时候并非如此，代码合并进入 <code>master</code> 分支，并不代表它就能立刻发布。比如，苹果商店的APP提交审核以后，等一段时间才能上架。这时，如果还有新的代码提交，<code>master</code> 分支就会与刚发布的版本不一致。另一个例子是，有些公司有发布窗口，只有指定时间才能发布，这也会导致线上版本落后于 <code>master</code> 分支。</p><p>上面这种情况，只有 <code>master</code> 一个主分支就不够用了。通常，你不得不在master分支以外，另外新建一个 <code>production</code> 分支跟踪线上版本。</p><h2 id="四、Gitlab-flow"><a href="#四、Gitlab-flow" class="headerlink" title="四、Gitlab flow"></a>四、Gitlab flow</h2><p>Gitlab flow 是 Git flow 与 Github flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。</p><h3 id="4-1-上游优先"><a href="#4-1-上游优先" class="headerlink" title="4.1 上游优先"></a>4.1 上游优先</h3><p>Gitlab flow 的最大原则叫做”上游优先”（upsteam first），即只存在一个主分支 <code>master</code>，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。</p><p>Chromium项目就是一个例子，它明确规定，上游分支依次为：</p><ol><li>Linus Torvalds的分支</li><li>子系统（比如netdev）的分支</li><li>设备厂商（比如三星）的分支</li></ol><h3 id="4-2-持续发布"><a href="#4-2-持续发布" class="headerlink" title="4.2 持续发布"></a>4.2 持续发布</h3><p>Gitlab flow 分成两种情况，适应不同的开发流程。</p><p><img src="http://i.imgur.com/SLLsAER.png" alt></p><p>对于”持续发布”的项目，它建议在 <code>master</code> 分支以外，再建立不同的环境分支。比如，”开发环境”的分支是 <code>master</code>，”预发环境”的分支是 <code>pre-production</code>，”生产环境”的分支是 <code>production</code>。</p><p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到 <code>master</code>，确认没有问题，再 <code>cherry-pick</code> 到 <code>pre-production</code> ，这一步也没有问题，才进入 <code>production</code>。</p><p>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p><h3 id="4-3-版本发布"><a href="#4-3-版本发布" class="headerlink" title="4.3 版本发布"></a>4.3 版本发布</h3><p><img src="http://i.imgur.com/0x3ExTi.png" alt></p><p>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从 <code>master</code> 分支拉出一个分支，比如 <code>2-3-stable</code>、<code>2-4-stable</code> 等等。</p><p>以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。</p><h2 id="五、一些小技巧"><a href="#五、一些小技巧" class="headerlink" title="五、一些小技巧"></a>五、一些小技巧</h2><h3 id="5-1-Pull-Request"><a href="#5-1-Pull-Request" class="headerlink" title="5.1 Pull Request"></a>5.1 Pull Request</h3><p><img src="http://i.imgur.com/pv6ho8H.png" alt></p><p>功能分支合并进 <code>master</code> 分支，必须通过 <code>Pull Request</code>（Gitlab里面叫做 Merge Request）。</p><p><img src="http://i.imgur.com/uXRDTx8.png" alt></p><p>前面说过，Pull Request本质是一种对话机制，你可以在提交的时候，@相关人员或团队，引起他们的注意。</p><h3 id="5-2-Protected-branch"><a href="#5-2-Protected-branch" class="headerlink" title="5.2 Protected branch"></a>5.2 Protected branch</h3><p><code>master</code> 分支应该受到保护，不是每个人都可以修改这个分支，以及拥有审批 <code>Pull Request</code> 的权力。<br>Github 和 Gitlab 都提供”保护分支”（Protected branch）这个功能。</p><h3 id="5-3-Issue"><a href="#5-3-Issue" class="headerlink" title="5.3 Issue"></a>5.3 Issue</h3><p>Issue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。</p><p>功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如”15-require-a-password-to-change-it”。</p><p><img src="http://i.imgur.com/6G4rMsn.png" alt></p><p>开发完成后，在提交说明里面，可以写上 <code>&quot;fixes #14&quot;</code> 或者 <code>&quot;closes #67&quot;</code>。Github规定，只要 <code>commit message</code> 里面有下面这些动词 + 编号，就会关闭对应的issue。</p><ul><li>close</li><li>closes</li><li>closed</li><li>fix</li><li>fixes</li><li>fixed</li><li>resolve</li><li>resolves</li><li>resolved</li></ul><p>这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是 <code>username/repository#issue_number</code>。</p><p><code>Pull Request</code>被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。</p><h3 id="5-4-Merge节点"><a href="#5-4-Merge节点" class="headerlink" title="5.4 Merge节点"></a>5.4 Merge节点</h3><p>Git有两种合并：一种是”直进式合并”（fast forward），不生成单独的合并节点；另一种是”非直进式合并”（none fast-forword），会生成单独节点。</p><p>前者不利于保持 <code>commit</code> 信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用 <code>--no-ff</code> 参数）。只要发生合并，就要有一个单独的合并节点。</p><h3 id="5-5-Squash-多个-commit"><a href="#5-5-Squash-多个-commit" class="headerlink" title="5.5 Squash 多个 commit"></a>5.5 Squash 多个 commit</h3><p>为了便于他人阅读你的提交，也便于 <code>cherry-pick</code> 或撤销代码变化，在发起 <code>Pull Request</code> 之前，应该把多个 <code>commit</code> 合并成一个。（前提是，该分支只有你一个人开发，且没有跟 <code>master</code> 合并过。）</p><p><img src="http://i.imgur.com/NsLF4by.png" alt></p><p>这可以采用rebase命令附带的squash操作，具体方法请参考《Git 使用规范流程》。</p>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>常用Git命令清单</title>
    <link href="http://miaopei.github.io/2017/01/27/git-common-list/"/>
    <id>http://miaopei.github.io/2017/01/27/git-common-list/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>我每天使用 Git ，但是很多命令记不住。</p><p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p><a id="more"></a><p><img src="http://i.imgur.com/zYeQxr4.png" alt></p><p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><pre><code># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><pre><code># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><pre><code># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><pre><code># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><pre><code># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><pre><code># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]</code></pre><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><pre><code># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><pre><code># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><pre><code># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop</code></pre><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><pre><code># 生成一个可供发布的压缩包$ git archive</code></pre>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git远程操作详解</title>
    <link href="http://miaopei.github.io/2017/01/27/git-remote-operation/"/>
    <id>http://miaopei.github.io/2017/01/27/git-remote-operation/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。</p><p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p><a id="more"></a><ul><li>git clone</li><li>git remote</li><li>git fetch</li><li>git pull</li><li>git push</li></ul><p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p><p><img src="http://i.imgur.com/m5Q68Gr.png" alt></p><h2 id="一、git-clone"><a href="#一、git-clone" class="headerlink" title="一、git clone"></a>一、git clone</h2><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到 <code>git clone</code> 命令。</p><pre><code>$ git clone &lt;版本库的网址&gt;</code></pre><p>比如，克隆jQuery的版本库。</p><pre><code>$ git clone https://github.com/jquery/jquery.git</code></pre><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为 <code>git clone</code> 命令的第二个参数。</p><pre><code>$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code></pre><p><code>git clone</code> 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p><pre><code>$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/</code></pre><p>SSH协议还有另一种写法。</p><pre><code>$ git clone [user@]example.com:path/to/repo.git/</code></pre><p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p><h2 id="二、git-remote"><a href="#二、git-remote" class="headerlink" title="二、git remote"></a>二、git remote</h2><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code> 命令就用于管理主机名。</p><p>不带选项的时候，<code>git remote</code> 命令列出所有远程主机。</p><pre><code>$ git remoteorigin</code></pre><p>使用 <code>-v</code> 选项，可以参看远程主机的网址。</p><pre><code>$ git remote -vorigin  git@github.com:jquery/jquery.git (fetch)origin  git@github.com:jquery/jquery.git (push)</code></pre><p>上面命令表示，当前只有一台远程主机，叫做 <code>origin</code>，以及它的网址。</p><p>克隆版本库的时候，所使用的远程主机自动被Git命名为 <code>origin</code>。如果想用其他的主机名，需要用 <code>git clone</code> 命令的 <code>-o</code> 选项指定。</p><pre><code>$ git clone -o jQuery https://github.com/jquery/jquery.git$ git remotejQuery</code></pre><p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p><p><code>git remote show</code> 命令加上主机名，可以查看该主机的详细信息。</p><pre><code>$ git remote show &lt;主机名&gt;</code></pre><p><code>git remote add</code> 命令用于添加远程主机。</p><pre><code>$ git remote add &lt;主机名&gt; &lt;网址&gt;</code></pre><p><code>git remote rm</code> 命令用于删除远程主机。</p><pre><code>$ git remote rm &lt;主机名&gt;</code></pre><p><code>git remote rename</code> 命令用于远程主机的改名。</p><pre><code>$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></pre><h2 id="三、git-fetch"><a href="#三、git-fetch" class="headerlink" title="三、git fetch"></a>三、git fetch</h2><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到 <code>git fetch</code> 命令。</p><pre><code>$ git fetch &lt;远程主机名&gt;</code></pre><p>上面命令将某个远程主机的更新，全部取回本地。</p><p><code>git fetch</code> 命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p><p>默认情况下，<code>git fetch</code> 取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p><pre><code>$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></pre><p>比如，取回 <code>origin</code> 主机的 <code>master</code> 分支。</p><pre><code>$ git fetch origin master</code></pre><p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如 <code>origin</code> 主机的 <code>master</code>，就要用 <code>origin/master</code> 读取。</p><p><code>git branch</code> 命令的 <code>-r</code> 选项，可以用来查看远程分支，<code>-a</code> 选项查看所有分支。</p><pre><code>$ git branch -rorigin/master$ git branch -a* master  remotes/origin/master</code></pre><p>上面命令表示，本地主机的当前分支是 <code>master</code>，远程分支是 <code>origin/master</code>。</p><p>取回远程主机的更新以后，可以在它的基础上，使用 <code>git checkout</code> 命令创建一个新的分支。</p><pre><code>$ git checkout -b newBrach origin/master</code></pre><p>上面命令表示，在 <code>origin/master</code> 的基础上，创建一个新分支。</p><p>此外，也可以使用 <code>git merge</code> 命令或者 <code>git rebase</code> 命令，在本地分支上合并远程分支。</p><pre><code>$ git merge origin/master# 或者$ git rebase origin/master</code></pre><p>上面命令表示在当前分支上，合并 <code>origin/master</code>。</p><h2 id="四、git-pull"><a href="#四、git-pull" class="headerlink" title="四、git pull"></a>四、git pull</h2><p><code>git pull</code> 命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p><pre><code>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>比如，取回 <code>origin</code> 主机的 <code>next</code> 分支，与本地的 <code>master</code> 分支合并，需要写成下面这样。</p><pre><code>$ git pull origin next:master</code></pre><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><pre><code>$ git pull origin next</code></pre><p>上面命令表示，取回 <code>origin/next</code> 分支，再与当前分支合并。实质上，这等同于先做 <code>git fetch</code> ，再做 <code>git merge</code>。</p><pre><code>$ git fetch origin$ git merge origin/next</code></pre><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在 <code>git clone</code> 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 <code>master</code> 分支自动”追踪” <code>origin/master</code> 分支。</p><p>Git也允许手动建立追踪关系。</p><pre><code>git branch --set-upstream master origin/next</code></pre><p>上面命令指定 <code>master</code> 分支追踪 <code>origin/next</code> 分支。</p><p>如果当前分支与远程分支存在追踪关系，<code>git pull</code> 就可以省略远程分支名。</p><pre><code>$ git pull origin</code></pre><p>上面命令表示，本地的当前分支自动与对应的 <code>origin</code> 主机”追踪分支”（remote-tracking branch）进行合并。</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><pre><code>$ git pull</code></pre><p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p><p>如果合并需要采用 <code>rebase</code> 模式，可以使用 <code>--rebase</code> 选项。</p><pre><code>$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致 <code>git pull</code> 不知不觉删除了本地分支。</p><p>但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。</p><pre><code>$ git pull -p# 等同于下面的命令$ git fetch --prune origin $ git fetch -p</code></pre><h2 id="五、git-push"><a href="#五、git-push" class="headerlink" title="五、git push"></a>五、git push</h2><p><code>git push</code> 命令用于将本地分支的更新，推送到远程主机。它的格式与 <code>git pull</code> 命令相仿。</p><pre><code>$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></pre><p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以 <code>git pull</code> 是&lt;远程分支&gt;:&lt;本地分支&gt;，而 <code>git push</code> 是&lt;本地分支&gt;:&lt;远程分支&gt;。</p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><pre><code>$ git push origin master</code></pre><p>上面命令表示，将本地的 <code>master</code> 分支推送到 <code>origin</code> 主机的 <code>master</code> 分支。如果后者不存在，则会被新建。</p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><pre><code>$ git push origin :master# 等同于$ git push origin --delete master</code></pre><p>上面命令表示删除 <code>origin</code> 主机的 <code>master</code> 分支。</p><p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p><pre><code>$ git push origin</code></pre><p>上面命令表示，将当前分支推送到 <code>origin</code> 主机的对应分支。</p><p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p><pre><code>$ git push</code></pre><p>如果当前分支与多个主机存在追踪关系，则可以使用 <code>-u</code> 选项指定一个默认主机，这样后面就可以不加任何参数使用 <code>git push</code>。</p><pre><code>$ git push -u origin master</code></pre><p>上面命令将本地的 <code>master</code> 分支推送到 <code>origin</code> 主机，同时指定 <code>origin</code> 为默认主机，后面就可以不加任何参数使用 <code>git push</code> 了。</p><p>不带任何参数的 <code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用 <code>git config</code> 命令。</p><pre><code>$ git config --global push.default matching# 或者$ git config --global push.default simple</code></pre><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 <code>--all</code> 选项。</p><pre><code>$ git push --all origin</code></pre><p>上面命令表示，将所有本地分支都推送到 <code>origin</code> 主机。</p><p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做 <code>git pull</code> 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 <code>--force</code> 选项。</p><pre><code>$ git push --force origin </code></pre><p>上面命令使用 <code>--force</code> 选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用 <code>--force</code> 选项。</p><p>最后，<code>git push</code> 不会推送标签（tag），除非使用 <code>--tags</code> 选项。</p><pre><code>$ git push origin --tags</code></pre>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git使用规范流程</title>
    <link href="http://miaopei.github.io/2017/01/27/git-using-standard-process/"/>
    <id>http://miaopei.github.io/2017/01/27/git-using-standard-process/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。</p><p>否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。</p><p>下面是ThoughtBot 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。</p><a id="more"></a><p><img src="http://i.imgur.com/WjTakfD.png" alt></p><h2 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h2><p>首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考《Git分支管理策略》）。</p><pre><code># 获取主干最新代码$ git checkout master$ git pull# 新建一个开发分支myfeature$ git checkout -b myfeature</code></pre><h2 id="第二步：提交分支commit"><a href="#第二步：提交分支commit" class="headerlink" title="第二步：提交分支commit"></a>第二步：提交分支commit</h2><p>分支修改后，就可以提交commit了。</p><pre><code>$ git add --all$ git status$ git commit --verbose</code></pre><p><code>git add</code> 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。</p><p><code>git status</code> 命令，用来查看发生变动的文件。</p><p><code>git commit</code> 命令的 <code>verbose</code> 参数，会列出 diff 的结果。</p><h2 id="第三步：撰写提交信息"><a href="#第三步：撰写提交信息" class="headerlink" title="第三步：撰写提交信息"></a>第三步：撰写提交信息</h2><p>提交commit时，必须给出完整扼要的提交信息，下面是一个范本。</p><pre><code>Present-tense summary under 50 characters* More information about commit (under 72 characters).* More information about commit (under 72 characters).http://project.management-system.com/ticket/123</code></pre><p>第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。</p><h2 id="第四步：与主干同步"><a href="#第四步：与主干同步" class="headerlink" title="第四步：与主干同步"></a>第四步：与主干同步</h2><p>分支的开发过程中，要经常与主干保持同步。</p><pre><code>$ git fetch origin$ git rebase origin/master</code></pre><h2 id="第五步：合并commit"><a href="#第五步：合并commit" class="headerlink" title="第五步：合并commit"></a>第五步：合并commit</h2><p>分支开发完成后，很可能有一堆 <code>commit</code>，但是合并到主干的时候，往往希望只有一个（或最多两三个）<code>commit</code>，这样不仅清晰，也容易管理。</p><p>那么，怎样才能将多个 <code>commit</code> 合并呢？这就要用到 <code>git rebase</code> 命令。</p><pre><code>$ git rebase -i origin/master</code></pre><p><code>git rebase</code> 命令的 <code>i</code> 参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usagepick de9b1eb Fix PostChecker::Post#urlspick 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend# Rebase 8db7e8b..fa20af3 onto 8db7e8b## Commands:#  p, pick = use commit#  r, reword = use commit, but edit the commit message#  e, edit = use commit, but stop for amending#  s, squash = use commit, but meld into previous commit#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message#  x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out</code></pre><p>上面的互动界面，先列出当前分支最新的4个 <code>commit</code>（越下面越新）。每个 <code>commit</code> 前面有一个操作命令，默认是 <code>pick</code>，表示该行 <code>commit</code> 被选中，要进行 <code>rebase</code> 操作。</p><p>4个commit的下面是一大堆注释，列出可以使用的命令。</p><ul><li>pick：正常选中</li><li>reword：选中，并且修改提交信息；</li><li>edit：选中，rebase时会暂停，允许你修改这个commit（参考这里）</li><li>squash：选中，会将当前commit与上一个commit合并</li><li>fixup：与squash相同，但不会保存当前commit的提交信息</li><li>exec：执行其他shell命令</li></ul><p>上面这6个命令当中，<code>squash</code> 和 <code>fixup</code> 可以用来合并 <code>commit</code>。先把需要合并的 <code>commit</code> 前面的动词，改成 <code>squash</code>（或者s）。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlss 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend</code></pre><p>这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。</p><pre><code># This is a combination of 3 commits.# The first commit&apos;s message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:Hey kids, stop all the highlighting</code></pre><p>如果将第三行的 <code>squash</code> 命令改成 <code>fixup</code> 命令。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlsf 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend</code></pre><p>运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。</p><pre><code># This is a combination of 3 commits.# The first commit&apos;s message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:# Hey kids, stop all the highlighting</code></pre><p>Pony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。</p><pre><code>$ git reset HEAD~5$ git add .$ git commit -am &quot;Here&apos;s the bug fix that closes #28&quot;$ git push --force</code></pre><p><code>squash</code> 和 <code>fixup</code> 命令，还可以当作命令行参数使用，自动合并commit。</p><pre><code>$ git commit --fixup  $ git rebase -i --autosquash </code></pre><p>这个用法请参考<span class="exturl" data-url="aHR0cDovL2ZsZS5naXRodWIuaW8vZ2l0LXRpcC1rZWVwLXlvdXItYnJhbmNoLWNsZWFuLXdpdGgtZml4dXAtYW5kLWF1dG9zcXVhc2guaHRtbA==" title="http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html">http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html<i class="fa fa-external-link"></i></span>，这里就不解释了。</p><h2 id="第六步：推送到远程仓库"><a href="#第六步：推送到远程仓库" class="headerlink" title="第六步：推送到远程仓库"></a>第六步：推送到远程仓库</h2><p>合并commit后，就可以推送当前分支到远程仓库了。</p><pre><code>$ git push --force origin myfeature</code></pre><p><code>git push</code> 命令要加上 <code>force</code> 参数，因为 <code>rebase</code> 以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送。</p><h2 id="第七步：发出Pull-Request"><a href="#第七步：发出Pull-Request" class="headerlink" title="第七步：发出Pull Request"></a>第七步：发出Pull Request</h2><p>提交到远程仓库以后，就可以发出 <code>Pull Request</code> 到 <code>master</code> 分支，然后请求别人进行代码 <code>review</code>，确认可以合并到 <code>master</code>。</p>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="http://miaopei.github.io/2016/12/23/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://miaopei.github.io/2016/12/23/Docker-学习笔记/</id>
    <published>2016-12-23T02:14:50.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h1><h3 id="常用Docker命令"><a href="#常用Docker命令" class="headerlink" title="常用Docker命令"></a>常用Docker命令</h3><hr><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启Docker守护进程调试模式</span></span><br><span class="line">$ sudo docker daemon -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Docker信息</span></span><br><span class="line">$ sudo docker info </span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止或者启动Docker</span></span><br><span class="line">$ sudo service docker stop/start </span><br><span class="line"></span><br><span class="line"><span class="comment"># 以命令行模式运行一个容器</span></span><br><span class="line">$ sudo docker run -i -t ubuntu /bin/bash </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给容器命名</span></span><br><span class="line">$ sudo docker run --name Micheal_container -i -t ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动或者停止运行的容器</span></span><br><span class="line">$ sudo docker start/stop Micheal_container </span><br><span class="line"></span><br><span class="line"><span class="comment"># 附着到正在运行的容器</span></span><br><span class="line">$ sudo docker attach Micheal_container</span><br></pre></td></tr></table></figure><p><strong>创建守护式容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的docker run 使用了<code>-d</code>参数，因此Docker会将容器放到后台运行。</p></blockquote><p><strong>Docker日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取守护式容器的日志</span></span><br><span class="line">$ sudo docker logs daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪守护式容器的日志</span></span><br><span class="line">$ sudo docker logs -f daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取日志的最后10行</span></span><br><span class="line">$ sudo docker logs --tail 10 daemon_dave </span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪某个容器的最新日志</span></span><br><span class="line">$ sudo docker logs --tail 0 -f daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># -t 标志为每条日志项加上时间戳</span></span><br><span class="line">$ sudo docker logs -ft daemon_dave</span><br></pre></td></tr></table></figure><p><strong>Docker日志驱动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --<span class="built_in">log</span>-driver=<span class="string">"syslog"</span> --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p>使用syslog将会禁用docker logs命令，并且将所有容器的日志输出都重定向到Syslog。</p></blockquote><p><strong>查看容器内的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker top daemon_dave</span><br></pre></td></tr></table></figure><p><strong>Docker统计信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker stats daemon_dave daemon_kate daemon_clear daemon_sarah</span><br></pre></td></tr></table></figure><blockquote><p>以上命令可以看到一个守护容器的列表，以及他们的CPU、内存、网络I/O以及存储I/O的性能和指标。这对快速监控一台主机上的一组容器非常有用。</p></blockquote><p><strong>在容器内部运行进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -d daemon_dave touch /etc/new_config_file</span><br></pre></td></tr></table></figure><blockquote><p><code>-d</code>表示需要运行一个后台进程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内运行交互命令</span></span><br><span class="line">$ sudo docker <span class="built_in">exec</span> -t -i daemon_dave /bin/bash</span><br></pre></td></tr></table></figure><p><strong>自动重启容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --restart=always --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p><code>--restart</code>标志被设置为always。无论容器的退出代码是什么，Docker都会自动重启改容器。除了always，还可以将这个标志设为<code>on-failure</code>，这样，只有当容器的退出代码为非0值的时候，才会自动重启。另外，on-failure还接受一个可选的重启次数参数，<code>--restart=on-failure:5</code>,Docker会尝试自动重启改容器，最多重启5次。</p></blockquote><p><strong>深入容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect daemon_dave</span><br></pre></td></tr></table></figure><blockquote><p>docker inspect命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置以及很多有用的数据。可以使用<code>-f</code>或者<code>--format</code>标志来选定查看结果。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format=<span class="string">'&#123;.State.Running&#125;'</span> daemon_dave</span><br></pre></td></tr></table></figure><blockquote><p>查看多个容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format <span class="string">'&#123;.Name&#125; &#123;.State.Running&#125;'</span> daemon_dave Micheal_container</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong><br>​    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker rm daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line">$ sudo docker rm `sudo docker ps -a -q`</span><br></pre></td></tr></table></figure><p><strong>列出所有镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br></pre></td></tr></table></figure><p><strong>拉去镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure><p><strong>运行一个带标签的Docker镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t --name new_container ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure><p><strong>查找镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker search puppet</span><br></pre></td></tr></table></figure><p><strong>构建镜像</strong></p><ul><li>使用<code>docker commit</code>命令</li><li>使用<code>docker build</code>命令和<code>Dockerfile</code>文件</li></ul><p><strong>用Docker的commit命令创建镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来安装需要安装的工具，安装完成后exit退出容器, eg：</span></span><br><span class="line">$ apt-get -yqq update</span><br><span class="line">$ apt-get -y install apache2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定提交修改过的容器的ID（可以通过docker ps -l -q命令得到刚创建的容器的ID）</span></span><br><span class="line">$ sudo docker commit 4aab3cecb76 micheal/apache2  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查新创建的镜像</span></span><br><span class="line">sudo docker images micheal/apache2  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交另一个新定制容器</span></span><br><span class="line"><span class="comment"># -m 选项用来指定新创建的镜像的提交信息，-a 用来列出该镜像的作者信息。</span></span><br><span class="line">$ sudo docker commit -m<span class="string">"A new custom image"</span> -a<span class="string">"Micheal"</span> 4aab3cecb76 micheal/apache2:webserver</span><br></pre></td></tr></table></figure><p><strong>用Dockerfile构建镜像</strong></p><p>Dockerfile文件示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Vsersion: 0.0.1</span></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER Micheal "miaopei@baicells.com"</span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get -y install nginx</span><br><span class="line">RUN echo 'Hi, I an in your container' &gt; /usr/share/nginx/html/index.html</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><blockquote><p>Dockerfile中的指令会按照顺序从上到下执行，所以根据需要合理安排指令的顺序。</p><p>如果Dockerfile由于某些原因没有正常结束，那么用户得到了一个可以使用的镜像。这对调试非常有帮助：可以基于改镜像运行一个具备交互功能的容器，使用最后创建的镜像对为什么用户指令会失败进行调试。</p><p><strong>每个Dockerfile的第一条指令必须是FROM</strong>,FROM指令指定一个已经存在的镜像，后续指令都将基于该镜像进行，这个镜像被称为基础镜像。</p><p>MAINTAINER指令告诉Docker镜像的作者是谁，以及作者的电子邮件。有助于标识镜像的所有者和联系方式。</p></blockquote><blockquote><p>默认情况下，RUN指令会在shell里使用命令包装器<code>/bin/sh -c</code>来执行，如果是在一个不支持shell的平台上运行或者不希望在shell中运行（比如避免shell字符串篡改），也可以使用<code>exec</code>格式的RUN指令，如下所示：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ "apt-get", " install", "-y", "nginx" ]</span><br></pre></td></tr></table></figure><blockquote><p>EXPOSE指令告诉Docker该容器内的应用程序将会使用该容器的指定端口。</p></blockquote><p><strong>基于Dockerfile构建新镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web"</span> .</span><br><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web:v1"</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里Docker假设在这个Git仓库的根目录下存在Dockerfile文件</span></span><br><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web:v1"</span> git@github.com:micheal/docker_static_web  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略Dockerfile的构建缓存</span></span><br><span class="line">$ sudo docker build --no-cache -t=<span class="string">"micheal/static_web"</span> .</span><br></pre></td></tr></table></figure><p><strong>查看镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出Docker镜像</span></span><br><span class="line">$ sudo docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像每一层，以及创建这些层的Dockerfile指令</span></span><br><span class="line">$ sudo docker <span class="built_in">history</span> micheal/static_web </span><br><span class="line"></span><br><span class="line">$ sudo docker run -d -p 80 --name statix_web micheal/static_web nginx -g <span class="string">"daemon off;"</span></span><br></pre></td></tr></table></figure><blockquote><p>nginx -g “daemon off;”,这将以前台的方式启动Nginx。</p><p><code>-p</code>标志用来控制Docker在运行时应该公开那些网络端口给外部（宿主机）。运行一个容器时，Docker可以通过两种方式来在宿主机上分配端口。</p><ul><li>Docker可以在宿主机上随机选择一个位于32768 ~ 61000的一个比较大的端口号来映射到容器中的80端口上。</li><li>可以在Docker宿主机只指定一个具体的端口号来映射到容器中的80端口上。</li></ul></blockquote><p><strong>查看Docker端口映射情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回宿主机中映射的端口</span></span><br><span class="line">$ sudo socker port static_web 80 </span><br><span class="line"></span><br><span class="line"><span class="comment"># -p会将容器内的80端口绑定到宿主机的8080端口上</span></span><br><span class="line">$ sudo docker run -d -p 8080:80 --name statix_web micheal/static_web nginx -g <span class="string">"daemon off;"</span></span><br></pre></td></tr></table></figure><p><strong>Dockerfile指令</strong></p><ol><li>CMD</li></ol><blockquote><p>CMD指令用于指定一个容器启动时要运行的命令。这有点儿类似于RUN指令，只是RUN指令是指定容器镜像被构建时要运行的命令，而CMD是指定容器被启动时要运行的命令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash/"</span>, <span class="string">"-l"</span>]</span><br></pre></td></tr></table></figure><ol><li>ENTRYPOINT</li></ol><blockquote><p>ENTRYPOINT和CMD指令非常类似，我们可在docker run命令行中覆盖CMD指令，而ENTRYPOINT指令提供的命令则不容易在启动容器的时候被覆盖。</p><p>可以组合使用ENTRYPOINT和CMD指令来完成一些巧妙的工作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">"/usr/sbin/nginx"</span>]</span><br><span class="line">CMD [<span class="string">"-h"</span>]</span><br></pre></td></tr></table></figure><ol><li>WORKDIR</li></ol><blockquote><p>WORKDIR指令用来在从镜像创建一个新容器时，在容器内部设置一个工作目录，ENTRYPOINT和/或CMD指定的程序会在这个目录下执行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /opt/webapp/db</span><br><span class="line">RUN bundle install</span><br><span class="line">WORKDIR /opt/webapp</span><br><span class="line">ENTRYPOINT [<span class="string">"rackup"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>-w</code>标志在运行时覆盖工作目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -ti -w /var/<span class="built_in">log</span> ubuntu <span class="built_in">pwd</span>/var/<span class="built_in">log</span></span><br></pre></td></tr></table></figure><ol><li>ENV</li></ol><blockquote><p>ENV指令用来在镜像构建过程中设置环境变量。这些变量会持久保存到从我们镜像创建的任何容器中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV RVM_PATH /home/rvm</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用docker run命令行的<code>-e</code>标志来传递环境变量。这些环境变量只会在运行时有效。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -ti -e <span class="string">"WEB_PORT=8080"</span> ubuntu env</span><br></pre></td></tr></table></figure><ol><li>USER</li></ol><blockquote><p>USER指令用来指定该镜像会以什么样的用户身份来运行。我们可以指定用户名或者UID以及组或GID，甚至是两者的组合。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure><blockquote><p>也可以在docker run命令行中通过<code>-u</code>标志覆盖该指令指定的值。</p></blockquote><ol><li>VOLUME</li></ol><blockquote><p>VOLUME指令用来向基于镜像创建的容器添加卷。一个卷可以存在于一个或者多个容器内特定的目录，这个目录可以绕过联合文件系统，并提供如下共享数据或者对数据进行持久化的功能。</p><ul><li>卷可以在容器间共享和重用</li><li>一个容器可以不是必须和其他容器共享卷</li><li>对卷的修改是立即生效的</li><li>对卷的修改不会对更新镜像产生影响</li><li>卷会一直存在直到没有任何容器再使用它</li></ul><p>卷功能让我们可以将数据（如源代码）、数据库或者其他内容添加到镜像中而不是将这些内容提交到镜像中，并且允许我们在多个容器间共享这些内容，我们可以利用此功能来测试容器和内部应用程序代码，管理日志，或者处理容器内部的数据库。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/opt/project"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>这条指令将会基于此镜像的任何容器创建一个名为/opt/project的挂载点。</p><p>也可以通过指定数组的方式指定多个卷</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/opt/project"</span>, <span class="string">"/data"</span>]</span><br></pre></td></tr></table></figure><ol><li>ADD</li></ol><blockquote><p>ADD指令用来将构建环境下的文件和目录复制到镜像中。不能对构建目录或者上下文之外的文件进行ADD操作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD software.lic /opt/application/software.lic</span><br><span class="line">ADD latest.tar.gz /var/www/wordpress/   //这条指令会将归档文件解开到指定的目录下</span><br></pre></td></tr></table></figure><ol><li>COPY</li></ol><blockquote><p>COPY指令非常类似ADD，它们根本不同是COPY只关心构建上下文中复制本地文件，而不会去做文件提取（extraction）和解压（decompression）的工作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY conf.d/ /etc/apache2/</span><br></pre></td></tr></table></figure><ol><li>LABEL</li></ol><blockquote><p>LABEL指令用于为Docker镜像添加元数据。元数据以键值对的形式展现</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=<span class="string">"1.0"</span></span><br><span class="line">LABEL location=<span class="string">"New York"</span> <span class="built_in">type</span>=<span class="string">"Data Center"</span> role=<span class="string">"Web Server"</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用docker inspect命令查看容器标签</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect micheal/apache2</span><br></pre></td></tr></table></figure><ol><li>STOPSIGNAL</li></ol><blockquote><p>STOPSIGNAL指令用来设置停止容器时发送什么系统调用信号给容器。</p></blockquote><ol><li>ARG</li></ol><blockquote><p>ARG指令用来定义可以在docker build命令运行时传递给构建运行时的变量，我们只需要在构建时使用–build-arg标志即可。用户只能在构建时指定在Dockerfile文件汇总定义过的参数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG build</span><br><span class="line">ARG webapp_user=user</span><br><span class="line"></span><br><span class="line">$ docker build --build-arg build=1234 -t micheal/webapp .</span><br></pre></td></tr></table></figure><ol><li>ONBUILD</li></ol><blockquote><p>ONBUILD指令能为镜像添加触发器（trigger）。当一个镜像被用做其他镜像的基础镜像时（比如用户的镜像需要从某未准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本），该镜像中的触发器将会被执行。</p><p>触发器会在构建过程中插入新指令，我们可以认为这些指令是紧跟在FROM之后指定的。触发器可以是任何构建指令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN <span class="built_in">cd</span> /app/src/ &amp;&amp; make</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码将会在创建的镜像中加入ONBUILD触发器，ONBUILD指令可以在镜像上运行docker inspect命令查看。</p></blockquote><p><strong>Docker Networking</strong></p><blockquote><p>容器之间的连接用网络创建，这被称为Docker Networking。Docker Networking允许用户创建自己的网络，容器可以通过这个网上互相通信。更重要的是，现在容器可以跨越不同的宿主机来通信，并且网络配置可以更灵活的定制。Docker Networking也和Docker Compose以及Swarm进行了集成。</p><p>要想使用Docker网络，需要先创建一个网络，然后在这个网络下启动容器。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network create app</span><br></pre></td></tr></table></figure><blockquote><p>这里使用docker network命令创建了一个桥接网络，命名为app。可以使用docker network inspect命令查看新创建的这个网络。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect app</span><br></pre></td></tr></table></figure><blockquote><p>我们可以看到这个新网络是一个本地的桥接网络（这非常像docker0网络），而且现在没有容器再这个网络中运行。</p><p>可以使用<code>docker network ls</code>命令列出当前系统中所有的网络。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network ls</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用 <code>docker network rm</code>命令删除一个Docker网络。</p><p>在Docker网络中创建Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --net=app --name db micheal/redis</span><br></pre></td></tr></table></figure><blockquote><p><code>--net</code>标志指定了新容器将会在那个网络中运行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect app</span><br></pre></td></tr></table></figure><blockquote><p>将已有容器连接到Docker网络</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network connect app db2</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>docker network disconnect</code> 命令断开一个容器与指定网络的连接</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network disconnect app db2</span><br></pre></td></tr></table></figure><p><strong>通过Docker链接连接容器</strong></p><blockquote><p>启动一个Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name redis micheal/redis</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里没有公开容器的任何端口。一会就能看到这么做的原因。</p></blockquote><blockquote><p>链接Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -p 4567 --name webapp --link redis:db -t -i -v <span class="variable">$PWD</span>/webapp_redis:/opt/webapp micheal/sinatra /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>这个命令做了不少事情，我们逐一解释。首先，我们使用<code>-p</code>标志公开4567端口，这样就能从外面访问web应用程序。</p><p>我们还使用<code>--name</code>标志给容器命名为webapp，并且使用了<code>-v</code>标志把web应用程序目录作为卷挂载到了容器里。</p><p>然而，这次我们使用了一个新标志<code>--link</code>。<code>--link</code>标志创建了两个容器间的客户-服务链接。这个标志需要两个参数：一个是要链接的容器的名字，另一个是链接的别名。这个例子中我们创建了客户联系，webapp容器是客户，redis容器是“服务”，并且为这个服务增加了db作为别名。这个别名让我们可以一致地访问容器公开信息，而无须关注底层容器的名字。链接让服务容器有能力与客户容器通信，并且能分享一些连接细节，这些细节有助于在应用程序中配置并使用这个链接。</p></blockquote><blockquote><p>连接也能得到一些安全上的好处。注意，启动 Redis 容器时，并没有使用<code>-p</code>标志公开Redis的端口。因为不需要这么做。通过把容器链接在一起，可以让客户直接访问任意服务容器的公开端口（即客户webapp容器可以连接到服务redis容器的6379端口）。更妙的是，只有使用<code>--link</code>标志链接到这个容器的容器才能连接到这个端口。容器的端口不需要对本地宿主机公开，现在我们已经拥有一个非常安全的模型。通过这个安全模型，就可以限制容器化应用程序被攻击面，减少应用暴露的网络。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker基本命令&quot;&gt;&lt;a href=&quot;#Docker基本命令&quot; class=&quot;headerlink&quot; title=&quot;Docker基本命令&quot;&gt;&lt;/a&gt;Docker基本命令&lt;/h1&gt;&lt;h3 id=&quot;常用Docker命令&quot;&gt;&lt;a href=&quot;#常用Docker命令&quot; class=&quot;headerlink&quot; title=&quot;常用Docker命令&quot;&gt;&lt;/a&gt;常用Docker命令&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://miaopei.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://miaopei.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>CPlusPlus 设计模式</title>
    <link href="http://miaopei.github.io/2016/06/28/Program-C/cplus-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://miaopei.github.io/2016/06/28/Program-C/cplus-设计模式/</id>
    <published>2016-06-28T02:14:50.000Z</published>
    <updated>2019-06-11T08:14:19.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p>定义一个单例类：</p><ol><li>私有化它的构造函数，以防止外界创建单例类的对象；</li><li>使用类的私有静态指针变量指向类的唯一实例；</li><li>使用一个公有的静态方法获取该实例。</li></ol></blockquote><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><blockquote><p>即第一次调用该类实例的时候才产生一个新的该类实例，并在以后仅返回此实例。</p><p>需要用锁，来保证其线程安全性：原因：多个线程可能进入判断是否已经存在实例的 if 语句，从而non thread safety.</p><p>使用double-check来保证thread safety.但是如果处理大量数据时，该锁才成为严重的性能瓶颈。</p></blockquote><details><summary>1. 静态成员实例的懒汉模式：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)</span><br><span class="line">    &#123;</span><br><span class="line">        Lock();<span class="comment">//借用其它类来实现，如boost</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        UnLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>2. 内部静态实例的懒汉模式：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonInside</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SingletonInside* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Lock(); <span class="comment">// not needed after C++0x</span></span><br><span class="line">        <span class="keyword">static</span> SingletonInside instance;</span><br><span class="line">        UnLock(); <span class="comment">// not needed after C++0x</span></span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SingletonInside()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><blockquote><p>即无论是否调用该类的实例，在程序开始时就会产生一个该类的实例，并在以后仅返回此实例。</p><p>由静态初始化实例保证其线程安全性，WHY？因为静态实例初始化在程序开始时<strong>进入主函数之前就由主线程以单线程方式完成了初始化</strong>，不必担心多线程问题。</p><p>故在性能需求较高时，应使用这种模式，避免频繁的锁争夺。</p></blockquote><details><summary>饿汉模式：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonStatic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> SingletonStatic* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SingletonStatic* m_instance;</span><br><span class="line">    SingletonStatic()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部初始化 before invoke main</span></span><br><span class="line"><span class="keyword">const</span> SingletonStatic* SingletonStatic::m_instance = <span class="keyword">new</span> SingletonStatic;</span><br></pre></td></tr></table></figure></details><p><strong>m_pInstance 指向的空间什么时候释放呢？更严重的问题是，该实例的析构函数什么时候执行？</strong></p><details><summary>单例模式 - 线程安全</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Singleton() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton ctor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singleton() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton dtor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Garbo</span></span></span><br><span class="line"><span class="class">    &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        ~Garbo()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::m_pInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Garbo dtor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> Garbo garbo; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Singleton::Garbo Singleton::garbo;  <span class="comment">// 一定要初始化，不然程序结束时不会析构garbo</span></span><br><span class="line">Singleton *Singleton::m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">Singleton *Singleton::GetInstance()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (m_pInstance == <span class="literal">NULL</span>) </span><br><span class="line">        m_pInstance = <span class="keyword">new</span> Singleton;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *p1 = Singleton::GetInstance();</span><br><span class="line">    Singleton *p2 = Singleton::GetInstance();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 == p2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出结果如下：</span></span><br><span class="line">Singleton ctor</span><br><span class="line">p1 == p2</span><br><span class="line">Garbo dtor</span><br><span class="line">Singleton dtor</span><br></pre></td></tr></table></figure></details><p>类 CGarbo 被定义为 CSingleton 的私有内嵌类，以防该类被在其他地方滥用。</p><p>程序运行结束时，系统会调用 CSingleton的 静态成员 Garbo 的析构函数，该析构函数会删除单例的唯一实例。</p><p>使用这种方法释放单例对象有以下特征：</p><ul><li><p>在单例类内部定义专有的嵌套类；</p></li><li><p>在单例类内定义私有的专门用于释放的静态成员；</p></li><li><p>利用程序在结束时析构全局变量的特性，选择最终的释放时机；</p></li><li><p>使用单例的代码不需要任何操作，不必关心对象的释放。</p></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuZmF0ZWRpZXIuY29tLzIwMTUvMDMvMDQvZGVjb3VwbGluZy1ieS11c2luZy1yZWZsZWN0LWFuZC1zaW1wbGUtZmFjdG9yeS1wYXR0ZXJuLWluLWNwcC8=" title="http://blog.fatedier.com/2015/03/04/decoupling-by-using-reflect-and-simple-factory-pattern-in-cpp/">在C++中利用反射和简单工厂模式实现业务模块解耦<i class="fa fa-external-link"></i></span></p></blockquote><p>用一个单独的类来做创造实例的过程，就是工厂。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><details><summary>简单工厂模式基本代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProduct() &#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> :</span> <span class="keyword">public</span> AbstractProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> :</span> <span class="keyword">public</span> AbstractProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProduct* <span class="title">createProduct</span><span class="params">(<span class="keyword">char</span> product)</span> </span>&#123;</span><br><span class="line">        AbstractProduct* ap = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">switch</span>(product) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>: ap = <span class="keyword">new</span> ProductA(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'B'</span>: ap = <span class="keyword">new</span> ProductB(); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Factory* f = <span class="keyword">new</span> Factory();</span><br><span class="line">    AbstractProduct* apa = f-&gt;createProduct(<span class="string">'A'</span>);</span><br><span class="line">    apa-&gt;Operation();  <span class="comment">// ProductA</span></span><br><span class="line"></span><br><span class="line">    AbstractProduct* apb = f-&gt;createProduct(<span class="string">'B'</span>);</span><br><span class="line">    apb-&gt;Operation();  <span class="comment">// ProductB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> apa;</span><br><span class="line">    <span class="keyword">delete</span> apb;</span><br><span class="line">    <span class="keyword">delete</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><img src="/images/imageProgramC/%E7%AE%80%E5%8D%95%E8%BF%90%E7%AE%97%E5%B7%A5%E5%8E%82.png" alt="简单运算工厂"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation <span class="title">createOperate</span><span class="params">(<span class="built_in">string</span> operate)</span> </span>&#123;</span><br><span class="line">        Operation oper = null;</span><br><span class="line">        <span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"+"</span>: oper = <span class="keyword">new</span> OperationAdd(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"-"</span>: oper = <span class="keyword">new</span> OperationSub(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"*"</span>: oper = <span class="keyword">new</span> OperationMul(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"/"</span>: oper = <span class="keyword">new</span> OperationDiv(); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。</p></blockquote><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。</p><p><img src="/images/imageProgramC/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="工厂方法模式结构图"></p><details><summary>工厂方法模式基本代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Product()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteProductA"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteProductB"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">FactoryMethod</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Creator()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreatorA</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreatorB</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Creator* ca = <span class="keyword">new</span> ConcreteCreatorA();</span><br><span class="line">    Product* pa = ca-&gt;FactoryMethod();</span><br><span class="line">    pa-&gt;Operation(); <span class="comment">// ConcreteProductA</span></span><br><span class="line"></span><br><span class="line">    Creator* cb = <span class="keyword">new</span> ConcreteCreatorB();</span><br><span class="line">    Product* pb = cb-&gt;FactoryMethod();</span><br><span class="line">    pb-&gt;Operation(); <span class="comment">// ConcreteProductB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ca;</span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line">    <span class="keyword">delete</span> cb;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>把简单工厂模式中的工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，就变成了一个工厂抽象接口和多个具体生成对象的工厂。</p><p><img src="/images/imageProgramC/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE-01.png" alt="工厂方法模式结构图"></p><p>这样整个工厂和产品体系就没有修改，而只是扩展，符合开放 - 封闭原则。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><img src="/images/imageProgramC/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="抽象工厂模式结构图"></p><details><summary>抽象工厂模式基本代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProductA()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> :</span> <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> :</span> <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProductB()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> :</span> <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> :</span> <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductA* <span class="title">CreateProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductB* <span class="title">CreateProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractFactory()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA1* <span class="title">CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB1* <span class="title">CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA2* <span class="title">CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB2* <span class="title">CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractFactory* af1 = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">    <span class="comment">// 具体工厂创建对应的具体产品</span></span><br><span class="line">    AbstractProductA* apa1 = af1-&gt;CreateProductA();  <span class="comment">// 工厂1创建产品A</span></span><br><span class="line">    apa1-&gt;Operation();  <span class="comment">// ProductA1</span></span><br><span class="line"></span><br><span class="line">    AbstractProductB* apb1 = af1-&gt;CreateProductB();  <span class="comment">// 工厂1创建产品B</span></span><br><span class="line">    apb1-&gt;Operation();  <span class="comment">// ProductB1</span></span><br><span class="line"></span><br><span class="line">    AbstractFactory* af2 = <span class="keyword">new</span> ConcreteFactory2();</span><br><span class="line">    AbstractProductA* apa2 = af2-&gt;CreateProductA();  <span class="comment">// 工厂2创建产品A</span></span><br><span class="line">    apa2-&gt;Operation();  <span class="comment">// ProductA2</span></span><br><span class="line"></span><br><span class="line">    AbstractProductB* apb2 = af2-&gt;CreateProductB();  <span class="comment">// 工厂2创建产品B</span></span><br><span class="line">    apb2-&gt;Operation();  <span class="comment">// ProductB2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> apa1;</span><br><span class="line">    <span class="keyword">delete</span> apa2;</span><br><span class="line">    <span class="keyword">delete</span> af1;</span><br><span class="line">    <span class="keyword">delete</span> apb1;</span><br><span class="line">    <span class="keyword">delete</span> apb2;</span><br><span class="line">    <span class="keyword">delete</span> af2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>抽象工厂函数的优缺点</strong></p><p>优点：</p><ul><li>易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这样就使得改变一个应用的具体工厂变得非常容易，只需要改变具体工厂即可使用不同的产品配置。</li><li>让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂实现分离，不会出现在客户代码中。</li></ul><p>缺点：增加新的产品时需要改动多处代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是
      
    
    </summary>
    
      <category term="Program-C" scheme="http://miaopei.github.io/categories/Program-C/"/>
    
    
      <category term="Program-C" scheme="http://miaopei.github.io/tags/Program-C/"/>
    
  </entry>
  
  <entry>
    <title>Interview STL</title>
    <link href="http://miaopei.github.io/2016/06/18/Program-C/STL/"/>
    <id>http://miaopei.github.io/2016/06/18/Program-C/STL/</id>
    <published>2016-06-18T02:14:50.000Z</published>
    <updated>2019-06-10T09:09:07.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9ub3RlL2Jsb2IvbWFzdGVyL1NUTC5tZA==" title="https://github.com/huihut/note/blob/master/STL.md">github . huihut/note/STL.md<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdGwv" title="http://www.cplusplus.com/reference/stl/">cplusplus . stl<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLmNwcHJlZmVyZW5jZS5jb20vdy8lRTklQTYlOTYlRTklQTElQjU=" title="http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference . C++ 参考手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sdW1uL2RldGFpbHMvZ2Vlay1zdGwuaHRtbA==" title="http://blog.csdn.net/column/details/geek-stl.html">CSDN专栏：STL学习笔记<i class="fa fa-external-link"></i></span></li></ul><a id="more"></a><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li>容器（containers）</li><li>算法（algorithms）</li><li>迭代器（iterators）</li><li>仿函数（functors）</li><li>配接器（adapters）</li><li>空间配置器（allocator）</li></ul><h2 id="容器（containers）"><a href="#容器（containers）" class="headerlink" title="容器（containers）"></a>容器（containers）</h2><ul><li>序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted）</li><li>关联式容器（associattive containers）</li></ul><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>array是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。</p><p>在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。</p><p>与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。</p><p>零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。</p><p>与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。</p><p>数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">size_t</span> <span class="title">N</span> &gt; <span class="title">class</span> <span class="title">array</span>;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160405225541788" alt></p><h4 id="array-begin"><a href="#array-begin" class="headerlink" title="array::begin"></a>array::begin</h4><p>返回指向数组容器中第一个元素的迭代器。</p><p><img src="https://i.stack.imgur.com/oa3EQ.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; myarray = &#123;<span class="number">2</span>, <span class="number">16</span>, <span class="number">77</span>,<span class="number">34</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myarray.begin(); it != myarray.end(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 2 16 77 34 50</span><br></pre></td></tr></table></figure><h4 id="array-end"><a href="#array-end" class="headerlink" title="array::end"></a>array::end</h4><p>返回指向数组容器中最后一个元素之后的理论元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123; <span class="number">5</span>, <span class="number">19</span>, <span class="number">77</span>, <span class="number">34</span>, <span class="number">99</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> it = myarray.begin(); it != myarray.end(); ++it )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 5 19 77 34 99</span><br></pre></td></tr></table></figure><h4 id="array-rbegin"><a href="#array-rbegin" class="headerlink" title="array::rbegin"></a>array::rbegin</h4><p>返回指向数组容器中最后一个元素的反向迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      reverse_iterator rbegin（）<span class="keyword">noexcept</span>;</span><br><span class="line">const_reverse_iterator rbegin（）<span class="keyword">const</span> <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,4&gt; myarray = &#123;<span class="number">4</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">14</span>&#125; ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 14 80 26 4</span><br></pre></td></tr></table></figure><h4 id="array-rend"><a href="#array-rend" class="headerlink" title="array::rend"></a>array::rend</h4><p>返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,4&gt; myarray = &#123;<span class="number">4</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">14</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 14 80 26 4</span><br></pre></td></tr></table></figure><h4 id="array-cbegin"><a href="#array-cbegin" class="headerlink" title="array::cbegin"></a>array::cbegin</h4><p>返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const_iterator cbegin（）<span class="keyword">const</span> <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123;<span class="number">2</span>, <span class="number">16</span>, <span class="number">77</span>, <span class="number">34</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> it = myarray.cbegin(); it != myarray.cend(); ++it )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;   <span class="comment">// cannot modify *it</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 2 16 77 34 50</span><br></pre></td></tr></table></figure><h4 id="array-cend"><a href="#array-cend" class="headerlink" title="array::cend"></a>array::cend</h4><p>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123; <span class="number">15</span>, <span class="number">720</span>, <span class="number">801</span>, <span class="number">1002</span>, <span class="number">3502</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> it = myarray.cbegin(); it != myarray.cend(); ++it )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;   <span class="comment">// cannot modify *it</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 2 16 77 34 50</span><br></pre></td></tr></table></figure><h4 id="array-crbegin"><a href="#array-crbegin" class="headerlink" title="array::crbegin"></a>array::crbegin</h4><p>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const_reverse_iterator crbegin（）<span class="keyword">const</span> <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,6&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125; ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray backwards:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;   <span class="comment">// cannot modify *rit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray backwards: 60 50 40 30 20 10</span><br></pre></td></tr></table></figure><h4 id="array-crend"><a href="#array-crend" class="headerlink" title="array::crend"></a>array::crend</h4><p>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_reverse_iterator <span class="title">crend</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,6&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125; ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray backwards:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;   <span class="comment">// cannot modify *rit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray backwards: 60 50 40 30 20 10</span><br></pre></td></tr></table></figure><h4 id="array-size"><a href="#array-size" class="headerlink" title="array::size"></a>array::size</h4><p>返回数组容器中元素的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> size_type size（）<span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myints;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of myints:"</span> &lt;&lt; myints.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(myints):"</span> &lt;&lt; <span class="keyword">sizeof</span>(myints) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size of myints: 5</span><br><span class="line">sizeof(myints): 20</span><br></pre></td></tr></table></figure><h4 id="array-max-size"><a href="#array-max-size" class="headerlink" title="array::max_size"></a>array::max_size</h4><p>返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myints;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of myints: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size of myints: "</span> &lt;&lt; myints.max_size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size of myints: 10</span><br><span class="line">max_size of myints: 10</span><br></pre></td></tr></table></figure><h4 id="array-empty"><a href="#array-empty" class="headerlink" title="array::empty"></a>array::empty</h4><p>返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,0&gt; first;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; second;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first "</span> &lt;&lt; (first.empty() ? <span class="string">"is empty"</span> : <span class="string">"is not empty"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second "</span> &lt;&lt; (second.empty() ? <span class="string">"is empty"</span> : <span class="string">"is not empty"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first is empty</span><br><span class="line">second is not empt</span><br></pre></td></tr></table></figure><h4 id="array-operator"><a href="#array-operator" class="headerlink" title="array::operator[]"></a>array::operator[]</h4><p>返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      reference <span class="keyword">operator</span>[] (size_type n);</span><br><span class="line">const_reference <span class="keyword">operator</span>[] (size_type n) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myarray;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign some values:</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        myarray[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print content</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myarray[i];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h4 id="array-at"><a href="#array-at" class="headerlink" title="array::at"></a>array::at</h4><p>返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reference <span class="title">at</span> <span class="params">( size_type n )</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">at</span> <span class="params">( size_type n )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myarray;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign some values:</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        myarray[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print content</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myarray[i];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h4 id="array-front"><a href="#array-front" class="headerlink" title="array::front"></a>array::front</h4><p>返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。<br>在空容器上调用此函数会导致未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reference <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">2</span>, <span class="number">16</span>, <span class="number">77</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"front is: "</span> &lt;&lt; myarray.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"back is: "</span> &lt;&lt; myarray.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 77</span></span><br><span class="line"></span><br><span class="line">  myarray.front() = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray now contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x : myarray ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">front is: 2</span><br><span class="line">back is: 77</span><br><span class="line">myarray now contains: 100 16 77</span><br></pre></td></tr></table></figure><h4 id="array-back"><a href="#array-back" class="headerlink" title="array::back"></a>array::back</h4><p>返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。<br>在空容器上调用此函数会导致未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reference <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">5</span>, <span class="number">19</span>, <span class="number">77</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"front is: "</span> &lt;&lt; myarray.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"back is: "</span> &lt;&lt; myarray.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 77</span></span><br><span class="line"></span><br><span class="line">  myarray.back() = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray now contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x : myarray ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">front is: 5</span><br><span class="line">back is: 77</span><br><span class="line">myarray now contains: 5 19 50</span><br></pre></td></tr></table></figure><h4 id="array-data"><a href="#array-data" class="headerlink" title="array::data"></a>array::data</h4><p>返回指向数组对象中第一个元素的指针。</p><p>由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">value_type* <span class="title">data</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> value_type* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="string">"Test string"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">char</span>,12&gt; charray;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span> (charray.data(),cstr,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; charray.data() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test string</span><br></pre></td></tr></table></figure><h4 id="array-fill"><a href="#array-fill" class="headerlink" title="array::fill"></a>array::fill</h4><p>用val填充数组所有元素，将val设置为数组对象中所有元素的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,6&gt; myarray;</span><br><span class="line"></span><br><span class="line">  myarray.fill(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x : myarray) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 5 5 5 5 5 5</span><br></pre></td></tr></table></figure><h4 id="array-swap"><a href="#array-swap" class="headerlink" title="array::swap"></a>array::swap</h4><p>通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。</p><p>与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="built_in">array</span>&amp; x)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;())))</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; first = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; second = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">  first.swap (second);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x : first) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x : second) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first: 11 22 33 44 55</span><br><span class="line">second: 10 20 30 40 50</span><br></pre></td></tr></table></figure><h4 id="get（array）"><a href="#get（array）" class="headerlink" title="get（array）"></a>get（array）</h4><p>形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> I，<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt; <span class="title">T</span>＆<span class="title">get</span>（<span class="title">array</span> &lt;T，N&gt;＆<span class="title">arr</span>）<span class="title">noexcept</span>;</span> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> I，<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt; <span class="title">T</span> &amp;&amp; <span class="title">get</span>（<span class="title">array</span> &lt;T，N&gt; &amp;&amp; <span class="title">arr</span>）<span class="title">noexcept</span>;</span> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> I，<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt; <span class="title">const</span> <span class="title">T</span>＆<span class="title">get</span>（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">arr</span>）<span class="title">noexcept</span>;</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mytuple (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tuple_element&lt;<span class="number">0</span>,<span class="keyword">decltype</span>(myarray)&gt;::type myelement;  <span class="comment">// int myelement</span></span><br><span class="line"></span><br><span class="line">  myelement = <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(myarray);</span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(myarray) = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(myarray);</span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(myarray) = myelement;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element in myarray: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(myarray) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element in mytuple: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first element in myarray: 30</span><br><span class="line">first element in mytuple: 10</span><br></pre></td></tr></table></figure><h4 id="relational-operators-array"><a href="#relational-operators-array" class="headerlink" title="relational operators (array)"></a>relational operators (array)</h4><p>形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_T</span> <span class="title">N</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span> ==（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">lhs</span>，<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">rhs</span>）;</span></span><br><span class="line">（<span class="number">2</span>）</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_T</span> <span class="title">N</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span>！=（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">lhs</span>，<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">rhs</span>）;</span></span><br><span class="line">（<span class="number">3</span>）</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_T</span> <span class="title">N</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span> &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;</span></span><br><span class="line"><span class="class">（4）</span></span><br><span class="line"><span class="class">template &lt;class T，size_T N&gt; </span></span><br><span class="line"><span class="class">  bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;</span></span><br><span class="line"><span class="class">（5）</span></span><br><span class="line"><span class="class">template &lt;class T，size_T N&gt; </span></span><br><span class="line"><span class="class">  bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;</span></span><br><span class="line"><span class="class">（6）</span></span><br><span class="line"><span class="class">template &lt;class T，size_T N&gt; </span></span><br><span class="line"><span class="class">  bool operator&gt; =（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">lhs</span>，<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">rhs</span>）;</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; a = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; b = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; c = &#123;<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a==b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a and b are equal\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (b!=c) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b and c are not equal\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (b&lt;c) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b is less than c\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (c&gt;b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c is greater than b\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (a&lt;=b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a is less than or equal to b\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (a&gt;=b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a is greater than or equal to b\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a and b are equal</span><br><span class="line">b and c are not equal</span><br><span class="line">b is less than c</span><br><span class="line">c is greater than b</span><br><span class="line">a is less than or equal to b</span><br><span class="line">a is greater than or equal to b</span><br></pre></td></tr></table></figure><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector是表示可以改变大小的数组的序列容器。</p><p>就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。</p><p>在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。</p><p>相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。</p><p>因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。</p><p>与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。</p><p>针对 vector 的各种常见操作的复杂度（效率）如下： </p><ul><li>随机访问 - 常数 O(1) </li><li>在尾部增删元素 - 平摊（amortized）常数 O(1)}} </li><li>增删元素 - 至 vector 尾部的线性距离 O(n)}}</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt; &gt; <span class="title">class</span> <span class="title">vector</span>;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160406151211233" alt></p><h4 id="vector-vector"><a href="#vector-vector" class="headerlink" title="vector::vector"></a>vector::vector</h4><p>（1）empty容器构造函数（默认构造函数）<br>构造一个空的容器，没有元素。<br>（2）fill构造函数<br>用n个元素构造一个容器。每个元素都是val的副本（如果提供）。<br>（3）范围（range）构造器<br>使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。<br>（4）复制（copy）构造函数（并用分配器复制）<br>按照相同的顺序构造一个包含x中每个元素的副本的容器。<br>（5）移动（move）构造函数（和分配器移动）<br>构造一个获取x元素的容器。<br>如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。<br>x保持未指定但有效的状态。<br>（6）初始化列表构造函数<br>构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line">         <span class="built_in">vector</span> (size_type n, <span class="keyword">const</span> value_type&amp; val,</span><br><span class="line">                 <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type());</span><br><span class="line">range (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">vector</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">          <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br><span class="line">copy (<span class="number">4</span>)</span><br><span class="line"><span class="built_in">vector</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&amp; x);</span><br><span class="line"><span class="built_in">vector</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line">move (<span class="number">5</span>)</span><br><span class="line"><span class="built_in">vector</span> (<span class="built_in">vector</span>&amp;&amp; x);</span><br><span class="line"><span class="built_in">vector</span> (<span class="built_in">vector</span>&amp;&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">vector</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first;             <span class="comment">// empty vector of ints</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; second(<span class="number">4</span>, <span class="number">100</span>);    <span class="comment">// four ints with value 100</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; third(second.begin(), second.end());<span class="comment">// iterating through second</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fourth(third);     <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the iterator constructor can also be used to construct from arrays:</span></span><br><span class="line">    <span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fifth(myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of fifth are:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The contents of fifth are: 16 2 77 29</span><br></pre></td></tr></table></figure><h4 id="vector-vector-1"><a href="#vector-vector-1" class="headerlink" title="vector::~vector"></a>vector::~vector</h4><p>销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">vector</span>();</span><br></pre></td></tr></table></figure><h4 id="vector-operator"><a href="#vector-operator" class="headerlink" title="vector::operator="></a>vector::operator=</h4><p>将新内容分配给容器，替换其当前内容，并相应地修改其大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copy (<span class="number">1</span>)</span><br><span class="line"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> <span class="built_in">vector</span>&amp; x);</span><br><span class="line">move (<span class="number">2</span>)</span><br><span class="line"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span>= (<span class="built_in">vector</span>&amp;&amp; x);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span></span>= (<span class="built_in">initializer_list</span>&lt;value_type&gt; il);</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;int&gt; foo (3,0);</span><br><span class="line">  std::vector&lt;int&gt; bar (5,0);</span><br><span class="line"></span><br><span class="line">  bar = foo;</span><br><span class="line">  foo = std::vector&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Size of foo: 0</span><br><span class="line">Size of bar: 3</span><br></pre></td></tr></table></figure><h4 id="vector-begin"><a href="#vector-begin" class="headerlink" title="vector::begin"></a>vector::begin</h4><h4 id="vector-end"><a href="#vector-end" class="headerlink" title="vector::end"></a>vector::end</h4><h4 id="vector-rbegin"><a href="#vector-rbegin" class="headerlink" title="vector::rbegin"></a>vector::rbegin</h4><h4 id="vector-rend"><a href="#vector-rend" class="headerlink" title="vector::rend"></a>vector::rend</h4><h4 id="vector-cbegin"><a href="#vector-cbegin" class="headerlink" title="vector::cbegin"></a>vector::cbegin</h4><h4 id="vector-cend"><a href="#vector-cend" class="headerlink" title="vector::cend"></a>vector::cend</h4><h4 id="vector-rcbegin"><a href="#vector-rcbegin" class="headerlink" title="vector::rcbegin"></a>vector::rcbegin</h4><h4 id="vector-rcend"><a href="#vector-rcend" class="headerlink" title="vector::rcend"></a>vector::rcend</h4><h4 id="vector-size"><a href="#vector-size" class="headerlink" title="vector::size"></a>vector::size</h4><p>返回vector中元素的数量。</p><p>这是vector中保存的实际对象的数量，不一定等于其存储容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myints;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"0. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) myints.push_back(i);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myints.insert (myints.end(),<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myints.pop_back();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0. size: 0</span><br><span class="line">1. size: 10</span><br><span class="line">2. size: 20</span><br><span class="line">3. size: 19</span><br></pre></td></tr></table></figure><h4 id="vector-max-size"><a href="#vector-max-size" class="headerlink" title="vector::max_size"></a>vector::max_size</h4><p>返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制，</p><p>这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some content in the vector:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; myvector.size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size: "</span> &lt;&lt; myvector.max_size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A possible output for this program could be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size: 100</span><br><span class="line">capacity: 128</span><br><span class="line">max_size: 1073741823</span><br></pre></td></tr></table></figure><h4 id="vector-resize"><a href="#vector-resize" class="headerlink" title="vector::resize"></a>vector::resize</h4><p>调整容器的大小，使其包含n个元素。</p><p>如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。</p><p>如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。</p><p>如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。</p><p>注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some initial content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  myvector.resize(<span class="number">5</span>);</span><br><span class="line">  myvector.resize(<span class="number">8</span>,<span class="number">100</span>);</span><br><span class="line">  myvector.resize(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;myvector.size();i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myvector[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0</span><br></pre></td></tr></table></figure><h4 id="vector-capacity"><a href="#vector-capacity" class="headerlink" title="vector::capacity"></a>vector::capacity</h4><p>返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some content in the vector:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; (<span class="keyword">int</span>) myvector.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; (<span class="keyword">int</span>) myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size: "</span> &lt;&lt; (<span class="keyword">int</span>) myvector.max_size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A possible output for this program could be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size: 100</span><br><span class="line">capacity: 128</span><br><span class="line">max_size: 1073741823</span><br></pre></td></tr></table></figure><h4 id="vector-empty"><a href="#vector-empty" class="headerlink" title="vector::empty"></a>vector::empty</h4><p>返回vector是否为空（即，它的size是否为0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!myvector.empty())</span><br><span class="line">  &#123;</span><br><span class="line">     sum += myvector.back();</span><br><span class="line">     myvector.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total: 55</span><br></pre></td></tr></table></figure><h4 id="vector-reserve"><a href="#vector-reserve" class="headerlink" title="vector::reserve"></a>vector::reserve</h4><p>请求vector容量至少足以包含n个元素。</p><p>如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。</p><p>在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。</p><p>这个函数对vector大小没有影响，也不能改变它的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span> <span class="params">(size_type n)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type sz;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo;</span><br><span class="line">  sz = foo.capacity();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"making foo grow:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">    foo.push_back(i);</span><br><span class="line">    <span class="keyword">if</span> (sz!=foo.capacity()) &#123;</span><br><span class="line">      sz = foo.capacity();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity changed: "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar;</span><br><span class="line">  sz = bar.capacity();</span><br><span class="line">  bar.reserve(<span class="number">100</span>);   <span class="comment">// this is the only difference with foo above</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"making bar grow:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">    bar.push_back(i);</span><br><span class="line">    <span class="keyword">if</span> (sz!=bar.capacity()) &#123;</span><br><span class="line">      sz = bar.capacity();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity changed: "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">making foo grow:</span><br><span class="line">capacity changed: 1</span><br><span class="line">capacity changed: 2</span><br><span class="line">capacity changed: 4</span><br><span class="line">capacity changed: 8</span><br><span class="line">capacity changed: 16</span><br><span class="line">capacity changed: 32</span><br><span class="line">capacity changed: 64</span><br><span class="line">capacity changed: 128</span><br><span class="line">making bar grow:</span><br><span class="line">capacity changed: 100</span><br></pre></td></tr></table></figure><h4 id="vector-shrink-to-fit"><a href="#vector-shrink-to-fit" class="headerlink" title="vector::shrink_to_fit"></a>vector::shrink_to_fit</h4><p>要求容器减小其capacity(容量)以适应其尺寸。</p><p>该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1. capacity of myvector: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myvector.resize(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2. capacity of myvector: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myvector.shrink_to_fit();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3. capacity of myvector: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. capacity of myvector: 100</span><br><span class="line">2. capacity of myvector: 100</span><br><span class="line">3. capacity of myvector: 10</span><br></pre></td></tr></table></figure><h4 id="vector-operator-1"><a href="#vector-operator-1" class="headerlink" title="vector::operator[]"></a>vector::operator[]</h4><h4 id="vector-at"><a href="#vector-at" class="headerlink" title="vector::at"></a>vector::at</h4><h4 id="vector-front"><a href="#vector-front" class="headerlink" title="vector::front"></a>vector::front</h4><h4 id="vector-back"><a href="#vector-back" class="headerlink" title="vector::back"></a>vector::back</h4><h4 id="vector-data"><a href="#vector-data" class="headerlink" title="vector::data"></a>vector::data</h4><h4 id="vector-assign"><a href="#vector-assign" class="headerlink" title="vector::assign"></a>vector::assign</h4><p>将新内容分配给vector，替换其当前内容，并相应地修改其大小。</p><p>在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。</p><p>在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。</p><p>在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。</p><p>所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">range (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">assign</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; second;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; third;</span><br><span class="line"></span><br><span class="line">  first.assign (<span class="number">7</span>,<span class="number">100</span>);             <span class="comment">// 7 ints with a value of 100</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  it=first.begin()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  second.assign (it,first.end()<span class="number">-1</span>); <span class="comment">// the 5 central values of first</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">1776</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  third.assign (myints,myints+<span class="number">3</span>);   <span class="comment">// assigning from array.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of first: "</span> &lt;&lt; <span class="keyword">int</span> (first.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of second: "</span> &lt;&lt; <span class="keyword">int</span> (second.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of third: "</span> &lt;&lt; <span class="keyword">int</span> (third.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Size of first: 7</span><br><span class="line">Size of second: 5</span><br><span class="line">Size of third: 3</span><br></pre></td></tr></table></figure><p>补充：vector::assign 与 vector::operator= 的区别：</p><ol><li>vector::assign 实现源码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(size_type __n, <span class="keyword">const</span> _Tp&amp; __val)</span> </span>&#123; _M_fill_assign(__n, __val); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;_Tp, _Alloc&gt;:</span>:_M_fill_assign(<span class="keyword">size_t</span> __n, <span class="keyword">const</span> value_type&amp; __val) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__n &gt; capacity()) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator());</span><br><span class="line">    __tmp.swap(*<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__n &gt; size()) &#123;</span><br><span class="line">    fill(begin(), end(), __val);</span><br><span class="line">    _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    erase(fill_n(begin(), __n, __val), end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>vector::operator= 实现源码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;_Tp,_Alloc&gt;&amp; </span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;_Tp,_Alloc&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;__x != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __xlen = __x.size();</span><br><span class="line">    <span class="keyword">if</span> (__xlen &gt; capacity()) &#123;</span><br><span class="line">      iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());</span><br><span class="line">      destroy(_M_start, _M_finish);</span><br><span class="line">      _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">      _M_start = __tmp;</span><br><span class="line">      _M_end_of_storage = _M_start + __xlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size() &gt;= __xlen) &#123;</span><br><span class="line">      iterator __i = copy(__x.begin(), __x.end(), begin());</span><br><span class="line">      destroy(__i, _M_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      copy(__x.begin(), __x.begin() + size(), _M_start);</span><br><span class="line">      uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    _M_finish = _M_start + __xlen;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-push-back"><a href="#vector-push-back" class="headerlink" title="vector::push_back"></a>vector::push_back</h4><p>在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。</p><p>这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="keyword">int</span> myint;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter some integers (enter 0 to end):\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; myint;</span><br><span class="line">    myvector.push_back (myint);</span><br><span class="line">  &#125; <span class="keyword">while</span> (myint);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector stores "</span> &lt;&lt; <span class="keyword">int</span>(myvector.size()) &lt;&lt; <span class="string">" numbers.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-pop-back"><a href="#vector-pop-back" class="headerlink" title="vector::pop_back"></a>vector::pop_back</h4><p>删除vector中的最后一个元素，有效地将容器size减少一个。</p><p>这破坏了被删除的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  myvector.push_back (<span class="number">100</span>);</span><br><span class="line">  myvector.push_back (<span class="number">200</span>);</span><br><span class="line">  myvector.push_back (<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!myvector.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    sum+=myvector.back();</span><br><span class="line">    myvector.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The elements of myvector add up to "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The elements of myvector add up to 600</span><br></pre></td></tr></table></figure><h4 id="vector-insert"><a href="#vector-insert" class="headerlink" title="vector::insert"></a>vector::insert</h4><p>通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。 </p><p>由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">single <span class="title">element</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line">range (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">insert</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br><span class="line">move (<span class="number">4</span>)</span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, value_type&amp;&amp; val)</span></span>;</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="built_in">initializer_list</span>&lt;value_type&gt; il)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  it = myvector.begin();</span><br><span class="line">  it = myvector.insert ( it , <span class="number">200</span> );</span><br><span class="line"></span><br><span class="line">  myvector.insert (it,<span class="number">2</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "it" no longer valid, get a new one:</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anothervector (<span class="number">2</span>,<span class="number">400</span>);</span><br><span class="line">  myvector.insert (it+<span class="number">2</span>,anothervector.begin(),anothervector.end());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myarray [] = &#123; <span class="number">501</span>,<span class="number">502</span>,<span class="number">503</span> &#125;;</span><br><span class="line">  myvector.insert (myvector.begin(), myarray, myarray+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (it=myvector.begin(); it&lt;myvector.end(); it++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 501 502 503 300 300 400 400 200 100 100 100</span><br></pre></td></tr></table></figure><p>补充：insert 迭代器野指针错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vi;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取vector第一个元素的迭代器</span></span><br><span class="line">vi = v.begin();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错</span></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">v.insert(vi, <span class="number">2</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正：应该把<code>vi = v.begin();</code>放到<code>v.push_back(10);</code>后面</p><h4 id="vector-erase"><a href="#vector-erase" class="headerlink" title="vector::erase"></a>vector::erase</h4><p>从vector中删除单个元素（position）或一系列元素（[first，last））。</p><p>这有效地减少了被去除的元素的数量，从而破坏了容器的大小。</p><p>由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some values (from 1 to 10)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// erase the 6th element</span></span><br><span class="line">  myvector.erase (myvector.begin()+<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// erase the first 3 elements:</span></span><br><span class="line">  myvector.erase (myvector.begin(),myvector.begin()+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;myvector.size(); ++i)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myvector[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 4 5 7 8 9 10</span><br></pre></td></tr></table></figure><h4 id="vector-swap"><a href="#vector-swap" class="headerlink" title="vector::swap"></a>vector::swap</h4><p>通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。</p><p>在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。</p><p>请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="built_in">vector</span>&amp; x)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"></span><br><span class="line">  foo.swap(bar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;foo.size(); i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; foo[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;bar.size(); i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; bar[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo contains: 200 200 200 200 200 </span><br><span class="line">bar contains: 100 100 100</span><br></pre></td></tr></table></figure><h4 id="vector-clear"><a href="#vector-clear" class="headerlink" title="vector::clear"></a>vector::clear</h4><p>从vector中删除所有的元素（被销毁），留下size为0的容器。</p><p>不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：<code>vector&lt;T&gt;().swap(x);   // clear x reallocating</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.begin(); it != v.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 size  = "</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 capacity  = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v1.clear();</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 size  = "</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 capacity  = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v1.push_back(<span class="number">11</span>);</span><br><span class="line">v1.push_back(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 size  = "</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 capacity  = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">50 50 50 50 50</span><br><span class="line">v1 size  = 5</span><br><span class="line">v1 capacity  = 5</span><br><span class="line"></span><br><span class="line">v1 size  = 0</span><br><span class="line">v1 capacity  = 5</span><br><span class="line">11 22</span><br><span class="line">v1 size  = 2</span><br><span class="line">v1 capacity  = 5</span><br></pre></td></tr></table></figure><h4 id="vector-emplace"><a href="#vector-emplace" class="headerlink" title="vector::emplace"></a>vector::emplace</h4><p>通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。</p><p>这有效地增加了一个容器的大小。</p><p>分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。</p><p>由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。</p><p>该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">emplace</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = myvector.emplace ( myvector.begin()+<span class="number">1</span>, <span class="number">100</span> );</span><br><span class="line">  myvector.emplace ( it, <span class="number">200</span> );</span><br><span class="line">  myvector.emplace ( myvector.end(), <span class="number">300</span> );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: myvector)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 10 200 100 20 30 300</span><br></pre></td></tr></table></figure><h4 id="vector-emplace-back"><a href="#vector-emplace-back" class="headerlink" title="vector::emplace_back"></a>vector::emplace_back</h4><p>在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。</p><p>这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。</p><p>该元素是通过调用allocator_traits :: construct来转换args来创建的。</p><p>与push_back相比，emplace_back可以避免额外的复制和移动操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_back</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">President</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> country;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line"> </span><br><span class="line">    President(<span class="built_in">std</span>::<span class="built_in">string</span> p_name, <span class="built_in">std</span>::<span class="built_in">string</span> p_country, <span class="keyword">int</span> p_year)</span><br><span class="line">        : name(<span class="built_in">std</span>::move(p_name)), country(<span class="built_in">std</span>::move(p_country)), year(p_year)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being constructed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President(President&amp;&amp; other)</span><br><span class="line">        : name(<span class="built_in">std</span>::move(other.name)), country(<span class="built_in">std</span>::move(other.country)), year(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being moved.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> President&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; elections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:\n"</span>;</span><br><span class="line">    elections.emplace_back(<span class="string">"Nelson Mandela"</span>, <span class="string">"South Africa"</span>, <span class="number">1994</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; reElections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\npush_back:\n"</span>;</span><br><span class="line">    reElections.push_back(President(<span class="string">"Franklin Delano Roosevelt"</span>, <span class="string">"the USA"</span>, <span class="number">1936</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nContents:\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: elections) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was elected president of "</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: reElections) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was re-elected president of "</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">I am being constructed.</span><br><span class="line"> </span><br><span class="line">push_back:</span><br><span class="line">I am being constructed.</span><br><span class="line">I am being moved.</span><br><span class="line"> </span><br><span class="line">Contents:</span><br><span class="line">Nelson Mandela was elected president of South Africa in 1994.</span><br><span class="line">Franklin Delano Roosevelt was re-elected president of the USA in 1936.</span><br></pre></td></tr></table></figure><h4 id="vector-get-allocator"><a href="#vector-get-allocator" class="headerlink" title="vector::get_allocator"></a>vector::get_allocator</h4><p>返回与vector关联的构造器对象的副本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="keyword">int</span> * p;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate an array with space for 5 elements using vector's allocator:</span></span><br><span class="line">  p = myvector.get_allocator().allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// construct values in-place on the array:</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) myvector.get_allocator().construct(&amp;p[i],i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The allocated array contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; p[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// destroy and deallocate:</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) myvector.get_allocator().destroy(&amp;p[i]);</span><br><span class="line">  myvector.get_allocator().deallocate(p,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The allocated array contains: 0 1 2 3 4</span><br></pre></td></tr></table></figure><h4 id="relational-operators-vector"><a href="#relational-operators-vector" class="headerlink" title="relational operators (vector)"></a>relational operators (vector)</h4><h4 id="swap-vector"><a href="#swap-vector" class="headerlink" title="swap (vector)"></a>swap (vector)</h4><h4 id="vector-1"><a href="#vector-1" class="headerlink" title="vector "></a>vector <bool></bool></h4><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。</p><p>特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。</p><p>因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。</p><p>两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。</p><p>对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。</p><p>deque上常见操作的复杂性（效率）如下： </p><ul><li>随机访问 - 常数O(1) </li><li>在结尾或开头插入或移除元素 - 摊销不变O(1) </li><li>插入或移除元素 - 线性O(n)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt; &gt; <span class="title">class</span> <span class="title">deque</span>;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="http://img.blog.csdn.net/20170727225856144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlg2Nzc1ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br><img src="https://images0.cnblogs.com/blog/559453/201401/092150340824.png" alt></p><h4 id="deque-deque"><a href="#deque-deque" class="headerlink" title="deque::deque"></a>deque::deque</h4><p>构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容：</p><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; first;                                <span class="comment">// empty deque of ints</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; second (<span class="number">4</span>,<span class="number">100</span>);                       <span class="comment">// four ints with value 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; third (second.begin(),second.end());  <span class="comment">// iterating through second</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; fourth (third);                       <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// the iterator constructor can be used to copy arrays:</span></span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; fifth (myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of fifth are:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The contents of fifth are: 16 2 77 29</span><br></pre></td></tr></table></figure><h4 id="deque-push-back"><a href="#deque-push-back" class="headerlink" title="deque::push_back"></a>deque::push_back</h4><p>在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。</p><p>这有效地增加了一个容器的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line">  <span class="keyword">int</span> myint;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter some integers (enter 0 to end):\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; myint;</span><br><span class="line">    mydeque.push_back (myint);</span><br><span class="line">  &#125; <span class="keyword">while</span> (myint);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque stores "</span> &lt;&lt; (<span class="keyword">int</span>) mydeque.size() &lt;&lt; <span class="string">" numbers.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-push-front"><a href="#deque-push-front" class="headerlink" title="deque::push_front"></a>deque::push_front</h4><p>在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。</p><p>这有效地增加了一个容器的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque (<span class="number">2</span>,<span class="number">100</span>);     <span class="comment">// two ints with a value of 100</span></span><br><span class="line">  mydeque.push_front (<span class="number">200</span>);</span><br><span class="line">  mydeque.push_front (<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">300 200 100 100</span><br></pre></td></tr></table></figure><h4 id="deque-pop-back"><a href="#deque-pop-back" class="headerlink" title="deque::pop_back"></a>deque::pop_back</h4><p>删除deque容器中的最后一个元素，有效地将容器大小减少一个。</p><p>这破坏了被删除的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  mydeque.push_back (<span class="number">10</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">20</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!mydeque.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    sum+=mydeque.back();</span><br><span class="line">    mydeque.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The elements of mydeque add up to "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The elements of mydeque add up to 60</span><br></pre></td></tr></table></figure><h4 id="deque-pop-front"><a href="#deque-pop-front" class="headerlink" title="deque::pop_front"></a>deque::pop_front</h4><p>删除deque容器中的第一个元素，有效地减小其大小。</p><p>这破坏了被删除的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">  mydeque.push_back (<span class="number">100</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">200</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Popping out the elements in mydeque:"</span>;</span><br><span class="line">  <span class="keyword">while</span> (!mydeque.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; mydeque.front();</span><br><span class="line">    mydeque.pop_front();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe final size of mydeque is "</span> &lt;&lt; <span class="keyword">int</span>(mydeque.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Popping out the elements in mydeque: 100 200 300</span><br><span class="line">The final size of mydeque is 0</span><br></pre></td></tr></table></figure><h4 id="deque-emplace-front"><a href="#deque-emplace-front" class="headerlink" title="deque::emplace_front"></a>deque::emplace_front</h4><p>在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。</p><p>这有效地增加了一个容器的大小。</p><p>该元素是通过调用allocator_traits::construct来转换args来创建的。</p><p>存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_front</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mydeque.emplace_front (<span class="number">111</span>);</span><br><span class="line">  mydeque.emplace_front (<span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: mydeque)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydeque contains: 222 111 10 20 30</span><br></pre></td></tr></table></figure><h4 id="deque-emplace-back"><a href="#deque-emplace-back" class="headerlink" title="deque::emplace_back"></a>deque::emplace_back</h4><p>在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。</p><p>这有效地增加了一个容器的大小。</p><p>该元素是通过调用allocator_traits::construct来转换args来创建的。</p><p>存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_back</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mydeque.emplace_back (<span class="number">100</span>);</span><br><span class="line">  mydeque.emplace_back (<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: mydeque)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydeque contains: 10 20 30 100 200</span><br></pre></td></tr></table></figure><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。</p><p>forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表</p><p>之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。</p><p>与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。</p><p>的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。</p><p>该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。</p><p><img src="http://img.blog.csdn.net/20160407212133266" alt></p><h4 id="forward-list-forward-list"><a href="#forward-list-forward-list" class="headerlink" title="forward_list::forward_list"></a>forward_list::forward_list</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line">range (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">forward_list</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br><span class="line">copy (<span class="number">4</span>)</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst);</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line">move (<span class="number">5</span>)</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst);</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">forward_list</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; first;                      <span class="comment">// default: empty</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; second (<span class="number">3</span>,<span class="number">77</span>);              <span class="comment">// fill: 3 seventy-sevens</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; third (second.begin(), second.end()); <span class="comment">// range initialization</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; fourth (third);            <span class="comment">// copy constructor</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; fifth (<span class="built_in">std</span>::move(fourth));  <span class="comment">// move ctor. (fourth wasted)</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; sixth = &#123;<span class="number">3</span>, <span class="number">52</span>, <span class="number">25</span>, <span class="number">90</span>&#125;;    <span class="comment">// initializer_list constructor</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first:"</span> ; <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: first)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second:"</span>; <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: second) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"third:"</span>;  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: third)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fourth:"</span>; <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: fourth) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fifth:"</span>;  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: fifth)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sixth:"</span>;  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: sixth)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">forward_list constructor examples:</span><br><span class="line">first:</span><br><span class="line">second: 77 77 77</span><br><span class="line">third: 77 77 77</span><br><span class="line">fourth:</span><br><span class="line">fifth: 77 77 77</span><br><span class="line">sixth: 3 52 25 90</span><br></pre></td></tr></table></figure><h4 id="forward-list-forward-list-1"><a href="#forward-list-forward-list-1" class="headerlink" title="forward_list::~forward_list"></a>forward_list::~forward_list</h4><h4 id="forward-list-before-begin"><a href="#forward-list-before-begin" class="headerlink" title="forward_list::before_begin"></a>forward_list::before_begin</h4><p>返回指向容器中第一个元素之前的位置的迭代器。</p><p>返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; mylist = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mylist.insert_after ( mylist.before_begin(), <span class="number">11</span> );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x: mylist ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist contains: 11 20 30 40 50</span><br></pre></td></tr></table></figure><h4 id="forward-list-cbefore-begin"><a href="#forward-list-cbefore-begin" class="headerlink" title="forward_list::cbefore_begin"></a>forward_list::cbefore_begin</h4><p>返回指向容器中第一个元素之前的位置的const_iterator。</p><p>一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。</p><p>返回的价值不得解除引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">cbefore_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; mylist = &#123;<span class="number">77</span>, <span class="number">2</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mylist.insert_after ( mylist.cbefore_begin(), <span class="number">19</span> );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x: mylist ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist contains: 19 77 2 16</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。</p><p>在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;</span><br></pre></td></tr></table></figure><p>在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // <span class="title">map</span>:</span>:key_type</span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                                       // <span class="title">map</span>:</span>:mapped_type</span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,                     // <span class="title">map</span>:</span>:key_compare</span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;pair&lt;const Key,T&gt; &gt;    // <span class="title">map</span>:</span>:allocator_type</span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure><h4 id="map-map"><a href="#map-map" class="headerlink" title="map::map"></a>map::map</h4><p>构造一个映射容器对象，根据所使用的构造器版本初始化其内容：</p><p>（1）空容器构造函数（默认构造函数）</p><p>构造一个空的容器，没有元素。</p><p>（2）范围构造函数</p><p>构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。</p><p>（3）复制构造函数（并用分配器复制）</p><p>使用x中的每个元素的副本构造一个容器。</p><p>（4）移动构造函数（并与分配器一起移动）</p><p>构造一个获取x元素的容器。<br>如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。<br>x保持未指定但有效的状态。</p><p>（5）初始化列表构造函数</p><p>用il中的每个元素的副本构造一个容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">empty (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">map</span> <span class="params">(<span class="keyword">const</span> key_compare&amp; comp = key_compare(),</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">map</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc)</span></span>;</span><br><span class="line">range (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">map</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">key_compare</span>&amp; <span class="title">comp</span> = <span class="title">key_compare</span>(),</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">allocator_type</span>&amp; = <span class="title">allocator_type</span>());</span></span><br><span class="line">copy (<span class="number">3</span>)</span><br><span class="line"><span class="built_in">map</span> (<span class="keyword">const</span> <span class="built_in">map</span>&amp; x);</span><br><span class="line"><span class="built_in">map</span> (<span class="keyword">const</span> <span class="built_in">map</span>&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line">move (<span class="number">4</span>)</span><br><span class="line"><span class="built_in">map</span> (<span class="built_in">map</span>&amp;&amp; x);</span><br><span class="line"><span class="built_in">map</span> (<span class="built_in">map</span>&amp;&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">map</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> key_compare&amp; comp = key_compare(),</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fncomp</span> <span class="params">(<span class="keyword">char</span> lhs, <span class="keyword">char</span> rhs)</span> </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classcomp</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>&amp; lhs, <span class="keyword">const</span> <span class="keyword">char</span>&amp; rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; first;</span><br><span class="line"></span><br><span class="line">  first[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">  first[<span class="string">'b'</span>]=<span class="number">30</span>;</span><br><span class="line">  first[<span class="string">'c'</span>]=<span class="number">50</span>;</span><br><span class="line">  first[<span class="string">'d'</span>]=<span class="number">70</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; second (first.begin(),first.end());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; third (second);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>,classcomp&gt; fourth;                 <span class="comment">// class as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span>(*fn_pt)(<span class="keyword">char</span>,<span class="keyword">char</span>) = fncomp;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>,<span class="keyword">bool</span>(*)(<span class="keyword">char</span>,<span class="keyword">char</span>)&gt; fifth (fn_pt); <span class="comment">// function pointer as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-begin"><a href="#map-begin" class="headerlink" title="map::begin"></a>map::begin</h4><p>返回引用map容器中第一个元素的迭代器。</p><p>由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。</p><p>如果容器是空的，则返回的迭代器值不应被解除引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'b'</span>] = <span class="number">100</span>;</span><br><span class="line">  mymap[<span class="string">'a'</span>] = <span class="number">200</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>] = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// show content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; 200</span><br><span class="line">b =&gt; 100</span><br><span class="line">c =&gt; 300</span><br></pre></td></tr></table></figure><h4 id="map-key-comp"><a href="#map-key-comp" class="headerlink" title="map::key_comp"></a>map::key_comp</h4><p>返回容器用于比较键的比较对象的副本。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::key_compare mycomp = mymap.key_comp();</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">100</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">200</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap contains:\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> highest = mymap.rbegin()-&gt;first;     <span class="comment">// key value of last element</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( mycomp((*it++).first, highest) );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mymap contains:</span><br><span class="line">a =&gt; 100</span><br><span class="line">b =&gt; 200</span><br><span class="line">c =&gt; 300</span><br></pre></td></tr></table></figure><h4 id="map-value-comp"><a href="#map-value-comp" class="headerlink" title="map::value_comp"></a>map::value_comp</h4><p>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'x'</span>]=<span class="number">1001</span>;</span><br><span class="line">  mymap[<span class="string">'y'</span>]=<span class="number">2002</span>;</span><br><span class="line">  mymap[<span class="string">'z'</span>]=<span class="number">3003</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap contains:\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; highest = *mymap.rbegin();          <span class="comment">// last element</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( mymap.value_comp()(*it++, highest) );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mymap contains:</span><br><span class="line">x =&gt; 1001</span><br><span class="line">y =&gt; 2002</span><br><span class="line">z =&gt; 3003</span><br></pre></td></tr></table></figure><h4 id="map-find"><a href="#map-find" class="headerlink" title="map::find"></a>map::find</h4><p>在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。</p><p>如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。 </p><p>另一个成员函数map::count可以用来检查一个特定的键是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">50</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">100</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">150</span>;</span><br><span class="line">  mymap[<span class="string">'d'</span>]=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  it = mymap.find(<span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != mymap.end())</span><br><span class="line">    mymap.erase (it);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// print content:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"elements in mymap:"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a =&gt; "</span> &lt;&lt; mymap.find(<span class="string">'a'</span>)-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c =&gt; "</span> &lt;&lt; mymap.find(<span class="string">'c'</span>)-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d =&gt; "</span> &lt;&lt; mymap.find(<span class="string">'d'</span>)-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elements in mymap:</span><br><span class="line">a =&gt; 50</span><br><span class="line">c =&gt; 150</span><br><span class="line">d =&gt; 200</span><br></pre></td></tr></table></figure><h4 id="map-count"><a href="#map-count" class="headerlink" title="map::count"></a>map::count</h4><p>在容器中搜索具有等于k的键的元素，并返回匹配的数量。</p><p>由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。</p><p>如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">  mymap [<span class="string">'a'</span>]=<span class="number">101</span>;</span><br><span class="line">  mymap [<span class="string">'c'</span>]=<span class="number">202</span>;</span><br><span class="line">  mymap [<span class="string">'f'</span>]=<span class="number">303</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (c=<span class="string">'a'</span>; c&lt;<span class="string">'h'</span>; c++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    <span class="keyword">if</span> (mymap.count(c)&gt;<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" is an element of mymap.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" is not an element of mymap.\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a is an element of mymap.</span><br><span class="line">b is not an element of mymap.</span><br><span class="line">c is an element of mymap.</span><br><span class="line">d is not an element of mymap.</span><br><span class="line">e is not an element of mymap.</span><br><span class="line">f is an element of mymap.</span><br><span class="line">g is not an element of mymap.</span><br></pre></td></tr></table></figure><h4 id="map-lower-bound"><a href="#map-lower-bound" class="headerlink" title="map::lower_bound"></a>map::lower_bound</h4><p>将迭代器返回到下限</p><p>返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。</p><p>该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。</p><p>如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。</p><p>一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">lower_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator itlow,itup;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">20</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">40</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">60</span>;</span><br><span class="line">  mymap[<span class="string">'d'</span>]=<span class="number">80</span>;</span><br><span class="line">  mymap[<span class="string">'e'</span>]=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  itlow=mymap.lower_bound (<span class="string">'b'</span>);  <span class="comment">// itlow points to b</span></span><br><span class="line">  itup=mymap.upper_bound (<span class="string">'d'</span>);   <span class="comment">// itup points to e (not d!)</span></span><br><span class="line"></span><br><span class="line">  mymap.erase(itlow,itup);        <span class="comment">// erases [itlow,itup)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// print content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; 20</span><br><span class="line">e =&gt; 100</span><br></pre></td></tr></table></figure><h4 id="map-upper-bound"><a href="#map-upper-bound" class="headerlink" title="map::upper_bound"></a>map::upper_bound</h4><p>将迭代器返回到上限</p><p>返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。</p><p>该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。</p><p>如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。</p><p>类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">upper_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator itlow,itup;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">20</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">40</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">60</span>;</span><br><span class="line">  mymap[<span class="string">'d'</span>]=<span class="number">80</span>;</span><br><span class="line">  mymap[<span class="string">'e'</span>]=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  itlow=mymap.lower_bound (<span class="string">'b'</span>);  <span class="comment">// itlow points to b</span></span><br><span class="line">  itup=mymap.upper_bound (<span class="string">'d'</span>);   <span class="comment">// itup points to e (not d!)</span></span><br><span class="line"></span><br><span class="line">  mymap.erase(itlow,itup);        <span class="comment">// erases [itlow,itup)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// print content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; 20</span><br><span class="line">e =&gt; 100</span><br></pre></td></tr></table></figure><h4 id="map-equal-range"><a href="#map-equal-range" class="headerlink" title="map::equal_range"></a>map::equal_range</h4><p>获取相同元素的范围</p><p>返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。 </p><p>如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;const_iterator,const_iterator&gt; equal_range (<span class="keyword">const</span> key_type&amp; k) <span class="keyword">const</span>;</span><br><span class="line">pair&lt;iterator,iterator&gt;             equal_range (<span class="keyword">const</span> key_type&amp; k);</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">20</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator,<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator&gt; ret;</span><br><span class="line">  ret = mymap.equal_range(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lower bound points to: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"upper bound points to: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ret.second-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; ret.second-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lower bound points to: &apos;b&apos; =&gt; 20</span><br><span class="line">upper bound points to: &apos;c&apos; =&gt; 30</span><br></pre></td></tr></table></figure><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><h3 id="无序容器（Unordered-Container）：unordered-set、unordered-multiset、unordered-map、unordered-multimap"><a href="#无序容器（Unordered-Container）：unordered-set、unordered-multiset、unordered-map、unordered-multimap" class="headerlink" title="无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap"></a>无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap</h3><p>包括：</p><ul><li>unordered_set</li><li>unordered_multiset</li><li>unordered_map</li><li>unordered_multimap</li></ul><p>都是以哈希表实现的。</p><p><img src="http://img.blog.csdn.net/20160410123436394" alt></p><p>unordered_set、unodered_multiset结构：</p><p><img src="http://img.blog.csdn.net/20160410123518692" alt></p><p>unordered_map、unodered_multimap结构：</p><p><img src="http://img.blog.csdn.net/20160410123525739" alt></p><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h3 id="unordered-multiset"><a href="#unordered-multiset" class="headerlink" title="unordered_multiset"></a>unordered_multiset</h3><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><h3 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h3><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Types</span>&gt; <span class="title">class</span> <span class="title">tuple</span>;</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple, std::get, std::tie, std::ignore</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; foo (<span class="number">10</span>,<span class="string">'x'</span>);</span><br><span class="line">  <span class="keyword">auto</span> bar = <span class="built_in">std</span>::make_tuple (<span class="string">"test"</span>, <span class="number">3.1</span>, <span class="number">14</span>, <span class="string">'y'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(bar) = <span class="number">100</span>;                                    <span class="comment">// access element</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myint; <span class="keyword">char</span> mychar;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tie (myint, mychar) = foo;                            <span class="comment">// unpack elements</span></span><br><span class="line">  <span class="built_in">std</span>::tie (<span class="built_in">std</span>::ignore, <span class="built_in">std</span>::ignore, myint, mychar) = bar;  <span class="comment">// unpack (with ignore)</span></span><br><span class="line"></span><br><span class="line">  mychar = <span class="built_in">std</span>::get&lt;<span class="number">3</span>&gt;(bar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(foo) = <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(bar);</span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(foo) = mychar;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(foo) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(foo) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo contains: 100 y</span><br></pre></td></tr></table></figure><h4 id="tuple-tuple"><a href="#tuple-tuple" class="headerlink" title="tuple::tuple"></a>tuple::tuple</h4><p>构建一个 tuple（元组）对象。</p><p>这涉及单独构建其元素，初始化取决于调用的构造函数形式：</p><p>（1）默认的构造函数</p><p>构建一个 元组对象的元素值初始化。</p><p>（2）复制/移动构造函数</p><p>该对象使用tpl的内容进行初始化 元组目的。tpl<br>的相应元素被传递给每个元素的构造函数。</p><p>（3）隐式转换构造函数</p><p>同上。tpl中的<br>所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。</p><p>（4）初始化构造函数<br>用elems中的相应元素初始化每个元素。elems<br>的相应元素被传递给每个元素的构造函数。</p><p>（5）对转换构造函数</p><p>该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。</p><p>（6）分配器版本</p><p>和上面的版本一样，除了每个元素都是使用allocator alloc构造的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line">copy / move (<span class="number">2</span>)</span><br><span class="line">tuple (<span class="keyword">const</span> tuple&amp; tpl) = <span class="keyword">default</span>;</span><br><span class="line">tuple (tuple&amp;&amp; tpl) = <span class="keyword">default</span>;</span><br><span class="line"><span class="function">implicit <span class="title">conversion</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">template &lt;class... UTypes&gt;</span><br><span class="line">  tuple (<span class="keyword">const</span> tuple&lt;UTypes...&gt;&amp; tpl);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span></span><br><span class="line">initialization (<span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="keyword">const</span> Types&amp;... elems)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">explicit</span> <span class="title">tuple</span> (<span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span></span><br><span class="line"><span class="function">conversion from <span class="title">pair</span> <span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line">template &lt;class U1, class U2&gt;</span><br><span class="line">  tuple (<span class="keyword">const</span> pair&lt;U1,U2&gt;&amp; pr);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span></span><br><span class="line">allocator (<span class="number">6</span>)</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">tuple</span>&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">tuple</span>&amp;&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>,<span class="title">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">tuple</span>&lt;UTypes...&gt;&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">Types</span>&amp;... <span class="title">elems</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">pair</span>&lt;U1,U2&gt;&amp; <span class="title">pr</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // std::make_pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple, std::make_tuple, std::get</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; first;                             <span class="comment">// default</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; second (first);                    <span class="comment">// copy</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; third (<span class="built_in">std</span>::make_tuple(<span class="number">20</span>,<span class="string">'b'</span>));   <span class="comment">// move</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">long</span>,<span class="keyword">char</span>&gt; fourth (third);                   <span class="comment">// implicit conversion</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; fifth (<span class="number">10</span>,<span class="string">'a'</span>);                    <span class="comment">// initialization</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; sixth (<span class="built_in">std</span>::make_pair(<span class="number">30</span>,<span class="string">'c'</span>));    <span class="comment">// from pair / move</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sixth contains: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(sixth);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" and "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(sixth) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sixth contains: 30 and c</span><br></pre></td></tr></table></figure><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。</p><p>pair是tuple（元组）的一个特例。</p><p>pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p><p>应用：</p><ul><li>可以将两个类型数据组合成一个如map&lt;key, value&gt;</li><li>当某个函数需要两个返回值时</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">struct</span> <span class="title">pair</span>;</span></span><br></pre></td></tr></table></figure><h4 id="pair-pair"><a href="#pair-pair" class="headerlink" title="pair::pair"></a>pair::pair</h4><p>构建一个pair对象。</p><p>这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式：</p><p>（1）默认的构造函数</p><p>构建一个 对对象的元素值初始化。</p><p>（2）复制/移动构造函数（和隐式转换）</p><p>该对象被初始化为pr的内容 对目的。pr<br>的相应成员被传递给每个成员的构造函数。</p><p>（3）初始化构造函数</p><p>会员 第一是由一个和成员构建的第二与b。</p><p>（4）分段构造</p><p>构造成员 first  和 second  到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">pair</span><span class="params">()</span></span>;</span><br><span class="line">copy / move (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">V</span>&gt; <span class="title">pair</span> (<span class="title">const</span> <span class="title">pair</span>&lt;U,V&gt;&amp; <span class="title">pr</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">V</span>&gt; <span class="title">pair</span> (<span class="title">pair</span>&lt;U,V&gt;&amp;&amp; <span class="title">pr</span>);</span></span><br><span class="line">pair (<span class="keyword">const</span> pair&amp; pr) = <span class="keyword">default</span>;</span><br><span class="line">pair (pair&amp;&amp; pr) = <span class="keyword">default</span>;</span><br><span class="line">initialization (<span class="number">3</span>)</span><br><span class="line">pair (<span class="keyword">const</span> first_type&amp; a, <span class="keyword">const</span> second_type&amp; b);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">V</span>&gt; <span class="title">pair</span> (<span class="title">U</span>&amp;&amp; <span class="title">a</span>, <span class="title">V</span>&amp;&amp; <span class="title">b</span>);</span></span><br><span class="line">piecewise (<span class="number">4</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args1</span>, <span class="title">class</span>... <span class="title">Args2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">pair</span> (<span class="title">piecewise_construct_t</span> <span class="title">pwc</span>, <span class="title">tuple</span>&lt;Args1...&gt; <span class="title">first_args</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">tuple</span>&lt;Args2...&gt; <span class="title">second_args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // std::pair, std::make_pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product1;                     <span class="comment">// default constructor</span></span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product2 (<span class="string">"tomatoes"</span>,<span class="number">2.30</span>);   <span class="comment">// value init</span></span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product3 (product2);          <span class="comment">// copy constructor</span></span><br><span class="line"></span><br><span class="line">  product1 = <span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"lightbulbs"</span>),<span class="number">0.99</span>);   <span class="comment">// using make_pair (move)</span></span><br><span class="line"></span><br><span class="line">  product2.first = <span class="string">"shoes"</span>;                  <span class="comment">// the type of first is string</span></span><br><span class="line">  product2.second = <span class="number">39.90</span>;                   <span class="comment">// the type of second is double</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product1.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product1.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product2.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product2.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product3.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product3.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The price of lightbulbs is $0.99</span><br><span class="line">The price of shoes is $39.9</span><br><span class="line">The price of tomatoes is $2.3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;STL&quot;&gt;&lt;a href=&quot;#STL&quot; class=&quot;headerlink&quot; title=&quot;STL&quot;&gt;&lt;/a&gt;STL&lt;/h1&gt;&lt;h2 id=&quot;网站&quot;&gt;&lt;a href=&quot;#网站&quot; class=&quot;headerlink&quot; title=&quot;网站&quot;&gt;&lt;/a&gt;网站&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9ub3RlL2Jsb2IvbWFzdGVyL1NUTC5tZA==&quot; title=&quot;https://github.com/huihut/note/blob/master/STL.md&quot;&gt;github . huihut/note/STL.md&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdGwv&quot; title=&quot;http://www.cplusplus.com/reference/stl/&quot;&gt;cplusplus . stl&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3poLmNwcHJlZmVyZW5jZS5jb20vdy8lRTklQTYlOTYlRTklQTElQjU=&quot; title=&quot;http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5&quot;&gt;cppreference . C++ 参考手册&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sdW1uL2RldGFpbHMvZ2Vlay1zdGwuaHRtbA==&quot; title=&quot;http://blog.csdn.net/column/details/geek-stl.html&quot;&gt;CSDN专栏：STL学习笔记&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Program-C" scheme="http://miaopei.github.io/categories/Program-C/"/>
    
    
      <category term="Program-C" scheme="http://miaopei.github.io/tags/Program-C/"/>
    
  </entry>
  
  <entry>
    <title>Interview C C++</title>
    <link href="http://miaopei.github.io/2016/06/08/Program-C/interview/"/>
    <id>http://miaopei.github.io/2016/06/08/Program-C/interview/</id>
    <published>2016-06-08T02:14:50.000Z</published>
    <updated>2019-06-11T02:02:19.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-C-面试知识总结"><a href="#C-C-面试知识总结" class="headerlink" title="C/C++ 面试知识总结"></a>C/C++ 面试知识总结</h1><p>C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。</p><p>勘误新增请 Issue、PR，建议、讨论请 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvaXNzdWVzLzEy" title="https://github.com/huihut/interview/issues/12">#issues/12<i class="fa fa-external-link"></i></span>，排版使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL216bG9naW4vY2hpbmVzZS1jb3B5d3JpdGluZy1ndWlkZWxpbmVz" title="https://github.com/mzlogin/chinese-copywriting-guidelines">中文文案排版指北<i class="fa fa-external-link"></i></span></p><p>使用建议：</p><ul><li><code>Ctrl + F</code>：快速查找定位知识点</li><li><code>TOC 导航</code>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phd2lsL0dheUh1Yg==" title="https://github.com/jawil/GayHub">jawil/GayHub<i class="fa fa-external-link"></i></span> 插件快速目录跳转</li></ul><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#cc">C/C++</a></li><li><a href="#stl">STL</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li><li><a href="#%E7%AE%97%E6%B3%95">算法</a></li><li><a href="#problems">Problems</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E5%BA%93">链接装载库</a></li><li><a href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">海量数据处理</a></li><li><a href="#%E9%9F%B3%E8%A7%86%E9%A2%91">音视频</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li><li><a href="#%E4%B9%A6%E7%B1%8D">书籍</a></li><li><a href="#%E5%A4%8D%E4%B9%A0%E5%88%B7%E9%A2%98%E7%BD%91%E7%AB%99">复习刷题网站</a></li><li><a href="#%E6%8B%9B%E8%81%98%E6%97%B6%E9%97%B4%E5%B2%97%E4%BD%8D">招聘时间岗位</a></li><li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E7%BB%8F%E9%AA%8C">面试题目经验</a></li></ul><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针和指针常量；</li><li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><details><summary>const 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="comment">// 还有其中区别方法，沿着 * 号划一条线：</span></span><br><span class="line"><span class="comment">// 如果const位于 * 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；</span></span><br><span class="line"><span class="comment">// 如果const位于 * 的右侧，const就是修饰指针本身，即指针本身是常量。</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure></details><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。</li><li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ol><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81YzM1Y2MyMThiYjQ=" title="https://www.jianshu.com/p/5c35cc218bb4">C++ static 和const 的作用<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 <code>this</code> 指针：<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol><h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>不能包含循环、递归、switch 等复杂操作；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><details><summary>inline 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure></details><h4 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h4><ol><li>将 inline 函数体复制到 inline 函数调用点处； </li><li>为所用 inline 函数中的局部变量分配内存空间； </li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h4 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h4><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcy50ZWNobmlvbi5hYy5pbC91c2Vycy95ZWNoaWVsL2MrKy1mYXEvaW5saW5lLXZpcnR1YWxzLmh0bWw=" title="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html">Are “inline virtual” member functions ever actually “inlined”?<i class="fa fa-external-link"></i></span></p><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><details><summary>虚函数内联使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">Base b;</span><br><span class="line">b.who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">ptr-&gt;who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p><details><summary>assert() 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure></details><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h3><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul><h3 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h3><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p><details><summary>#pragma pack(n) 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure></details><h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bit mode: <span class="number">2</span>;    <span class="comment">// mode 占 2 位</span></span><br></pre></td></tr></table></figure><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和连接的</li></ul><p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><details><summary>extern "C" 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></details><h3 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h3><h4 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p><p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p><h4 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h4><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p><p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p><p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student(); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h3><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>最本质的一个区别就是默认的访问控制<ol><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ol></li></ul><h3 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><details><summary>union 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h3><p><span class="exturl" data-url="aHR0cDovL2Rvbmd4aWNoZW5nLm9yZy9jcHAvb29jLw==" title="http://dongxicheng.org/cpp/ooc/">C 语言实现封装、继承和多态<i class="fa fa-external-link"></i></span></p><h3 id="explicit（显式）构造函数"><a href="#explicit（显式）构造函数" class="headerlink" title="explicit（显式）构造函数"></a>explicit（显式）构造函数</h3><p>explicit 修饰的构造函数可用来防止隐式转换</p><details><summary>explicit 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test1(<span class="keyword">int</span> n)            <span class="comment">// 普通构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> n)</span>   <span class="comment">// explicit（显式）构造函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test1 t1=<span class="number">12</span>;            <span class="comment">// 隐式调用其构造函数，成功</span></span><br><span class="line">    Test2 t2=<span class="number">12</span>;            <span class="comment">// 编译错误，不能隐式调用其构造函数</span></span><br><span class="line">    <span class="function">Test2 <span class="title">t2</span><span class="params">(<span class="number">12</span>)</span></span>;           <span class="comment">// 显式调用成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h3><ul><li>能访问私有成员  </li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><h4 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h4><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure><h4 id="构造函数的-using-声明【C-11】"><a href="#构造函数的-using-声明【C-11】" class="headerlink" title="构造函数的 using 声明【C++11】"></a>构造函数的 using 声明【C++11】</h4><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">derived(parms) : base(args) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h4><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure><h4 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 <code>using 指示</code> 污染命名空间</h4><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了制定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><details><summary>using 使用</summary> <p>尽量少使用 <code>using 指示</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>应该多使用 <code>using 声明</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></details><h3 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ol><details><summary>:: 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    count = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h3><h4 id="限定作用域的枚举类型"><a href="#限定作用域的枚举类型" class="headerlink" title="限定作用域的枚举类型"></a>限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span> input, output, append &#125;;</span><br></pre></td></tr></table></figure><h4 id="不限定作用域的枚举类型"><a href="#不限定作用域的枚举类型" class="headerlink" title="不限定作用域的枚举类型"></a>不限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy53ZWl4dWV5dWFuLm5ldC92aWV3LzU4MjQuaHRtbA==" title="http://www.weixueyuan.net/view/5824.html">C++ 枚举类型详解<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure><details><summary>decltype 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>常规引用，一般表示对象的身份。</p><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p><p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p><ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li></ul><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aWFvbHUxMTc1L2FydGljbGUvZGV0YWlscy80Njg4OTUyMw==" title="https://blog.csdn.net/tianxiaolu1175/article/details/46889523">详解c++ 引用（reference）与 指针（pointer）的区别与联系<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul><li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li></ul><h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><p>好处</p><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li></ol></li></ul><h3 id="initializer-list-列表初始化【C-11】"><a href="#initializer-list-列表初始化【C-11】" class="headerlink" title="initializer_list 列表初始化【C++11】"></a>initializer_list 列表初始化【C++11】</h3><p>用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p><details><summary>initializer_list 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.size() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.end(), l.begin(), l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> T*, <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; c_arr() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.size()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p><img src="http://img.my.csdn.net/uploads/201211/22/1353564524_6375.png" alt="面向对象特征"></p><p>面向对象三大特征 —— 封装、继承、多态</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li><li>关键字：public, protected, friendly, private。不写默认为 friendly。</li></ul><table><thead><tr><th>关键字</th><th>当前类</th><th>包内</th><th>子孙类</th><th>包外</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>friendly</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>基类（父类）——&gt; 派生类（子类）</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。</li><li>C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。</li><li>多态是以封装和继承为基础的。</li></ul><h4 id="静态多态（早绑定）"><a href="#静态多态（早绑定）" class="headerlink" title="静态多态（早绑定）"></a>静态多态（早绑定）</h4><p>函数重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态多态（晚绑定）"><a href="#动态多态（晚绑定）" class="headerlink" title="动态多态（晚绑定）"></a>动态多态（晚绑定）</h4><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li></ul><p><strong>注意：</strong></p><ul><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数，解释见：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcjJUU4JTk5JTlBJUU1JTg3JUJEJUU2JTk1JUIwdmlydHVhbCVFNSU4RiVBRiVFNCVCQiVBNSVFNiU5OCVBRiVFNSU4NiU4NSVFOCU4MSU5NCVFNSU4NyVCRCVFNiU5NSVCMGlubGluZSVFNSU5MCU5Nw==" title="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97">虚函数（virtual）可以是内联函数（inline）吗？<i class="fa fa-external-link"></i></span></li></ul><details><summary>动态多态使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                     // 形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p><details><summary>虚析构函数使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();    </span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIyNjAyMzgvYXJ0aWNsZS9kZXRhaWxzLzUzNjEwNDYy" title="https://blog.csdn.net/u012260238/article/details/53610462">CSDN . C++ 中的虚函数、纯虚函数区别和联系<i class="fa fa-external-link"></i></span></p><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 </li><li>虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 </li><li>带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。</li></ul><h3 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h3><ul><li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li></ul><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p><p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><h3 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h3><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h3 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h3><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h3 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h3><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有有定于任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数</li></ul></li></ul><h3 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a>内存分配和管理</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9jaGVucXguZ2l0aHViLmlvLzIwMTQvMDkvMjUvQ3BwLU1lbW9yeS1NYW5hZ2VtZW50Lw==" title="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">C/C++内存管理详解<i class="fa fa-external-link"></i></span> - ShinChan’s Blog</p></blockquote><h4 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h4><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ol><h4 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h4><p>用于分配、释放内存</p><details><summary>malloc、free 使用</summary> <p>申请内存，确认是否申请成功</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">assert(str != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>释放内存后指针置空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></details><h4 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h4><ol><li>new / new[]：完成两件事，先底层调用 malloc 分了配内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><details><summary>new、delete 使用</summary> <p>申请内存，确认是否申请成功</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t = <span class="keyword">new</span> T();     <span class="comment">// 先内存分配 ，再构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t;           <span class="comment">// 先析构函数，再内存释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="定位-new"><a href="#定位-new" class="headerlink" title="定位 new"></a>定位 new</h4><p>定位 new（placement new）允许我们向 new 传递额外的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (palce_address) type</span><br><span class="line"><span class="keyword">new</span> (palce_address) type (initializers)</span><br><span class="line"><span class="keyword">new</span> (palce_address) type [size]</span><br><span class="line"><span class="keyword">new</span> (palce_address) type [size] &#123; braced initializer <span class="built_in">list</span> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>palce_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h3 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h3><p><span class="exturl" data-url="aHR0cHM6Ly9pc29jcHAub3JnL3dpa2kvZmFxL2ZyZWVzdG9yZS1tZ210I2RlbGV0ZS10aGlz" title="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this">Is it legal (and moral) for a member function to say delete this?<i class="fa fa-external-link"></i></span></p><p>合法，但：</p><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol><h3 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvMGE1ODRhYTEzZjgwNGYzZWE3MmI0NDJhMDY1YTc2MTg=" title="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618">如何定义一个只能在堆上（栈上）生成对象的类?<i class="fa fa-external-link"></i></span></p><h4 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h4><p>方法：将析构函数设置为私有</p><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p><h4 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h4><p>方法：将 new 和 delete 重载为私有</p><p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2xleGlhby9hcnRpY2xlL2RldGFpbHMvNTY3NzMwMzk=" title="https://blog.csdn.net/haolexiao/article/details/56773039">C++11及C++14标准的智能指针<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4MTk4MjUyOTQvYXJ0aWNsZS9kZXRhaWxzLzUyMTM5MzI4" title="https://blog.csdn.net/a819825294/article/details/52139328">C++ 智能指针<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMTA0NjY2Lw==" title="http://blog.jobbole.com/104666/">使用 C++11 智能指针时要避开的 10 大错误<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h4><p>头文件：<code>#include &lt;memory&gt;</code></p><h4 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps (<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))；</span><br></pre></td></tr></table></figure><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h4><ol><li>shared_ptr</li><li>unique_ptr</li><li>weak_ptr</li><li>auto_ptr（被 C++11 弃用）</li></ol><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li><li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li></ul><h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p><ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li></ul><h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p><ul><li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li></ul><h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p><ul><li>unique_ptr 用于取代 auto_ptr</li></ul><h5 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h5><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p><h5 id="auto-ptr-与-unique-ptr-比较"><a href="#auto-ptr-与-unique-ptr-比较" class="headerlink" title="auto_ptr 与 unique_ptr 比较"></a>auto_ptr 与 unique_ptr 比较</h5><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li><li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li></ul><h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vemgtQ04vbGlicmFyeS81ZjZjOWY4aC5hc3B4" title="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx">MSDN . 强制转换运算符<i class="fa fa-external-link"></i></span></p><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ29vZGhhY2tlci9hcmNoaXZlLzIwMTEvMDcvMjAvMjExMTk5Ni5odG1s" title="https://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html">C++类型转换总结<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><ul><li>用于非多态类型的转换</li><li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li><li>通常用于转换数值数据类型（如 float -&gt; int）</li><li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li></ul><blockquote><p>向上转换是一种隐式转换。</p></blockquote><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li><li>执行行运行时类型检查</li><li>只适用于指针或引用</li><li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><ul><li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li></ul><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><ul><li>用于位的简单重新解释</li><li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li><li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li><li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li><li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li></ul><h4 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h4><ul><li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li></ul><details><summary>bad_cast 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Circle&amp; ref_circle = <span class="keyword">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> (bad_cast b) &#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught: "</span> &lt;&lt; b.what();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><h4 id="dynamic-cast-1"><a href="#dynamic-cast-1" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li></ul><h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><h4 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h4><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：<code>typeinfo</code></li></ul><details><summary>typeid、type_info 使用</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>                       // 能飞的</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>= <span class="number">0</span>;     <span class="comment">// 起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>= <span class="number">0</span>;        <span class="comment">// 降落</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> :</span> <span class="keyword">public</span> Flyable         <span class="comment">// 鸟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foraging</span><span class="params">()</span> </span>&#123;...&#125;           <span class="comment">// 觅食</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> :</span> <span class="keyword">public</span> Flyable        <span class="comment">// 飞机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">carry</span><span class="params">()</span> </span>&#123;...&#125;              <span class="comment">// 运输</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> take <span class="title">off</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info &amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">doSomething</span><span class="params">(Flyable *obj)</span>                 <span class="comment">// 做些事情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;takeoff();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*obj).name() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 输出传入对象类型（"class Bird" or "class Plane"）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(*obj) == <span class="keyword">typeid</span>(Bird))            <span class="comment">// 判断对象类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bird *bird = <span class="keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="comment">// 对象转化</span></span><br><span class="line">        bird-&gt;foraging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj-&gt;land();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h3 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h3><ol><li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li><li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li><li>尽可能使用 const</li><li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li><li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li><li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li><li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li><li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li><li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li><li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li><li>在 <code>operator=</code> 中处理 “自我赋值”</li><li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li><li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li><li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li><li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li><li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li><li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li><li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li><li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li><li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li><li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li><li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li><li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li><li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li><li>考虑写一个不抛异常的 swap 函数</li><li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li><li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li><li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li><li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li><li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li><li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能过够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li><li>确定你的 public 继承塑模出 is-a 关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li><li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li><li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li><li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li><li>绝不重新定义继承而来的 non-virtual 函数</li><li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li></ol><h3 id="Google-C-Style-Guide"><a href="#Google-C-Style-Guide" class="headerlink" title="Google C++ Style Guide"></a>Google C++ Style Guide</h3><blockquote><p>英文：<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL3N0eWxlZ3VpZGUvY3BwZ3VpZGUuaHRtbA==" title="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide<i class="fa fa-external-link"></i></span><br>中文：<span class="exturl" data-url="aHR0cHM6Ly96aC1nb29nbGUtc3R5bGVndWlkZS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvZ29vZ2xlLWNwcC1zdHlsZWd1aWRlL2NvbnRlbnRzLw==" title="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">C++ 风格指南<i class="fa fa-external-link"></i></span></p></blockquote><details><summary>Google C++ Style Guide 图</summary><p><img src="/images/imageProgramC/interview/GoogleCppStyleGuide.png" alt="Google C++ Style Guide"></p><blockquote><p>图片来源于：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZvaWRjY2MvYXJ0aWNsZS9kZXRhaWxzLzM3NTk5MjAz" title="https://blog.csdn.net/voidccc/article/details/37599203">CSDN . 一张图总结Google C++编程规范(Google C++ Style Guide)<i class="fa fa-external-link"></i></span></p></blockquote></details><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="STL-索引"><a href="#STL-索引" class="headerlink" title="STL 索引"></a>STL 索引</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RM" title="https://github.com/huihut/interview/tree/master/STL">STL 方法含义索引<i class="fa fa-external-link"></i></span></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTU2MDcxNjZmYjlhMDFjYjI1NmQ1MDE=" title="https://juejin.im/post/5a5607166fb9a01cb256d501">C++ STL容器总结<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h3><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI2FycmF5" title="https://github.com/huihut/interview/tree/master/STL#array">array<i class="fa fa-external-link"></i></span></td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持快速随机访问</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3ZlY3Rvcg==" title="https://github.com/huihut/interview/tree/master/STL#vector">vector<i class="fa fa-external-link"></i></span></td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1)<br>头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持快速随机访问</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI2xpc3Q=" title="https://github.com/huihut/interview/tree/master/STL#list">list<i class="fa fa-external-link"></i></span></td><td>双向链表</td><td>插入、删除 O(1)<br>随机读改 O(n)</td><td>无序</td><td>可重复</td><td>支持快速增删</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI2RlcXVl" title="https://github.com/huihut/interview/tree/master/STL#deque">deque<i class="fa fa-external-link"></i></span></td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3N0YWNr" title="https://github.com/huihut/interview/tree/master/STL#stack">stack<i class="fa fa-external-link"></i></span></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3F1ZXVl" title="https://github.com/huihut/interview/tree/master/STL#queue">queue<i class="fa fa-external-link"></i></span></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3ByaW9yaXR5X3F1ZXVl" title="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue<i class="fa fa-external-link"></i></span></td><td>vector + max-heap</td><td>插入、删除 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3NldA==" title="https://github.com/huihut/interview/tree/master/STL#set">set<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI211bHRpc2V0" title="https://github.com/huihut/interview/tree/master/STL#multiset">multiset<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI21hcA==" title="https://github.com/huihut/interview/tree/master/STL#map">map<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI211bHRpbWFw" title="https://github.com/huihut/interview/tree/master/STL#multimap">multimap<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td>hash_set</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>hash_multiset</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td>hash_map</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>hash_multimap</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><h3 id="STL-算法"><a href="#STL-算法" class="headerlink" title="STL 算法"></a>STL 算法</h3><table><thead><tr><th>算法</th><th>底层算法</th><th>时间复杂度</th><th>可不可重复</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9hbGdvcml0aG0vZmluZC8=" title="http://www.cplusplus.com/reference/algorithm/find/">find<i class="fa fa-external-link"></i></span></td><td>顺序查找</td><td>O(n)</td><td>可重复</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2djYy1taXJyb3IvZ2NjL2Jsb2IvbWFzdGVyL2xpYnN0ZGMrKy12My9pbmNsdWRlL2JpdHMvc3RsX2FsZ28uaCNMNDgwOA==" title="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808">sort<i class="fa fa-external-link"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50cm9zb3J0" title="https://en.wikipedia.org/wiki/Introsort">内省排序<i class="fa fa-external-link"></i></span></td><td>O(n*log<sub>2</sub>n)</td><td>可重复</td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h4 id="顺序栈（Sequence-Stack）"><a href="#顺序栈（Sequence-Stack）" class="headerlink" title="顺序栈（Sequence Stack）"></a>顺序栈（Sequence Stack）</h4><p><a href="DataStructure/SqStack.cpp">SqStack.cpp</a></p><details><summary>顺序栈数据结构和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqSrack;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/SqStack.png" alt></p></details><h4 id="队列（Sequence-Queue）"><a href="#队列（Sequence-Queue）" class="headerlink" title="队列（Sequence Queue）"></a>队列（Sequence Queue）</h4><details><summary>队列数据结构</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType * elem;</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> maxSize;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></details><h5 id="非循环队列"><a href="#非循环队列" class="headerlink" title="非循环队列"></a>非循环队列</h5><details><summary>非循环队列图片</summary><p><img src="/images/imageProgramC/interview/SqQueue.png" alt></p><p><code>SqQueue.rear++</code></p></details><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><details><summary>循环队列图片</summary><p><img src="/images/imageProgramC/interview/SqLoopStack.png" alt></p><p><code>SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize</code></p></details><h4 id="顺序表（Sequence-List）"><a href="#顺序表（Sequence-List）" class="headerlink" title="顺序表（Sequence List）"></a>顺序表（Sequence List）</h4><p><a href="DataStructure/SqList.cpp">SqList.cpp</a></p><details><summary>顺序表数据结构和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/SqList.png" alt></p></details><h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><p><a href="DataStructure/LinkList.cpp">LinkList.cpp</a></p><p><a href="DataStructure/LinkList_with_head.cpp">LinkList_with_head.cpp</a></p><details><summary>链式数据结构</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure></details><h4 id="链队列（Link-Queue）"><a href="#链队列（Link-Queue）" class="headerlink" title="链队列（Link Queue）"></a>链队列（Link Queue）</h4><details><summary>链队列图片</summary><p><img src="/images/imageProgramC/interview/LinkQueue.png" alt></p></details><h4 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h4><h5 id="单链表（Link-List）"><a href="#单链表（Link-List）" class="headerlink" title="单链表（Link List）"></a>单链表（Link List）</h5><details><summary>单链表图片</summary><p><img src="/images/imageProgramC/interview/LinkList.png" alt></p></details><h5 id="双向链表（Du-Link-List）"><a href="#双向链表（Du-Link-List）" class="headerlink" title="双向链表（Du-Link-List）"></a>双向链表（Du-Link-List）</h5><details><summary>双向链表图片</summary><p><img src="/images/imageProgramC/interview/DuLinkList.png" alt></p></details><h5 id="循环链表（Cir-Link-List）"><a href="#循环链表（Cir-Link-List）" class="headerlink" title="循环链表（Cir-Link-List）"></a>循环链表（Cir-Link-List）</h5><details><summary>循环链表图片</summary><p><img src="/images/imageProgramC/interview/CirLinkList.png" alt></p></details><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="DataStructure/HashTable.cpp">HashTable.cpp</a></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>哈希函数：<code>H(key): K -&gt; D , key ∈ K</code></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>直接定址法</li><li>除留余数法</li><li>数字分析法</li><li>折叠法</li><li>平方取中法</li></ul><h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><ul><li>链地址法：key 相同的用单链表链接</li><li>开放定址法<ul><li>线性探测法：key 相同 -&gt; 放到 key 的下一个位置，<code>Hi = (H(key) + i) % m</code></li><li>二次探测法：key 相同 -&gt; 放到 <code>Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2）</code></li><li>随机探测法：<code>H = (H(key) + 伪随机数) % m</code></li></ul></li></ul><h4 id="线性探测的哈希表数据结构"><a href="#线性探测的哈希表数据结构" class="headerlink" title="线性探测的哈希表数据结构"></a>线性探测的哈希表数据结构</h4><details><summary>线性探测的哈希表数据结构和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">KeyType key;</span><br><span class="line">&#125;RcdType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">RcdType *rcd;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">bool</span> *tag;</span><br><span class="line">&#125;HashTable;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/HashTable.png" alt></p></details><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>函数直接或间接地调用自身</p><h4 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h4><ul><li>分治法<ul><li>问题的分解</li><li>问题规模的分解</li></ul></li><li>折半查找（递归）</li><li>归并查找（递归）</li><li>快速排序（递归）</li></ul><h4 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h4><ul><li>迭代：反复利用变量旧值推出新值</li><li>折半查找（迭代）</li><li>归并查找（迭代）</li></ul><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><h5 id="头尾链表存储表示"><a href="#头尾链表存储表示" class="headerlink" title="头尾链表存储表示"></a>头尾链表存储表示</h5><details><summary>广义表的头尾链表存储表示和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的头尾链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom;</span><br><span class="line">        <span class="comment">// atom 是原子结点的值域，AtomType 由用户定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="comment">// ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾</span></span><br><span class="line">    &#125; a;</span><br><span class="line">&#125; *GList, GLNode;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/GeneralizedList1.png" alt></p></details><h5 id="扩展线性链表存储表示"><a href="#扩展线性链表存储表示" class="headerlink" title="扩展线性链表存储表示"></a>扩展线性链表存储表示</h5><details><summary>扩展线性链表存储表示和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的扩展线性链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom; <span class="comment">// 原子结点的值域</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">hp</span>;</span> <span class="comment">// 表结点的表头指针</span></span><br><span class="line">    &#125; a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">tp</span>;</span></span><br><span class="line">    <span class="comment">// 相当于线性链表的 next，指向下一个元素结点</span></span><br><span class="line">&#125; *GList1, GLNode1;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/GeneralizedList2.png" alt></p></details><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><a href="DataStructure/BinaryTree.cpp">BinaryTree.cpp</a></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i &gt;= 1）</li><li>深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k &gt;= 1）</li><li>度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1</li><li>有 n 个结点的完全二叉树深度 k = ⌊ log<sub>2</sub>(n) ⌋ + 1 </li><li>对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点<ol><li>若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋</li><li>若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i</li><li>若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1</li></ol></li></ol><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><details><summary>二叉树数据结构</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure></details><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><details><summary>二叉树顺序存储图片</summary><p><img src="/images/imageProgramC/interview/SqBinaryTree.png" alt></p></details><h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><details><summary>二叉树链式存储图片</summary><p><img src="/images/imageProgramC/interview/LinkBinaryTree.png" alt></p></details><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul><li>先序遍历</li><li>中序遍历</li><li>后续遍历</li><li>层次遍历</li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>满二叉树</li><li>完全二叉树（堆）<ul><li>大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右</li><li>小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右</li></ul></li><li>二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右</li><li>平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1</li><li>最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：<ul><li>LL型：根的左孩子右旋</li><li>RR型：根的右孩子左旋</li><li>LR型：根的左孩子左旋，再右旋</li><li>RL型：右孩子的左子树，先右旋，再左旋</li></ul></li></ul><h3 id="其他树及森林"><a href="#其他树及森林" class="headerlink" title="其他树及森林"></a>其他树及森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul><li>双亲表示法</li><li>双亲孩子表示法</li><li>孩子兄弟表示法</li></ul><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>一种不相交的子集所构成的集合 S = {S1, S2, …, Sn}</p><h4 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h4><h5 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h5><ul><li>| 左子树树高 - 右子树树高 | &lt;= 1</li><li>平衡二叉树必定是二叉搜索树，反之则不一定</li><li>最小二叉平衡树的节点的公式：<code>F(n)=F(n-1)+F(n-2)+1</code> （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）</li></ul><details><summary>平衡二叉树图片</summary><p><img src="/images/imageProgramC/interview/Self-balancingBinarySearchTree.png" alt></p></details><h5 id="最小失衡树"><a href="#最小失衡树" class="headerlink" title="最小失衡树"></a>最小失衡树</h5><p>平衡二叉树插入新结点导致失衡的子树</p><p>调整：</p><ul><li>LL 型：根的左孩子右旋</li><li>RR 型：根的右孩子左旋</li><li>LR 型：根的左孩子左旋，再右旋</li><li>RL 型：右孩子的左子树，先右旋，再左旋</li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h5 id="红黑树的特征是什么？"><a href="#红黑树的特征是什么？" class="headerlink" title="红黑树的特征是什么？"></a>红黑树的特征是什么？</h5><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是 NIL 节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）</li></ol><h5 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h5><ol><li>变色</li><li>左旋</li><li>右旋</li></ol><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul><li>关联数组：如 STL 中的 map、set</li></ul><h5 id="红黑树、B-树、B-树的区别？"><a href="#红黑树、B-树、B-树的区别？" class="headerlink" title="红黑树、B 树、B+ 树的区别？"></a>红黑树、B 树、B+ 树的区别？</h5><ul><li>红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些</li><li>B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。</li></ul><h4 id="B-树（B-tree）、B-树（B-tree）"><a href="#B-树（B-tree）、B-树（B-tree）" class="headerlink" title="B 树（B-tree）、B+ 树（B+-tree）"></a>B 树（B-tree）、B+ 树（B+-tree）</h4><details><summary>B 树、B+ 树图片</summary><p><img src="https://i.stack.imgur.com/l6UyF.png" alt="B 树（B-tree）、B+ 树（B+-tree）"></p></details><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>一般化的二叉查找树（binary search tree）</li><li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li></ul><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ul><li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li></ul><h5 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h5><ul><li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li><li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li></ul><h5 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h5><p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p><h5 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h5><ul><li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li><li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li></ul><blockquote><p>B 树、B+ 树区别来自：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODcwMjE4L2RpZmZlcmVuY2VzLWJldHdlZW4tYi10cmVlcy1hbmQtYi10cmVlcw==" title="https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees">differences-between-b-trees-and-b-trees<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaXZpY3Rvci9wLzU4NDkwNjEuaHRtbA==" title="https://www.cnblogs.com/ivictor/p/5849061.html">B树和B+树的区别<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h4><details><summary>八叉树图片</summary><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png" alt></p></details><p>八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><ul><li>三维计算机图形</li><li>最邻近搜索</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最差时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td><a href="Algorithm/BubbleSort.h">冒泡排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td><a href="Algorithm/SelectionSort.h">选择排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>数组不稳定、链表稳定</td></tr><tr><td><a href="Algorithm/InsertSort.h">插入排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td><a href="Algorithm/QuickSort.h">快速排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n<sup>2</sup>)</td><td>O(log<sub>2</sub>n)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/HeapSort.cpp">堆排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n*log<sub>2</sub>n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/MergeSort.h">归并排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n*log<sub>2</sub>n)</td><td>O(n)</td><td>稳定</td></tr><tr><td><a href="Algorithm/ShellSort.h">希尔排序</a></td><td>O(n*log<sup>2</sup>n)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/CountSort.cpp">计数排序</a></td><td>O(n+m)</td><td>O(n+m)</td><td>O(n+m)</td><td>稳定</td></tr><tr><td><a href="Algorithm/BucketSort.cpp">桶排序</a></td><td>O(n)</td><td>O(n)</td><td>O(m)</td><td>稳定</td></tr><tr><td><a href="Algorithm/RadixSort.h">基数排序</a></td><td>O(k*n)</td><td>O(n<sup>2</sup>)</td><td></td><td>稳定</td></tr></tbody></table><blockquote><ul><li>均按从小到大排列</li><li>k：代表数值中的 “数位” 个数</li><li>n：代表数据规模</li><li>m：代表数据的最大值减最小值</li><li>来自：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JThFJTkyJUU1JUJBJThGJUU3JUFFJTk3JUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">wikipedia . 排序算法<i class="fa fa-external-link"></i></span></li></ul></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><table><thead><tr><th>查找算法</th><th>平均时间复杂度</th><th>空间复杂度</th><th>查找条件</th></tr></thead><tbody><tr><td><a href="Algorithm/SequentialSearch.h">顺序查找</a></td><td>O(n)</td><td>O(1)</td><td>无序或有序</td></tr><tr><td><a href="Algorithm/BinarySearch.h">二分查找（折半查找）</a></td><td>O(log<sub>2</sub>n)</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="Algorithm/InsertionSearch.h">插值查找</a></td><td>O(log<sub>2</sub>(log<sub>2</sub>n))</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="Algorithm/FibonacciSearch.cpp">斐波那契查找</a></td><td>O(log<sub>2</sub>n)</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="DataStructure/HashTable.cpp">哈希查找</a></td><td>O(1)</td><td>O(n)</td><td>无序或有序</td></tr><tr><td><a href="Algorithm/BSTSearch.h">二叉查找树（二叉搜索树查找）</a></td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr><tr><td><a href="DataStructure/RedBlackTree.cpp">红黑树</a></td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr><tr><td>2-3树</td><td>O(log<sub>2</sub>n - log<sub>3</sub>n)</td><td></td><td></td></tr><tr><td>B树/B+树</td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr></tbody></table><h3 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h3><table><thead><tr><th>图搜索算法</th><th>数据结构</th><th>遍历时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUI5JUJGJUU1JUJBJUE2JUU0JUJDJTk4JUU1JTg1JTg4JUU2JTkwJTlDJUU3JUI0JUEy" title="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS广度优先搜索<i class="fa fa-external-link"></i></span></td><td>邻接矩阵<br>邻接链表</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUI3JUIxJUU1JUJBJUE2JUU0JUJDJTk4JUU1JTg1JTg4JUU2JTkwJTlDJUU3JUI0JUEy" title="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">DFS深度优先搜索<i class="fa fa-external-link"></i></span></td><td>邻接矩阵<br>邻接链表</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td></tr></tbody></table><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><table><thead><tr><th>算法</th><th>思想</th><th>应用</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg4JTg2JUU2JUIyJUJCJUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法<i class="fa fa-external-link"></i></span></td><td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvUHJvYmxlbXMvUm91bmRSb2JpblByb2JsZW0=" title="https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem">循环赛日程安排问题<i class="fa fa-external-link"></i></span>、排序算法（快速排序、归并排序）</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThBJUE4JUU2JTgwJTgxJUU4JUE3JTg0JUU1JTg4JTky" title="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划<i class="fa fa-external-link"></i></span></td><td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvUHJvYmxlbXMvS25hcHNhY2tQcm9ibGVt" title="https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem">背包问题<i class="fa fa-external-link"></i></span>、斐波那契数列</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI0JUFBJUU1JUJGJTgzJUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">贪心法<i class="fa fa-external-link"></i></span></td><td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</td><td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</td></tr></tbody></table><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><h3 id="Single-Problem"><a href="#Single-Problem" class="headerlink" title="Single Problem"></a>Single Problem</h3><ul><li><a href="Problems/ChessboardCoverageProblem">Chessboard Coverage Problem（棋盘覆盖问题）</a></li><li><a href="Problems/KnapsackProblem">Knapsack Problem（背包问题）</a></li><li><a href="Problems/NeumannNeighborProblem">Neumann Neighbor Problem（冯诺依曼邻居问题）</a></li><li><a href="Problems/RoundRobinProblem">Round Robin Problem（循环赛日程安排问题）</a></li><li><a href="Problems/TubingProblem">Tubing Problem（输油管道问题）</a></li></ul><h3 id="Leetcode-Problems"><a href="#Leetcode-Problems" class="headerlink" title="Leetcode Problems"></a>Leetcode Problems</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhb2VsL2xlZXRjb2Rl" title="https://github.com/haoel/leetcode">Github . haoel/leetcode<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BlenkvTGVldENvZGU=" title="https://github.com/pezy/LeetCode">Github . pezy/LeetCode<i class="fa fa-external-link"></i></span></li></ul><h3 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a>剑指 Offer</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poZWRhaGh0L0NvZGluZ0ludGVydmlld0NoaW5lc2Uy" title="https://github.com/zhedahht/CodingInterviewChinese2">Github . zhedahht/CodingInterviewChinese2<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dhdGllbWUvQ29kaW5nSW50ZXJ2aWV3cw==" title="https://github.com/gatieme/CodingInterviews">Github . gatieme/CodingInterviews<i class="fa fa-external-link"></i></span></li></ul><h3 id="Cracking-the-Coding-Interview-程序员面试金典"><a href="#Cracking-the-Coding-Interview-程序员面试金典" class="headerlink" title="Cracking the Coding Interview 程序员面试金典"></a>Cracking the Coding Interview 程序员面试金典</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NhcmVlcmN1cC9jdGNp" title="https://github.com/careercup/ctci">Github . careercup/ctci<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3RhL2NyYWNraW5nLXRoZS1jb2RpbmctaW50ZXJ2aWV3" title="https://www.nowcoder.com/ta/cracking-the-coding-interview">牛客网 . 程序员面试金典<i class="fa fa-external-link"></i></span></li></ul><h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2FjdGl2aXR5L29q" title="https://www.nowcoder.com/activity/oj">牛客网 . 在线编程专题<i class="fa fa-external-link"></i></span></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjA1NDkyNQ==" title="https://zhuanlan.zhihu.com/p/26054925">【构建操作系统】进程间通信<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd6aGVuMjA5L2FydGljbGUvZGV0YWlscy83ODI0OTI4OA==" title="https://blog.csdn.net/wangzhen209/article/details/78249288">C++ 高性能服务器网络框架设计细节<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxNTE2ODI3L2Fuc3dlci81MzU3Njc1NA==" title="https://www.zhihu.com/question/21516827/answer/53576754">epoll编程，如何实现高并发服务器开发？<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODU1MjU5MA==" title="https://zhuanlan.zhihu.com/p/38552590">如何实现高并发服务器开发<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3dlaWZ1L2FydGljbGUvZGV0YWlscy80NjgzNTQzNw==" title="https://blog.csdn.net/luoweifu/article/details/46835437">编程思想之多线程与多进程(4)——C++中的多线程<i class="fa fa-external-link"></i></span></p></blockquote><p>对于有线程系统：</p><ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul><p>对于无线程系统：</p><ul><li>进程是资源调度、分配的独立单位</li></ul><h4 id="进程之间的通信方式以及优缺点"><a href="#进程之间的通信方式以及优缺点" class="headerlink" title="进程之间的通信方式以及优缺点"></a>进程之间的通信方式以及优缺点</h4><ul><li>管道（PIPE）<ul><li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信<ul><li>优点：可以实现任意关系的进程间的通信</li><li>缺点：<ol><li>长期存于系统中，使用不当容易出错</li><li>缓冲区有限</li></ol></li></ul></li><li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul><li>优点：简单方便</li><li>缺点：<ol><li>局限于单向通信 </li><li>只能创建在它的进程以及其有亲缘关系的进程之间</li><li>缓冲区有限</li></ol></li></ul></li></ul></li><li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问<ul><li>优点：可以同步进程</li><li>缺点：信号量有限</li></ul></li><li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识<ul><li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li><li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul></li><li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul><li>优点：无须复制，快捷，信息量大</li><li>缺点：<ol><li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li><li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ol></li></ul></li><li>套接字（Socket）：可用于不同及其间的进程通信<ul><li>优点：<ol><li>传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>传输数据时间短，性能高</li><li>适合于客户端和服务器端之间信息实时交互</li><li>可以加密,数据安全性强</li></ol></li><li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li></ul></li></ul><h4 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h4><ul><li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul><li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持着是否已经释放锁。</li><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)<ul><li>无名线程信号量</li><li>命名线程信号量</li></ul></li><li>信号机制(Signal)：类似进程间的信号处理</li><li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li></ul><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  </p><blockquote><p>进程之间的通信方式以及优缺点来源于：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VqaWFmZWlfbmpnY3h5L2FydGljbGUvZGV0YWlscy83NzA5ODk3Nw==" title="http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977">进程线程面试题总结<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="进程之间私有和共享的资源"><a href="#进程之间私有和共享的资源" class="headerlink" title="进程之间私有和共享的资源"></a>进程之间私有和共享的资源</h4><ul><li>私有：地址空间、堆、全局变量、栈、寄存器</li><li>共享：代码段，公共数据，进程目录，进程 ID</li></ul><h4 id="线程之间私有和共享的资源"><a href="#线程之间私有和共享的资源" class="headerlink" title="线程之间私有和共享的资源"></a>线程之间私有和共享的资源</h4><ul><li>私有：线程栈，寄存器，程序寄存器</li><li>共享：堆，地址空间，全局变量，静态变量</li></ul><h4 id="多进程与多线程间的对比、优劣与选择"><a href="#多进程与多线程间的对比、优劣与选择" class="headerlink" title="多进程与多线程间的对比、优劣与选择"></a>多进程与多线程间的对比、优劣与选择</h4><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table><thead><tr><th>对比维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td><td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU 利用率低</td><td>占用内存少，切换简单，CPU 利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度很快</td><td>线程占优</td></tr><tr><td>编程、调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会互相影响</td><td>一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布式</td><td>进程占优</td></tr></tbody></table><h5 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h5><table><thead><tr><th>优劣</th><th>多进程</th><th>多线程</th></tr></thead><tbody><tr><td>优点</td><td>编程、调试简单，可靠性较高</td><td>创建、销毁、切换速度快，内存、资源占用小</td></tr><tr><td>缺点</td><td>创建、销毁、切换速度慢，内存、资源占用大</td><td>编程、调试复杂，可靠性较差</td></tr></tbody></table><h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><ul><li>需要频繁创建销毁的优先用线程</li><li>需要进行大量计算的优先使用线程</li><li>强相关的处理用线程，弱相关的处理用进程</li><li>可能要扩展到多机分布的用进程，多核分布的用线程</li><li>都满足需求的情况下，用你最熟悉、最拿手的方式</li></ul><blockquote><p>多进程与多线程间的对比、优劣与选择来自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2hlbmdsb25nNjY2L2FydGljbGUvZGV0YWlscy84NTU3MjE1" title="https://blog.csdn.net/lishenglong666/article/details/8557215">多线程还是多进程的选择及区别<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>将应用程序分为多个、独立的、单纯和的进程，它们运行在同一时刻，就像你可以同时进行网页浏览和文字处理，这些独立的进程可以通过所有常规的进程间通信渠道互相传递信息（信号、套接字、文件、管道等）。</li><li>操作系统在进程间提供的附加保护操作和更高级别的通信机制，意味着可以比线程更容易地编写安全的并发代码。</li><li>使用独立的进程实现并发，可以在网络连接的不同的机器上运行独立的进程，虽然这增加了通信成本，但在一个精心设计的系统上，这可能是一个提高并行可用行和提高性能的低成本方法。</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>这种进程之间的通信通常设置复杂，或是速度较慢，或两者兼备，因为操作系统通常在进程间提供了大量的保护，以避免一个进程不小心修改了属于另一个进程的数据。</li><li>运行多个进和所需的固有开销：启动进程需要时间，操作系统必须投入内部资源来管理进程。</li></ul><h4 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul><li>每个线程相互独立运行，且每个线程可以运行不同的指令序列。但进程中的所有的线程都共享相同的地址空间，并且从所有线程中访问大部分数据——全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。</li><li>共享的地址空间，以及缺少线程间的数据保护，使得使用多线程相关的开销远小于使用多进程，因为操作系统有更少的簿记要做。</li></ul><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul><li><p>虽然通常可以在进程之间共享内存，但这难以建立并且通常难以管理，因为同一数据的内存地址在不同的进程中也不尽相同。</p></li><li><p>共享内存的灵活性是有代价的：如果数据要被多个线程访问，那么必须确保当每个线程访问时所看到的数据是一致的。</p></li></ul><h3 id="Linux-内核的同步方式"><a href="#Linux-内核的同步方式" class="headerlink" title="Linux 内核的同步方式"></a>Linux 内核的同步方式</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</p><h4 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4><ul><li>原子操作</li><li>信号量（semaphore）</li><li>读写信号量（rw_semaphore）</li><li>自旋锁（spinlock）</li><li>大内核锁（BKL，Big Kernel Lock）</li><li>读写锁（rwlock）</li><li>大读者锁（brlock-Big Reader Lock）</li><li>读-拷贝修改(RCU，Read-Copy Update)</li><li>顺序锁（seqlock）</li></ul><blockquote><p>来自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLXN5bmNoL3BhcnQxLw==" title="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/">Linux 内核的同步机制，第 1 部分<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLXN5bmNoL3BhcnQyLw==" title="https://www.ibm.com/developerworks/cn/linux/l-synch/part2/">Linux 内核的同步机制，第 2 部分<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><ul><li>系统资源不足</li><li>资源分配不当</li><li>进程运行推进顺序不合适</li></ul><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ul><li>互斥</li><li>请求和保持</li><li>不剥夺</li><li>环路</li></ul><h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ul><li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li><li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li><li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li><li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li><li>有序资源分配法</li><li>银行家算法</li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li>Windows：FCB 表 + FAT + 位图</li><li>Unix：inode + 混合索引 + 成组链接</li></ul><h3 id="主机字节序与网络字节序"><a href="#主机字节序与网络字节序" class="headerlink" title="主机字节序与网络字节序"></a>主机字节序与网络字节序</h3><h4 id="主机字节序（CPU-字节序）"><a href="#主机字节序（CPU-字节序）" class="headerlink" title="主机字节序（CPU 字节序）"></a>主机字节序（CPU 字节序）</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：</p><ul><li>大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址</li><li>小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址</li></ul><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p>32 位整数 <code>0x12345678</code> 是从起始位置为 <code>0x00</code> 的地址开始存放，则：</p><table><thead><tr><th>内存地址</th><th>0x00</th><th>0x01</th><th>0x02</th><th>0x03</th></tr></thead><tbody><tr><td>大端</td><td>12</td><td>34</td><td>56</td><td>78</td></tr><tr><td>小端</td><td>78</td><td>56</td><td>34</td><td>12</td></tr></tbody></table><details><summary>大端小端图片</summary><p><img src="/images/imageProgramC/interview/CPU-Big-Endian.svg.png" alt="大端序"><br><img src="/images/imageProgramC/interview/CPU-Little-Endian.svg.png" alt="小端序"></p></details><h5 id="判断大端小端"><a href="#判断大端小端" class="headerlink" title="判断大端小端"></a>判断大端小端</h5><details><summary>判断大端小端</summary><p>可以这样判断自己 CPU 字节序是大端还是小端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*((<span class="keyword">char</span>*)&amp;i) == <span class="number">0x12</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"小端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h5 id="各架构处理器的字节序"><a href="#各架构处理器的字节序" class="headerlink" title="各架构处理器的字节序"></a>各架构处理器的字节序</h5><ul><li>x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；</li><li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；</li><li>ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。</li></ul><h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保重数据在不同主机之间传输时能够被正确解释。</p><p>网络字节顺序采用：大端（Big Endian）排列方式。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li>全局置换：在整个内存空间置换</li><li>局部置换：在本进程中进行置换</li></ul><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>全局：</p><ul><li>工作集算法</li><li>缺页率置换算法</li></ul><p>局部：</p><ul><li>最佳置换算法（OPT）</li><li>先进先出置换算法（FIFO）</li><li>最近最久未使用（LRU）算法</li><li>时钟（Clock）置换算法</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机经网络体系结构：</p><p><img src="/images/imageProgramC/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机经网络体系结构"></p><h3 id="各层作用及协议"><a href="#各层作用及协议" class="headerlink" title="各层作用及协议"></a>各层作用及协议</h3><table><thead><tr><th>分层</th><th>作用</th><th>协议</th></tr></thead><tbody><tr><td>物理层</td><td>通过媒介传输比特，确定机械及电气规范（比特 Bit）</td><td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td></tr><tr><td>数据链路层</td><td>将比特组装成帧和点到点的传递（帧 Frame）</td><td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td></tr><tr><td>网络层</td><td>负责数据包从源到宿的传递和网际互连（包 Packet）</td><td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td></tr><tr><td>运输层</td><td>提供端到端的可靠报文传递和错误恢复（ 段Segment）</td><td>TCP、UDP、SPX</td></tr><tr><td>会话层</td><td>建立、管理和终止会话（会话协议数据单元 SPDU）</td><td>NFS、SQL、NETBIOS、RPC</td></tr><tr><td>表示层</td><td>对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）</td><td>JPEG、MPEG、ASII</td></tr><tr><td>应用层</td><td>允许访问OSI环境的手段（应用协议数据单元 APDU）</td><td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td></tr></tbody></table><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul><li>传输数据的单位 ———— 比特</li><li>数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点）</li></ul><p>通道：</p><ul><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li><li>双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul><p>通道复用技术：</p><ul><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>主要信道：</p><ul><li>点对点信道</li><li>广播信道</li></ul><h4 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h4><ul><li>数据单元 ———— 帧</li></ul><p>三个基本问题：</p><ul><li>封装成帧：把网络层的 IP 数据报封装成帧，<code>SOH - 数据部分 - EOT</code></li><li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li><li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li></ul><p>点对点协议（Point-to-Point Protocol）：</p><ul><li>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</li></ul><h4 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h4><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li><li>ARP（Address Resolution Protocol，地址解析协议）</li><li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li></ul><h4 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP 网际协议"></a>IP 网际协议</h4><p>IP 地址分类：</p><ul><li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li></ul><table><thead><tr><th>IP 地址类别</th><th>网络号</th><th>网络范围</th><th>主机号</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A 类</td><td>8bit，第一位固定为 0</td><td>0 —— 127</td><td>24bit</td><td>1.0.0.0 —— 127.255.255.255</td></tr><tr><td>B 类</td><td>16bit，前两位固定为  10</td><td>128.0 —— 191.255</td><td>16bit</td><td>128.0.0.0 —— 191.255.255.255</td></tr><tr><td>C  类</td><td>24bit，前三位固定为  110</td><td>192.0.0 —— 223.255.255</td><td>8bit</td><td>192.0.0.0 —— 223.255.255.255</td></tr><tr><td>D  类</td><td>前四位固定为 1110，后面为多播地址</td><td></td><td></td><td></td></tr><tr><td>E  类</td><td>前五位固定为 11110，后面保留为今后所用</td><td></td><td></td><td></td></tr></tbody></table><p>IP 数据报格式：</p><p><img src="/images/imageProgramC/interview/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IP 数据报格式"></p><h4 id="ICMP-网际控制报文协议"><a href="#ICMP-网际控制报文协议" class="headerlink" title="ICMP 网际控制报文协议"></a>ICMP 网际控制报文协议</h4><p>ICMP 报文格式：</p><p><img src="/images/imageProgramC/interview/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="ICMP 报文格式"></p><p>应用：</p><ul><li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性<ul><li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li></ul></li></ul><h4 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h4><ul><li>RIP（Routing Information Protocol，路由信息协议）</li><li>OSPF（Open Sortest Path First，开放最短路径优先）</li></ul><h4 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h4><ul><li>BGP（Border Gateway Protocol，边界网关协议）</li></ul><h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><ul><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li><li>多播路由选择协议</li></ul><h4 id="VPN-和-NAT"><a href="#VPN-和-NAT" class="headerlink" title="VPN 和 NAT"></a>VPN 和 NAT</h4><ul><li>VPN（Virtual Private Network，虚拟专用网）</li><li>NAT（Network Address Translation，网络地址转换）</li></ul><h4 id="路由表包含什么？"><a href="#路由表包含什么？" class="headerlink" title="路由表包含什么？"></a>路由表包含什么？</h4><ol><li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li><li>子网掩码（subnet mask）：用来判断 IP 所属网络</li><li>下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: <code>0.0.0.0</code>, Netmask: <code>0.0.0.0</code>）指向自治系统的出口。</li></ol><p>根据应用和执行的不同，路由表可能含有如下附加信息：</p><ol><li>花费（Cost）：就是数据发送过程中通过路径所需要的花费。</li><li>路由的服务质量</li><li>路由中需要过滤的出/入连接列表</li></ol><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>协议：</p><ul><li>TCP（Transmission Control Protocol，传输控制协议）</li><li>UDP（User Datagram Protocol，用户数据报协议）</li></ul><p>端口：</p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>HTTPS</th><th>SNMP</th></tr></thead><tbody><tr><td>端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>443</td><td>161</td></tr></tbody></table><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li></ul><p>特征：</p><ul><li>面向连接</li><li>只能点对点（一对一）通信</li><li>可靠交互</li><li>全双工通信</li><li>面向字节流</li></ul><p>TCP 如何保证可靠传输：</p><ul><li>确认和超时重传</li><li>数据合理分片和排序</li><li>流量控制</li><li>拥塞控制</li><li>数据校验</li></ul><p>TCP 报文结构</p><p><img src="/images/imageProgramC/interview/TCP%E6%8A%A5%E6%96%87.png" alt="TCP 报文"></p><p>TCP 首部</p><p><img src="/images/imageProgramC/interview/TCP%E9%A6%96%E9%83%A8.png" alt="TCP 首部"></p><p>TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：</p><ul><li>URG：紧急比特（urgent），当 <code>URG＝1</code> 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li><li>ACK：确认比特（Acknowledge）。只有当 <code>ACK＝1</code> 时确认号字段才有效，代表这个封包为确认封包。当 <code>ACK＝0</code> 时，确认号无效。</li><li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li><li>RST：复位比特(Reset)，当 <code>RST＝1</code> 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li><li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li><li>FIN：终止比特(Final)，用来释放一个连接。当 <code>FIN＝1</code> 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li></ul><p>特征：</p><ul><li>无连接</li><li>尽最大努力交付</li><li>面向报文</li><li>没有拥塞控制</li><li>支持一对一、一对多、多对一、多对多的交互通信</li><li>首部开销小</li></ul><p>UDP 报文结构</p><p><img src="/images/imageProgramC/interview/UDP%E6%8A%A5%E6%96%87.png" alt="UDP 报文"></p><p>UDP 首部</p><p><img src="/images/imageProgramC/interview/UDP%E9%A6%96%E9%83%A8.png" alt="UDP 首部"></p><blockquote><p>TCP/UDP 图片来源于：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0plcnJ5QzgwODAvdW5kZXJzdGFuZC10Y3AtdWRw" title="https://github.com/JerryC8080/understand-tcp-udp">https://github.com/JerryC8080/understand-tcp-udp<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h4><ol><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li><li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ol><h4 id="TCP-黏包问题"><a href="#TCP-黏包问题" class="headerlink" title="TCP 黏包问题"></a>TCP 黏包问题</h4><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5><p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li><li>在数据包之间设置边界，如添加特殊符号 <code>\r\n</code> 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 <code>\r\n</code>，则会误判为消息的边界。</li><li>使用更加复杂的应用层协议。</li></ul><h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><details><summary>利用可变窗口进行流量控制</summary><p><img src="/images/imageProgramC/interview/%E5%88%A9%E7%94%A8%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B.png" alt></p></details><h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul><li>慢开始( slow-start )</li><li>拥塞避免( congestion avoidance )</li><li>快重传( fast retransmit )</li><li>快恢复( fast recovery )</li></ul><details><summary>TCP的拥塞控制图</summary><p><img src="/images/imageProgramC/interview/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png" alt><br><img src="/images/imageProgramC/interview/%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt><br><img src="/images/imageProgramC/interview/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p></details><h4 id="TCP-传输连接管理"><a href="#TCP-传输连接管理" class="headerlink" title="TCP 传输连接管理"></a>TCP 传输连接管理</h4><blockquote><p>因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvYmxvYi9tYXN0ZXIvaW1hZ2VzL1RDUC10cmFuc3BvcnQtY29ubmVjdGlvbi1tYW5hZ2VtZW50LnBuZw==" title="https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png">https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png<i class="fa fa-external-link"></i></span></p></blockquote><h5 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h5><p><img src="/images/imageProgramC/interview/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p><p>【TCP 建立连接全过程解释】</p><ol><li>客户端发送 SYN 给服务器，说明客户端请求建立连接；</li><li>服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；</li><li>客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；</li><li>服务端收到客户端的 ACK，连接已建立，可以数据传输。</li></ol><h5 id="TCP-为什么要进行三次握手？"><a href="#TCP-为什么要进行三次握手？" class="headerlink" title="TCP 为什么要进行三次握手？"></a>TCP 为什么要进行三次握手？</h5><p>【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIW1zZy9wb25nYmEva0Y2TzctTUZ4TTAvNVM3eklKNHlxS1VK" title="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ">Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}<i class="fa fa-external-link"></i></span></p></blockquote><p>【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI0ODUzNjMzL2Fuc3dlci8xMTUxNzMzODY=" title="https://www.zhihu.com/question/24853633/answer/115173386">知乎 . TCP 为什么是三次握手，而不是两次或四次？<i class="fa fa-external-link"></i></span></p></blockquote><p>【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvYmxvYi9tYXN0ZXIvaW1hZ2VzL1RDUC10cmFuc3BvcnQtY29ubmVjdGlvbi1tYW5hZ2VtZW50LnBuZw==" title="https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png">《计算机网络（第 7 版）-谢希仁》<i class="fa fa-external-link"></i></span></p></blockquote><h5 id="TCP-四次挥手释放连接"><a href="#TCP-四次挥手释放连接" class="headerlink" title="TCP 四次挥手释放连接"></a>TCP 四次挥手释放连接</h5><p><img src="/images/imageProgramC/interview/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p><p>【TCP 释放连接全过程解释】</p><ol><li>客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li><li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li><li>客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li><li>服务端继续发送之前没发完的数据给客户端；</li><li>服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li><li>客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）；</li><li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。</li></ol><h5 id="TCP-为什么要进行四次挥手？"><a href="#TCP-为什么要进行四次挥手？" class="headerlink" title="TCP 为什么要进行四次挥手？"></a>TCP 为什么要进行四次挥手？</h5><p>【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？</p><p>【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p><p>【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</p><p>【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p><p>【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</p><p>【答案三】</p><ol><li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li><li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li></ol><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L292ZXJzdGFjay9hcnRpY2xlL2RldGFpbHMvODgzMzg5NA==" title="https://blog.csdn.net/overstack/article/details/8833894">Time-wait状态(2MSL)一些理解<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="TCP-有限状态机"><a href="#TCP-有限状态机" class="headerlink" title="TCP 有限状态机"></a>TCP 有限状态机</h4><details><summary>TCP 有限状态机图片</summary><p><img src="/images/imageProgramC/interview/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="TCP 的有限状态机"></p></details><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zMzVkZTEzMjNjZTk=" title="https://www.jianshu.com/p/335de1323ce9">TCP和UDP详解<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hNWNmODFiMWE5NzY=" title="https://www.jianshu.com/p/a5cf81b1a976">HTTP、TCP、UDP详解<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><ul><li>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</li></ul><p>域名：</p><ul><li><code>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}</code>，如：<code>blog.huihut.com</code></li></ul><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><ul><li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li><li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</li></ul><h4 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h4><ul><li><p>TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p></li><li><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。</p></li><li><p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。</p></li><li><p>Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。</p></li></ul><h4 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h4><ul><li>WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问</li></ul><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><ul><li>URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）</li></ul><p>标准格式：</p><ul><li><code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li></ul><p>完整格式：</p><ul><li><code>协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li></ul><blockquote><p>其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项<br>如：<code>https://github.com/huihut/interview#cc</code></p></blockquote><h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p><p>请求方法</p><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>OPTIONS</td><td>请求一些选项信息，允许客户端查看服务器的性能</td></tr><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>HEAD</td><td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>状态码（Status-Code）</p><ul><li>1xx：表示通知信息，如请求收到了或正在进行处理<ul><li>100 Continue：继续，客户端应继续其请求</li><li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li></ul></li><li>2xx：表示成功，如接收或知道了<ul><li>200 OK: 请求成功</li></ul></li><li>3xx：表示重定向，如要完成请求还必须采取进一步的行动<ul><li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li></ul></li><li>4xx：表示客户的差错，如请求中有错误的语法或不能完成<ul><li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li><li>401 Unauthorized: 请求要求用户的身份认证</li><li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li><li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li><li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li></ul></li><li>5xx：表示服务器的差错，如服务器失效无法完成请求<ul><li>500 Internal Server Error: 服务器内部错误，无法完成请求</li><li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li><li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li></ul></li></ul><blockquote><p>更多状态码：<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2h0dHAvaHR0cC1zdGF0dXMtY29kZXMuaHRtbA==" title="http://www.runoob.com/http/http-status-codes.html">菜鸟教程 . HTTP状态码<i class="fa fa-external-link"></i></span></p></blockquote><h5 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h5><ul><li>SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</li><li>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：<ul><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ul></li><li>SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2t5bmV0L2FyY2hpdmUvMjAxMC8xMi8xMi8xOTAzOTQ5Lmh0bWw=" title="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket 编程（不限 Linux）<i class="fa fa-external-link"></i></span></p><p><img src="/images/imageProgramC/interview/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF.jpg" alt="Socket 客户端服务器通讯"></p><h4 id="Socket-中的-read-、write-函数"><a href="#Socket-中的-read-、write-函数" class="headerlink" title="Socket 中的 read()、write() 函数"></a>Socket 中的 read()、write() 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><h5 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h5><ul><li>read 函数是负责从 fd 中读取内容。</li><li>当读成功时，read 返回实际所读的字节数。</li><li>如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。</li><li>如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。</li></ul><h5 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h5><ul><li>write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。</li><li>成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。</li><li>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</li><li>（1）write 的返回值大于 0，表示写了部分或者是全部的数据。</li><li>（2）返回的值小于 0，此时出现了错误。</li><li>如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。</li></ul><h4 id="Socket-中-TCP-的三次握手建立连接"><a href="#Socket-中-TCP-的三次握手建立连接" class="headerlink" title="Socket 中 TCP 的三次握手建立连接"></a>Socket 中 TCP 的三次握手建立连接</h4><p>我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</p><ol><li>客户端向服务器发送一个 SYN J</li><li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1</li><li>客户端再想服务器发一个确认 ACK K+1</li></ol><p>只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png" alt="socket 中发送的 TCP 三次握手"></p><p>从图中可以看出：</p><ol><li>当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；  </li><li>服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；  </li><li>客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；  </li><li>服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。</li></ol><h4 id="Socket-中-TCP-的四次握手释放连接"><a href="#Socket-中-TCP-的四次握手释放连接" class="headerlink" title="Socket 中 TCP 的四次握手释放连接"></a>Socket 中 TCP 的四次握手释放连接</h4><p>上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png" alt="socket 中发送的 TCP 四次握手"></p><p>图示过程如下：</p><ol><li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；</li><li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；</li><li>接收到这个 FIN 的源发送端 TCP 对它进行确认。</li></ol><p>这样每个方向上都有一个 FIN 和 ACK。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>数据库事务四大特性：原子性、一致性、分离性、持久性</li><li>数据库索引：顺序索引、B+ 树索引、hash 索引<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvYXJ0aWNsZXMvdGhlb3J5LW9mLW15c3FsLWluZGV4Lmh0bWw=" title="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vc3FsL3NxbF9jb25zdHJhaW50cy5hc3A=" title="http://www.w3school.com.cn/sql/sql_constraints.asp">SQL 约束 (Constraints)<i class="fa fa-external-link"></i></span></li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li>第一范式（1NF）：属性（字段）是最小单位不可再分</li><li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）</li><li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）</li><li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）</li><li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p>各大设计模式例子参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvbHVtbi9kZXRhaWxzLzE1MzkyLmh0bWw=" title="https://blog.csdn.net/column/details/15392.html">CSDN专栏 . C++ 设计模式<i class="fa fa-external-link"></i></span> 系列博文</p></blockquote><p><a href="DesignPattern">设计模式工程目录</a></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><a href="DesignPattern/SingletonPattern">单例模式例子</a></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><a href="DesignPattern/AbstractFactoryPattern">抽象工厂模式例子</a></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><a href="DesignPattern/AdapterPattern">适配器模式例子</a></p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><a href="DesignPattern/BridgePattern">桥接模式例子</a></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><a href="DesignPattern/ObserverPattern">观察者模式例子</a></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ul><li>单一职责原则（SRP，Single Responsibility Principle）</li><li>里氏替换原则（LSP，Liskov Substitution Principle）</li><li>依赖倒置原则（DIP，Dependence Inversion Principle）</li><li>接口隔离原则（ISP，Interface Segregation Principle）</li><li>迪米特法则（LoD，Law of Demeter）</li><li>开放封闭原则（OCP，Open Close Principle）</li></ul><h2 id="链接装载库"><a href="#链接装载库" class="headerlink" title="链接装载库"></a>链接装载库</h2><h3 id="内存、栈、堆"><a href="#内存、栈、堆" class="headerlink" title="内存、栈、堆"></a>内存、栈、堆</h3><p>一般应用程序内存空间有如下区域：</p><ul><li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文</li><li>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</li><li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里</li><li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：</p><ul><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>保存上下文：包括函数调用前后需要保持不变的寄存器</li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆分配算法：</p><ul><li>空闲链表（Free List）</li><li>位图（Bitmap）</li><li>对象池</li></ul><h4 id="“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”"><a href="#“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”" class="headerlink" title="“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”"></a>“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”</h4><p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。</p><p>普遍原因：</p><ul><li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针</li><li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</li></ul><h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><h4 id="各平台文件格式"><a href="#各平台文件格式" class="headerlink" title="各平台文件格式"></a>各平台文件格式</h4><table><thead><tr><th>平台</th><th>可执行文件</th><th>目标文件</th><th>动态库/共享对象</th><th>静态库</th></tr></thead><tbody><tr><td>Windows</td><td>exe</td><td>obj</td><td>dll</td><td>lib</td></tr><tr><td>Unix/Linux</td><td>ELF、out</td><td>o</td><td>so</td><td>a</td></tr><tr><td>Mac</td><td>Mach-O</td><td>o</td><td>dylib、tbd、framework</td><td>a、framework</td></tr></tbody></table><h4 id="编译链接过程"><a href="#编译链接过程" class="headerlink" title="编译链接过程"></a>编译链接过程</h4><ol><li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li><li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）</li><li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）</li><li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</li></ol><blockquote><p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</p></blockquote><blockquote><p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</p></blockquote><h4 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h4><p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p><blockquote><p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</p></blockquote><h5 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h5><ul><li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式</li><li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式</li><li>Intel/Microsoft 的 OMF（Object Module Format）</li><li>Unix 的 <code>a.out</code> 格式</li><li>MS-DOS 的 <code>.COM</code> 格式</li></ul><blockquote><p>PE 和 ELF 都是 COFF（Common File Format）的变种</p></blockquote><h5 id="目标文件存储结构"><a href="#目标文件存储结构" class="headerlink" title="目标文件存储结构"></a>目标文件存储结构</h5><table><thead><tr><th>段</th><th>功能</th></tr></thead><tbody><tr><td>File Header</td><td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td></tr><tr><td>.text section</td><td>代码段，执行语句编译成的机器代码</td></tr><tr><td>.data section</td><td>数据段，已初始化的全局变量和局部静态变量</td></tr><tr><td>.bss section</td><td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td></tr><tr><td>.rodata section</td><td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td></tr><tr><td>.comment section</td><td>注释信息段，存放编译器版本信息</td></tr><tr><td>.note.GNU-stack section</td><td>堆栈提示段</td></tr></tbody></table><blockquote><p>其他段略</p></blockquote><h4 id="链接的接口————符号"><a href="#链接的接口————符号" class="headerlink" title="链接的接口————符号"></a>链接的接口————符号</h4><p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p><p>如下符号表（Symbol Table）：</p><table><thead><tr><th>Symbol（符号名）</th><th>Symbol Value （地址）</th></tr></thead><tbody><tr><td>main</td><td>0x100</td></tr><tr><td>Add</td><td>0x123</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h3 id="Linux-的共享库（Shared-Library）"><a href="#Linux-的共享库（Shared-Library）" class="headerlink" title="Linux 的共享库（Shared Library）"></a>Linux 的共享库（Shared Library）</h3><p>Linux 下的共享库就是普通的 ELF 共享对象。</p><p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p><code>libname.so.x.y.z</code></p><ul><li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译</li><li>y：次版本号，高版本号向后兼容低版本号</li><li>z：发布版本号，不对接口进行更改，完全兼容</li></ul><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p><ul><li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li><li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li><li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li></ul><blockquote><p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p></blockquote><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul><li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li><li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li><li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li></ul><h4 id="so-共享库的编写"><a href="#so-共享库的编写" class="headerlink" title="so 共享库的编写"></a>so 共享库的编写</h4><details><summary>使用 CLion 编写共享库</summary><p>创建一个名为 MySharedLib 的共享库</p><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(MySharedLib SHARED library.cpp library.h)</span><br></pre></td></tr></table></figure><p>library.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 Hello World!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可变模版参数求和</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Types&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T first, Types ... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + sum&lt;T&gt;(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>library.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="so-共享库的使用（被可执行项目调用）"><a href="#so-共享库的使用（被可执行项目调用）" class="headerlink" title="so 共享库的使用（被可执行项目调用）"></a>so 共享库的使用（被可执行项目调用）</h4><details><summary>使用 CLion 调用共享库</summary><p>创建一个名为 TestSharedLib 的可执行项目</p><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(TestSharedLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++11 编译</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件路径</span></span><br><span class="line"><span class="keyword">set</span>(INC_DIR /home/xx/code/clion/MySharedLib)</span><br><span class="line"><span class="comment"># 库文件路径</span></span><br><span class="line"><span class="keyword">set</span>(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;INC_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(TestSharedLib main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 MySharedLib 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(TestSharedLib MySharedLib)</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 + 3 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1 + 2 = 3</span><br><span class="line">1 + 2 + 3 = 6</span><br></pre></td></tr></table></figure></details><h3 id="运行库（Runtime-Library）"><a href="#运行库（Runtime-Library）" class="headerlink" title="运行库（Runtime Library）"></a>运行库（Runtime Library）</h3><h4 id="典型程序运行步骤"><a href="#典型程序运行步骤" class="headerlink" title="典型程序运行步骤"></a>典型程序运行步骤</h4><ol><li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）</li><li>入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。</li><li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。</li><li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。</li></ol><blockquote><p>一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。</p></blockquote><h4 id="glibc-入口"><a href="#glibc-入口" class="headerlink" title="glibc 入口"></a>glibc 入口</h4><p><code>_start -&gt; __libc_start_main -&gt; exit -&gt; _exit</code></p><p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。</p><h4 id="MSVC-CRT-入口"><a href="#MSVC-CRT-入口" class="headerlink" title="MSVC CRT 入口"></a>MSVC CRT 入口</h4><p><code>int mainCRTStartup(void)</code></p><p>执行如下操作：</p><ol><li>初始化和 OS 版本有关的全局变量。</li><li>初始化堆。</li><li>初始化 I/O。</li><li>获取命令行参数和环境变量。</li><li>初始化 C 库的一些数据。</li><li>调用 main 并记录返回值。</li><li>检查错误并将 main 的返回值返回。</li></ol><h4 id="C-语言运行库（CRT）"><a href="#C-语言运行库（CRT）" class="headerlink" title="C 语言运行库（CRT）"></a>C 语言运行库（CRT）</h4><p>大致包含如下功能：</p><ul><li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li><li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。</li><li>I/O：I/O 功能的封装和实现。</li><li>堆：堆的封装和实现。</li><li>语言实现：语言中一些特殊功能的实现。</li><li>调试：实现调试功能的代码。</li></ul><h4 id="C语言标准库（ANSI-C）"><a href="#C语言标准库（ANSI-C）" class="headerlink" title="C语言标准库（ANSI C）"></a>C语言标准库（ANSI C）</h4><p>包含：</p><ul><li>标准输入输出（stdio.h）</li><li>文件操作（stdio.h）</li><li>字符操作（ctype.h）</li><li>字符串操作（string.h）</li><li>数学函数（math.h）</li><li>资源管理（stdlib.h）</li><li>格式转换（stdlib.h）</li><li>时间/日期（time.h）</li><li>断言（assert.h）</li><li>各种类型上的常数（limits.h &amp; float.h）</li><li>变长参数（stdarg.h）</li><li>非局部跳转（setjmp.h）</li></ul><h2 id="回调函数和钩子函数"><a href="#回调函数和钩子函数" class="headerlink" title="回调函数和钩子函数"></a>回调函数和钩子函数</h2><h3 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a>什么是回调函数？</h3><p>简而言之，回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。 </p><h4 id="为什么要使用回调函数？"><a href="#为什么要使用回调函数？" class="headerlink" title="为什么要使用回调函数？"></a>为什么要使用回调函数？</h4><p>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为 int ）的被调用函数。 </p><p>如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、 shell 排序、 shake 排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（ int 、 float 、 string ），此时，该怎么办呢？可以使用函数指针，并进行回调。 </p><p>回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API 使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。 </p><p>另一个使用回调机制的 API 函数是 EnumWindow() ，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。 EnumWindow() 并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。 </p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>不管怎么说，<strong>回调函数是继续自 C 语言的，因而，在 C++ 中，应只在与 C 代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在 C++ 中应使用虚拟方法或函数符（ functor ），而不是回调函数</strong>。</p><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p>也可以这样，更容易理解：回调函数就好像是一个中断处理函数，系统在符合你设定的条件时自动调用。</p><p>为此，你需要做三件事：</p><ol><li><p>声明；</p></li><li><p>定义；</p></li><li><p>设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用。</p></li></ol><p>声明和定义时应注意：回调函数由系统调用，所以可以认为它属于WINDOWS系统，不要把它当作你的某个类的成员函数</p><p>回调函数是一个程序员不能显式调用的函数；通过将回调函数的地址传给调用者从而实现调用。回调函数使用是必要的，在我们想通过一个统一接口实现不同的内容，这时用回掉函数非常合适。比如，我们为几个不同的设备分别写了不同的显示函数：void TVshow(); void ComputerShow(); void NoteBookShow()…等等。这是我们想用一个统一的显示函数，我们这时就可以用回掉函数了。void show(void (*ptr)()); 使用时根据所传入的参数不同而调用不同的回调函数。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy52b2lkY24uY29tL2FydGljbGUvcC1jcGl0dWdwdS1iY2cuaHRtbA==" title="http://www.voidcn.com/article/p-cpitugpu-bcg.html">C语言中的回调函数<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODI5MzkwMg==" title="https://segmentfault.com/a/1190000008293902">一文搞懂C语言回调函数<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvY2hvL2FydGljbGUvZGV0YWlscy81MTU4MzExMg==" title="https://blog.csdn.net/socho/article/details/51583112">c语言实现回调函数<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2Nwcm9ncmFtbWluZy9jLWZ1bi1wb2ludGVyLWNhbGxiYWNrLmh0bWw=" title="http://www.runoob.com/cprogramming/c-fun-pointer-callback.html">函数指针<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="什么是钩子函数？"><a href="#什么是钩子函数？" class="headerlink" title="什么是钩子函数？"></a>什么是钩子函数？</h3><p>钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。对每种类型的钩子由系统来维护一个钩子链，最近安装的钩子放在链的开始，而最先安装的钩子放在最后，也就是后加入的先获得控制权。</p><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>钩子函数是Windows消息处理机制的一部分，通过设置“钩子”，应用程序可以在系统级对所有消息、事件进行过滤，访问在正常情况下无法访问的消息。钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol><li><p>局部钩子：仅钩挂您自己进程的事件。</p></li><li><p>远程钩子：可以钩挂自己进程或其他进程的事件，</p><p>远程钩子又分为两种：</p><ul><li>一种是系统级的全局钩子，</li><li>一种是线程级的钩子。</li></ul><p>全局钩子函数需要定义在 DLL 中，线程级的钩子中经常用到 GetCurrentThreadID 函数来获取当前线程的ID。</p></li></ol><h4 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h4><p>当创建一个钩子时，WINDOWS会先在内存中创建一个数据结构，该数据结构包含了钩子的相关信息，然后把该结构体加到已经存在的钩子链表中去。新的钩子将加到老的前面。当一个事件发生时，如果安装的是一个局部钩子，自己进程中的钩子函数将被调用。如果是一个远程钩子，系统就必须把钩子函数插入到其他进程的地址空间，要做到这一点要求钩子函数必须在一个动态链接库中，所以如果想要使用远程钩子，就必须把该钩子函数放到动态链接库中去。</p><p>两个例外：</p><ul><li>工作日志钩子</li><li>工作日志回放钩子。</li></ul><p>这两个钩子的钩子函数必须在安装钩子的线程中。原因是：</p><ul><li>这两个钩子是用来监控比较底层的硬件事件的，既然是记录和回放，所有的事件就当然都是有先后次序的。所以如果把回调函数放在DLL中，输入的事件被放在几个线程中记录，所以我们无法保证得到正确的次序。</li></ul><p>解决办法：把钩子函数放到单个的线程中，譬如安装钩子的线程。</p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8xMjgxNDUuaHRt" title="https://www.jb51.net/article/128145.htm">浅谈c++ hook 钩子的使用介绍<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="异步消息的传递－回调机制"><a href="#异步消息的传递－回调机制" class="headerlink" title="异步消息的传递－回调机制"></a>异步消息的传递－回调机制</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWNhbGxiYWNrL2luZGV4Lmh0bWw=" title="https://www.ibm.com/developerworks/cn/linux/l-callback/index.html">异步消息的传递－回调机制<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="什么是回调"><a href="#什么是回调" class="headerlink" title="什么是回调"></a>什么是回调</h4><p>软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：</p><ul><li>同步调用</li><li>回调</li><li>异步调用</li></ul><p>同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。</p><p><strong>回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知</strong>。</p><p>同步调用是三者当中最简单的，而回调又常常是异步调用的基础，因此，下面我们着重讨论回调机制在不同软件架构中的实现。</p><img src="/images/imageProgramC/interview/回调机制-01.gif"><p>对于不同类型的语言（如结构化语言和对象语言）、平台（Win32、JDK）或构架（CORBA、DCOM、WebService），客户和服务的交互除了同步方式以外，都需要具备一定的异步通知机制，让服务方（或接口提供方）在某些情况下能够主动通知客户，而回调是实现异步的一个最简捷的途径。</p><p>对于一般的结构化语言，可以通过回调函数来实现回调。回调函数也是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数。</p><p>在面向对象的语言中，回调则是通过接口或抽象类来实现的，我们把实现这种接口的类成为回调类，回调类的对象成为回调对象。对于象C++或Object Pascal这些兼容了过程特性的对象语言，不仅提供了回调对象、回调方法等特性，也能兼容过程语言的回调函数机制。</p><p>Windows平台的消息机制也可以看作是回调的一种应用，我们通过系统提供的接口注册消息处理函数（即回调函数），从而实现接收、处理消息的目的。由于Windows平台的API是用C语言来构建的，我们可以认为它也是回调函数的一个特例。</p><p>对于分布式组件代理体系CORBA，异步处理有多种方式，如回调、事件服务、通知服务等。事件服务和通知服务是CORBA用来处理异步消息的标准服务，他们主要负责消息的处理、派发、维护等工作。对一些简单的异步处理过程，我们可以通过回调机制来实现。</p><p>下面我们集中比较具有代表性的语言（C、Object Pascal）和架构（CORBA）来分析回调的实现方式、具体作用等。</p><h4 id="过程语言中的回调（C）"><a href="#过程语言中的回调（C）" class="headerlink" title="过程语言中的回调（C）"></a>过程语言中的回调（C）</h4><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><p>回调在C语言中是通过函数指针来实现的，通过将回调函数的地址传给被调函数从而实现回调。因此，要实现回调，必须首先定义函数指针，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void Func(char *s)；// 函数原型</span><br><span class="line"><span class="keyword">void</span> (*pFunc) (<span class="keyword">char</span> *);<span class="comment">//函数指针</span></span><br></pre></td></tr></table></figure><p>可以看出，函数的定义和函数指针的定义非常类似。</p><p>一般的话，为了简化函数指针类型的变量定义，提高程序的可读性，我们需要把函数指针类型自定义一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pcb)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>回调函数可以象普通函数一样被程序调用，但是只有它被当作参数传递给被调函数时才能称作回调函数。</p><p>被调函数的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetCallBack</span><span class="params">(pcb callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户在调用上面的函数时，需要自己实现一个pcb类型的回调函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fCallback</span><span class="params">(<span class="keyword">char</span> *s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* do something */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 然后，就可以直接把fCallback当作一个变量传递给GetCallBack,</span></span><br><span class="line">GetCallBack（fCallback）;</span><br></pre></td></tr></table></figure><p>如果赋了不同的值给该参数，那么调用者将调用不同地址的函数。赋值可以发生在运行时，这样使你能实现动态绑定。</p><h5 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h5><p>到目前为止，我们只讨论了函数指针及回调而没有去注意 ANSI C/C++ 的编译器规范。许多编译器有几种调用规范。如在Visual C++中，可以在函数类型前加 <code>_cdecl</code>，<code>_stdcall</code> 或者 <code>_pascal</code> 来表示其调用规范（默认为 <code>_cdecl</code>）。C++ Builder也支持 <code>_fastcall</code> 调用规范。调用规范影响编译器产生的给定函数名，参数传递的顺序（从右到左或从左到右），堆栈清理责任（调用者或者被调用者）以及参数传递机制（堆栈，CPU寄存器等）。</p><p>将调用规范看成是函数类型的一部分是很重要的；不能用不兼容的调用规范将地址赋值给函数指针。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用函数是以 int 为参数，以 int 为返回值</span></span><br><span class="line">__<span class="function">stdcall <span class="keyword">int</span> <span class="title">callee</span><span class="params">(<span class="keyword">int</span>)</span></span>; </span><br><span class="line"><span class="comment">// 调用函数以函数指针为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">caller</span><span class="params">( __cdecl <span class="keyword">int</span>(*ptr)(<span class="keyword">int</span>))</span></span>; </span><br><span class="line"><span class="comment">// 在 p 中企图存储被调用函数地址的非法操作</span></span><br><span class="line">__<span class="function">cdecl <span class="title">int</span><span class="params">(*p)</span><span class="params">(<span class="keyword">int</span>)</span> </span>= callee; <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure><p>指针 p 和 callee() 的类型不兼容，因为它们有不同的调用规范。因此不能将被调用者的地址赋值给指针p，尽管两者有相同的返回值和参数列</p><h5 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h5><p>C 语言的标准库函数中很多地方就采用了回调函数来让用户定制处理过程。如常用的快速排序函数、二分搜索函数等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> width, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> (_USERENTRY *fcmp)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">// 二分搜索函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bsearch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *base, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> (_USERENTRY *fcmp)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><p>其中 fcmp 就是一个回调函数的变量。</p><p>下面给出一个具体的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">5</span>] = &#123; <span class="number">54</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">22</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x;</span><br><span class="line">   qsort((<span class="keyword">void</span> *)<span class="built_in">list</span>, <span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="built_in">list</span>[<span class="number">0</span>]), sort_function);</span><br><span class="line">   <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%i\n"</span>, <span class="built_in">list</span>[x]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> *(<span class="keyword">int</span>*)a-*(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回调在分布式计算中的应用（CORBA）"><a href="#回调在分布式计算中的应用（CORBA）" class="headerlink" title="回调在分布式计算中的应用（CORBA）"></a>回调在分布式计算中的应用（CORBA）</h4><h5 id="回调接口模型"><a href="#回调接口模型" class="headerlink" title="回调接口模型"></a>回调接口模型</h5><p>CORBA 的消息传递机制有很多种，比如回调接口、事件服务和通知服务等。回调接口的原理很简单，CORBA 客户和服务器都具有双重角色，即充当服务器也是客户客户。</p><p>回调接口的反向调用与正向调用往往是同时进行的，如果服务端多次调用该回调接口，那么这个回调接口就变成异步接口了。因此，回调接口在 CORBA 中常常充当事件注册的用途，客户端调用该注册函数时，客户函数就是回调函数，在此后的调用中，由于不需要客户端的主动参与，该函数就是实现了一种异步机制。</p><p>从 CORBA 规范我们知道，一个 CORBA 接口在服务端和客户端有不同的表现形式，在客户端一般使用桩（Stub）文件，服务端则用到框架（Skeleton）文件，接口的规格采用 IDL 来定义。而回调函数的引入，使得服务端和客户端都需要实现一定的桩和框架。下面是回调接口的实现模型：</p><img src="/images/imageProgramC/interview/回调机制-02.gif"><p>下面给出了一个使用回调的接口文件，服务端需要实现 Server 接口的框架，客户端需要实现 CallBack 的框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module cb</span><br><span class="line">&#123;</span><br><span class="line">    interface CallBack;</span><br><span class="line">    interface Server;</span><br><span class="line">    interface CallBack </span><br><span class="line">    &#123;</span><br><span class="line">    void OnEvent(in long Source,in long msg);</span><br><span class="line">    &#125;;</span><br><span class="line">    interface Server </span><br><span class="line">    &#123;</span><br><span class="line">        long RegisterCB(in CallBack cb);</span><br><span class="line">        void UnRegisterCB(in long hCb);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户端首先通过同步方式调用服务端的接口 RegistCB，用来注册回调接口 CallBack。服务端收到该请求以后，就会保留该接口引用，如果发生某种事件需要向客户端通知的时候就通过该引用调用客户方的 OnEvent 函数，以便对方及时处理。</p><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><h3 id="避免野指针的方法"><a href="#避免野指针的方法" class="headerlink" title="避免野指针的方法"></a>避免野指针的方法</h3><p>为了防止野指针带来的灾难，建议指针在定义时给一个初值，比如“NULL”，意思是不指向任何内存地址。然后再使用malloc函数给指针分配一块存储空间。</p><details><summary>避免野指针的方法</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"123"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="literal">NULL</span>; <span class="comment">//str2 赋初值，不指向任何内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2的值是: %u\n"</span>, str2);</span><br><span class="line">    </span><br><span class="line">    str2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2被分配的地址是: %u\n"</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(str2, str1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2指向的字符串是: %s\n"</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != str2)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">free</span>(str2); <span class="comment">// 主动释放分配给str2的内存</span></span><br><span class="line">    str2 = <span class="literal">NULL</span>; <span class="comment">// 让str2不指向任何内存    </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9qdWx5X3YvYXJ0aWNsZS9kZXRhaWxzLzY2ODU5NjI=" title="http://blog.csdn.net/v_july_v/article/details/6685962"> 海量数据处理面试题集锦<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9KVUxZX3YvYXJ0aWNsZS9kZXRhaWxzLzYyNzk0OTg=" title="http://blog.csdn.net/v_JULY_v/article/details/6279498">十道海量数据处理面试题与十个方法大总结<i class="fa fa-external-link"></i></span></li></ul><h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy55dW5saWFvaW0uY29tL2ltLzE4NjkuaHRtbA==" title="http://www.yunliaoim.com/im/1869.html">最全实时音视频开发要用到的开源工程汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlYnJ0Yy5vcmcuY24vMTglRTQlQjglQUElRTUlQUUlOUUlRTYlOTclQjYlRTklOUYlQjMlRTglQTclODYlRTklQTIlOTElRTUlQkMlODAlRTUlOEYlOTElRTQlQjglQUQlRTQlQkMlOUElRTclOTQlQTglRTUlODglQjAlRTUlQkMlODAlRTYlQkElOTAlRTklQTElQjklRTclOUIlQUUv" title="http://webrtc.org.cn/18%E4%B8%AA%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BC%9A%E7%94%A8%E5%88%B0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">18个实时音视频开发中会用到开源项目<i class="fa fa-external-link"></i></span></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9ic19mYXEuaHRtbA==" title="http://www.stroustrup.com/bs_faq.html">Bjarne Stroustrup 的常见问题<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9ic19mYXEyLmh0bWw=" title="http://www.stroustrup.com/bs_faq2.html">Bjarne Stroustrup 的 C++ 风格和技巧常见问题<i class="fa fa-external-link"></i></span></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul><li>《C++ Primer》</li><li>《Effective C++》</li><li>《More Effective C++》</li><li>《深度探索 C++ 对象模型》</li><li>《深入理解 C++11》</li><li>《STL 源码剖析》</li></ul><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><ul><li>《剑指 Offer》</li><li>《编程珠玑》</li><li>《程序员面试宝典》</li></ul><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul><li>《深入理解计算机系统》</li><li>《Windows 核心编程》</li><li>《Unix 环境高级编程》</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>《Unix 网络编程》</li><li>《TCP/IP 详解》</li></ul><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li>《程序员的自我修养》</li></ul><h2 id="复习刷题网站"><a href="#复习刷题网站" class="headerlink" title="复习刷题网站"></a>复习刷题网站</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20v" title="https://leetcode.com/">leetcode<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIubmV0Lw==" title="https://www.nowcoder.net/">牛客网<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW1vb2MuY29tLw==" title="https://www.imooc.com/">慕课网<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tLw==" title="http://www.runoob.com/">菜鸟教程<i class="fa fa-external-link"></i></span></li></ul><h2 id="招聘时间岗位"><a href="#招聘时间岗位" class="headerlink" title="招聘时间岗位"></a>招聘时间岗位</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2FjdGl2aXR5L2NhbXB1czIwMTk=" title="https://www.nowcoder.com/activity/campus2019">牛客网 . 2019 IT名企校招指南<i class="fa fa-external-link"></i></span></li></ul><h2 id="面试题目经验"><a href="#面试题目经验" class="headerlink" title="面试题目经验"></a>面试题目经验</h2><h3 id="牛客网-1"><a href="#牛客网-1" class="headerlink" title="牛客网"></a>牛客网</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvMTI4MDU=" title="https://www.nowcoder.com/discuss/12805">牛客网 . 2017秋季校园招聘笔经面经专题汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvMjUyNjg=" title="https://www.nowcoder.com/discuss/25268">牛客网 . 史上最全2017春招面经大合集！！<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvNTc5Nzg=" title="https://www.nowcoder.com/discuss/57978">牛客网 . 面试题干货在此<i class="fa fa-external-link"></i></span></li></ul><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI5NjkzMDE2" title="https://www.zhihu.com/question/29693016">知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI0OTY0OTg3" title="https://www.zhihu.com/question/24964987">知乎 . 互联网公司最常见的面试算法题有哪些？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMTg0ODU3" title="https://www.zhihu.com/question/20184857">知乎 . 面试 C++ 程序员，什么样的问题是好问题？<i class="fa fa-external-link"></i></span></li></ul><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGp6Y29tZS9hcnRpY2xlL2RldGFpbHMvNTc0MTU4" title="http://blog.csdn.net/ljzcome/article/details/574158">CSDN . 全面整理的C++面试题<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdjaGFvOTkvYXJ0aWNsZS9kZXRhaWxzLzc0NTI0ODA3P2xvY2F0aW9uTnVtPTYmZnBzPTE=" title="http://blog.csdn.net/Xiongchao99/article/details/74524807?locationNum=6&fps=1">CSDN . 百度研发类面试题（C++方向）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmFraW5lL2FydGljbGUvZGV0YWlscy81MTMyMTU0NA==" title="http://blog.csdn.net/fakine/article/details/51321544">CSDN . c++常见面试题30道<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb25ldmVyX3NheV9sb3ZlL2FydGljbGUvZGV0YWlscy81MTIyMzg4Ng==" title="http://blog.csdn.net/onever_say_love/article/details/51223886">CSDN . 腾讯2016实习生面试经验（已经拿到offer)<i class="fa fa-external-link"></i></span></li></ul><h3 id="cnblogs"><a href="#cnblogs" class="headerlink" title="cnblogs"></a>cnblogs</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vWTFGb2N1cy9wLzY3MDcxMjEuaHRtbA==" title="https://www.cnblogs.com/Y1Focus/p/6707121.html">cnblogs . C++面试集锦( 面试被问到的问题 )<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZmFuZ3l1a3Vhbi9hcmNoaXZlLzIwMTAvMDkvMTgvMTgyOTg3MS5odG1s" title="https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html">cnblogs . C/C++ 笔试、面试题目大汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTFVPNzcvcC81NzcxMjM3Lmh0bWw=" title="https://www.cnblogs.com/LUO77/p/5771237.html">cnblogs . 常见C++面试题及基本知识点总结（一）<i class="fa fa-external-link"></i></span></li></ul><h3 id="Segmentfault"><a href="#Segmentfault" class="headerlink" title="Segmentfault"></a>Segmentfault</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwMzc0NTUyOQ==" title="https://segmentfault.com/a/1190000003745529">segmentfault . C++常见面试问题总结<i class="fa fa-external-link"></i></span></li></ul><h3 id="HTTP相关知识"><a href="#HTTP相关知识" class="headerlink" title="HTTP相关知识"></a>HTTP相关知识</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjM2ODczMg==" title="https://segmentfault.com/a/1190000012368732">你必须知道的HTTP基本概念<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9pbXF1cXUuY29tL3Bvc3QvbmV0d29yay1wcm90b2NvbC1pbi1icm93c2VyLmh0bWw=" title="https://imququ.com/post/network-protocol-in-browser.html">浏览器中常见网络协议介绍<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDA3MzE3" title="https://cloud.tencent.com/developer/article/1007317">WebRTC介绍及简单应用<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2htYWkvYXJ0aWNsZS9kZXRhaWxzLzY5NjgxNTk1" title="https://blog.csdn.net/fishmai/article/details/69681595">WebRTC架构简介<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWIxNGJkOWNlNTFkNDUwNjg4MTM0NDMw" title="https://juejin.im/entry/5b14bd9ce51d450688134430">了不起的WebRTC：生态日趋完善，或将实时音视频技术白菜化<i class="fa fa-external-link"></i></span></li></ul><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><ul><li><span class="exturl" data-url="aHR0cDovL3NwYXJrLmFwYWNoZWNuLm9yZy9kb2NzL2NuLzIuMi4wLw==" title="http://spark.apachecn.org/docs/cn/2.2.0/">Apache Spark 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxODUyOTYvYXJ0aWNsZS9kZXRhaWxzLzc2ODU1Nzcw" title="https://blog.csdn.net/u012185296/article/details/76855770">Apache Spark 2.2.0 官方文档中文版（翻译完成 98%. 除 MLib 外） | ApacheCN<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h3YzM1MDQ3L2FydGljbGUvZGV0YWlscy82MDMzMDUyOA==" title="https://blog.csdn.net/xwc35047/article/details/60330528">30分钟概览Spark分布式计算引擎<i class="fa fa-external-link"></i></span></li></ul><h3 id="加密安全问题"><a href="#加密安全问题" class="headerlink" title="加密安全问题"></a>加密安全问题</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1ZmFsaWFuZzAwMy9hcnRpY2xlL2RldGFpbHMvNzk3ODIxNjg=" title="https://blog.csdn.net/wufaliang003/article/details/79782168">SHA算法系列介绍<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yMjVmZjk0MzkxMzI=" title="https://www.jianshu.com/p/225ff9439132">比特币背后的密码学原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5kaXd1eWEvYXJ0aWNsZS9kZXRhaWxzLzc5NTcxNjM5" title="https://blog.csdn.net/tiandiwuya/article/details/79571639">比特币的加密算法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnV4cHJvYmUyMDE3L2FydGljbGUvZGV0YWlscy82MjA0OTAwMQ==" title="https://blog.csdn.net/linuxprobe2017/article/details/62049001">密码学大事件！ SHA-1 哈希碰撞实例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzI4NTI3Lmh0bWw=" title="https://www.freebuf.com/articles/web/28527.html">如何安全的存储用户的密码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXFuaXUuY29tL2xlYXJuLzMwMjM4Lmh0bWw=" title="https://www.aqniu.com/learn/30238.html">机器学习作用于信息安全的五大顶级案例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzUwODUzODkx" title="https://www.zhihu.com/question/50853891">机器学习和数据挖掘在网络安全领域会有哪些应用？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGVpcGhvbmUuY29tL25ld3MvMjAxNjA5L2ZZNHB6dHQ0UlFzck9xamkuaHRtbA==" title="https://www.leiphone.com/news/201609/fY4pztt4RQsrOqji.html">机器学习正在安全领域挂起一阵小旋风，但这里面有BUG<i class="fa fa-external-link"></i></span></li></ul><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLm1iYWxpYi5jb20vc3RvcnkvODg1MDY=" title="https://news.mbalib.com/story/88506">终于有人把P2P、P2C、O2O、B2C、B2B、C2C 的区别讲透了！<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTA2NjkzOQ==" title="https://zhuanlan.zhihu.com/p/35066939">如何真正让小程序,WebRTC和APP互通连麦直播<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly8zNmtyLmNvbS9wLzUxMTc1NzUuaHRtbA==" title="https://36kr.com/p/5117575.html">创业者必读：开发一款 App 到底需要多久？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80MmMyNDkxNjgyNzU=" title="https://www.jianshu.com/p/42c249168275">如何开发一个app（Android）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hYWVmNWNlYjM5MzY=" title="https://www.jianshu.com/p/aaef5ceb3936">微信小程序开发教程–从零开始<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTkzMTU1MQ==" title="https://zhuanlan.zhihu.com/p/39931551">面向机器学习:数据平台的设计与搭建<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjEzNTQ4MmU1MWQ0NTA2ZGMwYWFhMTQ=" title="https://juejin.im/post/5b135482e51d4506dc0aaa14">基于Apache Spark以BigDL搭建可扩展的分布式深度学习框架<i class="fa fa-external-link"></i></span></li><li></li></ul><h3 id="高德面试"><a href="#高德面试" class="headerlink" title="高德面试"></a>高德面试</h3><p>基本知识</p><p>1、进程和线程</p><p>2、多线程通讯方式</p><p>3、消费者和生产者模式（消费者是否轮询方式读取消息，用等待信号方式）</p><p>4、linux命令   top、netstat</p><p>5、gdb调试，怎样切换到某个线程</p><p>6、inline和宏定义区别</p><p>7、vector和list区别，什么情况分别是用什么</p><p>8、类的什么函数不能作为虚函数、析构函数能否作为虚函数，虚函数怎么实现的</p><p>9、setsocektopt   no-delay，等参数的作用</p><p>10、tcp关闭时的几个步骤，tcp的慢启动时啥意思，，，，</p><p>11、epoll模型，我说的是多线程，每个线程一个epoll，一个专门接收链接，另外的读数据 ，解码在哪个线程中进行</p><p>12、c++11 智能指针</p><p>13、死锁概念</p><p>14、什么叫做稳定排序、有哪些排序算法、快排怎么实现的</p><p>15、怎么样判断一棵树和平衡二叉树</p><p>16、当前编写代码（输入一个字符串和一个分隔符，，，，，，把字符串用分割符分割几部分，然后输出）</p><p>项目：</p><p>1、freeswitch的系统结构模型、并发的语音的最大路数，语音编码</p><p>2、视频花屏是怎样优化的</p><p>3、rtp，udp</p><p>4、语音包、和视频包是不是固定大小的，，，是否分包</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-C-面试知识总结&quot;&gt;&lt;a href=&quot;#C-C-面试知识总结&quot; class=&quot;headerlink&quot; title=&quot;C/C++ 面试知识总结&quot;&gt;&lt;/a&gt;C/C++ 面试知识总结&lt;/h1&gt;&lt;p&gt;C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。&lt;/p&gt;
&lt;p&gt;勘误新增请 Issue、PR，建议、讨论请 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvaXNzdWVzLzEy&quot; title=&quot;https://github.com/huihut/interview/issues/12&quot;&gt;#issues/12&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;，排版使用 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL216bG9naW4vY2hpbmVzZS1jb3B5d3JpdGluZy1ndWlkZWxpbmVz&quot; title=&quot;https://github.com/mzlogin/chinese-copywriting-guidelines&quot;&gt;中文文案排版指北&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl + F&lt;/code&gt;：快速查找定位知识点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TOC 导航&lt;/code&gt;：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2phd2lsL0dheUh1Yg==&quot; title=&quot;https://github.com/jawil/GayHub&quot;&gt;jawil/GayHub&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt; 插件快速目录跳转&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Program-C" scheme="http://miaopei.github.io/categories/Program-C/"/>
    
    
      <category term="Program-C" scheme="http://miaopei.github.io/tags/Program-C/"/>
    
  </entry>
  
  <entry>
    <title>Program-C 数据结构</title>
    <link href="http://miaopei.github.io/2016/06/03/Program-C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://miaopei.github.io/2016/06/03/Program-C/数据结构/</id>
    <published>2016-06-03T02:14:50.000Z</published>
    <updated>2019-06-10T08:03:58.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><a id="more"></a><img src="/images/imageProgramC/数据结构-00.png"><h2 id="一、数据结构概念"><a href="#一、数据结构概念" class="headerlink" title="一、数据结构概念"></a>一、数据结构概念</h2><h3 id="1-1-数据结构相关概念"><a href="#1-1-数据结构相关概念" class="headerlink" title="1.1 数据结构相关概念"></a>1.1 数据结构相关概念</h3><p><strong>疑惑</strong></p><p>1、我学完了C语言，可是现在感觉还是写不出代码。</p><p>2、为什么会有各种各样的程序存在？</p><p>3、程序的本质是什么？</p><ul><li><p>程序是为了具体问题而存在的 </p></li><li><p>程序需要围绕问题的解决进行设计</p></li><li><p>同一个问题可以有多种解决方案</p></li><li><p>如何追求程序的“性价比”？</p></li><li><p>是否有可量化的方法判别程序的好坏？</p></li></ul><p><strong>数据结构起源</strong></p><ul><li><p>计算机从解决数值计算问题到解决生活中的问题</p></li><li><p>现实生活中的问题涉及不同个体间的复杂联系</p></li><li><p>需要在计算机程序中描述生活中个体间的联系</p></li><li><p>*<em>数据结构主要研究非数值计算程序问题中的操作对象以及它们之间的关系 *</em></p></li><li><p><strong>不是研究复杂的算法</strong></p></li></ul><p><strong>数据结构中的基本概念</strong></p><p>数据 – 程序的操作对象，用于描述客观事物  (int a, int b,)</p><p>数据的特点：</p><ul><li><p>可以输入到计算机</p></li><li><p>可以被计算机程序处理</p></li></ul><p>数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等</p><p><strong>数据元素：组成数据的基本单位</strong></p><p>数据项：一个数据元素由若干数据项组成</p><p><strong>数据对象 – 性质相同的数据元素的集合   （比如：数组，链表）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyTeacher</span>&#123;</span>   <span class="comment">//一种数据类型</span></span><br><span class="line"><span class="keyword">char</span>name[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">char</span>tile[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span>age;</span><br><span class="line"><span class="keyword">char</span>addr[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main21</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyTeacher</span>  <span class="title">t1</span>;</span> <span class="comment">//数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyTeacher</span> <span class="title">tArray</span>[30];</span> <span class="comment">//数据对象</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;t1, <span class="number">0</span>, <span class="keyword">sizeof</span>(t1));</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(t1.name, <span class="string">"name"</span>); <span class="comment">//数据项</span></span><br><span class="line"><span class="built_in">strcpy</span>(t1.addr, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line"><span class="built_in">strcpy</span>(t1.tile, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line">t1.age = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/数据结构.png"><p>数据元素之间不是独立的，存在特定的关系，这些关系即结构</p><p>*<em>数据结构指数据对象中数据元素之间的关系   *</em></p><p>如：数组中各个元素之间存在固定的线性关系   </p><ul><li>编写一个“好”的程序之前，必须分析待处理问题中各个对象的特性，以及对象之间的关系。</li></ul><p>基本概念总结：</p><img src="/images/imageProgramC/数据结构-01.png"><p><strong>数据的逻辑结构</strong></p><p>指数据元素之间的逻辑关系。即从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。逻辑结构可细分为4类：</p><img src="/images/imageProgramC/数据结构-02.png"><p><strong>数据的物理结构</strong></p><img src="/images/imageProgramC/数据结构-03.png"><p><strong>数据的运算</strong></p><img src="/images/imageProgramC/数据结构-04.png"><h3 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h3><p><strong>算法概念</strong></p><ul><li><p>算法是<strong>特定问题求解步骤的描述</strong></p></li><li><p>在计算机中表现为指令的有限序列 </p></li><li><p>算法是独立存在的一种解决问题的方法和思想。</p></li><li><p>对于算法而言，语言并不重要，重要的是思想。</p></li></ul><p><strong>算法和数据结构区别</strong></p><ul><li><p>数据结构只是静态的描述了数据元素之间的关系</p></li><li><p>高效的程序需要在数据结构的基础上设计和选择算法</p></li></ul><p><strong>程序 = 数据结构 + 算法</strong></p><p>总结：</p><ul><li><p>算法是为了解决实际问题而设计的</p></li><li><p>数据结构是算法需要处理的问题载体</p></li><li><p>数据结构与算法相辅相成</p></li></ul><p><strong>算法特性</strong></p><p>输入</p><ul><li>算法具有0个或多个输入</li></ul><p>输出</p><ul><li>算法至少有1个或多个输出</li></ul><p>有穷性</p><ul><li>算法在有限的步骤之后会自动结束而不会无限循环</li></ul><p>确定性</p><ul><li>算法中的每一步都有确定的含义，不会出现二义性</li></ul><p>可行性</p><ul><li>算法的每一步都是可行的</li></ul><p><strong>算法效率的度量</strong></p><p>1、事后统计法</p><ul><li>比较不同算法对同一组输入数据的运行处理时间</li><li>缺陷    <ul><li>为了获得不同算法的运行时间必须编写相应程序</li><li>运行时间严重依赖硬件以及运行时的环境因素</li><li>算法的测试数据的选取相当困难</li></ul></li><li>事后统计法虽然直观，但是实施困难且缺陷多</li></ul><p>算法效率的度量</p><ul><li>事前分析估算</li><li>依据统计的方法对算法效率进行估算</li><li>影响算法效率的主要因素<ul><li>算法采用的策略和方法</li><li>问题的输入规模</li><li>编译器所产生的代码</li><li>计算机执行速度</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法最终编译成具体的计算机指令</span></span><br><span class="line"><span class="comment">//每一个指令，在具体的计算机上运行速度固定</span></span><br><span class="line"><span class="comment">//通过具体的n的步骤，就可以推导出算法的复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;                         </span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">array</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)   </span><br><span class="line">        <span class="built_in">array</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">        ret += <span class="built_in">array</span>[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>); </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">ret += i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>( n &gt; <span class="number">0</span> )</span><br><span class="line">        ret = (<span class="number">1</span> + n) * n / <span class="number">2</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum1(<span class="number">100</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum2(<span class="number">100</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum3(<span class="number">100</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;len; j++)&#123;</span><br><span class="line">            s += i*j;  <span class="comment">//n*n</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/数据结构-05.png"><p><strong>注意 1</strong>：判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略。</p><p><strong>注意 2</strong>：在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度。</p><p>2、大 O 表示法</p><ul><li><p>算法效率严重依赖于操作(Operation)数量</p></li><li><p>在判断时首先关注操作数量的最高次项</p></li><li><p>操作数量的估算可以作为时间复杂度的估算</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">5</span>) = O(<span class="number">1</span>)</span><br><span class="line">O(<span class="number">2</span>n + <span class="number">1</span>) = O(<span class="number">2</span>n) = O(n)  </span><br><span class="line">O(n2+ n + <span class="number">1</span>) = O(n2)</span><br><span class="line">O(<span class="number">3</span>n3+<span class="number">1</span>) = O(<span class="number">3</span>n3) = O(n3)</span><br></pre></td></tr></table></figure><p>常见时间复杂度</p><img src="/images/imageProgramC/数据结构-06.png"><p>关系</p><img src="/images/imageProgramC/数据结构-07.png"><p>3、算法的空间复杂度</p><p>算法的空间复杂度通过计算算法的存储空间实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S(n) = O(f(n))</span><br></pre></td></tr></table></figure><p>其中，<code>n</code> 为问题规模，<code>f(n)</code> 为在问题规模为 <code>n</code> 时所占用存储空间的函数</p><p>大 O 表示法同样适用于算法的空间复杂度</p><p><strong>当算法执行时所需要的空间是常数时，空间复杂度为O(1)</strong></p><p>空间与时间的策略：</p><ul><li><p>多数情况下，算法执行时所用的时间更令人关注</p></li><li><p>如果有必要，可以通过增加空间复杂度来降低时间复杂度</p></li><li><p>同理，也可以通过增加时间复杂度来降低空间复杂度</p></li></ul><p>练习1：分析 sum1 sum2 sum3 函数的空间复杂度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">4</span>n+<span class="number">12</span>)  O(<span class="number">8</span>)=O(<span class="number">1</span>)  O(<span class="number">4</span>)=O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>总结：实现算法时，需要分析具体问题，对执行时间和空间的要求。</p><p>练习2：时间换空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题： </span></span><br><span class="line"><span class="comment">    在一个由自然数 1-1000 中某些数字所组成的数组中，每个数字可能出现零次或者多次。</span></span><br><span class="line"><span class="comment">    设计一个算法，找出出现次数最多的数字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">方法<span class="number">1</span>：</span><br><span class="line">   排序，然后找出出现次数最多的数字</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sp[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = a[i] - <span class="number">1</span>;    </span><br><span class="line">        sp[index]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( max &lt; sp[i] )</span><br><span class="line">            max = sp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( max == sp[i] )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line">    search(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(*<span class="built_in">array</span>));   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把每个数字出现的次数的中间结果，缓存下来；在缓存的结果中求最大值。</p><img src="/images/imageProgramC/数据结构-08.png"><h2 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h2><h3 id="2-1-线性表基本概念"><a href="#2-1-线性表基本概念" class="headerlink" title="2.1 线性表基本概念"></a>2.1 线性表基本概念</h3><p><strong>线性表定义</strong></p><ul><li><p>线性表(List)是零个或多个数据元素的集合 </p></li><li><p>线性表中的数据元素之间是有顺序的</p></li><li><p>线性表中的数据元素个数是有限的</p></li><li><p>线性表中的数据元素的类型必须相同</p></li></ul><img src="/images/imageProgramC/数据结构-09.png"><p><strong>数学定义</strong></p><p>线性表是具有相同类型的 n（ ≥ 0）个数据元素的有限序列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（a1, a2, …, an）</span><br><span class="line">ai 是表项，n 是表长度。</span><br></pre></td></tr></table></figure><p><strong>性质</strong></p><ul><li><p>a0 为线性表的第一个元素，只有一个后继</p></li><li><p>an 为线性表的最后一个元素，只有一个前驱</p></li><li><p>除 a0 和 an 外的其它元素 ai，既有前驱，又有后继</p></li><li><p>线性表能够逐项访问和顺序存取</p></li></ul><p><strong>练习</strong></p><p>下面的关系中可以用线性表描述的是</p><ul><li><p>A.班级中同学的友谊关系 N:N</p></li><li><p>B.公司中的上下级关系  1:N</p></li><li><p>C.冬天图书馆排队占座关系 </p></li><li><p>D.花名册上名字之间的关系 1::1</p></li></ul><p><strong>线性表的操作</strong></p><ul><li><p>创建线性表</p></li><li><p>销毁线性表</p></li><li><p>清空线性表</p></li><li><p>将元素插入线性表</p></li><li><p>将元素从线性表中删除</p></li><li><p>获取线性表中某个位置的元素</p></li><li><p>获取线性表的长度</p></li></ul><blockquote><p>线性表在程序中表现为一种特殊的数据类型</p><p>线性表的操作在程序中的表现为一组函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C 语言描述=====》线性表的设计与实现</span></span><br><span class="line"><span class="comment">ADT 抽象层  《[数据结构(C语言版)].严蔚敏_吴伟民.扫描版.pdf》 p44页 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WBM_LIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WBM_LIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并且返回一个空的线性表</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//销毁一个线性表list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//将一个线性表list中的所有元素清空, 线性表回到创建时的初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//向一个线性表list的pos位置处插入新元素node</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;  </span><br><span class="line"><span class="comment">//获取一个线性表list的pos位置处的元素</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//删除一个线性表list的pos位置处的元素  返回值为被删除的元素，NULL表示删除失败</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意: */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;  (重点:分离思想)</span><br></pre></td></tr></table></figure><h3 id="2-2-线性表的顺序存储结构"><a href="#2-2-线性表的顺序存储结构" class="headerlink" title="2.2 线性表的顺序存储结构"></a>2.2 线性表的顺序存储结构</h3><p><strong>基本概念</strong></p><img src="/images/imageProgramC/数据结构-10.png"><p><strong>设计与实现</strong></p><p>插入元素算法</p><ul><li><p>判断线性表是否合法</p></li><li><p>判断插入位置是否合法</p></li><li><p>把最后一个元素到插入位置的元素后移一个位置</p></li><li><p>将新元素插入</p></li><li><p>线性表长度加 1</p></li></ul><p>获取元素操作</p><ul><li><p>判断线性表是否合法</p></li><li><p>判断位置是否合法</p></li><li><p>直接通过数组下标的方式获取元素</p></li></ul><p>删除元素算法</p><ul><li><p>判断线性表是否合法</p></li><li><p>判断删除位置是否合法</p></li><li><p>将元素取出</p></li><li><p>将删除位置后的元素分别向前移动一个位置</p></li><li><p>线性表长度减 1</p></li></ul><p>链表顺序存储插入算法和删除算法</p><img src="/images/imageProgramC/数据结构-11.png"><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><p>无需为线性表中的逻辑关系增加额外的空间</p></li><li><p>可以快速的获取表中合法位置的元素</p></li></ul><p>缺点：</p><ul><li><p>插入和删除操作需要移动大量元素</p></li><li><p>当线性表长度变化较大时难以确定存储空间的容量</p></li></ul><h3 id="2-3-线性表的链式存储"><a href="#2-3-线性表的链式存储" class="headerlink" title="2.3 线性表的链式存储"></a>2.3 线性表的链式存储</h3><p><strong>基本概念</strong></p><p>链式存储定义</p><ul><li>为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。</li></ul><img src="/images/imageProgramC/数据结构-12.png"><p>表头结点</p><ul><li>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息</li></ul><p>数据结点</p><ul><li>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息</li></ul><p>尾结点</p><ul><li>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li></ul><p><strong>链表技术领域推演</strong></p><img src="/images/imageProgramC/数据结构-13.png"><p><strong>设计与实现</strong></p><p>链表链式存储 <code>_api</code> 实现分析</p><p>在C语言中可以用结构体来定义链表中的指针域</p><p>链表中的表头结点也可以用结构体实现</p><img src="/images/imageProgramC/数据结构-14.png"><img src="/images/imageProgramC/数据结构-15.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> * LK;      <span class="comment">// 不希望看到内部数据是可以这么定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function">LK <span class="title">init_LinkList</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_LinkList</span><span class="params">(LK <span class="built_in">list</span>, <span class="keyword">int</span> position, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foreach_LinkList</span><span class="params">(LK <span class="built_in">list</span>, <span class="keyword">void</span>(*myforeach)(<span class="keyword">void</span> *))</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveByPos_LinkList</span><span class="params">(LK <span class="built_in">list</span>, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destroy_LinkList</span><span class="params">(LK <span class="built_in">list</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点、位置从0的单链表</span></span><br><span class="line"><span class="comment">// 返回链表中第3个位置处，元素的值</span></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Get</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>&#123; </span><br><span class="line"><span class="keyword">int</span>  i = <span class="number">0</span>;</span><br><span class="line">TLinkList *tList = (TLinkList *)<span class="built_in">list</span>;</span><br><span class="line">LinkListNode *current = <span class="literal">NULL</span>;</span><br><span class="line">LinkListNode *ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || pos &lt; <span class="number">0</span> || pos &gt;= tList-&gt;length)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">current = (LinkListNode *)tList;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">ret = current-&gt;next;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>返回第三个位置的,移动pos次以后，当前指针指向哪里？</p><p>答案：指向位置2，所以需要返回 <code>ret = current-&gt;next;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    备注：循环遍历时，</span></span><br><span class="line"><span class="comment">    遍历第1次，指向位置0</span></span><br><span class="line"><span class="comment">        遍历第2次，指向位置1</span></span><br><span class="line"><span class="comment">        遍历第3次，指向位置2</span></span><br><span class="line"><span class="comment">        遍历第n次，指向位置n-1;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以如果想返回位置 n 的元素的值，需要怎么做 <code>ret = current-&gt;next;</code></p><p>此问题是：*<em>指向头结点的指针移动 n 次 和 第 n 个元素之间的关系？ *</em></p><p>删除元素</p><img src="/images/imageProgramC/数据结构-16.png"><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><p>无需一次性定制链表的容量 </p></li><li><p>插入和删除操作无需移动数据元素</p></li></ul><p>缺点：</p><ul><li><p>数据元素必须保存后继元素的位置信息</p></li><li><p>获取指定数据的元素操作需要顺序访问之前的元素</p></li></ul><h3 id="2-4-循环链表"><a href="#2-4-循环链表" class="headerlink" title="2.4 循环链表"></a>2.4 循环链表</h3><p><strong>基本概念</strong></p><p>循环链表的定义：将单链表中最后一个数据元素的next指针指向第一个元素</p><img src="/images/imageProgramC/数据结构-17.png"><p>循环链表拥有单链表的所有操作</p><ul><li><p>创建链表</p></li><li><p>销毁链表</p></li><li><p>获取链表长度</p></li><li><p>清空链表</p></li><li><p>获取第pos个元素操作</p></li><li><p>插入元素到位置pos</p></li><li><p>删除位置pos处的元素</p></li></ul><p>新增功能：<strong>游标</strong> 的定义</p><p>在循环链表中可以定义一个“当前”指针，这个指针通常称为 <strong>游标</strong>，可以通过这个游标来遍历链表中的所有元素。</p><img src="/images/imageProgramC/数据结构-18.png"><p>循环链表新操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将游标重置指向链表中的第一个数据元素</span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_Reset</span><span class="params">(CircleList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前游标指向的数据元素</span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_Current</span><span class="params">(CircleList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将游标移动指向到链表中的下一个数据元素</span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_Next</span><span class="params">(CircleList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接指定删除链表中的某个数据元素 </span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_DeleteNode</span><span class="params">(CircleList* <span class="built_in">list</span>, CircleListNode* node)</span></span>;  </span><br><span class="line"><span class="comment">// 根据元素的 值 删除, 元素 pk 根据元素的 位置 删除元素</span></span><br></pre></td></tr></table></figure><p><strong>循环链表的应用</strong></p><p><strong>证明循环链表</strong></p><ul><li>打印两次。</li></ul><p><strong>约瑟夫问题求解</strong></p><blockquote><p>约瑟夫问题 - 循环链表典型应用</p><p>n 个人围成一个圆圈，首先第 1 个人从 1 开始一个人一个人顺时针报数，报到第 m 个人，令其出列。然后再从下一 个人开始从 1 顺时针报数，报到第 m 个人，再令其出列，…，如此下去，求出列顺序。</p></blockquote><img src="/images/imageProgramC/数据结构-19.png"><p><strong>设计与实现</strong></p><p><strong>循环链表插入元素的分析</strong> </p><p>1） 普通插入元素（和单链表是一样的）</p><p>2） 尾插法（和单链表是一样的，单链表的写法支持尾插法；因：辅助指针向后跳length次，指向最后面那个元素）</p><img src="/images/imageProgramC/数据结构-20.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList_Insert</span><span class="params">(<span class="built_in">list</span>, (CircleListNode*)&amp;v1, CircleList_Length(<span class="built_in">list</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>3） 头插法（要进行头插法，需要求出尾结点，和单链表不一样的地方，保证是循环链表）第一次插入元素时，让游标指向 0 号结点</p><img src="/images/imageProgramC/数据结构-21.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList_Insert</span><span class="params">(<span class="built_in">list</span>, (CircleListNode*)&amp;v1, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>4）第一次插入元素</p><img src="/images/imageProgramC/数据结构-22.png"><p><strong>循环链表插入综合场景分析图</strong></p><img src="/images/imageProgramC/数据结构-23.png"><p><strong>循环链表删除结点分析</strong></p><p>1、 删除普通结点</p><p>2、 删除头结点（删除 0 号位置处元素），需要求出尾结点</p><img src="/images/imageProgramC/数据结构-24.png"><p><strong>优点和缺点</strong></p><p>优点：功能强了。</p><ul><li><p>循环链表只是在单链表的基础上做了一个加强</p></li><li><p>循环链表可以完全取代单链表的使用</p></li><li><p>循环链表的 Next 和 Current 操作可以高效的遍历链表中的所有元素</p></li></ul><p>缺点：</p><ul><li>代码复杂度提高了</li></ul><h3 id="2-5-双向链表"><a href="#2-5-双向链表" class="headerlink" title="2.5 双向链表"></a>2.5 双向链表</h3><p><strong>基本概念</strong> </p><p>请思考： 为什么 <strong>需要</strong> 双向链表？</p><ul><li><p>单链表的结点都只有一个指向下一个结点的指针</p></li><li><p>单链表的数据元素无法直接访问其前驱元素</p></li><li><p><strong>逆序访问单链表</strong> 中的元素是极其 <strong>耗时</strong> 的操作！</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">len = LinkList_Length(<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">for</span> (i=len<span class="number">-1</span>; len&gt;=<span class="number">0</span>; i++) <span class="comment">//O(n)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode *p = LinkList_Get(<span class="built_in">list</span>, i); <span class="comment">//O(n)</span></span><br><span class="line">    <span class="comment">//访问数据元素p中的元素</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向链表的定义</strong></p><p>在单链表的结点中增加一个指向其前驱的 pre 指针</p><img src="/images/imageProgramC/数据结构-25.png"><p>双向链表拥有单链表的所有操作</p><ul><li><p>创建链表</p></li><li><p>销毁链表</p></li><li><p>获取链表长度</p></li><li><p>清空链表</p></li><li><p>获取第 pos 个元素操作</p></li><li><p>插入元素到位置 pos</p></li><li><p>删除位置 pos 处的元素</p></li></ul><p><strong>设计与实现</strong></p><p>循环链表一般操作</p><blockquote><p> 插入操作</p></blockquote><img src="/images/imageProgramC/数据结构-26.png"><p>插入操作异常处理</p><ul><li><p>插入第一个元素异常处理</p></li><li><p>在 0 号位置处插入元素；</p></li></ul><blockquote><p>删除操作</p></blockquote><img src="/images/imageProgramC/数据结构-27.png"><p>删除操作异常处理</p><p>双向链表的新操作</p><ul><li><p>获取当前游标指向的数据元素</p></li><li><p>将游标重置指向链表中的第一个数据元素</p></li><li><p>将游标移动指向到链表中的下一个数据元素</p></li><li><p>将游标移动指向到链表中的上一个数据元素</p></li><li><p>直接指定删除链表中的某个数据元素</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_DeleteNode</span><span class="params">(DLinkList* <span class="built_in">list</span>, DLinkListNode* node)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Reset</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Current</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Next</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Pre</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//大家一定要注意：教科书不会告诉你 项目上如何用；哪些点是项目的重点；做一个企业级的财富库，完成你人生开发经验的积累，是我们的学习重点，要注意！</span></span><br></pre></td></tr></table></figure><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><p>双向链表在单链表的基础上增加了指向前驱的指针</p></li><li><p>功能上双向链表可以完全取代单链表的使用</p></li><li><p>双向链表的 Next，Pre 和 Current 操作可以高效的遍历链表中的所有元素</p></li></ul><p>缺点：</p><ul><li>代码复杂</li></ul><h2 id="三、栈-stack-和队列-queue"><a href="#三、栈-stack-和队列-queue" class="headerlink" title="三、栈 stack 和队列 queue"></a>三、栈 stack 和队列 queue</h2><h3 id="3-1栈-stack"><a href="#3-1栈-stack" class="headerlink" title="3.1栈 stack"></a>3.1栈 stack</h3><p><strong>Stack基本概念</strong></p><ul><li><p>栈是一种  特殊的线性表  </p></li><li><p>栈仅能在线性表的一端进行操作</p><ul><li>栈顶(Top)：允许操作的一端</li><li>栈底(Bottom)：不允许操作的一端</li></ul></li></ul><img src="/images/imageProgramC/数据结构-28.png"><p><strong>Stack的常用操作</strong></p><ul><li><p>创建栈</p></li><li><p>销毁栈</p></li><li><p>清空栈</p></li><li><p>进栈</p></li><li><p>出栈</p></li><li><p>获取栈顶元素</p></li><li><p>获取栈的大小 </p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack* <span class="title">Stack_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack_Destroy</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack_Clear</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack_Push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Stack_Pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Stack_Top</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack_Size</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_STACK_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>栈模型和链表模型关系分析</strong></p><img src="/images/imageProgramC/数据结构-29.png"><p><strong>栈的顺序存储设计与实现</strong></p><img src="/images/imageProgramC/数据结构-30.png"><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  __MY_SEQLIST_H__ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MY_SEQLIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqListNode;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqStack_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SeqStack _Destroy(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SeqStack _Clear(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SeqStack _Length(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SeqStack _Capacity(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SeqStack _Insert(SeqStack * <span class="built_in">list</span>, SeqListNode* node, <span class="keyword">int</span> pos);</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Get</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Delete</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//__MY_SEQLIST_H__</span></span></span><br></pre></td></tr></table></figure><p><strong>栈的链式存储设计与实现</strong></p><img src="/images/imageProgramC/数据结构-31.png"><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_LINKSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_LINKSTACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack* <span class="title">LinkStack_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack_Destroy</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack_Clear</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack_Push</span><span class="params">(LinkStack* <span class="built_in">stack</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkStack_Pop</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkStack_Top</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack_Size</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_LINKSTACK_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>栈的应用</strong></p><p><strong>案例1：就近匹配</strong></p><blockquote><p>应用1：就近匹配 </p><p>几乎所有的编译器都具有检测括号是否匹配的能力</p><p>如何实现编译器中的符号成对检测？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>]; </span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">4</span>]; </span><br><span class="line">    p = a[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>算法思路</p><ul><li><p>从第一个字符开始扫描</p></li><li><p>当遇见普通字符时忽略，</p></li><li><p>当遇见左符号时压入栈中</p></li><li><p>当遇见右符号时从栈中弹出栈顶符号，并进行匹配</p><ul><li>匹配成功：继续读入下一个字符</li><li>匹配失败：立即停止，并报错</li></ul></li><li><p>结束：</p><ul><li>成功: 所有字符扫描完毕，且栈为空</li><li>失败：匹配失败或所有字符扫描完毕但栈非空</li></ul></li></ul></blockquote><p>当需要检测成对出现但又互不相邻的事物时，可以使用栈 “后进先出” 的特性，栈非常适合于需要“就近匹配”的场合</p><p><strong>案例2：中缀表达式和后缀表达式</strong></p><blockquote><p>应用2：中缀 后缀</p></blockquote><blockquote><p>计算机的本质工作就是做数学运算，那计算机可以读入字符串</p><p>“9 + (3 - 1) * 5 + 8 / 2”并计算值吗？</p></blockquote><blockquote><p>后缀表达式  ==？符合计算机运算</p><p>波兰科学家在20世纪50年代提出了一种将运算符放在数字后面的后缀表达式对应的，</p><p>我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例：</span></span><br><span class="line"><span class="number">5</span> + <span class="number">4</span>=&gt; <span class="number">5</span> <span class="number">4</span> +  </span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> * <span class="number">3</span> =&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> * +  </span><br><span class="line"><span class="number">8</span> + ( <span class="number">3</span> – <span class="number">1</span> ) * <span class="number">5</span> =&gt; <span class="number">8</span> <span class="number">3</span> <span class="number">1</span> – <span class="number">5</span> * +</span><br></pre></td></tr></table></figure><blockquote><p>中缀表达式符合人类的阅读和思维习惯</p><p>后缀表达式符合计算机的“运算习惯”</p><p>如何将中缀表达式转换成后缀表达式？</p></blockquote><blockquote><p>中缀转后缀算法：</p><ul><li><p>遍历中缀表达式中的数字和符号</p></li><li><p>对于数字：直接输出</p></li><li><p>对于符号：</p><ul><li>左括号：进栈  </li><li>运算符号：与栈顶符号进行优先级比较<ul><li>若栈顶符号优先级低：此符合进栈  （默认栈顶若是左括号，左括号优先级最低）</li><li>若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈</li></ul></li></ul></li><li><p>右括号：将栈顶符号弹出并输出，直到匹配左括号</p></li><li><p>遍历结束：将栈中的所有符号弹出并输出</p></li><li><p>中缀转后缀</p></li></ul></blockquote><img src="/images/imageProgramC/数据结构-32.png"><blockquote><p>计算机是如何基于后缀表达式计算的？</p><p>8 3 1 – 5 * + </p></blockquote><blockquote><p>遍历后缀表达式中的数字和符号</p><p>对于数字：进栈</p><p>对于符号：</p><ul><li><p>从栈中弹出右操作数</p></li><li><p>从栈中弹出左操作数</p></li><li><p>根据符号进行运算</p></li><li><p>将运算结果压入栈中</p></li></ul><p>遍历结束：栈中的唯一数字为计算结果</p></blockquote><img src="/images/imageProgramC/数据结构-33.png"><blockquote><p>栈的神奇！    </p><p>中缀表达式是人习惯的表达方式</p><p>后缀表达式是计算机喜欢的表达方式</p><p>通过栈可以方便的将中缀形式变换为后缀形式</p><p>中缀表达式的计算过程类似程序编译运行的过程  </p></blockquote><blockquote><p>扩展：给你一个字符串，计算结果</p><p>“1 + 2 * (66 / (2 * 3) + 7 )”   </p><ul><li><p>字符串解析</p></li><li><p>词法语法分析</p></li><li><p>优先级分析     </p></li><li><p>数据结构选型===》栈还是树？</p></li></ul></blockquote><h3 id="3-2-队列queue"><a href="#3-2-队列queue" class="headerlink" title="3.2 队列queue"></a>3.2 <strong>队列queue</strong></h3><p><strong>queue基本概念</strong></p><ul><li><p>队列是一种特殊的线性表  </p></li><li><p>队列仅在线性表的两端进行操作</p></li><li><p>队头(Front)：取出数据元素的一端</p></li><li><p>队尾(Rear)：插入数据元素的一端</p></li><li><p>队列不允许在中间部位进行操作！</p></li></ul><img src="/images/imageProgramC/数据结构-34.png"><p><strong>queue常用操作</strong></p><ul><li><p>销毁队列</p></li><li><p>清空队列</p></li><li><p>进队列</p></li><li><p>出队列</p></li><li><p>获取队头元素</p></li><li><p>获取队列的长度</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue* <span class="title">Queue_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Destroy</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Clear</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Append</span><span class="params">(Queue* <span class="built_in">queue</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Queue_Retrieve</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Queue_Header</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Length</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_QUEUE_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>队列模型和链表模型关系分析</strong></p><img src="/images/imageProgramC/数据结构-35.png"><p><strong>队列的顺序存储设计与实现</strong></p><p>队列也是一种特殊的线性表；可以用线性表顺序存储来模拟队列。</p><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_SEQQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_SEQQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqQueue* <span class="title">SeqQueue_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue_Destroy</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue_Clear</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue_Append</span><span class="params">(SeqQueue* <span class="built_in">queue</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">SeqQueue_Retrieve</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">SeqQueue_Header</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue_Length</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue_Capacity</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_SEQQUEUE_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>队列的链式存储设计与实现</strong></p><p>队列也是一种特殊的线性表；可以用线性表链式存储来模拟队列的链式存储。</p><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_LINKQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_LINKQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkQueue* <span class="title">LinkQueue_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue_Destroy</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue_Clear</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue_Append</span><span class="params">(LinkQueue* <span class="built_in">queue</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkQueue_Retrieve</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkQueue_Header</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue_Length</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_LINKQUEUE_H_</span></span></span><br></pre></td></tr></table></figure><h2 id="四、树专题"><a href="#四、树专题" class="headerlink" title="四、树专题"></a>四、树专题</h2><p><strong>树基本概念</strong></p><p>非线性结构，一个直接前驱，但可能有多个直接后继（1:n）</p><img src="/images/imageProgramC/数据结构-79.png"><img src="/images/imageProgramC/数据结构-78.png"><p><strong>树的表示法</strong></p><ul><li><p>图形表示法</p></li><li><p>广义表表示法</p></li><li><p>左孩子－右兄弟表示法</p></li><li><p>双亲孩子表示法</p></li></ul><p><strong>树的逻辑结构</strong></p><ul><li><p>一对多（1:n），有多个直接后继（如家谱树、目录树等等），但只有一个根结点，且子树之间互不相交。</p></li><li><p>广义表表示法</p></li><li><p>左孩子－右兄弟表示法</p></li></ul><h3 id="4-1-二叉树概念"><a href="#4-1-二叉树概念" class="headerlink" title="4.1 二叉树概念"></a>4.1 二叉树概念</h3><img src="/images/imageProgramC/数据结构-80.png"><img src="/images/imageProgramC/数据结构-81.png"><img src="/images/imageProgramC/数据结构-82.png"><img src="/images/imageProgramC/数据结构-83.png"><img src="/images/imageProgramC/数据结构-84.png"><img src="/images/imageProgramC/数据结构-85.png"><img src="/images/imageProgramC/数据结构-86.png"><img src="/images/imageProgramC/数据结构-87.png"><img src="/images/imageProgramC/数据结构-38.png"><p>先序遍历（DLR）：先访问根、再访问左、再访问右</p><p>中序遍历（LDR）：先访问左、再访问根、再访问右</p><p>后序遍历（LRD）：先访问左、再访问右、再访问根</p><img src="/images/imageProgramC/数据结构-88.png"><img src="/images/imageProgramC/数据结构-89.png"><p>二叉树的结构最简单，规律性最强。可以证明，所有树都能转为唯一对应的二叉树，不失一般性</p><p>定义：是 n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成</p><p>二叉树性质</p><blockquote><p>性质1: 在二叉树的第 <code>i</code> 层上至多有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PTJee2ktMX0=" title="https://www.codecogs.com/eqnedit.php?latex=2^{i-1}"><img src="https://latex.codecogs.com/gif.latex?2^{i-1}" title="2^{i-1}"><i class="fa fa-external-link"></i></span> 个结点（<code>i&gt;0</code>）</p></blockquote><blockquote><p>性质2: 深度为 <code>k</code> 的二叉树至多有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PTJeayZzcGFjZTstMQ==" title="https://www.codecogs.com/eqnedit.php?latex=2^k&space;-1"><img src="https://latex.codecogs.com/gif.latex?2^k&space;-1" title="2^k -1"><i class="fa fa-external-link"></i></span> 个结点（<code>k&gt;0</code>）</p></blockquote><blockquote><p>性质3: 对于任何一棵二叉树，若 2 度的结点数有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMg==" title="https://www.codecogs.com/eqnedit.php?latex=n_2"><img src="https://latex.codecogs.com/gif.latex?n_2" title="n_2"><i class="fa fa-external-link"></i></span> 个，则叶子数（<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMA==" title="https://www.codecogs.com/eqnedit.php?latex=n_0"><img src="https://latex.codecogs.com/gif.latex?n_0" title="n_0"><i class="fa fa-external-link"></i></span>）必定为 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMiZzcGFjZTsmcGx1czsmc3BhY2U7MQ==" title="https://www.codecogs.com/eqnedit.php?latex=n_2&space;&plus;&space;1"><img src="https://latex.codecogs.com/gif.latex?n_2&space;&plus;&space;1" title="n_2 + 1"><i class="fa fa-external-link"></i></span> （即<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMCZzcGFjZTs9JnNwYWNlO25fMiZzcGFjZTsmcGx1czsmc3BhY2U7MQ==" title="https://www.codecogs.com/eqnedit.php?latex=n_0&space;=&space;n_2&space;&plus;&space;1"><img src="https://latex.codecogs.com/gif.latex?n_0&space;=&space;n_2&space;&plus;&space;1" title="n_0 = n_2 + 1"><i class="fa fa-external-link"></i></span>）</p></blockquote><p>满二叉树：一棵深度为 <code>k</code> 且有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PTJeayZzcGFjZTstJnNwYWNlOzE=" title="https://www.codecogs.com/eqnedit.php?latex=2^k&space;-&space;1"><img src="https://latex.codecogs.com/gif.latex?2^k&space;-&space;1" title="2^k - 1"><i class="fa fa-external-link"></i></span> 个结点的二叉树。（特点：每层都“充满”了结点）</p><p>完全二叉树：深度为 <code>k</code> 的，有 <code>n</code> 个结点的二叉树，当且仅当其每一个结点都与深度为 <code>k</code> 的满二叉树中编号从 1 至 <code>n</code> 的结点一一对应。</p><p>理解：（<code>k-1</code> 层与满二叉树完全相同，第 <code>k</code> 层结点尽力靠左）</p> <img src="/images/imageProgramC/数据结构-36.png"><blockquote><p>性质4: 具有 <code>n</code> 个结点的完全二叉树的深度必为 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PXxcbG9nXzJufCZzcGFjZTsmcGx1czsmc3BhY2U7MQ==" title="https://www.codecogs.com/eqnedit.php?latex=|\log_2n|&space;&plus;&space;1"><img src="https://latex.codecogs.com/gif.latex?|\log_2n|&space;&plus;&space;1" title="|\log_2n| + 1"><i class="fa fa-external-link"></i></span></p></blockquote><blockquote><p>性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为 <code>i</code> 的结点，其左孩子编号必为 <code>2i</code>，其右孩子编号必为 <code>2i + 1</code>；其双亲的编号必为 <code>i/2</code>（<code>i=1</code> 时为根,除外）</p></blockquote><p><strong>二叉树的存储结构</strong></p><ul><li><p>1、顺序存储结构</p><p>按二叉树的结点“自上而下、从左至右”编号，用一组连续的存储单元存储。</p><p>答：一律转为完全二叉树！</p><p>讨论：不是完全二叉树怎么办？</p><p>方法很简单，将各层空缺处统统补上“虚结点”，其内容为空</p></li><li><p>2、链式存储结构</p></li></ul><p><strong>二叉树的表示</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct BiTNode</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">intdata;</span></span><br><span class="line"><span class="comment"> struct BiTNode *lchild, *rchild;</span></span><br><span class="line"><span class="comment">&#125;BiTNode, *BiTree;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> <span class="title">BiTNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> * <span class="title">BiTree</span>;</span></span><br></pre></td></tr></table></figure><p><strong>树的三叉链表表示</strong></p><img src="/images/imageProgramC/数据结构-37.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="comment">//左右孩子指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">&#125;TriTNode, *TriTree;</span><br><span class="line"></span><br><span class="line">双亲链表法</span><br><span class="line"><span class="comment">//双亲链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> parentPosition; <span class="comment">//指向双亲的指针 //数组下标</span></span><br><span class="line"><span class="keyword">char</span> LRTag; <span class="comment">//左右孩子标志域</span></span><br><span class="line">&#125;BPTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BPTNode nodes[<span class="number">100</span>]; <span class="comment">//因为节点之间是分散的，需要把节点存储到数组中</span></span><br><span class="line"><span class="keyword">int</span> num_node;  <span class="comment">//节点数目</span></span><br><span class="line"><span class="keyword">int</span> root; <span class="comment">//根结点的位置 //注意此域存储的是父亲节点在数组的下标</span></span><br><span class="line">&#125;BPTree;</span><br><span class="line"><span class="comment">//用这个数据结构能表达出一颗树，为什么？</span></span><br></pre></td></tr></table></figure><p><strong>二叉树的遍历</strong></p><img src="/images/imageProgramC/数据结构-38.png"><p>树的遍历本质剖析</p><img src="/images/imageProgramC/数据结构-39.png"><h3 id="4-2-二叉树编程实践"><a href="#4-2-二叉树编程实践" class="headerlink" title="4.2 二叉树编程实践"></a>4.2 二叉树编程实践</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span>  data; </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>；</span></span><br><span class="line"><span class="class">&#125; <span class="title">NODE</span>;</span></span><br><span class="line">NODE *root;</span><br></pre></td></tr></table></figure><p><strong>先序遍历算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DLR(NODE *root )</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (root) <span class="comment">//非空二叉树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“%d”,root-&gt;data); <span class="comment">//访问D</span></span><br><span class="line">        DLR(root-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">        DLR(root-&gt;rchild); <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LDR(NODE *root)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(root !=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        LDR(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(“%d”,root-&gt;data);</span><br><span class="line">        LDR(root-&gt;rchild); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LRD (NODE *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root !=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        LRD(root-&gt;lchild);</span><br><span class="line">        LRD(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(“%d”,root-&gt;data); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例1：计算二叉树中叶子结点的数目</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//全局变量</span></span><br><span class="line">DLR_CountLeafNum(NODE *root)<span class="comment">//采用中序遍历的递归算法</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> ( root)  <span class="comment">//非空二叉树条件，还可写成if(root !=NULL )</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;lchild&amp;&amp;!root-&gt;rchild)  <span class="comment">//是叶子结点则统计并打印</span></span><br><span class="line">        &#123;   </span><br><span class="line">            sum++;     </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);  </span><br><span class="line">        &#125;</span><br><span class="line">        DLR_CountLeafNum(root-&gt;lchild); <span class="comment">//递归遍历左子树，直到叶子处；</span></span><br><span class="line">        DLR_CountLeafNum(root-&gt;rchild);&#125;<span class="comment">//递归遍历右子树，直到叶子处；</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思想：    1）求根结点左子树的叶子结点个数，累计到sum中，求根结点右子树的叶子结点个数累计到sum中。<br>​        2）若左子树还是树，重复步骤1；若右子树还是树，重复步骤1。<br>​        3）全局变量转成函数参数<br>​        4）按照先序、中序、后序方式计算叶子结点，<br>===》三种遍历的本质思想强化：访问结点的路径都是一样的，计算结点的时机不同。</p></blockquote><p><strong>案例2：求二叉树的深度</strong></p><blockquote><p>思想：    1）求根结点左子树高度，根结点右子树高度，比较的子树最大高度，再 +1。</p><p>​        2）若左子树还是树，重复步骤 1；若右子树还是树，重复步骤 1。</p></blockquote><p><strong>案例3：完全Copy二叉树</strong></p><blockquote><p>思想：    1）malloc新结点，</p><p>​        2）拷贝左子树，拷贝右子树，让新结点连接左子树，右子树</p><p>​        3）若左子树还是树，重复步骤1、2；若右子树还是树，重复步骤1、2。</p></blockquote><p><strong>案例4：树的非递归遍历(中序遍历)</strong></p><blockquote><p>中序 遍历的几种情况</p><p>分析1：</p><ul><li>什么时候访问根、什么时候访问左子树、什么访问右子树</li><li>当左子树为空或者左子树已经访问完毕以后，再访问根</li><li>访问完毕根以后，再访问右子树。</li></ul><p>分析2：</p><ul><li>非递归遍历树，访问结点时，为什么是栈，而不是其他模型（比如说是队列）。</li><li>先走到的后访问、后走到的先访问，显然是栈结构</li></ul><p>分析3：结点所有路径情况</p><ul><li><p>步骤1：</p><ul><li>如果结点有左子树，该结点入栈；</li><li>如果结点没有左子树，访问该结点；</li></ul></li><li><p>步骤2：</p><ul><li>如果结点有右子树，重复步骤1；</li><li>如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1</li><li>如果栈为空，表示遍历结束。 </li></ul></li></ul><p>注意：入栈的结点表示，本身没有被访问过，同时右子树也没有被访问过。</p><p>分析4：有一个一直往左走入栈的操作，中序遍历的起点</p></blockquote><img src="/images/imageProgramC/数据结构-40.png"><img src="/images/imageProgramC/数据结构-41.png"><p>作业：自己编写堆栈函数原型，实现中序遍历非递归算法</p><h3 id="4-3-二叉树的创建"><a href="#4-3-二叉树的创建" class="headerlink" title="4.3 二叉树的创建"></a>4.3 <strong>二叉树的创建</strong></h3><p><strong>中序和先序创建树</strong></p><p>1、根据中序遍历的结果能确定一棵树吗？</p><p>中序遍历：结果为：“12345”，这个“12345”能确定一棵树吗？</p><p>请思考，会有多少种形状。</p><p>2、如何才能确定一棵树？</p><blockquote><p>结论：    通过中序遍历和先序遍历可以确定一个树</p><p>​        通过中序遍历和后续遍历可以确定一个树</p><p>​        通过先序遍历和后序遍历确定不了一个树。</p></blockquote><p>单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。</p><p>3、根据先序和中序结果画树</p><blockquote><p>算法</p><p>1、通过先序遍历找到根结点A，再通过A在中序遍历的位置找出左子树，右子树</p><p>2、在A的左子树中，找左子树的根结点（在先序中找），转步骤1</p><p>3、在A的右子树中，找右子树的根结点（在先序中找），转步骤1</p></blockquote><blockquote><p>讲解：</p><p>先序遍历结果：ADEBCF</p><p>中序遍历结果：DEACFB</p></blockquote><blockquote><p>练习：</p><p>先序遍历结果：ABDHKECFIGJ</p><p>中序遍历结果：HKDBEAIFCGJ</p></blockquote><p>4、学习算法可借助工具、动画</p><p><strong>#号法创建树</strong></p><p>1、什么是 <code>#</code> 号法创建树</p><p><code>#</code> 创建树，让树的每一个节点都变成度数为2的树</p><img src="/images/imageProgramC/数据结构-42.png"><p>先序遍历：<code>124###3##</code> 可以唯一确定一棵树吗，为什么？</p><img src="/images/imageProgramC/数据结构-43.png"><p>2、<code>#</code> 创建树练习</p><p>先序遍历：<code>ABDH#K###E##CFI###G#J##</code> ,请画出树的形状</p><p><code>#</code> 号法画出树关键点：</p><p>要清楚的确定<strong>左子树什么结束</strong>，<strong>右子树什么时候开始</strong>。</p><p>3、<code>#</code> 号法编程实践</p><p>利用前序遍历来建树（结点值陆续从键盘输入，用 DLR 为宜）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bintree <span class="title">createBTpre</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    Bintree T; </span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(“%c”,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch==’#’) </span><br><span class="line">        T=<span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        T=( Bintree )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTNode));</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        T-&gt;lchild=createBTpre(); </span><br><span class="line">        T-&gt;rchild=createBTpre();</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历销毁一个树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BiTree_Free</span><span class="params">(BiTNode* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode *tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (T!= <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T-&gt;rchild != <span class="literal">NULL</span>) BiTree_Free(T-&gt;rchild);</span><br><span class="line"><span class="keyword">if</span> (T-&gt;lchild != <span class="literal">NULL</span>) BiTree_Free(T-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(T); </span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-二叉线索树"><a href="#4-4-二叉线索树" class="headerlink" title="4.4 二叉线索树"></a>4.4 <strong>二叉线索树</strong></h3><p><strong>线索化概念</strong></p><p>1、前言</p><p>普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得。</p><p>若可将遍历后对应的有关前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树了。</p><p>二叉线索树思想是干什么的？</p><img src="/images/imageProgramC/数据结构-44.png"><p>中序遍历这棵树===》转换成链表访问</p><p>2、线索化思想</p><img src="/images/imageProgramC/数据结构-45.png"><img src="/images/imageProgramC/数据结构-46.png"><img src="/images/imageProgramC/数据结构-47.png"><blockquote><p>结论：    线索化过程就是在遍历过程（假设是中序遍历）中修改空指针的过程：</p><p>​        将空的lchild改为结点的直接前驱；</p><p>​        将空的rchild改为结点的直接后继。</p></blockquote><p>3、线索化思想训练</p><img src="/images/imageProgramC/数据结构-48.png"><p>请将此树线索化。</p><p>1）右空指针线索化：</p><img src="/images/imageProgramC/数据结构-49.png"><p>2）左空指针线索化</p><img src="/images/imageProgramC/数据结构-50.png"><p>3）总结</p><img src="/images/imageProgramC/数据结构-51.png"><p><strong>线索化的实现</strong></p><p>1）线索化树结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>/* 二叉线索存储结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>data;<span class="comment">/* 结点数据 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">/* 左右孩子指针 */</span></span><br><span class="line"><span class="keyword">int</span>LTag;</span><br><span class="line"><span class="keyword">int</span>RTag;<span class="comment">/* 左右标志 */</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><p>2）线索化思想分析</p><img src="/images/imageProgramC/数据结构-52.png"><p>线索化的本质：让前后结点，建立关系；</p><p>1）两个辅助指针变量形成差值后：后继结点的左孩子指向前驱结点，前驱结点的右孩子指向后继结点。</p><p>2）赋值指针变量和业务操作的逻辑关系</p><img src="/images/imageProgramC/数据结构-53.png"><img src="/images/imageProgramC/数据结构-54.png"><p>4） 二叉树线索化树的遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 中序遍历二叉线索树T(头结点)的非递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrNode* T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">BiThrNode* p;</span><br><span class="line">p = T-&gt;lchild; <span class="comment">/* p指向根结点 */</span></span><br><span class="line"><span class="keyword">while</span> (p != T)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">/* 空树或遍历结束时,p==T */</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;LTag == Link)</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-霍夫曼树"><a href="#4-5-霍夫曼树" class="headerlink" title="4.5 霍夫曼树"></a>4.5 <strong>霍夫曼树</strong></h3><p>组建一个网络，耗费最小 WPL最小；这个方法是霍夫曼想出来的，称为霍夫曼树</p><img src="/images/imageProgramC/数据结构-55.png"><p><strong>霍夫曼树的构造</strong></p><p>对于文本 ”BADCADFEED” 的传输而言，因为重复出现的只有 ”ABCDEF” 这6个字符，因此可以用下面的方式编码：</p><img src="/images/imageProgramC/数据结构-56.png"><p>接收方可以根据每3个bit进行一次字符解码的方式还原文本信息。</p><p>这样的编码方式需要30个bit位才能表示10个字符</p><p>那么当传输一篇500个字符的情报时，需要15000个bit位</p><p>在战争年代，这种编码方式对于情报的发送和接受是很低效且容易出错的。</p><p>如何提高收发效率？</p><p>要提高效率，必然要从编码方式的改进入手，要避免每个字符都占用相同的bit位</p><img src="/images/imageProgramC/数据结构-57.png"><p>准则：任一字符的<strong>编码</strong>都不是另一个字符编码的前缀！</p><p>也就是说：每一个字符的编码路径，都不包含另外一个字符的路径。</p><blockquote><p>霍夫曼树</p><p>1、给定 n 个数值 { v1, v2, …, vn}</p><p>2、根据这 n 个数值构造二叉树集合 F</p><p>F = { T1, T2, …, Tn}</p><p>Ti 的数据域为 vi，左右子树为空</p><p>3、在 F 中选取两棵根结点的值最小的树作为左右子树构造一棵新的二叉树，这棵二叉树的根结点中的值为左右子树根结点中的值之和</p><p>4、在 F 中删除这两棵子树，并将构造的新二叉树加入F中</p><p>5、重复 3 和 4，直到 F 中只剩下一个树为止。这棵树即霍夫曼树</p></blockquote><p>假设经过统计 ABCDEF 在需要传输的报文中出现的概率如下</p><img src="/images/imageProgramC/数据结构-58.png"><img src="/images/imageProgramC/数据结构-59.png"><p>霍夫曼树是一种特殊的二叉树           </p><p>霍夫曼树应用于信息编码和数据压缩领域 </p><p>霍夫曼树是现代压缩算法的基础 </p><h2 id="五、-排序"><a href="#五、-排序" class="headerlink" title="五、 排序"></a>五、 排序</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。</p><p>排序数学定义：</p><ul><li>假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：Kp1≤Kp2≤…≤Kpn 。按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序 </li></ul><p>排序的稳定性：</p><ul><li>如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的；否则称这个排序方法是不稳定的。</li></ul><p>多关键字排序：</p><ul><li><p>排序时需要比较的关键字多余一个</p></li><li><p>排序结果首先按关键字1进行排序</p></li><li><p>当关键字1相同时按关键字2进行排序</p></li><li><p>当关键字n-1相同时按关键字n进行排序</p></li><li><p>对于多关键字排序，只需要在比较操作时同时考虑多个关键字即可！</p></li></ul><p>排序中的关键操作：</p><ul><li><p>比较</p><ul><li>任意两个数据元素通过比较操作确定先后次序</li></ul></li><li><p>交换</p><ul><li>数据元素之间需要交换才能得到预期结果</li></ul></li></ul><p>内排序和外排序：</p><ul><li><p>内排序</p><ul><li>整个排序过程不需要访问外存便能完成  </li></ul></li><li><p>外排序</p><ul><li>待排序的数据元素数量很大，整个序列的排序过程不可能在内存中完成</li></ul></li></ul><p>排序的审判：</p><ul><li><p>时间性能</p><ul><li>关键性能差异体现在比较和交换的数量  </li></ul></li><li><p>辅助存储空间</p><ul><li>为完成排序操作需要的额外的存储空间  </li><li>必要时可以“空间换时间”</li></ul></li><li><p>算法的实现复杂性</p><ul><li>过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能</li></ul></li></ul><p>总结：</p><ul><li><p>排序是数据元素从无序到有序的过程</p></li><li><p>排序具有稳定性，是选择排序算法的因素之一</p></li><li><p>比较和交换是排序的基本操作</p></li><li><p>多关键字排序与单关键字排序无本质区别</p></li><li><p>排序的时间性能是区分排序算法好坏的主要因素</p></li></ul><h3 id="5-2-选择法"><a href="#5-2-选择法" class="headerlink" title="5.2 选择法"></a>5.2 选择法</h3><p>基本思想：</p><ul><li>每一趟 (例如第 i 趟，i = 0, 1, …,n-2)在后面 n-i个待排的数据元素中选出关键字最小的元素, 作为有序元素序列的第 i 个元素。</li></ul><p>排序过程：</p><ul><li><p>首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换</p></li><li><p>再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第二个记录交换</p></li><li><p>重复上述操作，共进行n-1趟排序后，排序结束</p></li></ul><img src="/images/imageProgramC/数据结构-60.png"><img src="/images/imageProgramC/数据结构-61.png"><h3 id="5-3-插入排序"><a href="#5-3-插入排序" class="headerlink" title="5.3 插入排序"></a>5.3 插入排序</h3><p>基本思想：</p><ul><li>元素1个元素，</li></ul><p>排序过程：</p><ul><li>整个排序过程为 n-1 趟插入，即先将序列中第 1 个记录看成是一个有序子序列，然后从第 2 个记录开始，逐个进行插入，直至整个序列有序</li></ul><p>实质：对线性表执行 n-1 次插入操作，只是先要找到插入位置</p><p>V[0], V[1], …, V[i-1] 已经排好序。这时已经排好序。这时,用V[i]的关键字与 V[i-1], V[i-2], …的关键字进行比较, 找到插入位置即将V[i]]插入, 原来位置上的对象向后顺移。</p><p>插入排序关键点：</p><ul><li>1、拿出一个元素，留出位置</li><li>2、符合条件的元素后移</li></ul><img src="/images/imageProgramC/数据结构-62.png"><h3 id="5-4-冒泡排序"><a href="#5-4-冒泡排序" class="headerlink" title="5.4 冒泡排序"></a>5.4 冒泡排序</h3><img src="/images/imageProgramC/数据结构-63.png"><img src="/images/imageProgramC/数据结构-64.png"><h3 id="5-5-希尔排序"><a href="#5-5-希尔排序" class="headerlink" title="5.5 希尔排序"></a>5.5 希尔排序</h3><p>排序过程：</p><ul><li>先取一个正整数 d1&lt;n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2&lt;d1，重复上述分组和排序操作；直至 di=1，即所有记录放进一个组中排序为止</li></ul><p>O(n-1.3)</p><p>Q(nlogn)    </p><p>希尔排序是不稳定的。</p><img src="/images/imageProgramC/数据结构-65.png"><h3 id="5-6-快速排序"><a href="#5-6-快速排序" class="headerlink" title="5.6 快速排序"></a>5.6 快速排序</h3><p>思想：</p><ul><li><p>快速排序是对冒泡排序的一种改进。它的基本思想是：</p></li><li><p>通过一躺排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，基准数据排在这两个子序列的中间；</p></li><li><p>然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></li></ul><img src="/images/imageProgramC/数据结构-67.png"><img src="/images/imageProgramC/数据结构-68.png"><img src="/images/imageProgramC/数据结构-69.png"><img src="/images/imageProgramC/数据结构-70.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n*logn)</span></span><br><span class="line">不稳定，分组，后面的有可能跑到前面去了。</span><br><span class="line"><span class="number">21</span> <span class="number">100</span> <span class="number">3</span> <span class="number">50</span> <span class="number">1</span>  </span><br><span class="line"><span class="number">3</span> <span class="number">1</span>  <span class="number">21</span>  <span class="number">100</span> <span class="number">50</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span>    <span class="number">21</span>   <span class="number">50</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="5-7-归并排序"><a href="#5-7-归并排序" class="headerlink" title="5.7 归并排序"></a>5.7 归并排序</h3><p>注意：一个元素，可以看做有序的，是稳定的算法</p><img src="/images/imageProgramC/数据结构-71.png"><img src="/images/imageProgramC/数据结构-72.png"><img src="/images/imageProgramC/数据结构-73.png"><p>对一个数组分成两路，mid中间</p><img src="/images/imageProgramC/数据结构-74.png"><p>设两个有序的子文件(相当于输入堆)放在同一向量中相邻的位置上：R[low..m],R[m+1..high],先将它们合并到一个局部的暂存向量R1(相当于输出堆)中,待合并完成后将R1复制回R[low..high]中。  </p><img src="/images/imageProgramC/数据结构-75.png"><h3 id="5-8-排序总结"><a href="#5-8-排序总结" class="headerlink" title="5.8 排序总结"></a>5.8 排序总结</h3><img src="/images/imageProgramC/数据结构-90.png"><h2 id="六、C-模板类与数据结构基础"><a href="#六、C-模板类与数据结构基础" class="headerlink" title="六、C++ 模板类与数据结构基础"></a>六、C++ 模板类与数据结构基础</h2><p>C++模板是容器的概念。</p><img src="/images/imageProgramC/数据结构-77.png"><p><strong>理论提高：</strong>所有容器提供的都是值（value）语意，而非引用（reference）语意。<strong>容器执行插入元素的操作时，内部实施拷贝动作。</strong>所以STL容器内存储的元素必须<strong>能够被拷贝</strong>（必须提供拷贝构造函数）。</p><p>加入到容器中的元素，应该可以被加入才行。</p><p><strong>模板类设计与实现</strong></p><blockquote><p>链表类_链式存储设计与实现 </p><p>栈类_链式存储设计与实现 </p><p>队列类_链式存储设计与实现 </p></blockquote><blockquote><p>链表类_顺序存储设计与实现 </p><p>栈类_顺序存储设计与实现 </p><p>队列类_顺序存储设计与实现 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;
    
    </summary>
    
      <category term="Program-C" scheme="http://miaopei.github.io/categories/Program-C/"/>
    
    
      <category term="Program-C" scheme="http://miaopei.github.io/tags/Program-C/"/>
    
  </entry>
  
  <entry>
    <title>Program-C 进阶</title>
    <link href="http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/"/>
    <id>http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/</id>
    <published>2016-05-24T02:14:50.000Z</published>
    <updated>2019-06-10T08:03:35.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-语言进阶"><a href="#C-语言进阶" class="headerlink" title="C 语言进阶"></a>C 语言进阶</h1><h2 id="一、-内存分区"><a href="#一、-内存分区" class="headerlink" title="一、 内存分区"></a>一、 内存分区</h2><p>栈区</p><ul><li>由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。</li></ul><a id="more"></a><p>堆区</p><ul><li>由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：在内存动态存储区中分配nmemb块长度为size字节的连续区域。<span class="built_in">calloc</span>自动将分配的内存置<span class="number">0</span>。</span><br><span class="line">参数：</span><br><span class="line">nmemb：所需内存单元数量</span><br><span class="line">size：每个内存单元的大小（单位：字节）</span><br><span class="line">返回值：</span><br><span class="line">成功：分配空间的起始地址</span><br><span class="line">失败：<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：重新分配用<span class="built_in">malloc</span>或者<span class="built_in">calloc</span>函数在堆中分配内存空间的大小。<span class="built_in">realloc</span>不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么<span class="built_in">realloc</span>会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。</span><br><span class="line">参数：</span><br><span class="line">ptr：为之前用<span class="built_in">malloc</span>或者<span class="built_in">calloc</span>分配的内存地址，如果此参数等于<span class="literal">NULL</span>，那么和<span class="built_in">realloc</span>与<span class="built_in">malloc</span>功能一致</span><br><span class="line">size：为重新分配内存的大小, 单位：字节</span><br><span class="line">返回值：</span><br><span class="line">成功：新分配的堆内存地址</span><br><span class="line">失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>全局/静态区</p><ul><li><p>全局静态区内的变量在编译阶段已经分配好内存空间并初始化。这块内存在程序运行期间一直存在,它主要存储<strong>全局变量</strong>、<strong>静态变量</strong>和<strong>常量</strong>。</p><p><strong>注意</strong>：</p><ul><li>这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。</li><li>全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。</li><li>字符串常量存储在全局/静态存储区的常量区。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">10</span>;<span class="comment">//全局/静态区</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> v2 = <span class="number">20</span>; <span class="comment">//常量，一旦初始化，不可修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> v3 = <span class="number">20</span>; <span class="comment">//全局/静态区</span></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局/静态区，编译器默认初始化为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么全局static int 和 全局int变量有什么区别？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> v4 = <span class="number">20</span>; <span class="comment">//全局/静态区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串常量是否可修改？字符串常量优化</strong>：</p><table><thead><tr><th>ANSI C中规定：修改字符串常量，结果是未定义的。<br>ANSI C并没有规定编译器的实现者对字符串的处理，例如：<br>1. 有些编译器可修改字符串常量，有些编译器则不可修改字符串常量。<br>2. 有些编译器把多个相同的字符串常量看成一个（这种优化可能出现在字符串常量中，节省空间），有些则不进行此优化。如果进行优化，则可能导致修改一个字符串常量导致另外的字符串常量也发生变化，结果不可知。<br><strong>所以尽量不要去修改字符串常量</strong>！</th></tr></thead><tbody><tr><td>C99标准：<br>char <em>p = “abc”; defines p with type ‘‘pointer to char’’ and initializes it to point to an object with type ‘‘array of char’’ with length 4 whose elements are initialized with a character string literal. *</em>If an attempt is made to use p to modify the contents of the array, the behavior is undefined**.</td></tr></tbody></table><p><strong>总结</strong></p><p>在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等，初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。</p><p><strong>数据区包括</strong>：堆，栈，全局/静态存储区。</p><p><strong>全局/静态存储区包括</strong>：常量区，全局区、静态区。</p><p><strong>常量区包括</strong>：字符串常量区、常变量区。</p><p><strong>代码区</strong>：存放程序编译后的二进制代码，不可寻址区。</p><p><strong>可以说，C/C++内存分区其实只有两个，即代码区和数据区</strong>。</p><p>函数调用模型：</p><ul><li>在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。</li></ul><p>栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：</p><ul><li>函数的返回地址；</li><li>函数的参数；</li><li>临时变量；</li><li>保存的上下文：包括在函数调用前后需要保持不变的寄存器。</li></ul><img src="/images/imageProgramC/函数调用流程.png"><p>栈的生长方向和内存存放方向：</p><img src="/images/imageProgramC/栈的生长方向和内存存放方向.png"><h2 id="二、指针强化"><a href="#二、指针强化" class="headerlink" title="二、指针强化"></a>二、指针强化</h2><p><strong>指针是一种数据类型，占用内存空间，用来保存内存地址</strong>。</p><h3 id="2-1-野指针和空指针"><a href="#2-1-野指针和空指针" class="headerlink" title="2.1 野指针和空指针"></a>2.1 野指针和空指针</h3><h4 id="2-1-1-空指针"><a href="#2-1-1-空指针" class="headerlink" title="2.1.1 空指针"></a>2.1.1 空指针</h4><p>标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。</p><p>对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未执行任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。</p><p>如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。</p><p><strong>不允许向NULL和非法地址拷贝内存</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//给p指向的内存区域拷贝内容</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"1111"</span>); <span class="comment">//err</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *q = <span class="number">0x1122</span>;</span><br><span class="line"><span class="comment">//给q指向的内存区域拷贝内容</span></span><br><span class="line"><span class="built_in">strcpy</span>(q, <span class="string">"2222"</span>); <span class="comment">//err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-野指针"><a href="#2-1-2-野指针" class="headerlink" title="2.1.2 野指针"></a>2.1.2 野指针</h4><p><strong>在使用指针时，要避免野指针的出现</strong>：</p><p>野指针指向一个已删除的对象或未申请访问受限内存区域的<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzE1OTQxNy5odG0=" title="http://baike.baidu.com/view/159417.htm">指针<i class="fa fa-external-link"></i></span>。与空指针不同，野指针无法通过简单地判断是否为 <span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzMyOTQ4NC5odG0=" title="http://baike.baidu.com/view/329484.htm">NULL<i class="fa fa-external-link"></i></span>避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。</p><p><strong>什么情况下会导致野指针</strong>？</p><ul><li><p><strong>指针变量未初始化</strong></p><ul><li>任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</li></ul></li><li><p><strong>指针释放后未置空</strong></p><ul><li>有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。</li></ul></li><li><p><strong>指针操作超越变量作用域</strong></p><ul><li><strong>不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放</strong>。</li></ul></li></ul><p><strong>操作野指针是非常危险的操作，应该规避野指针的出现</strong>：</p><ul><li><p><strong>初始化时置 NULL</strong></p><ul><li>指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。</li></ul></li><li><p><strong>释放时置 NULL</strong></p><ul><li>当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。</li></ul></li></ul><p><strong>用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据</strong>，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。请看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func(), n;</span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value = %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">100</span></span><br></pre></td></tr></table></figure><p> n 是 func() 内部的局部变量，func() 返回了指向 n 的指针，根据上面的观点，func() 运行结束后 n 将被销毁，使用 <code>*p</code> 应该获取不到 n 的值。但是从运行结果来看，我们的推理好像是错误的，func() 运行结束后 <code>*p</code> 依然可以获取局部变量 n 的值，这个上面的观点不是相悖吗？</p><p>为了进一步看清问题的本质，不妨将上面的代码稍作修改，在第9~10行之间增加一个函数调用，看看会有什么效果：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func(), n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c.biancheng.net\n"</span>);</span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value = %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.biancheng.net</span><br><span class="line">value = <span class="number">-2</span></span><br></pre></td></tr></table></figure><p>可以看到，现在 p 指向的数据已经不是原来 n 的值了，它变成了一个毫无意义的甚至有些怪异的值。与前面的代码相比，该段代码仅仅是在 <code>*p</code> 之前增加了一个函数调用，这一细节的不同却导致运行结果有天壤之别，究竟是为什么呢？</p><p>前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。</p><blockquote><p>关于函数调用的原理以及函数如何占用内存的更多细节，我们将在《<span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9jcHAvdS9jMjAv" title="http://c.biancheng.net/cpp/u/c20/">C语言和内存<i class="fa fa-external-link"></i></span>》专题中深入探讨，相信你必将有所顿悟，解开心中的谜团。</p></blockquote><p>第一个例子在调用其他函数之前使用 <code>*p</code> 抢先获得了 n 的值并将它保存起来，第二个例子显然没有抓住机会，有其他函数被调用后才使用 <code>*p</code> 获取数据，这个时候已经晚了，内存已经被后来的函数覆盖了，而覆盖它的究竟是一份什么样的数据我们无从推断（一般是一个没有意义甚至有些怪异的值）。</p><p><strong>总结</strong>：</p><p>常规程序中，函数返回的指针通常应该是：</p><ul><li>指向静态（static）变量；</li><li>指向专门申请分配的（如用malloc）空间；</li><li>指向常量区（如指向字符串”hello”）；</li><li>指向全局变量；</li><li>指向程序代码区（如指向函数的指针）。 </li></ul><p>除这5项以外，其它怪技巧不提倡。</p><p><strong>函数内的变量，没有关键字static修饰的变量的生命周期只在本函数内，函数结束后变量自动销毁</strong>。当返回为指针的时候需要特别注意，因为<strong>函数结束后指针所指向的地址依然存在，但是该地址可以被其他程序修改，里面的内容就不确定了，有可能后面的操作会继续用到这块地址，有可能不会用到，所以会出现时对时错的情况，如果需要返回一个指针而又不出错的话只能调用内存申请函数</strong></p><h3 id="2-2-间接访问操作符"><a href="#2-2-间接访问操作符" class="headerlink" title="2.2 间接访问操作符"></a>2.2 间接访问操作符</h3><p>通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是 <code>*</code>。</p><p>注意：对一个<code>int*</code>类型指针解引用会产生一个整型值，类似地，对一个<code>float*</code>指针解引用会产生了一个float类型的值。</p><ul><li><p>在指针声明时，<code>*</code> 号表示所声明的变量为指针</p></li><li><p>在指针使用时，<code>*</code> 号表示操作指针所指向的内存空间</p><ul><li><code>*</code> 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存</li><li><code>*</code> 放在等号的左边赋值（给内存赋值，写内存）</li><li><code>*</code> 放在等号的右边取值（从内存中取值，读内存）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指针</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//指针指向谁，就把谁的地址赋给指针</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">p = &amp;a;</span><br><span class="line">*p = <span class="number">20</span>;<span class="comment">//*在左边当左值，必须确保内存可写</span></span><br><span class="line"><span class="comment">//*号放右面，从内存中读值</span></span><br><span class="line"><span class="keyword">int</span> b = *p;</span><br><span class="line"><span class="comment">//必须确保内存可写</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"hello world!"</span>;</span><br><span class="line">*str = <span class="string">'m'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p:%d\n"</span>, *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b:%d\n"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-指针的步长"><a href="#2-3-指针的步长" class="headerlink" title="2.3 指针的步长"></a>2.3 <strong>指针的步长</strong></h3><p>指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。</p><h3 id="2-4-指针的意义-间接赋值"><a href="#2-4-指针的意义-间接赋值" class="headerlink" title="2.4 指针的意义_间接赋值"></a>2.4 指针的意义_间接赋值</h3><p>通过指针间接赋值成立的三大条件：</p><ul><li><p>2个变量（一个普通变量一个指针变量、或者一个实参一个形参）</p></li><li><p>建立关系</p></li><li><p>通过 <code>*</code> 操作指针指向的内存</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;<span class="comment">//两个变量</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//建立关系</span></span><br><span class="line"><span class="comment">//指针指向谁，就把谁的地址赋值给指针</span></span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="comment">//通过*操作内存</span></span><br><span class="line">*p = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>间接赋值：从1级指针到2级指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllocateSpace</span><span class="params">(<span class="keyword">char</span>** p)</span></span>&#123;</span><br><span class="line">*p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(*p, <span class="string">"hello world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeSpace</span><span class="params">(<span class="keyword">char</span>** p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(*p);</span><br><span class="line">*p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AllocateSpace(&amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br><span class="line">FreeSpace(&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p内存释放!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>间接赋值的推论</strong>：</p><ul><li><p>用 1 级指针形参，去间接修改了 0 级指针(实参)的值。</p></li><li><p>用 2 级指针形参，去间接修改了 1 级指针(实参)的值。</p></li><li><p>用 3 级指针形参，去间接修改了 2 级指针(实参)的值。</p></li><li><p>用 n 级指针形参，去间接修改了 n-1 级指针(实参)的值。</p></li></ul><h3 id="2-5-指针做函数参数"><a href="#2-5-指针做函数参数" class="headerlink" title="2.5 指针做函数参数"></a>2.5 指针做函数参数</h3><p>指针做函数参数，具备输入和输出特性：</p><ul><li><p>输入：主调函数分配内存</p></li><li><p>输出：被调用函数分配内存</p></li></ul><p>输入特性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p <span class="comment">/* in */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//给p指向的内存区域拷贝内容</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"abcddsgsd"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输入，主调函数分配内存</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">fun(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf  = %s\n"</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出特性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> **p <span class="comment">/* out */</span>, <span class="keyword">int</span> *len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp, <span class="string">"adlsgjldsk"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//间接赋值</span></span><br><span class="line">*p = tmp;</span><br><span class="line">*len = <span class="built_in">strlen</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输出，被调用函数分配内存，地址传递</span></span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">fun(&amp;p, &amp;len);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p = %s, len = %d\n"</span>, p, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-字符串指针强化"><a href="#2-6-字符串指针强化" class="headerlink" title="2.6 字符串指针强化"></a>2.6 字符串指针强化</h3><p><strong>字符串是以0或者’\0’结尾的字符数组，(数字0和字符’\0’等价)</strong></p><p><strong>如果以字符串初始化，那么编译器默认会在字符串尾部添加’\0’</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str3[] = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><ul><li><p>sizeof 计算数组大小，数组包含’\0’字符</p></li><li><p>strlen 计算字符串的长度，到’\0’结束</p></li></ul><p>字符串拷贝功能实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1）应该判断下传入的参数是否为NULL</span></span><br><span class="line"><span class="comment">//2）最好不要直接使用形参</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_string04</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">char</span>* source)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dest == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (source == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* src = source;</span><br><span class="line"><span class="keyword">char</span>* tar = dest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*tar++ = *src++)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串的格式化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">     根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 <span class="string">'\0'</span> 为止。</span><br><span class="line">参数： </span><br><span class="line">str：字符串首地址</span><br><span class="line">format：字符串格式，用法和<span class="built_in">printf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际格式化的字符个数</span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 格式化字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"你好,%s,欢迎加入我们!"</span>, <span class="string">"John"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>,buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"我今年%d岁了!"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 拼接字符串</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">sprintf</span>(buf,<span class="string">"%s %s"</span>,str1,str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s len:%d\n"</span>, buf,len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 数字转字符串</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"><span class="comment">//设置宽度 右对齐</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%8d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"><span class="comment">//设置宽度 左对齐</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%-8d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</span><br><span class="line">参数：</span><br><span class="line">str：指定的字符串首地址</span><br><span class="line">format：字符串格式，用法和<span class="built_in">scanf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际读取的字符个数</span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>格式</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>%*s或%*d</code></td><td>跳过数据</td></tr><tr><td>%[width]s</td><td>读指定宽度的数据</td></tr><tr><td>%[a-z]</td><td>匹配a到z中任意字符(尽可能多的匹配)</td></tr><tr><td>%[aBc]</td><td>匹配a、B、c中一员，贪婪性</td></tr><tr><td><code>%[^a]</code></td><td>匹配非a的任意字符，贪婪性</td></tr><tr><td><code>%[^a-z]</code></td><td>表示读取除a-z以外的所有字符</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 跳过数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//匹配第一个字符是否是数字，如果是，则跳过</span></span><br><span class="line"><span class="comment">//如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"123456aaaa"</span>, <span class="string">"%*d%s"</span>, buf); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 读取指定宽度数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"123456aaaa"</span>, <span class="string">"%7s"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 匹配a-z中任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line">  <span class="comment">//先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配</span></span><br><span class="line"><span class="comment">//如果不是停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"abcdefg123456"</span>, <span class="string">"%[a-z]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 匹配aBc中的任何一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"abcdefg123456"</span>, <span class="string">"%[aBc]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 匹配非a的任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"bcdefag123456"</span>, <span class="string">"%[^a]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 匹配非a-z中的任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"123456ABCDbcdefag"</span>, <span class="string">"%[^a-z]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-1-一级指针易错点"><a href="#2-6-1-一级指针易错点" class="headerlink" title="2.6.1 一级指针易错点"></a>2.6.1 一级指针易错点</h4><ul><li><p>越界</p></li><li><p>指针叠加会不断改变指针指向 <code>p++</code></p></li><li><p>返回局部变量地址</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdedsgads"</span>; <span class="comment">//栈区，</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[get_str]str = %s\n"</span>, str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同一块内存释放多次<ul><li>free()函数的功能只是告诉系统 p 指向的内存可以回收了。就是说，p 指向的内存使用权交还给系统。但是，p的值还是原来的值(野指针)，p还是指向原来的内存</li></ul></li></ul><h3 id="2-7-const使用"><a href="#2-7-const使用" class="headerlink" title="2.7 const使用"></a>2.7 const使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const修饰变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1. const基本概念</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//i = 100; //错误，只读变量初始化之后不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义const变量最好初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="comment">//j = 100; //错误，不能再次赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. c语言的const是一个只读变量，并不是一个常量，可通过指针间接修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//k = 100; //错误，不可直接修改，我们可通过指针间接修改</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"k:%d\n"</span>, k);</span><br><span class="line"><span class="keyword">int</span>* p = &amp;k;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"k:%d\n"</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const 修饰指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//const放在*号左侧 修饰p_a指针指向的内存空间不能修改,但可修改指针的指向</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p_a = &amp;a;</span><br><span class="line"><span class="comment">//*p_a = 100; //不可修改指针指向的内存空间</span></span><br><span class="line">p_a = &amp;b; <span class="comment">//可修改指针的指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const放在*号的右侧， 修饰指针的指向不能修改，但是可修改指针指向的内存空间</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p_b = &amp;a;</span><br><span class="line"><span class="comment">//p_b = &amp;b; //不可修改指针的指向</span></span><br><span class="line">*p_b = <span class="number">100</span>; <span class="comment">//可修改指针指向的内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的指向和指针指向的内存空间都不能修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p_c = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const指针用法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次都对对象进行拷贝，效率低，应该用指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonByValue</span><span class="params">(struct Person person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, person.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是用指针会有副作用，可能会不小心修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonByPointer</span><span class="params">(<span class="keyword">const</span> struct Person *person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, person-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span> = &#123;</span> <span class="string">"Obama"</span>, <span class="number">1101</span>, <span class="number">23</span>, <span class="number">87</span> &#125;;</span><br><span class="line"><span class="comment">//printPersonByValue(p);</span></span><br><span class="line">printPersonByPointer(&amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、指针的指针-二级指针"><a href="#三、指针的指针-二级指针" class="headerlink" title="三、指针的指针(二级指针)"></a>三、指针的指针(二级指针)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br></pre></td></tr></table></figure><p>它在内存中的大概模样大致如下：</p><img src="/images/imageProgramC/二级指针.png"><h3 id="3-1-二级指针做形参输出特性"><a href="#3-1-二级指针做形参输出特性" class="headerlink" title="3.1 二级指针做形参输出特性"></a>3.1 二级指针做形参输出特性</h3><p>二级指针做参数的输出特性是指由被调函数分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调函数,由参数n确定分配多少个元素内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate_space</span><span class="params">(<span class="keyword">int</span> **arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//堆上分配n个int类型元素内存</span></span><br><span class="line"><span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)* n);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == temp)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给内存初始化值</span></span><br><span class="line"><span class="keyword">int</span> *pTemp = temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line"><span class="comment">//temp[i] = i + 100;</span></span><br><span class="line">*pTemp = i + <span class="number">100</span>;</span><br><span class="line">pTemp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针间接赋值</span></span><br><span class="line">*arr = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二级指针输出特性(由被调函数分配内存)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//给arr指针间接赋值</span></span><br><span class="line">allocate_space(&amp;arr,n);</span><br><span class="line"><span class="comment">//输出arr指向数组的内存</span></span><br><span class="line">print_array(arr, n);</span><br><span class="line"><span class="comment">//释放arr所指向内存空间的值</span></span><br><span class="line"><span class="keyword">if</span> (arr != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-二级指针做形参输入特性"><a href="#3-2-二级指针做形参输入特性" class="headerlink" title="3.2 二级指针做形参输入特性"></a>3.2 二级指针做形参输入特性</h3><p>二级指针做形参输入特性是指由主调函数分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> **arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,*(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二级指针输入特性(由主调函数分配内存)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> a5 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>** arr = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * n);</span><br><span class="line">arr[<span class="number">0</span>] = &amp;a1;</span><br><span class="line">arr[<span class="number">1</span>] = &amp;a2;</span><br><span class="line">arr[<span class="number">2</span>] = &amp;a3;</span><br><span class="line">arr[<span class="number">3</span>] = &amp;a4;</span><br><span class="line">arr[<span class="number">4</span>] = &amp;a5;</span><br><span class="line"></span><br><span class="line">print_array(arr,n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、位运算"><a href="#四、位运算" class="headerlink" title="四、位运算"></a>四、位运算</h2><h3 id="4-1-位逻辑运算符"><a href="#4-1-位逻辑运算符" class="headerlink" title="4.1 位逻辑运算符"></a>4.1 位逻辑运算符</h3><p>4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(&amp;&amp; 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。</p><ul><li><strong>按位取反~</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> a = <span class="number">2</span>;   <span class="comment">//00000010</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b = ~a;  <span class="comment">//11111101</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, a); <span class="comment">//ret = 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, b); <span class="comment">//ret = 253</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>位与（AND）: &amp;</strong></p><ul><li>二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。</li></ul></li><li><p><strong>位或（OR）: |</strong></p><ul><li>二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1.</li></ul></li><li><p><strong>位异或:</strong></p><ul><li>二进制运算符 <code>^</code> 对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0.</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10010011</span>) </span><br><span class="line">^ (<span class="number">00111101</span>)</span><br><span class="line">= (<span class="number">10101110</span>)</span><br></pre></td></tr></table></figure><p><strong>用法</strong>：</p><ul><li>打开位</li></ul><p>已知：10011010：</p><ol><li><p>将位2打开</p><p><code>flag | 10011010</code></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">| (<span class="number">00000100</span>)</span><br><span class="line">= (<span class="number">10011110</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>将所有位打开。</p><p><code>flag | ~flag</code></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">| (<span class="number">01100101</span>)</span><br><span class="line">= (<span class="number">11111111</span>)</span><br></pre></td></tr></table></figure><ul><li><p>关闭位</p><p><code>flag &amp; ~flag</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">&amp; (<span class="number">01100101</span>)</span><br><span class="line">= (<span class="number">00000000</span>)</span><br></pre></td></tr></table></figure><ul><li><p>转置位</p><ul><li>转置(toggling)一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开。您可以使用位异或运算符来转置。其思想是如果b是一个位(1或0)，那么如果b为1则 <code>b^1</code> 为0，如果b为0，则 <code>1^b</code> 为1。无论b的值是0还是1, <code>0^b</code> 为b.</li></ul><p><code>flag ^ 0xff</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10010011</span>)</span><br><span class="line">^ (<span class="number">11111111</span>)</span><br><span class="line">= (<span class="number">01101100</span>)</span><br></pre></td></tr></table></figure><ul><li>交换两个数不需要临时变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a ^ b = temp;</span></span><br><span class="line"><span class="comment">//a ^ temp = b;</span></span><br><span class="line"><span class="comment">//b ^ temp = a</span></span><br><span class="line">  (<span class="number">10010011</span>)</span><br><span class="line">^ (<span class="number">00100110</span>)</span><br><span class="line">= (<span class="number">10110101</span>)</span><br><span class="line"></span><br><span class="line">  (<span class="number">10110101</span>)</span><br><span class="line">^ (<span class="number">00100110</span>)</span><br><span class="line">   <span class="number">10010011</span></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = b ^ a;</span><br><span class="line">    a = a ^ b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d b = %d/n"</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-移位运算符"><a href="#4-2-移位运算符" class="headerlink" title="4.2 移位运算符"></a>4.2 移位运算符</h3><ul><li><p><strong>左移 &lt;&lt;</strong></p><ul><li><p>左移运算符 <code>&lt;&lt;</code> 将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。</p></li><li><p>左移一位相当于原值 <code>*2</code>.</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10001010</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">(<span class="number">00101000</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">1</span> = <span class="number">2</span>;</span><br><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">1</span> = <span class="number">4</span>;</span><br><span class="line"><span class="number">4</span> &lt;&lt; <span class="number">1</span> = <span class="number">8</span>;</span><br><span class="line"><span class="number">8</span> &lt;&lt; <span class="number">2</span> = <span class="number">32</span></span><br></pre></td></tr></table></figure><ul><li><strong>右移 &gt;&gt;</strong><ul><li>右移运算符 <code>&gt;&gt;</code> 将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。<strong>对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充</strong>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有符号值</span></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">00100010</span>)     <span class="comment">//在某些系统上的结果值</span></span><br><span class="line"></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">11100010</span>)     <span class="comment">//在另一些系统上的解雇</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号值</span></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">00100010</span>)    <span class="comment">//所有系统上的结果值</span></span><br></pre></td></tr></table></figure><p><strong>用法：移位运算符</strong>：</p><ul><li>移位运算符能够提供快捷、高效（依赖于硬件）对2的幂的乘法和除法。</li></ul><table><thead><tr><th>number &lt;&lt; n</th><th>number乘以2的n次幂</th></tr></thead><tbody><tr><td>number &gt;&gt; n</td><td>如果number非负，则用number除以2的n次幂</td></tr></tbody></table><h2 id="五、多维数组"><a href="#五、多维数组" class="headerlink" title="五、多维数组"></a>五、多维数组</h2><h3 id="5-1-一维数组"><a href="#5-1-一维数组" class="headerlink" title="5.1 一维数组"></a>5.1 一维数组</h3><ul><li>元素类型角度：数组是相同类型的变量的有序集合</li><li>内存角度：连续的一大片内存空间</li></ul><p><strong>请问：指针和数组是等价的吗？</strong></p><p>答案是<strong>否定</strong>的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下：</p><ul><li>当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。</li><li>当数组名作为&amp;操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//arr = NULL; //arr作为指针常量，不可修改</span></span><br><span class="line"><span class="keyword">int</span> *p = arr; <span class="comment">//此时arr作为指针常量来使用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(arr):%d\n"</span>, <span class="keyword">sizeof</span>(arr)); <span class="comment">//此时sizeof结果为整个数组的长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;arr type is %s\n"</span>, <span class="keyword">typeid</span>(&amp;arr).name()); <span class="comment">//int(*)[10]而不是int*</span></span><br></pre></td></tr></table></figure><p><strong>下标引用</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>*(arr + 3)</strong> ,这个表达式是什么意思呢？<ul><li>首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(arr + <span class="number">3</span>)</span><br><span class="line">arr[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>问题 1</strong>：数组下标可否为负值？</p><p><strong>问题 2</strong>：请阅读如下代码，说出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, *p); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, p[<span class="number">-1</span>]);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="5-1-1-数组和指针"><a href="#5-1-1-数组和指针" class="headerlink" title="5.1.1 数组和指针"></a>5.1.1 数组和指针</h4><p>指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *b;</span><br></pre></td></tr></table></figure><p>声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。</p><p>因此，表达式 <code>*a</code> 是完全合法的，但是表达式 <code>*b</code> 却是非法的。<code>*b</code> 将访问内存中一个不确定的位置，将会导致程序终止。另一方面 b++ 可以通过编译，a++ 却不行，因为 a 是一个常量值。</p><h4 id="5-1-2-作为函数参数的数组名"><a href="#5-1-2-作为函数参数的数组名" class="headerlink" title="5.1.2 作为函数参数的数组名"></a>5.1.2 作为函数参数的数组名</h4><p>当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> *arr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。<strong>同样sizeof arr值是指针的长度，而不是数组的长度</strong>。</p><p>现在我们清楚了，<strong>为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数</strong>。</p><h3 id="5-2-多维数组"><a href="#5-2-多维数组" class="headerlink" title="5.2 多维数组"></a>5.2 多维数组</h3><p><strong>数组名</strong>：</p><ul><li>一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。</p><p><strong>指向数组的指针(数组指针)</strong>：</p><p>数组指针，它是指针，指向数组的指针。</p><p>数组的类型由<strong>元素类型</strong>和<strong>数组大小</strong>共同决定：int array[5]  的类型为  int[5]；C语言可通过typedef定义一个数组类型：</p><p>定义数组指针有一下三种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先定义数组类型，再用数组类型定义数组指针</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType</span></span><br><span class="line">typedef int(ArrayType)[10];</span><br><span class="line"><span class="comment">//int ArrayType[10]; //定义一个数组，数组名为ArrayType</span></span><br><span class="line"></span><br><span class="line">ArrayType myarr; <span class="comment">//等价于 int myarr[10];</span></span><br><span class="line">ArrayType* pArr = &amp;arr; <span class="comment">//定义了一个数组指针pArr，并且指针指向数组arr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,(*pArr)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//定义数组指针类型</span></span><br><span class="line">typedef int(*ArrayType)[10];</span><br><span class="line">ArrayType pArr = &amp;arr; <span class="comment">//定义了一个数组指针pArr，并且指针指向数组arr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">(*pArr)[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, (*pArr)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>(*pArr)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">(*pArr)[i] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, (*pArr)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-1-指针数组-元素为指针"><a href="#5-2-1-指针数组-元素为指针" class="headerlink" title="5.2.1 指针数组(元素为指针)"></a>5.2.1 指针数组(元素为指针)</h4><p><strong>栈区指针数组</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组做函数函数，退化为指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_sort</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j --)&#123;</span><br><span class="line"><span class="comment">//比较两个字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(arr[j<span class="number">-1</span>],arr[j]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">char</span>* temp = arr[j - <span class="number">1</span>];</span><br><span class="line">arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//主调函数分配内存</span></span><br><span class="line"><span class="comment">//指针数组</span></span><br><span class="line"><span class="keyword">char</span>* p[] = &#123; <span class="string">"bbb"</span>, <span class="string">"aaa"</span>, <span class="string">"ccc"</span>, <span class="string">"eee"</span>, <span class="string">"ddd"</span>&#125;;</span><br><span class="line"><span class="comment">//char** p = &#123; "aaa", "bbb", "ccc", "ddd", "eee" &#125;; //错误</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">array_print(p, len);</span><br><span class="line"><span class="comment">//对字符串进行排序</span></span><br><span class="line">array_sort(p, len);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">array_print(p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆区指针数组</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">allocate_memory</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>** temp = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * n);</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分别给每一个指针malloc分配内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">temp[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)* <span class="number">30</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp[i], <span class="string">"%2d_hello world!"</span>, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(<span class="keyword">char</span>** buf,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buf == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line"><span class="built_in">free</span>(buf[i]);</span><br><span class="line">buf[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span>** p = allocate_memory(n);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">array_print(p, n);</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line">free_memory(p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维数组的线性存储特性式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的线性存储</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[][<span class="number">3</span>] = &#123;</span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr2[][<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何证明二维数组是线性的？</span></span><br><span class="line"><span class="comment">//通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">PrintArray((<span class="keyword">int</span>*)arr, len);</span><br><span class="line">PrintArray((<span class="keyword">int</span>*)arr2, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维数组的3种形式参数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组的第一种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray01</span><span class="params">(<span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的第二种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray02</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的第二种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray03</span><span class="params">(<span class="keyword">int</span>(*arr)[<span class="number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[][<span class="number">3</span>] = &#123; </span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintArray01(arr);</span><br><span class="line">PrintArray02(arr);</span><br><span class="line">PrintArray03(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p><strong>编程提示</strong>：</p><ul><li>源代码的可读性几乎总是比程序的运行时效率更为重要</li><li><strong>只要有可能，函数的指针形参都应该声明为const</strong></li><li>在多维数组的初始值列表中使用完整的多层花括号提供可读性</li></ul><p><strong>内容总结</strong>：</p><ul><li>在绝大多数表达式中，数组名的值是指向数组第1个元素的指针。<strong>这个规则只有两个例外，sizeof和对数组名&amp;</strong>。</li><li>指针和数组并不相等。当我们声明一个数组的时候，同时也分配了内存。但是声明指针的时候，只分配容纳指针本身的空间。</li><li>当数组名作为函数参数时，实际传递给函数的是一个指向数组第1个元素的指针。</li><li>我们不单可以创建指向普通变量的指针，也可创建指向数组的指针。</li></ul><h2 id="六、结构体"><a href="#六、结构体" class="headerlink" title="六、结构体"></a>六、结构体</h2><h3 id="6-1-结构体基础知识"><a href="#6-1-结构体基础知识" class="headerlink" title="6.1 结构体基础知识"></a>6.1 结构体基础知识</h3><p>结构体类型的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PERSON</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;Person;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。</p><p><strong>结构体变量的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;p1; <span class="comment">//定义类型同时定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;p2; <span class="comment">//定义类型同时定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p3</span>;</span> <span class="comment">//通过类型直接定义</span></span><br></pre></td></tr></table></figure><p><strong>结构体成员的使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//在栈上分配空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(p1.name, <span class="string">"John"</span>);</span><br><span class="line">p1.age = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//如果是普通变量，通过点运算符操作结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p1.name, p1.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆上分配空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">p2</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>));</span></span><br><span class="line"><span class="built_in">strcpy</span>(p2-&gt;name, <span class="string">"Obama"</span>);</span><br><span class="line">p2-&gt;age = <span class="number">33</span>;</span><br><span class="line"><span class="comment">//如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p2-&gt;name, p2-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝和浅拷贝</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个老师有N个学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Teacher t1;</span><br><span class="line">t1.name = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t1.name , <span class="string">"John"</span>);</span><br><span class="line"></span><br><span class="line">Teacher t2;</span><br><span class="line">t2 = t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对手动开辟的内存，需要手动拷贝</span></span><br><span class="line">t2.name = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t2.name, t1.name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(t1.name);</span><br><span class="line">t1.name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(t2.name);</span><br><span class="line">t1.name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//在栈上分配空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>[3] = &#123;</span></span><br><span class="line">&#123; <span class="string">"John"</span>, <span class="number">30</span> &#125;,</span><br><span class="line">&#123; <span class="string">"Obama"</span>, <span class="number">33</span> &#125;,</span><br><span class="line">&#123; <span class="string">"Edward"</span>, <span class="number">25</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>[3] = &#123;</span> <span class="string">"John"</span>, <span class="number">30</span>, <span class="string">"Obama"</span>, <span class="number">33</span>, <span class="string">"Edward"</span>, <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>,p1[i].name,p1[i].age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----------------\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p2[i].name, p2[i].age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----------------\n"</span>);</span><br><span class="line"><span class="comment">//在堆上分配结构体数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">p3</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>) * 3);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(p3[i].name, <span class="string">"Name_%d"</span>, i + <span class="number">1</span>);</span><br><span class="line">p3[i].age = <span class="number">20</span> + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p3[i].name, p3[i].age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-结构体嵌套指针"><a href="#6-2-结构体嵌套指针" class="headerlink" title="6.2 结构体嵌套指针"></a>6.2 结构体嵌套指针</h3><p><strong>结构体嵌套一级指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate_memory</span><span class="params">(struct Person** person)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (person == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">temp</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>));</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给name指针分配内存</span></span><br><span class="line">temp-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)* <span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(temp-&gt;name, <span class="string">"John"</span>);</span><br><span class="line">temp-&gt;age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">*person = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_person</span><span class="params">(struct Person* person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>,person-&gt;name,person-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(struct Person** person)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (person == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">temp</span> = *<span class="title">person</span>;</span></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(temp-&gt;name);</span><br><span class="line">temp-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">allocate_memory(&amp;p);</span><br><span class="line">print_person(p);</span><br><span class="line">free_memory(&amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体嵌套二级指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个老师有N个学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">char</span>** students;</span><br><span class="line">&#125;Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_teacher</span><span class="params">(Teacher** teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (teacher == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建老师数组</span></span><br><span class="line">Teacher* teachers = (Teacher*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Teacher)* n);</span><br><span class="line"><span class="keyword">if</span> (teachers == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给每一个老师分配学生</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(teachers[i].name, <span class="string">"老师_%d"</span>, i + <span class="number">1</span>);</span><br><span class="line">teachers[i].students = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)&#123;</span><br><span class="line">teachers[i].students[j] = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(teachers[i].students[j], <span class="string">"学生_%d"</span>, num + <span class="number">1</span>);</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*teacher = teachers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_teacher</span><span class="params">(Teacher* teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, teacher[i].name);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  %s"</span>,teacher[i].students[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(Teacher** teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (teacher == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher* temp = *teacher;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j ++)&#123;</span><br><span class="line"><span class="built_in">free</span>(temp[i].students[j]);</span><br><span class="line">temp[i].students[j] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(temp[i].students);</span><br><span class="line">temp[i].students = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Teacher* p = <span class="literal">NULL</span>;</span><br><span class="line">create_teacher(&amp;p,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">print_teacher(p, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">free_memory(&amp;p,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-结构体成员偏移量"><a href="#6-3-结构体成员偏移量" class="headerlink" title="6.3 结构体成员偏移量"></a>6.3 结构体成员偏移量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一旦结构体定义下来，则结构体中的成员内存布局就定下了</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> a;  </span><br><span class="line"><span class="keyword">int</span> b;      </span><br><span class="line"><span class="keyword">int</span> c;        </span><br><span class="line"></span><br><span class="line">&#125; Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Teacher  t1;</span><br><span class="line">Teacher*p = <span class="literal">NULL</span>;</span><br><span class="line">p = &amp;t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> offsize1 = (<span class="keyword">int</span>)&amp;(p-&gt;b) - (<span class="keyword">int</span>)p;  <span class="comment">//age 相对于结构体 Teacher的偏移量</span></span><br><span class="line"><span class="keyword">int</span> offsize2 = (<span class="keyword">int</span>)&amp;(((Teacher *)<span class="number">0</span>)-&gt;b);<span class="comment">//绝对0地址 age的偏移量</span></span><br><span class="line"><span class="keyword">int</span> offsize3 = offsetof(Teacher, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"offsize1:%d \n"</span>, offsize1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"offsize2:%d \n"</span>, offsize2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"offsize3:%d \n"</span>, offsize3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-结构体字节对齐"><a href="#6-4-结构体字节对齐" class="headerlink" title="6.4 结构体字节对齐"></a>6.4 结构体字节对齐</h3><p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。</p><p>从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是<strong>内存对齐</strong>。</p><h4 id="6-4-1-内存对齐原因"><a href="#6-4-1-内存对齐原因" class="headerlink" title="6.4.1 内存对齐原因"></a>6.4.1 内存对齐原因</h4><p>我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等</p><p>内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)。如果没有对齐，为了访问一个变量可能产生二次访问。</p><p><strong>为什么要简单内存对齐？</strong></p><ul><li>提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量。</li><li>某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。</li></ul><h4 id="6-4-2-如何内存对齐"><a href="#6-4-2-如何内存对齐" class="headerlink" title="6.4.2 如何内存对齐"></a>6.4.2 如何内存对齐</h4><ul><li>对于标准数据类型，它的地址只要是它的长度的整数倍。</li><li>对于非标准数据类型，比如结构体，要遵循一下对齐原则：<ul><li>数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为<strong>min（当前成员的大小，#pargama pack(n)）</strong>整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。</li><li>结构体总的大小，也就是sizeof的结果，必须是<strong>min（结构体内部最大成员，#pargama pack(n)）</strong>的整数倍，不足要补齐。</li><li>结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。</li></ul></li></ul><p>手动设置对齐模数:</p><ul><li><strong>#pragma pack(show)</strong><ul><li>显示当前packing alignment的字节数，以warning message的形式被显示。</li></ul></li><li><strong>#pragma pack(push)</strong> <ul><li>将当前指定的packing alignment数组进行压栈操作，这里的栈是the internal compiler stack,同事设置当前的packing alignment为n；如果n没有指定，则将当前的packing alignment数组压栈。</li></ul></li><li><strong>#pragma pack(pop)</strong> <ul><li>从internal compiler stack中删除最顶端的reaord; 如果没有指定n,则当前栈顶record即为新的packing alignement数值；如果指定了n，则n成为新的packing alignment值</li></ul></li><li><strong>#pragma pack(n)</strong><ul><li>指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 </li></ul></li></ul><p>内存对齐案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> b;</span><br><span class="line"><span class="keyword">double</span> c;</span><br><span class="line"><span class="keyword">float</span> d;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT2</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line">Student b; </span><br><span class="line"><span class="keyword">double</span> c;</span><br><span class="line">&#125;Student2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//a从偏移量0位置开始存储</span></span><br><span class="line"><span class="comment">//b从4位置开始存储</span></span><br><span class="line"><span class="comment">//c从8位置开始存储</span></span><br><span class="line"><span class="comment">//d从12位置开存储</span></span><br><span class="line"><span class="comment">//所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof Student:%d\n"</span>,<span class="keyword">sizeof</span>(Student));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Student2 </span></span><br><span class="line"><span class="comment">//a从偏移量为0位置开始 8</span></span><br><span class="line"><span class="comment">//b从偏移量为Student内部最大成员整数倍开始，也就是8开始 24</span></span><br><span class="line"><span class="comment">//c从8的整数倍地方开始,也就是32开始</span></span><br><span class="line"><span class="comment">//所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof Student2:%d\n"</span>, <span class="keyword">sizeof</span>(Student2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、文件操作"><a href="#七、文件操作" class="headerlink" title="七、文件操作"></a>七、文件操作</h2><p>文件在今天的计算机系统中作用是很重要的。文件用来存放程序、文档、数据、表格、图片和其他很多种类的信息。作为一名程序员，您必须编程来创建、写入和读取文件。编写程序从文件读取信息或者将结果写入文件是一种经常性的需求。C提供了强大的和文件进行通信的方法。使用这种方法我们可以在程序中打开文件，然后使用专门的I/O函数读取文件或者写入文件。</p><p><strong>文件的概念</strong></p><ul><li>一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。</li></ul><p><strong>流的概念</strong></p><p>流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。</p><p>C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。</p><p><strong>文本流</strong></p><ul><li>文本流，也就是我们常说的以文本模式读取文件。文本流的有些特性在不同的系统中可能不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只使用一个换行符结尾。</li><li>标准C把文本定义为零个或者多个字符，后面跟一个表示结束的换行符(\n).对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式和内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形势而操纵文本的能力简化了可移植程序的创建。</li></ul><p><strong>二进制流</strong></p><ul><li>二进制流中的字节将完全根据程序编写它们的形式写入到文件中，而且完全根据它们从文件或设备读取的形式读入到程序中。它们并未做任何改变。这种类型的流适用于非文本数据，但是如果你不希望I/O函数修改文本文件的行末字符，也可以把它们用于文本文件。</li></ul><p>c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。</p><p><strong>我们程序中，经常看到的文本方式打开文件和二进制方式打开文件仅仅体现在换行符的处理上</strong>。</p><p>比如说，在widows下，文件的换行符是 <code>\r\n</code>，而在Linux下换行符则是 <code>\n</code>.</p><p>当对文件使用文本方式打开的时候，读写的windows文件中的换行符\r\n会被替换成\n读到内存中，当在windows下写入文件的时候，\n被替换成\r\n再写入文件。如果使用二进制方式打开文件，则不进行\r\n和\n之间的转换。 那么由于Linux下的换行符就是\n, 所以文本文件方式和二进制方式无区别。</p><h3 id="7-1-文件的操作"><a href="#7-1-文件的操作" class="headerlink" title="7.1 文件的操作"></a>7.1 文件的操作</h3><p><strong>文件流总览</strong></p><p>标准库函数是的我们在C程序中执行与文件相关的I/O任务非常方便。下面是关于文件I/O的一般概况。</p><ul><li>程序为同时处于活动状态的每个文件声明一个指针变量，其类型为 <code>FILE*</code>。这个指针指向这个FILE结构，当它处于活动状态时由流使用。</li><li>流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式(读、写、或者读写)。Fopen和操作系统验证文件或者设备是否存在并初始化FILE。</li><li>根据需要对文件进行读写操作。</li><li>最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放FILE结构。</li></ul><p>标准I/O更为简单，因为它们并不需要打开或者关闭。</p><p>I/O函数以三种基本的形式处理数据：<strong>单个字符</strong>、<strong>文本行</strong>和<strong>二进制数据</strong>。对于每种形式都有一组特定的函数对它们进行处理。</p><p><strong>输入/输出函数家族</strong></p><table><thead><tr><th>家族名</th><th>目的</th><th>可用于所有流</th><th>只用于stdin和stdout</th></tr></thead><tbody><tr><td>getchar</td><td>字符输入</td><td>fgetc、getc</td><td>getchar</td></tr><tr><td>putchar</td><td>字符输出</td><td>fputc、putc</td><td>putchar</td></tr><tr><td>gets</td><td>文本行输入</td><td>fgets</td><td>gets</td></tr><tr><td>puts</td><td>文本行输出</td><td>fputs</td><td>puts</td></tr><tr><td>scanf</td><td>格式化输入</td><td>fscanf</td><td>scanf</td></tr><tr><td>printf</td><td>格式化输出</td><td>fprintf</td><td>printf</td></tr></tbody></table><h3 id="7-2-文件打开关闭"><a href="#7-2-文件打开关闭" class="headerlink" title="7.2 文件打开关闭"></a>7.2 文件打开关闭</h3><p>文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line">功能：打开文件</span><br><span class="line">参数：</span><br><span class="line">filename：需要打开的文件名，根据需要加上路径</span><br><span class="line">mode：打开文件的权限设置</span><br><span class="line">返回值：</span><br><span class="line">成功：文件指针</span><br><span class="line">失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方式</th><th>含义</th></tr></thead><tbody><tr><td>“r”</td><td>打开，只读，文件必须已经存在。</td></tr><tr><td>“w”</td><td>只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。</td></tr><tr><td>“a”</td><td>只能在文件末尾追加数据,如果文件不存在则创建</td></tr><tr><td>“rb”</td><td>打开一个二进制文件，只读</td></tr><tr><td>“wb”</td><td>打开一个二进制文件，只写</td></tr><tr><td>“ab”</td><td>打开一个二进制文件，追加</td></tr><tr><td>“r+”</td><td>允许读和写,文件必须已存在</td></tr><tr><td>“w+”</td><td>允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。</td></tr><tr><td>“a+”</td><td>允许读和追加数据,如果文件不存在则创建</td></tr><tr><td>“rb+”</td><td>以读/写方式打开一个二进制文件</td></tr><tr><td>“wb+”</td><td>以读/写方式建立一个新的二进制文件</td></tr><tr><td>“ab+”</td><td>以读/写方式打开一个二进制文件进行追加</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "\\"这样的路径形式，只能在windows使用</span></span><br><span class="line"><span class="comment">// "/"这样的路径形式，windows和linux平台下都可用，建议使用这种</span></span><br><span class="line"><span class="comment">// 路径可以是相对路径，也可是绝对路径</span></span><br><span class="line">fp = fopen(<span class="string">"../test"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="comment">//fp = fopen("..\\test", "w");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) <span class="comment">//返回空，说明打开失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//perror()是标准出错打印函数，能打印调用库函数出错原因</span></span><br><span class="line">perror(<span class="string">"open"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。</span><br><span class="line">参数：</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值.</p><p><strong>文件读写函数回顾</strong></p><ul><li>按照字符读写文件：fgetc(), fputc()</li><li>按照行读写文件：fputs(), fgets()</li><li>按照块读写文件：fread(), fwirte()</li><li>按照格式化读写文件：fprintf(), fscanf()</li><li>按照随机位置读写文件：fseek(), ftell(), rewind()    </li></ul><p><strong>块读写函数回顾</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式给文件写入内容</span><br><span class="line">参数：</span><br><span class="line">ptr：准备写入文件数据的地址</span><br><span class="line">size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定写入文件内容的块数据大小</span><br><span class="line">nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功写入文件数据的块数，此值和nmemb相等</span><br><span class="line">失败：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式从文件中读取内容</span><br><span class="line">参数：</span><br><span class="line">ptr：存放读取出来数据的内存空间</span><br><span class="line">size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定读取文件内容的块数据大小</span><br><span class="line">nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于<span class="number">0</span>，说明读到文件的结尾。</span><br><span class="line">失败：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>格式化读写函数回顾</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件</span><br><span class="line">format：字符串格式，用法和<span class="built_in">printf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际写入文件的字符个数</span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件</span><br><span class="line">format：字符串格式，用法和<span class="built_in">scanf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际从文件中读取的字符个数</span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>fscanf遇到空格和换行时结束。</strong></p><h3 id="7-3-读写配置文件"><a href="#7-3-读写配置文件" class="headerlink" title="7.3 读写配置文件"></a>7.3 读写配置文件</h3><img src="/images/imageProgramC/文件读写案例.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> key[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">char</span> val[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span>&#123;</span></span><br><span class="line">FILE *fp; <span class="comment">//保存文件指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">list</span>;</span> <span class="comment">//保存配置信息</span></span><br><span class="line"><span class="keyword">int</span> lines; <span class="comment">//配置信息条数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_file</span><span class="params">(<span class="keyword">char</span> *path, struct config **myconfig)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == path)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以读写的方式打开文件</span></span><br><span class="line">FILE *fp = fopen(path, <span class="string">"r+"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> ==fp)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件打开失败!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置文件信息分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span> *<span class="title">conf</span> = (<span class="title">struct</span> <span class="title">config</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">config</span>));</span></span><br><span class="line">conf-&gt;fp = fp;</span><br><span class="line">conf-&gt;<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的间接赋值</span></span><br><span class="line">*myconfig = conf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计文件行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> lines = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="number">1024</span>, config-&gt;fp))&#123;</span><br><span class="line"><span class="comment">//如果是注释则不统计</span></span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'#'</span>)&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">lines++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将文件指针重置到开始位置</span></span><br><span class="line">fseek(config-&gt;fp,<span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得配置文件行数</span></span><br><span class="line">config-&gt;lines = count_file(config);</span><br><span class="line"><span class="comment">//给每一行配置信息分配内存</span></span><br><span class="line">config-&gt;<span class="built_in">list</span> = (struct info *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct info) * config-&gt;lines);</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="number">1024</span>, config-&gt;fp))&#123;</span><br><span class="line"><span class="comment">//去除每一行最后的\n字符</span></span><br><span class="line">buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">//如果是注释则不显示</span></span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'#'</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(config-&gt;<span class="built_in">list</span>[index].key, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">memset</span>(config-&gt;<span class="built_in">list</span>[index].val, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *delimit = <span class="built_in">strchr</span>(buf, <span class="string">':'</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(config-&gt;<span class="built_in">list</span>[index].key, buf, delimit - buf);</span><br><span class="line"><span class="built_in">strncpy</span>(config-&gt;<span class="built_in">list</span>[index].val, delimit + <span class="number">1</span>, <span class="built_in">strlen</span>(delimit + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span> , <span class="number">1024</span>);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">get_file</span><span class="params">(struct config *config, <span class="keyword">char</span> *key)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == key)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; config-&gt;lines;i ++)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(config-&gt;<span class="built_in">list</span>[i].key,key) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> config-&gt;<span class="built_in">list</span>[i].val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件指针</span></span><br><span class="line">fclose(config-&gt;fp);</span><br><span class="line">config-&gt;fp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//释放配置信息</span></span><br><span class="line"><span class="built_in">free</span>(config-&gt;<span class="built_in">list</span>);</span><br><span class="line">config-&gt;<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *path = <span class="string">"./my.ini"</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span> *<span class="title">conf</span> = <span class="title">NULL</span>;</span></span><br><span class="line">load_file(path, &amp;conf);</span><br><span class="line">parse_file(conf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"username"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"password"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"server_ip"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"server_port"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"aaaa"</span>));</span><br><span class="line">destroy_file(conf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、链表"><a href="#八、链表" class="headerlink" title="八、链表"></a>八、链表</h2><h3 id="8-1-链表基本概念"><a href="#8-1-链表基本概念" class="headerlink" title="8.1 链表基本概念"></a>8.1 链表基本概念</h3><img src="/images/imageProgramC/链表.png"><ul><li>链表是一种常用的数据结构，它通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的动态性（<strong>非顺序存储</strong>）。</li><li>数据域用来存储数据，指针域用于建立与下一个结点的联系。</li><li>建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。</li><li><strong>链表的开销，主要是访问顺序性和组织链的空间损失</strong>。</li></ul><p><strong>数组和链表的区别</strong>：</p><ul><li><p>数组：一次性分配一块连续的存储区域。</p><p>优点：随机访问元素效率高</p><p>缺点：</p><ul><li>需要分配一块连续的存储区域（很大区域，有可能分配失败）</li><li>删除和插入某个元素效率低</li></ul></li><li><p>链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。</p><p>优点：</p><ul><li>不需要一块连续的存储区域</li><li>删除和插入某个元素效率高</li></ul><p>缺点：随机访问元素效率低</p></li></ul><h4 id="8-1-1-有关结构体的自身引用"><a href="#8-1-1-有关结构体的自身引用" class="headerlink" title="8.1.1 有关结构体的自身引用"></a>8.1.1 有关结构体的自身引用</h4><p>问题1：请问结构体可以嵌套本类型的结构体变量吗？</p><p>问题2：请问结构体可以嵌套本类型的结构体指针变量吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">Student stu; <span class="comment">//结构体可以嵌套其他类型的结构体</span></span><br><span class="line"><span class="comment">//Teacher stu;</span></span><br><span class="line"><span class="comment">//struct _TEACHER teacher; //此时Teacher类型的成员还没有确定，编译器无法分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>* <span class="title">teacher</span>;</span> <span class="comment">//不论什么类型的指针，都只占4个字节，编译器可确定内存分配</span></span><br><span class="line">&#125;Teacher;</span><br></pre></td></tr></table></figure><ul><li>结构体可以嵌套另外一个结构体的任何类型变量;</li><li><strong>结构体嵌套本结构体普通变量（不可以）</strong>。本结构体的类型大小无法确定，类型本质：固定大小内存块别名;</li><li><strong>结构体嵌套本结构体指针变量（可以）</strong>, 指针变量的空间能确定，32位， 4字节， 64位， 8字节;</li></ul><h4 id="8-1-2-链表节点"><a href="#8-1-2-链表节点" class="headerlink" title="8.1.2 链表节点"></a>8.1.2 <strong>链表节点</strong></h4><p>大家思考一下，我们说链表是由一系列的节点组成，那么如何表示一个包含了数据域和指针域的节点呢？</p><p><strong>链表的节点类型实际上是结构体变量，此结构体包含数据域和指针域</strong>：</p><ul><li><p>数据域用来存储数据；</p></li><li><p>指针域用于建立与下一个结点的联系，<strong>当此节点为尾节点时，指针域的值为NULL</strong>；</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>       </span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/链表-01.png"><h4 id="8-1-3-链表的分类"><a href="#8-1-3-链表的分类" class="headerlink" title="8.1.3 链表的分类"></a>8.1.3 链表的分类</h4><p>链表分为：</p><ul><li>静态链表</li><li>动态链表</li></ul><p>静态链表和动态链表是线性表链式存储结构的两种不同的表示方式：</p><ul><li><p>所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表称为“静态链表”。</p></li><li><p>所谓动态链表，是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。</p></li></ul><p><strong>静态链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化三个结构体变量</span></span><br><span class="line">Stu s1 = &#123; <span class="number">1</span>, <span class="string">"yuri"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">Stu s2 = &#123; <span class="number">2</span>, <span class="string">"lily"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">Stu s3 = &#123; <span class="number">3</span>, <span class="string">"lilei"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">s1.next = &amp;s2; <span class="comment">//s1的next指针指向s2</span></span><br><span class="line">s2.next = &amp;s3;</span><br><span class="line">s3.next = <span class="literal">NULL</span>; <span class="comment">//尾结点</span></span><br><span class="line"></span><br><span class="line">Stu *p = &amp;s1;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d, name = %s\n"</span>, p-&gt;id, p-&gt;name);</span><br><span class="line"><span class="comment">//结点往后移动一位</span></span><br><span class="line">p = p-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//动态分配3个节点</span></span><br><span class="line">Stu *s1 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">s1-&gt;id = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s1-&gt;name, <span class="string">"yuri"</span>);</span><br><span class="line"></span><br><span class="line">Stu *s2 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">s2-&gt;id = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s2-&gt;name, <span class="string">"lily"</span>);</span><br><span class="line"></span><br><span class="line">Stu *s3 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">s3-&gt;id = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s3-&gt;name, <span class="string">"lilei"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立节点的关系</span></span><br><span class="line">s1-&gt;next = s2; <span class="comment">//s1的next指针指向s2</span></span><br><span class="line">s2-&gt;next = s3;</span><br><span class="line">s3-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历节点</span></span><br><span class="line">Stu *p = s1;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d, name = %s\n"</span>, p-&gt;id, p-&gt;name);</span><br><span class="line"><span class="comment">//结点往后移动一位</span></span><br><span class="line">p = p-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点空间</span></span><br><span class="line">p = s1;</span><br><span class="line">Stu *tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">tmp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带头和不带头链表</strong></p><ul><li>带头链表：固定一个节点作为头结点(数据域不保存有效数据)，起一个标志位的作用，以后不管链表节点如何改变，此头结点固定不变。</li></ul><img src="/images/imageProgramC/链表-02.png"><ul><li>不带头链表：头结点不固定，根据实际需要变换头结点(如在原来头结点前插入新节点，然后，新节点重新作为链表的头结点)。</li></ul><img src="/images/imageProgramC/链表-03.png"><p><strong>单向链表、双向链表、循环链表</strong></p><ul><li>单向链表：</li></ul><img src="/images/imageProgramC/链表-04.png"><ul><li>双向链表：</li></ul><img src="/images/imageProgramC/链表-05.png"><ul><li>循环链表：</li></ul><img src="/images/imageProgramC/链表-06.png"><h3 id="8-2-链表基本操作"><a href="#8-2-链表基本操作" class="headerlink" title="8.2 链表基本操作"></a>8.2 链表基本操作</h3><h4 id="8-2-1-创建链表"><a href="#8-2-1-创建链表" class="headerlink" title="8.2.1 创建链表"></a>8.2.1 <strong>创建链表</strong></h4><p>使用结构体定义节点类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id; <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;link_node;</span><br></pre></td></tr></table></figure><p>编写函数：<code>link_node* init_linklist()</code></p><p>建立带有头结点的单向链表，循环创建结点，结点数据域中的数值从键盘输入，以 -1 作为输入结束标志，链表的头结点地址由函数值返回.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;link_node;</span><br><span class="line"></span><br><span class="line"><span class="function">link_node *<span class="title">init_linklist</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建头结点指针</span></span><br><span class="line">link_node* head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//给头结点分配内存</span></span><br><span class="line">head = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前节点</span></span><br><span class="line">link_node* p_current = head;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//循环向链表中插入节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input data:\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果输入-1，则退出循环</span></span><br><span class="line"><span class="keyword">if</span> (data == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给新节点分配内存</span></span><br><span class="line">link_node* newnode = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给节点赋值</span></span><br><span class="line">newnode-&gt;data = data;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//新节点入链表，也就是将节点插入到最后一个节点的下一个位置</span></span><br><span class="line">p_current-&gt;next = newnode;</span><br><span class="line"><span class="comment">//更新辅助指针p_current</span></span><br><span class="line">p_current = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-遍历链表"><a href="#8-2-2-遍历链表" class="headerlink" title="8.2.2 遍历链表"></a>8.2.2 遍历链表</h4><p>编写函数：<code>void foreach_linklist(link_node* head)</code></p><p>顺序输出单向链表各项结点数据域中的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foreach_linklist</span><span class="params">(link_node* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值指针变量</span></span><br><span class="line">link_node* p_current = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,p_current-&gt;data);</span><br><span class="line">p_current = p_current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-3-插入节点"><a href="#8-2-3-插入节点" class="headerlink" title="8.2.3 插入节点"></a>8.2.3 <strong>插入节点</strong></h4><p>编写函数: <code>void insert_linklist(link_node* head,int val,int data).</code></p><p>在指定值后面插入数据data,如果值val不存在，则在尾部插入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在值val前插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_linklist</span><span class="params">(link_node* head, <span class="keyword">int</span> val, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个辅助指针</span></span><br><span class="line">link_node* p_prev = head;</span><br><span class="line">link_node* p_current = p_prev-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (p_current-&gt;data == val)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">p_prev = p_current;</span><br><span class="line">p_current = p_prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果p_current为NULL，说明不存在值为val的节点</span></span><br><span class="line"><span class="keyword">if</span> (p_current == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在值为%d的节点!\n"</span>,val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建新的节点</span></span><br><span class="line">link_node* newnode = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line">newnode-&gt;data = data;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新节点入链表</span></span><br><span class="line">newnode-&gt;next = p_current;</span><br><span class="line">p_prev-&gt;next = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-4-删除节点"><a href="#8-2-4-删除节点" class="headerlink" title="8.2.4 删除节点"></a>8.2.4 <strong>删除节点</strong></h4><p>编写函数: <code>void remove_linklist(link_node* head,int val)</code></p><p>删除第一个值为val的结点.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除值为val的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_linklist</span><span class="params">(link_node* head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助指针</span></span><br><span class="line">link_node* p_prev = head;</span><br><span class="line">link_node* p_current = p_prev-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找值为val的节点</span></span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (p_current-&gt;data == val)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">p_prev = p_current;</span><br><span class="line">p_current = p_prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果p_current为NULL，表示没有找到</span></span><br><span class="line"><span class="keyword">if</span> (p_current == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除当前节点： 重新建立待删除节点(p_current)的前驱后继节点关系</span></span><br><span class="line">p_prev-&gt;next = p_current-&gt;next;</span><br><span class="line"><span class="comment">//释放待删除节点的内存</span></span><br><span class="line"><span class="built_in">free</span>(p_current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-5-销毁链表"><a href="#8-2-5-销毁链表" class="headerlink" title="8.2.5 销毁链表"></a>8.2.5 <strong>销毁链表</strong></h4><p>编写函数: <code>void destroy_linklist(link_node* head)</code></p><p>销毁链表，释放所有节点的空间.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_linklist</span><span class="params">(link_node* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值指针</span></span><br><span class="line">link_node* p_current = head;</span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//缓存当前节点下一个节点</span></span><br><span class="line">link_node* p_next = p_current-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p_current);</span><br><span class="line">p_current = p_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、函数指针"><a href="#九、函数指针" class="headerlink" title="九、函数指针"></a>九、函数指针</h2><h3 id="9-1-函数类型"><a href="#9-1-函数类型" class="headerlink" title="9.1 函数类型"></a>9.1 函数类型</h3><p>通过什么来区分两个不同的函数？</p><p>一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，<strong>函数名代表函数的入口地址</strong>。</p><p>函数三要素： 名称、参数、返回值。C语言中的函数有自己特定的类型。</p><p>c 语言中通过 typedef 为函数类型重命名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;<span class="comment">// f 为函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">// p 为函数类型</span></span><br></pre></td></tr></table></figure><p>这一点和数组一样，因此我们可以用一个指针变量来存放这个入口地址，然后通过该指针变量调用函数。</p><p><strong>注意：</strong>通过函数类型定义的变量是不能够直接执行，因为没有函数体。只能通过类型定义一个函数指针指向某一个具体函数，才能调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(p)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">p p1;</span><br><span class="line"><span class="comment">//p1(10,20); //错误，不能直接调用，只描述了函数类型，但是并没有定义函数体，没有函数体无法调用</span></span><br><span class="line">p* p2 = my_func;</span><br><span class="line">p2(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//正确，指向有函数体的函数入口地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-函数指针-指向函数的指针"><a href="#9-2-函数指针-指向函数的指针" class="headerlink" title="9.2 函数指针(指向函数的指针)"></a>9.2 函数指针(指向函数的指针)</h3><ul><li>函数指针定义方式(先定义函数类型，根据类型定义指针变量);</li><li>先定义函数指针类型，根据类型定义指针变量;</li><li>直接定义函数指针变量;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret:%d\n"</span>, a + b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 先定义函数类型，通过类型定义指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(FUNC_TYPE)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">FUNC_TYPE* f = my_func;</span><br><span class="line"><span class="comment">//如何调用？</span></span><br><span class="line">(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FUNC_POINTER)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">FUNC_POINTER f = my_func;</span><br><span class="line"><span class="comment">//如何调用？</span></span><br><span class="line">(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 直接定义函数指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>(*f)(<span class="keyword">int</span>, <span class="keyword">int</span>) = my_func;</span><br><span class="line"><span class="comment">//如何调用？</span></span><br><span class="line">(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-函数指针数组"><a href="#9-3-函数指针数组" class="headerlink" title="9.3 函数指针数组"></a>9.3 <strong>函数指针数组</strong></h3><p>函数指针数组，每个元素都是函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func01</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func01:%d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func02</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func02:%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func03</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func03:%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//定义函数指针</span></span><br><span class="line"><span class="keyword">void</span>(*func_array[])(<span class="keyword">int</span>) = &#123; func01, func02, func03 &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">void</span>(*func_array[<span class="number">3</span>])(<span class="keyword">int</span>);</span><br><span class="line">func_array[<span class="number">0</span>] = func01;</span><br><span class="line">func_array[<span class="number">1</span>] = func02;</span><br><span class="line">func_array[<span class="number">2</span>] = func03;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)&#123;</span><br><span class="line">func_array[i](<span class="number">10</span> + i);</span><br><span class="line">(*func_array[i])(<span class="number">10</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-函数指针做函数参数-回调函数"><a href="#9-4-函数指针做函数参数-回调函数" class="headerlink" title="9.4 函数指针做函数参数(回调函数)"></a>9.4 <strong>函数指针做函数参数(回调函数)</strong></h3><p>函数参数除了是普通变量，还可以是函数指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参为普通变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">int</span> x )</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//形参为函数指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">int</span>(*p)(<span class="keyword">int</span> a) )</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>函数指针变量常见的用途之一是把指针作为参数传递到其他函数，指向函数的指针也可以作为参数，以实现函数地址的传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caculator</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>(*func)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> func(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FUNC_POINTER)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caculator</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, FUNC_POINTER func)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> func(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>函数指针和指针函数的区别：</p><ul><li><p>函数指针是指向函数的指针；</p></li><li><p>指针函数是返回类型为指针的函数；</p></li></ul><h2 id="十、预处理"><a href="#十、预处理" class="headerlink" title="十、预处理"></a>十、预处理</h2><h3 id="10-1-预处理的基本概念"><a href="#10-1-预处理的基本概念" class="headerlink" title="10.1 预处理的基本概念"></a>10.1 预处理的基本概念</h3><p>C 语言对源程序处理的四个步骤：<strong>预处理、编译、汇编、链接</strong>。</p><p>预处理是在程序源代码被编译之前，由预处理器（Preprocessor）对程序源代码进行的处理。这个过程并不对程序的源代码语法进行解析，但它会把源代码分割或处理成为特定的符号为下一步的编译做准备工作。</p><h3 id="10-2-文件包含指令-include"><a href="#10-2-文件包含指令-include" class="headerlink" title="10.2 文件包含指令(#include)"></a>10.2 文件包含指令(#include)</h3><p>“文件包含处理”是指一个源文件可以将另外一个文件的全部内容包含进来。Ｃ语言提供了 #include 命令用来实现“文件包含”的操作。</p><p><strong>#incude&lt;&gt; 和 #include”” 区别</strong></p><ul><li><p><strong>“”</strong> 表示系统先在 file1.c 所在的当前目录找 file1.h，如果找不到，再按系统指定的目录检索。</p></li><li><p><strong>&lt; &gt;</strong> 表示系统直接按系统指定的目录检索。</p></li></ul><p>注意：</p><p>​    1. #include &lt;&gt; 常用于包含库函数的头文件；</p><p>​    2. #include “” 常用于包含自定义的头文件；</p><p>​    3. 理论上 #include 可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含；</p><h3 id="10-3-宏定义"><a href="#10-3-宏定义" class="headerlink" title="10.3 宏定义"></a>10.3 宏定义</h3><h4 id="10-3-1-无参数的宏定义-宏常量"><a href="#10-3-1-无参数的宏定义-宏常量" class="headerlink" title="10.3.1 无参数的宏定义(宏常量)"></a>10.3.1 无参数的宏定义(宏常量)</h4><p>如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为：</p><p>const int num = 100; 但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用：</p><p>#define num 100</p><p>在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。<strong>宏定义，只在宏定义的文件中起作用</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> r = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">double</span> s = PI * r * r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s = %lf\n"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>1)宏名一般用大写，以便于与变量区别；</p></li><li><p>2) 宏定义可以是常数、表达式等；</p></li><li><p>3) 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错；</p></li><li><p>4) 宏定义不是C语言，不在行末加分号；</p></li><li><p>5) <strong>宏名有效范围为从定义到本源文件结束</strong>；</p></li><li><p>6) <strong>可以用#undef命令终止宏定义的作用域</strong>；</p></li><li><p>7) 在宏定义中，可以引用已定义的宏名；</p></li></ul><h4 id="10-3-2-带参数的宏定义-宏函数"><a href="#10-3-2-带参数的宏定义-宏函数" class="headerlink" title="10.3.2 带参数的宏定义(宏函数)"></a>10.3.2 带参数的宏定义(宏函数)</h4><p>在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。</p><p>宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(x,y) ((x)+(y))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//仅仅只是做文本替换 下例替换为 int ret = ((10)+(20));</span></span><br><span class="line"><span class="comment">//不进行计算</span></span><br><span class="line"><span class="keyword">int</span> ret = SUM(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret:%d\n"</span>,ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p>1) 宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格；</p></li><li><p>2) 用括号括住每一个参数，并括住宏的整体定义。</p></li><li><p>3) 用大写字母表示宏的函数名。</p></li><li><p>4) 如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。</p></li></ul><h3 id="10-4-条件编译"><a href="#10-4-条件编译" class="headerlink" title="10.4 条件编译"></a>10.4 条件编译</h3><p>一般情况下，源程序中所有的行都参加编译。但有时希望对部分源程序行只在满足一定条件时才编译，即对这部分源程序行指定编译条件。</p><img src="/images/imageProgramC/条件编译.png"><p><strong>条件编译</strong></p><ul><li>防止头文件被重复包含引用；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SOMEFILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SOMEFILE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要声明的变量、函数</span></span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="10-5-一些特殊的预定宏"><a href="#10-5-一些特殊的预定宏" class="headerlink" title="10.5 一些特殊的预定宏"></a>10.5 <strong>一些特殊的预定宏</strong></h3><p>C 编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__FILE__宏所在文件的源文件名 </span></span><br><span class="line"><span class="comment">//__LINE__宏所在行的行号</span></span><br><span class="line"><span class="comment">//__DATE__代码编译的日期</span></span><br><span class="line"><span class="comment">//__TIME__代码编译的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __FILE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, __LINE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __DATE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __TIME__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、动态库的封装和使用"><a href="#十一、动态库的封装和使用" class="headerlink" title="十一、动态库的封装和使用"></a>十一、动态库的封装和使用</h2><h3 id="11-1-库的基本概念"><a href="#11-1-库的基本概念" class="headerlink" title="11.1 库的基本概念"></a>11.1 库的基本概念</h3><p>库是已经写好的、成熟的、可复用的代码。每个程序都需要依赖很多底层库，不可能每个人的代码从零开始编写代码，因此库的存在具有非常重要的意义。</p><p>在我们的开发的应用中经常有一些公共代码是需要反复使用的，就把这些代码编译为库文件。</p><p>库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。像在Windows这样的平台上，最常用的 c 语言库是由集成按开发环境所附带的运行库，这些库一般由编译厂商提供。</p><p>库：就是已经编写好的，后续可以直接使用的代码。</p><p>c++静态库：会合入到最终生成的程序，<strong>使得结果文件比较大</strong>。优点是不再有任何依赖。</p><p>c++动态库：动态库，<strong>一个文件可以多个代码同时使用内存中只有一份，节省内存</strong>，可以随主代码一起编译。缺点是需要头文件。</p><p><strong>网友说：库就是除了main函数之外的其他代码，都可以组成库</strong>。</p><h3 id="11-2-静态库优缺点"><a href="#11-2-静态库优缺点" class="headerlink" title="11.2 静态库优缺点"></a>11.2 静态库优缺点</h3><ul><li><p><strong>静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系</strong>；</p></li><li><p>程序在运行时与函数库再无瓜葛，移植方便。</p></li><li><p><strong>浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</strong>。</p></li></ul><p><strong>内存和磁盘空间</strong></p><ul><li>静态链接这种方法很简单，原理上也很容易理解，在操作系统和硬件不发达的早期，绝大部门系统采用这种方案。随着计算机软件的发展，这种方法的缺点很快暴露出来，那就是静态链接的方式对于计算机内存和磁盘空间浪费非常严重。特别是多进程操作系统下，静态链接极大的浪费了内存空间。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。</li></ul><p><strong>程序开发和发布</strong></p><ul><li>空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也会带来很多麻烦。比如程序中所使用的mylib.lib是由一个第三方厂商提供的，当该厂商更新容量mylib.lib的时候，那么我们的程序就要拿到最新版的mylib.lib，然后将其重新编译链接后，将新的程序整个发布给用户。这样的做缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。</li></ul><p>要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，<strong>把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想</strong>。</p><h3 id="11-3-Linux-下-gcc-编译器生成和使用静态库和动态库"><a href="#11-3-Linux-下-gcc-编译器生成和使用静态库和动态库" class="headerlink" title="11.3 Linux 下 gcc 编译器生成和使用静态库和动态库"></a>11.3 Linux 下 gcc 编译器生成和使用静态库和动态库</h3><p>我们通常把一些公用函数制作成函数库，供其它程序使用。函数库分为静态库和动态库两种。</p><ul><li><p>静态库<strong>在程序编译时会被链接并拷贝到目标代码中，程序运行时将不再需要该静态库</strong>。</p></li><li><p>动态库<strong>在程序编译时并不会被拷贝到目标代码中，而是在程序运行时才被载入</strong>，因此在程序运行时还需要动态库存在。本质上说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。</p></li></ul><p>windows 和 linux 库的二进制是不兼容的（主要是编译器、汇编器和连接器的不同）。</p><h4 id="11-3-1-基本概念"><a href="#11-3-1-基本概念" class="headerlink" title="11.3.1 基本概念"></a>11.3.1 基本概念</h4><p><strong>库的种类</strong>：</p><p>linux下的库有两种：</p><ul><li>静态库</li><li>共享库（动态库）。</li></ul><p>二者区别在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。</p><p><strong>库文件是如何产生的</strong>：</p><p>静态库的后缀是 <code>.a</code>，它的产生分两步:</p><ul><li><p>Step 1. 由源文件编译生成一堆 <code>.o</code>，每个 <code>.o</code> 里都包含这个编译单元的符号表</p></li><li><p>Step 2. ar 命令将很多 <code>.o</code> 转换成 <code>.a</code>，成为静态库</p></li></ul><p>动态库的后缀是 <code>.so</code>，它由 gcc 加特定参数编译产生。</p><p><strong>库文件命名规范</strong>：</p><p>库文件一般放在 <code>/usr/local/lib</code>，<code>/usr/lib</code>，<code>/lib</code>，或者其他自定义的 <code>lib</code> 下。</p><ul><li><p>静态库的名字一般为 <code>libxxxx.a</code>，其中 <code>xxxx</code> 是该 <code>lib</code> 的名称</p></li><li><p>动态库的名字一般为 <code>libxxxx.so.major.minor</code>， <code>xxxx</code> 是该 <code>lib</code> 的名称，<code>major</code> 是主版本号， <code>minor</code> 是副版本号</p></li></ul><p><strong>如何知道一个可执行程序依赖哪些库</strong>：</p><p><code>ldd</code> 命令可以查看一个可执行程序依赖的共享库，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd /lib/i386-linux-gnu/libc.so.6</span></span><br><span class="line">/lib/ld-linux.so.2 (0xf7740000)</span><br><span class="line">linux-gate.so.1 =&gt;  (0xf773f000)</span><br></pre></td></tr></table></figure><p>可以看到 <code>libc</code> 命令依赖于 <code>linux-gate</code> 库和 <code>ld-linux</code> 库</p><p><strong>可执行程序在执行的时候如何定位共享库文件</strong>：</p><p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(<code>dynamic linker/loader</code>)</p><p>对于 <code>elf</code> 格式的可执行程序，是由 <code>ld-linux.so*</code> 来完成的，它先后搜索 <code>elf</code> 文件的 <code>DT_RPATH</code> 段—环境变量 <code>LD_LIBRARY_PATH—/etc/ld.so.cache</code> 文件列表— <code>/lib/,/usr/lib</code> 目录找到库文件后将其载入内存</p><p>如：<code>export LD_LIBRARY_PATH=’pwd’</code></p><p>将当前文件目录添加为共享目录</p><p><strong>在新安装一个库之后如何让系统能够找到他</strong>：</p><p>如果安装在 <code>/lib</code> 或者 <code>/usr/lib</code> 下，那么 <code>ld</code> 默认能够找到，无需其他操作。如果安装在其他目录，需要将其添加到 <code>/etc/ld.so.cache</code> 文件中，步骤如下：</p><ol><li><p>编辑 <code>/etc/ld.so.conf</code> 文件，加入库文件所在目录的路径</p></li><li><p>运行 <code>ldconfig</code>，该命令会重建 <code>/etc/ld.so.cache</code> 文件</p></li></ol><h4 id="11-3-2-用-gcc-生成静态和动态链接库的示例"><a href="#11-3-2-用-gcc-生成静态和动态链接库的示例" class="headerlink" title="11.3.2 用 gcc 生成静态和动态链接库的示例"></a>11.3.2 用 gcc 生成静态和动态链接库的示例</h4><p>假设有1个类 hello，和一个 main 函数。如下：</p><p><strong>hello.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HELLO_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_H </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>hello.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    hello(<span class="string">"world!"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello.c 是一个没有 main 函数的 <code>.c</code> 程序，因此不够成一个完整的程序，如果使用 <code>gcc –o</code> 编译并连接它，<code>gcc</code> 将报错，无法通过编译。</p><p>前面提过，无论静态库，还是动态库，都是由 <code>.o</code>文件创建的。那么我们如何才能让 main.c 调用 hello 类呢？也就是说该如何才能将 hello.c 通过 gcc 先编译成 <code>.o</code> 文件，并且让 main.c 在编译时能找到它？有三种途径可以实现：</p><ul><li><p>1）通过编译多个源文件，直接将目标代码合成一个 <code>.o</code> 文件。</p></li><li><p>2）通过创建静态链接库 <code>libmyhello.a</code>，使得 main 函数调用 hello 函数时可调用静态链接库。</p></li><li><p>3）通过创建动态链接库 <code>libmyhello.so</code>，使得 main 函数调用 hello 函数时可调用动态链接库。</p></li></ul><h5 id="11-3-2-1-途径一：编译多个源文件"><a href="#11-3-2-1-途径一：编译多个源文件" class="headerlink" title="11.3.2.1 途径一：编译多个源文件"></a>11.3.2.1 途径一：编译多个源文件</h5><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c main.c</span></span><br></pre></td></tr></table></figure><p>这里提醒一下：<code>gcc –o</code> 是将 <code>.c</code> 源文件编译成为一个可执行的二进制代码。而 <code>gcc –c</code> 是使用GNU汇编器将源文件转化为目标代码。更多 gcc 编译选项的常识点<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FyYWNrZXRoaXMvYXJ0aWNsZS9kZXRhaWxzLzQzMzcwMzA3" title="https://blog.csdn.net/arackethis/article/details/43370307">这里<i class="fa fa-external-link"></i></span>。</p><p>这时可以看到生成了 hello.o 和 main.o 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c  main.o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将两个文件链接成一个 `.o` 文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看此时已经生成了可执行文件sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c  main.o  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure><h5 id="11-3-2-2-途径二：静态链接库"><a href="#11-3-2-2-途径二：静态链接库" class="headerlink" title="11.3.2.2 途径二：静态链接库"></a>11.3.2.2 途径二：静态链接库</h5><p>静态库文件名是以 lib 为前缀，紧接着是静态库名，扩展名为 <code>.a</code>。例如：我们将创建的静态库名为myhello，则静态库文件名就是 <code>libmyhello.a</code> 。创建静态库用 <code>ar</code> 命令。</p><p>删除途径一中生成的3个文件，回到原始的三个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm hello.o main.o sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始尝试途径二，创建静态库文件libmyhello.a：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs libmyhello.a hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下已经生成了：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  libmyhello.a  main.c</span><br></pre></td></tr></table></figure><p>静态库制作完了，如何使用它内部的函数呢？</p><p><strong>只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明，然后在用 gcc 命令生成目标文件时指明静态库名，gcc 将会从静态库中将公用函数连接到目标文件中</strong>。</p><p><strong>注意</strong>，gcc 会在静态库名前加上前缀 lib，然后追加扩展名 <code>.a</code> 得到的静态库文件名来查找静态库文件。</p><p>因此，我们在写需要连接的库时，只写静态库名就可以，如 <code>libmyhello.a</code> 的库，只写: <code>-lmyhello</code><br>在 main.c 中，我们已包含了该静态库的头文件 hello.h。现在在主程序 main.c 中直接调用它内部的函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里-L.告诉 gcc 先在当前目录下查找库文件。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.c -static -L. -lmyhello       </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下，已经生成可执行文件sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  libmyhello.a  main.c  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure><p>前面提过静态库在编译过程中会被拷贝到目标程序中，运行时不再需要静态库的存在。这里可以简单验证一下：我们删除静态库文件，然后再试着调用函数 hello 看是否还能调用成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm libmyhello.a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure><p>程序照常运行，静态库中的函数已经被复制到目标程序中了，编译完成后，静态库就没用了，执行时不再需要静态库的存在。</p><p><strong>静态链接库的一个缺点是</strong>：</p><ul><li>如果我们同时运行了许多程序，并且它们使用了同一个库函数，这样，在内存中会大量拷贝同一库函数。这样，就会浪费内存和存储空间。</li></ul><p>使用了共享链接库的Linux就可以避免这个问题。共享函数库和静态函数在同一个地方，只是后缀不同。比如，在Linux系统，标准的共享数序函数库是 <code>/usr/lib/libm.so</code>。<strong>当一个程序使用共享函数库时，在连接阶段并不把函数代码连接进来，而只是链接函数的一个引用。当最终的函数导入内存开始真正执行时，函数引用被解析，共享函数库的代码才真正导入到内存中</strong>。这样，共享链接库的函数就可以被许多程序同时共享，并且只需存储一次就可以了。<strong>共享函数库的另一个优点是，它可以独立更新，与调用它的函数毫不影响</strong>。</p><h5 id="11-3-2-3-途径三：动态链接库（共享函数库）"><a href="#11-3-2-3-途径三：动态链接库（共享函数库）" class="headerlink" title="11.3.2.3 途径三：动态链接库（共享函数库）"></a>11.3.2.3 途径三：动态链接库（共享函数库）</h5><p>动态库文件名和静态库类似，也是在动态库名增加前缀 lib，但其文件扩展名为 <code>.so</code>。例如：我们将创建的动态库名为 myhello，则动态库文件名就是 <code>libmyhello.so</code> 。用 gcc 来创建动态库。</p><p>删除途径二中生成的2个文件，回到原始的三个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm hello.o sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始尝试途径三，创建静态库文件libmyhello.so：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按教程里，会报错：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -fPIC -o libmyhello.so hello.o</span></span><br><span class="line">/usr/bin/ld: hello.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC</span><br><span class="line">hello.o: could not read symbols: Bad value</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>正确方法是，这样就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared -o libmyhello.so hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 已生成libmyhello.so，是绿色。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  libmyhello.so  main.c</span><br></pre></td></tr></table></figure><p>最主要的是 GCC 命令行的选项:</p><ul><li><p><code>-shared</code>：指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件</p></li><li><p><code>-fPIC</code>：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。</p></li></ul><p>下面调用该动态链接库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.c -L. -lmyhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  libmyhello.so  main.c  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br><span class="line">成功！</span><br></pre></td></tr></table></figure><p>按教程里说的：他以这种方式调用动态链接库出错，找不到动态库文件 <code>libmyhello.so</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sayhello: error while loading shared libraries: libmyhello.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>程序在运行时，会在 /usr/lib 和 /lib 等目录中查找需要的动态库文件。若找到，则载入动态库，否则将提示类似上述错误而终止程序运行。解决此类问题有如下三种方法：</p><ul><li><p>（1）我们将文件 libmyhello.so复制到目录/usr/lib中。</p></li><li><p>（2）既然连接器会搜寻LD_LIBRARY_PATH所指定的目录，那么我们只要将当前目录添加到环境变量：</p><p><code>export LD_LIBRARY_PATH=$(pwd)</code></p></li><li><p>（3）执行： <code>ldconfig /usr/zhsoft/lib</code></p></li></ul><p>说明：当用户在某个目录下面创建或拷贝了一个动态链接库，若想使其被系统共享，可以执行一下 “ldconfig 目录名” 这个命令。此命令的功能在于让 ldconfig 将指定目录下的动态链接库被系统共享起来，意即：在缓存文件 <code>/etc/ld.so.cache</code> 中追加进指定目录下的共享库。该命令会重建 <code>/etc/ld.so.cache</code> 文件。</p><p>参考教程：</p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlheW91eGpoL2FydGljbGUvZGV0YWlscy83NjAyNzI5" title="http://blog.csdn.net/jiayouxjh/article/details/7602729">http://blog.csdn.net/jiayouxjh/article/details/7602729<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzU0ZjgyY2MyMDEwMTE1M3guaHRtbA==" title="http://blog.sina.com.cn/s/blog_54f82cc20101153x.html">http://blog.sina.com.cn/s/blog_54f82cc20101153x.html<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25hdnlhaWptLmJsb2cuNTFjdG8uY29tLzQ2NDcwNjgvODA5NDI0" title="http://navyaijm.blog.51cto.com/4647068/809424">http://navyaijm.blog.51cto.com/4647068/809424<i class="fa fa-external-link"></i></span></p><h2 id="十二、递归函数"><a href="#十二、递归函数" class="headerlink" title="十二、递归函数"></a>十二、递归函数</h2><h3 id="12-1-递归函数基本概念"><a href="#12-1-递归函数基本概念" class="headerlink" title="12.1 递归函数基本概念"></a>12.1 <strong>递归函数基本概念</strong></h3><p>C通过运行时堆栈来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。</p><h3 id="12-2-普通函数调用"><a href="#12-2-普通函数调用" class="headerlink" title="12.2 普通函数调用"></a>12.2 普通函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funB</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b = %d\n"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">funB(a - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">funA(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用流程如下：</p><img src="/images/imageProgramC/递归函数.png"><h3 id="12-3-递归函数调用"><a href="#12-3-递归函数调用" class="headerlink" title="12.3 递归函数调用"></a>12.3 递归函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//中断函数很重要</span></span><br><span class="line">&#125;</span><br><span class="line">fun(a - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">fun(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用流程如下：</p><img src="/images/imageProgramC/递归函数-01.png"><p><strong>递归实现给出一个数8793，依次打印千位数字8、百位数字7、十位数字9、个位数字3。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (val == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret = val / <span class="number">10</span>;</span><br><span class="line">recursion(ret);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,val % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-递归实现字符串反转"><a href="#12-4-递归实现字符串反转" class="headerlink" title="12.4 递归实现字符串反转"></a>12.4 递归实现字符串反转</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse1</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">'\0'</span>) &#123;  <span class="comment">// 函数递归调用结束条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse1(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, *str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( *str == <span class="string">'\0'</span> ) &#123;<span class="comment">// 函数递归调用结束条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse2(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strncat</span>(buf, str, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse3</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> *dst)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span> || dst == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">'\0'</span>) &#123;<span class="comment">// 函数递归调用结束条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse3(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strncat</span>(dst, str, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-递归实现链表逆序打印"><a href="#12-5-递归实现链表逆序打印" class="headerlink" title="12.5 递归实现链表逆序打印"></a>12.5 递归实现链表逆序打印</h3><p>TODO</p><h2 id="十三、面向接口编程"><a href="#十三、面向接口编程" class="headerlink" title="十三、面向接口编程"></a>十三、面向接口编程</h2><h3 id="13-1-案例背景"><a href="#13-1-案例背景" class="headerlink" title="13.1 案例背景"></a>13.1 案例背景</h3><p>一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。</p><h3 id="13-2-案例需求"><a href="#13-2-案例需求" class="headerlink" title="13.2 案例需求"></a>13.2 案例需求</h3><p>要求在企业信息系统框架中集成第三方厂商的socket通信产品和第三方厂商加密产品。软件设计要求：模块要求松、接口要求紧。</p><h3 id="13-3-案例要求"><a href="#13-3-案例要求" class="headerlink" title="13.3 案例要求"></a>13.3 案例要求</h3><ul><li><p>1）能支持多个厂商的 socket 通信产品入围</p></li><li><p>2）能支持多个第三方厂商加密产品的入围</p></li><li><p>3）企业信息系统框架不轻易发生框架</p></li></ul><h3 id="13-4-编程提示"><a href="#13-4-编程提示" class="headerlink" title="13.4 编程提示"></a>13.4 编程提示</h3><ul><li><p>1）抽象通信接口结构体设计（CSocketProtocol）</p></li><li><p>2）框架接口设计（framework）</p></li><li><p>3）   a) 通信厂商1入围（CSckImp1）  b) 通信厂商2入围（CSckImp2）</p></li><li><p>4）   a) 抽象加密接口结构体设计（CEncDesProtocol） b) 升级框架函数（增加加解密功能）  c) 加密厂商1入围(CHwImp)、加密厂商2入围(CCiscoImp)</p></li><li><p>5）框架接口分文件</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-语言进阶&quot;&gt;&lt;a href=&quot;#C-语言进阶&quot; class=&quot;headerlink&quot; title=&quot;C 语言进阶&quot;&gt;&lt;/a&gt;C 语言进阶&lt;/h1&gt;&lt;h2 id=&quot;一、-内存分区&quot;&gt;&lt;a href=&quot;#一、-内存分区&quot; class=&quot;headerlink&quot; title=&quot;一、 内存分区&quot;&gt;&lt;/a&gt;一、 内存分区&lt;/h2&gt;&lt;p&gt;栈区&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Program-C" scheme="http://miaopei.github.io/categories/Program-C/"/>
    
    
      <category term="Program-C" scheme="http://miaopei.github.io/tags/Program-C/"/>
    
  </entry>
  
  <entry>
    <title>Program-C 基础</title>
    <link href="http://miaopei.github.io/2016/05/10/Program-C/program-c/"/>
    <id>http://miaopei.github.io/2016/05/10/Program-C/program-c/</id>
    <published>2016-05-10T02:14:50.000Z</published>
    <updated>2019-06-10T08:02:59.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C 语言基础"></a>C 语言基础</h1><h2 id="一、C-语言概述"><a href="#一、C-语言概述" class="headerlink" title="一、C 语言概述"></a>一、C 语言概述</h2><a id="more"></a><img src="/images/imageProgramC/03_C语言概述.png"><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><img src="/images/imageProgramC/04_数据类型.png"><h2 id="三、字符串处理和函数"><a href="#三、字符串处理和函数" class="headerlink" title="三、字符串处理和函数"></a>三、字符串处理和函数</h2><ul><li><p>声明变量不需要建立存储空间，如：extern int a;</p></li><li><p>定义变量需要建立存储空间，如：int b;</p></li><li><p>全局数组若不初始化，编译器将其初始化为零。局部数组若不初始化，内容为随机值。</p></li><li><p>数字 0 (和字符 ‘\0’ 等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。</p></li></ul><p>gets(str)与scanf(“%s”,str)的区别：</p><ul><li><p>gets(str)允许输入的字符串含有空格</p></li><li><p>scanf(“%s”,str)不允许含有空格</p></li><li><p>注意：由于scanf()和gets()无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字符数组越界(缓冲区溢出)的情况。</p></li></ul><p>gets() 、puts()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">功能：从标准输入读入字符，并保存到s指定的内存空间，直到出现换行符或读到文件结尾为止。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">功能：标准设备输出s字符串，在输出完成后自动输出一个<span class="string">'\n'</span>。</span><br></pre></td></tr></table></figure><p>fgets() 、fputs()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line">功能：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - <span class="number">1</span>个字符为止，最后会自动加上字符 <span class="string">'\0'</span> 作为字符串结束。</span><br><span class="line">fgets()在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。通过<span class="built_in">scanf</span>和gets输入一个字符串的时候，不包含结尾的“\n”，但通过fgets结尾多了“\n”。fgets()函数是安全的，不存在缓冲区溢出的问题。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, FILE * stream)</span></span>;</span><br><span class="line">功能：将str所指定的字符串写入到stream指定的文件中， 字符串结束符 <span class="string">'\0'</span>  不写入文件。</span><br><span class="line"><span class="built_in">fputs</span>()是<span class="built_in">puts</span>()的文件操作版本，但<span class="built_in">fputs</span>()不会自动输出一个<span class="string">'\n'</span>。</span><br></pre></td></tr></table></figure><p>strlen() 、strcpy() 、strncpy() 、strcat() 、strncat() 、strcmp() 、strncmp() 、sprintf() 、sscanf() 、strchr() 、strstr() 、strtok() 、atoi()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">功能：计算指定指定字符串s的长度，不包含字符串结束符‘\<span class="number">0</span>’</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br><span class="line">功能：把src所指向的字符串复制到dest所指向的空间中，<span class="string">'\0'</span>也会拷贝过去</span><br><span class="line">注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含<span class="string">'\0'</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br><span class="line">功能：将src字符串连接到dest的尾部，‘\<span class="number">0</span>’也会追加过去</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：将src字符串前n个字符连接到dest的尾部，‘\<span class="number">0</span>’也会追加过去</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line">功能：比较 s1 和 s2 的大小，比较的是字符ASCII码大小。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *_CRT_SECURE_NO_WARNINGS, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line">功能：在字符串s中查找字母c出现的位置</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle)</span></span>;</span><br><span class="line">功能：在字符串haystack中查找字符串needle出现的位置</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *delim)</span></span>;</span><br><span class="line">功能：来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\<span class="number">0</span> 字符，当连续出现多个时只替换第一个为\<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br><span class="line">功能：atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(<span class="string">'\0'</span>)才结束转换，并将结果返回返回值。</span><br><span class="line">类似的函数有：</span><br><span class="line">- atof()：把一个小数形式的字符串转化为一个浮点数。</span><br><span class="line">- atol()：将一个字符串转化为<span class="keyword">long</span>类型</span><br></pre></td></tr></table></figure><p>形参列表</p><ul><li>在定义函数时指定的形参，<strong>在未出现函数调用时，它们并不占内存中的存储单元</strong>，因此称它们是形式参数或虚拟参数，简称形参，表示它们并不是实际存在的数据，所以，形参里的变量不能赋值。</li></ul><p>如果函数返回的类型和return语句中表达式的值不一致，则以函数返回类型为准，即<strong>函数返回类型决定返回值的类型</strong>。对数值型数据，可以自动进行类型转换。</p><p><strong>注意</strong>：如果函数返回的类型和return语句中表达式的值不一致，而它又无法自动进行类型转换，程序则会报错。</p><p><strong>当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</strong> </p><p><strong>extern告诉编译器这个变量或函数在其他文档里已被定义了。</strong></p><p>static法则：</p><ul><li>A、若全局变量仅在单个C文档中访问，则能够将这个变量修改为静态全局变量，以降低模块间的耦合度; </li><li>B、若全局变量仅由单个函数访问，则能够将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； </li><li>C、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多文件编译</span></span><br><span class="line">gcc -o 可执行程序 文件<span class="number">1.</span>c 文件<span class="number">2.</span>c 头文件.h</span><br></pre></td></tr></table></figure><h2 id="四、指针和指针变量"><a href="#四、指针和指针变量" class="headerlink" title="四、指针和指针变量"></a>四、指针和指针变量</h2><ul><li><strong>内存区的每一个字节都有一个编号，这就是“地址”</strong>。</li><li>如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)</li><li>指针的实质就是内存“地址”。指针就是地址，地址就是指针。</li><li><strong>指针是内存单元的编号，指针变量是存放地址的变量</strong>。</li><li>通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。</li><li>指针也是一种数据类型，指针变量也是一种变量</li><li>指针变量指向谁，就把谁的地址赋值给指针变量</li><li><strong>“*” 操作符操作的是指针变量指向的内存空间</strong></li></ul><p>指针大小</p><ul><li><strong>使用sizeof()测量指针的大小，得到的总是：4或8</strong></li><li>sizeof()测的是指针变量指向存储地址的大小</li><li>在32位平台，所有的指针（地址）都是32位(4字节)</li><li>在64位平台，所有的指针（地址）都是64位(8字节)</li></ul><p>野指针和空指针</p><ul><li>指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，<strong>任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针</strong>，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，<strong>野指针不会直接引发错误，操作野指针指向的内存区域才会出问题</strong>。</li><li>但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。</li><li>NULL是一个值为0的宏常量：<code>#define NULL    ((void *)0)</code></li></ul><p>万能指针 <code>void *</code></p><p><code>void *</code> 指针可以指向任意变量的内存空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">p = (<span class="keyword">void</span> *)&amp;a; <span class="comment">//指向变量时，最好转换为void *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指针变量指向的内存时，转换为int *</span></span><br><span class="line">*( (<span class="keyword">int</span> *)p ) = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br></pre></td></tr></table></figure><p>const修饰的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向常量的指针</span></span><br><span class="line"><span class="comment">//修饰*，指针指向内存区域不能修改，指针指向可以变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a; <span class="comment">//等价于int const *p1 = &amp;a;</span></span><br><span class="line"><span class="comment">//*p1 = 111; //err</span></span><br><span class="line">p1 = &amp;b; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//修饰p1，指针指向不能变，指针指向的内存可以修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; //err</span></span><br><span class="line">*p2 = <span class="number">222</span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>指针操作数组元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf("%d, ", a[i]);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(a+i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a; <span class="comment">//定义一个指针变量保存a的地址</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(p + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针加减运算</p><ul><li>指针计算不是简单的整数相加</li><li>如果是一个<code>int *</code>，+1的结果是增加一个int的大小</li><li>如果是一个<code>char *</code>，+1的结果是增加一个char大小</li></ul><p>通过改变指针指向操作数组元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *p);</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针数组</p><ul><li>指针数组，它是数组，数组的每个元素都是指针类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//指针数组</span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>] = &amp;a;</span><br><span class="line">p[<span class="number">1</span>] = &amp;b;</span><br><span class="line">p[<span class="number">2</span>] = &amp;c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(p[<span class="number">0</span>]); i++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(p[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多级指针 </p><ul><li>C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针。</li><li>二级指针就是指向一个一级指针变量地址的指针。</li><li>三级指针基本用不着，但考试会考。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">//一级指针</span></span><br><span class="line">*p = <span class="number">100</span>; <span class="comment">//*p就是a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **q = &amp;p;</span><br><span class="line"><span class="comment">//*q就是p</span></span><br><span class="line"><span class="comment">//**q就是a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ***t = &amp;q;</span><br><span class="line"><span class="comment">//*t就是q</span></span><br><span class="line"><span class="comment">//**t就是p</span></span><br><span class="line"><span class="comment">//***t就是a</span></span><br></pre></td></tr></table></figure><p>数组名做函数参数</p><ul><li>数组名做函数参数，函数的形参会退化为指针：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void printArrary(int a[10], int n)</span></span><br><span class="line"><span class="comment">//void printArrary(int a[], int n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArrary</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组名做函数参数</span></span><br><span class="line">printArrary(a, n); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针做为函数的返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*( getA() ) = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针和字符串</p><ul><li>字符指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = str;</span><br><span class="line">*p = <span class="string">'m'</span>;</span><br><span class="line">p++;</span><br><span class="line">*p = <span class="string">'i'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);  <span class="comment">// millo world</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">"mike jiang"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p); <span class="comment">// mike jiang</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *q = <span class="string">"test"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, q); <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const修饰的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//const修饰一个变量为只读</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//a = 100; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量， 指针指向的内存， 2个不同概念</span></span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"aklgjdlsgjlkds"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从左往右看，跳过类型，看修饰哪个字符</span></span><br><span class="line"><span class="comment">//如果是*， 说明指针指向的内存不能改变</span></span><br><span class="line"><span class="comment">//如果是指针变量，说明指针的指向不能改变，指针的值不能修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = buf;</span><br><span class="line"><span class="comment">// 等价于上面 char const *p1 = buf;</span></span><br><span class="line"><span class="comment">//p[1] = '2'; //err</span></span><br><span class="line">p = <span class="string">"agdlsjaglkdsajgl"</span>; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p2 = buf;</span><br><span class="line">p2[<span class="number">1</span>] = <span class="string">'3'</span>;</span><br><span class="line"><span class="comment">//p2 = "salkjgldsjaglk"; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p3为只读，指向不能变，指向的内存也不能变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p3 = buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、内存管理"><a href="#五、内存管理" class="headerlink" title="五、内存管理"></a>五、内存管理</h2><h3 id="5-1-作用域"><a href="#5-1-作用域" class="headerlink" title="5.1 作用域"></a>5.1 作用域</h3><p>C语言变量的作用域分为：</p><ul><li>代码块作用域(代码块是{}之间的一段代码)</li><li>函数作用域</li><li>文件作用域</li></ul><p>局部变量也叫auto自动变量(auto可写可不写)，一般情况下代码块{}内部定义的变量都是自动变量，它有如下特点：</p><ul><li>在一个函数内定义，只在函数范围内有效</li><li>在复合语句中定义，只在复合语句中有效</li><li><strong>随着函数调用的结束或复合语句的结束局部变量的声明声明周期也结束</strong></li><li>如果没有赋初值，内容为随机</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//auto写不写是一样的</span></span><br><span class="line"><span class="comment">//auto只能出现在&#123;&#125;内部</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">int</span> b = <span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//b = 100; //err， 在main作用域中没有b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在复合语句中定义，只在复合语句中有效</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = 10; //err离开if()的复合语句，a已经不存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态(static)局部变量</p><ul><li>static局部变量的作用域也是在定义的函数内有效</li><li>static局部变量的生命周期和程序运行周期一样，同时staitc局部变量的值<strong>只初始化一次，但可以赋值多次</strong></li><li>static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0，字符型变量赋空字符</li></ul><p>全局变量</p><ul><li>在函数外定义，可被本文件及其它文件中的函数所共用，<strong>若其它文件中的函数调用此变量,须用extern声明</strong></li><li>全局变量的生命周期和程序运行周期一样</li><li>不同文件的全局变量不可重名</li></ul><p>静态(static)全局变量</p><ul><li>在函数外定义,作用范围被限制在所定义的文件中</li><li>不同文件静态全局变量可以重名,但作用域不冲突</li><li>static全局变量的生命周期和程序运行周期一样，同时staitc全局变量的值只初始化一次</li></ul><p>extern全局变量声明</p><ul><li>extern int a; 声明一个变量，这个变量在别的文件中已经定义了，这里只是声明，而不是定义</li></ul><p>全局函数和静态函数</p><ul><li>在C语言中函数默认都是全局的，使用关键字static可以将函数声明为静态，函数定义为static就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数都没用。</li></ul><p><strong>注意</strong>：</p><ul><li>允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰。</li><li>同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。</li><li>所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。</li></ul><p>总结：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th></tr></thead><tbody><tr><td>auto变量</td><td>一对{}内</td><td>当前函数</td></tr><tr><td>static局部变量</td><td>一对{}内</td><td>整个程序运行期</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>register变量</td><td>一对{}内</td><td>当前函数</td></tr></tbody></table><h3 id="5-2-内存布局"><a href="#5-2-内存布局" class="headerlink" title="5.2 内存布局"></a>5.2 内存布局</h3><p>内存分区</p><ul><li>C代码经过<strong>预处理、编译、汇编、链接</strong>4步后生成一个可执行程序。</li></ul><p>在 Linux 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况：</p><img src="/images/imageProgramC/fileinfo.png"><p>通过上图可以得知，在没有运行程序前，也就是说<strong>程序没有加载到内存前</strong>，可执行程序内部已经分好3段信息，分别为<strong>代码区（text）、数据区（data）和未初始化数据区（bss）</strong>3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。</p><ul><li><p><strong>代码区</strong></p><ul><li>存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。<strong>代码区通常是只读的</strong>，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。</li></ul></li><li><p><strong>全局初始化数据区/静态数据区（data段）</strong></p><ul><li>该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</li></ul></li><li><p><strong>未初始化数据区（又叫 bss 区）</strong></p><ul><li>存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。</li></ul><p>程序在加载到内存前，<strong>代码区和全局区(data和bss)的大小就是固定的</strong>，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，<strong>除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区</strong>。</p></li></ul><img src="/images/imageProgramC/内存分区.png"><ul><li><p>代码区（text segment）</p><ul><li>加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。</li></ul></li><li><p>未初始化数据区（BSS）</p><ul><li>加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。</li></ul></li><li><p>全局初始化数据区/静态数据区（data segment）</p><ul><li>加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。</li></ul></li><li><p>栈区（stack）</p><ul><li><strong>栈是一种先进后出的内存结构</strong>，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。</li></ul></li><li><p>堆区（heap）</p><ul><li>堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。<strong>堆在内存中位于BSS区和栈区之间</strong>。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</li></ul></li></ul><p>存储类型总结：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th><th><strong>存储位置</strong></th></tr></thead><tbody><tr><td>auto变量</td><td>一对{}内</td><td>当前函数</td><td>栈区</td></tr><tr><td>static局部变量</td><td>一对{}内</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td><td>代码区</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td><td>代码区</td></tr><tr><td>register变量</td><td>一对{}内</td><td>当前函数</td><td>运行时存储在CPU寄存器</td></tr><tr><td>字符串常量</td><td>当前文件</td><td>整个程序运行期</td><td>data段</td></tr></tbody></table><p><strong>存储类型总结内存操作函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：将s的内存区域的前n个字节以参数c填入</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。</span><br><span class="line"></span><br><span class="line">memmove()</span><br><span class="line">memmove()功能用法和<span class="built_in">memcpy</span>()一样，区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比<span class="built_in">memcpy</span>()低些。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：比较s1和s2所指向内存区域的前n个字节</span><br></pre></td></tr></table></figure><p><strong>堆区内存分配和释放</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用<span class="built_in">memset</span>初始化。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count, *<span class="built_in">array</span>, n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入要申请数组的个数:\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"申请空间失败!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将申请到空间清0</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; n; count++) <span class="comment">/*给数组赋值*/</span></span><br><span class="line"><span class="built_in">array</span>[count] = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; n; count++) <span class="comment">/*打印数组元素*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%2d"</span>, <span class="built_in">array</span>[count]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回堆区地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">tmp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*tmp = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;<span class="comment">//返回堆区地址，函数调用完毕，不释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = fun();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, *p);<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//堆区空间，使用完毕，手动释放</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、复合类型-自定义类型"><a href="#六、复合类型-自定义类型" class="headerlink" title="六、复合类型(自定义类型)"></a>六、复合类型(自定义类型)</h2><h3 id="6-1-结构体"><a href="#6-1-结构体" class="headerlink" title="6.1 结构体"></a>6.1 结构体</h3><p>定义结构体变量的方式：</p><ul><li>先声明结构体类型再定义变量名</li><li>在声明类型的同时定义变量</li><li>直接定义结构体类型变量（无类型名）</li></ul><img src="/images/imageProgramC/结构体.png"><p>结构体类型和结构体变量关系：</p><ul><li>结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。</li><li>结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先定义类型，再定义变量（常用）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span> = &#123;</span> <span class="string">"mike"</span>, <span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类型同时定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;s2 = &#123; <span class="string">"lily"</span>, <span class="number">22</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;s3 = &#123; <span class="string">"yuri"</span>, <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure><p>结构体成员的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是普通变量，通过点运算符操作结构体成员</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1.name, <span class="string">"abc"</span>);</span><br><span class="line">s1.age = <span class="number">18</span>;   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s1.name = %s, s1.age = %d\n"</span>, s1.name, s1.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line"><span class="built_in">strcpy</span>((&amp;s1)-&gt;name, <span class="string">"test"</span>);</span><br><span class="line">(&amp;s1)-&gt;age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(&amp;s1)-&gt;name = %s, (&amp;s1)-&gt;age = %d\n"</span>, (&amp;s1)-&gt;name, (&amp;s1)-&gt;age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体套结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">info</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[2] = &#123;</span> <span class="number">1</span>, <span class="string">"lily"</span>, <span class="string">'F'</span>, <span class="number">2</span>, <span class="string">"yuri"</span>, <span class="string">'M'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d\tinfo.name=%s\tinfo.sex=%c\n"</span>, s[i].id, s[i].info.name, s[i].info.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体套一级指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *name; <span class="comment">//一级指针</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">p = (struct stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct  stu));</span><br><span class="line">p-&gt;name = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">"test"</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(p-&gt;name, <span class="string">"test"</span>);</span><br><span class="line">p-&gt;age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p-&gt;name = %s, p-&gt;age=%d\n"</span>, p-&gt;name, p-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(*p).name = %s, (*p).age=%d\n"</span>, (*p).name, (*p).age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;name != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p-&gt;name);</span><br><span class="line">p-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体普通变量做函数参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数参数为结构体普通变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stu</span><span class="params">(struct stu tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp.name, <span class="string">"mike"</span>);</span><br><span class="line">tmp.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"tmp.name = %s, tmp.age = %d\n"</span>, tmp.name, tmp.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">set_stu(s); <span class="comment">//值传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s.name = %s, s.age = %d\n"</span>, s.name, s.age);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体指针变量做函数参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数参数为结构体指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stu_pro</span><span class="params">(struct stu *tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp-&gt;name, <span class="string">"mike"</span>);</span><br><span class="line">tmp-&gt;age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">set_stu_pro(&amp;s); <span class="comment">//地址传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s.name = %s, s.age = %d\n"</span>, s.name, s.age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体数组名做函数参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void set_stu_pro(struct stu tmp[100], int n)</span></span><br><span class="line"><span class="comment">//void set_stu_pro(struct stu tmp[], int n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stu_pro</span><span class="params">(struct stu *tmp, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(tmp-&gt;name, <span class="string">"name%d%d%d"</span>, i, i, i);</span><br><span class="line">tmp-&gt;age = <span class="number">20</span> + i;</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[3] = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">set_stu_pro(s, n); <span class="comment">//数组名传递</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s, %d\n"</span>, s[i].name, s[i].age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-共用体-联合体"><a href="#6-2-共用体-联合体" class="headerlink" title="6.2 共用体(联合体)"></a>6.2 共用体(联合体)</h3><ul><li>联合union是一个能在同一个存储空间存储不同类型数据的类型；</li><li>联合体所占的内存长度等于其最长成员的长度，也有叫做共用体；</li><li>同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用；</li><li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖；</li><li>共用体变量的地址和它的各成员的地址都是同一地址。</li></ul><h3 id="6-3-枚举"><a href="#6-3-枚举" class="headerlink" title="6.3 枚举"></a>6.3 枚举</h3><p>枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p><p>枚举类型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  枚举名</span><br><span class="line">&#123;</span><br><span class="line">枚举值表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在枚举值表中应列出所有可用值，也称为枚举元素。</li><li>枚举值是常量，不能在程序中用赋值语句再对它赋值。</li><li>枚举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 …</li></ul><h3 id="6-4-typedef"><a href="#6-4-typedef" class="headerlink" title="6.4 typedef"></a>6.4 typedef</h3><p>typedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，<strong>不能创建新类型</strong>。</p><ul><li><p>与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值</p></li><li><p>#define发生在预处理，typedef发生在编译阶段</p></li></ul><h2 id="七、文件操作"><a href="#七、文件操作" class="headerlink" title="七、文件操作"></a>七、文件操作</h2><p>磁盘文件和设备文件</p><ul><li>磁盘文件<ul><li>指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。</li></ul></li><li>设备文件<ul><li>在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。</li></ul></li></ul><h3 id="7-1-文件的打开和关闭"><a href="#7-1-文件的打开和关闭" class="headerlink" title="7.1 文件的打开和关闭"></a>7.1 文件的打开和关闭</h3><p>文件指针</p><ul><li>在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">short</span>           level;<span class="comment">//缓冲区"满"或者"空"的程度 </span></span><br><span class="line"><span class="keyword">unsigned</span>        flags;<span class="comment">//文件状态标志 </span></span><br><span class="line"><span class="keyword">char</span>            fd;<span class="comment">//文件描述符</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>   hold;<span class="comment">//如无缓冲区不读取字符</span></span><br><span class="line"><span class="keyword">short</span>           bsize;<span class="comment">//缓冲区的大小</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>   *buffer;<span class="comment">//数据缓冲区的位置 </span></span><br><span class="line"><span class="keyword">unsigned</span>        ar; <span class="comment">//指针，当前的指向</span></span><br><span class="line"><span class="keyword">unsigned</span>        istemp;<span class="comment">//临时文件，指示器</span></span><br><span class="line"><span class="keyword">short</span>           token;<span class="comment">//用于有效性的检查 </span></span><br><span class="line">&#125;FILE;</span><br></pre></td></tr></table></figure><p>FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，<strong>结构中含有文件名、文件状态和文件当前位置等信息</strong>。</p><p>声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 </p><p>文件的打开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line">功能：打开文件</span><br></pre></td></tr></table></figure><p>第二个参数的几种形式(打开文件的方式)：</p><table><thead><tr><th><strong>打开模式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>r或rb</td><td>以只读方式打开一个文本文件（不创建文件，若文件不存在则报错）</td></tr><tr><td>w或wb</td><td>以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a或ab</td><td>以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件</td></tr><tr><td>r+或rb+</td><td>以可读、可写的方式打开文件(不创建新文件)</td></tr><tr><td>w+或wb+</td><td>以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a+或ab+</td><td>以添加方式打开文件，打开文件并在末尾更改文件,若文件不存在则创建文件</td></tr></tbody></table><p>注意：</p><ul><li><p>b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的</p></li><li><p>Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾</p></li><li><p>在Windows平台下，以“文本”方式打开文件，不加b：</p><ul><li>当读取文件的时候，系统会将所有的 “\r\n” 转换成 “\n”</li><li>当写入文件的时候，系统会将 “\n” 转换成 “\r\n” 写入 </li><li><strong>以”二进制”方式打开文件，则读\写都不会进行这样的转换</strong></li></ul></li><li><p>在Unix/Linux平台下，“文本”与“二进制”模式没有区别，”\r\n” 作为两个字符原样输入输出</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径可以是相对路径，也可是绝对路径</span></span><br><span class="line">fp = fopen(<span class="string">"../test"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="comment">//fp = fopen("..\\test", "w");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) <span class="comment">//返回空，说明打开失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//perror()是标准出错打印函数，能打印调用库函数出错原因</span></span><br><span class="line">perror(<span class="string">"open"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-文件的顺序读写"><a href="#7-2-文件的顺序读写" class="headerlink" title="7.2 文件的顺序读写"></a>7.2 文件的顺序读写</h3><ul><li>按照字符读写文件fgetc、fputc</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE * stream)</span></span>;</span><br><span class="line">功能：将ch转换为<span class="keyword">unsigned</span> <span class="keyword">char</span>后写入stream指定的文件中</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：从stream指定的文件中读取一个字符</span><br></pre></td></tr></table></figure><p>在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，<strong>这种以EOF作为文件结束标志的文件，必须是文本文件</strong>。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。<code>#define EOF    (-1)</code></p><p>当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。<strong>feof函数既可用以判断二进制文件又可用以判断文本文件</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：检测是否读取到了文件结尾。**判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)**。</span><br></pre></td></tr></table></figure><ul><li>按照行读写文件fgets、fputs</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, FILE * stream)</span></span>;</span><br><span class="line">功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 <span class="string">'\0'</span>  不写入文件。 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> * str, <span class="keyword">int</span> size, FILE * stream)</span></span>;</span><br><span class="line">功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - <span class="number">1</span>个字符为止，最后会自动加上字符 <span class="string">'\0'</span> 作为字符串结束。</span><br></pre></td></tr></table></figure><ul><li>按照格式化文件fprintf、fscanf</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</span><br></pre></td></tr></table></figure><ul><li>按照块读写文件fread、fwrite</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式给文件写入内容</span><br><span class="line">参数：</span><br><span class="line">ptr：准备写入文件数据的地址</span><br><span class="line">size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定写入文件内容的块数据大小</span><br><span class="line">nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功写入文件数据的块数目，此值和nmemb相等</span><br><span class="line">失败：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式从文件中读取内容</span><br></pre></td></tr></table></figure><h3 id="7-3-文件的随机读写"><a href="#7-3-文件的随机读写" class="headerlink" title="7.3 文件的随机读写"></a>7.3 文件的随机读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line">功能：移动文件流（文件光标）的读写位置。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line">whence：其取值如下：</span><br><span class="line">SEEK_SET：从文件开头移动offset个字节</span><br><span class="line">SEEK_CUR：从当前位置移动offset个字节</span><br><span class="line">SEEK_END：从文件末尾移动offset个字节</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">功能：获取文件流（文件光标）的读写位置。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：当前文件流（文件光标）的读写位置</span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">功能：把文件流（文件光标）的读写位置移动到文件开头。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">无返回值</span><br></pre></td></tr></table></figure><h3 id="7-4-获取文件状态"><a href="#7-4-获取文件状态" class="headerlink" title="7.4 获取文件状态"></a>7.4 获取文件状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line">功能：获取文件状态信息</span><br><span class="line">参数：</span><br><span class="line">path：文件名</span><br><span class="line">buf：保存文件信息的结构体</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="keyword">dev_t</span>         st_dev;         <span class="comment">//文件的设备编号</span></span><br><span class="line"><span class="keyword">ino_t</span>         st_ino;          <span class="comment">//节点</span></span><br><span class="line"><span class="keyword">mode_t</span>        st_mode;   <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line"><span class="keyword">nlink_t</span>       st_nlink;     <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line"><span class="keyword">uid_t</span>         st_uid;         <span class="comment">//用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span>         st_gid;         <span class="comment">//组ID</span></span><br><span class="line"><span class="keyword">dev_t</span>         st_rdev;      <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line"><span class="keyword">off_t</span>         st_size;        <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;   <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks;    <span class="comment">//块数</span></span><br><span class="line"><span class="keyword">time_t</span>        st_atime;     <span class="comment">//最后一次访问时间</span></span><br><span class="line"><span class="keyword">time_t</span>        st_mtime;    <span class="comment">//最后一次修改时间</span></span><br><span class="line"><span class="keyword">time_t</span>        st_ctime;     <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">stat(args[<span class="number">1</span>], &amp;st);</span><br><span class="line"><span class="keyword">int</span> size = st.st_size;<span class="comment">//得到结构体中的成员变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, size);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-删除文件、重命名文件名"><a href="#7-5-删除文件、重命名文件名" class="headerlink" title="7.5 删除文件、重命名文件名"></a>7.5 删除文件、重命名文件名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line">功能：删除文件</span><br><span class="line">参数：</span><br><span class="line">pathname：文件名</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line">功能：把oldpath的文件名改为newpath</span><br><span class="line">参数：</span><br><span class="line">oldpath：旧文件名</span><br><span class="line">newpath：新文件名</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="7-6-文件缓冲区"><a href="#7-6-文件缓冲区" class="headerlink" title="7.6 文件缓冲区"></a>7.6 文件缓冲区</h3><p>ANSI C标准采用“缓冲文件系统”处理数据文件。</p><p>所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。</p><p>如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。</p><p>磁盘文件的存取：</p><img src="/images/imageProgramC/磁盘文件的读取.png"><ul><li><p>磁盘文件，一般保存在硬盘、U盘等掉电不丢失的磁盘设备中，在需要时调入内存</p></li><li><p>在内存中对文件进行编辑处理后，保存到磁盘中</p></li><li><p>程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率</p></li></ul><p>更新缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">功能：更新缓冲区，让缓冲区的数据立马写到文件中。</span><br><span class="line">参数：</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-语言基础&quot;&gt;&lt;a href=&quot;#C-语言基础&quot; class=&quot;headerlink&quot; title=&quot;C 语言基础&quot;&gt;&lt;/a&gt;C 语言基础&lt;/h1&gt;&lt;h2 id=&quot;一、C-语言概述&quot;&gt;&lt;a href=&quot;#一、C-语言概述&quot; class=&quot;headerlink&quot; title=&quot;一、C 语言概述&quot;&gt;&lt;/a&gt;一、C 语言概述&lt;/h2&gt;
    
    </summary>
    
      <category term="Program-C" scheme="http://miaopei.github.io/categories/Program-C/"/>
    
    
      <category term="Program-C" scheme="http://miaopei.github.io/tags/Program-C/"/>
    
  </entry>
  
  <entry>
    <title>Program-C 交叉编译</title>
    <link href="http://miaopei.github.io/2016/05/05/Program-C/compile/"/>
    <id>http://miaopei.github.io/2016/05/05/Program-C/compile/</id>
    <published>2016-05-05T02:14:50.000Z</published>
    <updated>2019-06-10T08:02:34.396Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><img src="/images/imageProgramC/03_C语言概述.png"><h1 id="建立ARM交叉编译环境arm-none-linux-gnueabi-gcc"><a href="#建立ARM交叉编译环境arm-none-linux-gnueabi-gcc" class="headerlink" title="建立ARM交叉编译环境arm-none-linux-gnueabi-gcc"></a>建立ARM交叉编译环境arm-none-linux-gnueabi-gcc</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> add2line：将你要找的地址转成文件和行号，它要使用 debug 信息</span></span><br><span class="line">arm-none-linux-gnueabi-addr2line </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ar：产生、修改和解开一个存档文件</span></span><br><span class="line">arm-none-linux-gnueabi-ar </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> as：gnu的汇编器</span></span><br><span class="line">arm-none-linux-gnueabi-as   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ld：gnu 的连接器</span></span><br><span class="line">arm-none-linux-gnueabi-ld </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gprof：gnu 汇编器预编译器</span></span><br><span class="line">arm-none-linux-gnueabi-gprof </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nm：列出目标文件的符号和对应的地址</span></span><br><span class="line">arm-none-linux-gnueabi-nm      </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> objdump：显示目标文件的信息</span></span><br><span class="line">arm-none-linux-gnueabi-objdump </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> readelf：显示 elf 格式的目标文件的信息</span></span><br><span class="line">arm-none-linux-gnueabi-readelf </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> strings：打印出目标文件中可以打印的字符串，有个默认的长度，为4</span></span><br><span class="line">arm-none-linux-gnueabi-strings </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> c++filt：C++ 和 java 中有一种重载函数，所用的重载函数最后会被编译转化成汇编的标，c++filt 就是实现这种反向的转化，根据标号得到函数名</span></span><br><span class="line">arm-none-linux-gnueabi-c++filt </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> objcopy：将某种格式的目标文件转化成另外格式的目标文件</span></span><br><span class="line">arm-none-linux-gnueabi-objcopy </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ranlib：为一个存档文件产生一个索引，并将这个索引存入存档文件中</span></span><br><span class="line">arm-none-linux-gnueabi-ranlib  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> size：显示目标文件各个节的大小和目标文件的大小</span></span><br><span class="line">arm-none-linux-gnueabi-size    </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> strip：剥掉目标文件的所有的符号信息</span></span><br><span class="line">arm-none-linux-gnueabi-strip</span><br></pre></td></tr></table></figure><h1 id="C调用C-库和C-调用C库的方法"><a href="#C调用C-库和C-调用C库的方法" class="headerlink" title="C调用C++库和C++调用C库的方法"></a>C调用C++库和C++调用C库的方法</h1><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW9zdW5yaXNlL2FydGljbGUvZGV0YWlscy84MTE3Njg4MA==" title="https://blog.csdn.net/shaosunrise/article/details/81176880">C调用C++库和C++调用C库的方法<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="C-调用C的静态库-动态库"><a href="#C-调用C的静态库-动态库" class="headerlink" title="C++调用C的静态库/动态库"></a>C++调用C的静态库/动态库</h2><p>C++ 调用 C 的函数比较简单，直接使用 <code>extern &quot;C&quot; {}</code> 告诉编译器用 C 的规则去调用 C 函数就可以了。</p><p><strong>CAdd.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>CAdd.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CAdd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"from C function.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译libCAdd.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c CAdd.c           # 生成CAdd.o</span><br><span class="line">ar -r libCAdd.a CAdd.o  # 归档生成libCAdd.a</span><br></pre></td></tr></table></figure><p><strong>编译动态库 libCAdd.so</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libCAdd.so CAdd.c</span><br></pre></td></tr></table></figure><p><strong>cppmain.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CAdd.h"</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = cadd(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1+2 = %d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译main</strong></p><p><code>-l</code> 指定库名称，优先链接so动态库，没有动态库再链接 <code>.a</code> 静态库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o cppmain cppmain.cpp -L. -lCAdd</span><br></pre></td></tr></table></figure><p><strong>运行</strong> </p><p>如果链接的是静态库就可以直接运行了，如果链接的是动态库可能会提示 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cppmain: error while loading shared libraries: libCAdd.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>是因为Linux系统程序和Windows不一样，Linux系统只会从系统环境变量指定的路径加载动态库，可以把生成的动态库放到系统目录，或者执行 <code>export LD_LIBRARY_PATH=./</code> 设置当前路径为系统链接库目录就可以了。</p><p>*<em>注释 *</em></p><p>这里是在 include 头文件的外面包裹了 <code>extern &quot;C&quot; { }</code>，是告诉编译器以 C 语言的命名方式去加载这个符号。还有一种比较常见的方式是在头文件中进行编译声明，如下所示，这样的话，无论 C 还是 C++ 直接正常include就可以使用了。</p><p><strong>CAdd.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C-调用-C-的静态库"><a href="#C-调用-C-的静态库" class="headerlink" title="C 调用 C++ 的静态库"></a>C 调用 C++ 的静态库</h2><p>C 语言没法直接调用 C++ 的函数，<strong>但可以使用包裹函数来实现</strong>。C++ 文件 <code>.cpp</code> 中可以调用 C 和 C++ 的函数，但是 C 代码 <code>.c</code> 只能调用 C 的函数，所以可以用包裹函数去包裹C ++ 函数，然后把这个包裹函数以 C 的规则进行编译，这样 C 就可以调用这个包裹函数了。</p><p><strong>CppAdd.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>CppAdd.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAdd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from C++ function.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译静态库 libCppAdd.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c CppAdd.cpp</span><br><span class="line">ar -r libCppAdd.a CppAdd.o</span><br></pre></td></tr></table></figure><p><strong>CppAddWrapper.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppaddwrapper</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>CppAddWrapper.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAddWrapper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAdd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppaddwrapper</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from wrapper.\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = cppadd(x, y);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译 wrapper 静态库 libCppAddWrapper.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c CppAddWrapper.cpp</span><br><span class="line">ar -r libCppAddWrapper.a CppAddWrapper.o</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAddWrapper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = cppaddwrapper(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"1+2 = %d\n"</span>, sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译 main，同时指定 libCppAdd.a 和 libCppAddWrapper.a。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -L. -lCppAddWrapper -lCppAdd</span><br></pre></td></tr></table></figure><p>或者把 libCppAdd.a 合并到 libCppAddWrapper.a 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ar -x libCppAdd.a         # 提取CppAdd.o</span><br><span class="line">ar -x libCppAddWrapper.a  # 提取CppAddWrapper.o</span><br><span class="line">ar -r libCppAddWrapper.a CppAdd.o CppAddWrapper.o # 打包libCppAddWrapper.a</span><br><span class="line">gcc -o main main.c -L. -lCppAddWrapper  # 只需要连接libCppAddWrapper.a即可</span><br></pre></td></tr></table></figure><p>如果是 C 调用 C++ 的 so 动态库的话，类似于调用静态库的方法应该也是有效的，太麻烦我没试过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>C/C++ 函数符号的区别</strong></p><p>C++ 可以兼容 C 的语法，C/C++ 主要的区别是编译函数符号规则不一样，C 语言代码编译后的函数名还是原来函数名，C++ 代码编译后的函数名带有参数信息。 </p><p>做个测试来检验一下。一个简单的函数，分别用 C 和 C++ 进行编译。 </p><p><strong>hello1.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hello2.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello1.c     # 生成hello1.o</span><br><span class="line">g++ -c hello1.cpp   # 生成hello2.o</span><br></pre></td></tr></table></figure><p><strong>查看符号表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nm hello1.o</span></span><br><span class="line">0000000000000000 T test</span><br><span class="line"><span class="meta">$</span><span class="bash"> nm hello2.o</span></span><br><span class="line">0000000000000000 T _Z4testiPc</span><br></pre></td></tr></table></figure><p>从上面信息可以看出，C 语言编译后的函数符号还是原函数名，而 C++ 编译后的函数符号由test变成了 <code>_Z4testiPc</code>，从这个符号名字可以看出 test 前面有个数字 4 应该是函数名长度，test 后面 <code>iPc</code> 应该就是函数的参数签名。C++ 之所以这样规定编译后的函数符号是因为对面对象的 C++ 具有函数重载功能，以此来区分不同的函数。</p><p><strong>.so 动态库、.a 静态库和 .o 中间文件的关系</strong></p><p>程序的运行都要经过<strong>编译和链接</strong>两个步骤。假如有文件 <code>add.c</code>，可以使用命令 <code>gcc -c add.c</code> 进行编译，生成 add.o 中间文件，使用命令 <code>ar -r libadd.a add.o</code> 可以生成 <code>libadd.a</code> 静态库文件。静态库文件其实就是对 <code>.o</code> 中间文件进行的封装，使用 <code>nm libadd.a</code> 命令可以查看其中封装的中间文件以及函数符号。 </p><p>链接静态库就是链接静态库中的 <code>.o</code> 文件，这和直接编译多个文件再链接成可执行文件一样。 </p><p>动态链接库是程序执行的时候直接调用的“插件”，使用命令 <code>gcc -shared -o libadd.so add.c</code> 生成 so 动态库。动态库链接的时候可以像静态库一样链接，告诉编译器函数的定义在这个静态库中（避免找不到函数定义的错误），只是不把这个 so 打包到可执行文件中。如果没有头文件的话，可以使用 <code>dlopen/dlsum</code> 函数手动去加载相应的动态库。详细做法参考上一篇文章《<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW9zdW5yaXNlL2FydGljbGUvZGV0YWlscy84MTE2MTA2NA==" title="https://blog.csdn.net/shaosunrise/article/details/81161064">C语言调用so动态库的两种方式<i class="fa fa-external-link"></i></span>》。</p><h1 id="ar-nm-命令的详细解释"><a href="#ar-nm-命令的详细解释" class="headerlink" title="ar nm 命令的详细解释"></a>ar nm 命令的详细解释</h1><p>功能说明：建立或修改备存文件，或是从备存文件中抽取文件。</p><p>语　　法：<code>ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件]</code></p><p>补充说明：ar 可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p><p>参　　数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指令参数</span></span><br><span class="line">　-d 　删除备存文件中的成员文件。</span><br><span class="line">　-m 　变更成员文件在备存文件中的次序。</span><br><span class="line">　-p 　显示备存文件中的成员文件内容。</span><br><span class="line">　-q 　将问家附加在备存文件末端。</span><br><span class="line">　-r 　将文件插入备存文件中。</span><br><span class="line">　-t 　显示备存文件中所包含的文件。</span><br><span class="line">　-x 　自备存文件中取出成员文件。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项参数</span></span><br><span class="line">　a&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之后。</span><br><span class="line">　b&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</span><br><span class="line">　c 　建立备存文件。</span><br><span class="line">　f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。</span><br><span class="line">　i&lt;成员文件&gt; 　将问家插入备存文件中指定的成员文件之前。</span><br><span class="line">　o 　保留备存文件中文件的日期。</span><br><span class="line">　s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。</span><br><span class="line">　S 　不产生符号表。</span><br><span class="line">　u 　只将日期较新文件插入备存文件中。</span><br><span class="line">　v 　程序执行时显示详细的信息。</span><br><span class="line">　V 　显示版本信息。</span><br></pre></td></tr></table></figure><h2 id="ar基本用法"><a href="#ar基本用法" class="headerlink" title="ar基本用法"></a>ar基本用法</h2><p>ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。</p><p>下面是ar命令的格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ar [-]&#123;dmpqrtx&#125;[abcfilNoPsSuvV][membername] [count] archive files...</span></span><br></pre></td></tr></table></figure><p>例如我们可以用<strong>ar rv libtest.a hello.o hello1.o</strong>来生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-‘字符，也可以没有。下面我们来看看命令的操作选项<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q9JUU1JTkyJThDJUU0JUJCJUJCJnRuPTI0MDA0NDY5X29lbV9kZyZyc3ZfZGw9Z2hfcGxfc2xfY3Nk" title="https://www.baidu.com/s?wd=%E5%92%8C%E4%BB%BB&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">和任<i class="fa fa-external-link"></i></span>选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。</p><p>{dmpqrtx} 中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：</p><ul><li>d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。</li><li>m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用’a’，’b’，或’I’任选项移动到指定的位置。</li><li>p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。</li><li>q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。’a’，’b’，或’I’任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用’ar s’或ranlib来更新库的符号表索引。</li><li>r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。</li><li>t：显示库的模块表清单。一般只显示模块名。</li><li>x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。</li></ul><p>　　下面在看看可与操作选项结合使用的任选项：</p><ul><li>a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。</li><li>b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。</li><li>c：创建一个库。不管库是否存在，都将创建。</li><li>f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。</li><li>i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。</li><li>l：暂未使用</li><li>N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。</li><li>o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。</li><li>P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。</li><li>s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。</li><li>S：不创建目标文件索引，这在创建较大的库时能加快时间。</li><li>u：一般说来，命令ar r…插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。</li><li>v：该选项用来显示执行操作选项的附加信息。</li><li>V：显示ar的版本。</li></ul><h2 id="nm基本用法命令"><a href="#nm基本用法命令" class="headerlink" title="nm基本用法命令"></a>nm基本用法命令</h2><p>nm用来列出目标文件的符号清单。下面是nm命令的格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [-a|--debug-syms][-g|--extern-only] [-B][-C|--demangle] [-D|--dynamic][-s|--print-armap][-o|--print-file-name][-n|--numeric-sort][-p|--no-sort][-r|--reverse-sort] [--size-sort][-u|--undefined-only] [-l|--line-numbers][--help][--version][-t radix|--radix=radix][-P|--portability][-f format|--format=format][--target=bfdname][objfile...]</span><br></pre></td></tr></table></figure><p>如果没有为 nm 命令指出目标文件，则 nm 假定目标文件是a.out。下面列出该命令的任选项，大部分支持”-“开头的短格式和”—“开头的长格式。</p><ul><li><p>-A、-o或–print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。</p><p>例如nm libtest.a的输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CPThread.o:</span><br><span class="line">00000068 T Main__8CPThreadPv</span><br><span class="line">00000038 T Start__8CPThread</span><br><span class="line">00000014 T _._8CPThread</span><br><span class="line">00000000 T __8CPThread</span><br><span class="line">00000000 ? __FRAME_BEGIN__</span><br><span class="line">.......................................</span><br><span class="line"><span class="meta">#</span><span class="bash"> 则nm -A 的输出如下：</span></span><br><span class="line">libtest.a:CPThread.o:00000068 T Main__8CPThreadPv</span><br><span class="line">libtest.a:CPThread.o:00000038 T Start__8CPThread</span><br><span class="line">libtest.a:CPThread.o:00000014 T _._8CPThread</span><br><span class="line">libtest.a:CPThread.o:00000000 T __8CPThread</span><br><span class="line">libtest.a:CPThread.o:00000000 ? __FRAME_BEGIN__</span><br><span class="line">..................................................................</span><br></pre></td></tr></table></figure></li><li><p>-a或–debug-syms：显示调试符号。</p></li><li><p>-B：等同于–format=bsd，用来兼容MIPS的nm。</p></li><li><p>-C或–demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</p></li><li><p>-D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</p></li><li><p>-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。</p></li><li><p>-g或–extern-only：仅显示外部符号。</p></li><li><p>-n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。</p></li><li><p>-p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。</p></li><li><p>-P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。</p></li><li><p>-s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。</p></li><li><p>-r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。</p></li><li><p>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。</p></li><li><p>-t radix或–radix=radix：使用radix进制显示符号值。radix只能为”d”表示十进制、”o”表示八进制或”x”表示十六进制。</p></li><li><p>–target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。</p></li><li><p>-u或–undefined-only：仅显示没有定义的符号(那些外部符号)。</p></li><li><p>-l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。</p></li><li><p>-V或–version：显示nm的版本号。</p></li><li><p>–help：显示nm的任选项。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;img src=&quot;/images/imageProgramC/03_C语言概述.png&quot;&gt;

&lt;h1 id=&quot;建立ARM交叉编译环境arm-none-linux-gnueabi-gcc&quot;&gt;&lt;a href=&quot;#建立ARM交叉编译环境arm-n
      
    
    </summary>
    
      <category term="Program-C" scheme="http://miaopei.github.io/categories/Program-C/"/>
    
    
      <category term="Program-C" scheme="http://miaopei.github.io/tags/Program-C/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程</title>
    <link href="http://miaopei.github.io/2016/05/01/Program-C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://miaopei.github.io/2016/05/01/Program-C/Linux系统编程基础/</id>
    <published>2016-05-01T02:14:50.000Z</published>
    <updated>2019-06-10T08:15:45.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-Note"><a href="#Linux-Note" class="headerlink" title="Linux Note"></a>Linux Note</h1><blockquote><h3 id="C-语言之解析局部变量返回"><a href="#C-语言之解析局部变量返回" class="headerlink" title="C 语言之解析局部变量返回"></a>C 语言之解析局部变量返回</h3><p>一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。</p><p>准确的来说，<strong>函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)</strong>。</p></blockquote><a id="more"></a><h2 id="1-Linux-基础命令"><a href="#1-Linux-基础命令" class="headerlink" title="1. Linux 基础命令"></a>1. Linux 基础命令</h2><blockquote><p><strong>stat命令</strong>用于显示文件的状态信息。stat命令的输出信息比 <span class="exturl" data-url="aHR0cDovL21hbi5saW51eGRlLm5ldC9scw==" title="http://man.linuxde.net/ls">ls<i class="fa fa-external-link"></i></span> 命令的输出信息要更详细。</p></blockquote><h3 id="1-0-创建用户"><a href="#1-0-创建用户" class="headerlink" title="1.0 创建用户"></a>1.0 创建用户</h3><p><strong>创建用户命令两条</strong>：</p><ul><li><p>adduser</p></li><li><p>useradd</p></li></ul><p><strong>用户删除命令</strong>：</p><ul><li>userdel</li></ul><p><strong>两个用户创建命令之间的区别</strong>：</p><ul><li><p>adduser： 会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。</p></li><li><p>useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 adduser</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adduser apple</span></span><br><span class="line">正在添加用户"apple"...</span><br><span class="line">正在添加新组"apple" (1007)...</span><br><span class="line">正在添加新用户"apple" (1007) 到组"apple"...</span><br><span class="line">创建主目录"/home/apple"...</span><br><span class="line">正在从"/etc/skel"复制文件...</span><br><span class="line">输入新的 UNIX 密码： </span><br><span class="line">重新输入新的 UNIX 密码： </span><br><span class="line">passwd：已成功更新密码</span><br><span class="line">正在改变 apple 的用户信息</span><br><span class="line">请输入新值，或直接敲回车键以使用默认值</span><br><span class="line">        全名 []: </span><br><span class="line">        房间号码 []: </span><br><span class="line">        工作电话 []: </span><br><span class="line">        家庭电话 []: </span><br><span class="line">        其它 []: </span><br><span class="line">这些信息是否正确？ [Y/n] y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样在创建用户名时，就创建了用户的主目录以及密码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> adduser在创建用户时会主动调用  /etc/adduser.conf；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在创建用户主目录时默认在/home下，而且创建为 /home/用户名   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果主目录已经存在，就不再创建，但是此主目录虽然作为新用户的主目录，而且默认登录时会进入这个目录下，但是这个目录并不是属于新用户，当使用userdel删除新用户时，并不会删除这个主目录，因为这个主目录在创建前已经存在且并不属于这个用户。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为用户指定shell版本为：/bin/bash</span></span><br></pre></td></tr></table></figure><p>因此 adduser 常用参数选项为：</p><ul><li><p><code>--home</code>：  指定创建主目录的路径，默认是在/home目录下创建用户名同名的目录，这里可以指定；如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。</p></li><li><p><code>--quiet</code>：  即只打印警告和错误信息，忽略其他信息。</p></li><li><p><code>--debug</code>：  定位错误信息。</p></li><li><p><code>--conf</code>：   在创建用户时使用指定的configuration文件。</p></li><li><p><code>--force-badname</code>：  默认在创建用户时会进行/etc/adduser.conf中的正则表达式检查用户名是否合法，如果想使用弱检查，则使用这个选项，如果不想检查，可以将/etc/adduser.conf中相关选项屏蔽。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 useradd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意： 在使用useradd命令创建新用户时，不会为用户创建主目录，不会为用户指定shell版本，不会为用户创建密码。</span></span><br></pre></td></tr></table></figure><p>为用户指定参数的 useradd 命令，常用命令行选项：</p><ul><li><p><code>-d</code>：   指定用户的主目录</p></li><li><p><code>-m</code>：   如果存在不再创建，但是此目录并不属于新创建用户；如果主目录不存在，则强制创建； -m和-d一块使用。</p></li><li><p><code>-s</code>：   指定用户登录时的shell版本</p></li><li><p><code>-M</code>：   不创建主目录</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解释：   </span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -d   “/home/tt<span class="string">" ：就是指定/home/tt为主目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -m   就是如果/home/tt不存在就强制创建</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -s   就是指定shell版本           </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo  useradd  -d  <span class="string">"/home/tt"</span>  -m   -s <span class="string">"/bin/bash"</span>   tt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 tt 密码：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo passwd tt</span></span><br></pre></td></tr></table></figure><p><strong>删除用户命令</strong></p><ul><li><p>userdel</p></li><li><p>只删除用户：</p><ul><li><code>sudo   userdel   用户名</code></li></ul></li><li><p>连同用户主目录一块删除：</p><ul><li><code>sudo  userdel   -r   用户名</code></li></ul></li></ul><p><strong>相关文件</strong>：</p><ul><li>/etc/passwd - 使 用 者 帐 号 资 讯，可以查看用户信息</li><li>/etc/shadow - 使 用 者 帐 号 资 讯 加 密</li><li>/etc/group - 群 组 资 讯</li><li>/etc/default/useradd - 定 义 资 讯</li><li>/etc/login.defs - 系 统 广 义 设 定</li><li>/etc/skel - 内 含 定 义 档 的 目 录</li></ul><p><strong>为组用户增加 root 权限</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改 /etc/sudoers 文件，找到下面一行，在 root 下面添加一行，如下所示：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line">tommy   ALL=(ALL)     ALL</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改完毕，现在可以用 tommy 帐号登录，然后用命令 sudo – ，即可获得 root 权限进行操作。</span></span><br></pre></td></tr></table></figure><h3 id="1-1-ln-软硬链接"><a href="#1-1-ln-软硬链接" class="headerlink" title="1.1 ln 软硬链接"></a>1.1 ln 软硬链接</h3><p><strong>硬链接</strong></p><p>硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。可以用: ln 命令来建立硬链接。</p><p>尽管硬链接节省空间，也是Linux系统整合文件系统的传统方式，但是存在一下不足之处：</p><ul><li><p>（1）不可以在不同文件系统的文件间建立链接</p></li><li><p>（2）只有超级用户才可以为目录创建硬链接。</p></li></ul><p><strong>软链接（符号链接）</strong></p><p>软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。<br>建立软链接，只要在 ln 后面加上选项  –s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ln -s abc cde <span class="comment"># 建立 abc 的软连接</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln abc cde <span class="comment"># 建立 abc 的硬连接，</span></span></span><br></pre></td></tr></table></figure><p><strong>删除链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf symbolic_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> unlink symbolic_name</span></span><br></pre></td></tr></table></figure><h3 id="1-2-find-grep-xargs"><a href="#1-2-find-grep-xargs" class="headerlink" title="1.2 find grep xargs"></a>1.2 find grep xargs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前目录及子目录下所有文件和文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在/home目录下查找以.txt结尾的文件名 但忽略大小写</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /home -iname <span class="string">"*.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . \( -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span> \)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 匹配文件路径或者文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /usr/ -path <span class="string">"*local*"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于正则表达式匹配文件路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -regex <span class="string">".*\(\.txt\|\.pdf\)$"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，但忽略大小写</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -iregex <span class="string">".*\(\.txt\|\.pdf\)$"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出/home下 不是 以 .txt 结尾的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /home ! -name <span class="string">"*.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件类型进行搜索</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 类型参数列表：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  f 普通文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  l 符号连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  d 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  c 字符设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  b 块设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  s 套接字</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  p Fifo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> 类型参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于目录深度搜索 向下最大深度限制为3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -maxdepth 3 -<span class="built_in">type</span> f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索出深度距离当前目录至少2个子目录的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -mindepth 2 -<span class="built_in">type</span> f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件时间戳进行搜索</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UNIX/Linux文件系统每个文件都有三种时间戳：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索最近七天内被访问过的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -atime -7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索恰好在七天前被访问过的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -atime 7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索超过七天内被访问过的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -atime +7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索访问时间超过10分钟的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -amin +10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出比 file.log 修改时间更长的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -newer file.log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件大小进行匹配</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件大小单元：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  b —— 块（512字节）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  c —— 字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  w —— 字（2字节）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  k —— 千字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  M —— 兆字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  G —— 吉字节</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size 文件大小单元</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索大于10KB的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size +10k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索小于10KB的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size -10k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索等于10KB的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size 10k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除匹配文件 删除当前目录下所有.txt文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -delete</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件权限/所有权进行匹配 当前目录下搜索出权限为777的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -perm 777</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录下权限不是644的php文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.php"</span> ! -perm 644</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录用户tom拥有的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -user tom</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录用户组sunk拥有的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -group sunk</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 借助-<span class="built_in">exec</span>选项与其他命令结合使用 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录下所有root的文件，并把所有权更改为用户tom</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;&#125; 用于与 -<span class="built_in">exec</span> 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find .-<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> chown tom &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出自己家目录下所有的.txt文件并删除</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ok 和 -<span class="built_in">exec</span> 行为一样，不过它会给出提示，是否执行相应的操作。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find <span class="variable">$HOME</span>/. -name <span class="string">"*.txt"</span> -ok rm &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> cat &#123;&#125; \;&gt; all.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将30天前的.<span class="built_in">log</span>文件移动到old目录中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -mtime +30 -name <span class="string">"*.log"</span> -<span class="built_in">exec</span> cp &#123;&#125; old \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录下所有.txt文件并以 “File:文件名” 的形式打印出来</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> <span class="built_in">printf</span> <span class="string">"File: %s\n"</span> &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为单行命令中 -<span class="built_in">exec</span> 参数中无法使用多个命令，以下方法可以实现在 -<span class="built_in">exec</span> 之后接受多条命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -<span class="built_in">exec</span> ./text.sh &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索但跳出指定的目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -path <span class="string">"./sk"</span> -prune -o -name <span class="string">"*.txt"</span> -<span class="built_in">print</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> find其他技巧收集</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要列出所有长度为零的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -empty</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -<span class="built_in">exec</span> 接收 find 传过来的所有内容，容易造成溢出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xargs find 的好伴侣，xargs 将 find 命令查找的结果分成若干模块输出给后面的指令</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> grep 内容过滤</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep match_pattern file_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"match_pattern"</span> file_name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出除之外的所有行 -v 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -v <span class="string">"match_pattern"</span> file_name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 标记匹配颜色 --color=auto 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"match_pattern"</span> file_name --color=auto</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用正则表达式 -E 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -E <span class="string">"[1-9]+"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> egrep <span class="string">"[1-9]+"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只输出文件中匹配到的部分 -o 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a <span class="built_in">test</span> line. | grep -o -E <span class="string">"[a-z]+\."</span></span></span><br><span class="line">line.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a <span class="built_in">test</span> line. | egrep -o <span class="string">"[a-z]+\."</span></span></span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计文件或者文本中包含匹配字符串的行数 -c 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -c <span class="string">"text"</span> file_name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出包含匹配字符串的行数 -n 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"text"</span> -n file_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file_name | grep <span class="string">"text"</span> -n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索多个文件并查找匹配文本在哪些文件中：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -l <span class="string">"text"</span> file1 file2 file3...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在多级目录中对文本进行递归搜索：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"text"</span> . -r -n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 忽略匹配样式中的字符大小写：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span> | grep -i <span class="string">"HELLO"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项 -e 制动多个匹配样式：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a text line | grep -e <span class="string">"is"</span> -e <span class="string">"line"</span> -o</span></span><br><span class="line">is</span><br><span class="line">line</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。</span></span><br><span class="line">cat patfile</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> aaa bbb ccc ddd eee | grep -f patfile -o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在grep搜索结果中包括或者排除指定文件：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只在目录中所有的.php和.html文件中递归搜索字符<span class="string">"main()"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"main()"</span> . -r --include *.&#123;php,html&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在搜索结果中排除所有README文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"main()"</span> . -r --exclude <span class="string">"README"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在搜索结果中排除filelist文件列表里的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"main()"</span> . -r --exclude-from filelist</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用0值字节后缀的grep与xargs：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"aaa"</span> &gt; file1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"bbb"</span> &gt; file2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"aaa"</span> &gt; file3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"aaa"</span> file* -lZ | xargs -0 rm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后会删除 file1 和 file3，grep 输出用 -Z 选项来指定以 0 值字节作为终结符文件名（\0），xargs -0 读取输入并用 0 值字节终结符分隔文件名，然后删除匹配文件，-Z 通常和 -l 结合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> grep静默输出：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -q <span class="string">"test"</span> filename</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印出匹配文本之前或者之后的行：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配某个结果 之后的3行，使用 -A 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">"5"</span> -A 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配某个结果 之前的3行，使用 -B 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">"5"</span> -B 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配某个结果的 前三行和后三行，使用 -C 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">"5"</span> -C 3</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> xargs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数：</span></span><br><span class="line">-a file 从文件中读入作为sdtin</span><br><span class="line">-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</span><br><span class="line">-p 当每次执行一个argument的时候询问一次用户。</span><br><span class="line">-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</span><br><span class="line">-t 表示先打印命令，然后再执行。</span><br><span class="line">-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 &#123;&#125;，可以用 &#123;&#125; 代替。</span><br><span class="line">-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</span><br><span class="line">-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</span><br><span class="line">-L num 从标准输入一次读取 num 行送给 command 命令。</span><br><span class="line">-l 同 -L。</span><br><span class="line">-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</span><br><span class="line">-x exit的意思，主要是配合-s使用。。</span><br><span class="line">-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</span><br></pre></td></tr></table></figure><h3 id="1-3-VIM"><a href="#1-3-VIM" class="headerlink" title="1.3 VIM"></a>1.3 VIM</h3><p>设置 ~/.bashrc</p><p>添加 set -o vi     – 可以直接使用 vim 的各种快捷键</p><p>VIM 快捷键：</p><img src="/images/imageProgramC/vim.gif"><h3 id="1-4-GCC"><a href="#1-4-GCC" class="headerlink" title="1.4 GCC"></a>1.4 GCC</h3><p>gcc 工作流程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 预处理 头文件展开 宏替换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -E hello.c</span></span><br><span class="line">hello.i</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成汇编代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -S hello.i</span></span><br><span class="line">hello.s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将汇编编译成二进制文件 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hell0.s</span></span><br><span class="line">hello.o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc hello.o</span></span><br><span class="line">a.out</span><br></pre></td></tr></table></figure><p>gcc 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定编译输出的名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 -Wall 参数启用所有警告</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -E 参数只产生预处理输出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -E main.c &gt; main.i</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -S 参数只产生汇编代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -S main.c &gt; main.s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -C 参数只产生编译的代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -C main.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面的代码产生main.o, 包含机器级别的代码或者编译的代码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用-save-temps参数产生所有的中间步骤的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -save-temps main.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">a.out  main.c  main.i  main.o  main.s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -l 参数链接共享库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc  -Wall main.c -o main -lCPPfile</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -fPIC 产生位置无关的代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当产生共享库的时候，应该创建位置无关的代码，这会让共享库使用任意的地址而不是固定的地址，要实现这个功能，需要使用-fPIC参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面的例子产生libCfile.so动态库。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c -Wall -Werror -fPIC Cfile.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -o libCfile.so Cfile.o</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 产生共享库的时候使用了-fPIC 参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意 -shared 产生共享库。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -V 打印所有的执行命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -v main.c -o main</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/4.6/lto-wrapper</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -D 参数可以使用编译时的宏</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -D MY_MACRO main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -Werror 将警告升级为错误</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -Werror main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 @ 参数从文件中读取参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc参数可以从文件中读取，通过@后跟文件名的方式提供， 多个参数可以使用空格区隔。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat opt_file </span></span><br><span class="line">-Wall -omain</span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c @opt_file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用参数 -I 指定头文件的文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -I/home/codeman/include input-file.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I 取消前一个参数功能，一般用在 -Idir 之后。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用参数-std指定支持的c++/c的标准</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -std=c++11 hello-world.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -static 生成静态链接的文件 静态编译文件(把动态库的函数和其它依赖都编译进最终文件)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -static -o main -lpthread</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相反的使用 -shared 使用动态库链接。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -g 用于 gdb 调试</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -static -o main -g</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -lstdc++ 指定 gcc 以 c++ 方式编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.cpp -lstdc++ -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -O 优化选项， 1-3 越高优先级越高</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.cpp -lstdc++ -o main -O1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -M 生成文件关联的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -M main.c</span></span><br><span class="line">main.o: main.c /usr/include/stdc-predef.h /usr/include/stdio.h \</span><br><span class="line"> /usr/include/features.h /usr/include/sys/cdefs.h \</span><br><span class="line"> /usr/include/bits/wordsize.h /usr/include/gnu/stubs.h \</span><br><span class="line"> /usr/include/gnu/stubs-64.h \</span><br><span class="line"> /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h \</span><br><span class="line"> /usr/include/bits/types.h /usr/include/bits/typesizes.h \</span><br><span class="line"> /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \</span><br><span class="line"> /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdarg.h \</span><br><span class="line"> /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h</span><br></pre></td></tr></table></figure><h3 id="1-5-库文件制作"><a href="#1-5-库文件制作" class="headerlink" title="1.5 库文件制作"></a>1.5 库文件制作</h3><p><strong>静态库制作和使用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 步骤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 编译为 .o 文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将 .o 文件打包：ar rcs libmycalc.a file1.0 file2.o ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 将头文件与库一起发布</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看库信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nm libmycalc.a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译时 需要加静态库名（记得路径），-I 包含头文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -o app -I include/ -L lib/ -lmycalc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 优点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行快</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 发布应用时不需要发布库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缺点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行程序体积比较大</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 库变更时需要重新编译应用</span></span><br></pre></td></tr></table></figure><p><strong>动态库制作和使用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 步骤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 编译与位置无关的代码，生成 .o 关键参数 -fPIC</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将 .o 文件打包， 关键参数 -shared</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 将库与头文件一起发布</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -o libcalc.so *.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -L 指定动态库路径 -I 指定库名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -o app -I include/ -L lib/ -lcalc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ldd 查看库依赖</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd libcalc.so</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 优点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行程序体积小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 库变更时，一般不需要重新发布动态库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缺点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行时需要加载动态库，相对而言，比静态库慢</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 发布应用时需要同时发布动态库</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决不能加载动态库的问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 拷贝到 /lib 下。 一般不允许</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将库路径增加到环境变量 LD_LIBRARY_PATH 中，不是特别推荐</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 配置 /etc/ld.so.conf 文件，增加 当前项目库路径，执行 sudo ldconfig -v</span></span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/数据段.png"><h3 id="1-6-Makefile"><a href="#1-6-Makefile" class="headerlink" title="1.6 Makefile"></a>1.6 Makefile</h3><p>makefile 的三要素：</p><ul><li>目标</li><li>依赖</li><li>规则命令</li></ul><p>写法：</p><ul><li>目标：依赖</li><li>tab键 规则命令</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app: main.c add.c sub.c div.c mul.c</span></span><br><span class="line">gcc -o app -I./<span class="keyword">include</span>/ main.c add.c sub.c div.c mul.c</span><br></pre></td></tr></table></figure><p>如果更改其中一个文件，所有的源码都重新编译</p><p>可以考虑编译过程分解，先生成 .o 文件，然后使用 .o 文件编程结果</p><p>规则是递归的，依赖文件如果比目标文件新，则重新生成目标文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ObjFiles=main.o add.o sub.o div.o mul.o</span><br><span class="line">app: $(ObjFiles)</span><br><span class="line">gcc -o app -I./include/ $(ObjFiles)</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">gcc -c main.c -I./include/</span><br><span class="line">add.o: add.c</span><br><span class="line">gcc -c add.c -I./include/</span><br><span class="line">sub.o: sub.c</span><br><span class="line">gcc -c sub.c -I./include/</span><br><span class="line">div.o: div.c</span><br><span class="line">gcc -c div.c -I./include/</span><br><span class="line">mul.o: mul.c</span><br><span class="line">gcc -c mul.c -I./include/</span><br></pre></td></tr></table></figure><p>makefile 的隐含规则：默认处理第一个目标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> get all .c files</span></span><br><span class="line">SrcFiles=$(wildcard *.c)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> all .c files --&gt; .o file</span></span><br><span class="line">ObjFiles=$(patsubst %.c,%.o,$(SrcFiles))</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">echo $(SrcFiles)</span><br><span class="line">echo $(ObjFiles)</span><br></pre></td></tr></table></figure><p>makefile 变量：</p><ul><li>$@    代表目标</li><li>$^    代表全部依赖</li><li>$&lt;    第一个依赖</li><li>$?    第一个变化的依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> get all .c files</span></span><br><span class="line">SrcFiles=$(wildcard *.c)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> all .c files --&gt; .o file</span></span><br><span class="line">ObjFiles=$(patsubst %.c,%.o,$(SrcFiles))</span><br><span class="line"></span><br><span class="line">all:app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目标文件用法 $(Var)</span></span><br><span class="line">app: $(ObjFiles)</span><br><span class="line">gcc -o $@ -I./include/ $(ObjFiles)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模式匹配规则， <span class="variable">$@</span> $&lt; 这样的变量，只能在规则中出现</span></span><br><span class="line"><span class="meta">%</span><span class="bash">.o:%.c</span></span><br><span class="line">gcc -c $&lt; -I./include/ -o $@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> @ 在规则前代表不输出该条规则的命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 规则前的“-”，代表该条规则报错，仍然继续执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .PHONY 定义伪目标，防止有歧义</span></span><br><span class="line">.PHONY:clean all</span><br><span class="line">clean:</span><br><span class="line">-@rm -f *.o</span><br><span class="line">-@rm -f app</span><br></pre></td></tr></table></figure><p>make -f makefile1    指定makefile文件进行编译</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SrcFiles=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">TargetFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(TargetFiles)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">%:%.c</span></span><br><span class="line">gcc -o <span class="variable">$@</span> %^</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f <span class="variable">$(TargetFiles)</span></span><br></pre></td></tr></table></figure><h3 id="1-7-gdb-调试"><a href="#1-7-gdb-调试" class="headerlink" title="1.7 gdb 调试"></a>1.7 gdb 调试</h3><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMTA3NzU5Lw==" title="http://blog.jobbole.com/107759/">gdb 调试入门，大牛写的高质量指南<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eHRvb2xzLXJzdC5yZWFkdGhlZG9jcy5pby96aF9DTi9sYXRlc3QvdG9vbC9nZGIuaHRtbA==" title="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">gdb 调试利器<i class="fa fa-external-link"></i></span></p></blockquote><p>启动gdb：gdb app</p><p>在gdb启动程序：</p><ul><li>r(un)   – 启动  可以带参数启动</li><li>start   – 启动 - 停留在main函数，分步调试</li><li>n(ent)   – 下一条指令</li><li>s(tep)  – 下一条指令，可以进入函数内部，库函数不能进</li><li>q(uit)   – 退出 gdb</li><li>b(reak)  num  – 指定行号，函数, 文件:行号  设置断点<ul><li>b 行号  – 主函数所在文件的行</li><li>b 函数名</li><li>b 文件名:行号</li></ul></li><li>l(ist) 文件：行号   – 查看代码<ul><li>l – 显示主函数对应的文件</li><li>l 文件名:行号</li></ul></li><li>info b   – 查看断点信息</li><li>d(el)  num – 删除断点</li><li>c – continue 跳到下一个断点</li><li>p(rint) – 打印参数，或者变量值</li><li>ptype 变量  – 查看变量类型</li><li>set  – 设置变量的值<ul><li>set argc=4</li><li>set argv[1]=“12”</li><li>set argv[2] = “7”</li></ul></li><li>display argc  –  跟踪显示参数或者变量的变化</li><li>info display</li><li>undisplay num</li><li>b num if xx == xx  – 条件断点</li></ul><p><strong>gdb跟踪core</strong></p><ul><li><p>设置生成 core ：ulimit -c unlimited</p></li><li><p>取消生成 core： ulimit -c 0</p></li><li><p>设置 core 文件格式：/proc/sys/kernel/core_pattern</p><p>文件不能 vi，可以用后面的套路：echo “/corefile/core-%e-%p-%t” &gt; core_pattern</p></li></ul><p>core 文件如何使用：</p><ul><li><p>gdb app core</p></li><li><p>如果看不到在哪儿core  可以用 where 查看在哪儿产生的 core</p></li></ul><h2 id="2-系统api与库函数的关系"><a href="#2-系统api与库函数的关系" class="headerlink" title="2. 系统api与库函数的关系"></a>2. 系统api与库函数的关系</h2><img src="/images/imageProgramC/系统api与函数关系.png"><h2 id="3-Linux-系统编程"><a href="#3-Linux-系统编程" class="headerlink" title="3. Linux 系统编程"></a>3. Linux 系统编程</h2><p>ulimit -a 查看所有资源的上限</p><p>env 查看环境变量</p><p>echo $PATH  打印指定的环境变量</p><p><code>char *getenv()</code> 获取环境变量</p><p><strong>创建一个进程</strong>：</p><p><code>pid_t fork(void)</code></p><p>返回值：</p><ul><li>失败 -1</li><li>成功，返回两次<ul><li>父进程返回子进程的 id</li><li>子进程返回 0</li></ul></li></ul><p>获得pid，进程 id，获得当前进程</p><p><code>pid_t getpid(void)</code></p><p>获得当前进程父进程的 id</p><p><code>pid_t getppid(void)</code></p><p>ps ajx 查看父进程和子进程相关信息</p><p><strong>进程共享</strong>：</p><p>父子进程之间在fork后，有哪些相同和不同：</p><ul><li>父子相同处：<ul><li>全局变量</li><li>data、text、栈、堆、环境变量</li><li>用户 ID</li><li>宿主目录、进程工作目录、信号处理方式…</li></ul></li><li>父子不同处：<ul><li>进程 ID</li><li>父进程 ID</li><li>进程运行时间</li><li>闹钟（定时器）</li><li>未决信号集</li></ul></li></ul><p>似乎，子进程复制了父进程 0-3G 用户空间内容，以及父进程的 PCB， 但 pid 不同。真的每 fork 一个子进程都要将父进程的 0-3G 地址空间完全拷贝一份，然后在映射至屋里内存吗？当然不是，父子进程间遵循<strong>读时共享写时复制</strong>。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p><p><strong>孤儿进程与僵尸进程</strong>：</p><ul><li>孤儿进程<ul><li>父进程死了，子进程被 init 进程领养</li></ul></li><li>僵尸进程<ul><li>子进程死了，父进程没有回收子进程的资源（PCB）</li></ul></li></ul><p>回收子进程，知道子进程的死亡原因，作用：</p><ul><li>阻塞等待</li><li>回收子进程资源</li><li>查看死亡原因</li></ul><p><code>pid_t wait(int *status)</code></p><ul><li>status 传出参数</li><li>返回值<ul><li>成功返回终止的子进程 ID</li><li>失败 返回 -1</li></ul></li></ul><p>子进程的死亡原因：</p><ul><li>正常死亡 WIFEXITED<ul><li>如果 WIFEXITED 为真，使用 WEXITSTATUS 得到退出的状态</li></ul></li><li>非正常死亡 WIFSIGNALED<ul><li>如果 WIFSIGNALED 为真，使用 WTERMSIG 得到信号</li></ul></li></ul><p><code>pid_t waitpid(pid_t pid, int *status, int options)</code></p><ul><li>pid<ul><li><code>&lt; -1</code> 组ID</li><li><code>-1</code> 回收任意</li><li><code>0</code> 回收和调用进程组 ID 相同组内的子进程</li><li><code>&gt;0</code> 回收指定的 pid</li></ul></li><li>option<ul><li>0 与 wait 相同，也会阻塞</li><li>WNOHANG 如果当前没有子进程退出，会立刻返回</li></ul></li><li>返回值<ul><li>如果设置了 WNOHANG ，那么如果没有子进程退出，返回 0<ul><li>如果有子进程退出返回退出的 pid</li></ul></li><li>失败返回 -1 （没有子进程）</li></ul></li></ul><h3 id="3-1-IPC-概念"><a href="#3-1-IPC-概念" class="headerlink" title="3.1 IPC 概念"></a>3.1 IPC 概念</h3><p>IPC ： 进程间通信，通过内核提供的缓存区进行数据交换的机制</p><p>IPC 通信的方式有几种：</p><ul><li>pipe 管道 – 最简单</li><li>fifo 有名管道</li><li>mmap 文件映射共享IO – 速度最快</li><li>本地 socket 最稳定</li><li>信号 携带信息量最小</li><li>共享内存</li><li>消息队列</li></ul><p><strong>读管道</strong>：</p><ul><li>写端全部关闭 – read 读到 0， 想当于读到文件末尾</li><li>写端没有全部关闭<ul><li>有数据 – read 读到数据</li><li>没有数据 – read 阻塞 fcntl 函数可以更改非阻塞</li></ul></li></ul><p><strong>写管道</strong>：</p><ul><li>读端全部关闭 – ？ 产生一个信号 SIGPIPE，程序异常终止</li><li>读端未全部关闭<ul><li>管道已满 – write 阻塞 – 如果要显示现象，读端一直不读，写端狂写。</li><li>管道未满 – write 正常写入</li></ul></li></ul><p><strong>管道缓冲区大小</strong></p><p>可以使用 <code>ulimit –a</code> 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe size            (512 bytes, -p) 8</span><br></pre></td></tr></table></figure><p>也可以使用 <code>fpathconf</code> 函数，借助参数选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p><p><code>long fpathconf(int fd, int name);</code>    </p><ul><li>成功：返回管道的大小    </li><li>失败：-1，设置errno</li></ul><p><strong>管道的优劣</strong></p><ul><li><p>优点：</p><ul><li>简单，相比信号，套接字实现进程间通信，简单很多。</li></ul></li><li><p>缺点：</p><ul><li>只能单向通信，双向通信需建立两个管道。</li><li>只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。</li></ul></li></ul><p><strong>FIFO通信</strong></p><p>FIFO 有名管道，实现无血缘关系进程通信</p><ul><li>创建一个管道的伪文件<ul><li>mkfifo myfifo 命令创建</li><li>也可以使用函数 <code>int mkfifo(const char *pathname,  mode_t mode);</code></li></ul></li><li>内核会针对 fifo 文件开辟一个缓存区，操作 fifo 文件，可以操作缓存区，实现进程间通信 – 实际上就是文件读写</li></ul><p><strong>mmap映射共享区</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *adrr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>返回：</p><ul><li>成功：返回创建的映射区首地址；</li><li><strong>失败：MAP_FAILED宏</strong></li></ul></li><li><p>参数：    </p><ul><li>addr:     建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</li><li>length：   欲创建映射区的大小</li><li>prot：       映射区权限 PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</li><li>flags：      标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)<ul><li>MAP_SHARED:  会将映射区所做的操作反映到物理设备（磁盘）上。（共享的）</li><li>MAP_PRIVATE:  映射区所做的修改不会反映到物理设备。（私有的）</li></ul></li><li>fd：      用来建立映射区的文件描述符</li><li>offset：   映射文件的偏移(4k的整数倍)</li></ul></li></ul><p>释放映射区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>匿名映射</strong></p><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。</p><p>使用 <code>MAP_ANONYMOUS</code>(或 <code>MAP_ANON</code> )， 如: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// "4"随意举例，该位置表大小，可依实际需要填写。</span></span><br></pre></td></tr></table></figure><p>需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/dev/zero 聚宝盆，可以随意映射</span></span><br><span class="line"><span class="comment">/dev/null 无底洞，一般错误信息重定向到这个文件中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fd = open(<span class="string">"/dev/zero"</span>, O_RDWR);</span><br><span class="line">p = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>信号的概念</strong></p><ul><li><p>信号的特点</p><ul><li>简单，不能带大量信息，满足特定条件发生</li></ul></li><li><p>信号的机制</p><ul><li>进程 B 发送给进程 A ，内核产生信号，内核处理</li></ul></li><li><p>信号的产生</p><ul><li>按键产生 </li><li>函数调用 kill、raise、abort</li><li>定时器 alarm、setitimer</li><li>命令产生 kill</li><li>硬件异常、段错误、浮点型错误、总线错误、SIGPIPE</li></ul></li><li><p>信号的状态</p><ul><li>产生</li><li>递达 信号到达并且处理完</li><li>未决 信号被阻塞</li></ul></li><li><p>信号的默认处理方式</p><ul><li>忽略</li><li>执行默认动作</li><li>捕捉</li></ul></li><li><p>信号的 4 要素</p><ul><li>编号</li><li>事件</li><li>名称</li><li>默认处理动作<ul><li>忽略</li><li>终止</li><li>终止 + core</li><li>暂停</li><li>继续</li></ul></li></ul></li></ul><h3 id="3-2-进程和线程"><a href="#3-2-进程和线程" class="headerlink" title="3.2 进程和线程"></a>3.2 进程和线程</h3><ul><li>进程组</li><li>会话</li><li>守护进程</li></ul><p>创建一个会话需要注意以下 5 点注意事项：</p><ul><li>调用进程不能是进程组组长，该进程编程新会话首进程（session header）</li><li>该进程成为一个新进程组的组长进程</li><li>新会话丢弃原有的控制终端，该会话没有控制终端</li><li>该调用进程是组长进程，则出错返回</li><li>建立会话时，先调用fork，父进程终止，子进程调用 setsid</li></ul><p>守护进程：</p><p>Daemon 进程，是 Linux 中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p><p>创建守护进程，最关键的一步是调用 setsid 函数创建一个新的 session 。并成为 session leader。</p><p><strong>创建守护进程模型</strong>：</p><ul><li>创建子进程，父进程退出<ul><li>所有工作在子进程中进行形式上脱离了控制终端</li></ul></li><li>在子进程中创建新会话<ul><li>setsid() 函数</li><li>使子进程完全能独立出来，脱离控制</li></ul></li><li>改变当前目录为根目录<ul><li>chdir() 函数</li><li>防止占用可卸载的文件系统</li><li>也可以换成其他路径</li></ul></li><li>重设文件权限掩码<ul><li>umask() 函数</li><li>防止继承的文件创建屏蔽字拒绝某些权限</li><li>增加守护进程灵活性</li></ul></li><li>关闭文件描述符<ul><li>继承的打开文件不会用到，浪费系统资源，无法卸载</li></ul></li><li>开始执行守护进程核心工作</li><li>守护进程退出处理程序模型</li></ul><blockquote><p>会话：进程组的更高一级，多个进程组对应一个会话</p><p>进程组：多个进程在同一个组，第一个进程默认是进程组的组长</p><p>创建会话的时候，组长不可以创建，必须是组员创建。</p><p>创建会话的步骤：创建子进程，父进程终止，子进程当会长</p><p>守护进程的步骤：</p><ul><li>创建子进程 fork</li><li>父进程退出</li><li>子进程当会长 setsid</li><li>切换工作目录 $HOME</li><li>设置掩码 umask</li><li>关闭文件描述符，为了避免浪费资源</li><li>执行核心逻辑</li><li>退出</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strFileName[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(strFileName, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(strFileName));</span><br><span class="line">        <span class="built_in">sprintf</span>(strFileName, <span class="string">"%s/log/Mr.Miaow.%ld"</span>, getenv(<span class="string">"HOME"</span>), time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> fd = open(strFileName, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"open err"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        sleep(<span class="number">5</span>);                                                                                      </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展了解：</p><p>通过 nohup 指令也可以达到守护进程创建的效果</p><p>nohup cmd [&gt; 1.log] &amp;</p><ul><li>nohup 指令会让 cmd 收不到 SIGHUP 信号</li><li>&amp; 代表后台运行</li></ul><p>线程是最小的执行单位，进程是最小的系统资源分配单位</p><p>查看 LWP 号：<code>ps -Lf pid</code> 查看指定线程的 lwp 号</p><p>线程非共享资源</p><ul><li>线程 ID</li><li>处理器现场和栈指针（内核栈）</li><li>独立的栈空间（用户空间栈）</li><li>errno 变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><p>线程优缺点：</p><ul><li>优点：<ul><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ul></li><li>缺点：<ul><li>库函数 不稳定</li><li>调试、编写困难</li><li>对信号支持不好</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alias echomake=`cat ~/bin/makefile.template &gt;&gt; makefile`</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/bin/makefile.template</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> create by Mr.Miaow `date +%Y%m%d`</span></span><br><span class="line">SrcFiles=$(wildcard *.c)</span><br><span class="line">TargetFiles=$(patsubst %.c,%,$(SrcFiles))</span><br><span class="line">all:$(TargetFiles)</span><br><span class="line"><span class="meta">%</span><span class="bash">:%.c</span></span><br><span class="line">gcc -o $@ %&lt; -lpthread -g</span><br><span class="line">clean:</span><br><span class="line">-rm -f $(TargetFiles)</span><br></pre></td></tr></table></figure><p><strong>线程退出注意事项</strong>：</p><ul><li>在线程中使用pthread_exit</li><li>在线程中使用 return （主控线程return 代表退出进程）</li><li>exit 代表退出整个进程</li></ul><p>线程回收函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><p>杀死线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>被pthread_cancel 杀死的线程，退出状态为 PTHREAD_CANCELED</p><p>线程分离：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>此时不需要 pthread_join回收资源</p><p>线程 ID 在进程内部是唯一的</p><p><strong>进程属性控制</strong>：</p><ul><li><p>初始化线程属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>销毁线程属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>设置属性分离态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="meta"># attr init 初始化的属性</span></span><br><span class="line"><span class="meta"># detachstate</span></span><br><span class="line"># - PTHREAD_CREATE_DETACHED 线程分离</span><br><span class="line"># - PTHREAD_CREATE_JOINABLE 允许回收</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>查看线程库版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> getconf GNU_LIBPTHREAD_VERSION</span></span><br></pre></td></tr></table></figure><p>创建多少个线程？</p><ul><li>cpu核数 * 2 + 2</li></ul><p><strong>线程同步</strong>：</p><ul><li>协调步骤，顺序执行</li></ul><p>解决同步的问题：加锁</p><p><strong>mutex 互斥量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> fastmutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">// 常量初始化，此时可以使用init</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>读写锁的特点：读共享，写独占，写优先级高</p><p>读写说任然是一把锁，有不同状态：</p><ul><li>未加锁</li><li>读锁</li><li>写锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>条件变量</strong>（生产者消费者模型）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒至少一个阻塞在条件变量 cond 上的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量 cond 上的全部线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 条件变量阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 超时等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> struct timespec *abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>信号量 加强版的互斥锁</strong>：</p><p>信号量是进化版的互斥量，允许多个线程访问共享资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="meta"># pshared</span></span><br><span class="line"># - <span class="number">0</span> 代表线程信号量</span><br><span class="line"># - 非<span class="number">0</span> 代表进程信号量</span><br><span class="line"><span class="meta"># value 定义信号量的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请信号量，申请成功 value--</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// 释放信号量 value++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abs_timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Link with -pthread.</span></span><br></pre></td></tr></table></figure><p><strong>文件锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-Note&quot;&gt;&lt;a href=&quot;#Linux-Note&quot; class=&quot;headerlink&quot; title=&quot;Linux Note&quot;&gt;&lt;/a&gt;Linux Note&lt;/h1&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;C-语言之解析局部变量返回&quot;&gt;&lt;a href=&quot;#C-语言之解析局部变量返回&quot; class=&quot;headerlink&quot; title=&quot;C 语言之解析局部变量返回&quot;&gt;&lt;/a&gt;C 语言之解析局部变量返回&lt;/h3&gt;&lt;p&gt;一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。&lt;/p&gt;
&lt;p&gt;准确的来说，&lt;strong&gt;函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Program-C" scheme="http://miaopei.github.io/categories/Program-C/"/>
    
    
      <category term="Program-C" scheme="http://miaopei.github.io/tags/Program-C/"/>
    
  </entry>
  
</feed>
