<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Miaow Blog</title>
  
  <subtitle>天道酬勤，地道酬善，人道酬誠，商道酬信，業道酬精</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://miaopei.github.io/"/>
  <updated>2019-06-14T02:52:59.709Z</updated>
  <id>http://miaopei.github.io/</id>
  
  <author>
    <name>苗沛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/use-linux/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/use-linux/</id>
    <published>2019-06-14T02:52:59.709Z</published>
    <updated>2019-06-14T02:52:59.709Z</updated>
    
    <content type="html"><![CDATA[<p>为了获取文中提到的一个命令的更多信息，先试下“man &lt;命令名称&gt;”，在一些情况下，为了让这条命令可以正常执行，你必须安装相应的包，可以用aptitude 或者 yum。如果失败了，求助Google。</p><h2><span style="color: #000000;">基础篇</span></h2><ul><li>学习基础的Bash。事实上，读整个的bash的帮助手册；很容易理解而且篇幅也不算长。其他一些可选的shell外观可能更漂亮，但是bash功能很强大而且总是能用（主要学习zsh或者tcsh在很多情况下你会受到限制）。</li><li>学习vim，对于Linux下的随机编辑，几乎没有工具能出其右（即使你大部分的时间里都在使用Emacs或者Eclipse）。</li><li>通过ssh-agent，ssh-add等命令，了解ssh，以及跳过每次登陆时密码验证的基础办法，。</li><li>熟悉bash下的工作管理: &amp;，Ctrl-Z，Ctrl-C，jobs，fg，bg，kill， 等等。</li><li>基础的文件管理：ls 以及 ls -l (特别的，学习&#8221;ls -l&#8221;中列出的每一列字段的含义)，less，head，tail，tail -f，ln，ln -s (学习软链接和硬链接的区别)，chown，chmod，du（快速了解磁盘总体占用情况），df，mount。</li><li>基础的网络管理命令：ip 或者 ifconfig，dig。</li><li>了解正则表达式，以及grep、egrep的不同命令选项，-0，-A，-B 都值得了解一下。</li><li>学习使用apt-get 或者 yum(取决于你的发行包)来找到并安装你需要的包.</li></ul><h2><strong><span style="color: #000000;">日常使用篇</span></strong></h2><ul><li>使用bash时，用Ctrl-R来搜索命令的历史记录。</li><li>使用bash时，用Ctrl-W来清除最后一个单词，使用Ctrl-U来清除整行。可以查看man readline来获取bash里面默认键的绑定设置。内容很多。比如Alt-.(注：点)遍历之前命令中使用过的参数，Alt-* 扩展了参数的匹配模式。</li><li>回到上次的工作目录：cd -。</li><li>如果你的命令敲到一半时改变了主意，可以用Alt-#来在命令前面增加一个#，使之成为一行注释（或者使用Ctrl-A回到命令开头，然后再键入#）。你可以之后再通过搜索历史记录回来。</li><li>使用xargs（或者parallel）。它非常强大。注意你能控制每一行(-L)执行多少项，也能控制如何并发（- P）。如果你不太确定它会如你所愿的工作，先使用xargs。 再者，-l{} 很有用。例如：</li></ul><pre class="brush: shell; gutter: true">find . -name \*.py | xargs grep some_functioncat hosts | xargs -l{} ssh root@{} hostname</pre><ul><li>pstree -p 可以很方便的显示整个进程树。</li><li>使用pgrep 和pkill 来通过名字来发现进程或者给进程发信号（-f选项会有用）。</li><li>了解你能向进程发送的信号种类。比如，要挂起一个进程，使用kill -STOP [进程ID]。要了解整个列表，请参考man 7 signal。</li><li>如果你想让一个后台进程一直运行，使用nohup or disown 。</li><li>通过netstat -lntp 来检测哪些进程在监听。同样可以用lsof。</li><li>bash脚本中，使用set -x 来调试输出。使用set -e在有错误时终止时终止执行。要想严格输出错误，可以考虑使用set -o pipefail（虽然这个主题说起来有些复杂）。对于更复杂的脚本，也可以使用trap。</li><li>bash脚本中，子shell（通过写在括号里）是一种组织命令的方便的方法。一个很常见的例子是暂时移动到另外一个工作目录，例如：</li></ul><pre class="brush: shell; gutter: true">#在当前目录下做一些事情（cd /一些/另外的/目录；执行别的操作）#继续在原来的目录下执行</pre><ul><li>要注意bash中有很多种变量表达式。检查一个变量是否存在：${name:?错误信息}。例如：如果一个bash脚本需要一个单变量，只需要写input_file=${1:?usage: $0 inpute_file}。数值扩展：i=$({(i+1)%5})。序列：{1..10}。字符串的整理：${var%suffix} 和${var#prefix}。例如:<pre class="brush: shell; gutter: true">if var==foo.pdf, then echo ${var%.pdf}.txt   #会打印&quot;foo.txt&quot;。</pre></li><li>通过 &lt;(其他指令)，一条命令的输出可以被当作是一个文件的内容来对待。 例如，比较本地和远程的 /etc/hosts 文件，可以用diff /etc/hosts &lt;(ssh [远程主机] cat /etc/hosts)。</li><li>了解bash中的“here documents”，比如 cat &lt;&lt;EOF &#8230;</li><li>bash中，通过 其他指令 &gt; 日志文件 2&gt;&amp;1  把标准输出以及标准错误重定向。常见的情况是，为了保证一条指令没有为标准输入留下一个打开的文件描述符，从而输出至你当前所在的终端，增加“&lt;/dev/null” 也是好的习惯。</li><li>用man ascii可以得到一个完整的ASCII表，有对应的16进制和10进制的值。</li><li>通过ssh连接远程终端时，使用screen或者dtach 来保持你的session，防止被打断。在ssh中，了解如何使用-L或者-D选项（有时也会用到-R）会很有用处，比如，如果通过从一个远程的服务器访问一个网页。</li><li>优化你的SSH选项也可能管用。比如，下面的.ssh/config 内容在一些网络环境下可以防止连接掉线，当连接到新主机时不需要再次确认，跳转验证，并且还使用了压缩（对在一些低宽带的连接环境下使用scp时会有帮助）。</li></ul><div><pre class="brush: shell; gutter: true">TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6StrictHostKeyChecking=noCompression=yesForwardAgent=yes</pre><h2><span style="color: #000000;">数据处理篇</span></h2><ul><li>把HTML转成文本：lynx -dump 标准输入</li><li>如果要处理XML，xmlstarlet会很棒。</li><li>对于Amazon S3，s3cmd 很方便（虽然还不太成熟，可能会有一些不太好的特性）。</li><li>了解sort 以及 uniq（包括uniq的 -u 以及 -d 选项）。</li><li>了解cut，paste，join 来操作文本文件。许多人使用cut但却忘了还有join。</li><li>当你要在文件之间做集合的加，减，以及差运算时，用sort/uniq是非常方便的。假如a和b是两个已经去重的文本文件，那么运算起来会很快，而且可以在任意大小的文件之间执行操作，甚至可以到GB字节大小。（sort不受内存限制，不过如果/tmp 在一个很小的root分区的话，你可能需要使用-T选项）</li></ul><pre class="brush: shell; gutter: true">cat a b | sort | uniq &gt; c   # c is a union bcat a b | sort | uniq -d &gt; c   # c is a intersect bcat a b b | sort | uniq -u &gt; c   # c is set difference a - b</pre><ul><li>了解本地化会影响到许多命令行的工作，包括排序的顺序和性能。多数的linux安装包会把LANG或者其他一些本地化的变量设置为类似美国英语的一个本地设置。这会让sort和其他一些命令运行起来慢很多。（注意即使你使用UTF-8编码的文本，你仍然可以放心的通过ASCII码的顺序来排序，这一点用处很多）为避免i18n拖慢日常的工作，使用传统的基于字节的排序顺序，使用export LC_ALL=C（实际上，考虑在你的.bashrc里加进去）。</li><li>了解基本的AWK和sed命令来做简单的数据处理。例如：对一个文本文件的第三列的数字求和：awk &#8216;{x += $3} END {print x}&#8217;。 这大概比同等的python速度要快三倍并且代码长度也会简短3倍。</li><li>就地替换一个字符串在所有文件里所有出现的地方。</li></ul></div><div><pre class="brush: shell; gutter: true">perl -pi.bak -e &#039;s/old-string/new-string/g&#039; my-files-*.txt</pre><ul><li>使用shuf来随机打乱一个文件中的行或者选择一个随机的行。</li><li>了解sort的各个选项。知道键值是如何工作的。特别是，当你要使用 -k1时，要格外注意：1只对第一个字段排序，-k1则意味着根据整个行排序。</li><li>稳定排序（sort  -s）可能会有用。例如，先根据第二个字段排序，再根据第一个字段排序时，你可以使用sort -k1,1 | sort -s -k2,2</li><li>如果你需要在bash里的命令行里写入一个tab键的字面值的话，按Ctrl+V, &lt;tab&gt; 或者$‘\t’ (后者更好，因为你可以复制、粘贴)。</li><li>对于二进制文件，使用hd来进行简单的导出16进制表示或者用bvi进行二进制的编辑。</li><li>对于二进制文件，strings（还有grep等等）可以让你发现文件的字节位（0101）.要对文件转编，可以试下iconv，或者如果要使用更高级的用法，试试uconv，它可以支持一些高级的Unicode方面的事情。比如，这条命令可以将重音都小写，并且去掉（通过扩展并且丢掉）:</li></ul></div><div><pre class="brush: shell; gutter: true">uconv -f utf-8 -t utf-8 -x &#039;::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; &#039; &lt; input.txt &gt; output.txt</pre><ul><li>要将文件切片，可以试试split（根据大小切分）或者csplit（根据模式切分）。</li></ul><h2><span style="color: #000000;">系统调试篇</span></h2></div><div><ul><li>对于web调试来说，curl和curl -l会有用，以及和wget相同的那部分功能。</li><li>如果想了解磁盘/cpu/网络的状态，可以使用iostat，netstat，top(更好一些的话，用htop)，以及（尤其是）dstat，对于想快速了解系统当前正在发生的事情，非常的方便。如果想了解内存当前的状态，可以使用free以及vmstat，还要了解各项输出的含义。特别值得一提的是，你要知道“cached”的数值是linux内核保留用来做文件缓存的空间的大小，所以真正可用的有效内存是“free”项的对应值。</li><li>java的系统调试则完全是另外一回事，但在Sun以及其他的JVM上有一个简单的技巧，就是你可以运行kill -3 &lt;pid&gt; ,得到一个完整的栈调用轨迹以及堆使用的总体情况（包括产生的垃圾回收细节，这里面包含有很多的信息），会被定向到标准错误或者日志。</li><li>使用mtr作为更好的网络追踪，识别网络存在的问题。</li><li>要查看一个磁盘是否是满的，ncdu要比一般用的“du -sk *”要快。</li><li>要查看哪些socket或者进程在占用带宽，试试iftop或者netlogs。</li><li>ab 工具（随apache的安装包一起发布）对于检测网络服务器的性能很有帮助，对于更加复杂的压力测试，可以试下siege。对于更加严重的网络问题的调试，试试wireshark或者tshark。了解strace和ltrace。这在一个程序突然失败，挂掉，或者崩溃，而你却不知所措，或者是你想知道程序的整体性能的情况时，会很有帮助。可以注意下-c和-p选项。</li><li>了解用ldd来检查共享库函数等的一些问题。</li><li>了解如何用gdb连接到一个正在运行的程序，并且得到它的调用堆栈。</li><li>使用/proc. 对于现场调试问题会很有帮忙。例如：/proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps。</li><li>当要调试过去一段时间内出现的问题时，sar 会有用，它可以显示过去一段时间内的CPU，内存，网络的统计信息。</li><li>对于更深层次的系统性能优化，可以关注下stap（systemtap）或者perf。</li><li>当出现了一些很诡异的问题时，可以试下dmesg（比如硬件或者驱动的问题）。</li></ul></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了获取文中提到的一个命令的更多信息，先试下“man &amp;lt;命令名称&amp;gt;”，在一些情况下，为了让这条命令可以正常执行，你必须安装相应的包，可以用aptitude 或者 yum。如果失败了，求助Google。&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;color: #0
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/memory/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/memory/</id>
    <published>2019-06-14T02:52:59.709Z</published>
    <updated>2019-06-14T02:52:59.709Z</updated>
    
    <content type="html"><![CDATA[<h2> <strong>1 简介</strong> </h2> <p> 早期计算机比现在更为简单。系统的各种组件例如CPU，内存，大容量存储器和网口，由于被共同开发因而有非常均衡的表现。例如，内存和网口并不比CPU在提供数据的时候更（特别的）快。 </p> <p> 曾今计算机稳定的基本结构悄然改变，硬件开发人员开始致力于优化单个子系统。于是电脑一些组件的性能大大的落后因而成为了瓶颈。由于开销的原因，大容量存储器和内存子系统相对于其他组件来说改善得更为缓慢。 </p><p> 大容量存储的性能问题往往靠软件来改善: 操作系统将常用(且最有可能被用)的数据放在主存中，因为后者的速度要快上几个数量级。或者将缓存加入存储设备中，这样就可以在不修改操作系统的前提下提升性能。{然而，为了在使用缓存时保证数据的完整性，仍然要作出一些修改。}这些内容不在本文的谈论范围之内，就不作赘述了。 </p> <p> 而解决内存的瓶颈更为困难，它与大容量存储不同，几乎每种方案都需要对硬件作出修改。目前，这些变更主要有以下这些方式: </p> <ul>  <li> <span style="line-height:1.5;font-size:10pt;">RAM的硬件设计(速度与并发度</span><span style="line-height:1.5;font-size:10pt;">)</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">内存控制器的设计</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">CPU缓存</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">设备的直接内存访问(DMA)</span> </li> </ul><p> 本文主要关心的是CPU缓存和内存控制器的设计。在讨论这些主题的过程中，我们还会研究DMA。不过，我们首先会从当今商用硬件的设计谈起。这有助于我们理解目前在使用内存子系统时可能遇到的问题和限制。我们还会详细介绍RAM的分类，说明为什么会存在这么多不同类型的内存。 </p> <p> 本文不会包括所有内容，也不会包括最终性质的内容。我们的讨论范围仅止于商用硬件，而且只限于其中的一小部分。另外，本文中的许多论题，我们只会点到为止，以达到本文目标为标准。对于这些论题，大家可以阅读其它文档，获得更详细的说明。 </p><p> 当本文提到操作系统特定的细节和解决方案时，针对的都是Linux。无论何时都不会包含别的操作系统的任何信息，作者无意讨论其他操作系统的情况。如果读者认为他/她不得不使用别的操作系统，那么必须去要求供应商提供其<span>操作系统</span><span>类似于本文</span>的文档。 </p> <p> 在开始之前最后的一点说明，本文包含大量出现的术语“经常”和别的类似的限定词。<span>这里讨论的技术</span><span>在现实中</span>存在于很多不同的实现，所以本文只阐述使用得最广泛最主流的版本。在阐述中很少有地方能用到绝对的限定词。 </p><h3> <strong>1.1文档结构</strong> </h3> <p> 这个文档主要视为软件开发者而写的。本文不会涉及太多硬件细节，所以喜欢硬件的读者也许不会觉得有用。但是在我们讨论一些有用的细节之前，我们先要描述足够多的背景。 </p> <p> 在这个基础上，本文的第二部分将描述RAM（随机寄存器）。懂得这个部分的内容很好，但是此部分的内容并不是懂得其后内容必须部分。我们会在之后引用不少之前的部分，所以心急的读者可以跳过任何章节来读他们认为有用的部分。 </p> <p> 第三部分会谈到不少关于CPU缓存行为模式的内容。我们会列出一些图标，这样你们不至于觉得太枯燥。第三部分对于理解整个文章非常重要。第四部分将简短的描述虚拟内存是怎么被实现的。这也是你们需要理解全文其他部分的背景知识之一。 </p><p> 第五部分会提到许多关于Non Uniform Memory Access (NUMA)系统。 </p> <p> 第六部分是本文的中心部分。在这个部分里面，我们将回顾其他许多部分中的信息，并且我们将给阅读本文的程序员许多在各种情况下的编程建议。如果你真的很心急，那么你可以直接阅读第六部分，并且我们建议你在必要的时候回到之前的章节回顾一下必要的背景知识。 </p> <p> 本文的第七部分将介绍一些能够帮助程序员更好的完成任务的工具。即便在彻底理解了某一项技术的情况下，距离彻底理解在非测试环境下的程序还是很遥远的。我们需要借助一些工具。 </p> <p> 第八部分，我们将展望一些在未来我们可能认为好用的科技。 </p><p> <strong>1.2 反馈问题</strong> </p> <p> 作者会不定期更新本文档。这些更新既包括伴随技术进步而来的更新也包含更改错误。非常欢迎有志于反馈问题的读者发送电子邮件。 </p> <p> <strong>1.3 致谢</strong> </p> <p> 我首先需要感谢Johnray Fuller尤其是Jonathan Corbet，感谢他们将作者的英语转化成为更为规范的形式。Markus Armbruster提供大量本文中对于问题和缩写有价值的建议。 </p> <p> <strong>1.4 关于本文</strong> </p> <p> 本文题目对David Goldberg的经典文献《<span style="font-family:微软雅黑, Verdana, sans-serif, 宋体;line-height:20px;background-color:#F6F6F6;">What Every Computer Scientist Should Know About Floating-Point Arithmetic</span>》[goldberg]表示致敬。Goldberg的论文虽然不普及，但是对于任何有志于严格编程的人都会是一个先决条件。 </p><h3> 2 商用硬件现状 </h3> <p> 鉴于目前专业硬件正在逐渐淡出，理解商用硬件的现状变得十分重要。现如今，人们更多的采用水平扩展，也就是说，用大量小型、互联的商用计算机代替巨大、超快(但超贵)的系统。原因在于，快速而廉价的网络硬件已经崛起。那些大型的专用系统仍然有一席之地，但已被商用硬件后来居上。2007年，Red Hat认为，未来构成数据中心的“积木”将会是拥有最多4个插槽的计算机，每个插槽插入一个四核CPU，这些CPU都是超线程的。{超线程使单个处理器核心能同时处理两个以上的任务，只需加入一点点额外硬件}。也就是说，这些数据中心中的标准系统拥有最多64个虚拟处理器。当然可以支持更大的系统，但人们认为4插槽、4核CPU是最佳配置，绝大多数的优化都针对这样的配置。 </p><p> 在不同商用计算机之间，也存在着巨大的差异。不过，我们关注在主要的差异上，可以涵盖到超过90%以上的硬件。需要注意的是，这些技术上的细节往往日新月异，变化极快，因此大家在阅读的时候也需要注意本文的写作时间。 </p> <p> 这么多年来，个人计算机和小型服务器被标准化到了一个芯片组上，它由两部分组成: 北桥和南桥，见图2.1。 </p> <blockquote>  <p> <img src="http://static.oschina.net/uploads/img/201302/06104430_73iC.png"> </p>  <p> 图2.1 北桥和南桥组成的结构 </p> </blockquote> <p> CPU通过一条通用总线(前端总线，FSB)连接到北桥。北桥主要包括内存控制器和其它一些组件，内存控制器决定了RAM芯片的类型。不同的类型，包括DRAM、Rambus和SDRAM等等，要求不同的内存控制器。 </p><p> 为了连通其它系统设备，北桥需要与南桥通信。南桥又叫I/O桥，通过多条不同总线与设备们通信。目前，比较重要的总线有PCI、PCI Express、SATA和USB总线，除此以外，南桥还支持PATA、IEEE 1394、串行口和并行口等。比较老的系统上有连接北桥的AGP槽。那是由于南北桥间缺乏高速连接而采取的措施。现在的PCI-E都是直接连到南桥的。 </p> <p> 这种结构有一些需要注意的地方: </p> <ul>  <li> <span style="line-height:1.5;font-size:10pt;">从某个CPU到另一个CPU的数据需要走它与北桥通信的同一条总线。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">与RAM的通信需要经过北桥</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">RAM只有一个端口。{本文不会介绍多端口RAM，因为商用硬件不采用这种内存，至少程序员无法访问到。这种内存一般在路由器等专用硬件中采用。</span><span style="line-height:1.5;font-size:10pt;">}</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">CPU与南桥设备间的通信需要经过北桥</span> </li> </ul>在上面这种设计中，瓶颈马上出现了。第一个瓶颈与设备对RAM的访问有关。早期，所有设备之间的通信都需要经过CPU，结果严重影响了整个系统的性能。为了解决这个问题，有些设备加入了直接内存访问(DMA)的能力。DMA允许设备在北桥的帮助下，无需CPU的干涉，直接读写RAM。到了今天，所有高性能的设备都可以使用DMA。虽然DMA大大降低了CPU的负担，却占用了北桥的带宽，与CPU形成了争用。<p> 第二个瓶颈来自北桥与RAM间的总线。总线的具体情况与内存的类型有关。在早期的系统上，只有一条总线，因此不能实现并行访问。近期的RAM需要两条独立总线(或者说通道，DDR2就是这么叫的，见图2.8)，可以实现带宽加倍。北桥将内存访问交错地分配到两个通道上。更新的内存技术(如FB-DRAM)甚至加入了更多的通道。 </p> <p> 由于带宽有限，我们需要以一种使延迟最小化的方式来对内存访问进行调度。我们将会看到，处理器的速度比内存要快得多，需要等待内存。如果有多个超线程核心或CPU同时访问内存，等待时间则会更长。对于DMA也是同样。 </p><p> 除了并发以外，访问模式也会极大地影响内存子系统、特别是多通道内存子系统的性能。关于访问模式，可参见2.2节。 </p> <p> 在一些比较昂贵的系统上，北桥自己不含内存控制器，而是连接到外部的多个内存控制器上(在下例中，共有4个)。 </p> <blockquote>  <p> <img src="http://static.oschina.net/uploads/img/201302/06104430_V9Tz.png"> </p>  <p> 图2.2 拥有外部控制器的北桥 </p> </blockquote>这种架构的好处在于，多条内存总线的存在，使得总带宽也随之增加了。而且也可以支持更多的内存。通过同时访问不同内存区，还可以降低延时。对于像图2.2中这种多处理器直连北桥的设计来说，尤其有效。而这种架构的局限在于北桥的内部带宽，非常巨大(来自Intel)。{出于完整性的考虑，还需要补充一下，这样的内存控制器布局还可以用于其它用途，比如说「内存RAID」，它可以与热插拔技术一起使用。}<p> 使用外部内存控制器并不是唯一的办法，另一个最近比较流行的方法是将控制器集成到CPU内部，将内存直连到每个CPU。这种架构的走红归功于基于AMD Opteron处理器的SMP系统。图2.3展示了这种架构。Intel则会从Nehalem处理器开始支持通用系统接口(CSI)，基本上也是类似的思路——集成内存控制器，为每个处理器提供本地内存。 </p> <blockquote>  <p> <img src="http://static.oschina.net/uploads/img/201302/06104431_mINo.png"> </p>  <p> 图2.3 集成的内存控制器 </p> </blockquote> <p> 通过采用这样的架构，系统里有几个处理器，就可以有几个内存库(memory bank)。比如，在4 CPU的计算机上，不需要一个拥有巨大带宽的复杂北桥，就可以实现4倍的内存带宽。另外，将内存控制器集成到CPU内部还有其它一些优点，这里就不赘述了。 </p><p> 同样也有缺点。首先，系统仍然要让所有内存能被所有处理器所访问，导致内存不再是统一的资源(NUMA即得名于此)。处理器能以正常的速度访问本地内存(连接到该处理器的内存)。但它访问其它处理器的内存时，却需要使用处理器之间的互联通道。比如说，CPU 1如果要访问CPU 2的内存，则需要使用它们之间的互联通道。如果它需要访问CPU 4的内存，那么需要跨越两条互联通道。 </p> <p> 使用互联通道是有代价的。在讨论访问远端内存的代价时，我们用「NUMA因子」这个词。在图2.3中，每个CPU有两个层级: 相邻的CPU，以及两个互联通道外的CPU。在更加复杂的系统中，层级也更多。甚至有些机器有不止一种连接，比如说IBM的x445和SGI的Altix系列。CPU被归入节点，节点内的内存访问时间是一致的，或者只有很小的NUMA因子。而在节点之间的连接代价很大，而且有巨大的NUMA因子。 </p><p> 目前，已经有商用的NUMA计算机，而且它们在未来应该会扮演更加重要的角色。人们预计，从2008年底开始，每台SMP机器都会使用NUMA。每个在NUMA上运行的程序都应该认识到NUMA的代价。在第5节中，我们将讨论更多的架构，以及Linux内核为这些程序提供的一些技术。 </p> <p> 除了本节中所介绍的技术之外，还有其它一些影响RAM性能的因素。它们无法被软件所左右，所以没有放在这里。如果大家有兴趣，可以在第2.1节中看一下。介绍这些技术，仅仅是因为它们能让我们绘制的RAM技术全图更为完整，或者是可能在大家购买计算机时能够提供一些帮助。 </p> <p> 以下的两节主要介绍一些入门级的硬件知识，同时讨论内存控制器与DRAM芯片间的访问协议。这些知识解释了内存访问的原理，程序员可能会得到一些启发。不过，这部分并不是必读的，心急的读者可以直接跳到第2.2.5节。 </p><h3> 2.1 RAM类型 </h3> <p> 这些年来，出现了许多不同类型的RAM，各有差异，有些甚至有非常巨大的不同。那些很古老的类型已经乏人问津，我们就不仔细研究了。我们主要专注于几类现代RAM，剖开它们的表面，研究一下内核和应用开发人员们可以看到的一些细节。 </p> <p> 第一个有趣的细节是，为什么在同一台机器中有不同的RAM？或者说得更详细一点，为什么既有静态RAM(SRAM {SRAM还可以表示「同步内存」。})，又有动态RAM(DRAM)。功能相同，前者更快。那么，为什么不全部使用SRAM？答案是，代价。无论在生产还是在使用上，SRAM都比DRAM要贵得多。生产和使用，这两个代价因子都很重要，后者则是越来越重要。为了理解这一点，我们分别看一下SRAM和DRAM一个位的存储的实现过程。 </p> <p> 在本节的余下部分，我们将讨论RAM实现的底层细节。我们将尽量控制细节的层面，比如，在「逻辑的层面」讨论信号，而不是硬件设计师那种层面，因为那毫无必要。 </p><h4> 2.1.1 静态RAM </h4> <blockquote>  <p> <img src="http://static.oschina.net/uploads/img/201302/06104431_ys3P.png"> </p>  <p> 图2.6 6-T静态RAM </p> </blockquote> <p> 图2.4展示了6晶体管SRAM的一个单元。核心是4个晶体管M1-M4，它们组成两个交叉耦合的反相器。它们有两个稳定的状态，分别代表0和1。只要保持Vdd有电，状态就是稳定的。 </p> <p> 当需要访问单元的状态时，升起字访问线WL。BL和BL上就可以读取状态。如果需要覆盖状态，先将BL和BL设置为期望的值，然后升起WL。由于外部的驱动强于内部的4个晶体管，所以旧状态会被覆盖。 </p> <p> 更多详情，可以参考[sramwiki]。为了下文的讨论，需要注意以下问题: </p> <p> 一个单元需要6个晶体管。也有采用4个晶体管的SRAM，但有缺陷。 </p> <p> 维持状态需要恒定的电源。 </p> <p> 升起WL后立即可以读取状态。信号与其它晶体管控制的信号一样，是直角的(快速在两个状态间变化)。 </p> <p> 状态稳定，不需要刷新循环。 </p> <p> SRAM也有其它形式，不那么费电，但比较慢。由于我们需要的是快速RAM，因此不在关注范围内。这些较慢的SRAM的主要优点在于接口简单，比动态RAM更容易使用。 </p><h4> 2.1.2 动态RAM </h4> <p> 动态RAM比静态RAM要简单得多。图2.5展示了一种普通DRAM的结构。它只含有一个晶体管和一个电容器。显然，这种复杂性上的巨大差异意味着功能上的迥异。 </p> <blockquote>  <p> <img src="http://static.oschina.net/uploads/img/201302/06104431_i8Of.png"> </p>  <p> 图2.5 1-T动态RAM </p> </blockquote> <p> 动态RAM的状态是保持在电容器C中。晶体管M用来控制访问。如果要读取状态，升起访问线AL，这时，可能会有电流流到数据线DL上，也可能没有，取决于电容器是否有电。如果要写入<span></span>状态，先设置DL，然后升起AL一段时间，直到电容器充电或放电完毕。 </p> <p> 动态RAM的设计有几个复杂的地方。由于读取状态时需要对电容器放电，所以这一过程不能无限重复，不得不在某个点上对它重新充电。 </p> <p> 更糟糕的是，为了容纳大量单元(现在一般在单个芯片上容纳10的9次方以上的RAM单元)，电容器的容量必须很小(<span style="color:#222222;font-family:arial, sans-serif;font-size:small;line-height:16px;background-color:#FFFFFF;">0.000000000000001</span>法拉以下)。这样，完整充电后大约持有几万个电子。即使电容器的电阻很大(若干兆欧姆)，仍然只需很短的时间就会耗光电荷，称为「泄漏」。 </p><p> 这种泄露就是现在的大部分DRAM芯片每隔64ms就必须进行一次刷新的原因。在刷新期间，对于该芯片的访问是不可能的，这甚至会造成半数任务的延宕。（相关内容请察看【highperfdram】一章） </p> <p> 这个问题的另一个后果就是无法直接读取芯片单元中的信息，而必须通过信号放大器将0和1两种信号间的电势差增大。 </p> <p> 最后一个问题在于电容器的冲放电是需要时间的，这就导致了信号放大器读取的信号并不是典型的矩形信号。所以当放大器输出信号的时候就需要一个小小的延宕，相关公式如下 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/06104432_i34C.png" alt="[Formulas]"> </blockquote><p> 这就意味着需要一些时间（时间长短取决于电容C和电阻R）来对电容进行冲放电。另一个负面作用是，信号放大器的输出电流不能立即就作为信号载体使用。图2.6显示了冲放电的曲线，x轴表示的是单位时间下的R*C </p> <p> <img src="http://static.oschina.net/uploads/img/201302/06104432_ePJr.png"> </p> <p> 与静态RAM可以即刻读取数据不同的是，当要读取动态RAM的时候，必须花一点时间来等待电容的冲放电完全。这一点点的时间最终限制了DRAM的速度。 </p> <p> 当然了，这种读取方式也是有好处的。最大的好处在于缩小了规模。一个动态RAM的尺寸是小于静态RAM的。这种规模的减小不单单建立在动态RAM的简单结构之上，也是由于减少了静态RAM的各个单元独立的供电部分。以上也同时导致了动态RAM模具的简单化。 </p> <p> 综上所述，由于不可思议的成本差异，除了一些特殊的硬件（包括路由器什么的）之外，我们的硬件大多是使用DRAM的。这一点深深的影响了咱们这些程序员，后文将会对此进行讨论。在此之前，我们还是先了解下DRAM的更多细节。 </p><p> <strong>2.1.3 DRAM 访问</strong> </p> <p> 一个程序选择了一个内存位置使用到了一个虚拟地址。处理器转换这个到物理地址最后将内存控制选择RAM芯片匹配了那个地址。在RAM芯片去选择单个内存单元，部分的物理地址以许多地址行的形式被传递。 </p> <p> 它单独地去处理来自于内存控制器的内存位置将完全不切实际：4G的RAM将需要&nbsp;2<sup>32</sup>&nbsp;地址行。地址传递DRAM芯片的这种方式首先必须被路由器解析。一个路由器的N多地址行将有2<sup><i>N</i></sup>&nbsp;输出行。这些输出行能被使用到选择内存单元。使用这个直接方法对于小容量芯片不再是个大问题 </p><p> 但如果许多的单元生成这种方法不在适合。一个1G的芯片容量（我反感那些SI前缀，对于我一个<i>giga-bit将总是<i>2<sup>30</sup></i><i>&nbsp;</i>而不是<i>10<sup>9</sup></i></i>字节）将需要30地址行和2<sup>30</sup>&nbsp;选项行。一个路由器的大小及许多的输入行以指数方式递增当速度不被牺牲时。一个30地址行路由器需要一大堆芯片的真实身份另外路由器也就复杂起来了。更重要的是，传递30脉冲在地址行同步要比仅仅传递15脉冲困难的多。较少列能精确布局相同长度或恰当的时机（现代DRAM类型像DDR3能自动调整时序但这个限制能让他什么都能忍受） </p> <p> <img src="http://static.oschina.net/uploads/img/201302/06104432_tXPs.png"> </p> <p> 图2.7展示了一个很高级别的一个DRAM芯片，DRAM被组织在行和列里。他们能在一行中对奇但DRAM芯片需要一个大的路由器。通过阵列方法设计能被一个路由器和一个半的multiplexer获得{多路复用器（multiplexer）和路由器是一样的，这的multiplexer需要以路由器身份工作当写数据时候。那么从现在开始我们开始讨论其区别.}这在所有方面会是一个大的存储。例如地址linesa<sub>0和</sub>a<sub>1</sub>通过行地址选择路由器来选择整个行的芯片的地址列，当读的时候，所有的芯片目录能使其纵列选择路由器可用，依据地址linesa<sub>2和</sub>a<sub>3</sub>一个纵列的目录用于数据DRAM芯片的接口类型。这发生了许多次在许多DRAM芯片产生一个总记录数的字节匹配给一个宽范围的数据总线。 </p><p> 对于写操作，内存单元的数据新值被放到了数据总线，当使用RAS和CAS方式选中内存单元时，数据是存放在内存单元内的。这是一个相当直观的设计，在现实中——很显然——会复杂得多，对于读，需要规范从发出信号到数据在数据总线上变得可读的时延。电容不会像前面章节里面描述的那样立刻自动放电，从内存单元发出的信号是如此这微弱以至于它需要被放大。对于写，必须规范从数据RAS和CAS操作完成后到数据成功的被写入内存单元的时延（当然，电容不会立刻自动充电和放电）。这些时间常量对于DRAM芯片的性能是至关重要的，我们将在下章讨论它。 </p> <p> 另一个关于伸缩性的问题是，用<span>30根地址线连接到</span>每一个RAM芯片是行不通的。芯片的针脚是非常珍贵的资源，以至数据必须能并行传输就并行传输（比如：64位为一组）。内存控制器必须有能力解析每一个RAM模块（RAM芯片集合）。如果因为性能的原因要求并发行访问多个RAM模块并且每个RAM模块需要自己独占的30或多个地址线，那么对于8个RAM模块，仅仅是解析地址，内存控制器就需要240+之多的针脚。<span></span> </p>在很长一段时间里，地址线被复用以解决DRAM芯片的这些次要的可扩展性问题。这意味着地址被转换成两部分。第一部分由地址位a0和a1选择行（如图2.7）。这个选择保持有效直到撤销。然后是第二部分，地址位a2和a3选择列。关键差别在于：只需要两根外部地址线。需要一些很少的线指明RAS和CAS信号有效，但是把地址线的数目减半所付出的代价更小。可是地址复用也带来自身的一些问题。我们将在2.2章中提到。<p> <b>2.1.4 总结</b> </p> <p> 如果这章节的内容有些难以应付，不用担心。纵观这章节的重点，有： </p> <ul>  <li> 为什么不是所有的存储器都是SRAM的原因 </li>  <li> 存储单元需要单独选择来使用 </li>  <li> 地址线数目直接负责存储控制器，主板，DRAM模块和DRAM芯片的成本 </li>  <li> 在读或写操作结果之前需要占用一段时间是可行的 </li> </ul> 接下来的章节会涉及更多的有关访问DRAM存储器的实际操作的细节。我们不会提到更多有关访问SRAM的具体内容，它通常是直接寻址。这里是由于速度和有限的SRAM存储器的尺寸。SRAM现在应用在CPU的高速缓存和芯片，它们的连接件很小而且完全能在CPU设计师的掌控之下。我们以后会讨论到CPU高速缓存这个主题，但我们所需要知道的是SRAM存储单元是有确定的最大速度，这取决于花在SRAM上的艰难的尝试。这速度与CPU核心相比略慢一到两个数量级。 <br><h3> 2.2 DRAM访问细节 </h3> <p> 在上文介绍DRAM的时候，我们已经看到DRAM芯片为了节约资源，对地址进行了复用。而且，访问DRAM单元是需要一些时间的，因为电容器的放电并不是瞬时的。此外，我们还看到，DRAM需要不停地刷新。在这一节里，我们将把这些因素拼合起来，看看它们是如何决定DRAM的访问过程。 </p> <p> 我们将主要关注在当前的科技上，不会再去讨论异步DRAM以及它的各种变体。如果对它感兴趣，可以去参考[highperfdram]及[arstechtwo]。我们也不会讨论Rambus DRAM(RDRAM)，虽然它并不过时，但在系统内存领域应用不广。我们将主要介绍同步DRAM(SDRAM)及其后继者双倍速DRAM(DDR)。 </p><p> 同步DRAM，顾名思义，是参照一个时间源工作的。由内存控制器提供一个时钟，时钟的频率决定了前端总线(FSB)的速度。FSB是内存控制器提供给DRAM芯片的接口。在我写作本文的时候，FSB已经达到800MHz、1066MHz，甚至1333MHz，并且下一代的1600MHz也已经宣布。但这并不表示时钟频率有这么高。实际上，目前的总线都是双倍或四倍传输的，每个周期传输2次或4次数据。报的越高，卖的越好，所以这些厂商们喜欢把四倍传输的200MHz总线宣传为“有效的”800MHz总线。 </p> <p> 以今天的SDRAM为例，每次数据传输包含64位，即8字节。所以FSB的传输速率应该是有效总线频率乘于8字节(对于4倍传输200MHz总线而言，传输速率为6.4GB/s)。听起来很高，但要知道这只是峰值速率，实际上无法达到的最高速率。我们将会看到，与RAM模块交流的协议有大量时间是处于非工作状态，不进行数据传输。我们必须对这些非工作时间有所了解，并尽量缩短它们，才能获得最佳的性能。 </p><h4> 2.2.1 读访问协议 </h4> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/06104432_0ZDH.png">  <br> 图2.8: SDRAM读访问的时序 </blockquote> <p> 图2.8展示了某个DRAM模块一些连接器上的活动，可分为三个阶段，图上以不同颜色表示。按惯例，时间为从左向右流逝。这里忽略了许多细节，我们只关注时钟频率、RAS与CAS信号、地址总线和数据总线。首先，内存控制器将行地址放在地址总线上，并降低RAS信号，读周期开始。所有信号都在时钟(CLK)的上升沿读取，因此，只要信号在读取的时间点上保持稳定，就算不是标准的方波也没有关系。设置行地址会促使RAM芯片锁住指定的行。 </p> <p> CAS信号在tRCD(RAS到CAS时延)个时钟周期后发出。内存控制器将列地址放在地址总线上，降低CAS线。这里我们可以看到，地址的两个组成部分是怎么通过同一条总线传输的。 </p><p> 至此，寻址结束，是时候传输数据了。但RAM芯片任然需要一些准备时间，这个时间称为CAS时延(CL)。在图2.8中CL为2。这个值可大可小，它取决于内存控制器、主板和DRAM模块的质量。CL还可能是半周期。假设CL为2.5，那么数据将在蓝色区域内的第一个下降沿准备就绪。 </p> <p> 既然数据的传输需要这么多的准备工作，仅仅传输一个字显然是太浪费了。因此，DRAM模块允许内存控制指定本次传输多少数据。可以是2、4或8个字。这样，就可以一次填满高速缓存的整条线，而不需要额外的RAS/CAS序列。另外，内存控制器还可以在不重置行选择的前提下发送新的CAS信号。这样，读取或写入连续的地址就可以变得非常快，因为不需要发送RAS信号，也不需要把行置为非激活状态(见下文)。是否要将行保持为“打开”状态是内存控制器判断的事情。让它一直保持打开的话，对真正的应用会有不好的影响(参见[highperfdram])。CAS信号的发送仅与RAM模块的命令速率(Command Rate)有关(常常记为<span style="font-family:微软雅黑, Verdana, sans-serif, 宋体;line-height:21px;background-color:#F6F6F6;">T</span><i>x，</i>其中<i>x</i>为1或2，高性能的DRAM模块一般为1，表示在每个周期都可以接收新命令)。 </p> <p> 在上图中，SDRAM的每个周期输出一个字的数据。这是第一代的SDRAM。而DDR可以在一个周期中输出两个字。这种做法可以减少传输时间，但无法降低时延。DDR2尽管看上去不同，但在本质上也是相同的做法。对于DDR2，不需要再深入介绍了，我们只需要知道DDR2更快、更便宜、更可靠、更节能(参见[ddrtwo])就足够了。 </p><h4> 2.2.2 预充电与激活 </h4> <p> 图2.8并不完整，它只画出了访问DRAM的完整循环的一部分。在发送RAS信号之前，必须先把当前锁住的行置为非激活状态，并对新行进行预充电。在这里，我们主要讨论由于显式发送指令而触发以上行为的情况。协议本身作了一些改进，在某些情况下是可以省略这个步骤的，但预充电带来的时延还是会影响整个操作。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/06104433_y5nt.png">  <br> 图2.9: SDRAM的预充电与激活 </blockquote> <p> 图2.9显示的是两次CAS信号的时序图。第一次的数据在CL周期后准备就绪。图中的例子里，是在SDRAM上，用两个周期传输了两个字的数据。如果换成DDR的话，则可以传输4个字。 </p><p> 即使是在一个命令速率为1的DRAM模块上，也无法立即发出预充电命令，而要等数据传输完成。在上图中，即为两个周期。刚好与CL相同，但只是巧合而已。预充电信号并没有专用线，某些实现是用同时降低写使能(WE)线和RAS线的方式来触发。这一组合方式本身没有特殊的意义(参见[micronddr])。 </p> <p> 发出预充电信命令后，还需等待<span style="font-family:微软雅黑, Verdana, sans-serif, 宋体;line-height:21px;background-color:#F6F6F6;">t</span><sub>RP</sub>(行预充电时间)个周期之后才能使行被选中。在图2.9中，这个时间<span>(紫色部分)</span>大部分与内存传输的时间(淡蓝色部分)重合。不错。但<span style="font-family:微软雅黑, Verdana, sans-serif, 宋体;line-height:21px;background-color:#F6F6F6;">t</span><sub>RP</sub>大于传输时间，因此下一个RAS信号只能等待一个周期。<span></span> </p><p> 如果我们补充完整上图中的时间线，最后会发现下一次数据传输发生在前一次的5个周期之后。这意味着，数据总线的7个周期中只有2个周期才是真正在用的。再用它乘于FSB速度，结果就是，800MHz总线的理论速率6.4GB/s降到了1.8GB/s。真是太糟了。第6节将介绍一些技术，可以帮助我们提高总线有效速率。程序员们也需要尽自己的努力。 </p> <p> SDRAM还有一些定时值，我们并没有谈到。在图2.9中，预充电命令仅受制于数据传输时间。除此之外，SDRAM模块在RAS信号之后，需要经过一段时间，才能进行预充电(记为<span style="font-family:微软雅黑, Verdana, sans-serif, 宋体;line-height:21px;background-color:#F6F6F6;">t</span><sub>RAS</sub>)。它的值很大，一般达到<span style="font-family:微软雅黑, Verdana, sans-serif, 宋体;line-height:21px;background-color:#F6F6F6;">t</span><sub>RP</sub>的2到3倍。如果在某个RAS信号之后，只有一个CAS信号，而且数据只传输很少几个周期，那么就有问题了。假设在图2.9中，第一个CAS信号是直接跟在一个RAS信号后免的，而<span style="font-family:微软雅黑, Verdana, sans-serif, 宋体;line-height:21px;background-color:#F6F6F6;">t</span><sub>RAS</sub>为<span></span>8个周期。那么预充电命令还需要被推迟一个周期，因为<span style="font-family:微软雅黑, Verdana, sans-serif, 宋体;line-height:21px;background-color:#F6F6F6;">t</span><sub>RCD</sub>、CL和<span style="font-family:微软雅黑, Verdana, sans-serif, 宋体;line-height:21px;background-color:#F6F6F6;">t</span><sub>RP</sub>加起来才7个周期。 </p><p> DDR模块往往用w-z-y-z-T来表示。例如，2-3-2-8-T1，意思是： </p> <blockquote>  w 2 CAS时延(CL)  <br> x 3 RAS-to-CAS时延(t  <sub>RCD</sub>)  <br> y 2 RAS预充电时间(t  <sub>RP</sub>)  <br> z 8 激活到预充电时间(t  <sub>RAS</sub>)  <br> T T1 命令速率 </blockquote> <p> 当然，除以上的参数外，还有许多其它参数影响命令的发送与处理。但以上5个参数已经足以确定模块的性能。 </p> <p> 在解读计算机性能参数时，这些信息可能会派上用场。而在购买计算机时，这些信息就更有用了，因为它们与FSB/SDRAM速度一起，都是决定计算机速度的关键因素。 </p> <p> 喜欢冒险的读者们还可以利用它们来调优系统。有些计算机的BIOS可以让你修改这些参数。SDRAM模块有一些可编程寄存器，可供设置参数。BIOS一般会挑选最佳值。如果RAM模块的质量足够好，我们可以在保持系统稳定的前提下将减小以上某个时延参数。互联网上有大量超频网站提供了相关的文档。不过，这是有风险的，需要大家自己承担，可别怪我没有事先提醒哟。 </p><h4> 2.2.3 重充电 </h4> <p> 谈到DRAM的访问时，重充电是常常被忽略的一个主题。在2.1.2中曾经介绍，DRAM必须保持刷新。……行在充电时是无法访问的。[highperfdram]的研究发现，“令人吃惊，DRAM刷新对性能有着巨大的影响”。 </p> <p> 根据JEDEC规范，DRAM单元必须保持每64ms刷新一次。对于8192行的DRAM，这意味着内存控制器平均每7.8125&micro;s就需要发出一个刷新命令(在实际情况下，由于刷新命令可以纳入队列，因此这个时间间隔可以更大一些)。刷新命令的调度由内存控制器负责。DRAM模块会记录上一次刷新行的地址，然后在下次刷新请求时自动对这个地址进行递增。 </p> <p> 对于刷新及发出刷新命令的时间点，程序员无法施加影响。但我们在解读性能参数时有必要知道，它也是DRAM生命周期的一个部分。如果系统需要读取某个重要的字，而刚好它所在的行正在刷新，那么处理器将会被延迟很长一段时间。刷新的具体耗时取决于DRAM模块本身。 </p><h4> 2.2.4 内存类型 </h4> <p> 我们有必要花一些时间来了解一下目前流行的内存，以及那些即将流行的内存。首先从SDR(单倍速)SDRAM开始，因为它们是DDR(双倍速)SDRAM的基础。SDR非常简单，内存单元和数据传输率是相等的。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/06104433_JWAj.png">  <br> 图2.10: SDR SDRAM的操作 </blockquote> <p> 在图2.10中，DRAM单元阵列能以等同于内存总线的速率输出内容。假设DRAM单元阵列工作在100MHz上，那么总线的数据传输率可以达到100Mb/s。所有组件的频率<em>f</em>保持相同。由于提高频率会导致耗电量增加，所以提高吞吐量需要付出很高的的代价。如果是很大规模的内存阵列，代价会非常巨大。{<em>功率 = 动态电容 x 电压</em><sup><em>2</em></sup><em> x 频率</em>}。而且，提高频率还需要在保持系统稳定的情况下提高电压，这更是一个问题。因此，就有了DDR SDRAM(现在叫DDR1)，它可以在不提高频率的前提下提高吞吐量。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/06104433_A6Jf.png">  <br> 图2.11 DDR1 SDRAM的操作 </blockquote><p> 我们从图2.11上可以看出DDR1与SDR的不同之处，也可以从DDR1的名字里猜到那么几分，DDR1的每个周期可以传输两倍的数据，它的上升沿和下降沿都传输数据。有时又被称为“双泵(double-pumped)”总线。为了在不提升频率的前提下实现双倍传输，DDR引入了一个缓冲区。缓冲区的每条数据线都持有两位。它要求内存单元阵列的数据总线包含两条线。实现的方式很简单，用同一个列地址同时访问两个DRAM单元。对单元阵列的修改也很小。 </p> <p> SDR DRAM是以频率来命名的(例如，对应于100MHz的称为PC100)。为了让DDR1听上去更好听，营销人员们不得不想了一种新的命名方案。这种新方案中含有DDR模块可支持的传输速率(DDR拥有64位总线): </p> <blockquote>  100MHz x 64位 x 2 = 1600MB/s </blockquote><p> 于是，100MHz频率的DDR模块就被称为PC1600。由于1600 &gt; 100，营销方面的需求得到了满足，听起来非常棒，但实际上仅仅只是提升了两倍而已。{我接受两倍这个事实，但不喜欢类似的数字膨胀戏法。} </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/06104433_pulx.png">  <br>  <strong>图2.12: DDR2 SDRAM的操作</strong> </blockquote> <p> 为了更进一步，DDR2有了更多的创新。在图2.12中，最明显的变化是，总线的频率加倍了。频率的加倍意味着带宽的加倍。如果对单元阵列的频率加倍，显然是不经济的，因此DDR2要求I/O缓冲区在每个时钟周期读取4位。也就是说，DDR2的变化仅在于使I/O缓冲区运行在更高的速度上。这是可行的，而且耗电也不会显著增加。DDR2的命名与DDR1相仿，只是将因子2替换成4(四泵总线)。图2.13显示了目前常用的一些模块的名称。 </p> <blockquote>  <table border="1">   <tbody>    <tr>     <th> 阵列频率 </th>     <th> 总线频率 </th>     <th> 数据率 </th>     <th> 名称(速率) </th>     <th> 名称<br> (FSB) </th>    </tr>    <tr>     <td> 133MHz </td>     <td> 266MHz </td>     <td> 4,256MB/s </td>     <td> PC2-4200 </td>     <td> DDR2-533 </td>    </tr>    <tr>     <td> 166MHz </td>     <td> 333MHz </td>     <td> 5,312MB/s </td>     <td> PC2-5300 </td>     <td> DDR2-667 </td>    </tr>    <tr>     <td> 200MHz </td>     <td> 400MHz </td>     <td> 6,400MB/s </td>     <td> PC2-6400 </td>     <td> DDR2-800 </td>    </tr>    <tr>     <td> 250MHz </td>     <td> 500MHz </td>     <td> 8,000MB/s </td>     <td> PC2-8000 </td>     <td> DDR2-1000 </td>    </tr>    <tr>     <td> 266MHz </td>     <td> 533MHz </td>     <td> 8,512MB/s </td>     <td> PC2-8500 </td>     <td> DDR2-1066 </td>    </tr>   </tbody>  </table>  <br>  <strong>图2.13: DDR2模块名</strong> </blockquote><p> 在命名方面还有一个拧巴的地方。FSB速度是用有效频率来标记的，即把上升、下降沿均传输数据的因素考虑进去，因此数字被撑大了。所以，拥有266MHz总线的133MHz模块有着533MHz的FSB“频率”。 </p> <p> DDR3要求更多的改变(这里指真正的DDR3，而不是图形卡中假冒的GDDR3)。电压从1.8V下降到1.5V。由于耗电是与电压的平方成正比，因此可以节约30%的电力。加上管芯(die)的缩小和电气方面的其它进展，DDR3可以在保持相同频率的情况下，降低一半的电力消耗。或者，在保持相同耗电的情况下，达到更高的频率。又或者，在保持相同热量排放的情况下，实现容量的翻番。 </p><p> DDR3模块的单元阵列将运行在内部总线的四分之一速度上，DDR3的I/O缓冲区从DDR2的4位提升到8位。见图2.14。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/06104433_dVKN.png">  <br>  <strong>图2.14: DDR3 SDRAM的操作</strong> </blockquote> <p> 一开始，DDR3可能会有较高的CAS时延，因为DDR2的技术相比之下更为成熟。由于这个原因，DDR3可能只会用于DDR2无法达到的高频率下，而且带宽比时延更重要的场景。此前，已经有讨论指出，1.3V的DDR3可以达到与DDR2相同的CAS时延。无论如何，更高速度带来的价值都会超过时延增加带来的影响。 </p><p> DDR3可能会有一个问题，即在1600Mb/s或更高速率下，每个通道的模块数可能会限制为1。在早期版本中，这一要求是针对所有频率的。我们希望这个要求可以提高一些，否则系统容量将会受到严重的限制。 </p> <p> 图2.15显示了我们预计中各DDR3模块的名称。JEDEC目前同意了前四种。由于Intel的45nm处理器是1600Mb/s的FSB，1866Mb/s可以用于超频市场。随着DDR3的发展，可能会有更多类型加入。 </p> <blockquote>  <table border="1">   <tbody>    <tr>     <th> 阵列频率 </th>     <th> 总线频率 </th>     <th> 数据速率 </th>     <th> 名称(速率) </th>     <th> 名称<br> (FSB) </th>    </tr>    <tr>     <td> 100MHz </td>     <td> 400MHz </td>     <td> 6,400MB/s </td>     <td> PC3-6400 </td>     <td> DDR3-800 </td>    </tr>    <tr>     <td> 133MHz </td>     <td> 533MHz </td>     <td> 8,512MB/s </td>     <td> PC3-8500 </td>     <td> DDR3-1066 </td>    </tr>    <tr>     <td> 166MHz </td>     <td> 667MHz </td>     <td> 10,667MB/s </td>     <td> PC3-10667 </td>     <td> DDR3-1333 </td>    </tr>    <tr>     <td> 200MHz </td>     <td> 800MHz </td>     <td> 12,800MB/s </td>     <td> PC3-12800 </td>     <td> DDR3-1600 </td>    </tr>    <tr>     <td> 233MHz </td>     <td> 933MHz </td>     <td> 14,933MB/s </td>     <td> PC3-14900 </td>     <td> DDR3-1866<br> <br> </td>    </tr>   </tbody>  </table>  <strong>图2.15: DDR3模块名</strong> </blockquote><p> 所有的DDR内存都有一个问题：不断增加的频率使得建立并行数据总线变得十分困难。一个DDR2模块有240根引脚。所有到地址和数据引脚的连线必须被布置得差不多一样长。更大的问题是，如果多于一个DDR模块通过菊花链连接在同一个总线上，每个模块所接收到的信号随着模块的增加会变得越来越扭曲。DDR2规范允许每条总线（又称通道）连接最多两个模块，DDR3在高频率下只允许每个通道连接一个模块。每条总线多达240根引脚使得单个北桥无法以合理的方式驱动两个通道。替代方案是增加外部内存控制器（如图2.2），但这会提高成本。 </p> <p> 这意味着商品主板所搭载的DDR2或DDR3模块数将被限制在最多四条，这严重限制了系统的最大内存容量。即使是老旧的32位IA-32处理器也可以使用64GB内存。即使是家庭对内存的需求也在不断增长，所以，某些事必须开始做了。 </p><p> 一种解法是，在处理器中加入内存控制器，我们在第2节中曾经介绍过。AMD的Opteron系列和Intel的CSI技术就是采用这种方法。只要我们能把处理器要求的内存连接到处理器上，这种解法就是有效的。如果不能，按照这种思路就会引入NUMA架构，当然同时也会引入它的缺点。而在有些情况下，我们需要其它解法。 </p> <p> Intel针对大型服务器方面的解法(至少在未来几年)，是被称为全缓冲DRAM(FB-DRAM)的技术。FB-DRAM采用与DDR2相同的器件，因此造价低廉。不同之处在于它们与内存控制器的连接方式。FB-DRAM没有用并行总线，而用了串行总线(Rambus DRAM had this back when, too, 而SATA是PATA的继任者，就像PCI Express是PCI/AGP的继承人一样)。串行总线可以达到更高的频率，串行化的负面影响，甚至可以增加带宽。使用串行总线后 </p> <ol>  <li> <span style="line-height:1.5;font-size:10pt;">每个通道可以使用更多的模块。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">每个北桥/内存控制器可以使用更多的通道。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">串行总线是全双工的(两条线)。</span> </li> </ol><p> FB-DRAM只有69个脚。通过菊花链方式连接多个FB-DRAM也很简单。FB-DRAM规范允许每个通道连接最多8个模块。 </p> <p> 在对比下双通道北桥的连接性，采用FB-DRAM后，北桥可以驱动6个通道，而且脚数更少——6x69对比2x240。每个通道的布线也更为简单，有助于降低主板的成本。 </p> <p> 全双工的并行总线过于昂贵。而换成串行线后，这不再是一个问题，因此串行总线按全双工来设计的，这也意味着，在某些情况下，仅靠这一特性，总线的理论带宽已经翻了一倍。还不止于此。由于FB-DRAM控制器可同时连接6个通道，因此可以利用它来增加某些小内存系统的带宽。对于一个双通道、4模块的DDR2系统，我们可以用一个普通FB-DRAM控制器，用4通道来实现相同的容量。串行总线的实际带宽取决于在FB-DRAM模块中所使用的DDR2(或DDR3)芯片的类型。 </p><p> 我们可以像这样总结这些优势： </p> <blockquote>  DDR2 FB-DRAM </blockquote><blockquote>  <table border="1">   <tbody>    <tr>     <th> <br> </th>     <th> DDR2 </th>     <th> FB-DRAM </th>    </tr>    <tr>     <td> 脚 </td>     <td> 240 </td>     <td> 69 </td>    </tr>    <tr>     <td> 通道 </td>     <td> 2 </td>     <td> 6 </td>    </tr>    <tr>     <td> 每通道DIMM数 </td>     <td> 2 </td>     <td> 8 </td>    </tr>    <tr>     <td> 最大内存 </td>     <td> 16GB </td>     <td> 192GB </td>    </tr>    <tr>     <td> 吞吐量 </td>     <td> ~10GB/s </td>     <td> ~40GB/s </td>    </tr>   </tbody>  </table> </blockquote> 如果在单个通道上使用多个DIMM，会有一些问题。信号在每个DIMM上都会有延迟(尽管很小)，也就是说，延迟是递增的。不过，如果在相同频率和相同容量上进行比较，FB-DRAM总是能快过DDR2及DDR3，因为FB-DRAM只需要在每个通道上使用一个DIMM即可。而如果说到大型内存系统，那么DDR更是没有商用组件的解决方案。<h4> 2.2.5 结论 </h4> <p> 通过本节，大家应该了解到访问DRAM的过程并不是一个快速的过程。至少与处理器的速度相比，或与处理器访问寄存器及缓存的速度相比，DRAM的访问不算快。大家还需要记住CPU和内存的频率是不同的。Intel Core 2处理器运行在2.933GHz，而1.066GHz FSB有11:1的时钟比率(注: 1.066GHz的总线为四泵总线)。那么，内存总线上延迟一个周期意味着处理器延迟11个周期。绝大多数机器使用的DRAM更慢，因此延迟更大。在后续的章节中，我们需要讨论延迟这个问题时，请把以上的数字记在心里。 </p> <p> 前文中读命令的时序图表明，DRAM模块可以支持高速数据传输。每个完整行可以被毫无延迟地传输。数据总线可以100%被占。对DDR而言，意味着每个周期传输2个64位字。对于DDR2-800模块和双通道而言，意味着12.8GB/s的速率。 </p> <p> 但是，除非是特殊设计，DRAM的访问并不总是串行的。访问不连续的内存区意味着需要预充电和RAS信号。于是，各种速度开始慢下来，DRAM模块急需帮助。预充电的时间越短，数据传输所受的惩罚越小。 </p> <p> 硬件和软件的预取(参见第6.3节)可以在时序中制造更多的重叠区，降低延迟。预取还可以转移内存操作的时间，从而减少争用。我们常常遇到的问题是，在这一轮中生成的数据需要被存储，而下一轮的数据需要被读出来。通过转移读取的时间，读和写就不需要同时发出了。 </p><h3> 2.3 主存的其它用户 </h3> <p> 除了CPU外，系统中还有其它一些组件也可以访问主存。高性能网卡或大规模存储控制器是无法承受通过CPU来传输数据的，它们一般直接对内存进行读写(直接内存访问，DMA)。在图2.1中可以看到，它们可以通过南桥和北桥直接访问内存。另外，其它总线，比如USB等也需要FSB带宽，即使它们并不使用DMA，但南桥仍要通过FSB连接到北桥。 </p> <p> DMA当然有很大的优点，但也意味着FSB带宽会有更多的竞争。在有大量DMA流量的情况下，CPU在访问内存时必然会有更大的延迟。我们可以用一些硬件来解决这个问题。例如，通过图2.3中的架构，我们可以挑选不受DMA影响的节点，让它们的内存为我们的计算服务。还可以在每个节点上连接一个南桥，将FSB的负荷均匀地分担到每个节点上。除此以外，还有许多其它方法。我们将在第6节中介绍一些技术和编程接口，它们能够帮助我们通过软件的方式改善这个问题。 </p><p> 最后，还需要提一下某些廉价系统，它们的图形系统没有专用的显存，而是采用主存的一部分作为显存。由于对显存的访问非常频繁(例如，对于1024x768、16bpp、60Hz的显示设置来说，需要95MB/s的数据速率)，而主存并不像显卡上的显存，并没有两个端口，因此这种配置会对系统性能、尤其是时延造成一定的影响。如果大家对系统性能要求比较高，最好不要采用这种配置。这种系统带来的问题超过了本身的价值。人们在购买它们时已经做好了性能不佳的心理准备。 </p> <p> 继续阅读： </p> <ul>  <li> <span style="line-height:1.5;font-size:10pt;"><span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvMjUyMTI1Lw==" title="http://lwn.net/Articles/252125/">第2节<i class="fa fa-external-link"></i></span>: CPU的高速缓存</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvMjUzMzYxLw==" title="http://lwn.net/Articles/253361/">第3节<i class="fa fa-external-link"></i></span>: 虚拟内存</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvMjU0NDQ1Lw==" title="http://lwn.net/Articles/254445/">第4节<i class="fa fa-external-link"></i></span>: NUMA系统</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvMjU1MzY0Lw==" title="http://lwn.net/Articles/255364/">第5节<i class="fa fa-external-link"></i></span>: 程序员可以做什么 - 高速缓存的优化</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvMjU2NDMzLw==" title="http://lwn.net/Articles/256433/">第6节<i class="fa fa-external-link"></i></span>: </span><span style="line-height:1.5;font-size:10pt;">程序员可以做什么</span><span style="line-height:1.5;font-size:10pt;"> - 多线程的优化</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvMjU3MjA5Lw==" title="http://lwn.net/Articles/257209/">第7节<i class="fa fa-external-link"></i></span>: 内存性能工具</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvMjU4MTU0Lw==" title="http://lwn.net/Articles/258154/">第8节<i class="fa fa-external-link"></i></span>: 未来的技术</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvMjU4MTg4Lw==" title="http://lwn.net/Articles/258188/">第9节<i class="fa fa-external-link"></i></span>: 附录与参考书目</span> </li> </ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt; &lt;strong&gt;1 简介&lt;/strong&gt; &lt;/h2&gt; 
&lt;p&gt; 早期计算机比现在更为简单。系统的各种组件例如CPU，内存，大容量存储器和网口，由于被共同开发因而有非常均衡的表现。例如，内存和网口并不比CPU在提供数据的时候更（特别的）快。 &lt;/p&gt; 
&lt;p&gt; 曾今计算
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/nosql/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/nosql/</id>
    <published>2019-06-14T02:52:59.709Z</published>
    <updated>2019-06-14T02:52:59.709Z</updated>
    
    <content type="html"><![CDATA[<p>导读：Kristóf Kovács 是一位软件架构师和咨询顾问，他最近发布了一片对比各种类型NoSQL数据库的文章。</p><p>虽然SQL数据库是非常有用的工具，但经历了15年的一支独秀之后垄断即将被打破。这只是时间问题：被迫使用关系数据库，但最终发现不能适应需求的情况不胜枚举。</p><p>但是NoSQL数据库之间的不同，远超过两 SQL数据库之间的差别。这意味着软件架构师更应该在项目开始时就选择好一个适合的 NoSQL数据库。针对这种情况，这里对 <span class="exturl" data-url="aHR0cDovL2Nhc3NhbmRyYS5hcGFjaGUub3JnLw==" title="http://cassandra.apache.org/">Cassandra<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cDovL3d3dy5tb25nb2RiLm9yZy8=" title="http://www.mongodb.org/">Mongodb<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cDovL2NvdWNoZGIuYXBhY2hlLm9yZy8=" title="http://couchdb.apache.org/">CouchDB<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cDovL3JlZGlzLmlvLw==" title="http://redis.io/">Redis<i class="fa fa-external-link"></i></span>、 <span class="exturl" data-url="aHR0cDovL3d3dy5iYXNoby5jb20vUmlhay5odG1s" title="http://www.basho.com/Riak.html">Riak<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cDovL3d3dy5jb3VjaGJhc2Uub3JnL21lbWJhc2U=" title="http://www.couchbase.org/membase">Membase<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cDovL25lbzRqLm9yZy8=" title="http://neo4j.org/">Neo4j<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cDovL2hiYXNlLmFwYWNoZS5vcmcv" title="http://hbase.apache.org/">HBase<i class="fa fa-external-link"></i></span> 进行了比较：</p><p>（编注1：NoSQL：是一项全新的数据库革命性运动，NoSQL的拥护者们提倡运用非关系型的数据存储。现今的计算机体系结构在数据存储方面要求具 备庞大的水平扩 展性，而NoSQL致力于改变这一现状。目前Google的 BigTable 和Amazon 的Dynamo使用的就是NoSQL型数据库。 参见<span class="exturl" data-url="aHR0cDovL3poLndpa2lwZWRpYS5vcmcvemgvTm9TUUw=" title="http://zh.wikipedia.org/zh/NoSQL">NoSQL词条<i class="fa fa-external-link"></i></span>。）</p><p>&nbsp;</p><p><strong>1. CouchDB</strong></p><ul><li>所用语言： Erlang</li><li>特点：DB一致性，易于使用</li><li>使用许可： Apache</li><li>协议： HTTP/REST</li><li>双向数据复制，</li><li>持续进行或临时处理，</li><li>处理时带冲突检查，</li><li>因此，采用的是master-master复制（见编注2）</li><li>MVCC &#8211; 写操作不阻塞读操作</li><li>可保存文件之前的版本</li><li>Crash-only（可靠的）设计</li><li>需要不时地进行数据压缩</li><li>视图：嵌入式 映射/减少</li><li>格式化视图：列表显示</li><li>支持进行服务器端文档验证</li><li>支持认证</li><li>根据变化实时更新</li><li>支持附件处理</li><li>因此， CouchApps（独立的 js应用程序）</li><li>需要 jQuery程序库</li></ul><p>&nbsp;</p><p><strong>最佳应用场景：</strong>适用于数据变化较少，执行预定义查询，进行数据统计的应用程序。适用于需要提供数据版本支持的应用程序。</p><p><strong>例如：</strong> CRM、CMS系统。 master-master复制对于多站点部署是非常有用的。</p><p>（编注2：master-master复制：是一种数据库同步方法，允许数据在一组计算机之间共享数据，并且可以通过小组中任意成员在组内进行数据更新。）</p><p>&nbsp;</p><p><strong>2. Redis</strong></p><ul><li>所用语言：C/C++</li><li>特点：运行异常快</li><li>使用许可： BSD</li><li>协议：类 Telnet</li><li>有硬盘存储支持的内存数据库，</li><li>但自2.0版本以后可以将数据交换到硬盘（注意， 2.4以后版本不支持该特性！）</li><li>Master-slave复制（见编注3）</li><li>虽然采用简单数据或以键值索引的哈希表，但也支持复杂操作，例如 ZREVRANGEBYSCORE。</li><li>INCR &amp; co （适合计算极限值或统计数据）</li><li>支持 sets（同时也支持 union/diff/inter）</li><li>支持列表（同时也支持队列；阻塞式 pop操作）</li><li>支持哈希表（带有多个域的对象）</li><li>支持排序 sets（高得分表，适用于范围查询）</li><li>Redis支持事务</li><li>支持将数据设置成过期数据（类似快速缓冲区设计）</li><li>Pub/Sub允许用户实现消息机制</li></ul><p>&nbsp;</p><p><strong>最佳应用场景：</strong>适用于数据变化快且数据库大小可遇见（适合内存容量）的应用程序。</p><p><strong>例如：</strong>股票价格、数据分析、实时数据搜集、实时通讯。</p><p>（编注3：Master-slave复制：如果同一时刻只有一台服务器处理所有的复制请求，这被称为 Master-slave复制，通常应用在需要提供高可用性的服务器集群。）</p><p>&nbsp;</p><p><strong>3. MongoDB</strong></p><ul><li>所用语言：C++</li><li>特点：保留了SQL一些友好的特性（查询，索引）。</li><li>使用许可： AGPL（发起者： Apache）</li><li>协议： Custom, binary（ BSON）</li><li>Master/slave复制（支持自动错误恢复，使用 sets 复制）</li><li>内建分片机制</li><li>支持 javascript表达式查询</li><li>可在服务器端执行任意的 javascript函数</li><li>update-in-place支持比CouchDB更好</li><li>在数据存储时采用内存到文件映射</li><li>对性能的关注超过对功能的要求</li><li>建议最好打开日志功能（参数 &#8211;journal）</li><li>在32位操作系统上，数据库大小限制在约2.5Gb</li><li>空数据库大约占 192Mb</li><li>采用 GridFS存储大数据或元数据（不是真正的文件系统）</li></ul><p>&nbsp;</p><p><strong>最佳应用场景：</strong>适用于需要动态查询支持；需要使用索引而不是 map/reduce功能；需要对大数据库有性能要求；需要使用 CouchDB但因为数据改变太频繁而占满内存的应用程序。</p><p><strong>例如：</strong>你本打算采用 MySQL或 PostgreSQL，但因为它们本身自带的预定义栏让你望而却步。</p><p>&nbsp;</p><p><strong>4. Riak</strong></p><ul><li>所用语言：Erlang和C，以及一些Javascript</li><li>特点：具备容错能力</li><li>使用许可： Apache</li><li>协议： HTTP/REST或者 custom binary</li><li>可调节的分发及复制(N, R, W)</li><li>用 JavaScript or Erlang在操作前或操作后进行验证和安全支持。</li><li>使用JavaScript或Erlang进行 Map/reduce</li><li>连接及连接遍历：可作为图形数据库使用</li><li>索引：输入元数据进行搜索（1.0版本即将支持）</li><li>大数据对象支持（ Luwak）</li><li>提供“开源”和“企业”两个版本</li><li>全文本搜索，索引，通过 Riak搜索服务器查询（ beta版）</li><li>支持Masterless多站点复制及商业许可的 SNMP监控</li></ul><p>&nbsp;</p><p><strong>最佳应用场景：</strong>适用于想使用类似 Cassandra（类似Dynamo）数据库但无法处理 bloat及复杂性的情况。适用于你打算做多站点复制，但又需要对单个站点的扩展性，可用性及出错处理有要求的情况。</p><p>例如：销售数据搜集，工厂控制系统；对宕机时间有严格要求；可以作为易于更新的 web服务器使用。</p><p><strong>5. Membase</strong></p><ul><li>所用语言： Erlang和C</li><li>特点：兼容 Memcache，但同时兼具持久化和支持集群</li><li>使用许可： Apache 2.0</li><li>协议：分布式缓存及扩展</li><li>非常快速（200k+/秒），通过键值索引数据</li><li>可持久化存储到硬盘</li><li>所有节点都是唯一的（ master-master复制）</li><li>在内存中同样支持类似分布式缓存的缓存单元</li><li>写数据时通过去除重复数据来减少 IO</li><li>提供非常好的集群管理 web界面</li><li>更新软件时软无需停止数据库服务</li><li>支持连接池和多路复用的连接代理</li></ul><p>&nbsp;</p><p><strong>最佳应用场景：</strong>适用于需要低延迟数据访问，高并发支持以及高可用性的应用程序</p><p>例如：低延迟数据访问比如以广告为目标的应用，高并发的 web 应用比如网络游戏（例如 Zynga）</p><p>&nbsp;</p><p><strong>6. Neo4j</strong></p><ul><li>所用语言： Java</li><li>特点：基于关系的图形数据库</li><li>使用许可： GPL，其中一些特性使用 AGPL/商业许可</li><li>协议： HTTP/REST（或嵌入在 Java中）</li><li>可独立使用或嵌入到 Java应用程序</li><li>图形的节点和边都可以带有元数据</li><li>很好的自带web管理功能</li><li>使用多种算法支持路径搜索</li><li>使用键值和关系进行索引</li><li>为读操作进行优化</li><li>支持事务（用 Java api）</li><li>使用 Gremlin图形遍历语言</li><li>支持 Groovy脚本</li><li>支持在线备份，高级监控及高可靠性支持使用 AGPL/商业许可</li></ul><p>&nbsp;</p><p><strong>最佳应用场景：</strong>适用于图形一类数据。这是 Neo4j与其他nosql数据库的最显著区别</p><p>例如：社会关系，公共交通网络，地图及网络拓谱</p><p>&nbsp;</p><p><strong>7. Cassandra</strong></p><ul><li>所用语言： Java</li><li>特点：对大型表格和 Dynamo支持得最好</li><li>使用许可： Apache</li><li>协议： Custom, binary (节约型)</li><li>可调节的分发及复制(N, R, W)</li><li>支持以某个范围的键值通过列查询</li><li>类似大表格的功能：列，某个特性的列集合</li><li>写操作比读操作更快</li><li>基于 Apache分布式平台尽可能地 Map/reduce</li><li>我承认对 Cassandra有偏见，一部分是因为它本身的臃肿和复杂性，也因为 Java的问题（配置，出现异常，等等）</li></ul><p>&nbsp;</p><p><strong>最佳应用场景：</strong>当使用写操作多过读操作（记录日志）如果每个系统组建都必须用 Java编写（没有人因为选用 Apache的软件被解雇）</p><p>例如：银行业，金融业（虽然对于金融交易不是必须的，但这些产业对数据库的要求会比它们更大）写比读更快，所以一个自然的特性就是实时数据分析</p><p>&nbsp;</p><p><strong>8. HBase</strong></p><p>（配合 ghshephard使用）</p><ul><li>所用语言： Java</li><li>特点：支持数十亿行X上百万列</li><li>使用许可： Apache</li><li>协议：HTTP/REST （支持 <span class="exturl" data-url="aHR0cDovL3d3dy5qb2Jib2xlLmNvbS9lbnRyeS5waHAvNzM=" title="http://www.jobbole.com/entry.php/73">Thrift<i class="fa fa-external-link"></i></span>，见编注4）</li><li>在 BigTable之后建模</li><li>采用分布式架构 Map/reduce</li><li>对实时查询进行优化</li><li>高性能 Thrift网关</li><li>通过在server端扫描及过滤实现对查询操作预判</li><li>支持 XML, Protobuf, 和binary的HTTP</li><li>Cascading, hive, and pig source and sink modules</li><li>基于 Jruby（ JIRB）的shell</li><li>对配置改变和较小的升级都会重新回滚</li><li>不会出现单点故障</li><li>堪比MySQL的随机访问性能</li></ul><p>&nbsp;</p><p><strong>最佳应用场景：</strong>适用于偏好BigTable:)并且需要对大数据进行随机、实时访问的场合。</p><p>例如： Facebook消息数据库（更多通用的用例即将出现）</p><p>编注4：Thrift 是一种接口定义语言，为多种其他语言提供定义和创建服务，<span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vNzMv" title="http://blog.jobbole.com/73/">由Facebook开发并开源<i class="fa fa-external-link"></i></span>。</p><p>当然，所有的系统都不只具有上面列出的这些特性。这里我仅仅根据自己的观点列出一些我认为的重要特性。与此同时，技术进步是飞速的，所以上述的内容肯定需要不断更新。我会尽我所能地更新这个列表。</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;导读：Kristóf Kovács 是一位软件架构师和咨询顾问，他最近发布了一片对比各种类型NoSQL数据库的文章。&lt;/p&gt;
&lt;p&gt;虽然SQL数据库是非常有用的工具，但经历了15年的一支独秀之后垄断即将被打破。这只是时间问题：被迫使用关系数据库，但最终发现不能适应需求的情况
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/picture-server/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/picture-server/</id>
    <published>2019-06-14T02:52:59.709Z</published>
    <updated>2019-06-14T02:52:59.709Z</updated>
    
    <content type="html"><![CDATA[<p>现在几乎任何一个网站、Web App以及移动APP等应用都需要有图片展示的功能，对于图片功能从下至上都是很重要的。必须要具有前瞻性的规划好图片服务器，图片的上传和下载速度至关重要，当然这并不是说一上来就搞很NB的架构，至少具备一定扩展性和稳定性。虽然各种架构设计都有，在这里我只是谈谈我的一些个人想法。</p><p><span id="more-967"></span></p><p>&nbsp;</p><p>对于图片服务器来说IO无疑是消耗资源最为严重的，对于web应用来说需要将图片服务器做一定的分离，否则很可能因为图片服务器的IO负载导致应用崩溃。因此尤其对于大型网站和应用来说，非常有必要将图片服务器和应用服务器分离，构建独立的图片服务器集群，构建独立的图片服务器其主要优势：</p><p>1）分担Web服务器的I/O负载-将耗费资源的图片服务分离出来，提高服务器的性能和稳定性。</p><p>2）能够专门对图片服务器进行优化-为图片服务设置有针对性的缓存方案，减少带宽网络成本，提高访问速度。</p><p>3）提高网站的可扩展性-通过增加图片服务器，提高图片服务吞吐能力。</p><p>&nbsp;</p><p>从传统互联网的web1.0，历经web2.0时代以及发展到现在的web3.0，随着图片存储规模的增加，图片服务器的架构也在逐渐发生变化，以下主要论述三个阶段的图片服务器架构演进。</p><p>&nbsp;</p><p><strong> 初始阶段</strong></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuYWxpeXVuLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNi8xNy5wbmc=" title="http://blog.aliyun.com/wp-content/uploads/2014/06/17.png"><img class="alignnone  wp-image-968" alt="1" src="http://blog.aliyun.com/wp-content/uploads/2014/06/17.png" width="492" height="224"><i class="fa fa-external-link"></i></span></p><p>在介绍初始阶段的早期的小型图片服务器架构之前，首先让我们了解一下NFS技术，NFS是Network File System的缩写，即网络文件系统。NFS是由Sun开发并发展起来的一项用于在不同机器，不同操作系统之间通过网络互相分享各自的文件。NFS server也可以看作是一个FILE SERVER,用于在UNIX类系统之间共享文件，可以轻松的挂载(mount)到一个目录上，操作起来就像本地文件一样的方便。</p><p>&nbsp;</p><p>如果不想在每台图片服务器同步所有图片，那么NFS是最简单的文件共享方式。NFS是个分布式的客户机/服务器文件系统，NFS的实质在于用户间计算机的共享，用户可以联结到共享计算机并象访问本地硬盘一样访问共享计算机上的文件。具体实现思路是：</p><p>&nbsp;</p><p>1)所有前端web服务器都通过nfs挂载3台图片服务器export出来的目录，以接收web服务器写入的图片。然后[图片1]服务器挂载另外两台图片服务器的export目录到本地给apache对外提供访问。<br>2） 用户上传图片<br>用户通过Internet访问页面提交上传请求post到web服务器，web服务器处理完图片后由web服务器拷贝到对应的mount本地目录。<br>3）用户访问图片<br>用户访问图片时，通过[图片1]这台图片服务器来读取相应mount目录里边的图片。</p><p>&nbsp;</p><p>以上架构存在的问题：</p><p>1）性能：现有结构过度依赖nfs,当图片服务器的nfs服务器有问题时，可能影响到前端web服务器。NFS的问题主要是锁的问题. 很容易造成死锁, 只有硬件重启才能解决。尤其当图片达到一定的量级后，nfs会有严重的性能问题。<br>2）高可用：对外提供下载的图片服务器只有一台，容易出现单点故障。<br>3） 扩展性：图片服务器之间的依赖过多，而且横向扩展余地不够。<br>4） 存储：web服务器上传热点不可控，造成现有图片服务器空间占用不均衡。<br>5） 安全性：nfs方式对于拥有web服务器的密码的人来说，可以随意修改nfs里边的内容，安全级别不高。</p><p>&nbsp;</p><p>当然图片服务器的图片同步可以不采用NFS,也可以采用ftp或rsync，采用ftp这样的话每个图片服务器就都保存一份图片的副本，也起到了备份的作用。但是缺点是将图片ftp到服务器比较耗时，如果使用异步方式去同步图片的话又会有延时，不过一般的小图片文件也还好了。使用rsync同步，当数据文件达到一定的量级后，每次rsync扫描会耗时很久也会带来一定的延时性。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>发展阶段</strong></p><p>&nbsp;</p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuYWxpeXVuLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNi8yMy5wbmc=" title="http://blog.aliyun.com/wp-content/uploads/2014/06/23.png"><img class="alignnone  wp-image-969" alt="2" src="http://blog.aliyun.com/wp-content/uploads/2014/06/23.png" width="478" height="224"><i class="fa fa-external-link"></i></span></p><p>&nbsp;</p><p>当网站达到一定的规模后，对图片服务器的性能和稳定性有一定的要求后，上述NFS图片服务架构面临着挑战，严重的依赖NFS,而且系统存在单点机器容易出现故障，需要对整体架构进行升级。于是出现了上图图片服务器架构，出现了分布式的图片存储。</p><p>&nbsp;</p><p>其实现的具体思路如下：</p><p>1）用户上传图片到web服务器后，web服务器处理完图片，然后再由前端web服务器把图片post到到[图片1]、[图片2]&#8230;[图片N]其中的一个，图片服务器接收到post过来的图片，然后把图片写入到本地磁盘并返回对应成功状态码。前端web服务器根据返回状态码决定对应操作，如果成功的话，处理生成各尺寸的缩略图、打水印，把图片服务器对应的ID和对应图片路径写入DB数据库。<br>2) 上传控制<br>我们需要调节上传时，只需要修改web服务器post到的目的图片服务器的ID，就可以控制上传到哪台图片存储服务器,对应的图片存储服务器只需要安装nginx同时提供一个python或者php服务接收并保存图片，如果不想不想开启python或者php服务，也可以编写一个nginx扩展模块。</p><p>3) 用户访问流程<br>用户访问页面的时候，根据请求图片的URL到对应图片服务器去访问图片。</p><p>如： http://imgN.xxx.com/image1.jpg</p><p>&nbsp;</p><p>此阶段的图片服务器架构，增加了负载均衡和分布式图片存储，能够在一定程度上解决并发访问量高和存储量大的问题。负载均衡在有一定财力的情况下可以考虑F5硬负载，当然也可以考虑使用开源的LVS软负载(同时还可开启缓存功能)。此时将极大提升访问的并发量，可以根据情况随时调配服务器。当然此时也存在一定的瑕疵，那就是可能在多台Squid上存在同一张图片，因为访问图片时可能第一次分到squid1，在LVS过期后第二次访问到squid2或者别的，当然相对并发问题的解决，此种少量的冗余完全在我们的允许范围之内。在该系统架构中二级缓存可以使用squid也可以考虑使用varnish或者traffic server，对于cache的开源软件选型要考率以下几点</p><p>&nbsp;</p><p>1）性能：varnish本身的技术上优势要高于squid，它采用了“Visual Page Cache”技术，在内存的利用上，Varnish比Squid具有优势，它避免了Squid频繁在内存、磁盘中交换文件，性能要比Squid高。varnish是不能cache到本地硬盘上的。还有强大的通过Varnish管理端口，可以使用正则表达式快速、批量地清除部分缓存。nginx是用第三方模块ncache做的缓冲，其性能基本达到varnish，但在架构中nginx一般作为反向（静态文件现在用nginx的很多，并发能支持到2万+）。在静态架构中，如果前端直接面对的是cdn活着前端了4层负载的话，完全用nginx的cache就够了。</p><p>&nbsp;</p><p>2）避免文件系统式的缓存，在文件数据量非常大的情况下，文件系统的性能很差，像squid,nginx的proxy_store,proxy_cache之类的方式缓存，当缓存的量级上来后，性能将不能满足要求。开源的traffic server直接用裸盘缓存，是一个不错的选择，国内大规模应用并公布出来的主要是淘宝，并不是因为它做的差，而是开源时间晚。Traffic Server 在 Yahoo 内部使用了超过 4 年，主要用于 CDN 服务，CDN 用于分发特定的HTTP 内容，通常是静态的内容如图片、JavaScript、CSS。当然使用leveldb之类的做缓存，我估计也能达到很好的效果。</p><p>&nbsp;</p><p>3）稳定性：squid作为老牌劲旅缓存，其稳定性更可靠一些，从我身边一些使用者反馈来看varnish偶尔会出现crash的情况。Traffic Server在雅虎目前使用期间也没有出现已知的数据损坏情况，其稳定性相对也比较可靠，对于未来我其实更期待Traffic Server在国内能够拥有更多的用户。</p><p align="left">        以上图片服务架构设计消除了早期的NFS依赖以及单点问题，时能够均衡图片服务器的空间，提高了图片服务器的安全性等问题，但是又带来一个问题是图片服务器的横向扩展冗余问题。只想在普通的硬盘上存储，首先还是要考虑一下物理硬盘的实际处理能力。是 7200 转的还是 15000 转的，实际表现差别就很大。至于文件系统选择<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS5oay91cmw/c2E9dCZhbXA7cmN0PWomYW1wO3E9JmFtcDtlc3JjPXMmYW1wO3NvdXJjZT13ZWImYW1wO2NkPTQmYW1wO2NhZD1yamEmYW1wO3ZlZD0wQ0VRUUZqQUQmYW1wO3VybD1odHRwOi8vYmxvZy5jc2RuLm5ldC91cG5vYS9hcnRpY2xlL2RldGFpbHMvNjk3NzQ4MCZhbXA7ZWk9UTRTbFVvX19EZWpEMlFXODBvQ29BZyZhbXA7dXNnPUFGUWpDTkZQODRNUm9GMnRHdEdPMlVCN2tjazROY0pKMWcmYW1wO2J2bT1idi41Nzc1MjkxOSxkLmRHSQ==" title="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;ved=0CEQQFjAD&amp;url=http://blog.csdn.net/upnoa/article/details/6977480&amp;ei=Q4SlUo__DejD2QW80oCoAg&amp;usg=AFQjCNFP84MRoF2tGtGO2UB7kck4NcJJ1g&amp;bvm=bv.57752919,d.dGI">xfs、ext3、ext4还是reiserFs<i class="fa fa-external-link"></i></span>，需要做一些性能方面的测试，从官方的一些测试数据来看，reiserFs更适合存储一些小图片文件。创建文件系统的时候 Inode 问题也要加以考虑，选择合适大小的 inode size ，因为Linux 为每个文件分配一个称为索引节点的号码inode，可以将inode简单理解成一个指针，它永远指向本文件的具体存储位置。一个文件系统允许的inode节点数是有限的，如果文件数量太多，即使每个文件都是0字节的空文件，系统最终也会因为节点空间耗尽而不能再创建文件，因此需要在空间和速度上做取舍，构造合理的文件目录索引。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>云存储阶段</strong></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuYWxpeXVuLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNi8zMy5wbmc=" title="http://blog.aliyun.com/wp-content/uploads/2014/06/33.png"><img class="alignnone  wp-image-970" alt="3" src="http://blog.aliyun.com/wp-content/uploads/2014/06/33.png" width="494" height="241"><i class="fa fa-external-link"></i></span></p><p>&nbsp;</p><p>2011年李彦宏在百度联盟峰会上就提到过互联网的读图时代已经到来，图片服务早已成为一个互联网应用中占比很大的部分，对图片的处理能力也相应地变成企业和开发者的一项基本技能,图片的下载和上传速度显得更加重要，要想处理好图片，需要面对的三个主要问题是：大流量、高并发、海量存储。</p><p>&nbsp;</p><p>阿里云存储服务(OpenStorageService，简称OSS)，是阿里云对外提供的海量，安全，低成本，高可靠的云存储服务。用户可以通过简单的 REST接口，在任何时间、任何地点上传和下载数据，也可以使用WEB页面对数据进行管理。同时，OSS提供Java、Python、PHP SDK，简化用户的编程。基于OSS，用户可以搭建出各种多媒体分享网站、网盘、个人企业数据备份等基于大规模数据的服务。在以下图片云存储主要以阿里云的云存储OSS为切入点介绍，上图为OSS云存储的简单架构示意图。</p><p>&nbsp;</p><p>真正意义上的“云存储”，不是存储而是提供云服务，使用云存储服务的主要优势有以下几点：</p><p>1)用户无需了解存储设备的类型、接口、存储介质等。</p><p>2)无需关心数据的存储路径。</p><p>3)无需对存储设备进行管理、维护。</p><p>4)无需考虑数据备份和容灾</p><p>5)简单接入云存储，尽情享受存储服务。</p><h2></h2><h2></h2><h2></h2><p>&nbsp;</p><p>&nbsp;</p><h2><strong>架构模块组成</strong></h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuYWxpeXVuLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNi80MS5wbmc=" title="http://blog.aliyun.com/wp-content/uploads/2014/06/41.png"><img class="alignnone  wp-image-971" alt="4" src="http://blog.aliyun.com/wp-content/uploads/2014/06/41.png" width="547" height="369"><i class="fa fa-external-link"></i></span></p><p>1）KV Engine</p><p>OSS中的Object源信息和数据文件都是存放在KV Engine上。在6.15的版本，V Engine将使用0.8.6版本，并使用为OSS提供的OSSFileClient。</p><p>&nbsp;</p><p>2）Quota</p><p>此模块记录了Bucket和用户的对应关系，和以分钟为单位的Bucket资源使用情况。Quota还将提供HTTP接口供Boss系统查询。</p><p>&nbsp;</p><p>3）安全模块</p><p>安全模块主要记录User对应的ID和Key，并提供OSS访问的用户验证功能。</p><h2></h2><h2></h2><p>&nbsp;</p><h2><strong>OSS术语名词汇</strong></h2><p>&nbsp;</p><p>1 ）Access Key ID &amp; Access Key Secret （API密钥）<br>用户注册OSS时，系统会给用户分配一对Access Key ID &amp; Access Key Secret，称为ID对，用于标识用户，为访问OSS做签名验证。</p><p>&nbsp;</p><p>2） Service<br>OSS提供给用户的虚拟存储空间，在这个虚拟空间中，每个用户可拥有一个到多个Bucket。</p><p>&nbsp;</p><p>3） Bucket<br>Bucket是OSS上的命名空间；Bucket名在整个OSS中具有全局唯一性，且不能修改；存储在OSS上的每个Object必须都包含在某个Bucket中。一个应用，例如图片分享网站，可以对应一个或多个Bucket。一个用户最多可创建10个Bucket，但每个Bucket中存放的Object的数量和大小总和没有限制，用户不需要考虑数据的可扩展性。</p><p>4） Object<br>在OSS中，用户的每个文件都是一个Object，每个文件需小于5TB。Object包含key、data和user meta。其中，key是Object的名字；data是Object的数据；user meta是用户对该object的描述。<br>其使用方式非常简单,如下为java sdk：</p><p>OSSClient ossClient = new OSSClient(accessKeyId,accessKeySecret);</p><p>PutObjectResult result = ossClient.putObject(bucketname,          bucketKey, inStream,  new ObjectMetadata());</p><p>执行以上代码即可将图片流上传至OSS服务器上。</p><p>图片的访问方式也非常简单其url为：<span class="exturl" data-url="aHR0cDovL2J1Y2tldG5hbWUub3NzLmFsaXl1bmNzLmNvbS9idWNrZXRLZXk=" title="http://bucketname.oss.aliyuncs.com/bucketKey">http://bucketname.oss.aliyuncs.com/bucketKey<i class="fa fa-external-link"></i></span></p><p>&nbsp;</p><p>&nbsp;</p><p><strong>分布式文件系统</strong></p><p>用分布式存储有几个好处，分布式能自动提供冗余，不需要我们去备份，担心数据安全，在文件数量特别大的情况下，备份是一件很痛苦的事情，rsync扫一次可能是就是好几个小时，还有一点就是分布式存储动态扩容方便。当然在国内的其他一些文件系统里，TFS（<span class="exturl" data-url="aHR0cDovL2NvZGUudGFvYmFvLm9yZy9wL3Rmcy9zcmMv" title="http://code.taobao.org/p/tfs/src/">http://code.taobao.org/p/tfs/src/<i class="fa fa-external-link"></i></span>）和FASTDFS也有一些用户，但是TFS的优势更是针对一些小文件存储，主要是淘宝在用。另外FASTDFS在并发高于300写入的情况下出现性能问题，稳定性不够友好。OSS存储使用的是阿里云基于飞天5k平台自主研发的高可用，高可靠的分布式文件系统盘古。分布式文件系统盘古和Google的GFS类似，盘古的架构是Master-Slave主从架构，Master负责元数据管理，Sliave叫做Chunk Server，负责读写请求。其中Master是基于Paxos的多Master架构，一个Master死了之后，另外一个Master可以很快接过去，基本能够做到故障恢复在一分钟以内 。文件是按照分片存放，每个会分三个副本，放在不同的机架上，最后提供端到端的数据校验。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>HAPROXY负载均衡</strong></p><p>基于haproxy的自动hash架构 ,这是一种新的缓存架构，由nginx作为最前端，代理到缓存机器。 nginx后面是缓存组，由nginx经过url hash后将请求分到缓存机器。<br>这个架构方便纯squid缓存升级，可以在squid的机器上加装nginx。 nginx有缓存的功能，可以将一些访问量特大的链接直接缓存在nginx上，就不用经过多一次代理的请求，能够保证图片服务器的高可用、高性能。比如favicon.ico和网站的logo。 负载均衡负责OSS所有的请求的负载均衡，后台的http服务器故障会自动切换，从而保证了OSS的服务不间断。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>CDN</strong></p><p>阿里云CDN服务是一个遍布全国的分布式缓存系统，能够将网站文件（如图片或JavaScript代码文件）缓存到全国多个城市机房中的服务器上，当一个用户访问你的网站时，会就近到靠近TA的城市的服务器上获取数据，这样最终用户访问你的服务速度会非常快。</p><p>阿里云CDN服务在全国部署超过100个节点，能提供给用户优良的网络加速效果。当网站业务突然爆发增长时，无需手忙脚乱地扩容网络带宽，使用CDN服务即可轻松应对。和OSS服务一样，使用CDN，需要先在aliyun.com网站上开通CDN服务。开通后，需要在网站上的管理中心创建你的distribution（即分发频道），每个distribution由两个必须的部分组成：distribution ID和源站地址。</p><p>使用阿里云OSS和CDN可以非常方便的针对每个bucket进行内容加速，因为每个bucket对应一个独立的二级域名，针对每个文件进行CDN删除，简单、经济地解决服务的存储和网络问题，毕竟大多数网站或应用的存储和网络带宽多半是被图片或视频消耗掉的。</p><p>从整个业界来看，最近这样的面向个人用户的云存储如国外的DropBox和Box.net非常受欢迎，国内的云存储目前比较不错的主要有七牛云存储和又拍云存储。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>上传下载分而治之</strong></p><p>图片服务器的图片下载比例远远高于上传比例，业务逻辑的处理也区别明显，上传服器对图片重命名，记录入库信息，下载服务器对图片添加水印、修改尺寸之类的动态处理。从高可用的角度，我们能容忍部分图片下载失败，但绝不能有图片上传失败，因为上传失败，意味着数据的丢失。上传与下载分开，能保证不会因下载的压力影响图片的上传，而且还有一点，下载入口和上传入口的负载均衡策略也有所不同。上传需要经过Quota Server记录用户和图片的关系等逻辑处理，下载的逻辑处理如果绕过了前端缓存处理，穿透后端业务逻辑处理，需要从OSS获取图片路径信息。近期阿里云会推出基于CDN就近上传的功能，自动选择离用户最近的CDN节点，使得数据的上传下载速度均得到最优化。相较传统IDC，访问速度提升数倍。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>图片防盗链处理</strong></p><p>如果服务不允许防盗链，那么访问量会引起带宽、服务器压力等问题。比较通用的解决方案是在nginx或者squid反向代理软件上添加refer ACL判断，OSS也提供了基于refer的防盗链技术。当然OSS也提供了更为高级的URL签名防盗链，其其实现思路如下：</p><p>&nbsp;</p><p>首先，确认自己的bucket权限是private，即这个bucket的所有请求必须在签名认证通过后才被认为是合法的。然后根据操作类型、要访问的bucket、要访问的object以及超时时间，动态地生成一个经过签名的URL。通过这个签名URL，你授权的用户就可以在该签名URL过期时间前执行相应的操作。</p><p>&nbsp;</p><p>签名的Python代码如下：</p><p>h=hmac.new(&#8220;OtxrzxIsfpFjA7SwPzILwy8Bw21TLhquhboDYROV&#8221;, &#8220;GET\n\n\n1141889120\n/oss-example/oss-api.jpg&#8221;,sha);</p><p>urllib.quote_plus (base64.encodestring(h.digest()).strip());</p><p>&nbsp;</p><p>其中method可以是PUT、GET、HEAD、DELETE中的任意一种；最后一个参数“timeout”是超时的时间，单位是秒。一个通过上面Python方法，计算得到的签名URL为：</p><p>http://oss-example.oss-cn-hangzhou.aliyuncs.com/oss-api.jpg?OSSAccessKeyId=44CF9590006BF252F707&#038;Expires=1141889120&#038;Signature=vjbyPxybdZaNmGa%2ByT272YEAiv4%3D</p><p>&nbsp;</p><p>通过这种动态计算签名URL的方法，可以有效地保护放在OSS上的数据，防止被其他人盗链。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>图片编辑处理API</strong></p><p>对于在线图片的编辑处理，GraphicsMagick（GraphicsMagick(<span class="exturl" data-url="aHR0cDovL3d3dy5ncmFwaGljc21hZ2ljay5vcmcv" title="http://www.graphicsmagick.org/">http://www.graphicsmagick.org/<i class="fa fa-external-link"></i></span>)）对于从事互联网的技术人员应该不会陌生。GraphicsMagick是从 ImageMagick 5.5.2 分支出来的，但是现在他变得更稳定和优秀，GM更小更容易安装、GM更有效率、GM的手册非常丰富GraphicsMagick的命令与ImageMagick基本是一样的。</p><p>&nbsp;</p><p>GraphicsMagick 提供了包括裁、缩放、合成、打水印、图像转换、填充等非常丰富的接口API,其中的开发包SDK也非常丰富，包括了JAVA(im4java)、C、C++、Perl、PHP、Tcl、Ruby等的调用，支持超过88中图像格式，包括重要的DPX、GIF、JPEG、JPEG-2000、PNG、PDF、PNM和TIFF，GraphicsMagick可以再绝大多数的平台上使用，Linux、Mac、Windows都没有问题。但是独立开发这些图片处理服务，对服务器的IO要求相对要高一些，而且目前这些开源的图片处理编辑库，相对来说还不是很稳定，笔者在使用GraphicsMagick 的时候就遇到了tomcat 进程crash情况，需要手动重启tomcat服务。</p><p>&nbsp;</p><p>阿里云目前已经对外开放图片处理API,包括了大多数常用处理解决方案：缩略图、打水印、文字水印、样式、管道等。开发者可以非常方便的使用如上图片处理方案，希望越来越多的开发者能够基于OSS开放出更多优秀的产品。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在几乎任何一个网站、Web App以及移动APP等应用都需要有图片展示的功能，对于图片功能从下至上都是很重要的。必须要具有前瞻性的规划好图片服务器，图片的上传和下载速度至关重要，当然这并不是说一上来就搞很NB的架构，至少具备一定扩展性和稳定性。虽然各种架构设计都有，在这里
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/vim/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/vim/</id>
    <published>2019-06-14T02:52:59.709Z</published>
    <updated>2019-06-14T02:52:59.709Z</updated>
    
    <content type="html"><![CDATA[<p>Vim的学习曲线相当的大，所以，如果你一开始看到的是一大堆VIM的命令分类，你一定会对这个编辑器失去兴趣的。下面的文章翻译自《<span class="exturl" data-url="aHR0cDovL3lhbm5lc3Bvc2l0by5jb20vU2NyYXRjaC9lbi9ibG9nL0xlYXJuLVZpbS1Qcm9ncmVzc2l2ZWx5Lw==" title="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">Learn Vim Progressively<i class="fa fa-external-link"></i></span>》，我觉得这是给新手最好的VIM的升级教程了，没有列举所有的命令，只是列举了那些最有用的命令。非常不错。</p><p style="text-align: center;"><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L2NvZGUtZWRpdG9yLWxlYXJpbmctY3VydmUuanBn" title="一些常见编辑器的学习曲线图"><img class="aligncenter size-full wp-image-18359" title="一些常见编辑器的学习曲线图" alt="一些常见编辑器的学习曲线图" src="http://jbcdn2.b0.upaiyun.com/2012/04/code-editor-learing-curve.jpg" width="480" height="332"><i class="fa fa-external-link"></i></span></p><p>——————————正文开始——————————</p><p>你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。</p><p><span class="exturl" data-url="aHR0cDovL3d3dy52aW0ub3JnLw==" title="http://www.vim.org/">Vim<i class="fa fa-external-link"></i></span> the Six Billion Dollar editor</p><p><span style="color: #888888;">Better, Stronger, Faster.</span></p><p>学习 <span class="exturl" data-url="aHR0cDovL3d3dy52aW0ub3JnLw==" title="http://www.vim.org/">vim<i class="fa fa-external-link"></i></span> 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。</p><p>我建议下面这四个步骤：</p><p>1. 存活</p><p>2. 感觉良好</p><p>3. 觉得更好，更强，更快</p><p>4.使用VIM的超能力</p><p>当你走完这篇文章，你会成为一个vim的 superstar。</p><p>在开始学习以前，我需要给你一些警告：</p><p>● 学习vim在开始时是痛苦的。</p><p>● 需要时间</p><p>● 需要不断地练习，就像你学习一个乐器一样。</p><p>● 不要期望你能在3天内把vim练得比别的编辑器更有效率。</p><p>● 事实上，你需要2周时间的苦练，而不是3天。</p><p>&nbsp;</p><p><span style="color: #ff0000;"><strong>第一级 – 存活</strong></span></p><p>1. 安装 <span class="exturl" data-url="aHR0cDovL3d3dy52aW0ub3JnLw==" title="http://www.vim.org/">vim<i class="fa fa-external-link"></i></span></p><p>2. 启动 vim</p><p>3. <strong>什么也别干！</strong>请先阅读</p><p>当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p><p>● 启 动Vim后，vim在 <em>Normal</em> 模式下。</p><p>● 让我们进入 <em>Insert</em> 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</p><p>● 此时，你可以输入文本了，就像你用“记事本”一样。</p><p>● 如果你想返回 <em>Normal</em> 模式，请按 <code>ESC</code> 键。</p><p>现在，你知道如何在 <em>Insert</em> 和 <em>Normal</em> 模式下切换了。下面是一些命令，可以让你在 <em>Normal</em> 模式下幸存下来：</p><p><code>● i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</p><p><code>● x</code> → 删当前光标所在的一个字符。</p><p><code>● :wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)   （陈皓注：:w 后可以跟文件名）</p><p><code>● dd</code> → 删除当前行，并把删除的行存到剪贴板里</p><p><code>● p</code> → 粘贴剪贴板</p><p><strong>推荐</strong>:</p><p><code>● hjkl</code> (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</p><p><code>● :help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（陈皓注：退出帮助需要输入:q）</p><p>你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p><p>当是，在你进入第二级时，需要再说一下 <em>Normal </em>模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 <code>Ctrl</code> 键，比如：<code>Ctrl-C</code>。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，<strong>在VIM的Normal模式下，所有的键就是功能键了</strong>。这个你需要知道。</p><p>标记:</p><p>● 下面的文字中，如果是 <code>Ctrl-λ</code>我会写成 <code>&lt;C-λ&gt;</code>.</p><p>● 以 <code>:</code> 开始的命令你需要输入 <code>&lt;enter&gt;</code>回车，例如 — 如果我写成 <code>:q</code> 也就是说你要输入 <code>:q&lt;enter&gt;</code>.</p><h4 id="nd-level----feel-comfortable"></h4><p><span style="color: #ff0000;"><strong>第二级 – 感觉良好</strong></span></p><p>上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键）</p><p><strong>1. 各种插入模式</strong></p><p><strong></strong><code>● a</code> → 在光标后插入</p><p><code>● o</code> → 在当前行后插入一个新行</p><p><code>● O</code> → 在当前行前插入一个新行</p><p><code>● cw</code> → 替换从光标所在位置后到一个单词结尾的字符</p><p><strong>2. 简单的移动光标</strong></p><p><strong></strong><code>● 0</code> → 数字零，到行头</p><p><code>● ^</code> → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</p><p><code>● $</code> → 到本行行尾</p><p><code>● g_</code> → 到本行最后一个不是blank字符的位置。</p><p><code>● /pattern</code> → 搜索 <code>pattern</code> 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）</p><p><strong>3. 拷贝/粘贴</strong> （陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）</p><p><code>● P</code> → 粘贴</p><p><code>● yy</code> → 拷贝当前行当行于 <code>ddP</code></p><p><code></code><strong>4. Undo/Redo</strong></p><p><strong></strong><code>● u</code> → undo</p><p><code>● &lt;C-r&gt;</code> → redo</p><p><strong>5. 打开/保存/退出/改变文件</strong>(Buffer)</p><p><code>● :e &lt;path/to/file&gt;</code> → 打开一个文件</p><p><code>● :w</code> → 存盘</p><p><code>● :saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code></p><p><code></code><code>● :x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (:<code>x</code> 表示仅在需要时保存，ZZ不需要输入冒号并回车)</p><p><code>● :q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</p><p><code>● :bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）</p><p>花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。</p><h4 id="rd-level----better-stronger-faster"></h4><p><span style="color: #ff0000;"><strong>第三级 – 更好，更强，更快</strong></span></p><p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。</p><p id="better"><strong>更好</strong></p><p>下面，让我们看一下vim是怎么重复自己的：</p><p><code>1. .</code> → (小数点) 可以重复上一次的命令</p><p>2. N&lt;command&gt; → 重复某个命令N次</p><p>下面是一个示例，找开一个文件你可以试试下面的命令：</p><p><code>● 2dd</code> → 删除2行</p><p><code>● 3p</code> → 粘贴文本3次</p><p><code>● 100idesu [ESC]</code> → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</p><p><code>● .</code> → 重复上一个命令—— 100 “desu “.</p><p><code>● 3.</code> → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).</p><p id="stronger"><strong>更强</strong></p><p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，<strong>千万别跳过</strong>。</p><p>1. N<code>G</code> → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</p><p><code>2. gg</code> → 到第一行。（陈皓注：相当于1G，或 :1）</p><p><code>3. G</code> → 到最后一行。</p><p>4. 按单词移动：</p><p><code>● w</code> → 到下一个单词的开头。</p><p><code>● e</code> → 到下一个单词的结尾。</p><p>&gt; 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）</p><p>&gt; 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）</p><p><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L3dvcmRfbW92ZXMxLmpwZw==" title="简明 Vim 练级攻略"><img class="aligncenter size-full wp-image-18352" title="简明 Vim 练级攻略" alt="简明 Vim 练级攻略" src="http://jbcdn2.b0.upaiyun.com/2012/04/word_moves1.jpg" width="357" height="83"><i class="fa fa-external-link"></i></span></p><p>下面，让我来说说最强的光标移动：</p><p><code>● %</code> : 匹配括号移动，包括 <code>(</code>, <code>{</code>, <code>[</code>. （陈皓注：你需要把光标先移到括号上）</p><p><code>● *</code> 和 <code>#</code>:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</p><p>相信我，上面这三个命令对程序员来说是相当强大的。</p><p id="faster"><strong>更快</strong></p><p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：</p><p><code>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</code></p><p>例如 <code>0y$</code> 命令意味着：</p><p><code>● 0</code> → 先到行头</p><p><code>● y</code> → 从这里开始拷贝</p><p><code>● $</code> → 拷贝到本行最后一个字符</p><p>你可可以输入 <code>ye</code>，从当前位置拷贝到本单词的最后一个字符。</p><p>你也可以输入 <code>y2/foo</code> 来拷贝2个 “foo” 之间的字符串。</p><p>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p><p><code>● d</code> (删除 )</p><p><code>● v</code> (可视化的选择)</p><p><code>● gU</code> (变大写)</p><p><code>● gu</code> (变小写)</p><p>● 等等</p><div>（陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）</div><h4 id="th-level----vim-superpowers"></h4><p><span style="color: #ff0000;"><strong>第四级 – Vim 超能力</strong></span></p><p>你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。</p><p id="move-on-current-line-0---f-f-t-t--"><strong>在当前行上移动光标: <code>0</code> <code>^</code> <code>$</code> <code>f</code> <code>F</code> <code>t</code> <code>T</code> <code>,</code> <code>;</code></strong></p><p><strong><code></code></strong><code>● 0</code> → 到行头</p><p><code>● ^</code> → 到本行的第一个非blank字符</p><p><code>● $</code> → 到行尾</p><p><code>● g_</code> → 到本行最后一个不是blank字符的位置。</p><p><code>● fa</code> → 到下一个为a的字符处，你也可以fs到下一个为s的字符。</p><p><code>● t,</code> → 到逗号前的第一个字符。逗号可以变成其它字符。</p><p><code>● 3fa</code> → 在当前行查找第三个出现的a。</p><p><code>● F</code> 和 <code>T</code> → 和 <code>f</code> 和 <code>t</code> 一样，只不过是相反方向。</p><p><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L2xpbmVfbW92ZXMyLmpwZw==" title="简明 Vim 练级攻略"><img class="aligncenter size-full wp-image-18347" title="简明 Vim 练级攻略" alt="简明 Vim 练级攻略" src="http://jbcdn2.b0.upaiyun.com/2012/04/line_moves2.jpg" width="407" height="84"><i class="fa fa-external-link"></i></span></p><p>还有一个很有用的命令是 <code>dt"</code> → 删除所有的内容，直到遇到双引号—— <code>"。</code></p><p id="zone-selection-actionaobject-or-actioniobject"><strong>区域选择 <code>&lt;action&gt;a&lt;object&gt;</code> 或 <code>&lt;action&gt;i&lt;object&gt;</code></strong></p><p>在visual 模式下，这些命令很强大，其命令格式为</p><p><code>&lt;action&gt;a&lt;object&gt;</code> 和 <code>&lt;action&gt;i&lt;object&gt;</code></p><p><code></code>● action可以是任何的命令，如 <code>d</code> (删除), <code>y</code> (拷贝), <code>v</code> (可以视模式选择)。</p><p>● object 可能是： <code>w</code> 一个单词， <code>W</code> 一个以空格为分隔的单词， <code>s</code> 一个句字， <code>p</code> 一个段落。也可以是一个特别的字符：<code>"、</code> <code>'、</code> <code>)、</code> <code>}、</code> <code>]。</code></p><p>假设你有一个字符串 <code>(map (+) ("foo"))</code>.而光标键在第一个 <code>o </code>的位置。</p><p><code>● vi"</code> → 会选择 <code>foo</code>.</p><p><code>● va"</code> → 会选择 <code>"foo"</code>.</p><p><code>● vi)</code> → 会选择 <code>"foo"</code>.</p><p><code>● va)</code> → 会选择<code>("foo")</code>.</p><p><code>● v2i)</code> → 会选择 <code>map (+) ("foo")</code></p><p><code></code><code>● v2a)</code> → 会选择 <code>(map (+) ("foo"))</code></p><p><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L3RleHRvYmplY3RzMy5wbmc=" title="简明 Vim 练级攻略"><img class="aligncenter size-full wp-image-18351" title="简明 Vim 练级攻略" alt="简明 Vim 练级攻略" src="http://jbcdn2.b0.upaiyun.com/2012/04/textobjects3.png" width="242" height="126"><i class="fa fa-external-link"></i></span></p><p id="select-rectangular-blocks-c-v"><strong>块操作: <code>&lt;C-v&gt;</code></strong></p><p>块操作，典型的操作： <code>0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC]</code></p><p><code></code><code>● ^</code> → 到行头</p><p><code>● &lt;C-v&gt;</code> → 开始块操作</p><p><code>● &lt;C-d&gt;</code> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)</p><p><code>● I-- [ESC]</code> → I是插入，插入“<code>--</code>”，按ESC键来为每一行生效。</p><p><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L3JlY3Rhbmd1bGFyLWJsb2NrczQuZ2lm" title="简明 Vim 练级攻略"><img class="aligncenter size-full wp-image-18349" title="简明 Vim 练级攻略" alt="简明 Vim 练级攻略" src="http://jbcdn2.b0.upaiyun.com/2012/04/rectangular-blocks4.gif" width="300" height="160"><i class="fa fa-external-link"></i></span></p><p>在Windows下的vim，你需要使用 <code>&lt;C-q&gt;</code> 而不是 <code>&lt;C-v&gt;</code> ，<code>&lt;C-v&gt;</code> 是拷贝剪贴板。</p><p id="completion-c-n-and-c-p"><strong>自动提示： <code>&lt;C-n&gt;</code> 和 <code>&lt;C-p&gt;</code></strong></p><p>在 Insert 模式下，你可以输入一个词的开头，然后按 <code>&lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了……</code></p><p><code></code><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L2NvbXBsZXRpb241LmdpZg==" title="简明 Vim 练级攻略"><img class="aligncenter size-full wp-image-18346" title="简明 Vim 练级攻略" alt="简明 Vim 练级攻略" src="http://jbcdn2.b0.upaiyun.com/2012/04/completion5.gif" width="433" height="180"><i class="fa fa-external-link"></i></span></p><p id="macros--qa-do-something-q-a-"><strong>宏录制： <code>qa</code> 操作序列 <code>q</code>, <code>@a</code>, <code>@@</code></strong></p><p><strong><code></code></strong><code>● qa</code> 把你的操作记录在寄存器 <code>a。</code></p><p><code></code>●  于是 <code>@a</code> 会replay被录制的宏。</p><p><code>● @@</code> 是一个快捷键用来replay最新录制的宏。</p><p><strong>示例</strong></p><p><strong></strong>在一个只有一行且这一行只有“1”的文本中，键入如下命令：</p><p><code>● qaYp&lt;C-a&gt;q</code>→</p><p style="padding-left: 30px;"><code>● qa</code> 开始录制</p><p style="padding-left: 30px;"><code>● Yp</code> 复制行.</p><p style="padding-left: 30px;"><code>● &lt;C-a&gt;</code> 增加1.</p><p style="padding-left: 30px;"><code>● q</code> 停止录制.</p><p><code>● @a</code> → 在1下面写下 2</p><p><code>● @@</code> → 在2 正面写下3</p><p>● 现在做 <code>100@@</code> 会创建新的100行，并把数据增加到 103.</p><p><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L21hY3JvczYuZ2lm" title="简明 Vim 练级攻略"><img class="aligncenter size-full wp-image-18348" title="简明 Vim 练级攻略" alt="简明 Vim 练级攻略" src="http://jbcdn2.b0.upaiyun.com/2012/04/macros6.gif" width="400" height="180"><i class="fa fa-external-link"></i></span></p><p id="visual-selection-vvc-v"><strong>可视化选择： <code>v</code>,<code>V</code>,<code>&lt;C-v&gt;</code></strong></p><p>前面，我们看到了 <code>&lt;C-v&gt;</code>的示例 （在Windows下应该是&lt;C-q&gt;），我们可以使用 <code>v</code> 和 <code>V</code>。一但被选好了，你可以做下面的事：</p><p><code>● J</code> → 把所有的行连接起来（变成一行）</p><p><code>● &lt;</code> 或 <code>&gt;</code> → 左右缩进</p><p><code>● =</code> → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）</p><p><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L2F1dG9pbmRlbnQ3LmdpZg==" title="简明 Vim 练级攻略"><img class="aligncenter size-full wp-image-18345" title="简明 Vim 练级攻略" alt="简明 Vim 练级攻略" src="http://jbcdn2.b0.upaiyun.com/2012/04/autoindent7.gif" width="433" height="180"><i class="fa fa-external-link"></i></span></p><p>在所有被选择的行后加上点东西：</p><p>● &lt;C-v&gt;</p><p>● 选中相关的行 (可使用 <code>j</code> 或 <code>&lt;C-d&gt;</code> 或是 <code>/pattern</code> 或是 <code>%</code> 等……)</p><p><code>● $</code> 到行最后</p><p><code>● A</code>, 输入字符串，按 <code>ESC。</code></p><p><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L2FwcGVuZC10by1tYW55LWxpbmVzOC5naWY=" title="简明 Vim 练级攻略"><img class="aligncenter size-full wp-image-18344" title="简明 Vim 练级攻略" alt="简明 Vim 练级攻略" src="http://jbcdn2.b0.upaiyun.com/2012/04/append-to-many-lines8.gif" width="433" height="180"><i class="fa fa-external-link"></i></span></p><h5 id="splits-split-and-vsplit">分屏: <code>:split</code> 和 <code>vsplit</code>.</h5><p>下面是主要的命令，你可以使用VIM的帮助 <code>:help split</code>. 你可以参考本站以前的一篇文章<span class="exturl" data-url="aHR0cDovL2Nvb2xzaGVsbC5jbi9hcnRpY2xlcy8xNjc5Lmh0bWw=" title="Vim的分屏功能">VIM分屏<i class="fa fa-external-link"></i></span>。</p><p><code>● :split</code> → 创建分屏 (<code>:vsplit</code>创建垂直分屏)</p><p><code>● &lt;C-w&gt;&lt;dir&gt;</code> : dir就是方向，可以是 <code>hjkl</code> 或是 ←↓↑→ 中的一个，其用来切换分屏。</p><p><code>● &lt;C-w&gt;_</code> (或 <code>&lt;C-w&gt;|</code>) : 最大化尺寸 (&lt;C-w&gt;| 垂直分屏)</p><p><code>● &lt;C-w&gt;+</code> (或 <code>&lt;C-w&gt;-</code>) : 增加尺寸</p><p><span class="exturl" data-url="aHR0cDovL2piY2RuMi5iMC51cGFpeXVuLmNvbS8yMDEyLzA0L3NwbGl0OS5naWY=" title="简明 Vim 练级攻略"><img class="aligncenter size-full wp-image-18350" title="简明 Vim 练级攻略" alt="简明 Vim 练级攻略" src="http://jbcdn2.b0.upaiyun.com/2012/04/split9.gif" width="433" height="180"><i class="fa fa-external-link"></i></span></p><h4 id="conclusion"></h4><p><strong>结束语</strong></p><p>● 上面是作者最常用的90%的命令。</p><p>● 我建议你每天都学1到2个新的命令。</p><p>● 在两到三周后，你会感到vim的强大的。</p><p>● 有时候，学习VIM就像是在死背一些东西。</p><p>● 幸运的是，vim有很多很不错的工具和优秀的文档。</p><p>● 运行vimtutor直到你熟悉了那些基本命令。</p><p>● 其在线帮助文档中你应该要仔细阅读的是 <code>:help usr_02.txt</code>.</p><p>● 你会学习到诸如  <code>!，</code> 目录，寄存器，插件等很多其它的功能。</p><p>学习vim就像学弹钢琴一样，一旦学会，受益无穷。</p><p id="aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown">——————————正文结束——————————</p><p>对于vi/vim只是点评一点：这是一个你不需要使用鼠标，不需使用小键盘，只需要使用大键盘就可以完成很多复杂功能文本编辑的编辑器。不然，Visual Studio也不就会有vim的插件了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vim的学习曲线相当的大，所以，如果你一开始看到的是一大堆VIM的命令分类，你一定会对这个编辑器失去兴趣的。下面的文章翻译自《&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3lhbm5lc3Bvc2l0by5jb20vU2NyYXRjaC9
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/sql/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/sql/</id>
    <published>2019-06-14T02:52:59.709Z</published>
    <updated>2019-06-14T02:52:59.709Z</updated>
    
    <content type="html"><![CDATA[<p>很多程序员视 SQL 为洪水猛兽。SQL 是一种为数不多的声明性语言，它的运行方式完全不同于我们所熟知的命令行语言、面向对象的程序语言、甚至是函数语言（尽管有些人认为 SQL 语言也是一种函数式语言）。</p><p>我们每天都在写 SQL 并且应用在开源软件 jOOQ 中。于是我想把 SQL 之美介绍给那些仍然对它头疼不已的朋友，所以本文是为了以下读者而特地编写的：</p><p>1、 在工作中会用到 SQL 但是对它并不完全了解的人。</p><p>2、 能够熟练使用 SQL 但是并不了解其语法逻辑的人。</p><p>3、 想要教别人 SQL 的人。</p><p style="text-align: center;"><img class="alignnone size-full wp-image-55236" alt="sql logo" src="http://jbcdn2.b0.upaiyun.com/2014/01/e59983b9f25fc171558066e3071150d6.jpg"></p><p>本文着重介绍 SELECT 句式，其他的 DML （Data Manipulation Language 数据操纵语言命令）将会在别的文章中进行介绍。</p><h1>10个简单步骤，完全理解SQL</h1><h2>1、 SQL 是一种声明式语言</h2><p>首先要把这个概念记在脑中：“声明”。 SQL 语言是为计算机声明了一个你想从原始数据中获得什么样的结果的一个范例，而不是告诉计算机如何能够得到结果。这是不是很棒？</p><p><span style="color: #888888;">（译者注：简单地说，SQL 语言声明的是结果集的属性，计算机会根据 SQL 所声明的内容来从数据库中挑选出符合声明的数据，而不是像传统编程思维去指示计算机如何操作。）</span></p><pre class="brush: sql; gutter: true">SELECT first_name, last_name FROM employees WHERE salary &gt; 100000</pre><p>上面的例子很容易理解，我们不关心这些雇员记录从哪里来，我们所需要的只是那些高薪者的数据<span style="color: #888888;">（译者注： salary&gt;100000 ）。</span></p><p><strong>我们从哪儿学习到这些？</strong></p><p>如果 SQL 语言这么简单，那么是什么让人们“闻 SQL 色变”？主要的原因是：我们潜意识中的是按照命令式编程的思维方式思考问题的。就好像这样：“电脑，先执行这一步，再执行那一步，但是在那之前先检查一下是否满足条件 A 和条件 B ”。例如，用变量传参、使用循环语句、迭代、调用函数等等，都是这种命令式编程的思维惯式。</p><h2>2、 SQL 的语法并不按照语法顺序执行</h2><p>SQL 语句有一个让大部分人都感到困惑的特性，就是：SQL 语句的执行顺序跟其语句的语法顺序并不一致。SQL 语句的语法顺序是：</p><ul><li>SELECT[DISTINCT]</li><li>FROM</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>UNION</li><li>ORDER BY</li></ul><p>为了方便理解，上面并没有把所有的 SQL 语法结构都列出来，但是已经足以说明 SQL 语句的语法顺序和其执行顺序完全不一样，就以上述语句为例，其执行顺序为：</p><ul><li>FROM</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>SELECT</li><li>DISTINCT</li><li>UNION</li><li>ORDER BY</li></ul><p>关于 SQL 语句的执行顺序，有三个值得我们注意的地方：</p><p>1、 FROM 才是 SQL 语句执行的第一步，并非 SELECT 。数据库在执行 SQL 语句的第一步是将数据从硬盘加载到数据缓冲区中，以便对这些数据进行操作。<span style="color: #888888;">（译者注：原文为“The first thing that happens is loading data from the disk into memory, in order to operate on such data.”，但是并非如此，以 Oracle 等常用数据库为例，数据是从硬盘中抽取到数据缓冲区中进行操作。）</span></p><p>2、 SELECT 是在大部分语句执行了之后才执行的，严格的说是在 FROM 和 GROUP BY 之后执行的。理解这一点是非常重要的，这就是你不能在 WHERE 中使用在 SELECT 中设定别名的字段作为判断条件的原因。</p><pre class="brush: sql; gutter: true">SELECT A.x + A.y AS zFROM AWHERE z = 10 -- z 在此处不可用，因为SELECT是最后执行的语句！</pre><p>如果你想重用别名z，你有两个选择。要么就重新写一遍 z 所代表的表达式：</p><pre class="brush: sql; gutter: true">SELECT A.x + A.y AS zFROM AWHERE (A.x + A.y) = 10</pre><p>…或者求助于衍生表、通用数据表达式或者视图，以避免别名重用。请看下文中的例子。</p><p>3、 无论在语法上还是在执行顺序上， UNION 总是排在在 ORDER BY 之前。很多人认为每个 UNION 段都能使用 ORDER BY 排序，但是根据 SQL 语言标准和各个数据库 SQL 的执行差异来看，这并不是真的。尽管某些数据库允许 SQL 语句对子查询（subqueries）或者派生表（derived tables）进行排序，但是这并不说明这个排序在 UNION 操作过后仍保持排序后的顺序。</p><p>注意：并非所有的数据库对 SQL 语句使用相同的解析方式。如 MySQL、PostgreSQL和 SQLite 中就不会按照上面第二点中所说的方式执行。</p><p><strong>我们学到了什么？</strong></p><p>既然并不是所有的数据库都按照上述方式执行 SQL 预计，那我们的收获是什么？我们的收获是永远要记得： SQL 语句的语法顺序和其执行顺序并不一致，这样我们就能避免一般性的错误。如果你能记住 SQL 语句语法顺序和执行顺序的差异，你就能很容易的理解一些很常见的 SQL 问题。</p><p>当然，如果一种语言被设计成语法顺序直接反应其语句的执行顺序，那么这种语言对程序员是十分友好的，这种编程语言层面的设计理念已经被微软应用到了 LINQ 语言中。</p><h2>3、 SQL 语言的核心是对表的引用（table references）</h2><p>由于 SQL 语句语法顺序和执行顺序的不同，很多同学会认为SELECT 中的字段信息是 SQL 语句的核心。其实真正的核心在于对表的引用。</p><p>根据 SQL 标准，FROM 语句被定义为：</p><pre class="brush: sql; gutter: true">&lt;from clause&gt; ::= FROM &lt;table reference&gt; [ { &lt;comma&gt; &lt;table reference&gt; }... ]</pre><p>FROM 语句的“输出”是一张联合表，来自于所有引用的表在某一维度上的联合。我们们慢慢来分析：</p><pre class="brush: sql; gutter: true">FROM a, b</pre><p>上面这句 FROM 语句的输出是一张联合表，联合了表 a 和表 b 。如果 a 表有三个字段， b 表有 5 个字段，那么这个“输出表”就有 8 （ =5+3）个字段。</p><p>这个联合表里的数据是 a*b，即 a 和 b 的笛卡尔积。换句话说，也就是 a 表中的每一条数据都要跟 b 表中的每一条数据配对。如果 a 表有3 条数据， b 表有 5 条数据，那么联合表就会有 15 （ =5*3）条数据。</p><p>FROM 输出的结果被 WHERE 语句筛选后要经过 GROUP BY 语句处理，从而形成新的输出结果。我们后面还会再讨论这方面问题。</p><p>如果我们从集合论（关系代数）的角度来看，一张数据库的表就是一组数据元的关系，而每个 SQL 语句会改变一种或数种关系，从而产生出新的数据元的关系（即产生新的表）。</p><p><strong>我们学到了什么？</strong></p><p>思考问题的时候从表的角度来思考问题提，这样很容易理解数据如何在 SQL 语句的“流水线”上进行了什么样的变动。</p><h2>4、 灵活引用表能使 SQL 语句变得更强大</h2><p>灵活引用表能使 SQL 语句变得更强大。一个简单的例子就是 JOIN 的使用。严格的说 JOIN 语句并非是 SELECT 中的一部分，而是一种特殊的表引用语句。 SQL 语言标准中表的连接定义如下：</p><pre class="brush: sql; gutter: true">&lt;table reference&gt; ::=    &lt;table name&gt;  | &lt;derived table&gt;  | &lt;joined table&gt;</pre><p>就拿之前的例子来说：</p><pre class="brush: sql; gutter: true">FROM a, b</pre><p>a 可能输如下表的连接：</p><pre class="brush: sql; gutter: true">a1 JOIN a2 ON a1.id = a2.id</pre><p>将它放到之前的例子中就变成了：</p><pre class="brush: sql; gutter: true">FROM a1 JOIN a2 ON a1.id = a2.id, b</pre><p>尽管将一个连接表用逗号跟另一张表联合在一起并不是常用作法，但是你的确可以这么做。结果就是，最终输出的表就有了 a1+a2+b 个字段了。</p><p><span style="color: #888888;">（译者注：原文这里用词为 degree ，译为维度。如果把一张表视图化，我们可以想象每一张表都是由横纵两个维度组成的，横向维度即我们所说的字段或者列，英文为columns；纵向维度即代表了每条数据，英文为 record ，根据上下文，作者这里所指的应该是字段数。）</span></p><p>在 SQL 语句中派生表的应用甚至比表连接更加强大，下面我们就要讲到表连接。</p><p><strong>我们学到了什么？</strong></p><p>思考问题时，要从表引用的角度出发，这样就很容易理解数据是怎样被 SQL 语句处理的，并且能够帮助你理解那些复杂的表引用是做什么的。</p><p>更重要的是，要理解 JOIN 是构建连接表的关键词，并不是 SELECT 语句的一部分。有一些数据库允许在 INSERT 、 UPDATE 、 DELETE 中使用 JOIN 。</p><h2>5、 SQL 语句中推荐使用表连接</h2><p>我们先看看刚刚这句话：</p><pre class="brush: sql; gutter: true">FROM a, b</pre><p>高级 SQL 程序员也许学会给你忠告：尽量不要使用逗号来代替 JOIN 进行表的连接，这样会提高你的 SQL 语句的可读性，并且可以避免一些错误。</p><p>利用逗号来简化 SQL 语句有时候会造成思维上的混乱，想一下下面的语句：</p><pre class="brush: sql; gutter: true">FROM a, b, c, d, e, f, g, hWHERE a.a1 = b.bxAND a.a2 = c.c1AND d.d1 = b.bc-- etc...</pre><p>我们不难看出使用 JOIN 语句的好处在于：</p><ul><li>安全。 JOIN 和要连接的表离得非常近，这样就能避免错误。</li></ul><ul><li>更多连接的方式，JOIN 语句能去区分出来外连接和内连接等。</li></ul><p><strong>我们学到了什么？</strong></p><p>记着要尽量使用 JOIN 进行表的连接，永远不要在 FROM 后面使用逗号连接表。</p><h2>6、 SQL 语句中不同的连接操作</h2><p>SQL 语句中，表连接的方式从根本上分为五种：</p><ul><li>EQUI JOIN</li><li>SEMI JOIN</li><li>ANTI JOIN</li><li>CROSS JOIN</li><li>DIVISION</li></ul><p><strong> EQUI JOIN</strong></p><p>这是一种最普通的 JOIN 操作，它包含两种连接方式：</p><ul><li>INNER JOIN（或者是 JOIN ）</li><li>OUTER JOIN（包括： LEFT 、 RIGHT、 FULL OUTER JOIN）</li></ul><p>用例子最容易说明其中区别：</p><pre class="brush: sql; gutter: true">-- This table reference contains authors and their books.-- There is one record for each book and its author.-- authors without books are NOT includedauthor JOIN book ON author.id = book.author_id<p>– This table reference contains authors and their books<br>– There is one record for each book and its author.<br>– … OR there is an &quot;empty&quot; record for authors without books<br>– (&quot;empty&quot; meaning that all book columns are NULL)<br>author LEFT OUTER JOIN book ON author.id = book.author_id</p></pre><p></p><p><strong>SEMI JOIN</strong></p><p>这种连接关系在 SQL 中有两种表现方式：使用 IN，或者使用 EXISTS。“ SEMI ”在拉丁文中是“半”的意思。这种连接方式是只连接目标表的一部分。这是什么意思呢？再想一下上面关于作者和书名的连接。我们想象一下这样的情况：我们不需要作者 / 书名这样的组合，只是需要那些在书名表中的书的作者信息。那我们就能这么写：</p><pre class="brush: sql; gutter: true">-- Using INFROM authorWHERE author.id IN (SELECT book.author_id FROM book)<p>– Using EXISTS<br>FROM author<br>WHERE EXISTS (SELECT 1 FROM book WHERE book.author_id = author.id)</p></pre><p></p><p>尽管没有严格的规定说明你何时应该使用 IN ，何时应该使用 EXISTS ，但是这些事情你还是应该知道的：</p><ul><li>IN比 EXISTS 的可读性更好</li></ul><ul><li>EXISTS 比IN 的表达性更好（更适合复杂的语句）</li></ul><ul><li>二者之间性能没有差异（但对于某些数据库来说性能差异会非常大）</li></ul><p>因为使用 INNER JOIN 也能得到书名表中书所对应的作者信息，所以很多初学者机会认为可以通过 DISTINCT 进行去重，然后将 SEMI JOIN 语句写成这样：</p><pre class="brush: sql; gutter: true">-- Find only those authors who also have booksSELECT DISTINCT first_name, last_nameFROM authorJOIN book ON author.id = book.author_id</pre><p>这是一种很糟糕的写法，原因如下：</p><ul><li>SQL 语句性能低下：因为去重操作（ DISTINCT ）需要数据库重复从硬盘中读取数据到内存中。<span style="color: #888888;">（译者注： DISTINCT 的确是一种很耗费资源的操作，但是每种数据库对于 DISTINCT 的操作方式可能不同）。</span></li></ul><ul><li>这么写并非完全正确：尽管也许现在这么写不会出现问题，但是随着 SQL 语句变得越来越复杂，你想要去重得到正确的结果就变得十分困难。</li></ul><p>更多的关于滥用 DISTINCT 的危害可以参考这篇博文</p><p>（<span class="exturl" data-url="aHR0cDovL2Jsb2cuam9vcS5vcmcvMjAxMy8wNy8zMC8xMC1jb21tb24tbWlzdGFrZXMtamF2YS1kZXZlbG9wZXJzLW1ha2Utd2hlbi13cml0aW5nLXNxbC8=" title="http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/">http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/<i class="fa fa-external-link"></i></span>）。</p><p><strong>ANTI JOIN</strong></p><p>这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接。举个例子来说，我们列出书名表里没有书的作者：</p><pre class="brush: sql; gutter: true">-- Using INFROM authorWHERE author.id NOT IN (SELECT book.author_id FROM book)<p>– Using EXISTS<br>FROM author<br>WHERE NOT EXISTS (SELECT 1 FROM book WHERE book.author_id = author.id)</p></pre><p></p><p>关于性能、可读性、表达性等特性也完全可以参考 SEMI JOIN。</p><p>这篇博文介绍了在使用 NOT IN 时遇到 NULL 应该怎么办，因为有一点背离本篇主题，就不详细介绍，有兴趣的同学可以读一下</p><p>（<span class="exturl" data-url="aHR0cDovL2Jsb2cuam9vcS5vcmcvMjAxMi8wMS8yNy9zcWwtaW5jb21wYXRpYmlsaXRpZXMtbm90LWluLWFuZC1udWxsLXZhbHVlcy8=" title="http://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/">http://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/<i class="fa fa-external-link"></i></span>）。</p><p><strong>CROSS JOIN</strong></p><p>这个连接过程就是两个连接的表的乘积：即将第一张表的每一条数据分别对应第二张表的每条数据。我们之前见过，这就是逗号在 FROM 语句中的用法。在实际的应用中，很少有地方能用到 CROSS JOIN，但是一旦用上了，你就可以用这样的 SQL语句表达：</p><pre class="brush: sql; gutter: true">-- Combine every author with every bookauthor CROSS JOIN book</pre><p><strong>DIVISION</strong></p><p>DIVISION 的确是一个怪胎。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来，介于这是一个新手指南，解释 DIVISION 已经超出了我们的目的。但是有兴趣的同学还是可以来看看这三篇文章</p><p>（<span class="exturl" data-url="aHR0cDovL2Jsb2cuam9vcS5vcmcvMjAxMi8wMy8zMC9hZHZhbmNlZC1zcWwtcmVsYXRpb25hbC1kaXZpc2lvbi1pbi1qb29xLw==" title="http://blog.jooq.org/2012/03/30/advanced-sql-relational-division-in-jooq/">http://blog.jooq.org/2012/03/30/advanced-sql-relational-division-in-jooq/<i class="fa fa-external-link"></i></span>）</p><p>（<a href="#Division">http://en.wikipedia.org/wiki/Relational_algebra#Division</a>）</p><p>（<span class="exturl" data-url="aHR0cHM6Ly93d3cuc2ltcGxlLXRhbGsuY29tL3NxbC90LXNxbC1wcm9ncmFtbWluZy9kaXZpZGVkLXdlLXN0YW5kLXRoZS1zcWwtb2YtcmVsYXRpb25hbC1kaXZpc2lvbi8=" title="https://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/">https://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/<i class="fa fa-external-link"></i></span>）。</p><h3>推荐阅读 →_→ <span style="color: #0000ff;">《<span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vNDA0NDMv" title="http://blog.jobbole.com/40443/"><span style="color: #0000ff;">画图解释SQL联合语句</span><i class="fa fa-external-link"></i></span>》</span></h3><p><strong>我们学到了什么？</strong></p><p>学到了很多！让我们在脑海中再回想一下。 SQL 是对表的引用， JOIN 则是一种引用表的复杂方式。但是 SQL 语言的表达方式和实际我们所需要的逻辑关系之间是有区别的，并非所有的逻辑关系都能找到对应的 JOIN 操作，所以这就要我们在平时多积累和学习关系逻辑，这样你就能在以后编写 SQL 语句中选择适当的 JOIN 操作了。</p><h2>7、 SQL 中如同变量的派生表</h2><p>在这之前，我们学习到过 SQL 是一种声明性的语言，并且 SQL 语句中不能包含变量。但是你能写出类似于变量的语句，这些就叫做派生表：</p><p>说白了，所谓的派生表就是在括号之中的子查询：</p><pre class="brush: sql; gutter: true">-- A derived tableFROM (SELECT * FROM author)</pre><p>需要注意的是有些时候我们可以给派生表定义一个相关名（即我们所说的别名）。</p><pre class="brush: sql; gutter: true">-- A derived table with an aliasFROM (SELECT * FROM author) a</pre><p>派生表可以有效的避免由于 SQL 逻辑而产生的问题。举例来说：如果你想重用一个用 SELECT 和 WHERE 语句查询出的结果，这样写就可以（以 Oracle 为例）：</p><pre class="brush: sql; gutter: true">-- Get authors&#039; first and last names, and their age in daysSELECT first_name, last_name, ageFROM (  SELECT first_name, last_name, current_date - date_of_birth age  FROM author)-- If the age is greater than 10000 daysWHERE age &gt; 10000</pre><p>需要我们注意的是：在有些数据库，以及 SQL ： 1990 标准中，派生表被归为下一级——通用表语句（ common table experssion）。这就允许你在一个 SELECT 语句中对派生表多次重用。上面的例子就（几乎）等价于下面的语句：</p><pre class="brush: sql; gutter: true">WITH a AS (  SELECT first_name, last_name, current_date - date_of_birth age  FROM author)SELECT *FROM aWHERE age &gt; 10000</pre><p>当然了，你也可以给“ a ”创建一个单独的视图，这样你就可以在更广泛的范围内重用这个派生表了。更多信息可以阅读下面的文章（<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WaWV3XyhTUUwp" title="http://en.wikipedia.org/wiki/View_(SQL)">http://en.wikipedia.org/wiki/View_%28SQL%29<i class="fa fa-external-link"></i></span>）。</p><p><strong>我们学到了什么？</strong></p><p>我们反复强调，大体上来说 SQL 语句就是对表的引用，而并非对字段的引用。要好好利用这一点，不要害怕使用派生表或者其他更复杂的语句。</p><h2>8、 SQL 语句中 GROUP BY 是对表的引用进行的操作</h2><p>让我们再回想一下之前的 FROM 语句：</p><pre class="brush: sql; gutter: true">FROM a, b</pre><p>现在，我们将 GROUP BY 应用到上面的语句中：</p><pre class="brush: sql; gutter: true">GROUP BY A.x, A.y, B.z</pre><p>上面语句的结果就是产生出了一个包含三个字段的新的表的引用。我们来仔细理解一下这句话：当你应用 GROUP BY 的时候， SELECT 后没有使用聚合函数的列，都要出现在 GROUP BY 后面。<span style="color: #888888;">（译者注：原文大意为“当你是用 GROUP BY 的时候，你能够对其进行下一级逻辑操作的列会减少，包括在 SELECT 中的列”）。</span></p><ul><li>需要注意的是：其他字段能够使用聚合函数：</li></ul><pre class="brush: sql; gutter: true">SELECT A.x, A.y, SUM(A.z)FROM AGROUP BY A.x, A.y</pre><ul><li>还有一点值得留意的是： MySQL 并不坚持这个标准，这的确是令人很困惑的地方。<span style="color: #888888;">（译者注：这并不是说 MySQL 没有 GROUP BY 的功能）</span>但是不要被 MySQL 所迷惑。 GROUP BY 改变了对表引用的方式。你可以像这样既在 SELECT 中引用某一字段，也在 GROUP BY 中对其进行分组。</li></ul><p><strong>我们学到了什么？</strong></p><p>GROUP BY，再次强调一次，是在表的引用上进行了操作，将其转换为一种新的引用方式。</p><h2>9、 SQL 语句中的 SELECT 实质上是对关系的映射</h2><p>我个人比较喜欢“映射”这个词，尤其是把它用在关系代数上。<span style="color: #888888;">（译者注：原文用词为 projection ，该词有两层含义，第一种含义是预测、规划、设计，第二种意思是投射、映射，经过反复推敲，我觉得这里用映射能够更直观的表达出 SELECT 的作用）</span>。一旦你建立起来了表的引用，经过修改、变形，你能够一步一步的将其映射到另一个模型中。 SELECT 语句就像一个“投影仪”，我们可以将其理解成一个将源表中的数据按照一定的逻辑转换成目标表数据的函数。</p><p>通过 SELECT语句，你能对每一个字段进行操作，通过复杂的表达式生成所需要的数据。</p><p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条：</p><ol><li>你仅能够使用那些能通过表引用而得来的字段；</li><li>如果你有 GROUP BY 语句，你只能够使用 GROUP BY 语句后面的字段或者聚合函数；</li><li>当你的语句中没有 GROUP BY 的时候，可以使用开窗函数代替聚合函数；</li><li>当你的语句中没有 GROUP BY 的时候，你不能同时使用聚合函数和其它函数；</li><li>有一些方法可以将普通函数封装在聚合函数中；</li><li>……</li></ol><p>一些更复杂的规则多到足够写出另一篇文章了。比如：为何你不能在一个没有 GROUP BY 的 SELECT 语句中同时使用普通函数和聚合函数？（上面的第 4 条）</p><p>原因如下：</p><ol><li>凭直觉，这种做法从逻辑上就讲不通。</li><li>如果直觉不能够说服你，那么语法肯定能。 SQL : 1999 标准引入了 GROUPING SETS，SQL： 2003 标准引入了 group sets : GROUP BY() 。无论什么时候，只要你的语句中出现了聚合函数，而且并没有明确的 GROUP BY 语句，这时一个不明确的、空的 GROUPING SET 就会被应用到这段 SQL 中。因此，原始的逻辑顺序的规则就被打破了，映射（即 SELECT ）关系首先会影响到逻辑关系，其次就是语法关系。<span style="color: #888888;">（译者注：这段话原文就比较艰涩，可以简单理解如下：在既有聚合函数又有普通函数的 SQL 语句中，如果没有 GROUP BY 进行分组，SQL 语句默认视整张表为一个分组，当聚合函数对某一字段进行聚合统计的时候，引用的表中的每一条 record 就失去了意义，全部的数据都聚合为一个统计值，你此时对每一条 record 使用其它函数是没有意义的）。</span></li></ol><p>糊涂了？是的，我也是。我们再回过头来看点浅显的东西吧。</p><p><strong>我们学到了什么？</strong></p><p>SELECT 语句可能是 SQL 语句中最难的部分了，尽管他看上去很简单。其他语句的作用其实就是对表的不同形式的引用。而 SELECT 语句则把这些引用整合在了一起，通过逻辑规则将源表映射到目标表，而且这个过程是可逆的，我们可以清楚的知道目标表的数据是怎么来的。</p><p>想要学习好 SQL 语言，就要在使用 SELECT 语句之前弄懂其他的语句，虽然 SELECT 是语法结构中的第一个关键词，但它应该是我们最后一个掌握的。</p><h2>10、 SQL 语句中的几个简单的关键词： DISTINCT ， UNION ， ORDER BY 和 OFFSET</h2><p>在学习完复杂的 SELECT 豫剧之后，我们再来看点简单的东西：</p><ul><li>集合运算（ DISTINCT 和 UNION ）</li></ul><ul><li>排序运算（ ORDER BY，OFFSET…FETCH）</li></ul><p><strong>集合运算（ set operation）：</strong></p><p>集合运算主要操作在于集合上，事实上指的就是对表的一种操作。从概念上来说，他们很好理解：</p><ul><li>DISTINCT 在映射之后对数据进行去重</li></ul><ul><li>UNION 将两个子查询拼接起来并去重</li></ul><ul><li>UNION ALL 将两个子查询拼接起来但不去重</li></ul><ul><li>EXCEPT 将第二个字查询中的结果从第一个子查询中去掉</li></ul><ul><li>INTERSECT 保留两个子查询中都有的结果并去重</li></ul><p><strong>排序运算（ ordering operation）：</strong></p><p>排序运算跟逻辑关系无关。这是一个 SQL 特有的功能。排序运算不仅在 SQL 语句的最后，而且在 SQL 语句运行的过程中也是最后执行的。使用 ORDER BY 和 OFFSET…FETCH 是保证数据能够按照顺序排列的最有效的方式。其他所有的排序方式都有一定随机性，尽管它们得到的排序结果是可重现的。</p><p>OFFSET…SET是一个没有统一确定语法的语句，不同的数据库有不同的表达方式，如 MySQL 和 PostgreSQL 的 LIMIT…OFFSET、SQL Server 和 Sybase 的 TOP…START AT 等。具体关于 OFFSET..FETCH 的不同语法可以参考这篇文章</p><p>（<span class="exturl" data-url="aHR0cDovL3d3dy5qb29xLm9yZy9kb2MvMy4xL21hbnVhbC9zcWwtYnVpbGRpbmcvc3FsLXN0YXRlbWVudHMvc2VsZWN0LXN0YXRlbWVudC9saW1pdC1jbGF1c2Uv" title="http://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/">http://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/<i class="fa fa-external-link"></i></span>）。</p><p><strong>让我们在工作中尽情的使用 SQL！</strong></p><p>正如其他语言一样，想要学好 SQL 语言就要大量的练习。上面的 10 个简单的步骤能够帮助你对你每天所写的 SQL 语句有更好的理解。另一方面来讲，从平时常见的错误中也能积累到很多经验。下面的两篇文章就是介绍一些 JAVA 和其他开发者所犯的一些常见的 SQL 错误：</p><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9vcS5vcmcvMjAxMy8wNy8zMC8xMC1jb21tb24tbWlzdGFrZXMtamF2YS1kZXZlbG9wZXJzLW1ha2Utd2hlbi13cml0aW5nLXNxbC8=" title="http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/">10 Common Mistakes Java Developers Make when Writing SQL<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9vcS5vcmcvMjAxMy8wOC8xMi8xMC1tb3JlLWNvbW1vbi1taXN0YWtlcy1qYXZhLWRldmVsb3BlcnMtbWFrZS13aGVuLXdyaXRpbmctc3FsLw==" title="http://blog.jooq.org/2013/08/12/10-more-common-mistakes-java-developers-make-when-writing-sql/">10 More Common Mistakes Java Developers Make when Writing SQL<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多程序员视 SQL 为洪水猛兽。SQL 是一种为数不多的声明性语言，它的运行方式完全不同于我们所熟知的命令行语言、面向对象的程序语言、甚至是函数语言（尽管有些人认为 SQL 语言也是一种函数式语言）。&lt;/p&gt;
&lt;p&gt;我们每天都在写 SQL 并且应用在开源软件 jOOQ 中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/virtual-memory/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/virtual-memory/</id>
    <published>2019-06-14T02:52:59.709Z</published>
    <updated>2019-06-14T02:52:59.709Z</updated>
    
    <content type="html"><![CDATA[<p> 处理器的虚拟内存子系统为每个进程实现了虚拟地址空间。这让每个进程认为它在系统中是独立的。虚拟内存的优点列表别的地方描述的非常详细，所以这里就不重复了。本节集中在虚拟内存的实际的实现细节，和相关的成本。 </p><p> 虚拟地址空间是由CPU的内存管理单元(MMU)实现的。OS必须填充页表数据结构，但大多数CPU自己做了剩下的工作。这事实上是一个相当复杂的机制；最好的理解它的方法是引入数据结构来描述虚拟地址空间。 </p> <p> 由MMU进行地址翻译的输入地址是虚拟地址。通常对它的值很少有限制 — 假设还有一点的话。 虚拟地址在32位系统中是32位的数值，在64位系统中是64位的数值。在一些系统，例如x86和x86-64，使用的地址实际上包含了另一个层次的间接寻址：这些结构使用分段，这些分段只是简单的给每个逻辑地址加上位移。我们可以忽略这一部分的地址产生，它不重要，不是程序员非常关心的内存处理性能方面的东西。{<em>x86的分段限制是与性能相关的，但那是另一回事了</em>} </p><h3> 4.1 最简单的地址转换 </h3> <p> 有趣的地方在于由虚拟地址到物理地址的转换。MMU可以在逐页的基础上重新映射地址。就像地址缓存排列的时候，虚拟地址被分割为不同的部分。这些部分被用来做多个表的索引，而这些表是被用来创建最终物理地址用的。最简单的模型是只有一级表。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201303/18143754_rBvU.png">  <p> <b>Figure 4.1: 1-Level Address Translation</b> </p> </blockquote> <p> 图 4.1 显示了虚拟地址的不同部分是如何使用的。高字节部分是用来选择一个页目录的条目；那个目录中的每个地址可以被OS分别设置。页目录条目决定了物理内存页的地址；页面中可以有不止一个条目指向同样的物理地址。完整的内存物理地址是由页目录获得的页地址和虚拟地址低字节部分合并起来决定的。页目录条目还包含一些附加的页面信息，如访问权限。 </p><p> 页目录的数据结构存储在内存中。OS必须分配连续的物理内存，并将这个地址范围的基地址存入一个特殊的寄存器。然后虚拟地址的适当的位被用来作为页目录的索引，这个页目录事实上是目录条目的列表。 </p> <p> 作为一个具体的例子，这是 x86机器4MB分页设计。虚拟地址的位移部分是22位大小，足以定位一个4M页内的每一个字节。虚拟地址中剩下的10位指定页目录中1024个条目的一个。每个条目包括一个10位的4M页内的基地址，它与位移结合起来形成了一个完整的32位地址。 </p><h3> 4.2 多级页表 </h3> <p> 4MB的页不是规范，它们会浪费很多内存，因为OS需要执行的许多操作需要内存页的队列。对于4kB的页（32位机器的规范，甚至通常是64位机器的规范），虚拟地址的位移部分只有12位大小。这留下了20位作为页目录的指针。具有2<sup>20</sup>个条目的表是不实际的。即使每个条目只要4比特，这个表也要4MB大小。由于每个进程可能具有其唯一的页目录，因为这些页目录许多系统中物理内存被绑定起来。 </p> <p> 解决办法是用多级页表。然后这些就能表示一个稀疏的大的页目录，目录中一些实际不用的区域不需要分配内存。因此这种表示更紧凑，使它可能为内存中的很多进程使用页表而并不太影响性能。. </p><p> 今天最复杂的页表结构由四级构成。图4.2显示了这样一个实现的原理图。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201303/18143754_BaNt.png">  <p> <b>Figure 4.2: 4-Level Address Translation</b> </p> </blockquote> <p> 在这个例子中，虚拟地址被至少分为五个部分。其中四个部分是不同的目录的索引。被引用的第4级目录使用CPU中一个特殊目的的寄存器。第4级到第2级目录的内容是对次低一级目录的引用。如果一个目录条目标识为空，显然就是不需要指向任何低一级的目录。这样页表树就能稀疏和紧凑。正如图4.1，第1级目录的条目是一部分物理地址，加上像访问权限的辅助数据。 </p>为了决定相对于虚拟地址的物理地址，处理器先决定最高级目录的地址。这个地址一般保存在一个寄存器。然后CPU取出虚拟地址中相对于这个目录的索引部分，并用那个索引选择合适的条目。这个条目是下一级目录的地址，它由虚拟地址的下一部分索引。处理器继续直到它到达第1级目录，那里那个目录条目的值就是物理地址的高字节部分。物理地址在加上虚拟地址中的页面位移之后就完整了。这个过程称为页面树遍历。一些处理器（像x86和x86-64）在硬件中执行这个操作，其他的需要OS的协助。<p> 系统中运行的每个进程可能需要自己的页表树。有部分共享树的可能，但是这相当例外。因此如果页表树需要的内存尽可能小的话将对性能与可扩展性有利。理想的情况是将使用的内存紧靠着放在虚拟地址空间；但实际使用的物理地址不影响。一个小程序可能只需要第2，3，4级的一个目录和少许第1级目录就能应付过去。在一个采用4kB页面和每个目录512条目的x86-64机器上，这允许用4级目录对2MB定位（每一级一个）。1GB连续的内存可以被第2到第4级的一个目录和第1级的512个目录定位。 </p> <p> 但是，假设所有内存可以被连续分配是太简单了。由于复杂的原因，大多数情况下，一个进程的栈与堆的区域是被分配在地址空间中非常相反的两端。这样使得任一个区域可以根据需要尽可能的增长。这意味着最有可能需要两个第2级目录和相应的更多的低一级的目录。 </p><p> 但即使这也不常常匹配现在的实际。由于安全的原因，一个可运行的（代码，数据，堆，栈，动态共享对象，aka共享库）不同的部分被映射到随机的地址[未选中的]。随机化延伸到不同部分的相对位置；那意味着一个进程使用的不同的内存范围，遍布于虚拟地址空间。通过对随机的地址位数采用一些限定，范围可以被限制，但在大多数情况下，这当然不会让一个进程只用一到两个第2和第3级目录运行。 </p> <p> 如果性能真的远比安全重要，随机化可以被关闭。OS然后通常是在虚拟内存中至少连续的装载所有的动态共享对象(DSO)。 </p><h3> 4.3 优化页表访问 </h3> <p> 页表的所有数据结构都保存在主存中；在那里OS建造和更新这些表。当一个进程创建或者一个页表变化，CPU将被通知。页表被用来解决每个虚拟地址到物理地址的转换，用上面描述的页表遍历方式。更多有关于此：至少每一级有一个目录被用于处理虚拟地址的过程。这需要至多四次内存访问（对一个运行中的进程的单次访问来说），这很慢。有可能像普通数据一样处理这些目录表条目，并将他们缓存在L1d,L2等等，但这仍然非常慢。 </p> <p> <br> </p>从虚拟内存的早期阶段开始，CPU的设计者采用了一种不同的优化。简单的计算显示，只有将目录表条目保存在L1d和更高级的缓存，才会导致可怕的性能问题。每个绝对地址的计算，都需要相对于页表深度的大量的L1d访问。这些访问不能并行，因为它们依赖于前面查询的结果。在一个四级页表的机器上，这种单线性将 至少至少需要12次循环。再加上L1d的非命中的可能性，结果是指令流水线没有什么能隐藏的。额外的L1d访问也消耗了珍贵的缓存带宽。 <br><p> 所以，替代于只是缓存目录表条目，物理页地址的完整的计算结果被缓存了。因为同样的原因，代码和数据缓存也工作起来，这样的地址计算结果的缓存是高效的。由于虚拟地址的页面位移部分在物理页地址的计算中不起任何作用，只有虚拟地址的剩余部分被用作缓存的标签。根据页面大小这意味着成百上千的指令或数据对象共享同一个标签，因此也共享同一个物理地址前缀。 </p> <p> 保存计算数值的缓存叫做旁路转换缓存(TLB)。因为它必须非常的快，通常这是一个小的缓存。现代CPU像其它缓存一样，提供了多级TLB缓存；越高级的缓存越大越慢。小号的L1级TLB通常被用来做全相联映像缓存，采用LRU回收策略。最近这种缓存大小变大了，而且在处理器中变得集相联。其结果之一就是，当一个新的条目必须被添加的时候，可能不是最久的条目被回收于替换了。 </p><p> 正如上面提到的，用来访问TLB的标签是虚拟地址的一个部分。如果标签在缓存中有匹配，最终的物理地址将被计算出来，通过将来自虚拟地址的页面位移地址加到缓存值的方式。这是一个非常快的过程；也必须这样，因为每条使用绝对地址的指令都需要物理地址，还有在一些情况下，因为使用物理地址作为关键字的L2查找。如果TLB查询未命中，处理器就必须执行一次页表遍历；这可能代价非常大。 </p> <p> 通过软件或硬件预取代码或数据，会在地址位于另一页面时，暗中预取TLB的条目。硬件预取不可能允许这样，因为硬件会初始化非法的页面表遍历。因此程序员不能依赖硬件预取机制来预取TLB条目。它必须使用预取指令明确的完成。就像数据和指令缓存，TLB可以表现为多个等级。正如数据缓存，TLB通常表现为两种形式：指令TLB(ITLB)和数据TLB(DTLB)。高级的TLB像L2TLB通常是统一的，就像其他的缓存情形一样。 </p><p> <b>4.3.1 使用TLB的注意事项</b> </p> <p> TLB是以处理器为核心的全局资源。所有运行于处理器的线程与进程使用同一个TLB。由于虚拟到物理地址的转换依赖于安装的是哪一种页表树，如果页表变化了，CPU不能盲目的重复使用缓存的条目。每个进程有一个不同的页表树（不算在同一个进程中的线程），内核与内存管理器VMM(管理程序)也一样，如果存在的话。也有可能一个进程的地址空间布局发生变化。有两种解决这个问题的办法： </p> <ul>  <li> 当页表树变化时TLB刷新。 </li>  <li> TLB条目的标签附加扩展并唯一标识其涉及的页表树<br> </li> </ul> <p> 第一种情况，只要执行一个上下文切换TLB就被刷新。因为大多数OS中，从一个线程/进程到另一个的切换需要执行一些核心代码，TLB刷新被限制进入或离开核心地址空间。在虚拟化的系统中，当内核必须调用内存管理器VMM和返回的时候，这也会发生。如果内核和/或内存管理器没有使用虚拟地址，或者当进程或内核调用系统/内存管理器时，能重复使用同一个虚拟地址，TLB必须被刷新。当离开内核或内存管理器时，处理器继续执行一个不同的进程或内核。 </p>刷新TLB高效但昂贵。例如，当执行一个系统调用，触及的内核代码可能仅限于几千条指令，或许少许新页面（或一个大的页面，像某些结构的Linux的就是这样）。这个工作将替换触及页面的所有TLB条目。对Intel带128ITLB和256DTLB条目的Core2架构，完全的刷新意味着多于100和200条目（分别的）将被不必要的刷新。当系统调用返回同一个进程，所有那些被刷新的TLB条目可能被再次用到，但它们没有了。内核或内存管理器常用的代码也一样。每条进入内核的条目上，TLB必须擦去再装，即使内核与内存管理器的页表通常不会改变。因此理论上说，TLB条目可以被保持一个很长时间。这也解释了为什么现在处理器中的TLB缓存都不大：程序很有可能不会执行时间长到装满所有这些条目。<p> 当然事实逃脱不了CPU的结构。对缓存刷新优化的一个可能的方法是单独的使TLB条目失效。例如，如果内核代码与数据落于一个特定的地址范围，只有落入这个地址范围的页面必须被清除出TLB。这只需要比较标签，因此不是很昂贵。在部分地址空间改变的场合，例如对去除内存页的一次调用，这个方法也是有用的， </p> <p> 更好的解决方法是为TLB访问扩展标签。如果除了虚拟地址的一部分之外，一个唯一的对应每个页表树的标识（如一个进程的地址空间）被添加，TLB将根本不需要完全刷新。内核，内存管理程序，和独立的进程都可以有唯一的标识。这种场景唯一的问题在于，TLB标签可以获得的位数异常有限，但是地址空间的位数却不是。这意味着一些标识的再利用是有必要的。这种情况发生时TLB必须部分刷新（如果可能的话）。所有带有再利用标识的条目必须被刷新，但是希望这是一个非常小的集合。 </p><p> 当多个进程运行在系统中时，这种扩展的TLB标签具有一般优势。如果每个可运行进程对内存的使用（因此TLB条目的使用）做限制，进程最近使用的TLB条目,当其再次列入计划时，有很大机会仍然在TLB。但还有两个额外的优势： </p> <ol>  <li> 特殊的地址空间，像内核和内存管理器使用的那些，经常仅仅进入一小段时间；之后控制经常返回初始化此次调用的地址空间。没有标签，就有两次TLB刷新操作。有标签，调用地址空间缓存的转换地址将被保存，而且由于内核与内存管理器地址空间根本不会经常改变TLB条目，系统调用之前的地址转换等等可以仍然使用。 </li>  <li> 当同一个进程的两个线程之间切换时，TLB刷新根本就不需要。虽然没有扩展TLB标签时，进入内核的条目会破坏第一个线程的TLB的条目。 </li> </ol>有些处理器在一些时候实现了这些扩展标签。AMD给帕西菲卡（Pacifica）虚拟化扩展引入了一个1位的扩展标签。在虚拟化的上下文中，这个1位的地址空间ID（ASID）被用来从客户域区别出内存管理程序的地址空间。这使得OS能够避免在每次进入内存管理程序的时候（例如为了处理一个页面错误）刷新客户的TLB条目，或者当控制回到客户时刷新内存管理程序的TLB条目。这个架构未来会允许使用更多的位。其它主流处理器很可能会随之适应并支持这个功能。<p> <b>4.3.2 影响TLB性能</b> </p> <p> 有一些因素会影响TLB性能。第一个是页面的大小。显然页面越大，装进去的指令或数据对象就越多。所以较大的页面大小减少了所需的地址转换总次数，即需要更少的TLB缓存条目。大多数架构允许使用多个不同的页面尺寸；一些尺寸可以并存使用。例如，x86/x86-64处理器有一个普通的4kB的页面尺寸，但它们也可以分别用4MB和2MB页面。IA-64 和 PowerPC允许如64kB的尺寸作为基本的页面尺寸。 </p> <p> 然而，大页面尺寸的使用也随之带来了一些问题。用作大页面的内存范围必须是在物理内存中连续的。如果物理内存管理的单元大小升至虚拟内存页面的大小，浪费的内存数量将会增长。各种内存操作（如加载可执行文件）需要页面边界对齐。这意味着平均每次映射浪费了物理内存中页面大小的一半。这种浪费很容易累加；因此它给物理内存分配的合理单元大小划定了一个上限。 </p><p> 在x86-64结构中增加单元大小到2MB来适应大页面当然是不实际的。这是一个太大的尺寸。但这转而意味着每个大页面必须由许多小一些的页面组成。这些小页面必须在物理内存中连续。以4kB单元页面大小分配2MB连续的物理内存具有挑战性。它需要找到有512个连续页面的空闲区域。在系统运行一段时间并且物理内存开始碎片化以后，这可能极为困难（或者不可能） </p> <p> 因此在Linux中有必要在系统启动的时候，用特别的<span style="font-size:13px;">Huge TLBfs</span>文件系统，预分配这些大页面。一个固定数目的物理页面被保留，以单独用作大的虚拟页面。这使可能不会经常用到的资源捆绑留下来。它也是一个有限的池；增大它一般意味着要重启系统。尽管如此，大页面是进入某些局面的方法，在这些局面中性能具有保险性，资源丰富，而且麻烦的安装不会成为大的妨碍。数据库服务器就是一个例子。 </p><p> 增大最小的虚拟页面大小（正如选择大页面的相反面）也有它的问题。内存映射操作（例如加载应用）必须确认这些页面大小。不可能有更小的映射。对大多数架构来说，一个可执行程序的各个部分位置有一个固定的关系。如果页面大小增加到超过了可执行程序或DSO(Dynamic Shared Object)创建时考虑的大小，加载操作将无法执行。脑海里记得这个限制很重要。图4.3显示了一个ELF二进制的对齐需求是如何决定的。它编码在ELF程序头部。 </p> <pre>$ eu-readelf -l /bin/lsProgram Headers:  Type   Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align...  LOAD   0x000000 0x0000000000400000 0x0000000000400000 0x0132ac 0x0132ac R E 0x200000  LOAD   0x0132b0 0x00000000006132b0 0x00000000006132b0 0x001a71 0x001a71 RW  0x200000...</pre> <p> <b>Figure 4.3: ELF 程序头表明了对齐需求</b> </p> <p> 在这个例子中，一个x86-64二进制，它的值为0x200000&nbsp;=&nbsp;2,097,152&nbsp;=&nbsp;2MB，符合处理器支持的最大页面尺寸。 </p><p> 使用较大内存尺寸有第二个影响：页表树的级数减少了。由于虚拟地址相对于页面位移的部分增加了，需要用来在页目录中使用的位，就没有剩下许多了。这意味着当一个TLB未命中时，需要做的工作数量减少了。 </p> <p> 超出使用大页面大小，它有可能减少移动数据时需要同时使用的TLB条目数目，减少到数页。这与一些上面我们谈论的缓存使用的优化机制类似。只有现在对齐需求是巨大的。考虑到TLB条目数目如此小，这可能是一个重要的优化。 </p><h3> 4.4 虚拟化的影响 </h3> <p> OS映像的虚拟化将变得越来越流行；这意味着另一个层次的内存处理被加入了想象。进程（基本的隔间）或者OS容器的虚拟化，因为只涉及一个OS而没有落入此分类。类似Xen或KVM的技术使OS映像能够独立运行 — 有或者没有处理器的协助。这些情形下，有一个单独的软件直接控制物理内存的访问。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201303/18143755_MZnV.png">  <p> <b>图 4.4: Xen 虚拟化模型</b> </p> </blockquote> <p> 对Xen来说（见图4.4），Xen VMM(Xen内存管理程序)就是那个软件。但是，VMM没有自己实现许多硬件的控制，不像其他早先的系统（包括Xen VMM的第一个版本）的VMM，内存以外的硬件和处理器由享有特权的Dom0域控制。现在，这基本上与没有特权的DomU内核一样，就内存处理方面而言，它们没有什么不同。这里重要的是，VMM自己分发物理内存给Dom0和DomU内核，然后就像他们是直接运行在一个处理器上一样，实现通常的内存处理 </p>为了实现完成虚拟化所需的各个域之间的分隔，Dom0和DomU内核中的内存处理不具有无限制的物理内存访问权限。VMM不是通过分发独立的物理页并让客户OS处理地址的方式来分发内存；这不能提供对错误或欺诈客户域的防范。替代的，VMM为每一个客户域创建它自己的页表树，并且用这些数据结构分发内存。好处是对页表树管理信息的访问能得到控制。如果代码没有合适的特权，它不能做任何事。在虚拟化的Xen支持中，这种访问控制已被开发，不管使用的是参数的或硬件的（又名全）虚拟化。客户域以意图上与参数的和硬件的虚拟化极为相似的方法，给每个进程创建它们的页表树。每当客户OS修改了VMM调用的页表，VMM就会用客户域中更新的信息去更新自己的影子页表。这些是实际由硬件使用的页表。显然这个过程非常昂贵：每次对页表树的修改都需要VMM的一次调用。而没有虚拟化时内存映射的改变也不便宜，它们现在变得甚至更昂贵。考虑到从客户OS的变化到VMM以及返回，其本身已经相当昂贵，额外的代价可能真的很大。这就是为什么处理器开始具有避免创建影子页表的额外功能。这样很好不仅是因为速度的问题，而且它减少了VMM消耗的内存。Intel有扩展页表(EPTs)，AMD称之为嵌套页表(NPTs)。基本上两种技术都具有客户OS的页表，来产生虚拟的物理地址。然后通过每个域一个EPT/NPT树的方式，这些地址会被进一步转换为真实的物理地址。这使得可以用几乎非虚拟化情境的速度进行内存处理，因为大多数用来内存处理的VMM条目被移走了。它也减少了VMM使用的内存，因为现在一个域（相对于进程）只有一个页表树需要维护。额外的地址转换步骤的结果也存储于TLB。那意味着TLB不存储虚拟物理地址，而替代以完整的查询结果。已经解释过AMD的帕西菲卡扩展为了避免TLB刷新而给每个条目引入ASID。ASID的位数在最初版本的处理器扩展中是一位；这正好足够区分VMM和客户OS。Intel有服务同一个目的的虚拟处理器ID(VPIDs)，它们只有更多位。但对每个客户域VPID是固定的，因此它不能标记单独的进程，也不能避免TLB在那个级别刷新。<p> 对虚拟OS，每个地址空间的修改需要的工作量是一个问题。但是还有另一个内在的基于VMM虚拟化的问题：没有什么办法处理两层的内存。但内存处理很难（特别是考虑到像NUMA一样的复杂性，见第5部分）。Xen方法使用一个单独的VMM，这使最佳的（或最好的）处理变得困难，因为所有内存管理实现的复杂性，包括像发现内存范围之类“琐碎的”事情，必须被复制于VMM。OS有完全成熟的与最佳的实现；人们确实想避免复制它们。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201303/18143755_Lonh.png">  <p> <b>图 4.5: KVM 虚拟化模型</b> </p> </blockquote>这就是为什么对VMM/Dom0模型的分析是这么有吸引力的一个选择。图4.5显示了KVM的Linux内核扩展如何尝试解决这个问题的。并没有直接运行在硬件之上且管理所有客户的单独的VMM，替代的，一个普通的Linux内核接管了这个功能。这意味着Linux内核中完整且复杂的内存管理功能，被用来管理系统的内存。客户域运行于普通的用户级进程，创建者称其为“客户模式”。虚拟化的功能，参数的或全虚拟化的，被另一个用户级进程KVM VMM控制。这也就是另一个进程用特别的内核实现的KVM设备，去恰巧控制一个客户域。<p> 这个模型相较Xen独立的VMM模型好处在于，即使客户OS使用时，仍然有两个内存处理程序在工作，只需要在Linux内核里有一个实现。不需要像Xen VMM那样从另一段代码复制同样的功能。这带来更少的工作，更少的bug，或许还有更少的两个内存处理程序接触产生的摩擦，因为一个Linux客户的内存处理程序与运行于裸硬件之上的Linux内核的外部内存处理程序，做出了相同的假设。 </p> <p> 总的来说，程序员必须清醒认识到，采用虚拟化时，内存操作的代价比没有虚拟化要高很多。任何减少这个工作的优化，将在虚拟化环境付出更多。随着时间的过去，处理器的设计者将通过像EPT和NPT技术越来越减少这个差距，但它永远都不会完全消失。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 处理器的虚拟内存子系统为每个进程实现了虚拟地址空间。这让每个进程认为它在系统中是独立的。虚拟内存的优点列表别的地方描述的非常详细，所以这里就不重复了。本节集中在虚拟内存的实际的实现细节，和相关的成本。 &lt;/p&gt;
&lt;p&gt; 虚拟地址空间是由CPU的内存管理单元(MMU)实现的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/jvm/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/jvm/</id>
    <published>2019-06-14T02:52:59.705Z</published>
    <updated>2019-06-14T02:52:59.705Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h2>简介</h2><p></p><p>Java虚拟机（JVM）是Java应用的运行环境，从一般意义上来讲，JVM是通过规范来定义的一个虚拟的计算机，被设计用来解释执行从Java源码编译而来的字节码。更通俗地说，JVM是指对这个规范的具体实现。这种实现基于严格的指令集和全面的内存模型。另外，JVM也通常被形容为对软件运行时环境的实现。通常JVM实现主要指的是HotSpot。</p><p>JVM规范保证任何的实现都能够以同样的方式解释执行字节码。其实现可以多样化，包括进程、独立的Java操作系统或者直接执行字节码的处理器芯片。我们了解最多的JVM是作为软件实现，运行在流行的操作系统平台上（包括Windows、OS X、Linux和Solaris等）。</p><p>JVM的结构允许对一个Java应用进行更细微的控制。这些应用运行在沙箱（Sandbox）环境中。确保在没有恰当的许可时，无法访问到本地文件系统、处理器和网络连接。远程执行时，代码还需要进行证书认证。</p><p>除了解释执行Java字节码，大多数的JVM实现还包含一个JIT（just-in-time 即时）编译器，用于为常用的方法生成机器码。机器码使用的是CPU的本地语言，相比字节码有着更快的运行速度。</p><p>虽然理解JVM不是开发或运行Java程序的必要条件，但是如果多了解一些JVM知识，那么就有机会避免很多性能上的问题。理解了JVM，实际上这些问题会变得简单明了。</p><h2>体系结构</h2><p>JVM规范定义了一系列子系统以及它们的外部行为。JVM主要有以下子系统：</p><ul><li><code>Class Loader</code> 类加载器。 用于读入Java源代码并将类加载到数据区。</li><li><code>Execution Engine</code> 执行引擎。 执行来自数据区的指令。</li></ul><p>数据区使用的是底层操作系统分配给JVM的内存。</p><figure class="full-width-mobile  thin" style="width: 560px;"><span class="exturl" data-url="aHR0cDovL3d3dy5pbXBvcnRuZXcuY29tLzEzNTU2Lmh0bWwvanZtLWFyY2hpdGVjdHVyZS0y" title="http://www.importnew.com/13556.html/jvm-architecture-2"><img alt src="http://cdn1.importnew.com/2014/10/2110dde86cb967889d749a8aed23cdaf.png" class="wp-image-13560"><i class="fa fa-external-link"></i></span></figure><h2>类加载器（Class Loader）</h2><p>JVM在下面几种不同的层面使用不同的类加载器：</p><ul><li>bootstrap class loader（引导类加载器）：是其他类加载器的父类，它用于加载Java核心库，并且是唯一一个用本地代码编写的类加载器。</li><li>extension class loader（扩展类加载器）：是bootstrap class loader加载器的子类，用于加载扩展库。</li><li>system class loader（系统类加载器）：是extension class loader加载器的子类，用于加载在classpath中的应用程序的类文件。</li><li>user-defined class loader（用户定义的类加载器）：是系统类加载器或其他用户定义的类加载器的子类。</li></ul><p>当一个类加载器收到一个加载类的请求，首先它会检查缓存，确认该类是否已经被加载，然后把请求代理给它的父类。如果父类没能成功的加载类，那么子类就会自己去尝试加载该类。子类可检查父类加载器的缓存，但父类不能看到子类所加载的类。之所类加载体系会这样设计，是认为一个子类不应该重复加载已经被父类加载过的类。</p><h2>执行引擎（Execution Engine）</h2><p>执行引擎一个接一个地执行被加载到数据区的字节码。为了保证字节码指令对于机器来说是可读的，执行引擎使用下面两个方法：</p><ul><li>解释执行：执行引擎把它遇到的每一条指令解释为机器语言。</li><li>即时编译：如果一条指令经常被使用，执行引擎会把它编译为本地代码并存储在缓存中。这样，所有和这个方法相关的代码都会直接执行，从而避免重复解释。</li></ul><p>尽管即时编译比解释执行要占用更多的时间，但是对于需要使用成千上万次的方法，只需要处理一次。相比每次都解释执行，以本地代码的方式运行会节约很多执行时间。</p><p>JVM规范中并不规定一定要使用即时编译。即时编译也不是用于提高JVM性能的唯一的手段。规范仅仅规定了每条字节码对应的本地代码，至于执行引擎如何实现这一对应过程的，完全由JVM的具体实现来决定。</p><h2>内存模型（Memory Model）</h2><p>Java内存模型建立在自动内存管理的概念之上。当一个对象不再被一个应用所引用，垃圾回收器就会回收它，从而释放相应的内存。这一点和其他很多需要自行释放内存的语言有很大不同。</p><p>JVM从底层操作系统中分配内存，并将它们分为以下几个区域：</p><ul><li>堆空间（Heap Space）：这是共享的内存区域，用于存储可以被垃圾回收器回收的对象。</li><li>方法区（Method Area）：这块区域以前被称作“永生代”（permanent generation），用于存储被加载的类。这块区域最近被JVM取消了。现在，被加载的类作为元数据加载到底层操作系统的本地内存区。</li><li>本地区（Native Area）：这个区域用于存储基本类型的引用和变量。</li></ul><p>一个有效的管理内存方法是把对空间划分为不同代，这样垃圾回收器就不用扫描整个堆区。大多数的对象的生命周期都很段短暂，那些生命周期较长的对象往往直到应用退出才需要被清除。</p><p>当一个Java应用创建了一个对象，这个对象是被存储到“初生池”（<code>eden pool</code>）。一旦初生池存储满了，就会在新生代触发一次minor gc（小范围的垃圾回收）。首先，垃圾回收器会标记出那些“死对象”（不再被应用所引用的对象），同时延长所有保留对象的生命周期（这个生命周期长度是用数字来描述，代表了期所经历过的垃圾回收的次数）。然后，垃圾回收器会回收这些死对象，并把剩余的活着的对象移动到“幸存池”（<code>survivor pool</code>），从而清空初生池。</p><p>当一个对象存活达到一定的周期后，它就会被移动到堆中的老生代：“终身代”（<code>tenured pool</code>）。最后，当终身代被填满时，就会触发一次full gc或major gc（完全的垃圾回收），以清理终身代。</p><p><em>（译者注：一般我们把初生池和幸存池所在的区域合并成为新生代，把终身代所在的区域成为老生代。对应的，在新生代上产生的gc称为minor gc，在老生代上产生的gc称为full gc。希望这样大家在其他地方看到对应的术语时能更好理解）</em></p><p>当垃圾回收（gc）执行的时候，所有应用线程都要被停止，系统产生一次暂停。minor gc非常频繁，所以被优化的能够快速的回收死对象，是新生代的内存的主要的回收方式。major gc运行起来就相对慢得多，因为要扫描非常多的活着的对象。垃圾回收器本身也有多种实现，有些垃圾回收器在一定情况下能更快的执行major gc。</p><p>堆的大小是动态的，只有堆需要扩张的时候才会从内存中分配。当堆被填满时，JVM会重新给堆分配更多的内存，直到达到堆大小的上限，这种重新分配同样会导致应用的短暂停止。</p><h2>线程</h2><p>JVM是运行在一个独立的进程中的，但它可以并发执行多个线程，每个线程都运行自己的方法，这是Java必备的一个部分。以即时消息客户端这样一个应用为例，它至少运行两个线程。一个线程用于等待用户输入，另一个检查服务端是否有新的消息传输。再以服务端应用为例，有时一个请求可能要涉及多个线程并发执行，所以需要多线程来处理请求。</p><p>在JVM的进程中，所有的线程共享内存和其他可用的资源。每一个JVM进程在进入点（main方法）处都要启动一个主线程，其他线程都从主线程启动，成为执行过程中的一个独立部分。线程可以再不同的处理器上并行执行，同样也可以共享一个处理器，线程调度器负责处理多个线程共享一个处理器的情况。</p><p>很多应用（特别是服务端应用）会处理很多任务，需要并行运行。这些任务中有些是非常重要的，需要实时执行的。而另外一些是后台任务，可以在CPU空闲时执行。任务是在不同的线程中运行的。举例子来说，服务端可能有一些低优先级的线程，它们会根据一些数据来计算统计信息。同时也会启动一些高优先级的进程用于处理传入的数据，响应对这些统计信息的请求。这里可能有很多的源数据，很多来自客户端的数据请求，每个请求都会使服务端短暂的停止后台计算的线程以响应这个请求。所以，你必须监控在运行的线程数目并且保证有足够的CPU时间来执行必要的计算。</p><p><em>（译者注：这一段在原文中是在性能优化的章节，译者认为这可能是作者的不小心，似乎放在线程的章节更合适。）</em></p><h2>性能优化</h2><p>JVM的性能取决于其配置是否与应用的功能相匹配。尽管垃圾回收器和内存回收进程是自动管理内存的，但是你必须掌管它们的频率。通常来说，你的应用可使用的内存越多，那么这些会导致应用暂停的内存管理进程需要起作用的就越少。</p><p>如果垃圾回收发生的频率比你想的要多很多，那么可以在启动JVM的时候为其配置更大的最大堆大小值。堆被填满的时间越久，就越能降低垃圾回收发生的频率。最大堆大小值可以在启动JVM的时候，用<code>-Xmx</code>参数来设定。默认的最大堆大小是被设置为可用的操作系统内存的四分之一，或者最小1GB。</p><p>如果问题出在经常重新分配内存，那么你可以把初始化堆大小设置为和最大堆大小一样。这就意味着JVM永远不需要为堆重新分配内存。但这样做就会失去动态堆大小适配的优化，堆的大小从一开始就被固定下来。配置初始化对大小是在启动JVM，用<code>-Xms</code>来设定。默认初始化堆大小会被设定为操作系统可用的物理内存的六十四分之一，或者设置一个最小值。这个值是根据不同的平台来确定的。</p><p>如果你清楚是哪种垃圾回收（minor gc或major gc）导致了性能问题，可以在不改变整个堆大小的情况下设定新生代和老生代的大小比例。对于需要产生大量临时对象的应用，需要增大新生代的比例（当然，后果是减小了老生代的大小）。对于长生命周期对象较多的应用，则需增大老生代的比例（自然需要减少新生代的大小）。以下几种方法可以用来设定新生代和老生代的大小：</p><ul><li>在启动JVM时，使用<code>-XX:NewRatio</code>参数来具体指定新生代和老生代的大小比例。比如，如果想让老生代的大小是新生代的五倍，则设置参数为-XX:NewRatio=5，默认这个参数设定为2（即老生代占用堆空间的三分之二，新生代占用三分之一）。</li><li>在启动JVM时，直接使用<code>-Xmn</code>参数设定初始化和最大新生代大小，那么堆中的剩余大小即是老生代的大小。</li><li>在启动JVM时，直接使用<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>参数设定初始化和最大新生代大小，那么堆中的剩余大小即是老生代的大小。</li></ul><p>每一个线程都有一个栈，用于保存函数调用、返回地址等等，这些栈有着对应的内存分配。如果线程过多，就会导致OutOfMemory错误。即使你有足够的空间的堆来存放对象，你的应用也可能会因为创建一个新的线程而崩溃。这种情况下，需要考虑限制线程中的栈大小的最大值。线程栈大小可以在JVM启动的时候，通过<code>-Xss</code>参数来设置，默认这个值被设定为320KB至1024KB之间，这和平台相关。</p><h2>性能监控</h2><p>当开发或运行一个Java应用的时候，对JVM的性能进行监控是很重要的。配置JVM不是一次配置就万事大吉的，特别是你要应对的是Java服务器应用的情况。你必须持续的检查堆内存和非堆内存的分配和使用情况，线程数的创建情况和内存中加载的类的数据情况等。这些都是核心参数。</p><p>使用Anturis控制台，你可以为任何的硬件组件上运行的JVM<span class="exturl" data-url="aHR0cHM6Ly9hbnR1cmlzLmNvbS9qdm0tbW9uaXRvcmluZy8=" title="https://anturis.com/jvm-monitoring/">配置监控<i class="fa fa-external-link"></i></span>（例如，在一台电脑上运行的一个Tomcat网页服务器）。</p><p>JVM监控可以使用以下衡量标准：</p><ul><li>总内存使用情况（MB）：即JVM使用的总内存。如果JVM使用了所有可用内存，这项指标可以衡量底层操作系统的整体性能。</li><li>堆内存使用（MB）：即JVM为运行的Java应用所使用的对象分配的所有内存。不使用的对象通常会被垃圾回收器从堆中移除。所以，如果这个指数增大，表示你的应用没有把不使用的对象移除或者你需要更好的配置垃圾回收器的参数。</li><li>非堆内存的使用（MB）：即为方法区和代码缓存分配的所有内存。方法区是用于存储被加载的类的引用，如果这些引用没有被适当的清理，永生代池会在每次应用被重新部署的时候都会增大，导致非堆的内存泄露。这个指标也可能指示了线程创建的泄露。</li><li>池内总内存（MB）：即JVM所分配的所有变量内存池的内存和（即除了代码缓存区外的所有内存和）。这个指标能够让你明确你的应用在JVM过载前所能使用的总内存。</li><li>线程：即所有有效线程数。举个例子，在Tomcat服务器中每个请求都是一个独立的线程来处理，所以这个衡量指标可以表示当前有多少个请求数，是否影响到了后台低权限的线程的运行。</li><li>类：即所有被加载的类的总数。如果你的应用动态的创建很多类，这可能是服务器内存泄露的一个原因。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Java虚拟机（JVM）是Java应用的运行环境，从一般意义上来讲，JVM是通过规范来定义的一个虚拟的计算机，被设计用来解释执行从Java源码编译而来的字节码。更通俗地说，JVM是指对这个规范的具体实现。这种实现基
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/malloc/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/malloc/</id>
    <published>2019-06-14T02:52:59.705Z</published>
    <updated>2019-06-14T02:52:59.705Z</updated>
    
    <content type="html"><![CDATA[  <p>任何一个用过或学过C的人对malloc都不会陌生。大家都知道malloc可以分配一段连续的内存空间，并且在不再使用时可以通过free释放掉。但是，许多程序员对malloc背后的事情并不熟悉，许多人甚至把malloc当做操作系统所提供的系统调用或C的关键字。实际上，malloc只是C的标准库中提供的一个普通函数，而且实现malloc的<strong>基本</strong>思想并不复杂，任何一个对C和操作系统有些许了解的程序员都可以很容易理解。</p><p>这篇文章通过实现一个简单的malloc来描述malloc背后的机制。当然与现有C的标准库实现（例如glibc）相比，我们实现的malloc并不是特别高效，但是这个实现比目前真实的malloc实现要简单很多，因此易于理解。重要的是，这个实现和真实实现在基本原理上是一致的。</p><p>这篇文章将首先介绍一些所需的基本知识，如操作系统对进程的内存管理以及相关的系统调用，然后逐步实现一个简单的malloc。为了简单起见，这篇文章将只考虑x86_64体系结构，操作系统为Linux。</p><!-- toc --><ul><li><a href="#1-什么是malloc">1 什么是malloc</a></li><li><a href="#2-预备知识">2 预备知识</a><ul><li><a href="#21-linux内存管理">2.1 Linux内存管理</a><ul><li><a href="#211-虚拟内存地址与物理内存地址">2.1.1 虚拟内存地址与物理内存地址</a></li><li><a href="#212-页与地址构成">2.1.2 页与地址构成</a></li><li><a href="#213-内存页与磁盘页">2.1.3 内存页与磁盘页</a></li></ul></li><li><a href="#22-linux进程级内存管理">2.2 Linux进程级内存管理</a><ul><li><a href="#221-内存排布">2.2.1 内存排布</a></li><li><a href="#222-heap内存模型">2.2.2 Heap内存模型</a></li><li><a href="#223-brk与sbrk">2.2.3 brk与sbrk</a></li><li><a href="#224-资源限制与rlimit">2.2.4 资源限制与rlimit</a></li></ul></li></ul></li><li><a href="#3-实现malloc">3 实现malloc</a><ul><li><a href="#31-玩具实现">3.1 玩具实现</a></li><li><a href="#32-正式实现">3.2 正式实现</a><ul><li><a href="#321-数据结构">3.2.1 数据结构</a></li><li><a href="#322-寻找合适的block">3.2.2 寻找合适的block</a></li><li><a href="#323-开辟新的block">3.2.3 开辟新的block</a></li><li><a href="#324-分裂block">3.2.4 分裂block</a></li><li><a href="#325-malloc的实现">3.2.5 malloc的实现</a></li><li><a href="#326-calloc的实现">3.2.6 calloc的实现</a></li><li><a href="#327-free的实现">3.2.7 free的实现</a></li><li><a href="#328-realloc的实现">3.2.8 realloc的实现</a></li></ul></li><li><a href="#33-遗留问题和优化">3.3 遗留问题和优化</a></li></ul></li><li><a href="#4-其它参考">4 其它参考</a></li></ul><!-- toc stop --><h1 id="1-什么是malloc">1 什么是malloc</h1><p>在实现malloc之前，先要相对正式地对malloc做一个定义。</p><p>根据标准C库函数的定义，malloc具有如下原型：</p><pre class="prettyprint linenums lang-c">void* malloc(size_t size);</pre><p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p><ul><li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li><li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li><li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li><li>malloc应该尽快完成内存分配并返回（不能使用<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OUC1oYXJk" title="http://en.wikipedia.org/wiki/NP-hard">NP-hard<i class="fa fa-external-link"></i></span>的内存分配算法）</li><li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li></ul><p>对于malloc更多的说明可以在命令行中键入以下命令查看：</p><pre class="prettyprint linenums lang-bash">man malloc</pre><h1 id="2-预备知识">2 预备知识</h1><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p><h2 id="21-linux内存管理">2.1 Linux内存管理</h2><h3 id="211-虚拟内存地址与物理内存地址">2.1.1 虚拟内存地址与物理内存地址</h3><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片$2^N$字节的内存，其中$N$是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为$2^{64}$Byte。</p><p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p><p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1vcnlfbWFuYWdlbWVudF91bml0" title="http://en.wikipedia.org/wiki/Memory_management_unit">MMU<i class="fa fa-external-link"></i></span>（Memory Management Unit）的硬件完成。</p><h3 id="212-页与地址构成">2.1.2 页与地址构成</h3><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p><p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：</p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-01.png" alt="内存地址构成"></p><p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内偏移都是用低12位表示，而剩下的高地址表示页号。</p><p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYWdlX3RhYmxl" title="http://en.wikipedia.org/wiki/Page_table">页表<i class="fa fa-external-link"></i></span>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc2xhdGlvbl9sb29rYXNpZGVfYnVmZmVy" title="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB<i class="fa fa-external-link"></i></span>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。</p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-02.png" alt="内存地址翻译"></p><h3 id="213-内存页与磁盘页">2.1.3 内存页与磁盘页</h3><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p><p>最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYWdlX3RhYmxl" title="http://en.wikipedia.org/wiki/Page_table">图片来源页<i class="fa fa-external-link"></i></span>）。</p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-03.png" alt="较为完整的地址翻译流程"></p><h2 id="22-linux进程级内存管理">2.2 Linux进程级内存管理</h2><h3 id="221-内存排布">2.2.1 内存排布</h3><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p><p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p><p>根据<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi94ODYveDg2XzY0L21tLnR4dA==" title="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">Linux内核相关文档<i class="fa fa-external-link"></i></span>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-04.png" alt="Linux进程地址排布"></p><p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p><ul><li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li><li>Data：这里存放的是初始化过的全局变量</li><li>BSS：这里存放的是未初始化的全局变量</li><li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li><li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li><li>Stack：这是栈区域，自高地址向低地址增长</li></ul><p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p><h3 id="222-heap内存模型">2.2.2 Heap内存模型</h3><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p><p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：</p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-05.png" alt="Linux进程堆管理"></p><p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p><h3 id="223-brk与sbrk">2.2.3 brk与sbrk</h3><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：</p><pre class="prettyprint linenums lang-c">int brk(void *addr);void *sbrk(intptr_t increment);</pre><p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p><p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p><p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p><h3 id="224-资源限制与rlimit">2.2.4 资源限制与rlimit</h3><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：</p><pre class="prettyprint linenums lang-c">int main() {    struct rlimit *limit = (struct rlimit *)malloc(sizeof(struct rlimit));    getrlimit(RLIMIT_AS, limit);    printf(&quot;soft limit: %ld, hard limit: %ld\n&quot;, limit-&gt;rlim_cur, limit-&gt;rlim_max);}</pre><p>其中rlimit是一个结构体：</p><pre class="prettyprint linenums lang-c">struct rlimit {    rlim_t rlim_cur;  /* Soft limit */    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */};</pre><p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p><h1 id="3-实现malloc">3 实现malloc</h1><h2 id="31-玩具实现">3.1 玩具实现</h2><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p><pre class="prettyprint linenums lang-c">/* 一个玩具malloc */#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;void *malloc(size_t size){    void *p;    p = sbrk(0);    if (sbrk(size) == (void *)-1)        return NULL;    return p;}</pre><p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p><h2 id="32-正式实现">3.2 正式实现</h2><p>下面严肃点讨论malloc的实现方案。</p><h3 id="321-数据结构">3.2.1 数据结构</h3><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p><p>可以用如下结构体定义一个block：</p><pre class="prettyprint linenums lang-c">typedef struct s_block *t_block;struct s_block {    size_t size;  /* 数据区大小 */    t_block next; /* 指向下个块的指针 */    int free;     /* 是否是空闲块 */    int padding;  /* 填充4字节，保证meta块长度为8的倍数 */    char data[1]  /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */};</pre><p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：</p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-06.png" alt="Block结构"></p><h3 id="322-寻找合适的block">3.2.2 寻找合适的block</h3><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p><ul><li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li><li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li></ul><p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p><pre class="prettyprint linenums lang-c">/* First fit */t_block find_block(t_block *last, size_t size) {    t_block b = first_block;    while(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) {        *last = b;        b = b-&gt;next;    }    return b;}</pre><p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p><h3 id="323-开辟新的block">3.2.3 开辟新的block</h3><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p><pre class="prettyprint linenums lang-c">#define BLOCK_SIZE 24 /* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */<p>t_block extend_heap(t_block last, size_t s) {<br>    t_block b;<br>    b = sbrk(0);<br>    if(sbrk(BLOCK_SIZE + s) == (void *)-1)<br>        return NULL;<br>    b-&gt;size = s;<br>    b-&gt;next = NULL;<br>    if(last)<br>        last-&gt;next = b;<br>    b-&gt;free = 0;<br>    return b;<br>}</p></pre><p></p><h3 id="324-分裂block">3.2.4 分裂block</h3><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：</p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a--tutorial-07.png" alt="分裂block"></p><p>实现代码：</p><pre class="prettyprint linenums lang-c">void split_block(t_block b, size_t s) {    t_block new;    new = b-&gt;data + s;    new-&gt;size = b-&gt;size - s - BLOCK_SIZE ;    new-&gt;next = b-&gt;next;    new-&gt;free = 1;    b-&gt;size = s;    b-&gt;next = new;}</pre><h3 id="325-malloc的实现">3.2.5 malloc的实现</h3><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p><p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p><pre class="prettyprint linenums lang-c">size_t align8(size_t s) {    if(s &amp; 0x7 == 0)        return s;    return ((s &gt;&gt; 3) + 1) &lt;&lt; 3;}</pre><pre class="prettyprint linenums lang-c">#define BLOCK_SIZE 24void *first_block=NULL;<p>/* other functions… */</p><p>void <em>malloc(size_t size) {<br>    t_block b, last;<br>    size_t s;<br>    /</em> 对齐地址 <em>/    s = align8(size);<br>    if(first_block) {<br>        /</em> 查找合适的block <em>/        last = first_block;<br>        b = find_block(&amp;last, s);<br>        if(b) {<br>            /</em> 如果可以，则分裂 <em>/            if ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + 8))<br>                split_block(b, s);<br>            b-&gt;free = 0;<br>        } else {<br>            /</em> 没有合适的block，开辟一个新的 */<br>            b = extend_heap(last, s);<br>            if(!b)<br>                return NULL;<br>        }<br>    } else {<br>        b = extend_heap(NULL, s);<br>        if(!b)<br>            return NULL;<br>        first_block = b;<br>    }<br>    return b-&gt;data;<br>}</p></pre><p></p><h3 id="326-calloc的实现">3.2.6 calloc的实现</h3><p>有了malloc，实现calloc只要两步：</p><ol><li>malloc一段内存</li><li>将数据区内容置为0</li></ol><p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p><pre class="prettyprint linenums lang-c">void *calloc(size_t number, size_t size) {    size_t *new;    size_t s8, i;    new = malloc(number * size);    if(new) {        s8 = align8(number * size) &gt;&gt; 3;        for(i = 0; i &lt; s8; i++)            new[i] = 0;    }    return new;}</pre><h3 id="327-free的实现">3.2.7 free的实现</h3><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p><ol><li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li><li>如何解决碎片问题</li></ol><p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p><ul><li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li><li>这个地址确实是之前通过我们自己的malloc分配的</li></ul><p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p><p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：</p><pre class="prettyprint linenums lang-c">typedef struct s_block *t_block;struct s_block {    size_t size;  /* 数据区大小 */    t_block next; /* 指向下个块的指针 */    int free;     /* 是否是空闲块 */    int padding;  /* 填充4字节，保证meta块长度为8的倍数 */    void *ptr;    /* Magic pointer，指向data */    char data[1]  /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */};</pre><p>然后我们定义检查地址合法性的函数：</p><pre class="prettyprint linenums lang-c">t_block get_block(void *p) {    char *tmp;      tmp = p;    return (p = tmp -= BLOCK_SIZE);}<p>int valid_addr(void *p) {<br>    if(first_block) {<br>        if(p &gt; first_block &amp;&amp; p &lt; sbrk(0)) {<br>            return p == (get_block(p))-&gt;ptr;<br>        }<br>    }<br>    return 0;<br>}</p></pre><p></p><p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p><p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：</p><pre class="prettyprint linenums lang-c">typedef struct s_block *t_block;struct s_block {    size_t size;  /* 数据区大小 */    t_block prev; /* 指向上个块的指针 */    t_block next; /* 指向下个块的指针 */    int free;     /* 是否是空闲块 */    int padding;  /* 填充4字节，保证meta块长度为8的倍数 */    void *ptr;    /* Magic pointer，指向data */    char data[1]  /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */};</pre><p>合并方法如下：</p><pre class="prettyprint linenums lang-c">t_block fusion(t_block b) {    if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free) {        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;        b-&gt;next = b-&gt;next-&gt;next;        if(b-&gt;next)            b-&gt;next-&gt;prev = b;    }    return b;}</pre><p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：</p><pre class="prettyprint linenums lang-c">void free(void *p) {    t_block b;    if(valid_addr(p)) {        b = get_block(p);        b-&gt;free = 1;        if(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;free)            b = fusion(b-&gt;prev);        if(b-&gt;next)            fusion(b);        else {            if(b-&gt;prev)                b-&gt;prev-&gt;prev = NULL;            else                first_block = NULL;            brk(b);        }    }}</pre><h3 id="328-realloc的实现">3.2.8 realloc的实现</h3><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：</p><pre class="prettyprint linenums lang-c">void copy_block(t_block src, t_block dst) {    size_t *sdata, *ddata;    size_t i;    sdata = src-&gt;ptr;    ddata = dst-&gt;ptr;    for(i = 0; (i * 8) &lt; src-&gt;size &amp;&amp; (i * 8) &lt; dst-&gt;size; i++)        ddata[i] = sdata[i];}</pre><p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p><ul><li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li><li>如果新的size变小了，考虑split</li><li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li></ul><p>下面是realloc的实现：</p><pre class="prettyprint linenums lang-c">void *realloc(void *p, size_t size) {    size_t s;    t_block b, new;    void *newp;    if (!p)        /* 根据标准库文档，当p传入NULL时，相当于调用malloc */        return malloc(size);    if(valid_addr(p)) {        s = align8(size);        b = get_block(p);        if(b-&gt;size &gt;= s) {            if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))                split_block(b,s);        } else {            /* 看是否可进行合并 */            if(b-&gt;next &amp;&amp; b-&gt;next-&gt;free                    &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) {                fusion(b);                if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))                    split_block(b, s);            } else {                /* 新malloc */                newp = malloc (s);                if (!newp)                    return NULL;                new = get_block(newp);                copy_block(b, new);                free(p);                return(newp);            }        }        return (p);    }    return NULL;}</pre><h2 id="33-遗留问题和优化">3.3 遗留问题和优化</h2><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p><ul><li>同时兼容32位和64位系统</li><li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li><li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li><li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li></ul><p>还有很多可能的优化，这里不一一赘述。下面附上一些参考文献，有兴趣的同学可以更深入研究。</p><h1 id="4-其它参考">4 其它参考</h1><ol><li>这篇文章大量参考了<span class="exturl" data-url="aHR0cDovL3d3dy5pbmYudWRlYy5jbC9+bGVvL01hbGxvY190dXRvcmlhbC5wZGY=" title="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf">A malloc Tutorial<i class="fa fa-external-link"></i></span>，其中一些图片和代码直接引用了文中的内容，这里特别指出</li><li><span class="exturl" data-url="aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUv" title="http://csapp.cs.cmu.edu/">Computer Systems: A Programmer&#39;s Perspective, 2/E<i class="fa fa-external-link"></i></span>一书有许多值得参考的地方</li><li>关于Linux的虚拟内存模型，<span class="exturl" data-url="aHR0cDovL2R1YXJ0ZXMub3JnL2d1c3Rhdm8vYmxvZy9wb3N0L2FuYXRvbXktb2YtYS1wcm9ncmFtLWluLW1lbW9yeS8=" title="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/">Anatomy of a Program in Memory<i class="fa fa-external-link"></i></span>是很好的参考资料，另外作者还有一篇<span class="exturl" data-url="aHR0cDovL2R1YXJ0ZXMub3JnL2d1c3Rhdm8vYmxvZy9wb3N0L2hvdy10aGUta2VybmVsLW1hbmFnZXMteW91ci1tZW1vcnkv" title="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/">How the Kernel Manages Your Memory<i class="fa fa-external-link"></i></span>对于Linux内核中虚拟内存管理的部分有很好的讲解</li><li>对于真实世界的malloc实现，可以参考<span class="exturl" data-url="aHR0cDovL3JlcG8ub3IuY3ovdy9nbGliYy5naXQvYmxvYi9IRUFEOi9tYWxsb2MvbWFsbG9jLmM=" title="http://repo.or.cz/w/glibc.git/blob/HEAD:/malloc/malloc.c">glibc的实现<i class="fa fa-external-link"></i></span></li><li>本文写作过程中大量参考了<span class="exturl" data-url="aHR0cDovL3d3dy53aWtpcGVkaWEub3JnLw==" title="http://www.wikipedia.org/">维基百科<i class="fa fa-external-link"></i></span>，再次感谢这个伟大的网站，并且呼吁大家在手头允许的情况下可以适当捐助维基百科，帮助这个造福人类的系统运行下去</li></ol>]]></content>
    
    <summary type="html">
    
      
      
          &lt;p&gt;任何一个用过或学过C的人对malloc都不会陌生。大家都知道malloc可以分配一段连续的内存空间，并且在不再使用时可以通过free释放掉。但是，许多程序员对malloc背后的事情并不熟悉，许多人甚至把malloc当做操作系统所提供的系统调用或C的关键字。实际上，mal
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/how-stackoverflow-works/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/how-stackoverflow-works/</id>
    <published>2019-06-14T02:52:59.705Z</published>
    <updated>2019-06-14T02:52:59.705Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>同时使用Linux和Windows平台产品，大量使用静态的方法和类，Stack Overflow是个重度性能控。同时，取代横向扩展，他们坚持着纵向扩展思路，因为“硬件永远比程序员便宜”。                <br>                <div class="con news_content"><br>                <p>【编者按】StackOverflow是一个IT技术问答网站，用户可以在网站上提交和回答问题。当下的StackOverflow已拥有400万个用户，4000万个回答，月PV5.6亿，世界排行第54。然而值得关注的是，支撑他们网站的全部服务器只有25台，并且都保持着非常低的资源使用率，这是一场高有效性、负载均衡、缓存、数据库、搜索及高效代码上的较量。近日，High<br>    Scalability创始人Todd Hoff根据Marco Cecconi的演讲视频“<br>    <span class="exturl" data-url="aHR0cDovL3d3dy5kZXYtbWV0YWwuY29tL2FyY2hpdGVjdHVyZS1zdGFja292ZXJmbG93Lw==" title="http://www.dev-metal.com/architecture-stackoverflow/">The architecture of StackOverflow<i class="fa fa-external-link"></i></span>”以及Nick Craver的博文“<br>    <span class="exturl" data-url="aHR0cDovL25pY2tjcmF2ZXIuY29tL2Jsb2cvMjAxMy8xMS8yMi93aGF0LWl0LXRha2VzLXRvLXJ1bi1zdGFjay1vdmVyZmxvdy8=" title="http://nickcraver.com/blog/2013/11/22/what-it-takes-to-run-stack-overflow/">What it takes to run Stack Overflow<i class="fa fa-external-link"></i></span>”总结了StackOverflow的成功原因。</p><hr></div></p><hr><p><b>以下为译文</b></p><p style="text-align: center; "><span class="exturl" data-url="aHR0cDovL2Ntcy5jc2RuaW1nLmNuL2FydGljbGUvMjAxNDA3LzI1LzUzZDE3MGNiYzdlMjIuanBn" title="http://cms.csdnimg.cn/article/201407/25/53d170cbc7e22.jpg"><img src="http://cms.csdnimg.cn/article/201407/25/53d170cbc7e22_middle.jpg?_=36741" border="0" style="float: none; margin: 0px; width: 499.99999999999994px; height: 355px; " alt><i class="fa fa-external-link"></i></span><br></p><p>意料之中，也是意料之外，Stack Overflow仍然重度使用着微软的产品。他们认为既然微软的基础设施可以满足需求，又足够便宜，那么没有什么理由去做根本上的改变。而在需要的地方，他们同样使用了Linux。究其根本，一切都是为了性能。</p><p>另一个值得关注的地方是，Stack Overflow仍然使用着纵向扩展策略，没有使用云。他们使用了384GB的内存和2TB的SSD来支撑SQL    Servers，如果使用AWS的话，花费可想而知。没有使用云的另一个原因是Stack Overflow认为云会一定程度上的降低性能，同时也会给优化和排查系统问题增加难度。此外，他们的架构也并不需要横向扩展。峰值期间是横向扩展的杀手级应用场景，然而他们有着丰富的系统调整经验去应对。该公司仍然坚持着Jeff    Atwood的名言——硬件永远比程序员便宜。</p><p>Marco Ceccon曾提到，在谈及系统时，有一件事情必须首先弄明白——需要解决问题的类型。首先，从简单方面着手，StackExchange究竟是用来做什么的——首先是一些主题，然后围绕这些主题建立社区，最后就形成了这个令人敬佩的问答网站。</p><p>其次则是规模相关。StackExchange在飞速增长，需要处理大量的数据传输，那么这些都是如何完成的，特别是只使用了25台服务器，下面一起追根揭底：</p><h2><span style="color: #7f6000;">状态</span></h2><p>    </p><ul>        <li>StackExchange拥有110个站点，以每个月3到4个的速度增长。</li>        <li>400万用户</li>        <li>800万问题</li>        <li>4000万答案</li>        <li>世界排名54位</li>        <li>每年增长100%</li>        <li>月PV 5.6亿万</li>        <li>大多数工作日期间峰值为2600到3000请求每秒，作为一个编程相关网站，一般情况下工作日的请求都会高于周末</li>        <li>25台服务器</li>        <li>SSD中储存了2TB的SQL数据</li>        <li>每个web server都配置了2个320G的SSD，使用RAID 1</li>        <li>每个ElasticSearch主机都配备了300GB的机械硬盘，同时也使用了SSD</li>        <li>Stack Overflow的读写比是40:60</li>        <li>DB Server的平均CPU利用率是10%</li>        <li>11个web server，使用IIS</li>        <li>2个负载均衡器，1个活跃，使用HAProxy</li>        <li>4个活跃的数据库节点，使用MS SQL</li>        <li>3台实现了tag engine的应用程序服务器，所有搜索都通过tag</li>        <li>3台服务器通过ElasticSearch做搜索</li>        <li>2台使用了Redis的服务器支撑分布式缓存和消息</li>        <li>2台Networks（Nexus 5596 + Fabric Extenders）</li>        <li>2 Cisco 5525-X ASAs&nbsp;</li>        <li>2 Cisco 3945 Routers</li>        <li>主要服务Stack Exchange API的2个只读SQL Servers</li>        <li>VM用于部署、域控制器、监控、运维数据库等场合</li>    </ul><p></p><h2><span style="color: #7f6000;">平台</span></h2><p>    </p><ul>        <li>ElasticSearch</li>        <li>Redis</li>        <li>HAProxy</li>        <li>MS SQL</li>        <li>Opserver</li>        <li>TeamCity</li>        <li>Jil——Fast .NET JSON Serializer，建立在Sigil之上</li>        <li>Dapper——微型的ORM</li>    </ul><p></p><h2><span style="color: #7f6000;">UI</span></h2><p>    </p><ul>        <li>UI拥有一个信息收件箱，用于新徽章获得、用户发送信息、重大事件发生时的信息收取，使用WebSockets实现，并通过Redis支撑。</li>        <li>搜索箱通过 ElasticSearch 实现，使用了一个REST接口。</li>        <li>因为用户提出问题的频率很高，因此很难显示最新问题，每秒都会有新的问题产生，从而这里需要开发一个关注用户行为模式的算法，只给用户显示感兴趣的问题。它使用了基于Tag的复杂查询，这也是开发独立Tag            Engine的原因。</li>        <li>服务器端模板用于生成页面。</li>    </ul><p></p><h2><span style="color: #7f6000;">服务器</span></h2><p>    </p><ul>        <li>25台服务器并没有满载，CPU使用率并不高，单计算SO（Stack Overflow）只需要5台服务器。</li>        <li>数据库服务器资源利用率在10%左右，除下执行备份时。</li>        <li>为什么会这么低？因为数据库服务器足足拥有384GB内存，同时web server的CPU利用率也只有10%-15%。</li>        <li>纵向扩展还没有遇到瓶颈。通常情况下，如此流量使用横向扩展大约需要100到300台服务器。</li>        <li>简单的系统。基于.Net，只用了9个项目，其他系统可能需要100个。之所以使用这么少系统是为了追求极限的编译速度，这点需要从系统开始时就进行规划，每台服务器的编译时间大约是10秒。</li>        <li>11万行代码，对比流量来说非常少。</li>        <li>使用这种极简的方式主要基于几个原因。首先，不需要太多测试，因为Meta.stackoverflow本来就是一个问题和bug讨论社区。其次，Meta.stackoverflow还是一个软件的测试网站，如果用户发现问题的话，往往会提出并给予解决方案。</li>        <li>纽约数据中心使用的是Windows 2012，已经向2012 R2升级（Oregon已经完成了升级），Linux系统使用的是Centos 6.4。</li>    </ul><p></p><h2><span style="color: #7f6000;">SSD</span></h2><p>    </p><ul>        <li>默认使用的是Intel 330（Web层等）</li>        <li>Intel 520用于中间层写入，比如Elastic Search</li>        <li>数据层使用Intel 710和S3700</li>        <li>系统同时使用了RAID 1和RAID 10（任何4+以上的磁盘都使用RAID 10）。不畏惧故障发生，即使生产环境中使用了上千块2.5英寸SSD，还没碰到过一块失败的情景。每个模型都使用了1个以上的备件，多个磁盘发生故障的情景不在考虑之中。</li>        <li>ElasticSearch在SSD上表现的异常出色，因为SO writes/re-indexes的操作非常频繁。</li>        <li>SSD改变了搜索的使用方式。因为锁的问题，Luncene.net并不能支撑SO的并发负载，因此他们转向了ElasticSearch。在全SSD环境下，并不需要围绕Binary            Reader建立锁。</li>    </ul><p></p><h2><span style="color: #7f6000;">高可用性</span></h2><p>    </p><ul>        <li>异地备份——主数据中心位于纽约，备份数据中心在Oregon。</li>        <li>Redis有两个从节点，SQL有2个备份，Tag Engine有3个节点，elastic有3个节点，冗余一切，并在两个数据中心同时存在。</li>        <li>Nginx是用于SSL，终止SSL时转换使用HAProxy。</li>        <li>并不是主从所有，一些临时的数据只会放到缓存中</li>        <li>所有HTTP流量发送只占总流量的77%，还存在Oregon数据中心的备份及一些其他的VPN流量。这些流量主要由SQL和Redis备份产生。</li>    </ul><p></p><h2><span style="color: #7f6000;">数据库</span></h2><p>    </p><ul>        <li>MS SQL Server</li>        <li>Stack Exchange为每个网站都设置了数据库，因此Stack Overflow有一个、Server Fault有一个，以此类推。</li>        <li>在纽约的主数据中心，每个集群通常都使用1主和1只读备份的配置，同时还会在Oregon数据中心也设置一个备份。如果是运行的是Oregon集群，那么两个在纽约数据中心的备份都会是只读和同步的。</li>        <li>为其他内容准备的数据库。这里还存在一个“网络范围”的数据库，用于储存登陆凭证和聚合数据（大部分是stackexchange.com用户文件或者API）。</li>        <li>Careers Stack Overflow、stackexchange.com和Area 51等都拥有自己独立的数据库模式。</li>        <li>模式的变化需要同时提供给所有站点的数据库，它们需要向下兼容，举个例子，如果需要重命名一个列，那么将非常麻烦，这里需要进行多个操作：增加一个新列，添加作用在两个列上的代码，给新列写数据，改变代码让新列有效，移除旧列。</li>        <li>并不需要分片，所有事情通过索引来解决，而且数据体积也没那么大。如果有filtered indexes需求，那么为什么不更高效的进行？常见模式只在DeletionDate            = Null上做索引，其他则通过为枚举指定类型。每项votes都设置了1个表，比如一张表给post votes，1张表给comment votes。大部分的页面都可以实时渲染，只为匿名用户缓存，因此，不存在缓存更新，只有重查询。</li>        <li>Scores是非规范化的，因此需要经常查询。它只包含IDs和dates，post votes表格当下大约有56454478行，使用索引，大部分的查询都可以在数毫秒内完成。</li>        <li>Tag Engine是完全独立的，这就意味着核心功能并不依赖任何外部应用程序。它是一个巨大的内存结构数组结构，专为SO用例优化，并为重负载组合进行预计算。Tag            Engine是个简单的windows服务，冗余的运行在多个主机上。CPU使用率基本上保持在2-5%，3个主机专门用于冗余，不负责任何负载。如果所有主机同时发生故障，网络服务器将把Tag            Engine加载到内存中持续运行。</li>        <li>关于Dapper无编译器校验查询与传统ORM的对比。使用编译器有很多好处，但在运行时仍然会存在fundamental disconnect问题。同时更重要的是，由于生成nasty            SQL，通常情况还需要去寻找原始代码，而Query Hint和parameterization控制等能力的缺乏更让查询优化变得复杂。</li>    </ul><p></p><h2><span style="color: #7f6000;">编码</span></h2><p>    </p><ul>        <li>流程</li>    </ul><p></p><p>    </p><ul style="margin-left: 2em !important; ">        <li><span style="color: #7f7f7f;">大部分程序员都是远程工作，自己选择编码地点</span>        </li>        <li><span style="color: #7f7f7f;">编译非常快</span>        </li>        <li><span style="color: #7f7f7f;">然后运行少量的测试</span>        </li>        <li><span style="color: #7f7f7f;">一旦编译成功，代码即转移至开发交付准备服务器</span>        </li>        <li><span style="color: #7f7f7f;">通过功能开关隐藏新功能</span>        </li>        <li><span style="color: #7f7f7f;">在相同硬件上作为其他站点测试运行</span>        </li>        <li><span style="color: #7f7f7f;">然后转移至Meta.stackoverflow测试，每天有上千个程序员在使用，一个很好的测试环境</span>        </li>        <li><span style="color: #7f7f7f;">如果通过则上线，在更广大的社区进行测试</span>        </li>    </ul><p></p><p>    </p><ul>        <li>大量使用静态类和方法，为了更简单及更好的性能</li>        <li>编码过程非常简单，因为复杂的部分被打包到库里，这些库被开源和维护。.Net 项目数量很低，因为使用了社区共享的部分代码。</li>        <li>开发者同时使用2到3个显示器，多个屏幕可以显著提高生产效率。</li>    </ul><p></p><h2><span style="color: #7f6000;">缓存</span></h2><p>    </p><ul>        <li>缓存一切</li>        <li>5个等级的缓存</li>        <li>1级是网络级缓存，缓存在浏览器、CDN以及代理服务器中。</li>        <li>2级由.Net框架 HttpRuntime.Cache完成，在每台服务器的内存中。</li>        <li>3级Redis，分布式内存键值存储，在多个支撑同一个站点的服务器上共享缓存项。</li>        <li>4级SQL Server Cache，整个数据库，所有数据都被放到内存中。</li>        <li>5级SSD。通常只在SQL Server预热后才生效。</li>        <li>举个例子，每个帮助页面都进行了缓存，访问一个页面的代码非常简单：</li>    </ul><p></p><p>    </p><ul style="margin-left: 2em !important; ">        <li><span style="color: #7f7f7f;">使用了静态的方法和类。从OOP角度来看确实很糟，但是非常快并有利于简洁编码。</span>        </li>        <li><span style="color: #7f7f7f;">缓存由Redis和Dapper支撑，一个微型ORM</span>        </li>    </ul><p></p><p>    </p><ul>        <li>为了解决垃圾收集问题，模板中1个类只使用1个副本，被建立和保存在缓存中。监测一切，包括GC操。据统计显示，间接层增加GC压力达到了某个程度时会显著的降低性能。</li>        <li>CDN Hit 。鉴于查询字符串基于文件内容进行哈希，只在有新建立时才会被再次取出。每天3000万到5000万Hit，带宽大约为300GB到600GB。</li>        <li>CDN不是用来应对CPU或I/O负载，而是帮助用户更快的获得答案</li>    </ul><p></p><h2><span style="color: #7f6000;">部署</span></h2><p>    </p><ul>        <li>每天5次部署，不去建立过大的应用。主要因为</li>    </ul><p></p><p>    </p><ul style="margin-left: 2em !important; ">        <li><span style="color: #7f7f7f;">可以直接的监视性能</span>        </li>        <li><span style="color: #7f7f7f;">尽可能最小化建立，可以工作才是重点</span>        </li>    </ul><p></p><p>    </p><ul>        <li>产品建立后再通过强大的脚本拷贝到各个网页层，每个服务器的步骤是：</li>    </ul><p></p><p>    </p><ul style="margin-left: 2em !important; ">        <li><span style="color: #7f7f7f;">通过POST通知HAProxy下架某台服务器</span>        </li>        <li><span style="color: #7f7f7f;">延迟IIS结束现有请求（大约5秒）</span>        </li>        <li><span style="color: #7f7f7f;">停止网站（通过同一个PSSession结束所有下游）</span>        </li>        <li><span style="color: #7f7f7f;">Robocopy文件</span>        </li>        <li><span style="color: #7f7f7f;">开启网站</span>        </li>        <li><span style="color: #7f7f7f;">通过另一个POST做HAProxy Re-enable</span>        </li>    </ul><p></p><p>    </p><ul>        <li>几乎所有部署都是通过puppet或DSC，升级通常只是大幅度调整RAID阵列并通过PXE boot安装，这样做非常快速。</li>    </ul><p></p><h2><span style="color: #7f6000;">协作</span></h2><p>    </p><ul>        <li>团队</li>    </ul><p></p><p>    </p><ul style="margin-left: 2em !important; ">        <li>SRE （System Reliability Engineering）：5人</li>        <li>Core Dev（Q&amp;A site）6-7人</li>        <li>Core Dev Mobile：6人</li>        <li>Careers团队专门负责SO Careers产品开发：7人</li>    </ul><p></p><p>    </p><ul>        <li>Devops和开发者结合的非常紧密</li>        <li>团队间变化很大</li>        <li>大部分员工远程工作</li>        <li>办公室主要用于销售，Denver和London除外</li>        <li>一切平等，些许偏向纽约工作者，因为面对面有助于工作交流，但是在线工作影响也并不大</li>        <li>对比可以在同一个办公室办公，他们更偏向热爱产品及有才华的工程师，他们可以很好的衡量利弊</li>        <li>许多人因为家庭而选择远程工作，纽约是不错，但是生活并不宽松</li>        <li>办公室设立在曼哈顿，那是个人才的诞生地。数据中心不能太偏，因为经常会涉及升级</li>        <li>打造一个强大团队，偏爱极客。早期的微软就聚集了大量极客，因此他们征服了整个世界</li>        <li>Stack Overflow社区也是个招聘的地点，他们在那寻找热爱编码、乐于助人及热爱交流的人才。</li>    </ul><p></p><h2><span style="color: #7f6000;">编制预算</span></h2><p>    </p><ul>        <li>预算是项目的基础。钱只花在为新项目建立基础设施上，如此低利用率的&nbsp;web server还是3年前数据中心建立时购入。</li>    </ul><p></p><h2><span style="color: #7f6000;">测试</span></h2><p>    </p><ul>        <li>快速迭代和遗弃</li>        <li>许多测试都是发布队伍完成的。开发拥有一个同样的SQL服务器，并且运行在相同的Web层，因此性能测试并不会糟糕。</li>        <li>非常少的测试。Stack Overflow并没有进行太多的单元测试，因为他们使用了大量的静态代码，还有一个非常活跃的社区。</li>        <li>基础设施改变。鉴于所有东西都有双份，所以每个旧配置都有备份，并使用了一个快速故障恢复机制。比如，keepalived可以在负载均衡器中快速回退。</li>        <li>对比定期维护，他们更愿意依赖冗余系统。SQL备份用一个专门的服务器进行测试，只为了可以重存储。计划做每两个月一次的全数据中心故障恢复，或者使用完全只读的第二数据中心。</li>        <li>每次新功能发布都做单元测试、集成测试盒UI测试，这就意味着可以预知输入的产品功能测试后就会推送到孵化网站，即meta.stackexchange（原meta.stackoverflow）。</li>    </ul><p></p><h2><span style="color: #7f6000;">监视/日志</span></h2><p>    </p><ul>        <li>当下正在考虑使用http://logstash.net/做日志管理，目前使用了一个专门的服务将syslog UDP传输到SQL数据库中。网页中为计时添加header，这样就可以通过HAProxy来捕获并且融合到syslog传输中。</li>        <li>Opserver和Realog用于显示测量结果。Realog是一个日志展示系统，由Kyle Brandt和Matt Jibson使用Go建立。</li>        <li>日志通过HAProxy负载均衡器借助syslog完成，而不是IIS，因为其功能比IIS更丰富。</li>    </ul><p></p><h2><span style="color: #7f6000;">关于云</span></h2><p>    </p><ul>        <li>还是老生常谈，硬件永远比开发者和有效率的代码便宜。基于木桶效应，速度肯定受限于某个短板，现有的云服务基本上都存在容量和性能限制。</li>        <li>如果从开始就使用云来建设SO说不定也会达到现在的水准。但毫无疑问的是，如果达到同样的性能，使用云的成本将远远高于自建数据中心。</li>    </ul><p></p><h2><span style="color: #7f6000;">性能至上</span></h2><p>    </p><ul>        <li>StackOverflow是个重度的性能控，主页加载的时间永远控制在50毫秒内，当下的响应时间是28毫秒。</li>        <li>程序员热衷于降低页面加载时间以及提高用户体验。</li>        <li>每个独立的网络提交都予以计时和记录，这种计量可以弄清楚提升性能需要修改的地方。</li>        <li>如此低资源利用率的主要原因就是高效的代码。web server的CPU平均利用率在5%到15%之间，内存使用为15.5 GB，网络传输在20            Mb/s到40 Mb/s。SQL服务器的CPU使用率在5%到10%之间，内存使用是365GB，网络传输为100 Mb/s到200 Mb/s。这可以带来3个好处：给升级留下很大的空间；在严重错误发生时可以保持服务可用；在需要时可以快速回档。</li>    </ul><p></p><h2><span style="color: #7f6000;">学到的知识</span></h2><p><b>1. </b>为什么使用MS产品的同时还使用Redis？什么好用用什么，不要做无必要的系统之争，比如C#在Windows机器上运行最好，我们使用IIS；Redis在*nix机器上可以得到充分发挥，我们使用*nix。</p><p><b>2. </b>Overkill即策略。平常的利用率并不能代表什么，当某些特定的事情发生时，比如备份、重建等完全可以将资源使用拉满。</p><p><b>3. </b>坚固的SSD。所有数据库都建立在SSD之上，这样可以获得0延时。</p><p><b>4.</b> 了解你的读写负载。</p><p><b>5. </b>高效的代码意味着更少的主机。只有新项目上线时才会因为特殊需求增加硬件，通常情况下是添加内存，但在此之外，高效的代码就意味着0硬件添加。所以经常只讨论两个问题：为存储增加新的SSD；为新项目增加硬件。</p><p><b>6. </b>不要害怕定制化。SO在Tag上使用复杂查询，因此专门开发了所需的Tag Engine。</p><p><b>7.</b> 只做必须做的事情。之所以不需要测试是因为有一个活跃的社区支撑，比如，开发者不用担心出现“Square Wheel”效应，如果开发者可以制作一个更更轻量级的组件，那就替代吧。</p><p><b>8. </b>注重硬件知识，比如IL。一些代码使用IL而不是C#。聚焦SQL查询计划。使用web server的内存转储究竟做了些什么。探索，比如为什么一个split会产生2GB的垃圾。</p><p><b>9. </b>切勿官僚作风。总有一些新的工具是你需要的，比如，一个编辑器，新版本的Visual Studio，降低提升过程中的一切阻力。</p><p><b>10. </b>垃圾回收驱动编程。SO在减少垃圾回收成本上做了很多努力，跳过类似TDD的实践，避免抽象层，使用静态方法。虽然极端，但是确实打造出非常高效的代码。</p><p><b>11. </b>高效代码的价值远远超出你想象，它可以让硬件跑的更快，降低资源使用，切记让代码更容易被程序员理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;同时使用Linux和Windows平台产品，大量使用静态的方法和类，Stack Overflow是个重度性能控。同时，取代横向扩展，他们坚持着纵向扩展思路，因为“硬件永远比程序员便宜”。                &lt;br&gt;    
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/java-string/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/java-string/</id>
    <published>2019-06-14T02:52:59.705Z</published>
    <updated>2019-06-14T02:52:59.705Z</updated>
    
    <content type="html"><![CDATA[<p><span style="font-family: Arial;">String in Java is very special class and most frequently used class as<br>well. There are lot many things to learn about </span><span style="font-family: &quot;Courier New&quot;;">String</span><span style="font-family: Arial;"> in Java<br>than any other class, and having a good knowledge of different </span><span style="font-family: Courier New, Courier, monospace;">String<br></span><span style="font-family: Arial;">functionalities makes you to use it properly. Given heavy use of Java </span><span style="font-family: &quot;Courier New&quot;;">String</span><span style="font-family: Arial;"> in almost<br>any kind of project, it become even more important to know subtle detail about<br>String. Though I have shared lot of String related article already here in<br><b>Javarevisited</b>, this is an effort to bring some of String feature together. In<br>this tutorial we will see some important points about Java </span><span style="font-family: &quot;Courier New&quot;;">String</span><span style="font-family: Arial;">, which is<br>worth remembering. You can also refer my earlier post <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTIvMTAvMTAtamF2YS1zdHJpbmctaW50ZXJ2aWV3LXF1ZXN0aW9uLWFuc3dlcnMtdG9wLmh0bWw=" title="http://javarevisited.blogspot.com/2012/10/10-java-string-interview-question-answers-top.html">10<br>advanced Java String questions<i class="fa fa-external-link"></i></span> to know more about </span><span style="font-family: &quot;Courier New&quot;;">String</span><span style="font-family: Arial;">. Though I<br>tried to cover lot of things, there are definitely few things, which I might<br>have missed; please let me know if you have any question or doubt on </span><span style="font-family: &quot;Courier New&quot;;">java.lang.String</span><span style="font-family: Arial;"><br>functionality and I will try to address them here.</span><br><a name="more"></a><br></p><div class="MsoNormal"><br></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">1)Strings are not null terminated in Java.</span></u></b></div><div class="MsoNormal"><span style="font-family: Arial;">Unlike C and C++, String in Java doesn't terminate with null character. InsteadString are Object in Java and backed by character array. You can get thecharacter array used to represent String in Java by calling </span><span style="font-family: &quot;Courier New&quot;;">toCharArray()</span><span style="font-family: Arial;"> method of </span><span style="font-family: &quot;Courier New&quot;;">java.lang.String</span><span style="font-family: Arial;"> class ofJDK.</span></div><div class="MsoNormal"><br><br></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">2)Strings are immutable and final in Java</span></u></b></div><div class="MsoNormal"><span style="font-family: Arial;">Strings are immutable in Java it means once created you cannot modifycontent of String. If you modify it by using </span><span style="font-family: &quot;Courier New&quot;;">toLowerCase()</span><span style="font-family: Arial;">, </span><span style="font-family: &quot;Courier New&quot;;">toUpperCase()</span><span style="font-family: Arial;"> or anyother method,<span style="mso-spacerun: yes;">&nbsp; </span>It always result in newString. Since String is final there is no way anyone can extend String oroverride any of String functionality. Now if you are puzzled <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTAvMTAvd2h5LXN0cmluZy1pcy1pbW11dGFibGUtaW4tamF2YS5odG1s" title="http://javarevisited.blogspot.com/2010/10/why-string-is-immutable-in-java.html">whyString is immutable or final in Java<i class="fa fa-external-link"></i></span>. checkout the link.</span></div><div class="MsoNormal"><br><br></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">3)Strings are maintained in String Pool</span></u></b></div><div class="MsoNormal"><span class="exturl" data-url="aHR0cDovLzMuYnAuYmxvZ3Nwb3QuY29tLy1LNnEwRFExdi10dy9UV3U4b3dCdGMySS9BQUFBQUFBQUFEQS9vQm9IREJpSjhhZy9zMTYwMC8xNy5qcGc=" title="http://3.bp.blogspot.com/-K6q0DQ1v-tw/TWu8owBtc2I/AAAAAAAAADA/oBoHDBiJ8ag/s1600/17.jpg"><img alt="Advanced Java String tutorial and example programmers " border="0" src="http://3.bp.blogspot.com/-K6q0DQ1v-tw/TWu8owBtc2I/AAAAAAAAADA/oBoHDBiJ8ag/s1600/17.jpg" title><i class="fa fa-external-link"></i></span><span style="font-family: Arial;">As I Said earlier String is special class in Java and all String literale.g. </span><span style="font-family: &quot;Courier New&quot;;">"abc"</span><span style="font-family: Arial;"><span style="mso-spacerun: yes;">&nbsp; </span>(anythingwhich is inside double quotes are String literal in Java) are maintained in aseparate String pool, special memory location inside Java memory, moreprecisely inside <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTIvMDEvdG9tY2F0LWphdmFsYW5nb3V0b2ZtZW1vcnllcnJvci1wZXJtZ2VuLmh0bWw=" title="http://javarevisited.blogspot.com/2012/01/tomcat-javalangoutofmemoryerror-permgen.html">PermGenSpace<i class="fa fa-external-link"></i></span>.&nbsp;Any time&nbsp;you create a new String object using String literal, JVMfirst checks&nbsp;String pool and if an object with similar content available, thanit returns that and doesn't create a new object. JVM doesn't perform Stringpool check if you create object using new operator.</span></div><div class="MsoNormal"><br></div><div class="MsoNormal"><span style="font-family: Arial;">You may face subtle issues if you are not aware of this String&nbsp;behaviour&nbsp;, here is an example</span></div><div class="MsoNormal"><span style="font-family: Arial;"><br></span><div style="background: #F3F3F3; border: dotted windowtext 1.0pt; mso-border-alt: dotted windowtext .5pt; mso-element: para-border-div; padding: 1.0pt 4.0pt 1.0pt 4.0pt;"><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">String name = </span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Scala"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">; </span><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//1st String object</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">String name_1 = </span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Scala"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">; </span><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//same object referenced by name variable</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">String name_2 = </span><b><span style="color: #008800; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">new</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"> String(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Scala"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">) </span><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//different String object</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><br></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//this will return true</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><b><span style="color: #008800; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">if</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(name==name_1){<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">System.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">out</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">println</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"both name and name_1 is pointing to same string object"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">);<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">}<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><br></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//this will return false</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><b><span style="color: #008800; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">if</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(name==name_2){<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">System.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">out</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">println</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"both name and name_2 is pointing to same string object"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">);<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">}<o:p></o:p></span></div></div><span style="font-family: Arial;"><br></span><span style="font-family: Arial;">if you compare name and </span><span style="font-family: &quot;Courier New&quot;;">name_1</span><span style="font-family: Arial;"> using equality operator </span><span style="font-family: &quot;Courier New&quot;;">"=="</span><span style="font-family: Arial;"> it willreturn true because both are pointing to same object. While </span><span style="font-family: &quot;Courier New&quot;;">name==name_2</span><span style="font-family: Arial;"> willreturn false because they are pointing to different string object. It's worthremembering that <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3Quc2cvMjAxMi8xMi9kaWZmZXJlbmNlLWJldHdlZW4tZXF1YWxzLW1ldGhvZC1hbmQtZXF1YWxpdHktb3BlcmF0b3ItamF2YS5odG1s" title="http://javarevisited.blogspot.sg/2012/12/difference-between-equals-method-and-equality-operator-java.html">equality<span style="font-family: &quot;Courier New&quot;;">"=="</span> operator comparesobject memory location<i class="fa fa-external-link"></i></span> and not characters of String. By default Java putsall string literal into string pool, but you can also put any string into poolby calling </span><span style="font-family: &quot;Courier New&quot;;">intern()</span><span style="font-family: Arial;"> method of </span><span style="font-family: &quot;Courier New&quot;;">java.lang.String</span><span style="font-family: Arial;"> class,like string created using </span><span style="font-family: &quot;Courier New&quot;;">new()</span><span style="font-family: Arial;"> operator.</span></div><div class="MsoNormal"><br><br></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">4) UseEquals methods for comparing String in Java</span></u></b></div><div class="MsoNormal"><span style="font-family: Arial;">String class overrides equals method and provides a content equality,which is based on characters, case and order. So if you want to compare twoString object, to check whether they are same or not, always use </span><span style="font-family: &quot;Courier New&quot;;">equals()</span><span style="font-family: Arial;"> methodinstead of equality operator. Like in earlier example if <span style="mso-spacerun: yes;">&nbsp;</span>we use <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTEvMDIvaG93LXRvLXdyaXRlLWVxdWFscy1tZXRob2QtaW4tamF2YS5odG1s" title="http://javarevisited.blogspot.com/2011/02/how-to-write-equals-method-in-java.html">equalsmethod<i class="fa fa-external-link"></i></span> to compare objects, they will be equal to each other because theyall contains same contents. Here is example of comparing String using equalsmethod.</span><br><span style="font-family: Arial;"><br></span></div><div class="MsoNormal"><div style="background: #F3F3F3; border: dotted windowtext 1.0pt; mso-border-alt: dotted windowtext .5pt; mso-element: para-border-div; padding: 1.0pt 4.0pt 1.0pt 4.0pt;"><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">String name = </span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Java"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">; </span><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//1st String object</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">String name_1 = </span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Java"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">; </span><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//same object referenced by name variable</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">String name_2 = </span><b><span style="color: #008800; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">new</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"> String(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Java"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">) </span><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//different String object</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><br></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><b><span style="color: #008800; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">if</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(name.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">equals</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(name_1)){<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">System.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">out</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">println</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"name and name_1 are equal String by equals method"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">);<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">}<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><br></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//this will return false</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><b><span style="color: #008800; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">if</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(name==name_2){<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">System.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">out</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">println</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"name_1 and name_2 are equal String by equals method"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">);<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">}<o:p></o:p></span></div></div><span style="font-family: Arial;"><br></span><span style="font-family: Arial;">You can also check my earlier post </span><span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTIvMTIvZGlmZmVyZW5jZS1iZXR3ZWVuLWVxdWFscy1tZXRob2QtYW5kLWVxdWFsaXR5LW9wZXJhdG9yLWphdmEuaHRtbA==" title="http://javarevisited.blogspot.com/2012/12/difference-between-equals-method-and-equality-operator-java.html">differencebetween equals() method and == operator<i class="fa fa-external-link"></i></span><span style="font-family: Arial;"> for more detail discussion onconsequences of comparing two string using == operator in Java.</span></div><div class="MsoNormal"><br><br></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">5) UseindexOf() and lastIndexOf() or matches(String regex) method to search insideString</span></u></b></div><div class="MsoNormal"><span style="font-family: Arial;">String class in Java provides convenient method to see if a character or&nbsp;sub-string&nbsp;or a pattern exists in&nbsp;current String object. You can use<span style="font-family: Arial,Helvetica,sans-serif;"> </span></span><span style="font-family: Courier New, Courier, monospace;">indexOf()</span><span style="font-family: Arial;"><span style="font-family: Arial,Helvetica,sans-serif;"> </span>which willreturn position of character or String, if that exist in current String objector -1 if character doesn't exists in String. </span><span style="font-family: &quot;Courier New&quot;;">lastIndexOf</span><span style="font-family: Arial;"> is similarbut it searches from end. </span><span style="font-family: &quot;Courier New&quot;;">String.match(String regex)</span><span style="font-family: Arial;"> is evenmore powerful, which allows you to search for a <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTIvMTAvcmVndWxhci1leHByZXNzaW9uLWV4YW1wbGUtaW4tamF2YS10by1jaGVjay1TdHJpbmctbnVtYmVyLmh0bWw=" title="http://javarevisited.blogspot.com/2012/10/regular-expression-example-in-java-to-check-String-number.html">regularexpression pattern<i class="fa fa-external-link"></i></span> inside String. here is examples of </span><span style="font-family: &quot;Courier New&quot;;">indexOf</span><span style="font-family: Arial;">, </span><span style="font-family: &quot;Courier New&quot;;">lastIndexOf</span><span style="font-family: Arial;"> and </span><span style="font-family: &quot;Courier New&quot;;">matches</span><span style="font-family: Arial;"> methodfrom </span><span style="font-family: &quot;Courier New&quot;;">java.lang.String</span><span style="font-family: Arial;"> class.</span></div><div class="MsoNormal"><span style="font-family: Arial;"><br></span><div style="background: #F3F3F3; border: dotted windowtext 1.0pt; mso-border-alt: dotted windowtext .5pt; mso-element: para-border-div; padding: 1.0pt 4.0pt 1.0pt 4.0pt;"><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">String str = </span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Java is best programming language"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">;<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><br></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><b><span style="color: #008800; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">if</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(str.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">indexOf</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Java"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">) != -</span><b><span style="color: #0000dd; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">1</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">){<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">&nbsp;&nbsp;&nbsp;&nbsp; System.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">out</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">println</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Stringcontains Java at index :"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"> + str.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">indexOf</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Java"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">));<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">}<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><br></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><b><span style="color: #008800; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">if</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(str.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">matches</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"J.*"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">)){<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">&nbsp;&nbsp;&nbsp;&nbsp; System.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">out</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">println</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"StringStarts with J"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">);<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">}<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><br></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">str =</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Do you like Java ME or Java EE"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">;<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><br></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><b><span style="color: #008800; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">if</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(str.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">lastIndexOf</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Java"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">) != -</span><b><span style="color: #0000dd; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">1</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">){<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">out</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">println</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"String contains Java lastly at: "</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"> + str.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">lastIndexOf</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Java"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">));<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">}<o:p></o:p></span></div></div><span style="font-family: Arial;"><br></span><span style="font-family: Arial;">As expected </span><span style="font-family: &quot;Courier New&quot;;">indexOf</span><span style="font-family: Arial;"> will return </span><span style="font-family: &quot;Courier New&quot;;">0</span><span style="font-family: Arial;"> because charactersin String are indexed from zero. </span><span style="font-family: &quot;Courier New&quot;;">lastIndexOf</span><span style="font-family: Arial;"> returnsindex of second &#8220;</span><span style="font-family: &quot;Courier New&quot;;">Java&#8221;,</span><span style="font-family: Arial;"> which starts at 23 and matcheswill return true because </span><span style="font-family: &quot;Courier New&quot;;">J.*</span><span style="font-family: Arial;"> pattern is any String starting with character</span><span style="font-family: &quot;Courier New&quot;;">J</span><span style="font-family: Arial;"> followed by any character because of</span><span style="font-family: &quot;Courier New&quot;;"> dot(.) </span><span style="font-family: Arial;">and anynumber of time due to </span><span style="font-family: &quot;Courier New&quot;;">asterick (*)</span><span style="font-family: Arial;">.</span></div><div class="MsoNormal"><br></div><div class="MsoNormal"><span style="font-family: Arial;">Remember </span><span style="font-family: &quot;Courier New&quot;;">matches()</span><span style="font-family: Arial;"> is tricky and some timenon-intuitive. If you just put </span><span style="font-family: &quot;Courier New&quot;;">"Java"</span><span style="font-family: Arial;"> in matchesit will return </span><span style="font-family: &quot;Courier New&quot;;">false</span><span style="font-family: Arial;"> because String is not equals to"Java" i.e. in case of plain text it behaves like equals method. See <span class="exturl" data-url="aHR0cDovL2phdmE2Ny5ibG9nc3BvdC5zZy8yMDEyLzA5L2phdmEtc3RyaW5nLW1hdGNoZXMtZXhhbXBsZS1yZWd1bGFyLWV4cHJlc3Npb24uaHRtbA==" title="http://java67.blogspot.sg/2012/09/java-string-matches-example-regular-expression.html">here<i class="fa fa-external-link"></i></span>for more examples of String </span><span style="font-family: &quot;Courier New&quot;;">matches()</span><span style="font-family: Arial;"> method.</span></div><div class="MsoNormal"><br></div><div class="MsoNormal"><span style="font-family: Arial;">Apart from </span><span style="font-family: &quot;Courier New&quot;;">indexOf()</span><span style="font-family: Arial;">, </span><span style="font-family: &quot;Courier New&quot;;">lastIndexOf()</span><span style="font-family: Arial;"> and </span><span style="font-family: &quot;Courier New&quot;;">matches(Stringregex)</span><span style="font-family: Arial;"> String also has methods like </span><span style="font-family: &quot;Courier New&quot;;">startsWith()</span><span style="font-family: Arial;"> and </span><span style="font-family: &quot;Courier New&quot;;">endsWidth(),</span><span style="font-family: Arial;"> which canbe used to check an String if it starting or ending with certain character orString.</span></div><div class="MsoNormal"><br><br></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">6) UseSubString to get part of String in Java</span></u></b></div><div class="MsoNormal"><span style="font-family: Arial;">Java String provides another useful method called </span><span style="font-family: &quot;Courier New&quot;;">substring(),</span><span style="font-family: Arial;"> which canbe used to get parts of String. basically you specify start and end index and </span><span style="font-family: &quot;Courier New&quot;;">substring()</span><span style="font-family: Arial;"> methodreturns character from that range. Index starts from 0 and goes till </span><span style="font-family: &quot;Courier New&quot;;">String.length()-1</span><span style="font-family: Arial;">. By theway </span><span style="font-family: &quot;Courier New&quot;;">String.length()</span><span style="font-family: Arial;"> returns you number of characters in String,including white spaces like tab, space. One point which is worth rememberinghere is that substring is also backed up by character array, which is used byoriginal String. This can be dangerous if original string object is very largeand substring is very small, because even a small fraction can hold referenceof complete array and prevents it from being garbage collected even if there isno other reference for that particular String. Read <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTEvMTAvaG93LXN1YnN0cmluZy1pbi1qYXZhLXdvcmtzLmh0bWw=" title="http://javarevisited.blogspot.com/2011/10/how-substring-in-java-works.html">HowSubstring works in Java<i class="fa fa-external-link"></i></span> for more details. Here is an example of using SubStringin Java:</span></div><div class="MsoNormal"><br></div><div class="MsoNormal"><div style="background: #F3F3F3; border: dotted windowtext 1.0pt; mso-border-alt: dotted windowtext .5pt; mso-element: para-border-div; padding: 1.0pt 4.0pt 1.0pt 4.0pt;"><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">String str = </span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Java is best programming language"</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">;<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">&nbsp;&nbsp;&nbsp;&nbsp; <o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #888888; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">//this will return part ofString str from index 0 to 12</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"><o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">String subString = str.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">substring</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><b><span style="color: #0000dd; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">0</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">,</span><b><span style="color: #0000dd; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">12</span></b><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">);<o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">&nbsp;&nbsp;&nbsp;&nbsp; <o:p></o:p></span></div><div class="MsoNormal" style="background-position: initial initial; background-repeat: initial initial; border: none; padding: 0in;"><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">System.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">out</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">.</span><span style="color: #336699; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">println</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">(</span><span style="background: #FFF0F0; color: #dd2200; font-family: &quot;Courier New&quot;; font-size: 11.0pt;">"Substring: "</span><span style="color: #333333; font-family: &quot;Courier New&quot;; font-size: 11.0pt;"> + subString);<o:p></o:p></span></div></div></div><div class="MsoNormal"><br><br></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">7)"+" is overloaded for String concatenation</span></u></b></div><div class="MsoNormal"><span style="font-family: Arial;"><i>Javadoesn't support Operator overloading</i> but String is special and + operatorcan be used to concatenate two Strings. It can even used to convert </span><span style="font-family: &quot;Courier New&quot;;">int</span><span style="font-family: Arial;">, </span><span style="font-family: &quot;Courier New&quot;;">char</span><span style="font-family: Arial;">, </span><span style="font-family: &quot;Courier New&quot;;">long</span><span style="font-family: Arial;"> or </span><span style="font-family: &quot;Courier New&quot;;">double</span><span style="font-family: Arial;"> to convertinto String by simply concatenating with emptystring </span><span style="font-family: &quot;Courier New&quot;;">""</span><span style="font-family: Arial;">. internally + is implementedusing </span><span style="font-family: &quot;Courier New&quot;;">StringBuffer</span><span style="font-family: Arial;"> prior to Java 5 and </span><span style="font-family: &quot;Courier New&quot;;">StringBuilder</span><span style="font-family: Arial;"> from Java5 onwards. This also brings point of using </span><span style="font-family: &quot;Courier New&quot;;">StringBuffer</span><span style="font-family: Arial;"> or </span><span style="font-family: &quot;Courier New&quot;;">StringBuilder</span><span style="font-family: Arial;"> formanipulating String. Since both represent mutable object they can be used toreduce string garbage created because of temporary String. Read more about <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTEvMDcvc3RyaW5nLXZzLXN0cmluZ2J1ZmZlci12cy1zdHJpbmdidWlsZGVyLmh0bWw=" title="http://javarevisited.blogspot.com/2011/07/string-vs-stringbuffer-vs-stringbuilder.html">StringBuffervs StringBuilder<i class="fa fa-external-link"></i></span> here.</span></div><div class="MsoNormal"><br></div><div class="MsoNormal"><span style="font-family: Arial;"><span style="mso-spacerun: yes;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">8) Usetrim() to remove white spaces from String</span></u></b></div><div class="MsoNormal"><span style="font-family: Arial;">String in Java provides </span><span style="font-family: &quot;Courier New&quot;;">trim()</span><span style="font-family: Arial;"> method to remove white spacefrom both end of String. If </span><span style="font-family: &quot;Courier New&quot;;">trim()</span><span style="font-family: Arial;"> removes white spaces itreturns a new </span><span style="font-family: &quot;Courier New&quot;;">String</span><span style="font-family: Arial;"> otherwise it returns same String. Along with </span><span style="font-family: &quot;Courier New&quot;;">trim()</span><span style="font-family: Arial;"> String also provides </span><span style="font-family: &quot;Courier New&quot;;">replace()</span><span style="font-family: Arial;"> and </span><span style="font-family: &quot;Courier New&quot;;">replaceAll()</span><span style="font-family: Arial;"> method forreplacing characters from String. </span><span style="font-family: &quot;Courier New&quot;;">replaceAll</span><span style="font-family: Arial;"> method evensupport regular expression. Read more about How to replace String in Java <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTEvMTIvamF2YS1zdHJpbmctcmVwbGFjZS1leGFtcGxlLXR1dG9yaWFsLmh0bWw=" title="http://javarevisited.blogspot.com/2011/12/java-string-replace-example-tutorial.html">here<i class="fa fa-external-link"></i></span>.</span></div><div class="MsoNormal"><br><br></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">9) Usesplit() for splitting String using Regular expression</span></u></b></div><div class="MsoNormal"><span style="font-family: Arial;">String in Java is feature rich. it has methods like </span><span style="font-family: &quot;Courier New&quot;;">split(regex)</span><span style="font-family: Arial;"> which cantake any String in form of regular expression and split the String based onthat. particularly useful if you dealing with comma separated file (CSV) andwanted to have individual part in a String array. There are other methods alsoavailable related to splitting String, see this <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTEvMDkvc3RyaW5nLXNwbGl0LWV4YW1wbGUtaW4tamF2YS10dXRvcmlhbC5odG1s" title="http://javarevisited.blogspot.com/2011/09/string-split-example-in-java-tutorial.html">Javatutorial to split string<i class="fa fa-external-link"></i></span> for more details.</span><br><span style="font-family: Arial;"><br></span></div><div class="MsoNormal"><br></div><div class="MsoNormal"><b><u><span style="font-family: Arial;">10) Don'tstore sensitive data in String</span></u></b></div><div class="MsoNormal"><span style="font-family: Arial;">String pose security threat if used for storing sensitive data likepasswords, SSN or any other sensitive information. Since String is immutable inJava there is no way you can erase contents of String and since they are keptin String pool (in case of String literal) they stay longer on Java heap ,whichexposes risk of being seen by anyone who has access to Java memory, likereading from memory dump. Instead </span><span style="font-family: &quot;Courier New&quot;;">char[]</span><span style="font-family: Arial;"> should beused to store password or sensitive information. See <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLmJyLzIwMTIvMDMvd2h5LWNoYXJhY3Rlci1hcnJheS1pcy1iZXR0ZXItdGhhbi5odG1s" title="http://javarevisited.blogspot.com.br/2012/03/why-character-array-is-better-than.html">Whychar[] is more secure than String for storing passwords in Java<i class="fa fa-external-link"></i></span> for moredetails.</span><br><span style="font-family: Arial;"><br></span><span style="font-family: Arial;"><br></span><span style="font-family: Arial;"><b><u>11) Character Encoding and String</u></b></span><br><span style="font-family: Arial;">Apart from all these 10 facts about String in Java, the most critical thing to know is <i>what encoding your String is using</i>. It does not make sense to have a </span><span style="font-family: Courier New, Courier, monospace;">String </span><span style="font-family: Arial;">without knowing what encoding it uses. There is no way to interpret an String if you don't know the encoding it used. You can not assume that </span><span style="font-family: Courier New, Courier, monospace;">"plain"</span><span style="font-family: Arial;"> text is ASCII. If you have a String, in memory or stored in file, you must know what encoding it is in, or you cannot display it correctly. By default Java uses platform encoding i.e. character encoding of your server, and believe me this can cause huge trouble if you are handling Unicode data, especially if you are <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3Quc2cvMjAxMy8wMy9jb252ZXJ0LWFuZC1wcmludC1ieXRlLWFycmF5LXRvLWhleC1zdHJpbmctamF2YS1leGFtcGxlLXR1dG9yaWFsLmh0bWw=" title="http://javarevisited.blogspot.sg/2013/03/convert-and-print-byte-array-to-hex-string-java-example-tutorial.html">converting byte array to XML String<i class="fa fa-external-link"></i></span>. I have faced instances where our program fail to interpret Strings from European language e.g. German, French etc. because our server was not using Unicode encodings like </span><span style="font-family: Courier New, Courier, monospace;">UTF-8</span><span style="font-family: Arial;"> or </span><span style="font-family: Courier New, Courier, monospace;">UTF-16</span><span style="font-family: Arial;">. Thankfully, Java allows you to specify default character encoding for your application using system property file.encoding. See <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTIvMDEvZ2V0LXNldC1kZWZhdWx0LWNoYXJhY3Rlci1lbmNvZGluZy5odG1s" title="http://javarevisited.blogspot.com/2012/01/get-set-default-character-encoding.html">here <i class="fa fa-external-link"></i></span>to read more about character encoding in Java</span></div><div class="MsoNormal"><br><br></div><div class="MsoNormal"><span style="font-family: Arial;">That's all about String in Java. As I have said String is very special inJava, sometime even refer has God class. It has some unique feature like </span><span style="font-family: &quot;Courier New&quot;;">immutability</span><span style="font-family: Arial;">, </span><span style="font-family: &quot;Courier New&quot;;">concatenationsupport, caching</span><span style="font-family: Arial;"> etc, and to become a serious Java programmer,detailed knowledge of String is quite important. Last but not the least don'tforget about <span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLzIwMTIvMDEvZ2V0LXNldC1kZWZhdWx0LWNoYXJhY3Rlci1lbmNvZGluZy5odG1s" title="http://javarevisited.blogspot.com/2012/01/get-set-default-character-encoding.html">characterencoding<i class="fa fa-external-link"></i></span> while converting a byte array into String in Java. Good knowledge of</span><span style="font-family: Courier New, Courier, monospace;"> java.lang.String</span><span style="font-family: Arial;"> is must for good Java developers.</span></div><div class="MsoNormal"><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;String in Java is very special class and most frequently used class as&lt;br&gt;well. There are lot many thin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/logging/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/logging/</id>
    <published>2019-06-14T02:52:59.705Z</published>
    <updated>2019-06-14T02:52:59.705Z</updated>
    
    <content type="html"><![CDATA[<h2>前言</h2><p>日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。<br>日志记录的好坏直接关系到系统出现问题时定位的速度，同时可以通过对日志的观察和分析，提前发现系统可能的风险，避免线上事故的发生。<br>我们在开发和运维NOS（网易对象存储，Netease Object Storage）的过程中，对整个系统的日志进行了分析优化，积累出一些经验，归纳如下。</p><h2>相关问题经验整理</h2><h4>1. 关于日志级别</h4><p>我们通常使用的日志库（如log4j等），将日志基本分为以下几类（从低到高）：<br><strong>TRACE </strong>- The TRACE Level designates finer-grained informational events than the DEBUG<br><strong>DEBUG</strong> &#8211; The DEBUG Level designates fine-grained informational events that are most useful to debug an application.<br><strong>INFO </strong>- The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.<br><strong>WARN </strong>- The WARN level designates potentially harmful situations.<br><strong>ERROR </strong>- The ERROR level designates error events that might still allow the application to continue running.<br><strong>FATAL </strong>- The FATAL level designates very severe error events that will presumably lead the application to abort.</p><p>尽管<span class="exturl" data-url="aHR0cDovL2xvZ2dpbmcuYXBhY2hlLm9yZy9sb2c0ai8xLjIvYXBpZG9jcy9vcmcvYXBhY2hlL2xvZzRqL0xldmVsLmh0bWw=" title="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html">log4j官方文档<i class="fa fa-external-link"></i></span>对各个日志级别进行了简单定义。然而在实践中，究竟哪些操作需要记入日志，哪种错误应该记为WARN级别，而哪种错误又为ERROR级别，还需要进行进一步讨论。</p><p>关于该问题，在StackOverflow上有一个<span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDMxMTYzL3doZW4tdG8tdXNlLWxvZy1sZXZlbC13YXJuLXZzLWVycm9y" title="http://stackoverflow.com/questions/2031163/when-to-use-log-level-warn-vs-error">讨论贴<i class="fa fa-external-link"></i></span>进行过讨论。</p><p>此处对贴子中的一些观点，加上我们在平时运维过程中遇到的相关问题进行归纳：</p><ul><li>一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；</li><li>即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题；</li><li>对于日志级别的分类，有以下参考：<br><strong>FATAL</strong> &#8212; 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；<br><strong>ERROR</strong> &#8212; 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当ERROR错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上ERROR错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而ERROR相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印ERROR日志。特别需要注意的是，ERROR和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为ERROR日志的；<br><strong>WARN</strong> &#8212; 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；<br><strong>INFO</strong> &#8212; 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,ERROR,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于TRACE日志的10%；<br><strong>DEBUG</strong> or <strong>TRACE</strong> &#8212; 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过DEBUG（或TRACE）级别的日志对问题进行诊断。需要注意的是，DEBUG日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过DEBUG（或TRACE）日志来定位问题；</li></ul><p><strong>Rule 1：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等</strong></p><h4>2. 对记录的日志要进行更新维护</h4><p>由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：</p><ul><li>定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；</li><li>整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；</li><li>开发做运维，通过在查问题的过程来优化日志记录的方式；</li><li>运维或测试在日志中发现的问题，都需要及时向开发人员反映；</li></ul><p><strong>Rule 2：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题</strong></p><h4>3. 关于日志分类</h4><p>日志从功能来说，可分为诊断日志、统计日志、审计日志。</p><p>诊断日志， 典型的有：</p><ul><li>请求入口和出口</li><li>外部服务调用和返回</li><li>资源消耗操作: 打开文件等</li><li>容错行为： 譬如云硬盘的副本修复操作</li><li>程序异常： 譬如数据库无法连接</li><li>后台操作：清理程序</li><li>启动、关闭、配置加载</li><li>抛出异常时，不记录日志</li></ul><p>统计日志：</p><ul><li>用户访问统计</li><li>计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）</li></ul><p>审计日志：</p><ul><li>管理操作</li></ul><p>将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。</p><p><strong>Rule 3：要明确不同日志的用途，对日志内容进行分类</strong></p><h4>4. 日志中不要记录无用信息</h4><p>在很多应用中，用户都需要通过Fuse方式来挂载使用NOS。</p><p>POSIX标准中文件系统接口不允许文件 <strong>/a</strong> 与目录<strong> /a/</strong> 同时存在，而NOS作为对象存储系统，<strong>/a</strong> 和 <strong>/a/</strong> 是不同的对象，是能够同时存在的，一般地，NOS 中我们会规定<strong> /a/</strong> 是目录，<strong>/a</strong> 是文件，目录对象大小为0。</p><p>POSIX标准对文件的getattr操作，无论是<strong> /a</strong> 还是 <strong>/a/</strong>，对应的请求都是 <strong>/a</strong>。为了避免遗漏，需分别向 NOS 请求 HeadObject(&#8220;<strong>/a</strong>&#8220;)和 HeadObject(&#8220;<strong>/a/</strong>&#8220;)。如果命中<strong>/a</strong>，说明<strong> /a</strong> 是一个文件，不用再请求 getattr(&#8220;<strong>/a/</strong>&#8220;)。</p><p>因此当用户访问 */a/b/c.txt* 时，实际上向NOS发送了以下请求：<br># HeadObject(&#8220;/a&#8221;)<br># HeadObject(&#8220;/a/&#8221;)<br># HeadObject(&#8220;/a/b&#8221;)<br># HeadObject(&#8220;/a/b/&#8221;)<br># HeadObject(&#8220;/a/b/c.txt&#8221;)</p><p>对于上面的请求，实际上HeadObject(&#8220;/a&#8221;)和HeadObject(&#8220;/a/b&#8221;)都会返回NoSuchKey错误，而Fuse正是该错误来判断该文件不存在，而可能是个目录的。</p><p>然而对于NOS来说，这将导致产生大量无意义的NoSuchKey日志（整个日志文件的80%都是该错误日志）。这些日志对于开发人员进行日志观察，运维人员定位问题，日志监控等都造成了困难。</p><p><strong>Rule 4: 绝不要打印没有用的日志，防止无用日志淹没重要信息</strong></p><p><strong>解决办法：</strong>Fuse请求时，在Http头部加入 User-Agent 字段，当NOS发现请求是 Fuse发过来的且为HeadObject操作且为NoSuchKey错误时，则不打印错误日志。</p><h4>5. 日志记录信息要完整</h4><p><strong>问题描述：</strong></p><p>NOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：</p><ul><li>InitMultiUpload（生成一个UploadID）</li><li>UploadPart</li><li>UploadPart</li><li> ……</li><li>UploadPart</li><li>CompleteMultiUpload（AbortMultiUpload）</li></ul><p>之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。</p><p>然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。</p><p>类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。</p><p>因此，需要进一步对日志中需要记录哪些内容进行规定，<strong>此处推荐的需要在日志中记录的内容有：</strong></p><ul><li>在系统启动或初始化时记录重要的系统初始化参数</li><li>记录系统运行过程中的所有的错误</li><li>记录系统运行过程中的所有的警告</li><li>在持久化数据修改时记录修改前和修改后的值</li><li>记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）</li><li>重要的状态变化（如NOS中对系统白名单的修改等）</li><li>系统中一些长期执行的任务的执行进度</li></ul><p><strong>而不推荐记录日志的内容有：</strong></p><ul><li>函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志</li><li>文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志</li><li>“良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理</li></ul><p><strong>Rule 5：日志信息要准确全面，能做到仅凭日志就可以定位问题</strong></p><p><strong>解决办法：</strong>整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。</p><h4>6. 测试的日志</h4><p>测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。</p><p>测试日志应该包含以下内容：</p><ul><li>测试执行的环境</li><li>测试执行前的初始状态</li><li>测试的详细步骤</li><li>测试和系统的交互信息</li><li>测试期望的返回结果</li><li>测试实际的返回结果</li></ul><p><strong>Rule 6：要以同样严格的要求对待测试程序的日志</strong></p><h4>7. 从问题中完善日志</h4><p>在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：</p><ul><li>如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化</li><li>需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）</li></ul><p>通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。</p><p><strong>Rule 7：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</strong></p><h4>8. 关于RequestID</h4><h3>RequestID的生成：</h3><p>如今NOS有8台机器，共40个tomcat对外提供服务。通常用户在请求出错的时候，我们都希望用户告诉我们请求的RequestID，以此我们可以确定请求是在哪台机器上进行处理的。</p><p>NOS通过以下信息生成一个请求的RequestID：</p><ul><li>收到请求的时间</li><li>处理请求的服务器ip地址</li><li>随机数</li></ul><p>因此我们可以通过一个简单的程序从RequestID中得到该请求的处理时间和处理请求的服务器地址，更方便的去查看日志：</p><pre style="padding-left: 30px;"> <strong>./<span style="color: #0000ff;">decode.sh</span> 4b2c009a0a7800000142789f42b8ca96</strong><strong> Thu Nov 21 11:06:12 CST 2013</strong><strong> 10.120.202.150</strong><strong> 4b2c009a</strong></pre><p><strong>Rule 8：在RequestID中尽量编码更多的信息</strong></p><h3>用RequestID将请求的处理流程关联起来：</h3><p>在NOS性能测试中，之前存在的一个问题是，由于在打印错误堆栈的地方，并没有打印请求的RequestID，因此当一个请求出现错误时，很难（日志量太大）将该请求的错误堆栈和具体的请求关联起来。</p><p>另一个问题是，NOS后端有视频服务器集群和图片处理服务器集群。因此我们可能会有以下需求：当用户视频截图失败时，用户会告诉我们请求的RequestID，由于NOS并没有将该RequestID转发到后端的图片处理服务器，因此无法利用该信息去查看视频处理服务器上的日志，而需要通过用户请求的URL进行查找。同时，由于我们无法知道该请求是在哪个具体的视频处理的worker上进行，进一步导致查找日志的困难。</p><p>还有一个潜在的问题是：如果NOS将所有的日志收集起来（tomcat，图片处理集群，视频处理集群……），我们无法做到通过requestID来查找一个请求的处理流程。</p><p><strong>Rule 9：将一个请求的整个处理流程和唯一的requestID关联起来</strong></p><h4>9. 关于线上机器的日志级别</h4><p><strong>问题描述：</strong></p><p>NOS的DEBUG日志非常详细的记录了请求处理相关信息，然而由于DEBUG日志量太大，因此通常线上只开INFO级别日志。然而INFO级别的日志却有可能导致部分问题无法定位。NOS线上一个请求可能随机地分发到4台机器进行处理，因此如果某一种错误在一段时间内多次出现，它也会在4台服务器上都出现。</p><p>因此我们推荐的做法是，选择一台机器开启DEBUG级别的日志，方便定位问题。其实该做法背后的目的是，在线上任何问题的时候，都可以通过日志最快的找到问题的根源。</p><p><strong>Rule 10：让一台机器开启DEBUG日志</strong></p><h4>10. 上线后的日志观察</h4><p>随着NOS开始服务越来越多的产品，NOS每次版本升级之后，通过对日志的观察来确定服务是否正常变得至关重要。同时在上线新功能时，来发人员需要通过观察一些特定的日志，来确定新功能是否工作正常。</p><p><strong>举例来说：</strong></p><p>NOS在实现了桶表缓存的功能之后，首先上线一台服务器，并对该功能是否工作正常进行观察。通过将桶缓存的所有操作（如插入，查找，过期删除等）以及桶缓存的状态（如缓存桶数量）都记录在DEBUG级别的日志中。将新上线的机器的日志级别调为DEBUG，并对桶缓存的相关操作是否正确，缓存桶数量等信息进行观察，确认一切正常之后再上线其他机器。</p><p><strong>Rule 11：新上线服务器后一定要对日志进行观察，特别地，开发人员可以通过观察日志来确认新功能是否工作正常</strong></p><h4>11. 慢操作日志</h4><p>NOS在接收到一个请求的时候，会记录请求的接收时间（T1），在请求处理完成待发送的时候，会记录请求发送时间（T2），通常一个请求的日志都记为INFO级别，然而当出现请求处理时间（T2-T1）超过一定时间（如10s）时，会将该日志提升为WARN级别。通过该方法，可以预先发现系统可能存在的一些问题。</p><p>同样的慢操作日志还可以用来记录系统一些外部依赖的处理时间，如NOS依赖外部认证服务器来进行认证。我们会记录每个请求的认证时间，如果认证时间超过某个值，也需要将该事件的日志级别进行提升，这样我们可以尽早发现认证服务器是不是需要扩容等问题。</p><p>慢日志的时间阀值应该是可以动态调整的，这样在进行系统优化时，可以将该报警时间阀值逐渐调小，不断地对系统进行优化。</p><p><strong>Rule 12：通过日志级别的提升来发现潜在问题</strong></p><h4>12. 日志报警</h4><p>错误日志报警：</p><p>NOS通过[运维平台|https://m.hz.netease.com/]设置了日志监控报警，周期性的（1分钟，5分钟）对服务器新产生的日志进行监控，如果发现错误数超过某个阀值，则进行报警。这类报警通常不一定是我们服务本身的问题，也有可能是用户使用NOS不当造成的。</p><p>此处需要注意的问题是，日志报警相当于grep操作，如果日志量过大，或者匹配规则过多，可能对线上的服务产生影响。因此在设置好日志报警后，需要周期性的关注每次日志扫描的时间，评估日志监控是否对服务产生影响。</p><p><strong>Rule 13：对日志进行监控报警，比客户先发现系统问题</strong></p><p>关键字报警：</p><p>NOS为每个用户分配了一定量的存储配额，当用户容量超限时，会限制用户的上传操作。通过在日志中记录关键字，如“Quota Warning”等，可以及时提醒用户进行扩容，避免用户服务中断。</p><p>类似的关键字报警还有很多：如对InternalError的数量进行监控，对缓存的桶数量进行监控等等。</p><p><strong>Rule 14：通过日志中的关键字来确定系统的运行状态</strong></p><h4>13. 关于日志格式</h4><p>日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：</p><p>第一种：<br><strong>logger.error(&#8220;Gearman timeout exception for request &#8221; + getRequestID() + &#8221; value: &#8221; + value, e);</strong></p><p>第二种：<br><strong>logger.error(&#8220;RequestID: &#8221; + getRequestID() + &#8220;, Error Message: Gearman timeout exception: &#8221; + e);</strong></p><p>第三种：<br><strong>logger.error(getErrorMessage(getRequestID(), getErrorMessage(), e));</strong></p><p>第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：</p><ul><li>系统中日志格式不统一，不利于自动化处理</li><li>有些日志可能只有开发人员自己才能看懂</li><li>代码规范性不好</li></ul><p>而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。</p><p><strong>Rule 15：日志格式要统一规范</strong></p><h4>14. 错误日志输出到不同文件</h4><p>在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。</p><p>这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。</p><p><strong>Rule 16：将错误日志输出到一个单独的文件中进行分析</strong></p><h4>15. 关于日志文件大小</h4><p>日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。</p><p>为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：</p><ul><li>将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；</li><li>每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志</li></ul><p>log4j关于日志切分的相关配置，可以参考<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9iYWliYWx1by9hcmNoaXZlLzIwMTEvMDYvMDMvMjA3MjA5MS5odG1s" title="http://www.cnblogs.com/baibaluo/archive/2011/06/03/2072091.html">这篇文章<i class="fa fa-external-link"></i></span>。</p><p><strong>Rule 17：要把日志的大小，如何切分，如何删除等作为规范建立起来</strong></p><h2>经验汇总</h2><p>此处对以上总结的所有经验进行汇总：</p><ul><li>整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等</li><li>需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题</li><li>要明确不同日志的用途，对日志内容进行分类</li><li>绝不要打印没有用的日志，防止无用日志淹没重要信息</li><li>日志信息要准确全面，努力做到仅凭日志就可以定位问题</li><li>要以同样严格的要求对待测试程序的日志</li><li>日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</li><li>在RequestID中尽量编码更多的信息</li><li>将一个请求的整个处理流程和唯一的requestID关联起来</li><li>让一台机器开启DEBUG日志</li><li>新上线服务器后一定要对日志进行观察，特别地，开发人员可以通过观察日志来确认新功能是否工作正常</li><li>通过日志级别的提升来发现潜在问题</li><li>对日志进行监控报警，比客户先发现系统问题</li><li>通过日志中的关键字来确定系统的运行状态</li><li>日志格式要统一规范</li><li>将错误日志输出到一个单独的文件中进行分析</li><li>要把日志的大小，如何切分，如何删除等作为规范建立起来</li></ul><h2>参考文献</h2><p>[1] <i> &#8221;Optimal Logging&#8221; <i>Anthony Vallone from Google <span class="exturl" data-url="aHR0cDovL2dvb2dsZXRlc3RpbmcuYmxvZ3Nwb3QuanAvMjAxMy8wNi9vcHRpbWFsLWxvZ2dpbmcuaHRtbA==" title="http://googletesting.blogspot.jp/2013/06/optimal-logging.html">http://googletesting.blogspot.jp/2013/06/optimal-logging.html<i class="fa fa-external-link"></i></span> </i> </i></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。&lt;br&gt;
日志记录的好坏直接关系到系统出现问题时定位的速度，同时可以通
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/cpu-cache/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/cpu-cache/</id>
    <published>2019-06-14T02:52:59.705Z</published>
    <updated>2019-06-14T02:52:59.705Z</updated>
    
    <content type="html"><![CDATA[<p>现在的CPU比25年前要精密得多了。在那个年代，CPU的频率与内存总线的频率基本在同一层面上。内存的访问速度仅比寄存器慢那么一点点。但是，这一局面在上世纪90年代被打破了。CPU的频率大大提升，但内存总线的频率与内存芯片的性能却没有得到成比例的提升。并不是因为造不出更快的内存，只是因为太贵了。内存如果要达到目前CPU那样的速度，那么它的造价恐怕要贵上好几个数量级。</p><p> 如果有两个选项让你选择，一个是速度非常快、但容量很小的内存，一个是速度还算快、但容量很多的内存，如果你的工作集比较大，超过了前一种情况，那么人们总是会选择第二个选项。原因在于辅存(一般为磁盘)的速度。由于工作集超过主存，那么必须用辅存来保存交换出去的那部分数据，而辅存的速度往往要比主存慢上好几个数量级。 </p> <p> 好在这问题也并不全然是非甲即乙的选择。在配置大量DRAM的同时，我们还可以配置少量SRAM。将地址空间的某个部分划给SRAM，剩下的部分划给DRAM。一般来说，SRAM可以当作扩展的寄存器来使用。 </p>上面的做法看起来似乎可以，但实际上并不可行。首先，将SRAM内存映射到进程的虚拟地址空间就是个非常复杂的工作，而且，在这种做法中，每个进程都需要管理这个SRAM区内存的分配。每个进程可能有大小完全不同的SRAM区，而组成程序的每个模块也需要索取属于自身的SRAM，更引入了额外的同步需求。简而言之，快速内存带来的好处完全被额外的管理开销给抵消了。因此，SRAM是作为CPU自动使用和管理的一个资源，而不是由OS或者用户管理的。在这种模式下，SRAM用来复制保存（或者叫缓存）主内存中有可能即将被CPU使用的数据。这意味着，在较短时间内，CPU很有可能重复运行某一段代码，或者重复使用某部分数据。从代码上看，这意味着CPU执行了一个循环，所以相同的代码一次又一次地执行（空间局部性的绝佳例子）。数据访问也相对局限在一个小的区间内。即使程序使用的物理内存不是相连的，在短期内程序仍然很有可能使用同样的数据（时间局部性）。这个在代码上表现为，程序在一个循环体内调用了入口一个位于另外的物理地址的函数。这个函数可能与当前指令的物理位置相距甚远，但是调用的时间差不大。在数据上表现为，程序使用的内存是有限的（相当于工作集的大小）。但是实际上由于RAM的随机访问特性，程序使用的物理内存并不是连续的。正是由于空间局部性和时间局部性的存在，我们才提炼出今天的CPU缓存概念。<p> 我们先用一个简单的计算来展示一下高速缓存的效率。假设，访问主存需要200个周期，而访问高速缓存需要15个周期。如果使用100个数据元素100次，那么在没有高速缓存的情况下，需要2000000个周期，而在有高速缓存、而且所有数据都已被缓存的情况下，只需要168500个周期。节约了91.5%的时间。 </p> <p> 用作高速缓存的SRAM容量比主存小得多。以我的经验来说，高速缓存的大小一般是主存的千分之一左右(目前一般是4GB主存、4MB缓存)。这一点本身并不是什么问题。只是，计算机一般都会有比较大的主存，因此工作集的大小总是会大于缓存。特别是那些运行多进程的系统，它的工作集大小是所有进程加上内核的总和。 </p>处理高速缓存大小的限制需要制定一套很好的策略来决定在给定的时间内什么数据应该被缓存。由于不是所有数据的工作集都是在完全相同的时间段内被使用的，我们可以用一些技术手段将需要用到的数据临时替换那些当前并未使用的缓存数据。这种预取将会减少部分访问主存的成本，因为它与程序的执行是异步的。所有的这些技术将会使高速缓存在使用的时候看起来比实际更大。我们将在3.3节讨论这些问题。 <span>我们将在第6章讨论如何让</span>这些技术能很好地帮助程序员，让处理器更高效地工作。<h3> 3.1 高速缓存的位置 </h3> <p> 在深入介绍高速缓存的技术细节之前，有必要说明一下它在现代计算机系统中所处的位置。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113713_tlJC.png">  <br>  <strong>图3.1: 最简单的高速缓存配置图</strong> </blockquote> <p> 图3.1展示了最简单的高速缓存配置。早期的一些系统就是类似的架构。在这种架构中，CPU核心不再直连到主存。{在一些更早的系统中，高速缓存像CPU与主存一样连到系统总线上。那种做法更像是一种hack，而不是真正的解决方案。}数据的读取和存储都经过高速缓存。CPU核心与高速缓存之间是一条特殊的快速通道。在简化的表示法中，主存与高速缓存都连到系统总线上，这条总线同时还用于与其它组件通信。我们管这条总线叫“FSB”——就是现在称呼它的术语，参见第2.2节。在这一节里，我们将忽略北桥。 </p>在过去的几十年，经验表明使用了冯诺伊曼结构的 <span>计算机，</span>将用于代码和数据的高速缓存分开是存在巨大优势的。自1993年以来，Intel <span>并且一直坚持</span>使用独立的代码和数据高速缓存。由于所需的代码和数据的内存区域是几乎相互独立的，这就是为什么独立缓存工作得更完美的原因。近年来，独立缓存的另一个优势慢慢显现出来：常见处理器解码 <span>指令<span>的</span></span>步骤 <span>是缓慢的</span>，尤其当管线为空的时候，往往会伴随着错误的预测或无法预测的分支的出现， <span>将高速缓存技术用于</span> <span>指令</span> <span>解码可以加快其执行速度。</span><p> 在高速缓存出现后不久，系统变得更加复杂。高速缓存与主存之间的速度差异进一步拉大，直到加入了另一级缓存。新加入的这一级缓存比第一级缓存更大，但是更慢。由于加大一级缓存的做法从经济上考虑是行不通的，所以有了二级缓存，甚至现在的有些系统拥有三级缓存，如图3.2所示。随着单个CPU中核数的增加，未来甚至可能会出现更多层级的缓存。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113714_KQTE.png">  <br>  <strong>图3.2: 三级缓存的处理器</strong> </blockquote> <p> 图3.2展示了三级缓存，并介绍了本文将使用的一些术语。L1d是一级数据缓存，L1i是一级指令缓存，等等。请注意，这只是示意图，真正的数据流并不需要流经上级缓存。CPU的设计者们在设计高速缓存的接口时拥有很大的自由。而程序员是看不到这些设计选项的。 </p><p> 另外，我们有多核CPU，每个核心可以有多个“线程”。核心与线程的不同之处在于，核心拥有独立的硬件资源({早期的多核CPU甚至有独立的二级缓存。})。在不同时使用相同资源(比如，通往外界的连接)的情况下，核心可以完全独立地运行。而线程只是共享资源。Intel的线程只有独立的寄存器，而且还有限制——不是所有寄存器都独立，有些是共享的。综上，现代CPU的结构就像图3.3所示。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113714_1MPY.png">  <br>  <strong>图3.3 多处理器、多核心、多线程</strong> </blockquote> <p> 在上图中，有两个处理器，每个处理器有两个核心，每个核心有两个线程。线程们共享一级缓存。核心(以深灰色表示)有独立的一级缓存，同时共享二级缓存。处理器(淡灰色)之间不共享任何缓存。这些信息很重要，特别是在讨论多进程和多线程情况下缓存的影响时尤为重要。 </p><h3> 3.2 高级的缓存操作<br> </h3> <p> 了解成本和节约使用缓存，我们必须结合在第二节中讲到的关于计算机体系结构和RAM技术，以及前一节讲到的缓存描述来探讨。 </p> <p> 默认情况下，CPU核心所有的数据的读或写都存储在缓存中。当然，也有内存区域不能被缓存的，但是这种情况只发生在操作系统的实现者对数据考虑的前提下；对程序实现者来说，这是不可见的。这也说明，程序设计者可以故意绕过某些缓存，不过这将是第六节中讨论的内容了。 </p><p> 如果CPU需要访问某个字(word)，先检索缓存。很显然，缓存不可能容纳主存所有内容(否则还需要主存干嘛)。系统用字的内存地址来对缓存条目进行标记。如果需要读写某个地址的字，那么根据标签来检索缓存即可。这里用到的地址可以是虚拟地址，也可以是物理地址，取决于缓存的具体实现。 </p> <p> 标签是需要额外空间的，用字作为缓存的粒度显然毫无效率。比如，在x86机器上，32位字的标签可能需要32位，甚至更长。另一方面，由于空间局部性的存在，与当前地址相邻的地址有很大可能会被一起访问。再回忆下2.2.1节——内存模块在传输位于同一行上的多份数据时，由于不需要发送新CAS信号，甚至不需要发送RAS信号，因此可以实现很高的效率。基于以上的原因，缓存条目并不存储单个字，而是存储若干连续字组成的“线”。在早期的缓存中，线长是32字节，现在一般是64字节。对于64位宽的<span>内存总线</span>，每条线需要8次传输。而DDR对于这种传输模式的支持更为高效。 </p><p> 当处理器需要内存中的某块数据时，整条缓存线被装入L1d。缓存线的地址通过对内存地址进行掩码操作生成。对于64字节的缓存线，是将低6位置0。这些被丢弃的位作为线内偏移量。其它的位作为标签，并用于在缓存内定位。在实践中，我们将地址分为三个部分。32位地址的情况如下: </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113714_bLaw.png"> </blockquote> <p> 如果缓存线长度为2<sup>O</sup>，那么地址的低O位用作线内偏移量。上面的S位选择“缓存集”。后面我们会说明使用缓存集的原因。现在只需要明白一共有2<sup>S</sup>个缓存集就够了。剩下的32 - S - O = T位组成标签。它们用来区分别名相同的各条线{有相同S部分的缓存线被称为有相同的别名。}用于定位缓存集的S部分不需要存储，因为属于同一缓存集的所有线的S部分都是相同的。 </p><p> 当某条指令修改内存时，仍然要先装入缓存线，因为任何指令都不可能同时修改整条线(只有一个例外——第6.1节中将会介绍的写合并(write-combine))。因此需要在写操作前先把缓存线装载进来。如果缓存线被写入，但还没有写回主存，那就是所谓的“脏了”。脏了的线一旦写回主存，脏标记即被清除。 </p> <p> 为了装入新数据，基本上总是要先在缓存中清理出位置。L1d将内容逐出L1d，推入L2(线长相同)。当然，L2也需要清理位置。于是L2将内容推入L3，最后L3将它推入主存。这种逐出操作一级比一级昂贵。这里所说的是现代AMD和VIA处理器所采用的<em>独占型缓存(exclusive cache)</em>。而Intel采用的是<em>包容型缓存(inclusive cache)，</em>{并不完全正确，Intel有些缓存是独占型的，还有一些缓存具有独占型缓存的特点。}L1d的每条线同时存在于L2里。对这种缓存，逐出操作就很快了。如果有足够L2，对于相同内容存在不同地方造成内存浪费的缺点可以降到最低，而且在逐出时非常有利。而独占型缓存在装载新数据时只需要操作L1d，不需要碰L2，因此会比较快。 </p><p> 处理器体系结构中定义的作为存储器的模型只要还没有改变，那就允许多CPU按照自己的方式来管理高速缓存。这表示，例如，设计优良的处理器，利用很少或根本没有内存总线活动，并主动写回主内存脏高速缓存行。这种高速缓存架构在如x86和x86-64各种各样的处理器间存在。制造商之间，即使在同一制造商生产的产品中，证明了的内存模型抽象的力量。 </p> 在对称多处理器（SMP）架构的系统中，CPU的高速缓存不能独立的工作。在任何时候，所有的处理器都应该拥有相同的内存内容。保证这样的统一的内存视图被称为“高速缓存一致性”。如果在其自己的高速缓存和主内存间，处理器设计简单，它将不会看到在其他处理器上的脏高速缓存行的内容。从一个处理器直接访问另一个处理器的高速缓存这种模型设计代价将是非常昂贵的，它是一个相当大的瓶颈。相反，当另一个处理器要读取或写入到高速缓存线上时，处理器会去检测。 <br><p> 如果CPU检测到一个写访问，而且该CPU的cache中已经缓存了一个cache line的原始副本，那么这个cache line将被标记为无效的cache line。接下来在引用这个cache line之前，需要重新加载该cache line。需要注意的是读访问并不会导致cache line被标记为无效的。 </p> <p> 更精确的cache实现需要考虑到其他更多的可能性，比如第二个CPU在读或者写他的cache line时，发现该cache line在第一个CPU的cache中被标记为脏数据了，此时我们就需要做进一步的处理。在这种情况下，主存储器已经失效，第二个CPU需要读取第一个CPU的cache line。通过测试，我们知道在这种情况下第一个CPU会将自己的cache line数据自动发送给第二个CPU。这种操作是绕过主存储器的，但是有时候存储控制器是可以直接将第一个CPU中的cache line数据存储到主存储器中。对第一个CPU的cache的写访问会导致本地cache line的所有拷贝被标记为无效。 </p>随着时间的推移，一大批缓存一致性协议已经建立。其中，最重要的是MESI,我们将在第3.3.4节进行介绍。以上结论可以概括为几个简单的规则: <br> <ul>  <li> 一个脏缓存线不存在于任何其他处理器的缓存之中。 </li>  <li> 同一缓存线中的干净拷贝可以驻留在任意多个其他缓存之中。 </li> </ul> 如果遵守这些规则,处理器甚至可以在多处理器系统中更加有效的使用它们的缓存。所有的处理器需要做的就是监控其他每一个写访问和比较本地缓存中的地址。在下一节中,我们将介绍更多细节方面的实现,尤其是存储开销方面的细节。 <br><p> 最后，我们至少应该关注高速缓存命中或未命中带来的消耗。下面是英特尔奔腾 M 的数据： </p> <table border="1">  <tbody>   <tr>    <th> To Where </th>    <th> Cycles </th>   </tr>   <tr>    <td> Register </td>    <td> &lt;= 1 </td>   </tr>   <tr>    <td> L1d </td>    <td> ~3 </td>   </tr>   <tr>    <td> L2 </td>    <td> ~14 </td>   </tr>   <tr>    <td> Main Memory </td>    <td> ~240 </td>   </tr>  </tbody> </table> <p> <br> </p> <p> 这是在CPU周期中的实际访问时间。有趣的是，对于L2高速缓存的访问时间很大一部分（甚至是大部分）是由线路的延迟引起的。这是一个限制，增加高速缓存的大小变得更糟。只有当减小时（例如，从60纳米的Merom到45纳米Penryn处理器），可以提高这些数据。 </p>表格中的数字看起来很高，但是，幸运的是，整个成本不必须负担每次出现的缓存加载和缓存失效。某些部分的成本可以被隐藏。现在的处理器都使用不同长度的内部管道，在管道内指令被解码，并为准备执行。如果数据要传送到一个寄存器，那么部分的准备工作是从存储器（或高速缓存）加载数据。如果内存加载操作在管道中足够早的进行，它可以与其他操作并行发生，那么加载的全部发销可能会被隐藏。对L1D常常可能如此；某些有长管道的处理器的L2也可以。 <br> <br> 提早启动内存的读取有许多障碍。它可能只是简单的不具有足够资源供内存访问，或者地址从另一个指令获取，然后加载的最终地址才变得可用。在这种情况下，加载成本是不能隐藏的（完全的）。 <br><p> 对于写操作，CPU并不需要等待数据被安全地放入内存。只要指令具有类似的效果，就没有什么东西可以阻止CPU走捷径了。它可以早早地执行下一条指令，甚至可以在影子寄存器(shadow register)的帮助下，更改这个写操作将要存储的数据。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113714_N5Op.png">  <br>  <strong>图3.4: 随机写操作的访问时间</strong> </blockquote> <p> 图3.4展示了缓存的效果。关于产生图中数据的程序，我们会在稍后讨论。这里大致说下，这个程序是连续随机地访问某块大小可配的内存区域。每个数据项的大小是固定的。数据项的多少取决于选择的工作集大小。Y轴表示处理每个元素平均需要多少个CPU周期，注意它是对数刻度。X轴也是同样，工作集的大小都以2的n次方表示。 </p><p> 图中有三个比较明显的不同阶段。很正常，这个处理器有L1d和L2，没有L3。根据经验可以推测出，L1d有2<sup>13</sup>字节，而L2有2<sup>20</sup>字节。因为，如果整个工作集都可以放入L1d，那么只需不到10个周期就可以完成操作。如果工作集超过L1d，处理器不得不从L2获取数据，于是时间飘升到28个周期左右。如果工作集更大，超过了L2，那么时间进一步暴涨到480个周期以上。这时候，许多操作将不得不从主存中获取数据。更糟糕的是，如果修改了数据，还需要将这些脏了的缓存线写回内存。 </p> <p> 看了这个图，大家应该会有足够的动力去检查代码、改进缓存的利用方式了吧？这里的性能改善可不只是微不足道的几个百分点，而是几个数量级呀。在第6节中，我们将介绍一些编写高效代码的技巧。而下一节将进一步深入缓存的设计。虽然精彩，但并不是必修课，大家可以选择性地跳过。 </p><h3> 3.3 CPU缓存实现的细节 </h3> <p> 缓存的实现者们都要面对一个问题——主存中每一个单元都可能需被缓存。如果程序的工作集很大，就会有许多内存位置为了缓存而打架。前面我们曾经提过缓存与主存的容量比，1:1000也十分常见。 </p> <h4> 3.3.1 关联性 </h4> <p> 我们可以让缓存的每条线能存放任何内存地址的数据。这就是所谓的<em>全关联缓存(fully associative cache</em><em>)</em>。对于这种缓存，处理器为了访问某条线，将不得不检索所有线的标签。而标签则包含了整个地址，而不仅仅只是线内偏移量(也就意味着，图3.2中的S为0)。 </p> <p> <br> </p> <p> <br> </p><p> <span style="line-height:1.5;font-size:10pt;">高速缓存有类似这样的实现，但是，看看在今天使用的L2的数目，表明这是不切实际的。给定4MB的高速缓存和64B的高速缓存段，高速缓存将有65,536个项。为了达到足够的性能，缓存逻辑</span><span style="line-height:1.5;font-size:10pt;"></span><span style="line-height:1.5;font-size:10pt;">必须能够</span><span style="line-height:1.5;font-size:10pt;">在短短的几个时钟周期内，</span><span style="line-height:1.5;font-size:10pt;">从所有这些项中，挑一个匹配给定的标签。实现这一点的工作将是巨大的。</span> </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113715_MkFo.png">  <p> <b>Figure 3.5: 全关联高速缓存原理图</b> </p> </blockquote> <p> 对于每个高速缓存行，比较器是需要比较大标签（注意，S是零）。每个连接旁边的字母表示位的宽度。如果没有给出，它是一个单比特线。每个比较器都要比较两个T-位宽的值。然后，基于该结果，适当的高速缓存行的内容被选中，并使其可用。这需要合并多套O数据线，因为他们是缓存桶（译注：这里类似把O输出接入多选器，所以需要合并）。实现仅仅一个比较器，需要晶体管的数量就非常大，特别是因为它必须非常快。没有迭代比较器是可用的。节省比较器的数目的唯一途径是通过反复比较标签，以减少它们的数目。<span>这是不适合的，</span>出于同样的原因，迭代比较器不可用：它的时间太长。 </p>全关联高速缓存对 <span>小缓存是</span>实用的（例如，在某些Intel处理器的TLB缓存是全关联的），但这些缓存都很小，非常小的。我们正在谈论的最多几十项。 <br> <br> 对于L1i，L1d和更高级别的缓存，需要采用不同的方法。可以做的就是是限制搜索。最极端的限制是，每个标签映射到一个明确的缓存条目。计算很简单：给定的4MB/64B缓存有65536项，我们可以使用地址的bit6到bit21（16位）来直接寻址高速缓存的每一个项。地址的低6位作为高速缓存段的索引。 <br><blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113715_FrW1.png">  <p> <b>Figure 3.6: Direct-Mapped Cache Schematics</b> </p> </blockquote> <p> <span>在图3.6中可以看出，这种</span>直接映射的高速缓存，速度快，比较容易实现。它只是需要一个比较器，一个多路复用器（在这个图中有两个，标记和数据是分离的，但是<span>对于设计</span>这不是一个硬性要求），和一些逻辑来选择只是有效的高速缓存行的内容。由于速度的要求，<span>比较器是复杂的，但是现在</span>只需要一个，结果是可以花更多的精力，让其变得快速。这种方法的复杂性在于在多路复用器。一个简单的多路转换器中的晶体管的数量增速是O（log N）的，其中N是高速缓存段的数目。这是可以容忍的，但可能会很慢，在某种情况下，速度可提升，通过增加<span>多路复用器</span>晶体管数量，来并行化的一些工作和自身增速。晶体管的总数只是随着快速增长的高速缓存缓慢的增加，这使得这种解决方案非常有吸引力。但它有一个缺点：只有<span>用于直接映射地址的相关的地址位</span>均匀分布，程序才能<span>很好</span>工作。如果分布的不均匀，而且这是常态，一些缓存项频繁的使用，并因此多次被换出，而另一些则几乎不被使用或一直是空的。 </p><blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113715_hQpb.png">  <p> <b>Figure 3.7: 组关联高速缓存原理图</b> </p> </blockquote> <p> 可以<span>通过使高速缓存的组关联来</span>解决此问题。组关联结合高速缓存的全关联和直接映射高速缓存特点，在很大程度上避免那些设计的弱点。图3.7显示了一个组关联高速缓存的设计。标签和数据存储分成不同的组并可以通过地址选择。这类似直接映射高速缓存。但是，小数目的值可以在同一个高速缓存组缓存，而不是一个缓存组只有一个元素，用于在高速缓存中的每个设定值是相同的一组值的缓存。所有组的成员的标签可以并行比较，这类似全关联缓存的功能。 </p><p> <span style="line-height:1.5;font-size:10pt;">其结果是高速缓存，不容易被不幸或故意选择同属同一组编号的地址所击败，同时高速缓存的大小并不限于由比较器的数目，可以以并行的方式实现。如果高速缓存增长，只（在该图中）增加列的数目，而不增加行数。只有高速缓存之间的关联性增加，行数才会增加。今天，处理器的L2高速缓存或更高的高速缓存，使用的关联性高达16。 L1高速缓存通常使用8。</span> </p> <table border>  <tbody>   <tr>    <th> L2<br> Cache<br> Size </th>    <th> Associativity </th>   </tr>   <tr>    <th> Direct </th>    <th> 2 </th>    <th> 4 </th>    <th> 8 </th>   </tr>   <tr>    <th> CL=32 </th>    <th> CL=64 </th>    <th> CL=32 </th>    <th> CL=64 </th>    <th> CL=32 </th>    <th> CL=64 </th>    <th> CL=32 </th>    <th> CL=64 </th>   </tr>   <tr>    <td> 512k </td>    <td> 27,794,595 </td>    <td> 20,422,527 </td>    <td> 25,222,611 </td>    <td> 18,303,581 </td>    <td> 24,096,510 </td>    <td> 17,356,121 </td>    <td> 23,666,929 </td>    <td> 17,029,334 </td>   </tr>   <tr>    <td> 1M </td>    <td> 19,007,315 </td>    <td> 13,903,854 </td>    <td> 16,566,738 </td>    <td> 12,127,174 </td>    <td> 15,537,500 </td>    <td> 11,436,705 </td>    <td> 15,162,895 </td>    <td> 11,233,896 </td>   </tr>   <tr>    <td> 2M </td>    <td> 12,230,962 </td>    <td> 8,801,403 </td>    <td> 9,081,881 </td>    <td> 6,491,011 </td>    <td> 7,878,601 </td>    <td> 5,675,181 </td>    <td> 7,391,389 </td>    <td> 5,382,064 </td>   </tr>   <tr>    <td> 4M </td>    <td> 7,749,986 </td>    <td> 5,427,836 </td>    <td> 4,736,187 </td>    <td> 3,159,507 </td>    <td> 3,788,122 </td>    <td> 2,418,898 </td>    <td> 3,430,713 </td>    <td> 2,125,103 </td>   </tr>   <tr>    <td> 8M </td>    <td> 4,731,904 </td>    <td> 3,209,693 </td>    <td> 2,690,498 </td>    <td> 1,602,957 </td>    <td> 2,207,655 </td>    <td> 1,228,190 </td>    <td> 2,111,075 </td>    <td> 1,155,847 </td>   </tr>   <tr>    <td> 16M </td>    <td> 2,620,587 </td>    <td> 1,528,592 </td>    <td> 1,958,293 </td>    <td> 1,089,580 </td>    <td> 1,704,878 </td>    <td> 883,530 </td>    <td> 1,671,541 </td>    <td> 862,324 </td>   </tr>  </tbody> </table> <p> <b>Table 3.1: 高速缓存大小，关联行，段大小的影响</b> </p> <p> 给定我们4MB/64B高速缓存，8路组关联，相关的缓存留给我们的有8192组，只用标签的13位，就可以寻址缓集。要确定哪些（如果有的话）的缓存组设置中的条目包含寻址的高速缓存行，8个标签都要进行比较。在很短的时间内做出来是可行的。通过一个实验，我们可以看到，这是有意义的。 </p> <p> <br> </p><p> 表3.1显示一个程序在改变缓存大小，缓存段大小和关联集大小，L2高速缓存的缓存失效数量（根据Linux内核相关的方面人的说法，GCC在这种情况下，是他们所有中最重要的标尺）。在7.2节中，我们将介绍工具来模拟此测试要求的高速缓存。 </p> <p> &nbsp;万一这还不是很明显，所有这些值之间的关系是高速缓存的大小为： </p> <blockquote>  cache line size &times; associativity &times; number of sets&nbsp; </blockquote> <p> 地址被映射到高速缓存使用 </p> <blockquote>  <b>O</b> = log  <sub>2</sub> cache line size  <br>  <b>S</b> = log  <sub>2</sub> number of sets </blockquote> <p> 在第3.2节中的图显示的方式。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113715_JWar.png">  <p> <b>Figure 3.8: 缓存段大小 vs 关联行 (CL=32)</b> </p> </blockquote> <p> 图3.8表中的数据更易于理解。它显示一个固定的32个字节大小的高速缓存行的数据。对于一个给定的高速缓存大小，我们可以看出，关联性，的确可以帮助明显减少高速缓存未命中的数量。对于8MB的缓存，从直接映射到2路组相联，可以减少近44％的高速缓存未命中。组相联高速缓存和直接映射缓存相比，该处理器可以把更多的工作集保持在缓存中。 </p><p> 在文献中，偶尔可以读到，引入关联性，和加倍<span>高速缓存的大小</span>具有相同的效果。在从4M缓存跃升到8MB缓存的极端的情况下，<span>这是正确的</span>。关联性再提高一倍那就肯定不正确啦。正如我们所看到的数据，后面的收益要小得多。我们不应该完全低估它的效果，虽然。在示例程序中的内存使用的<span>峰值</span>是5.6M。因此，具有8MB缓存不太可能有很多（两个以上）使用相同的高速缓存的组。从较小的缓存的<span>关联性的巨大收益可以看出，较大工作集可以节省更多</span>。 </p> <p> 在一般情况下，增加8以上的高速缓存之间的关联性似乎对只有一个单线程工作量影响不大。随着介绍一个使用<span>共享L2的</span>多核处理器，形势发生了变化。现在你基本上有两个程序命中相同的缓存， 实际上导致高速缓存减半（对于四核处理器是1/4）。因此，可以预期，随着核的数目的增加，共享高速缓存的相关性也应增长。一旦这种方法不再可行（16 路组关联性已经很难）处理器设计者不得不开始使用共享的三级高速缓存和更高级别的，而L2高速缓存只被核的一个子集共享。 </p><p> 从图3.8中，我们还可以研究缓存大小对性能的影响。这一数据需要了解工作集的大小才能进行解读。很显然，与主存相同的缓存比小缓存能产生更好的结果，因此，缓存通常是越大越好。 </p> <p> 上文已经说过，示例中最大的工作集为5.6M。它并没有给出最佳缓存大小值，但我们可以估算出来。问题主要在于内存的使用并不连续，因此，即使是16M的缓存，在处理5.6M的工作集时也会出现冲突(参见2路集合关联式16MB缓存vs直接映射式缓存的优点)。不管怎样，我们可以有把握地说，在同样5.6M的负载下，缓存从16MB升到32MB基本已没有多少提高的余地。但是，工作集是会变的。如果工作集不断增大，缓存也需要随之增大。在购买计算机时，如果需要选择缓存大小，一定要先衡量工作集的大小。原因可以参见图3.10。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113716_62uA.png">  <br>  <strong>图3.9: 测试的内存分布情况</strong> </blockquote> <p> 我们执行两项测试。第一项测试是按顺序地访问所有元素。测试程序循着指针n进行访问，而所有元素是链接在一起的，从而使它们的被访问顺序与在内存中排布的顺序一致，如图3.9的下半部分所示，末尾的元素有一个指向首元素的引用。而第二项测试(见图3.9的上半部分)则是按随机顺序访问所有元素。在上述两个测试中，所有元素都构成一个单向循环链表。 </p><p> <b>3.3.2 Cache的性能测试</b> </p> <p> 用于测试程序的数据可以模拟一个任意大小的工作集：包括读、写访问，随机、连续访问。在图3.4中我们可以看到，程序为工作集创建了一个与其大小和元素类型相同的数组： </p> <pre>  struct l {    struct l *n;    long int pad[NPAD];  };</pre> <p> n字段将所有节点随机得或者顺序的加入到环形链表中，用指针从当前节点进入到下一个节点。pad字段用来存储数据，其可以是任意大小。在一些测试程序中，pad字段是可以修改的, 在其他程序中，pad字段只可以进行读操作。 </p> <p> 在性能测试中，我们谈到工作集大小的问题，工作集使用结构体l定义的元素表示的。2<sup>N</sup> 字节的工作集包含 </p> <blockquote>  2  <sup>N</sup>/sizeof(struct l) </blockquote> <p> 个元素. 显然sizeof(struct l) 的值取决于NPAD的大小。在32位系统上，NPAD=7意味着数组的每个元素的大小为32字节，在64位系统上，NPAD=7意味着数组的每个元素的大小为64字节。 </p><h4> 单线程顺序访问 </h4> <p> 最简单的情况就是遍历链表中顺序存储的节点。无论是从前向后处理，还是从后向前，对于处理器来说没有什么区别。下面的测试中，我们需要得到处理链表中一个元素所需要的时间，以CPU时钟周期最为计时单元。图3.10显示了测试结构。除非有特殊说明, 所有的测试都是在Pentium&nbsp;4 64-bit 平台上进行的，因此结构体l中NPAD=0，大小为8字节。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113716_eaYQ.png">  <p> <b>图 3.10: 顺序读访问, NPAD=0</b> </p> </blockquote> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113716_LLY3.png">  <p> <b>图 3.11: 顺序读多个字节</b> </p> </blockquote><p> 一开始的两个测试数据收到了噪音的污染。由于它们的工作负荷太小，无法过滤掉系统内其它进程对它们的影响。我们可以认为它们都是4个周期以内的。这样一来，整个图可以划分为比较明显的三个部分: </p> <ul>  <li> <span style="line-height:1.5;font-size:10pt;">工作集小于2</span><sup>14</sup><span style="line-height:1.5;font-size:10pt;">字节的。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">工作集从2</span><sup>15</sup><span style="line-height:1.5;font-size:10pt;">字节到2</span><sup>20</sup><span style="line-height:1.5;font-size:10pt;">字节的。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">工作集大于2</span><sup>21</sup><span style="line-height:1.5;font-size:10pt;">字节的。</span> </li> </ul> <p> 这样的结果很容易解释——是因为处理器有16KB的L1d和1MB的L2。而在这三个部分之间，并没有非常锐利的边缘，这是因为系统的其它部分也在使用缓存，我们的测试程序并不能独占缓存的使用。尤其是L2，它是统一式的缓存，处理器的指令也会使用它(注: Intel使用的是包容式缓存)。 </p> <p> <br> </p> <p> <br> </p>测试的实际耗时可能会出乎大家的意料。L1d的部分跟我们预想的差不多，在一台P4上耗时为4个周期左右。但L2的结果则出乎意料。大家可能觉得需要14个周期以上，但实际只用了9个周期。这要归功于处理器先进的处理逻辑，当它使用连续的内存区时，会 <i>预先读取</i>下一条缓存线的数据。这样一来，当真正使用下一条线的时候，其实已经早已读完一半了，于是真正的等待耗时会比L2的访问时间少很多。<p> 在工作集超过L2的大小之后，预取的效果更明显了。前面我们说过，主存的访问需要耗时200个周期以上。但在预取的帮助下，实际耗时保持在9个周期左右。200 vs 9，效果非常不错。 </p> <p> 我们可以观察到预取的行为，至少可以间接地观察到。图3.11中有4条线，它们表示处理不同大小结构时的耗时情况。随着结构的变大，元素间的距离变大了。图中4条线对应的元素距离分别是0、56、120和248字节。 </p><p> 图中最下面的这一条线来自前一个图，但在这里更像是一条直线。其它三条线的耗时情况比较差。图中这些线也有比较明显的三个阶段，同时，在小工作集的情况下也有比较大的错误(请再次忽略这些错误)。在只使用L1d的阶段，这些线条基本重合。因为这时候还不需要预取，只需要访问L1d就行。 </p> <p> 在L2阶段，三条新加的线基本重合，而且耗时比老的那条线高很多，大约在28个周期左右，差不多就是L2的访问时间。这表明，从L2到L1d的预取并没有生效。这是因为，对于<span>最下面的线(NPAD=0)，由于结构小，8次循环后才需要访问一条新缓存线，而上面三条线对应的结构比较大，</span>拿相对最小的NPAD=7来说，光是一次循环就需要访问一条新线，更不用说更大的NPAD=15和31了。而预取逻辑是无法在每个周期装载新线的，因此每次循环都需要从L2读取，我们看到的就是从L2读取的时延。 </p>更有趣的是工作集超过L2容量后的阶段。快看，4条线远远地拉开了。元素的大小变成了主角，左右了性能。处理器应能识别每一步(stride)的大小，不去为NPAD=15和31获取那些实际并不需要的缓存线(参见6.3.1)。元素大小对预取的约束是根源于硬件预取的限制——它无法跨越页边界。如果允许预取器跨越页边界，而下一页不存在或无效，那么OS还得去寻找它。这意味着，程序需要遭遇一次并非由它自己产生的页错误，这是完全不能接受的。在NPAD=7或者更大的时候，由于每个元素都至少需要一条缓存线，预取器已经帮不上忙了，它没有足够的时间去从内存装载数据。另一个导致慢下来的原因是TLB缓存的未命中。TLB是存储虚实地址映射的缓存，参见第4节。为了保持快速，TLB只有很小的容量。如果有大量页被反复访问，超出了TLB缓存容量，就会导致反复地进行地址翻译，这会耗费大量时间。TLB查找的代价分摊到所有元素上，如果元素越大，那么元素的数量越少，每个元素承担的那一份就越多。<p> 为了观察TLB的性能，我们可以进行另两项测试。第一项：我们还是顺序存储列表中的元素，使NPAD=7，让每个元素占满整个cache line，第二项：我们将列表的每个元素存储在一个单独的页上，忽略每个页没有使用的部分以用来计算工作集的大小。（这样做可能不太一致，因为在前面的测试中，我计算了结构体中每个元素没有使用的部分，从而用来定义NPAD的大小，因此每个元素占满了整个页，这样以来工作集的大小将会有所不同。但是这不是这项测试的重点，预取的低效率多少使其有点不同）。结果表明，第一项测试中，每次列表的迭代都需要一个新的cache line，而且每64个元素就需要一个新的页。第二项测试中，每次迭代都会在一个新的页中加载一个新的cache line。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113716_ifZC.png">  <p> <b>图 3.12: TLB 对顺序读的影响<br> </b> </p> </blockquote>结果见图3.12。该测试与图3.11是在同一台机器上进行的。基于可用RAM空间的有限性，测试设置容量空间大小为2的24次方字节，这就需要1GB的容量将对象放置在分页上。图3.12中下方的红色曲线正好对应了图3.11中NPAD等于7的曲线。我们看到不同的步长显示了高速缓存L1d和L2的大小。第二条曲线看上去完全不同，其最重要的特点是当工作容量到达2的13次方字节时开始大幅度增长。这就是TLB缓存溢出的时候。我们能计算出一个64字节大小的元素的TLB缓存有64个输入。成本不会受页面错误影响，因为程序锁定了存储器以防止内存被换出。<p> 可以看出，计算物理地址并把它存储在TLB中所花费的周期数量级是非常高的。图3.12的表格显示了一个极端的例子，但从中可以清楚的得到：TLB缓存效率降低的一个重要因素是大型NPAD值的减缓。由于物理地址必须在缓存行能被L2或主存读取之前计算出来，地址转换这个不利因素就增加了内存访问时间。这一点部分解释了为什么NPAD等于31时每个列表元素的总花费比理论上的RAM访问时间要高。 </p> <p> <img src="http://static.oschina.net/uploads/img/201302/27113717_mCPy.png"><br> 图3.13 NPAD等于1时的顺序读和写 </p> <p> 通过查看链表元素被修改时测试数据的运行情况，我们可以窥见一些更详细的预取实现细节。图3.13显示了三条曲线。所有情况下元素宽度都为16个字节。第一条曲线“Follow”是熟悉的链表走线在这里作为基线。第二条曲线，标记为“Inc”，仅仅在当前元素进入下一个前给其增加thepad[0]成员。第三条曲线，标记为&quot;Addnext0&quot;， 取出下一个元素的thepad[0]链表元素并把它添加为当前链表元素的thepad[0]成员。 </p><p> 在没运行时，大家可能会以为&quot;Addnext0&quot;更慢，因为它要做的事情更多——在没进到下个元素之前就需要装载它的值。但实际的运行结果令人惊讶——在某些小工作集下，&quot;Addnext0&quot;比&quot;Inc&quot;更快。这是为什么呢？原因在于，系统一般会对下一个元素进行强制性预取。当程序前进到下个元素时，这个元素其实早已被预取在L1d里。因此，只要工作集比L2小，&quot;Addnext0&quot;的性能基本就能与&quot;Follow&quot;测试媲美。 </p> <p> 但是，&quot;Addnext0&quot;比&quot;Inc&quot;更快离开L2，这是因为它需要从主存装载更多的数据。而在工作集达到2 <sup>21</sup>字节时，&quot;Addnext0&quot;的耗时达到了28个周期，是同期&quot;Follow&quot;14周期的两倍。这个两倍也很好解释。&quot;Addnext0&quot;和&quot;Inc&quot;涉及对内存的修改，因此L2的逐出操作不能简单地把数据一扔了事，而必须将它们写入内存。因此FSB的可用带宽变成了一半，传输等量数据的耗时也就变成了原来的两倍。 </p><blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113717_SILO.png">  <br>  <strong>图3.14: 更大L2/L3缓存的优势</strong> </blockquote> <p> 决定顺序式缓存处理性能的另一个重要因素是缓存容量。虽然这一点比较明显，但还是值得一说。图3.14展示了128字节长元素的测试结果(64位机，NPAD=15)。这次我们比较三台不同计算机的曲线，两台P4，一台Core 2。两台P4的区别是缓存容量不同，一台是32k的L1d和1M的L2，一台是16K的L1d、512k的L2和2M的L3。Core 2那台则是32k的L1d和4M的L2。 </p><p> 图中最有趣的地方，并不是Core 2如何大胜两台P4，而是工作集开始增长到连末级缓存也放不下、需要主存热情参与之后的部分。 </p> <table border="1">  <tbody>   <tr>    <th> Set<br> Size </th>    <th> Sequential </th>    <th> Random </th>   </tr>   <tr>    <th> L2 Hit </th>    <th> L2 Miss </th>    <th> #Iter </th>    <th> Ratio Miss/Hit </th>    <th> L2 Accesses Per Iter </th>    <th> L2 Hit </th>    <th> L2 Miss </th>    <th> #Iter </th>    <th> Ratio Miss/Hit </th>    <th> L2 Accesses Per Iter </th>   </tr>   <tr>    <td> 2<sup>20</sup> </td>    <td> 88,636 </td>    <td> 843 </td>    <td> 16,384 </td>    <td> 0.94% </td>    <td> 5.5 </td>    <td> 30,462 </td>    <td> 4721 </td>    <td> 1,024 </td>    <td> 13.42% </td>    <td> 34.4 </td>   </tr>   <tr>    <td> 2<sup>21</sup> </td>    <td> 88,105 </td>    <td> 1,584 </td>    <td> 8,192 </td>    <td> 1.77% </td>    <td> 10.9 </td>    <td> 21,817 </td>    <td> 15,151 </td>    <td> 512 </td>    <td> 40.98% </td>    <td> 72.2 </td>   </tr>   <tr>    <td> 2<sup>22</sup> </td>    <td> 88,106 </td>    <td> 1,600 </td>    <td> 4,096 </td>    <td> 1.78% </td>    <td> 21.9 </td>    <td> 22,258 </td>    <td> 22,285 </td>    <td> 256 </td>    <td> 50.03% </td>    <td> 174.0 </td>   </tr>   <tr>    <td> 2<sup>23</sup> </td>    <td> 88,104 </td>    <td> 1,614 </td>    <td> 2,048 </td>    <td> 1.80% </td>    <td> 43.8 </td>    <td> 27,521 </td>    <td> 26,274 </td>    <td> 128 </td>    <td> 48.84% </td>    <td> 420.3 </td>   </tr>   <tr>    <td> 2<sup>24</sup> </td>    <td> 88,114 </td>    <td> 1,655 </td>    <td> 1,024 </td>    <td> 1.84% </td>    <td> 87.7 </td>    <td> 33,166 </td>    <td> 29,115 </td>    <td> 64 </td>    <td> 46.75% </td>    <td> 973.1 </td>   </tr>   <tr>    <td> 2<sup>25</sup> </td>    <td> 88,112 </td>    <td> 1,730 </td>    <td> 512 </td>    <td> 1.93% </td>    <td> 175.5 </td>    <td> 39,858 </td>    <td> 32,360 </td>    <td> 32 </td>    <td> 44.81% </td>    <td> 2,256.8 </td>   </tr>   <tr>    <td> 2<sup>26</sup> </td>    <td> 88,112 </td>    <td> 1,906 </td>    <td> 256 </td>    <td> 2.12% </td>    <td> 351.6 </td>    <td> 48,539 </td>    <td> 38,151 </td>    <td> 16 </td>    <td> 44.01% </td>    <td> 5,418.1 </td>   </tr>   <tr>    <td> 2<sup>27</sup> </td>    <td> 88,114 </td>    <td> 2,244 </td>    <td> 128 </td>    <td> 2.48% </td>    <td> 705.9 </td>    <td> 62,423 </td>    <td> 52,049 </td>    <td> 8 </td>    <td> 45.47% </td>    <td> 14,309.0 </td>   </tr>   <tr>    <td> 2<sup>28</sup> </td>    <td> 88,120 </td>    <td> 2,939 </td>    <td> 64 </td>    <td> 3.23% </td>    <td> 1,422.8 </td>    <td> 81,906 </td>    <td> 87,167 </td>    <td> 4 </td>    <td> 51.56% </td>    <td> 42,268.3 </td>   </tr>   <tr>    <td> 2<sup>29</sup> </td>    <td> 88,137 </td>    <td> 4,318 </td>    <td> 32 </td>    <td> 4.67% </td>    <td> 2,889.2 </td>    <td> 119,079 </td>    <td> 163,398 </td>    <td> 2 </td>    <td> 57.84% </td>    <td> 141,238.5 </td>   </tr>  </tbody> </table> <p> <strong>表3.2: 顺序访问与随机访问时L2命中与未命中的情况，NPAD=0</strong> </p> <p> 与我们预计的相似，最末级缓存越大，曲线停留在L2访问耗时区的时间越长。在220字节的工作集时，第二台P4(更老一些)比第一台P4要快上一倍，这要完全归功于更大的末级缓存。而Core 2拜它巨大的4M L2所赐，表现更为卓越。 </p><p> 对于随机的工作负荷而言，可能没有这么惊人的效果，但是，如果我们能将工作负荷进行一些裁剪，让它匹配末级缓存的容量，就完全可以得到非常大的性能提升。也是由于这个原因，有时候我们需要多花一些钱，买一个拥有更大缓存的处理器。 </p> <p> <strong>单线程随机访问模式的测量</strong> </p> <p> 前面我们已经看到，处理器能够利用L1d到L2之间的预取消除访问主存、甚至是访问L2的时延。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113717_AuZx.png">  <br>  <strong>图3.15: 顺序读取vs随机读取，NPAD=0</strong> </blockquote> <p> 但是，如果换成随机访问或者不可预测的访问，情况就大不相同了。图3.15比较了顺序读取与随机读取的耗时情况。 </p> <p> 换成随机之后，处理器无法再有效地预取数据，只有少数情况下靠运气刚好碰到先后访问的两个元素挨在一起的情形。 </p><p> 图3.15中有两个需要关注的地方。首先，在大的工作集下需要非常多的周期。这台机器访问主存的时间大约为200-300个周期，但图中的耗时甚至超过了450个周期。我们前面已经观察到过类似现象(对比图3.11)。这说明，处理器的自动预取在这里起到了反效果。 </p> <p> 其次，代表随机访问的曲线在各个阶段不像顺序访问那样保持平坦，而是不断攀升。为了解释这个问题，我们测量了程序在不同工作集下对L2的访问情况。结果如图3.16和表3.2。 </p><p> 从图中可以看出，当工作集大小超过L2时，未命中率(L2未命中次数/L2访问次数)开始上升。整条曲线的走向与图3.15有些相似: 先急速爬升，随后缓缓下滑，最后再度爬升。它与耗时图有紧密的关联。L2未命中率会一直爬升到100%为止。只要工作集足够大(并且内存也足够大)，就可以将缓存线位于L2内或处于装载过程中的可能性降到非常低。 </p> <p> 缓存未命中率的攀升已经可以解释一部分的开销。除此以外，还有一个因素。观察表3.2的L2/#Iter列，可以看到每个循环对L2的使用次数在增长。由于工作集每次为上一次的两倍，如果没有缓存的话，内存的访问次数也将是上一次的两倍。在按顺序访问时，由于缓存的帮助及完美的预见性，对L2使用的增长比较平缓，完全取决于工作集的增长速度。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113718_DCMb.png">  <br>  <strong>图3.16: L2d未命中率</strong> </blockquote> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113718_LnzD.png">  <br>  <strong>图3.17: 页意义上(Page-Wise)的随机化，NPAD=7</strong> </blockquote>而换成随机访问后，单位耗时的增长超过了工作集的增长，根源是TLB未命中率的上升。图3.17描绘的是NPAD=7时随机访问的耗时情况。这一次，我们修改了随机访问的方式。正常情况下是把整个列表作为一个块进行随机(以∞表示)，而其它11条线则是在小一些的块里进行随机。例如，标签为'60'的线表示以60页(245760字节)为单位进行随机。先遍历完这个块里的所有元素，再访问另一个块。这样一来，可以保证任意时刻使用的TLB条目数都是有限的。NPAD=7对应于64字节，正好等于缓存线的长度。由于元素顺序随机，硬件预取不可能有任何效果，特别是在元素较多的情况下。这意味着，分块随机时的L2未命中率与整个列表随机时的未命中率没有本质的差别。随着块的增大，曲线逐渐逼近整个列表随机对应的曲线。这说明，在这个测试里，性能受到TLB命中率的影响很大，如果我们能提高TLB命中率，就能大幅度地提升性能(在后面的一个例子里，性能提升了38%之多)。<h4> 3.3.3 写入时的行为 </h4> <p> 在我们开始研究多个线程或进程同时使用相同内存之前，先来看一下缓存实现的一些细节。我们要求缓存是一致的，而且这种一致性必须对用户级代码完全透明。而内核代码则有所不同，它有时候需要对缓存进行转储(flush)。 </p> <p> 这意味着，如果对缓存线进行了修改，那么在这个时间点之后，系统的结果应该是与没有缓存的情况下是相同的，即主存的对应位置也已经被修改的状态。这种要求可以通过两种方式或策略实现： </p> <ul>  <li> <span style="line-height:1.5;font-size:10pt;">写通(write-through)</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">写回(write-back)</span> </li> </ul><p> 写通比较简单。当修改缓存线时，处理器立即将它写入主存。这样可以保证主存与缓存的内容永远保持一致。当缓存线被替代时，只需要简单地将它丢弃即可。这种策略很简单，但是速度比较慢。如果某个程序反复修改一个本地变量，可能导致FSB上产生大量数据流，而不管这个变量是不是有人在用，或者是不是短期变量。 </p> <p> 写回比较复杂。当修改缓存线时，处理器不再马上将它写入主存，而是打上已弄脏(dirty)的标记。当以后某个时间点缓存线被丢弃时，这个已弄脏标记会通知处理器把数据写回到主存中，而不是简单地扔掉。 </p><p> 写回有时候会有非常不错的性能，因此较好的系统大多采用这种方式。采用写回时，处理器们甚至可以利用FSB的空闲容量来存储缓存线。这样一来，当需要缓存空间时，处理器只需清除脏标记，丢弃缓存线即可。 </p> <p> 但写回也有一个很大的问题。当有多个处理器(或核心、超线程)访问同一块内存时，必须确保它们在任何时候看到的都是相同的内容。如果缓存线在其中一个处理器上弄脏了(修改了，但还没写回主存)，而第二个处理器刚好要读取同一个内存地址，那么这个读操作不能去读主存，而需要读第一个处理器的缓存线。在下一节中，我们将研究如何实现这种需求。 </p><p> 在此之前，还有其它两种缓存策略需要提一下: </p> <ul>  <li> <span style="line-height:1.5;font-size:10pt;">写入合并</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">不可缓存</span> </li> </ul> <p> 这两种策略用于真实内存不支持的特殊地址区，内核为地址区设置这些策略(x86处理器利用内存类型范围寄存器MTRR)，余下的部分自动进行。MTRR还可用于写通和写回策略的选择。 </p> <p> 写入合并是一种有限的缓存优化策略，更多地用于显卡等设备之上的内存。由于设备的传输开销比本地内存要高的多，因此避免进行过多的传输显得尤为重要。如果仅仅因为修改了缓存线上的一个字，就传输整条线，而下个操作刚好是修改线上的下一个字，那么这次传输就过于浪费了。而这恰恰对于显卡来说是比较常见的情形——屏幕上水平邻接的像素往往在内存中也是靠在一起的。顾名思义，写入合并是在写出缓存线前，先将多个写入访问合并起来。在理想的情况下，缓存线被逐字逐字地修改，只有当写入最后一个字时，才将整条线写入内存，从而极大地加速内存的访问。 </p>最后来讲一下不可缓存的内存。一般指的是不被RAM支持的内存位置，它可以是硬编码的特殊地址，承担CPU以外的某些功能。对于商用硬件来说，比较常见的是映射到外部卡或设备的地址。在嵌入式主板上，有时也有类似的地址，用来开关LED。对这些地址进行缓存显然没有什么意义。比如上述的LED，一般是用来调试或报告状态，显然应该尽快点亮或关闭。而对于那些PCI卡上的内存，由于不需要CPU的干涉即可更改，也不该缓存。<p> <b>3.3.4 多处理器支持</b> </p> <p> 在上节中我们已经指出当多处理器开始发挥作用的时候所遇到的问题。甚至对于那些不共享的高速级别的缓存（至少在L1d级别）的多核处理器也有问题。 </p> <p> 直接提供从一个处理器到另一处理器的高速访问，这是完全不切实际的。从一开始，连接速度根本就不够快。实际的选择是，在其需要的情况下，转移到其他处理器。需要注意的是，这同样应用在相同处理器上无需共享的高速缓存。 </p>现在的问题是，当该高速缓存线转移的时候会发生什么？这个问题回答起来相当容易：当一个处理器需要在另一个处理器的高速缓存中读或者写的脏的高速缓存线的时候。但怎样处理器怎样确定在另一个处理器的缓存中的高速缓存线是脏的？假设它仅仅是因为一个高速缓存线被另一个处理器加载将是次优的（最好的）。通常情况下，大多数的内存访问是只读的访问和产生高速缓存线，并不脏。在高速缓存线上处理器频繁的操作（当然，否则为什么我们有这样的文件呢？），也就意味着每一次写访问后，都要广播关于高速缓存线的改变将变得不切实际。<p> 多年来，人们开发除了MESI缓存一致性协议(MESI=Modified, Exclusive, Shared, Invalid，变更的、独占的、共享的、无效的)。协议的名称来自协议中缓存线可以进入的四种状态: </p> <ul>  <li> <span style="line-height:1.5;font-size:10pt;"><b>变更的</b>: 本地处理器修改了缓存线。同时暗示，它是所有缓存中唯一的拷贝。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><strong>独占的</strong>: 缓存线没有被修改，而且没有被装入其它处理器缓存。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><strong>共享的</strong>: 缓存线没有被修改，但可能已被装入其它处理器缓存。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;"><strong>无效的</strong>: 缓存线无效，即，未被使用。</span> </li> </ul> <p> MESI协议开发了很多年，最初的版本比较简单，但是效率也比较差。现在的版本通过以上4个状态可以有效地实现写回式缓存，同时支持不同处理器对只读数据的并发访问。 </p><p> <img src="http://static.oschina.net/uploads/img/201302/27113718_cSIF.png"> <br> <strong>图3.18: MESI协议的状态跃迁图</strong> </p> <p> 在协议中，通过处理器监听其它处理器的活动，不需太多努力即可实现状态变更。处理器将操作发布在外部引脚上，使外部可以了解到处理过程。目标的缓存线地址则可以在地址总线上看到。在下文讲述状态时，我们将介绍总线参与的时机。 </p> <p> 一开始，所有缓存线都是空的，缓存为无效(Invalid)状态。当有数据装进缓存供写入时，缓存变为变更(Modified)状态。如果有数据装进缓存供读取，那么新状态取决于其它处理器是否已经状态了同一条缓存线。如果是，那么新状态变成共享(Shared)状态，否则变成独占(Exclusive)状态。 </p>如果本地处理器对某条Modified缓存线进行读写，那么直接使用缓存内容，状态保持不变。如果另一个处理器希望读它，那么第一个处理器将内容发给第一个处理器，然后可以将缓存状态置为Shared。而发给第二个处理器的数据由内存控制器接收，并放入内存中。如果这一步没有发生，就不能将这条线置为Shared。如果第二个处理器希望的是写，那么第一个处理器将内容发给它后，将缓存置为Invalid。这就是臭名昭著的&quot;请求所有权(Request For Ownership,RFO)&quot;操作。在末级缓存执行RFO操作的代价比较高。如果是写通式缓存，还要加上将内容写入上一层缓存或主存的时间，进一步提升了代价。对于Shared缓存线，本地处理器的读取操作并不需要修改状态，而且可以直接从缓存满足。而本地处理器的写入操作则需要将状态置为Modified，而且需要将缓存线在其它处理器的所有拷贝置为Invalid。因此，这个写入操作需要通过RFO消息发通知其它处理器。如果第二个处理器请求读取，无事发生。因为主存已经包含了当前数据，而且状态已经为Shared。如果第二个处理器需要写入，则将缓存线置为Invalid。不需要总线操作。<p> Exclusive状态与Shared状态很像，只有一个不同之处: 在Exclusive状态时，本地写入操作不需要在总线上声明，因为本地的缓存是系统中唯一的拷贝。这是一个巨大的优势，所以处理器会尽量将缓存线保留在Exclusive状态，而不是Shared状态。只有在信息不可用时，才退而求其次选择shared。放弃Exclusive不会引起任何功能缺失，但会导致性能下降，因为E→M要远远快于S→M。 </p> <p> 从以上的说明中应该已经可以看出，在多处理器环境下，哪一步的代价比较大了。填充缓存的代价当然还是很高，但我们还需要留意RFO消息。一旦涉及RFO，操作就快不起来了。 </p><p> RFO在两种情况下是必需的: </p> <ul>  <li> <span style="line-height:1.5;font-size:10pt;">线程从一个处理器迁移到另一个处理器，需要将所有缓存线移到新处理器。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">某条缓存线确实需要被两个处理器使用。{<em>对于同一处理器的两个核心，也有同样的情况，只是代价稍低。RFO消息可能会被发送多次。</em></span><span style="line-height:1.5;font-size:10pt;">}</span> </li> </ul> <p> 多线程或多进程的程序总是需要同步，而这种同步依赖内存来实现。因此，有些RFO消息是合理的，但仍然需要尽量降低发送频率。除此以外，还有其它来源的RFO。在第6节中，我们将解释这些场景。缓存一致性协议的消息必须发给系统中所有处理器。只有当协议确定已经给过所有处理器响应机会之后，才能进行状态跃迁。也就是说，协议的速度取决于最长响应时间。{<em>这也是现在能看到三插槽AMD Opteron系统的原因。这类系统只有三个超级链路(hyperlink)，其中一个连接南桥，每个处理器之间都只有一跳的距离。</em>}总线上可能会发生冲突，NUMA系统的延时很大，突发的流量会拖慢通信。这些都是让我们避免无谓流量的充足理由。 </p><p> 此外，关于多处理器还有一个问题。虽然它的影响与具体机器密切相关，但根源是唯一的——FSB是共享的。在大多数情况下，所有处理器通过唯一的总线连接到内存控制器(参见图2.1)。如果一个处理器就能占满总线(十分常见)，那么共享总线的两个或四个处理器显然只会得到更有限的带宽。 </p> <p> 即使每个处理器有自己连接内存控制器的总线，如图2.2，但还需要通往内存模块的总线。一般情况下，这种总线只有一条。退一步说，即使像图2.2那样不止一条，对同一个内存模块的并发访问也会限制它的带宽。 </p> <p> 对于每个处理器拥有本地内存的AMD模型来说，也是同样的问题。的确，所有处理器可以非常快速地同时访问它们自己的内存。但是，多线程呢？多进程呢？它们仍然需要通过访问同一块内存来进行同步。 </p><p> 对同步来说，有限的带宽严重地制约着并发度。程序需要更加谨慎的设计，将不同处理器访问同一块内存的机会降到最低。以下的测试展示了这一点，还展示了与多线程代码相关的其它效果。 </p> <p> <strong>多线程测量</strong> </p> <p> 为了帮助大家理解问题的严重性，我们来看一些曲线图，主角也是前文的那个程序。只不过这一次，我们运行多个线程，并测量这些线程中最快那个的运行时间。也就是说，等它们全部运行完是需要更长时间的。我们用的机器有4个处理器，而测试是做多跑4个线程。所有处理器共享同一条通往内存控制器的总线，另外，通往内存模块的总线也只有一条。 </p><blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113718_1VA6.png">  <br>  <strong>图3.19: 顺序读操作，多线程</strong> </blockquote> <p> 图3.19展示了顺序读访问时的性能，元素为128字节长(64位计算机，NPAD=15)。对于单线程的曲线，我们预计是与图3.11相似，只不过是换了一台机器，所以实际的数字会有些小差别。 </p> <p> 更重要的部分当然是多线程的环节。由于是只读，不会去修改内存，不会尝试同步。但即使不需要RFO，而且所有缓存线都可共享，性能仍然分别下降了18%(双线程)和34%(四线程)。由于不需要在处理器之间传输缓存，因此这里的性能下降完全由以下两个瓶颈之一或同时引起: 一是从处理器到内存控制器的共享总线，二是从内存控制器到内存模块的共享总线。当工作集超过L3后，三种情况下都要预取新元素，而即使是双线程，可用的带宽也无法满足线性扩展(无惩罚)。 </p><p> 当加入修改之后，场面更加难看了。图3.20展示了顺序递增测试的结果。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113718_X4NY.png">  <br>  <strong>图3.20: 顺序递增，多线程</strong> </blockquote> <p> 图中Y轴采用的是对数刻度，不要被看起来很小的差值欺骗了。现在，双线程的性能惩罚仍然是18%，但四线程的惩罚飙升到了93%！原因在于，采用四线程时，预取的流量与写回的流量加在一起，占满了整个总线。 </p> <p> 我们用对数刻度来展示L1d范围的结果。可以发现，当超过一个线程后，L1d就无力了。单线程时，仅当工作集超过L1d时访问时间才会超过20个周期，而多线程时，即使在很小的工作集情况下，访问时间也达到了那个水平。 </p><p> 这里并没有揭示问题的另一方面，主要是用这个程序很难进行测量。问题是这样的，我们的测试程序修改了内存，所以本应看到RFO的影响，但在结果中，我们并没有在L2阶段看到更大的开销。原因在于，要看到RFO的影响，程序必须使用大量内存，而且所有线程必须同时访问同一块内存。如果没有大量的同步，这是很难实现的，而如果加入同步，则会占满执行时间。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113719_dsub.png">  <br>  <strong>图3.21: 随机的Addnextlast，多线程</strong> </blockquote> <p> 最后，在图3.21中，我们展示了随机访问的Addnextlast测试的结果。这里主要是为了让大家感受一下这些巨大到爆的数字。极端情况下，甚至用了1500个周期才处理完一个元素。如果加入更多线程，真是不可想象哪。我们把多线程的效能总结了一下: </p> <blockquote>  <p> <b> </b></p>  <table border style="margin:0px;padding:0px;font-family:微软雅黑, Verdana, sans-serif, 宋体;color:#006600;font-size:12px;">   <tbody>    <tr>     <th> #Threads </th>     <th> Seq Read </th>     <th> Seq Inc </th>     <th> Rand Add </th>    </tr>    <tr>     <td> 2 </td>     <td> 1.69 </td>     <td> 1.69 </td>     <td> 1.54 </td>    </tr>    <tr>     <td> 4 </td>     <td> 2.98 </td>     <td> 2.07 </td>     <td> 1.65 </td>    </tr>   </tbody>  </table>  <b> </b>  <b>表3.3: 多线程的效能</b> </blockquote> <p> 这个表展示了图3.21中多线程运行大工作集时的效能。表中的数字表示测试程序在使用多线程处理大工作集时可能达到的最大加速因子。双线程和四线程的理论最大加速因子分别是2和4。从表中数据来看，双线程的结果还能接受，但四线程的结果表明，扩展到双线程以上是没有什么意义的，带来的收益可以忽略不计。只要我们把图3.21换个方式呈现，就可以很容易看清这一点。 </p><p> <img src="http://static.oschina.net/uploads/img/201302/27113719_WbIL.png"> <br> <strong>图3.22: 通过并行化实现的加速因子</strong> </p> <p> 图3.22中的曲线展示了加速因子，即多线程相对于单线程所能获取的性能加成值。测量值的精确度有限，因此我们需要忽略比较小的那些数字。可以看到，在L2与L3范围内，多线程基本可以做到线性加速，双线程和四线程分别达到了2和4的加速因子。但是，一旦工作集的大小超出L3，曲线就崩塌了，双线程和四线程降到了基本相同的数值(参见表3.3中第4列)。也是部分由于这个原因，我们很少看到4CPU以上的主板共享同一个内存控制器。如果需要配置更多处理器，我们只能选择其它的实现方式(参见第5节)。 </p><p> 可惜，上图中的数据并不是普遍情况。在某些情况下，即使工作集能够放入末级缓存，也无法实现线性加速。实际上，这反而是正常的，因为普通的线程都有一定的耦合关系，不会像我们的测试程序这样完全独立。而反过来说，即使是很大的工作集，即使是两个以上的线程，也是可以通过并行化受益的，但是需要程序员的聪明才智。我们会在第6节进行一些介绍。 </p> <p> <strong>特例: 超线程</strong> </p> <p> 由CPU实现的超线程(有时又叫对称多线程，SMT)是一种比较特殊的情况，每个线程并不能真正并发地运行。它们共享着除寄存器外的绝大多数处理资源。每个核心和CPU仍然是并行工作的，但核心上的线程则受到这个限制。理论上，每个核心可以有大量线程，不过到目前为止，Intel的CPU最多只有两个线程。CPU负责对各线程进行时分复用，但这种复用本身并没有多少厉害。它真正的优势在于，CPU可以在当前运行的超线程发生延迟时，调度另一个线程。这种延迟一般由内存访问引起。 </p><p> 如果两个线程运行在一个超线程核心上，那么只有当两个线程<em>合起来</em><em>的</em>运行时间少于单线程运行时间时，效率才会比较高。我们可以将通常先后发生的内存访问叠合在一起，以实现这个目标。有一个简单的计算公式，可以帮助我们计算如果需要某个加速因子，最少需要多少的缓存命中率。 </p> <p> 程序的执行时间可以通过一个只有一级缓存的简单模型来进行估算(参见[htimpact]): </p> <blockquote>  <span style="color:#006600;font-family:微软雅黑, Verdana, sans-serif, 宋体;font-size:12px;background-color:#F4F5F7;">T&nbsp;</span>  <sub>exe</sub>  <span style="color:#006600;font-family:微软雅黑, Verdana, sans-serif, 宋体;font-size:12px;background-color:#F4F5F7;">&nbsp;= N[(1-F&nbsp;</span>  <sub>mem</sub>  <span style="color:#006600;font-family:微软雅黑, Verdana, sans-serif, 宋体;font-size:12px;background-color:#F4F5F7;">)T&nbsp;</span>  <sub>proc</sub>  <span style="color:#006600;font-family:微软雅黑, Verdana, sans-serif, 宋体;font-size:12px;background-color:#F4F5F7;">&nbsp;+ F&nbsp;</span>  <sub>mem</sub>  <span style="color:#006600;font-family:微软雅黑, Verdana, sans-serif, 宋体;font-size:12px;background-color:#F4F5F7;">(G&nbsp;</span>  <sub>hit</sub>  <span style="color:#006600;font-family:微软雅黑, Verdana, sans-serif, 宋体;font-size:12px;background-color:#F4F5F7;">T&nbsp;</span>  <sub>cache</sub>  <span style="color:#006600;font-family:微软雅黑, Verdana, sans-serif, 宋体;font-size:12px;background-color:#F4F5F7;">&nbsp;+ (1-G&nbsp;</span>  <sub>hit</sub>  <span style="color:#006600;font-family:微软雅黑, Verdana, sans-serif, 宋体;font-size:12px;background-color:#F4F5F7;">)T&nbsp;</span>  <sub>miss</sub>  <span style="color:#006600;font-family:微软雅黑, Verdana, sans-serif, 宋体;font-size:12px;background-color:#F4F5F7;">)]</span> </blockquote> <p> 各变量的含义如下: </p> <blockquote>  <table style="margin:0px;padding:0px;font-family:微软雅黑, Verdana, sans-serif, 宋体;color:#006600;font-size:12px;">   <tbody>    <tr>     <td> N </td>     <td> = </td>     <td> 指令数 </td>    </tr>    <tr>     <td> F<sub>mem</sub> </td>     <td> = </td>     <td> N中访问内存的比例 </td>    </tr>    <tr>     <td> G<sub>hit</sub> </td>     <td> = </td>     <td> 命中缓存的比例 </td>    </tr>    <tr>     <td> T<sub>proc</sub> </td>     <td> = </td>     <td> 每条指令所用的周期数 </td>    </tr>    <tr>     <td> T<sub>cache</sub> </td>     <td> = </td>     <td> 缓存命中所用的周期数 </td>    </tr>    <tr>     <td> T<sub>miss</sub> </td>     <td> = </td>     <td> 缓冲未命中所用的周期数 </td>    </tr>    <tr>     <td> T<sub>exe</sub> </td>     <td> = </td>     <td> 程序的执行时间 </td>    </tr>   </tbody>  </table> </blockquote><p> 为了让任何判读使用双线程，两个线程之中任一线程的执行时间最多为单线程指令的一半。两者都有一个唯一的变量缓存命中数。 如果我们要解决最小缓存命中率相等的问题需要使我们获得的线程的执行率不少于50%或更多，如图 3.23. </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113719_xzHV.png">  <p> <b>图&nbsp;3.23: 最小缓存命中率-加速</b> </p> </blockquote> <p> X轴表示单线程指令的缓存命中率G<sub>hit，</sub>Y轴表示多线程指令所需的缓存命中率。这个值永远不能高于单线程命中率，否则，单线程指令也会使用改良的指令。为了使单线程的命中率在低于55%的所有情况下优于使用多线程，cup要或多或少的足够空闲因为缓存丢失会运行另外一个超线程。 </p>绿色区域是我们的目标。如果线程的速度没有慢过50%，而每个线程的工作量只有原来的一半，那么它们合起来的耗时应该会少于单线程的耗时。对我们用的示例系统来说(使用超线程的P4机器)，如果单线程代码的命中率为60%，那么多线程代码至少要达到10%才能获得收益。这个要求一般来说还是可以做到的。但是，如果单线程代码的命中率达到了95%，那么多线程代码要做到80%才行。这就很难了。而且，这里还涉及到超线程，在两个超线程的情况下，每个超线程只能分到一半的有效缓存。因为所有超线程是使用同一个缓存来装载数据的，如果两个超线程的工作集没有重叠，那么原始的95%也会被打对折——47%，远低于80%。<p> 因此，超线程只在某些情况下才比较有用。单线程代码的缓存命中率必须低到一定程度，从而使缓存容量变小时新的命中率仍能满足要求。只有在这种情况下，超线程才是有意义的。在实践中，采用超线程能否获得更快的结果，取决于处理器能否有效地将每个进程的等待时间与其它进程的执行时间重叠在一起。并行化也需要一定的开销，需要加到总的运行时间里，这个开销往往是不能忽略的。 </p> <p> 在6.3.4节中，我们会介绍一种技术，它将多个线程通过公用缓存紧密地耦合起来。这种技术适用于许多场合，前提是程序员们乐意花费时间和精力扩展自己的代码。 </p>如果两个超线程执行完全不同的代码(两个线程就像被当成两个处理器，分别执行不同进程)，那么缓存容量就真的会降为一半，导致缓冲未命中率大为攀升，这一点应该是很清楚的。这样的调度机制是很有问题的，除非你的缓存足够大。所以，除非程序的工作集设计得比较合理，能够确实从超线程获益，否则还是建议在BIOS中把超线程功能关掉。{我们可能会因为另一个原因 <em>开启</em> <em>超线程，那就是调试，因为SMT在查找并行代码的问题方面真的非常好用。</em>}<h4> 3.3.5 其它细节 </h4> <p> 我们已经介绍了地址的组成，即标签、集合索引和偏移三个部分。那么，实际会用到什么样的地址呢？目前，处理器一般都向进程提供虚拟地址空间，意味着我们有两种不同的地址: 虚拟地址和物理地址。 </p> <p> 虚拟地址有个问题——并不唯一。随着时间的变化，虚拟地址可以变化，指向不同的物理地址。同一个地址在不同的进程里也可以表示不同的物理地址。那么，是不是用物理地址会比较好呢？ </p>问题是，处理器指令用的虚拟地址，而且需要在内存管理单元(MMU)的协助下将它们翻译成物理地址。这并不是一个很小的操作。在执行指令的管线(pipeline)中，物理地址只能在很后面的阶段才能得到。这意味着，缓存逻辑需要在很短的时间里判断地址是否已被缓存过。而如果可以使用虚拟地址，缓存查找操作就可以更早地发生，一旦命中，就可以马上使用内存的内容。结果就是，使用虚拟内存后，可以让管线把更多内存访问的开销隐藏起来。<p> 处理器的设计人员们现在使用虚拟地址来标记第一级缓存。这些缓存很小，很容易被清空。在进程页表树发生变更的情况下，至少是需要清空部分缓存的。如果处理器拥有指定变更地址范围的指令，那么可以避免缓存的完全刷新。由于一级缓存L1i及L1d的时延都很小(~3周期)，基本上必须使用虚拟地址。 </p> <p> 对于更大的缓存，包括L2和L3等，则需要以物理地址作为标签。因为这些缓存的时延比较大，虚拟到物理地址的映射可以在允许的时间里完成，而且由于主存时延的存在，重新填充这些缓存会消耗比较长的时间，刷新的代价比较昂贵。 </p>一般来说，我们并不需要了解这些缓存处理地址的细节。我们不能更改它们，而那些可能影响性能的因素，要么是应该避免的，要么是有很高代价的。填满缓存是不好的行为，缓存线都落入同一个集合，也会让缓存早早地出问题。对于后一个问题，可以通过缓存虚拟地址来避免，但作为一个用户级程序，是不可能避免缓存物理地址的。我们唯一可以做的，是尽最大努力不要在同一个进程里用多个虚拟地址映射同一个物理地址。<p> 另一个细节对程序员们来说比较乏味，那就是缓存的替换策略。大多数缓存会优先逐出最近最少使用(Least Recently Used,LRU)的元素。这往往是一个效果比较好的策略。在关联性很大的情况下(随着以后核心数的增加，关联性势必会变得越来越大)，维护LRU列表变得越来越昂贵，于是我们开始看到其它的一些策略。 </p> <p> 在缓存的替换策略方面，程序员可以做的事情不多。如果缓存使用物理地址作为标签，我们是无法找出虚拟地址与缓存集之间关联的。有可能会出现这样的情形: 所有逻辑页中的缓存线都映射到同一个缓存集，而其它大部分缓存却空闲着。即使有这种情况，也只能依靠OS进行合理安排，避免频繁出现。 </p><p> 虚拟化的出现使得这一切变得更加复杂。现在不仅操作系统可以控制物理内存的分配。虚拟机监视器（VMM，也称为&nbsp;<span>hypervisor</span>）也负责<span>分配</span>内存。 </p> <p> 对程序员来说，最好 a) 完全使用逻辑内存页面&nbsp;b) 在有意义的情况下，使用尽可能大的页面大小来分散物理地址。更大的页面大小也有其他好处，不过这是另一个话题（见第4节）。 </p><h3> 3.4 指令缓存 </h3> <p> 其实，不光处理器使用的数据被缓存，它们执行的指令也是被缓存的。只不过，指令缓存的问题相对来说要少得多，因为: </p> <ul>  <li> <span style="line-height:1.5;font-size:10pt;">执行的代码量取决于代码大小。而代码大小通常取决于问题复杂度。问题复杂度则是固定的。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">程序的数据处理逻辑是程序员设计的，而程序的指令却是编译器生成的。编译器的作者知道如何生成优良的代码。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">程序的流向比数据访问模式更容易预测。现如今的CPU很擅长模式检测，对预取很有利。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">代码永远都有良好的时间局部性和空间局部性。</span> </li> </ul> <p> 有一些准则是需要程序员们遵守的，但大都是关于如何使用工具的，我们会在第6节介绍它们。而在这里我们只介绍一下指令缓存的技术细节。 </p>随着CPU的核心频率大幅上升，缓存与核心的速度差越拉越大，CPU的处理开始管线化。也就是说，指令的执行分成若干阶段。首先，对指令进行解码，随后，准备参数，最后，执行它。这样的管线可以很长(例如，Intel的Netburst架构超过了20个阶段)。在管线很长的情况下，一旦发生延误(即指令流中断)，需要很长时间才能恢复速度。管线延误发生在这样的情况下: 下一条指令未能正确预测，或者装载下一条指令耗时过长(例如，需要从内存读取时)。<p> 为了解决这个问题，CPU的设计人员们在分支预测上投入大量时间和芯片资产(chip real estate)，以降低管线延误的出现频率。 </p> <p> 在CISC处理器上，指令的解码阶段也需要一些时间。x86及x86-64处理器尤为严重。近年来，这些处理器不再将指令的原始字节序列存入L1i，而是缓存解码后的版本。这样的L1i被叫做“追踪缓存(trace cache)”。追踪缓存可以在命中的情况下让处理器跳过管线最初的几个阶段，在管线发生延误时尤其有用。 </p><p> 前面说过，L2以上的缓存是统一缓存，既保存代码，也保存数据。显然，这里保存的代码是原始字节序列，而不是解码后的形式。 </p> <p> 在提高性能方面，与指令缓存相关的只有很少的几条准则: </p> <ol>  <li> <span style="line-height:1.5;font-size:10pt;">生成尽量少的代码。也有一些例外，如出于管线化的目的需要更多的代码，或使用小代码会带来过高的额外开销。</span> </li>  <li> <span style="line-height:1.5;font-size:10pt;">尽量帮助处理器作出良好的预取决策，可以通过代码布局或显式预取来实现。</span> </li> </ol> <p> 这些准则一般会由编译器的代码生成阶段强制执行。至于程序员可以参与的部分，我们会在第6节介绍。 </p><h4> 3.4.1 自修改的代码 </h4> <p> 在计算机的早期岁月里，内存十分昂贵。人们想尽千方百计，只为了尽量压缩程序容量，给数据多留一些空间。其中，有一种方法是修改程序自身，称为自修改代码(SMC)。现在，有时候我们还能看到它，一般是出于提高性能的目的，也有的是为了攻击安全漏洞。 </p> <p> 一般情况下，应该避免SMC。虽然一般情况下没有问题，但有时会由于执行错误而出现性能问题。显然，发生改变的代码是无法放入追踪缓存(追踪缓存放的是解码后的指令)的。即使没有使用追踪缓存(代码还没被执行或有段时间没执行)，处理器也可能会遇到问题。如果某个进入管线的指令发生了变化，处理器只能扔掉目前的成果，重新开始。在某些情况下，甚至需要丢弃处理器的大部分状态。 </p><p> 最后，由于处理器认为代码页是不可修改的(这是出于简单化的考虑，而且在99.9999999%情况下确实是正确的)，L1i用到并不是MESI协议，而是一种简化后的SI协议。这样一来，如果万一检测到修改的情况，就需要作出大量悲观的假设。 </p> <p> 因此，对于SMC，强烈建议能不用就不用。现在内存已经不再是一种那么稀缺的资源了。最好是写多个函数，而不要根据需要把一个函数改来改去。也许有一天可以把SMC变成可选项，我们就能通过这种方式检测入侵代码。如果一定要用SMC，应该让写操作越过缓存，以免由于L1i需要L1d里的数据而产生问题。更多细节，请参见6.1节。 </p><p> 在Linux上，判断程序是否包含SMC是很容易的。利用正常工具链(toolchain)构建的程序代码都是写保护(write-protected)的。程序员需要在链接时施展某些关键的魔术才能生成可写的代码页。现代的Intel x86和x86-64处理器都有统计SMC使用情况的专用计数器。通过这些计数器，我们可以很容易判断程序是否包含SMC，即使它被准许运行。 </p> <h3> 3.5 缓存未命中的因素 </h3> <p> 我们已经看过内存访问没有命中缓存时，那陡然猛涨的高昂代价。但是有时候，这种情况又是无法避免的，因此我们需要对真正的代价有所认识，并学习如何缓解这种局面。 </p> <p> <br> </p><h4> 3.5.1 缓存与内存带宽&nbsp; </h4> <p> 为了更好地理解处理器的能力，我们测量了各种理想环境下能够达到的带宽值。由于<span>不同</span><span>处理器的版本差别很大，所以这个</span>测试比较有趣，也因为如此，这一节都快被测试数据灌满了。我们使用了x86和x86-64处理器的SSE指令来装载和存储数据，每次16字节。工作集则与其它测试一样，从1kB增加到512MB，测量的具体对象是每个周期所处理的字节数。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113719_aUHT.png">  <br>  <strong>图3.24: P4的带宽</strong> </blockquote> <p> <span style="line-height:1.5;font-size:10pt;">图3.24展示了一颗64位Intel Netburst处理器的性能图表。当工作集能够完全放入L1d时，处理器的每个周期可以读取完整的16字节数据，即每个周期执行一条装载指令(moveaps指令，每次移动16字节的数据)。测试程序并不对数据进行任何处理，只是测试读取指令本身。当工作集增大，无法再完全放入L1d时，性能开始急剧下降，跌至每周期6字节。在2<sup>18</sup>工作集处出现的台阶是由于DTLB缓存耗尽，因此需要对每个新页施加额外处理。由于这里的读取是按顺序的，预取机制可以完美地工作，而FSB能以5.3字节/周期的速度传输内容。但预取的数据并不进入L1d。当然，真实世界的程序永远无法达到以上的数字，但我们可以将它们看作一系列实际上的极限值。</span> </p>更令人惊讶的是写操作和复制操作的性能。即使是在很小的工作集下，写操作也始终无法达到4字节/周期的速度。这意味着，Intel为Netburst处理器的L1d选择了写通(write-through)模式，所以写入性能受到L2速度的限制。同时，这也意味着，复制测试的性能不会比写入测试差太多(复制测试是将某块内存的数据拷贝到另一块不重叠的内存区)，因为读操作很快，可以与写操作实现部分重叠。最值得关注的地方是，两个操作在工作集无法完全放入L2后出现了严重的性能滑坡，降到了0.5字节/周期！比读操作慢了10倍！显然，如果要提高程序性能，优化这两个操作更为重要。<p> 再来看图3.25，它来自同一颗处理器，只是运行双线程，每个线程分别运行在处理器的一个超线程上。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113719_kjeK.png">  <br>  <strong>图3.25: P4开启两个超线程时的带宽表现</strong> </blockquote> <p> 图3.25采用了与图3.24相同的刻度，以方便比较两者的差异。图3.25中的曲线抖动更多，是由于采用双线程的缘故。结果正如我们预期，由于超线程共享着几乎所有资源(仅除寄存器外)，所以每个超线程只能得到一半的缓存和带宽。所以，即使每个线程都要花上许多时间等待内存，从而把执行时间让给另一个线程，也是无济于事——因为另一个线程也同样需要等待。这里恰恰展示了使用超线程时可能出现的最坏情况。 </p><blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113720_Rz7T.png">  <br>  <strong>图3.26: Core 2的带宽表现</strong> </blockquote> <p> 再来看Core 2处理器的情况。看看图3.26和图3.27，再对比下P4的<span style="line-height:1.5;font-size:10pt;">图3.24和3.25，可以看出不小的差异。Core 2是一颗双核处理器，有着共享的L2，容量是P4 L2的4倍。但更大的L2只能解释写操作的性能下降出现较晚的现象。</span> </p> <p> <span style="line-height:1.5;font-size:10pt;">当然还有更大的不同。可以看到，读操作的性能在整个工作集范围内一直稳定在16字节/周期左右，在2<sup>20</sup>处的下降同样是由于DTLB的耗尽引起。能够达到这么高的数字，不但表明处理器能够预取数据，并且按时完成传输，而且还意味着，预取的数据是被装入L1d的。</span> </p><p> 写/复制操作的性能与P4相比，也有很大差异。处理器没有采用写通策略，写入的数据留在L1d中，只在必要时才逐出。这使得写操作的速度可以逼近16字节/周期。一旦工作集超过L1d，性能即飞速下降。由于Core 2读操作的性能非常好，所以两者的差值显得特别大。当工作集超过L2时，两者的差值甚至超过20倍！但这并不表示Core 2的性能不好，相反，Core 2永远都比Netburst强。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113720_XDgl.png">  <br>  <strong>图3.27: Core 2运行双线程时的带宽表现</strong> </blockquote> <p> 在图3.27中，启动双线程，各自运行在Core 2的一个核心上。它们访问相同的内存，但不需要完美同步。从结果上看，读操作的性能与单线程并无区别，只是多了一些多线程情况下常见的抖动。 </p>有趣的地方来了——当工作集小于L1d时，写操作与复制操作的性能很差，就好像数据需要从内存读取一样。两个线程彼此竞争着同一个内存位置，于是不得不频频发送RFO消息。问题的根源在于，虽然两个核心共享着L2，但无法以L2的速度处理RFO请求。而当工作集超过L1d后，性能出现了迅猛提升。这是因为，由于L1d容量不足，于是将被修改的条目刷新到共享的L2。由于L1d的未命中可以由L2满足，只有那些尚未刷新的数据才需要RFO，所以出现了这样的现象。这也是这些工作集情况下速度下降一半的原因。这种渐进式的行为也与我们期待的一致:&nbsp;由于每个核心共享着同一条FSB，每个核心只能得到一半的FSB带宽，因此对于较大的工作集来说，每个线程的性能大致相当于单线程时的一半。<p> 由于同一个厂商的不同处理器之间都存在着巨大差异，我们没有理由不去研究一下其它厂商处理器的性能。图3.28展示了AMD家族10h Opteron处理器的性能。这颗处理器有64kB的L1d、512kB的L2和2MB的L3，其中L3缓存由所有核心所共享。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113720_O0pJ.png">  <br>  <strong>图3.28: AMD家族10h Opteron的带宽表现</strong> </blockquote> <p> 大家首先应该会注意到，在L1d缓存足够的情况下，这个处理器每个周期能处理两条指令。读操作的性能超过了32字节/周期，写操作也达到了18.7字节/周期。但是，不久，读操作的曲线就急速下降，跌到2.3字节/周期，非常差。处理器在这个测试中并没有预取数据，或者说，没有有效地预取数据。 </p><p> 另一方面，写操作的曲线随几级缓存的容量而流转。在L1d阶段达到最高性能，随后在L2阶段下降到6字节/周期，在L3阶段进一步下降到2.8字节/周期，最后，在工作集超过L3后，降到0.5字节/周期。它在L1d阶段超过了Core 2，在L2阶段基本相当(Core 2的L2更大一些)，在L3及主存阶段比Core 2慢。 </p> <p> 复制的性能既无法超越读操作的性能，也无法超越写操作的性能。因此，它的曲线先是被读性能压制，随后又被写性能压制。 </p><p> 图3.29显示的是Opteron处理器在多线程时的性能表现。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113720_XTVx.png">  <br>  <strong>图3.29: AMD Fam 10h在双线程时的带宽表现</strong> </blockquote> <p> 读操作的性能没有受到很大的影响。每个线程的L1d和L2表现与单线程下相仿，L3的预取也依然表现不佳。两个线程并没有过渡争抢L3。问题比较大的是写操作的性能。两个线程共享的所有数据都需要经过L3，而这种共享看起来却效率很差。即使是在L3足够容纳整个工作集的情况下，所需要的开销仍然远高于L3的访问时间。再来看图3.27，可以发现，在一定的工作集范围内，Core 2处理器能以共享的L2缓存的速度进行处理。而Opteron处理器只能在很小的一个范围内实现相似的性能，而且，它仅仅只能达到L3的速度，无法与Core 2的L2相比。 </p><p> <b>3.5.2 关键字加载</b> </p> <p> 内存以比缓存线还小的块从主存储器向缓存传送。如今64位可一次性传送，缓存线的大小为64或128比特。这意味着每个缓存线需要8或16次传送。 </p> <p> DRAM芯片可以以触发模式传送这些64位的块。这使得不需要内存控制器的进一步指令和可能伴随的延迟，就可以将缓存线充满。如果处理器预取了缓存，这有可能是最好的操作方式。 </p> <p> <br> </p><p> 如果程序在访问数据或指令缓存时没有命中(这可能是强制性未命中或容量性未命中，前者是由于数据第一次被使用，后者是由于容量限制而将缓存线逐出)，情况就不一样了。程序需要的并不总是缓存线中的第一个字，而数据块的到达是有先后顺序的，即使是在突发模式和双倍传输率下，也会有明显的时间差，一半在4个CPU周期以上。举例来说，如果程序需要缓存线中的第8个字，那么在首字抵达后它还需要额外等待30个周期以上。 </p> <p> 当然，这样的等待并不是必需的。事实上，内存控制器可以按不同顺序去请求缓存线中的字。当处理器告诉它，程序需要缓存中具体某个字，即「关键字(critical word)」时，内存控制器就会先请求这个字。一旦请求的字抵达，虽然缓存线的剩余部分还在传输中，缓存的状态还没有达成一致，但程序已经可以继续运行。这种技术叫做关键字优先及较早重启(Critical Word First &amp; Early Restart)。 </p><p> 现在的处理器都已经实现了这一技术，但有时无法运用。比如，预取操作的时候，并不知道哪个是关键字。如果在预取的中途请求某条缓存线，处理器只能等待，并不能更改请求的顺序。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113720_2RwQ.png">  <br>  <strong>图3.30: 关键字位于缓存线尾时的表现</strong> </blockquote> <p> 在关键字优先技术生效的情况下，关键字的位置也会影响结果。图3.30展示了下一个测试的结果，图中表示的是关键字分别在线首和线尾时的性能对比情况。元素大小为64字节，等于缓存线的长度。图中的噪声比较多，但仍然可以看出，当工作集超过L2后，关键字处于线尾情况下的性能要比线首情况下低0.7%左右。而顺序访问时受到的影响更大一些。这与我们前面提到的预取下条线时可能遇到的问题是相符的。 </p><p> <b>3.5.3 缓存设定</b> </p> <p> 缓存放置的位置与超线程，内核和处理器之间的关系，不在程序员的控制范围之内。但是程序员可以决定线程执行的位置，接着高速缓存与使用的CPU的关系将变得非常重要。 </p> <p> 这里我们将不会深入（探讨）什么时候选择什么样的内核以运行线程的细节。我们仅仅描述了在设置关联线程的时候，程序员需要考虑的<span>系统结构的细节。</span> </p><p> 超线程，通过定义，共享除去寄存器集以外的所有数据。包括 L1 缓存。这里没有什么可以多说的。多核处理器的独立核心带来了一些乐趣。每个核心都至少拥有自己的 L1 缓存。除此之外，下面列出了一些不同的特性： </p> <ul>  <li> 早期多核心处理器有独立的 L2 缓存且没有更高层级的缓存。 </li>  <li> 之后英特尔的双核心处理器模型拥有共享的L2 缓存。对四核处理器，则分对拥有独立的L2 缓存，且没有更高层级的缓存。 </li>  <li> AMD 家族的 10h 处理器有独立的 L2 缓存以及一个统一的L3 缓存。 </li> </ul><p> 关于各种处理器模型的优点，已经在它们各自的宣传手册里写得够多了。在每个核心的工作集互不重叠的情况下，独立的L2拥有一定的优势，单线程的程序可以表现优良。考虑到目前实际环境中仍然存在大量类似的情况，这种方法的表现并不会太差。不过，不管怎样，我们总会遇到工作集重叠的情况。如果每个缓存都保存着某些通用运行库的常用部分，那么很显然是一种浪费。 </p> <p> 如果像Intel的双核处理器那样，共享除L1外的所有缓存，则会有一个很大的优点。如果两个核心的工作集重叠的部分较多，那么综合起来的可用缓存容量会变大，从而允许容纳更大的工作集而不导致性能的下降。如果两者的工作集并不重叠，那么则是由Intel的高级智能缓存管理(Advanced Smart Cache management)发挥功用，防止其中一个核心垄断整个缓存。 </p><p> 即使每个核心只使用一半的缓存，也会有一些摩擦。缓存需要不断衡量每个核心的用量，在进行逐出操作时可能会作出一些比较差的决定。我们来看另一个测试程序的结果。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113720_DTZJ.png">  <br>  <strong>图3.31: 两个进程的带宽表现</strong> </blockquote> <p> 这次，测试程序两个进程，第一个进程不断用SSE指令读/写2MB的内存数据块，选择2MB，是因为它正好是Core 2处理器L2缓存的一半，第二个进程则是读/写大小变化的内存区域，我们把这两个进程分别固定在处理器的两个核心上。图中显示的是每个周期读/写的字节数，共有4条曲线，分别表示不同的读写搭配情况。例如，标记为读/写(read/write)的曲线代表的是后台进程进行写操作(固定2MB工作集)，而被测量进程进行读操作(工作集从小到大)。 </p>图中最有趣的是220到223之间的部分。如果两个核心的L2是完全独立的，那么所有4种情况下的性能下降均应发生在221到222之间，也就是L2缓存耗尽的时候。但从图上来看，实际情况并不是这样，特别是背景进程进行写操作时尤为明显。当工作集达到1MB(220)时，性能即出现恶化，两个进程并没有共享内存，因此并不会产生RFO消息。所以，完全是缓存逐出操作引起的问题。目前这种智能的缓存处理机制有一个问题，每个核心能实际用到的缓存更接近1MB，而不是理论上的2MB。如果未来的处理器仍然保留这种多核共享缓存模式的话，我们唯有希望厂商会把这个问题解决掉。<p> 推出拥有双L2缓存的4核处理器仅仅只是一种临时措施，是开发更高级缓存之前的替代方案。与独立插槽及双核处理器相比，这种设计并没有带来多少性能提升。两个核心是通过同一条总线(被外界看作FSB)进行通信，并没有什么特别快的数据交换通道。 </p> <p> 未来，针对多核处理器的缓存将会包含更多层次。AMD的10h家族是一个开始，至于会不会有更低级共享缓存的出现，还需要我们拭目以待。我们有必要引入更多级别的缓存，因为频繁使用的高速缓存不可能被许多核心共用，否则会对性能造成很大的影响。我们也需要更大的高关联性缓存，它们的数量、容量和关联性都应该随着共享核心数的增长而增长。巨大的L3和适度的L2应该是一种比较合理的选择。L3虽然速度较慢，但也较少使用。 </p> <p> 对于程序员来说，不同的缓存设计就意味着调度决策时的复杂性。为了达到最高的性能，我们必须掌握工作负载的情况，必须了解机器架构的细节。好在我们在判断机器架构时还是有一些支援力量的，我们会在后面的章节介绍这些接口。 </p><h4> 3.5.4 FSB的影响 </h4> <p> FSB在性能中扮演了核心角色。缓存数据的存取速度受制于内存通道的速度。我们做一个测试，在两台机器上分别跑同一个程序，这两台机器除了内存模块的速度有所差异，其它完全相同。图3.32展示了Addnext0测试(将下一个元素的pad[0]加到当前元素的pad[0]上)在这两台机器上的结果(NPAD=7，64位机器)。两台机器都采用Core 2处理器，一台使用667MHz的DDR2内存，另一台使用800MHz的DDR2内存(比前一台增长20%)。 </p> <blockquote>  <img src="http://static.oschina.net/uploads/img/201302/27113721_Do9s.png">  <br>  <strong>图3.32: FSB速度的影响</strong> </blockquote> <p> 图上的数字表明，当工作集大到对FSB造成压力的程度时，高速FSB确实会带来巨大的优势。在我们的测试中，性能的提升达到了18.5%，接近理论上的极限。而当工作集比较小，可以完全纳入缓存时，FSB的作用并不大。当然，这里我们只测试了一个程序的情况，在实际环境中，系统往往运行多个进程，工作集是很容易超过缓存容量的。 </p>如今，一些英特尔的处理器，支持前端总线(FSB)的速度高达1,333 MHz，这意味着速度有另外60％的提升。将来还会出现更高的速度。速度是很重要的，工作集会更大，快速的RAM和高FSB速度的内存肯定是值得投资的。我们必须小心使用它，因为即使处理器可以支持更高的前端总线速度，但是主板的北桥芯片可能不会。使用时，检查它的规范是至关重要的。]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在的CPU比25年前要精密得多了。在那个年代，CPU的频率与内存总线的频率基本在同一层面上。内存的访问速度仅比寄存器慢那么一点点。但是，这一局面在上世纪90年代被打破了。CPU的频率大大提升，但内存总线的频率与内存芯片的性能却没有得到成比例的提升。并不是因为造不出更快的内
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/c-globle-variable/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/c-globle-variable/</id>
    <published>2019-06-14T02:52:59.701Z</published>
    <updated>2019-06-14T02:52:59.701Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名程序员，如果说沉迷一门编程语言算作一种乐趣的话，那么与此同时反过来去黑一门编程语言就是这种乐趣的升华。今天我们就来黑一把C语言，好好展示一下这门经典语言令人抓狂的一面。</p><p>我们知道，全局变量是C语言语法和语义中一个很重要的知识点，首先它的存在意义需要从三个不同角度去理解：对于程序员来说，它是一个记录内容的<strong>变量(variable)</strong>；对于编译/链接器来说，它是一个需要解析的<strong>符号(symbol)</strong>；对于计算机来说，它可能是具有地址的一块<strong>内存(memory)</strong>。其次是语法/语义：从作用域上看，带static关键字的全局变量范围只能限定在文件里，否则会外联到整个模块和项目中；从生存期来看，它是静态的，贯穿整个程序或模块运行期间（<span style="color: #ff0000;"><strong>注意，正是跨单元访问和持续生存周期这两个特点使得全局变量往往成为一段受攻击代码的突破口，了解这一点十分重要</strong></span>）；从空间分配上看，定义且初始化的全局变量在编译时在数据段(.data)分配空间，定义但未初始化的全局变量<strong>暂存(tentative definition)</strong>在.bss段，编译时自动清零，而仅仅是声明的全局变量只能算个符号，寄存在编译器的符号表内，不会分配空间，直到链接或者运行时再重定向到相应的地址上。</p><p>我们将向您展现一下，<strong>非static限定全局变量</strong>在编译/链接以及程序运行时会发生哪些有趣的事情，顺便可以对C编译器/链接器的解析原理管中窥豹。以下示例对ANSI C和GNU C标准都有效，笔者的编译环境是Ubuntu下的GCC-4.4.3。</p><p><span id="more-10115"></span></p><h4>第一个例子</h4><pre class="brush: cpp; title: ; notranslate" title>/* t.h */#ifndef _H_#define _H_int a;#endif<p>/* foo.c */</p><p>#include &lt;stdio.h&gt;</p><p>#include &quot;t.h&quot;</p><p>struct {<br>   char a;<br>   int b;<br>} b = { 2, 4 };</p><p>int main();</p><p>void foo()<br>{    printf(&quot;foo:\t(&amp;a)=0x%08x\n\t(&amp;b)=0x%08x\n<br>        \tsizeof(b)=%d\n\tb.a=%d\n\tb.b=%d\n\tmain:0x%08x\n&quot;,<br>        &amp;a, &amp;b, sizeof b, b.a, b.b, main);<br>}</p><p>/* main.c */</p><p>#include &lt;stdio.h&gt;</p><p>#include &quot;t.h&quot;</p><p>int b;<br>int c;</p><p>int main()<br>{    foo();<br>    printf(&quot;main:\t(&amp;a)=0x%08x\n\t(&amp;b)=0x%08x\n<br>        \t(&amp;c)=0x%08x\n\tsize(b)=%d\n\tb=%d\n\tc=%d\n&quot;,<br>        &amp;a, &amp;b, &amp;c, sizeof b, b, c);<br>    return 0;<br>}</p></pre><p></p><p>Makefile如下：</p><pre class="brush: bash; title: ; notranslate" title>test: main.o foo.o    gcc -o test main.o foo.o<p>main.o: main.c<br>foo.o: foo.c</p><p>clean:<br>    rm *.o test<br></p></pre><p></p><p>运行情况：</p><pre class="brush: bash; title: ; notranslate" title>foo:    (&amp;a)=0x0804a024    (&amp;b)=0x0804a014    sizeof(b)=8    b.a=2    b.b=4    main:0x080483e4main:    (&amp;a)=0x0804a024    (&amp;b)=0x0804a014    (&amp;c)=0x0804a028    size(b)=4    b=2    c=0</pre><p>这个项目里我们定义了四个全局变量，t.h头文件定义了一个整型a，main.c里定义了两个整型b和c并且未初始化，foo.c里定义了一个初始化了的结构体，还定义了一个main的函数指针变量。由于C语言每个源文件单独编译，所以t.h分别包含了两次，所以int a就被定义了两次。两个源文件里变量b和函数指针变量main被重复定义了，实际上可以看做代码段的地址。但编译器并未报错，只给出一条警告：</p><pre class="brush: bash; title: ; notranslate" title>/usr/bin/ld: Warning: size of symbol 'b' changed from 4 in main.o to 8 in foo.o</pre><p>运行程序发现，main.c打印中b大小是4个字节，而foo.c是8个字节，因为sizeof关键字是编译时决议，而源文件中对b类型定义不一样。但令人惊奇的是无论是在main.c还是foo.c中，a和b都是相同的地址，也就是说，a和b被定义了两次，b还是不同类型，但内存映像中只有一份拷贝。我们还看到，main.c中b的值居然就是foo.c中结构体第一个成员变量b.a的值，这证实了前面的推断——<strong>即便存在多次定义，内存中只有一份初始化的拷贝。</strong>另外在这里c是置身事外的一个独立变量。</p><p>为何会这样呢？这涉及到<strong>C编译器对多重定义的全局符号的解析和链接。</strong>在编译阶段，编译器将全局符号信息隐含地编码在可重定位目标文件的符号表里。这里有个<strong>“强符号(strong)”</strong>和<strong>“弱符号(weak)”</strong>的概念——前者指的是定义并且初始化了的变量，比如foo.c里的结构体b，后者指的是未定义或者定义但未初始化的变量，比如main.c里的整型b和c，还有两个源文件都包含头文件里的a。当符号被多重定义时，GNU链接器(ld)使用以下规则决议：</p><ul><li>不允许出现多个相同强符号。</li></ul><ul><li>如果有一个强符号和多个弱符号，则选择强符号。</li></ul><ul><li>如果有多个弱符号，那么先决议到size最大的那个，如果同样大小，则按照链接顺序选择第一个。</li></ul><p>像上面这个例子中，全局变量a和b存在重复定义。如果我们将main.c中的b初始化赋值，那么就存在两个强符号而违反了规则一，编译器报错。如果满足规则二，则仅仅提出警告，实际运行时决议的是foo.c中的强符号。而变量a都是弱符号，所以只选择一个（按照目标文件链接时的顺序）。</p><p>事实上，这种规则是C语言里的一个大坑，编译器对这种全局变量多重定义的“纵容”很可能会无端修改某个变量，导致程序不确定行为。如果你还没有意识到事态严重性，我再举个例子。</p><h4>第二个例子</h4><pre class="brush: cpp; title: ; notranslate" title>/* foo.c */#include &lt;stdio.h&gt;;<p>struct {<br>    int a;<br>    int b;<br>} b = { 2, 4 };</p><p>int main();</p><p>void foo()<br>{    printf(&quot;foo:\t(&amp;b)=0x%08x\n\tsizeof(b)=%d\n<br>        \tb.a=%d\n\tb.b=%d\n\tmain:0x%08x\n&quot;,<br>        &amp;b, sizeof b, b.a, b.b, main);<br>}</p><p>/* main.c */</p><p>#include &lt;stdio.h&gt;</p><p>int b;<br>int c;</p><p>int main()<br>{    if (0 == fork()) {<br>        sleep(1);<br>        b = 1;<br>        printf(&quot;child:\tsleep(1)\n\t(&amp;b):0x%08x\n<br>            \t(&amp;c)=0x%08x\n\tsizeof(b)=%d\n\tset b=%d\n\tc=%d\n&quot;,<br>            &amp;b, &amp;c, sizeof b, b, c);<br>        foo();<br>    } else {<br>        foo();<br>        printf(&quot;parent:\t(&amp;b)=0x%08x\n\t(&amp;c)=0x%08x\n<br>            \tsizeof(b)=%d\n\tb=%d\n\tc=%d\n\twait child…\n&quot;,<br>            &amp;b, &amp;c, sizeof b, b, c);<br>        wait(-1);<br>        printf(&quot;parent:\tchild over\n\t(&amp;b)=0x%08x\n<br>            \t(&amp;c)=0x%08x\n\tsizeof(b)=%d\n\tb=%d\n\tc=%d\n&quot;,<br>            &amp;b, &amp;c, sizeof b, b, c);<br>    }<br>    return 0;<br>}</p></pre><p></p><p>运行情况如下：</p><pre class="brush: bash; title: ; notranslate" title>foo:    (&amp;b)=0x0804a020    sizeof(b)=8    b.a=2    b.b=4    main:0x080484c8parent:    (&amp;b)=0x0804a020    (&amp;c)=0x0804a034    sizeof(b)=4    b=2    c=0    wait child...child:    sleep(1)    (&amp;b):0x0804a020    (&amp;c)=0x0804a034    sizeof(b)=4    set b=1    c=0foo:    (&amp;b)=0x0804a020    sizeof(b)=8    b.a=1    b.b=4    main:0x080484c8parent:    child over    (&amp;b)=0x0804a020    (&amp;c)=0x0804a034    sizeof(b)=4    b=2    c=0</pre><p>（说明一点，运行情况是直接输出到stdout的打印，笔者曾经将./test输出重定向到log中，结果发现打印的执行序列不一致，所以采用默认输出。）</p><p>这是一个<strong>多进程环境</strong>，首先我们看到无论父进程还是子进程，main.c还是foo.c，全局变量b和c的地址仍然是一致的（当然只是个<strong>逻辑地址</strong>），而且对b的大小不同模块仍然有不同的决议。这里值得注意的是，我们在子进程中对变量b进行赋值动作，从此子进程本身包括foo()调用中，整型b以及结构体成员b.a的值都是1，而父进程中整型b和结构体成员b.a的值仍是2，但它们显示的逻辑地址仍是一致的。</p><p>个人认为可以这样解释，fork创建新进程时，子进程获得了父进程上下文“镜像”（自然包括全局变量），虚拟地址相同但属于不同的进程空间，而且此时真正映射的物理地址中只有一份拷贝，所以b的值是相同的（都是2）。随后子进程对b改写，触发了操作系统的<strong>写时拷贝(copy on write)</strong>机制，这时物理内存中才产生真正的两份拷贝，分别映射到不同进程空间的虚拟地址上，但虚拟地址的值本身仍然不变，这对于应用程序来说是透明的，具有隐瞒性。</p><p>还有一点值得注意，这个示例编译时没有出现第一个示例的警告，即对变量b的sizeof决议，笔者也不知道为什么，或许是GCC的一个bug？</p><h4>第三个例子</h4><p>这个例子代码同上一个一致，只不过我们将foo.c做成一个静态链接库libfoo.a进行链接，这里只给出Makefile的改动。</p><pre class="brush: bash; title: ; notranslate" title>test: main.o foo.o    ar rcs libfoo.a foo.o    gcc -static -o test main.o libfoo.a<p>main.o: main.c<br>foo.o: foo.c</p><p>clean:<br>    rm -f *.o test<br></p></pre><p></p><p>运行情况如下：</p><pre class="brush: bash; title: ; notranslate" title>foo:    (&amp;b)=0x080ca008    sizeof(b)=8    b.a=2    b.b=4    main:0x08048250parent:    (&amp;b)=0x080ca008    (&amp;c)=0x080cc084    sizeof(b)=4    b=2    c=0    wait child...child:    sleep(1)    (&amp;b):0x080ca008    (&amp;c)=0x080cc084    sizeof(b)=4    set b=1    c=0foo:    (&amp;b)=0x080ca008    sizeof(b)=8    b.a=1    b.b=4    main:0x08048250parent:    child over    (&amp;b)=0x080ca008    (&amp;c)=0x080cc084    sizeof(b)=4    b=2    c=0</pre><p>从这个例子看不出有啥差别，只不过使用<strong>静态链接</strong>后，全局变量加载的地址有所改变，b和c的地址之间似乎相隔更远了些。不过这次编译器倒是给出了变量b的sizeof决议警告。</p><p>到此为止，有些人可能会对上面的例子嗤之以鼻，觉得这不过是列举了C语言的某些特性而已，算不上黑。有些人认为既然如此，对于一切全局变量要么用static限死，要么定义同时初始化，杜绝弱符号，以便在编译时报错检测出来。只要小心地使用，C语言还是很完美的嘛~对于抱这样想法的人，我只想说，请你在夜深人静的时候竖起耳朵仔细聆听，你很可能听到Dennis Richie在九泉之下邪恶的笑声——不，与其说是嘲笑，不如说是诅咒……</p><h4>第四个例子</h4><pre class="brush: cpp; title: ; notranslate" title>/* foo.c */#include &lt;stdio.h&gt;<p>const struct {<br>    int a;<br>    int b;<br>} b = { 3, 3 };</p><p>int main();</p><p>void foo()<br>{    b.a = 4;<br>    b.b = 4;<br>    printf(&quot;foo:\t(&amp;b)=0x%08x\n\tsizeof(b)=%d\n<br>        \tb.a=%d\n\tb.b=%d\n\tmain:0x%08x\n&quot;,<br>        &amp;b, sizeof b, b.a, b.b, main);<br>}</p><p>/* t1.c */</p><p>#include &lt;stdio.h&gt;</p><p>int b = 1;<br>int c = 1;</p><p>int main()<br>{    int count = 5;<br>    while (count– &gt; 0) {<br>        t2();<br>        foo();<br>        printf(&quot;t1:\t(&amp;b)=0x%08x\n\t(&amp;c)=0x%08x\n<br>            \tsizeof(b)=%d\n\tb=%d\n\tc=%d\n&quot;,<br>            &amp;b, &amp;c, sizeof b, b, c);<br>        sleep(1);<br>    }<br>    return 0;<br>}</p><p>/* t2.c */</p><p>#include &lt;stdio.h&gt;</p><p>int b;<br>int c;</p><p>int t2()<br>{    printf(&quot;t2:\t(&amp;b)=0x%08x\n\t(&amp;c)=0x%08x\n<br>        \tsizeof(b)=%d\n\tb=%d\n\tc=%d\n&quot;,<br>        &amp;b, &amp;c, sizeof b, b, c);<br>    return 0;<br>}</p></pre><p></p><p>Makefile脚本：</p><pre class="brush: bash; title: ; notranslate" title>export LD_LIBRARY_PATH:=.<p>all: test<br>    ./test</p><p>test: t1.o t2.o<br>    gcc -shared -fPIC -o libfoo.so foo.c<br>    gcc -o test t1.o t2.o -L. -lfoo</p><p>t1.o: t1.c<br>t2.o: t2.c</p><p>.PHONY:clean<br>clean:<br>    rm -f <em>.o *.so test</em><br></p></pre><p></p><p>执行结果：</p><pre class="brush: bash; title: ; notranslate" title>./testt2:    (&amp;b)=0x0804a01c    (&amp;c)=0x0804a020    sizeof(b)=4    b=1    c=1foo:    (&amp;b)=0x0804a01c    sizeof(b)=8    b.a=4    b.b=4    main:0x08048564t1:    (&amp;b)=0x0804a01c    (&amp;c)=0x0804a020    sizeof(b)=4    b=4    c=4t2:    (&amp;b)=0x0804a01c    (&amp;c)=0x0804a020    sizeof(b)=4    b=4    c=4foo:    (&amp;b)=0x0804a01c    sizeof(b)=8    b.a=4    b.b=4    main:0x08048564t1:    (&amp;b)=0x0804a01c    (&amp;c)=0x0804a020    sizeof(b)=4    b=4    c=4    ...</pre><p>其实前面几个例子只是开胃小菜而已，真正的大坑终于出现了！而且这次编译器既没报错也没警告，但我们确实眼睁睁地看到作为main()中强符号的b被改写了，而且一旁的c也“躺枪”了。眼尖的读者发现，这次foo.c是作为动态链接库运行时加载的，当t1第一次调用t2时，libfoo.so还未加载，一旦调用了foo函数，b立马中弹，而且<strong>c的地址居然还相邻着b，这使得c一同中弹了。</strong>不过笔者有些无法解释这种行为的原因，有种说法是强符号的全局变量在数据段中是连续分布的（相应地弱符号暂存在.bss段或者符号表里），或许可以上报GNU的编译器开发小组。</p><p>另外笔者尝试过将t1.c中的b和c定义前面加上<strong>const限定词</strong>，编译器仍然默认通过，但程序在main()中第一次调用foo()时触发了Segment fault异常导致奔溃，在foo.c里使用指针改写它也一样。<strong>推断这是GCC对const常量所在地址启用了类似操作系统写保护机制，但我无法确定早期版本的GCC是否会让这个const常量被改写而程序不会奔溃。</strong></p><p>至于<strong>volatile关键词</strong>之于全局变量，自测似乎没有影响。</p><p>怎么样？看了最后一个例子是否有点“不明觉厉”呢？C语言在你心目中是否还是当初那个“纯洁”、“干净”、“行为一致”的姑娘呢？也许趁着你不注意的时候她会偷偷给你戴顶绿帽，这一切都是通过全局变量，特别在动态链接的环境下，就算全部定义成强符号仍然无法为编译器所察觉。而一些IT界“恐怖分子”也经常<strong>将恶意代码包装成全局变量注入到root权限下存在漏洞的操作序列中，</strong>就像著名的栈溢出攻击那样。某一天当你傻傻地看着一个程序出现未定义的行为却无法定位原因的时候，请不要忘记Richie大爷那来自九泉之下最深沉的“问候”~</p><p>或许有些人会偷换概念，把这一切归咎于编译器和链接器身上，认为这同语言无关，但我要提醒你，正是编译/链接器的行为支撑了整个语言的语法和语义。你可以反过来思考一下为何C的胞弟C++推出<strong>“命名空间(namespace)”</strong>的概念，或者你可以使用其它高级语言，对于重定义的全局变量是否能通过编译这一关。</p><p>所以请时刻谨记，<span style="color: #ff0000;"><strong>C是一门很恐怖的语言！</strong></span></p><p>P.S.题外话写在最后。我无意挑起语言之争，只是就事论事地去<strong>“黑(hack)</strong><strong>”</strong>一门语言而已，而且要黑就要黑得有理有力有层次，还要带点娱乐精神。其实黑一门语言并非什么尖端复杂的技术，个人觉得起码要做到两点：</p><ul><li><strong>亲自动手写测试程序。</strong>动手写测试程序是开发人员必备的基础技能，只有现成的代码才能让人心服口服，那些只会停留在口头上的争论只能算作cheap hack。</li></ul><ul><li><strong>测试程序不能依赖于不成熟的代码。</strong>软件开发99%以上的bug都是基于不合格(substandard)开发人员导致，这并不能怪罪于语言以及编译器本身。使用诸如#define TRUE FALSE或者#define NULL 1之类的trick来黑C语言只能证明此人很有娱乐精神而不是真正的&#8221;hack value&#8221;，拿老北京梨园行当里的一句话——“那是下三滥的玩意儿”。</li></ul><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名程序员，如果说沉迷一门编程语言算作一种乐趣的话，那么与此同时反过来去黑一门编程语言就是这种乐趣的升华。今天我们就来黑一把C语言，好好展示一下这门经典语言令人抓狂的一面。&lt;/p&gt;
&lt;p&gt;我们知道，全局变量是C语言语法和语义中一个很重要的知识点，首先它的存在意义需要从三
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/android-memory-prof2/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/android-memory-prof2/</id>
    <published>2019-06-14T02:52:59.701Z</published>
    <updated>2019-06-14T02:52:59.701Z</updated>
    
    <content type="html"><![CDATA[<div><p style="color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold; line-height:26px"><strong><span style="font-family:'Microsoft YaHei'; font-size:24px; color:rgb(204,0,0)">OOM：</span></strong></p><p style="color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold; line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)"><strong><br></strong></span></p><p style="color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold; line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)"><strong>内存泄露可以引发很多的问题：</strong></span></p><p>1.程序卡顿，响应速度慢（内存占用高时JVM虚拟机会频繁触发GC）</p><p>2.莫名消失（当你的程序所占内存越大，它在后台的时候就越可能被干掉。反之内存占用越小，在后台存在的时间就越长）</p><p>3.直接崩溃（OutOfMemoryError）</p><p style="color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold; line-height:26px; margin-top:0px; margin-bottom:8px; padding-top:0px; padding-bottom:0px; border-width:0px; list-style:none"><br></p><p style="color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold; line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)"><strong>ANDROID内存面临的问题：</strong></span></p><p style="color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold; line-height:26px"></p><p>1.有限的堆内存，原始只有16M</p><p>2.内存大小消耗等根据设备，操作系统等级，屏幕尺寸的不同而不同</p><p>3.程序不能直接控制</p><p>4.支持后台多任务处理（multitasking）</p><p>5.运行在虚拟机之上</p></div><div style="color:rgb(102,51,51); font-family:SimSun; font-size:14px; font-weight:bold; line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:18px"><br></span></div><p><span style="font-family:'Microsoft YaHei'; font-size:24px; color:rgb(204,0,0)"><strong>5R：</strong></span></p><p><span style="font-family:'Microsoft YaHei'; font-size:14px">本文主要通过如下的5R方法来对ANDROID内存进行优化：</span></p><p><span style="font-family:'Microsoft YaHei'; font-size:14px"><br></span></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">1.Reckon（计算）</span></strong></p><p><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>首先需要知道你的app所消耗内存的情况，知己知彼才能百战不殆</span></span></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">2.Reduce（减少）</span></strong></p><p><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>消耗更少的资源</span></span></p><p><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"></span></span></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">3.Reuse（重用）</span></strong></p><p><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>当第一次使用完以后，尽量给其他的使用</span></span></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">5.Recycle（回收）</span></strong></p><p><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>回收资源</span></span></p><p><strong><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(204,102,0)">4.Review（检查）</span><br></span></strong></p><p><span style="white-space:pre"><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'">回顾检查你的程序，看看设计或代码有什么不合理的地方。</span></span></span></p><div class="column"><br></div><br><p style="text-align:center"><strong><span style="color:rgb(204,0,0)"><span style="font-size:32px">Reckon：</span></span></strong></p><p style="text-align:left"><span style="font-size:18px"><br></span></p><p style="text-align:left"><span style="font-size:18px">关于内存简介，和Reckon（内存计算）的内容请看上一篇文章：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MC9hcnRpY2xlL2RldGFpbHMvMzc5MTQ0NjU=" title="http://blog.csdn.net/a396901990/article/details/37914465">ANDROID内存优化(大汇总——上)<i class="fa fa-external-link"></i></span></span></p><p style="text-align:center"><strong><span style="font-size:32px; color:#cc0000"><br></span></strong></p><p style="text-align:center"><strong><span style="font-size:32px; color:#cc0000"><br></span></strong></p><p style="text-align:center"><strong><span style="font-size:32px; color:#cc0000">Reduce ：</span></strong></p><p><span style="font-size:18px"><br></span></p><p><span style="font-size:18px">Reduce的意思就是减少，直接减少内存的使用是最有效的优化方式。</span></p><p><span style="font-size:18px">下面来看看有哪些方法可以减少内存使用：</span></p><p><br></p><p></p><div class="column"><span style="font-family:'Microsoft YaHei'; font-size:24px; color:rgb(153,102,51)"><strong>Bitmap</strong></span><span style="color:rgb(153,102,51); font-family:'Microsoft YaHei'; font-size:24px"><strong>：</strong></span></div><div class="column"><span style="font-size:18px">Bitmap是内存消耗大户，绝大多数的OOM崩溃都是在操作Bitmap时产生的，下面来看看几个处理图片的方法：</span></div><div class="column"><p><br></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px">图片显示：</span></strong></p><p>我们需要根据需求去加载图片的大小。</p><p>例如在列表中仅用于预览时加载缩略图（thumbnails&nbsp;）。</p><p>只有当用户点击具体条目想看详细信息的时候，这时另启动一个fragment／activity／对话框等等，去显示整个图片</p><p></p><p><br></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px">图片大小：</span></strong></p><div class="page" title="Page 19"><div class="layoutArea"><div class="column"><p>直接使用ImageView显示bitmap会占用较多资源，特别是图片较大的时候，可能导致崩溃。&nbsp;<br>使用<strong>BitmapFactory.Options</strong>设置inSampleSize, 这样做可以减少对系统资源的要求。&nbsp;<br>属性&#20540;inSampleSize表示缩略图大小为原始图片大小的几分之一，即如果这个&#20540;为2，则取出的缩略图的宽和高都是原始图片的1/2，图片大小就为原始大小的1/4。&nbsp;<br></p><p></p><pre name="code" class="java">        BitmapFactory.Options bitmapFactoryOptions = new BitmapFactory.Options();        bitmapFactoryOptions.inJustDecodeBounds = true;        bitmapFactoryOptions.inSampleSize = 2;        // 这里一定要将其设置回false，因为之前我们将其设置成了true          // 设置inJustDecodeBounds为true后，decodeFile并不分配空间，即，BitmapFactory解码出来的Bitmap为Null,但可计算出原始图片的长度和宽度          options.inJustDecodeBounds = false;        Bitmap bmp = BitmapFactory.decodeFile(sourceBitmap, options);</pre><p></p><p><br></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px">图片像素：</span></strong></p><div class="page" title="Page 20"><div class="layoutArea"><div class="column"><span style="font-size:14px">Android中图片有四种属性，分别是：</span><br><strong>ALPHA_8：</strong>每个像素占用1byte内存&nbsp;<br><strong>ARGB_4444：</strong>每个像素占用2byte内存&nbsp;<br><strong>ARGB_8888：</strong>每个像素占用4byte内存 （默认）<br><strong>RGB_565：</strong>每个像素占用2byte内存&nbsp;</div><div class="column"><br></div><div class="column">Android默认的颜色模式为ARGB_8888，这个颜色模式色彩最细腻，显示质量最高。但同样的，占用的内存也最大。 所以在对图片效果不是特别高的情况下使用RGB_565（565没有透明度属性），如下：</div><div class="column"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif"><span style="font-size:14px; line-height:25.200000762939453px"><span style="background-color:rgb(247,252,255)"></span></span></span><pre name="code" class="java">        publicstaticBitmapreadBitMap(Contextcontext, intresId) {            BitmapFactory.Optionsopt = newBitmapFactory.Options();            opt.inPreferredConfig = Bitmap.Config.RGB_565;            opt.inPurgeable = true;            opt.inInputShareable = true;            //获取资源图片             InputStreamis = context.getResources().openRawResource(resId);            returnBitmapFactory.decodeStream(is, null, opt);        }</pre></div><div class="column"><div class="page" title="Page 20"><div class="layoutArea"><div class="column"><br><p><span style="line-height:25.200000762939453px"><strong><span style="font-family:'Microsoft YaHei'; font-size:18px">图片回收：</span></strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">使用Bitmap过后，就需要及时的调用<strong>Bitmap.recycle()</strong>方法来释放Bitmap占用的内存空间，而不要等Android系统来进行释放。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">下面是释放Bitmap的示例代码片段。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><pre name="code" class="java" style="font-family: Arial; font-size: 14px; line-height: 26px;">        // 先判断是否已经回收        if(bitmap != null &amp;&amp; !bitmap.isRecycled()){            // 回收并且置为null            bitmap.recycle();            bitmap = null;        }        System.gc();</pre><br></div><div class="column"><p><span style="line-height:26px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">捕获异常：</span></strong></span><br></p><p>经过上面这些优化后还会存在报OOM的风险，所以下面需要一道最后的关卡——捕获OOM异常：</p><p></p><pre name="code" class="java">        Bitmap bitmap = null;        try {            // 实例化Bitmap            bitmap = BitmapFactory.decodeFile(path);        } catch (OutOfMemoryError e) {            // 捕获OutOfMemoryError，避免直接崩溃        }        if (bitmap == null) {            // 如果实例化失败 返回默认的Bitmap对象            return defaultBitmapMap;        }</pre><div><br></div><br></div></div></div></div></div></div></div></div></div></div><br><p></p><p><span style="font-family:'Microsoft YaHei'; font-size:24px; color:rgb(153,102,51)"><strong>修改对象引用类型：</strong></span></p><p><br></p><p><strong><span style="font-family:Microsoft YaHei; font-size:18px">引用类型：</span></strong></p><p><span style="font-family:Arial; font-size:14px; line-height:26px">引用分为四种级别，这四种级别由高到低依次为：强引用&gt;软引用&gt;弱引用&gt;虚引用。</span><br></p><p><strong>强引用（strong reference）</strong><br>如：Object object=new Object（），object就是一个强引用了。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。<br></p><p><strong>软引用（SoftReference）</strong><br>只有内存不够时才回收,常用于缓存；当内存达到一个阀&#20540;，GC就会去回收它；<br></p><p></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>弱引用（WeakReference）&nbsp;&nbsp;&nbsp;</strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。&nbsp;</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>虚引用（PhantomReference）</strong>&nbsp;&nbsp;&nbsp;</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 &nbsp;</p><p><br></p><p><strong><span style="font-family:Microsoft YaHei; font-size:18px">软引用和弱引用的应用实例：</span></strong><br></p><p><span style="font-size:14px; color:#ff6666"><span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">注意</span></span>：对于<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">SoftReference</span></span>(<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">软引用</span></span>)或者<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">WeakReference</span></span>(<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">弱引用</span></span>)的Bitmap缓存方案，现在已经不推荐使用了。自<span style="padding:0px; margin:0px">Android2.3</span>版本(<span style="padding:0px; margin:0px">API Level 9</span>)开始，垃圾回收器更着重于对软/弱引用的回收，</span><span style="color:rgb(255,102,102); font-size:14px">所以下面的内容可以选择忽略。</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">下面以使用软引用为例来详细说明（弱引用的使用方式与软引用是类&#20284;的）：</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">假设我们的应用会用到大量的默认图片，而且这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软引用技术来避免这个问题发生。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">首先定义一个HashMap，保存软引用对象。<br></p><pre name="code" class="java">private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</pre>再来定义一个方法，保存Bitmap的软引用到HashMap。<br><p><span style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px"></span></span></p><pre name="code" class="java"> public void addBitmapToCache(String path) {        // 强引用的Bitmap对象        Bitmap bitmap = BitmapFactory.decodeFile(path);        // 软引用的Bitmap对象        SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap);        // 添加该对象到Map中使其缓存        imageCache.put(path, softBitmap);    }</pre>获取的时候，可以通过SoftReference的get()方法得到Bitmap对象。<pre name="code" class="java" style="font-size: 14px; line-height: 25.200000762939453px;">public Bitmap getBitmapByPath(String path) {        // 从缓存中取软引用的Bitmap对象        SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);        // 判断是否存在软引用        if (softBitmap == null) {            return null;        }        // 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空        Bitmap bitmap = softBitmap.get();        return bitmap;    }</pre>使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。<p>需要注意的是，在垃圾回收器对这个Java对象回收前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该Java对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px"><span style="font-family:Microsoft YaHei; font-size:18px"><strong>到底什么时候使用软引用，什么时候使用弱引用呢？</strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">个人认为，如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">还有就是可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">另外，和弱引用功能类&#20284;的是WeakHashMap。WeakHashMap对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的回收，回收以后，其条目从映射中有效地移除。WeakHashMap使用ReferenceQueue实现的这种机制。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px"><strong><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633">其他小tips：</span></strong></p><div class="column"><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"></p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">对常量使用static final修饰符</span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">让我们来看看这两段在类前面的声明：</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px"><strong>static </strong>int intVal = 42;<br><strong>static </strong>String strVal = &quot;Hello, world!&quot;;<br>编译器会生成一个叫做clinit的初始化类的方法，当类第一次被使用的时候这个方法会被执行。方法会将42赋给intVal，然后把一个指向类中常量表 的引用赋给strVal。当以后要用到这些&#20540;的时候，会在成员变量表中查找到他们。 下面我们做些改进，使用“final”关键字：</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px"><strong>static final </strong>int intVal = 42;<br><strong>static final </strong>String strVal = &quot;Hello, world!&quot;;</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">现在，类不再需要clinit方法，因为在成员变量初始化的时候，会将常量直接保存到类文件中。用到intVal的代码被直接替换成42，而使用strVal的会指向一个字符串常量，而不是使用成员变量。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">将一个方法或类声明为final不会带来性能的提升，但是会帮助编译器优化代码。举例说，如果编译器知道一个getter方法不会被重载，那么编译器会对其采用内联调用。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px">你也可以将本地变量声明为final，同样，这也不会带来性能的提升。使用“final”只能使本地变量看起来更清晰些（但是也有些时候这是必须的，比如在使用匿名内部类的时候）。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:5px; padding-bottom:5px"></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">静态方法代替虚拟方法</span></strong></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。这也是一种好的做法，因为你可以从方法声明中看出调用该方法不需要更新此对象的状态。</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><br></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">减少不必要的全局变量</span></strong></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">尽量避免static成员变量引用资源耗费过多的实例,比如Context</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"></p><div class="column">因为Context的引用超过它本身的生命周期，会导致Context泄漏。所以尽量使用Application这种Context类型。&nbsp;你可以通过调用Context.getApplicationContext()或 Activity.getApplication()轻松得到Application对象。&nbsp;</div><div class="column"><br></div><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:21px"><span style="margin:0px; padding:0px; line-height:21px"><span style="margin:0px; padding:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">避免创建不必要的对象</span></strong></span></span><br></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px"><span style="margin:0px; padding:0px">最常见的例子就是当你要频繁操作一个字符串时，使用StringBuffer代替String。</span></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px">对于所有所有基本类型的组合：int数组比Integer数组好，这也概括了一个基本事实，两个平行的int数组比</span>&nbsp;(<span style="margin:0px; padding:0px">int</span>,<span style="margin:0px; padding:0px">int</span>)<span style="margin:0px; padding:0px">对象数组性能要好很多。</span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">总体来说，就是避免创建短命的临时对象。减少对象的创建就能减少垃圾收集，进而减少对用户体验的影响。</p><span style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"><strong></strong></span><div class="column"><span style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"><strong><br></strong></span></div><strong><span style="font-family:Microsoft YaHei; font-size:18px">避免内部Getters/Setters</span></strong></div><div class="column">在Android中，虚方法调用的代价比直接字段访问高昂许多。通常根据面向对象语言的实践，在公共接口中使用Getters和Setters是有道理的，但在一个字段经常被访问的类中宜采用直接访问。<br><br></div><div class="column"><div class="page" title="Page 19"><div class="layoutArea"><div class="column"><div class="page" title="Page 20"><div class="layoutArea"><div class="column"><div class="page" title="Page 20"><div class="layoutArea"><div class="column"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:21px"><span style="margin:0px; padding:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">避免使用浮点数</span></strong></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">通常的经验是，在Android设备中，浮点数会比整型慢两倍。</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><br></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:21px"><span style="margin:0px; padding:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">使用实体类比接口好</span></strong></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">假设你有一个HashMap对象，你可以将它声明为HashMap或者Map：</p><pre style="margin-top:0px; margin-bottom:0px; padding:0px; word-wrap:break-word">Map map1 = new HashMap();HashMap map2 = new HashMap();</pre><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">哪个更好呢？</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">按照传统的观点Map会更好些，因为这样你可以改变他的具体实现类，只要这个类继承自Map接口。传统的观点对于传统的程序是正确的，但是它并不适合嵌入式系统。调用一个接口的引用会比调用实体类的引用多花费一倍的时间。如果HashMap完全适合你的程序，那么使用Map就没有什么价&#20540;。如果有些地方你不能确定，先避免使用Map，剩下的交给IDE提供的重构功能好了。(当然公共API是一个例外：一个好的API常常会牺牲一些性能）</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><br></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:21px"><span style="margin:0px; padding:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">避免使用枚举</span></strong></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">枚举变量非常方便，但不幸的是它会牺牲执行的速度和并大幅增加文件体积。</p>使用枚举变量可以让你的API更出色，并能提供编译时的检查。所以在通常的时候你毫无疑问应该为公共API选择枚举变量。但是当性能方面有所限制的时候，你就应该避免这种做法了。<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px; line-height:21px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">for循环</span></strong></span><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px">访问成员变量比访问本地变量慢得多，如下面一段代码：<br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px"></span></p><pre name="code" class="java">for(int i =0; i &lt; this.mCount; i++)  {}</pre><p>永远不要在for的第二个条件中调用任何方法，如下面一段代码：</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px"></span></p><pre name="code" class="java">for(int i =0; i &lt; this.getCount(); i++) {}</pre><p>对上面两个例子最好改为：</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px"></span></p><pre name="code" class="java">int count = this.mCount; / int count = this.getCount();for(int i =0; i &lt; count; i++)  {}</pre>在java1.5中引入的for-each语法。编译器会将对数组的引用和数组的长度保存到本地变量中，这对访问数组元素非常好。 但是编译器还会在每次循环中产生一个额外的对本地变量的存储操作<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px">（如下面例子中的变量a）</span>，这样会比普通循环多出4个字节，速度要稍微慢一些：<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px"><span style="font-family:Verdana,Arial,Helvetica,sans-serif"><span style="font-size:14px; line-height:21px"></span></span></span></p><pre name="code" class="java">for (Foo a : mArray) {    sum += a.mSplat;}</pre><br><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><span style="margin:0px; padding:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">了解并使用类库</span></strong></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">选择Library中的代码而非自己重写，除了通常的那些原因外，考虑到系统空闲时会用汇编代码调用来替代library方法，这可能比JIT中生成的等价的最好的Java代码还要好。</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">当你在处理字串的时候，不要吝惜使用<strong>String.indexOf()</strong>，<strong>String.lastIndexOf()</strong>等特殊实现的方法。这些方法都是使用C/C&#43;&#43;实现的，比起Java循环快10到100倍。</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><strong>System.arraycopy</strong>方法在有JIT的Nexus One上，自行编码的循环快9倍。</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">android.text.format包下的<strong>Formatter</strong>类，提供了IP地址转换、文件大小转换等方法；DateFormat类，提供了各种时间转换，都是非常高效的方法。</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><strong>TextUtils</strong>类，对于字符串处理Android为我们提供了一个简单实用的TextUtils类，如果处理比较简单的内容不用去思考正则表达式不妨试试这个在android.text.TextUtils的类</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px">高性能<strong>MemoryFile</strong>类，很多人抱怨Android处理底层I/O性能不是很理想，如果不想使用NDK则可以通过MemoryFile类实现高性能的文件读写操作。MemoryFile适用于哪些地方呢？对于I/O需要频繁操作的，主要是和外部存储相关的I/O操作，MemoryFile通过将 NAND或SD卡上的文件，分段映射到内存中进行修改处理，这样就用高速的RAM代替了ROM或SD卡，性能自然提高不少，对于Android手机而言同时还减少了电量消耗。该类实现的功能不是很多，直接从Object上继承，通过JNI的方式直接在C底层执行。</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><br></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><br></p><p style="text-align:center; margin:10px auto; padding-top:0px; padding-bottom:0px"><strong><span style="font-family:Microsoft YaHei; font-size:32px; color:#cc0000">Reuse:</span></strong></p><div class="column"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif"><span style="font-size:14px"><br></span></span></div><div class="column"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif"><span style="font-size:14px">Reuse重用，减少内存消耗的重要手段之一。</span></span></div><div class="column"><span style="font-size:14px"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif">核心思路就是将已经存在的内存资源重新使用而避免去创建新的，最典型的使用就是<strong>缓存（Cache</strong></span><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif; color:rgb(67,67,67); line-height:24px"><strong>）</strong>和<strong>池（Pool）</strong>。</span></span></div><div class="column"><span style="font-size:14px"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif; color:rgb(67,67,67); line-height:24px"><br></span></span></div><div class="column"><span style="line-height:24px"><span style="color:rgb(153,102,51)"><strong><span style="font-family:Microsoft YaHei; font-size:24px">Bitmap缓存：</span></strong></span></span></div><div class="column"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif; line-height:24px"><strong><span style="font-size:24px; color:#996633"><br></span></strong></span></div><div class="column"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:18px">Bitmap缓存分为两种：</span></p><p style="color:rgb(67,67,67); font-family:Arial; font-size:14px; line-height:26px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="line-height:26px"><span style="color:rgb(67,67,67); font-family:Arial; font-size:14px; line-height:26px">一种是内存缓存，</span>一种是硬盘缓存。</span></p><p style="color:rgb(67,67,67); font-family:Arial; font-size:14px; line-height:26px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="line-height:26px"><br></span></p><p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>内存缓存（LruCache）：</strong></span></p><p>以牺牲宝贵的应用内存为代价，内存缓存提供了快速的Bitmap访问方式。系统提供的<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">LruCache</span></span>类是非常适合用作缓存Bitmap任务的，它将最近被引用到的对象存储在一个强引用的<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">LinkedHashMap</span></span>中，并且在缓存超过了指定大小之后将最近不常使用的对象释放掉。</p><p><span style="font-family:微软雅黑,Verdana,sans-serif,宋体; font-size:14px; line-height:26px; padding:0px; margin:0px; color:rgb(229,102,0)"><span style="padding:0px; margin:0px">注意</span></span><span style="color:rgb(67,67,67); font-family:微软雅黑,Verdana,sans-serif,宋体; font-size:14px; line-height:26px">：</span>以前有一个非常流行的内存缓存实现是<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">SoftReference</span></span>(<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">软引用</span></span>)或者<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">WeakReference</span></span>(<span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px">弱引用</span></span>)的Bitmap缓存方案，然而现在已经不推荐使用了。自<span style="padding:0px; margin:0px">Android2.3</span>版本(<span style="padding:0px; margin:0px">API Level 9</span>)开始，垃圾回收器更着重于对软/弱引用的回收，这使得上述的方案相当无效。<br></p><p><br></p><p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>硬盘缓存（DiskLruCache）：</strong></span></p><p></p><p style="margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px"><span style="padding:0px; margin:0px">一个内存缓存对加速访问最近浏览过的Bitmap非常有帮助，但是你不能局限于内存中的可用图片。GridView这样有着更大的数据集的组件可以很轻易消耗掉内存缓存。你的应用有可能在执行其他任务(如打电话)的时候被打断，并且在后台的任务有可能被杀死或者缓存被释放。一旦用户重新聚焦(<span style="padding:0px; margin:0px">resume</span>)到你的应用，你得再次处理每一张图片。</span></p><p style="margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px">在这种情况下，硬盘缓存可以用来存储Bitmap并在图片被内存缓存释放后减小图片加载的时间(次数)。当然，从硬盘加载图片比内存要慢，并且应该在后台线程进行，因为硬盘读取的时间是不可预知的。</p><p style="color:rgb(67,67,67); font-family:微软雅黑,Verdana,sans-serif,宋体; font-size:14px; line-height:26px; margin-top:0px; margin-bottom:15px; padding-top:0px; padding-bottom:0px"><span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; color:rgb(229,102,0)"><span style="padding:0px; margin:0px">注意</span></span>：如果访问图片的次数非常频繁，那么<span style="padding:0px; margin:0px; color:rgb(0,102,0)"><span style="padding:0px; margin:0px">ContentProvider</span></span>可能更适合用来存储缓存图片，例如<span style="padding:0px; margin:0px; color:rgb(0,102,0)">Image Gallery</span>这样的应用程序。</span></p>更多关于内存缓存和硬盘缓存的内容请看Google官方教程<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGV2ZWxvcC9pbmRleC5odG1s" title="https://developer.android.com/develop/index.html">https://developer.android.com/develop/index.html<i class="fa fa-external-link"></i></span><br></div><div class="column"><span style="font-size:24px; color:#996633"><br></span></div><div class="column"><strong><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633">图片缓存的开源项目：</span></strong></div><div class="column"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif; font-size:14px; color:#434343"><span style="line-height:24px">对于图片的缓存现在都倾向于使用开源项目，这里我列出几个我搜到的：</span></span></div><div class="column"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif; font-size:14px; color:#434343"><span style="line-height:24px"><br></span></span></div><div class="column"><span style="line-height:24px"></span><p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px"><span style="background-color:rgb(255,255,255)"><strong><span style="font-family:Microsoft YaHei; font-size:18px">1. Android-Universal-Image-Loader 图片缓存</span></strong></span></p><p style="font-family:simsun; font-size:14px; margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px"><span style="background-color:rgb(255,255,255)">目前使用最广泛的图片缓存，支持主流图片缓存的绝大多数特性。<br>项目地址：https://github.com/nostra13/Android-Universal-Image-Loader<br></span></p><p style="color:rgb(85,85,85); font-family:simsun; font-size:14px; margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px"><span style="background-color:rgb(255,255,255)">&nbsp;<wbr></span></p><p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px"><span style="background-color:rgb(255,255,255)"><strong><span style="font-family:Microsoft YaHei; font-size:18px">2. picasso square开源的图片缓存</span></strong><br><span style="font-family:simsun; font-size:14px">项目地址：https://github.com/square/picasso</span><br><span style="font-family:simsun; font-size:14px">特点：(1)可以自动检测adapter的重用并取消之前的下载</span><br><span style="font-family:simsun; font-size:14px">(2)图片变换</span><br><span style="font-family:simsun; font-size:14px">(3)可以加载本地资源</span><br><span style="font-family:simsun; font-size:14px">(4)可以设置占位资源</span><br><span style="font-family:simsun; font-size:14px">(5)支持debug模式</span></span></p><p style="color:rgb(85,85,85); font-family:simsun; font-size:14px; margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px"><span style="background-color:rgb(255,255,255)">&nbsp;<wbr></span></p><p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px"><span style="background-color:rgb(255,255,255)"><strong><span style="font-family:Microsoft YaHei; font-size:18px">3. ImageCache 图片缓存，包含内存和Sdcard缓存</span></strong><br><span style="font-family:simsun; font-size:14px">项目地址：https://github.com/Trinea/AndroidCommon</span><br><span style="font-family:simsun; font-size:14px">特点：</span></span></p><p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px"><span style="background-color:rgb(255,255,255)"><span style="font-family:simsun; font-size:14px">(1)支持预取新图片，支持等待队列</span><br><span style="font-family:simsun; font-size:14px">(2)包含二级缓存，可自定义文件名保存规则</span><br><span style="font-family:simsun; font-size:14px">(3)可选择多种缓存算法(FIFO、LIFO、LRU、MRU、LFU、MFU等13种)或自定义缓存算法</span><br><span style="font-family:simsun; font-size:14px">(4)可方便的保存及初始化恢复数据</span><br><span style="font-family:simsun; font-size:14px">(5)支持不同类型网络处理</span><br><span style="font-family:simsun; font-size:14px">(6)可根据系统配置初始化缓存等</span></span></p><br></div><div class="column"><span style="line-height:24px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">4.&nbsp;Android 网络通信框架Volley</span></strong></span></div><div class="column"><span style="font-size:14px"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif; line-height:24px"><span style="font-family:Arial; font-size:14px; line-height:26px; orphans:2; widows:2">项目地址：https://android.googlesource.com/platform/frameworks/volley</span></span></span></div><div class="column"><span style="font-size:14px"><span style="line-height:24px; font-family:Tahoma,Helvetica,Arial,宋体,sans-serif"><span style="orphans:2; widows:2; line-height:26px; font-size:14px; font-family:Arial">我们在程序中需要和网络通信的时候，大体使用的东西莫过于AsyncTaskLoader，HttpURLConnection，AsyncTask，HTTPClient（Apache）等，在2013年的Google I/O发布了Volley。Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮。</span></span></span></div><div class="column"><span style="line-height:21px; font-variant:inherit; font-style:inherit; font-size:14px; font-family:simsun">特点：</span></div><div class="column"><span style="orphans:2; widows:2; line-height:inherit; font-variant:inherit; font-style:inherit; font-size:14px; font-family:inherit"><span style="line-height:21px; font-size:14px; font-family:simsun">(1)</span>JSON，图像等的异步下载；</span></div><div class="column"><span style="orphans:2; widows:2; line-height:inherit; font-variant:inherit; font-style:inherit; font-size:14px; font-family:inherit"><span style="line-height:21px; font-size:14px; font-family:simsun">(2)</span>网络请求的排序（scheduling）</span></div><div class="column"><span style="orphans:2; widows:2; line-height:inherit; font-variant:inherit; font-style:inherit; font-size:14px; font-family:inherit"><span style="line-height:21px; font-size:14px; font-family:simsun">(3)</span>网络请求的优先级处理</span></div><div class="column"><span style="orphans:2; widows:2; line-height:inherit; font-variant:inherit; font-style:inherit; font-size:14px; font-family:inherit"><span style="line-height:21px; font-size:14px; font-family:simsun">(4)</span>缓存</span></div><div class="column"><span style="orphans:2; widows:2; line-height:inherit; font-variant:inherit; font-style:inherit; font-size:14px; font-family:inherit"><span style="line-height:21px; font-size:14px; font-family:simsun">(5)</span>多级别取消请求</span></div><div class="column"><span style="orphans:2; widows:2; line-height:inherit; font-variant:inherit; font-style:inherit; font-size:14px; font-family:inherit"><span style="font-family:simsun; font-size:14px; line-height:21px">(6)</span>和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）</span></div><div class="column"><span style="font-size:14px"><span style="font-family:Tahoma,Helvetica,Arial,宋体,sans-serif; color:rgb(67,67,67); line-height:24px"><br></span></span></div><div class="column"><div class="column"><span style="line-height:25.200000762939453px"><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633"><strong>Adapter适配器</strong></span></span></div><div class="column"><br></div><div class="column">在Android中Adapter使用十分广泛，特别是在list中。所以adapter是数据的<strong> “集散地”</strong> ，所以对其进行内存优化是很有必要的。</div><div class="column">下面算是一个标准的使用模版：</div><div class="column">主要使用convertView和ViewHolder来进行缓存处理</div><div class="column"><p></p><pre name="code" class="java">    @Override    public View getView(int position, View convertView, ViewGroup parent) {        ViewHolder vHolder = null;        //如果convertView对象为空则创建新对象，不为空则复用          if (convertView == null) {            convertView = inflater.inflate(..., null);            // 创建 ViewHodler 对象              vHolder = new ViewHolder();            vHolder.img= (ImageView) convertView.findViewById(...);            vHolder.tv= (TextView) convertView.findViewById(...);            // 将ViewHodler保存到Tag中(Tag可以接收Object类型对象，所以任何东西都可以保存在其中)            convertView.setTag(vHolder);        } else {            //当convertView不为空时，通过getTag()得到View              vHolder = (ViewHolder) convertView.getTag();        }        // 给对象赋值，修改显示的值          vHolder.img.setImageBitmap(...);        vHolder.tv.setText(...);        return convertView;    }    //将显示的View 包装成类      static class ViewHolder {        TextView tv;        ImageView img;    }</pre><div><br></div></div><br></div><div class="column"><span style="line-height:24px"><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633"><strong>池（PooL）</strong></span></span></div><div class="column"><br></div><p><span style="line-height:1.5; color:rgb(75,75,75)"><span style="font-family:Microsoft YaHei; font-size:18px"><strong>对象池：</strong></span></span></p><p>对象池使用的基本思路是：将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用，从而在一定程度上减少频繁创建对象所造成的开销。&nbsp;并非所有对象都适合拿来池化――因为维护对象池也要造成一定开销。对生成时开销不大的对象进行池化，反而可能会出现“维护对象池的开销”大于“生成新对象的开销”，从而使性能降低的情况。但是对于生成时开销可观的对象，池化技术就是提高性能的有效策略了。</p><p><br></p><p></p><div class="column"><span style="color:rgb(67,67,67); line-height:24px"><span style="color:rgb(68,68,68); line-height:21px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">线程池：</span></strong></span></span></div><div class="column"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">比如：一个应用要和网络打交道，有很多步骤需要访问网络，为了不阻塞主线程，每个步骤都创建个线程，在线程中和网络交互，用线程池就变的简单，线程池是对线程的一种封装，让线程用起来更加简便，只需要创一个线程池，把这些步骤像任务一样放进线程池，在程序销毁时只要调用线程池的销毁函数即可。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">java提供了<strong>ExecutorService</strong>和<strong>Executors</strong>类，我们可以应用它去建立线程池。</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">通常可以建立如下4种：</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><pre name="code" class="java">/** 每次只执行一个任务的线程池 */ExecutorService singleTaskExecutor =  Executors.newSingleThreadExecutor();<p>/** 每次执行限定个数个任务的线程池 */<br>ExecutorService limitedTaskExecutor = Executors.newFixedThreadPool(3);</p><p>/** 所有任务都一次性开始的线程池 */<br>ExecutorService allTaskExecutor = Executors.newCachedThreadPool();</p><p>/** 创建一个可在指定时间里执行任务的线程池，亦可重复执行 */<br>ExecutorService scheduledTaskExecutor = Executors.newScheduledThreadPool(3);</p></pre><p></p><p></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p>更多关于线程池的内容我推荐这篇文章：<span class="exturl" data-url="aHR0cDovL3d3dy54dWFueXVzb25nLmNvbS9hcmNoaXZlcy8yNDM5" title="http://www.xuanyusong.com/archives/2439">http://www.xuanyusong.com/archives/2439<i class="fa fa-external-link"></i></span><br><br></div><div><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633"><strong>注意：</strong></span></div><p></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px">要根据情况适度使用缓存，因为内存有限。</p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px">能保存路径地址的就不要存放图片数据，不经常使用的尽量不要缓存，不用时就清空。</p><div><br></div><div><br></div><p></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:24px; color:rgb(204,0,0)"><strong>写在最后：</strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:SimSun; font-size:14px"></span></p><p style="font-size:13.3333339691162px"><span style="font-size:18px">我准备将文章分为上、中、下三部分。现在已经全部完成：</span></p><p style="font-size:13.3333339691162px"><span style="font-family:'Microsoft YaHei'; font-size:18px"><strong>内存简介，Recoken（计算）</strong></span><span style="font-size:18px">请看</span><span style="font-family:'Microsoft YaHei'"><strong><span style="font-size:18px">：</span><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MC9hcnRpY2xlL2RldGFpbHMvMzc5MTQ0NjU=" title="http://blog.csdn.net/a396901990/article/details/37914465"><span style="font-size:18px; color:rgb(255,0,0)">ANDROID内存优化(大汇总——上)</span><i class="fa fa-external-link"></i></span></strong></span></p><p style="font-size:13.3333339691162px"><span style="font-size:18px"><span style="font-family:'Microsoft YaHei'"><strong>Reduce（减少），Reuse（重用）&nbsp;</strong></span><span style="font-family:SimSun">请看：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MC9hcnRpY2xlL2RldGFpbHMvMzg3MDcwMDc=" title="http://blog.csdn.net/a396901990/article/details/38707007"><span style="color:rgb(255,0,0)"><strong>ANDROID内存优化(大汇总——中)</strong></span><i class="fa fa-external-link"></i></span></span></span></p><p style="font-size:13.3333339691162px"><span style="font-family:'Microsoft YaHei'; font-size:18px"><strong>Recycle（回收）, Review（检查）&nbsp;</strong></span><span style="font-family:SimSun"><span style="font-size:18px">请看：</span><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MC9hcnRpY2xlL2RldGFpbHMvMzg5MDQ1NDM=" title="http://blog.csdn.net/a396901990/article/details/38904543"><span style="font-size:18px; color:#ff0000"><strong>ANDROID内存优化(大汇总——全)</strong></span><i class="fa fa-external-link"></i></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:SimSun; font-size:14px"></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px"><span style="font-family:SimSun"><span style="font-size:18px"><br></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px"><span style="font-family:SimSun"><span style="font-size:18px">写这篇文章的目的就是想弄一个大汇总，将零散的内存知识点总结一下，如果有错误、不足或建议都希望告诉我。</span><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-weight:bold"><span style="color:rgb(204,0,0)"><span style="font-family:SimSun; font-size:14px"><br></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-weight:bold"><span style="color:rgb(204,0,0)"><span style="font-family:SimSun; font-size:14px"><br></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:24px; color:rgb(204,0,0)"><strong>参考文章：</strong></span></p>解析Android开发优化之:软引用与弱引用的应用（http://www.jb51.net/article/36627.htm）<br style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px">android内存泄露优化总结（http://blog.csdn.net/imain/article/details/8560986）</span><br style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px">Android 内存优化（http://blog.csdn.net/awangyunke/article/details/20380719）</span><br style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px">Android开发优化之——对Bitmap的内存优化（http://blog.csdn.net/arui319/article/details/7953690）</span><br style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px">关于android性能，内存优化（http://www.cnblogs.com/zyw-205520/archive/2013/02/17/2914190.html）</span><p><span style="font-family:Arial; font-size:14px; line-height:26px">Android研究院之应用开发线程池的经典使用（http://www.xuanyusong.com/archives/2439）</span></p><p><br></p><p><br></p></div></div></div></div></div></div></div></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div&gt;
&lt;p style=&quot;color:rgb(102,51,51); font-family:&#39;Microsoft YaHei&#39;; font-size:18px; font-weight:bold; line-height:26px&quot;&gt;
&lt;strong&gt;&lt;span styl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/android-memory-prof3/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/android-memory-prof3/</id>
    <published>2019-06-14T02:52:59.701Z</published>
    <updated>2019-06-14T02:52:59.701Z</updated>
    
    <content type="html"><![CDATA[<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold"><span style="font-size:18px; color:rgb(204,102,0)">内存泄露可以引发很多的问题：</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">1.程序卡顿，响应速度慢（内存占用高时JVM虚拟机会频繁触发GC）</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">2.莫名消失（当你的程序所占内存越大，它在后台的时候就越可能被干掉。反之内存占用越小，在后台存在的时间就越长）</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">3.直接崩溃（OutOfMemoryError）</p><p style="margin-top:0px; margin-bottom:8px; padding-top:0px; padding-bottom:0px; color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold; border-width:0px; list-style:none"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold"><span style="font-size:18px; color:rgb(204,102,0)">ANDROID内存面临的问题：</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(102,51,51); font-family:'Microsoft YaHei'; font-size:18px; font-weight:bold"></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">1.有限的堆内存，原始只有16M</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">2.内存大小消耗等根据设备，操作系统等级，屏幕尺寸的不同而不同</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">3.程序不能直接控制</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">4.支持后台多任务处理（multitasking）</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">5.运行在虚拟机之上</p><div style="font-size:14px; line-height:26px; color:rgb(102,51,51); font-family:SimSun; font-weight:bold"><span style="font-family:'Microsoft YaHei'; font-size:18px"><br></span></div><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:24px; color:rgb(204,0,0)"><strong>5R：</strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px">本文主要通过如下的5R方法来对ANDROID内存进行优化：</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">1.Reckon（计算）</span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>首先需要知道你的app所消耗内存的情况，知己知彼才能百战不殆</span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">2.Reduce（减少）</span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>消耗更少的资源</span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">3.Reuse（重用）</span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>当第一次使用完以后，尽量给其他的使用</span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">5.Recycle（回收）</span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>回收资源</span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><strong><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(204,102,0)">4.Review（检查）</span><br></span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><span style="white-space:pre"><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'">回顾检查你的程序，看看设计或代码有什么不合理的地方。</span></span></span></p><div class="column" style="font-family:Arial; font-size:14px; line-height:26px"><br></div><br style="font-family:Arial; font-size:14px; line-height:26px"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px; text-align:center"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px; text-align:center"><strong><span style="color:rgb(204,0,0)"><span style="font-family:Microsoft YaHei; font-size:24px"><br></span></span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px; text-align:center"><span style="font-weight:bold"><span style="color:rgb(204,0,0)"><span style="font-size:32px"><span style="font-size:18px">Recycle（回收），回收可以说是在内存使用中最重要的部分。因为内存空间有限，无论你如何优化，如何节省内存总有用完的时候。而回收的意义就在于去清理和释放那些已经闲置，废弃不再使用的内存资源和内存空间。</span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:18px">因为在Java中有垃圾回收（GC）机制，所以我们平时都不会太关注它，下面就来简单的介绍一下回收机制：</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:12px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633"><strong><br></strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633"><strong>垃圾回收（GC）：</strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:18px"><strong><br></strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:18px"><strong>Java垃圾回收器：</strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">在C，C&#43;&#43;或其他程序设计语言中，资源或内存都必须由程序员自行声明产生和回收，否则其中的资源将消耗，造成资源的浪费甚至崩溃。但手工回收内存往往是一项复杂而艰巨的工作。<br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">于是，Java技术提供了一个系统级的线程，即垃圾收集器线程（Garbage Collection Thread），来跟踪每一块分配出去的内存空间，当Java 虚拟机（Java Virtual Machine）处于空闲循环时，垃圾收集器线程会自动检查每一快分配出去的内存空间，然后自动回收每一快可以回收的无用的内存块。&nbsp;</span><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:17px; line-height:18px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:18px"><span style="line-height:18px"><strong>作用：</strong></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px"><strong>1.</strong><span style="font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; line-height:20.799999237060547px">清除不用的对象来释放内存：</span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma; line-height:18px"><span style="font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; line-height:20.799999237060547px"><span style="font-size:14px">采用<span style="font-family:Arial,sans-serif,Helvetica,Tahoma; line-height:18px">一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾收集算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。&nbsp;</span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px; font-family:Arial,sans-serif,Helvetica,Tahoma; line-height:18px"><strong>2.</strong></span><span style="font-size:14px; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; line-height:20.799999237060547px">消除堆内存空间的碎片：</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma; line-height:18px"><span style="font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; line-height:20.799999237060547px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">由于创建对象和垃圾收集器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。&nbsp;</span></span><br></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:17px; line-height:18px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:18px"><span style="line-height:18px"><strong>垃圾回收器优点：</strong></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px"><strong>1.</strong><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px">减轻编程的负担，提高效率</span>：</span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">使程序员从手工回收内存空间的繁重工作中解脱了出来，因为</span>在没有垃圾收集机制的时候，可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程的时候，靠垃圾收集机制可大大缩短时间。</span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px; color:rgb(51,51,51); font-family:Arial; line-height:26px"><strong>2.</strong>它保护程序的完整性：</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">因此垃圾收集是Java语言安全性策略的一个重要部份。&nbsp;</span></span><br></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:18px"><span style="line-height:18px"><span style="color:rgb(51,51,51); line-height:26px"><strong><span style="font-family:Microsoft YaHei">垃圾回收器缺点：</span></strong></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px"><strong>1.</strong>占用资源时间：</span></span></span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px">Java虚拟机必须追踪运行程序中有用的对象, 而且最终释放没用的对象。这一个过程需要花费处理器的时间。</span><br></span></span></span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px; color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>2.</strong>不可预知:</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">垃圾收集器线程虽然是作为低优先级的线程运行，但在系统可用内存量过低的时候，它可能会突发地执行来挽救内存资源。当然其执行与否也是不可预知的。&nbsp;</span><br></span></span></span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px; color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>3.</strong>不确定性：</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"></span></span></span></span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma; line-height:18px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px">不能保证一个无用的对象一定会被垃圾收集器收集，也不能保证垃圾收集器在一段Java语言代码中一定会执行。<br></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">同样也没有办法预知在一组均符合垃圾收集器收集标准的对象中，哪一个会被首先收集。&nbsp;</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px"><strong>4.</strong>不可操作</span></span></span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,sans-serif,Helvetica,Tahoma"><span style="line-height:18px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"></span></span></span></span></span></span></p><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px">垃圾收集器不可以被强制执行，但程序员可以通过调用System. gc方法来建议执行垃圾收集器。</span></span><div class="column"><br></div><div class="column"><strong><span style="font-size:18px"><span style="font-family:Microsoft YaHei">垃圾回收算法：</span></span></strong></div><div class="column"><span style="font-size:14px"></span></div><span style="font-size:14px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><strong>1.</strong>引用计数（Reference Counting）</span><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">&nbsp;</span><br style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。&nbsp;</span></span><div class="layoutArea"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; color:#444444"><span style="line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><strong>2.</strong>标记-清除（Mark-Sweep）</span><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">&nbsp;</span><br style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</span></span></span></div><div class="layoutArea"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; color:#444444"><span style="line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><strong>3.</strong>复制（Copying）</span><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">&nbsp;</span><br style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</span></span></span></div><div class="layoutArea"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; color:#444444"><span style="line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><strong>4.</strong>标记-整理（Mark-Compact）</span><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">&nbsp;</span><br style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">此算法结合了 “标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。&nbsp;</span></span></span></div><div class="layoutArea"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; color:#444444"><span style="line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><strong>5.</strong>增量收集（Incremental Collecting）</span><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">&nbsp;</span><br style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">实施垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。&nbsp;</span></span></span></div><div class="layoutArea"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; color:#444444"><span style="line-height:25px"><span style="font-size:14px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><strong>6.</strong>分代（Generational Collecting）</span><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">&nbsp;</span><br style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px"><span style="color:rgb(68,68,68); font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px">基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。&nbsp;</span></span><br></span></span><span style="color:rgb(51,51,51); font-size:14px; line-height:26px; font-family:宋体"></span><div class="column"><span style="font-size:14px"></span><br></div><div class="column"><br></div><div class="column"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); line-height:25px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">finalize（）:</span></strong></span><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px">每一个对象都有一个finalize方法，这个方法是从Object类继承来的。&nbsp;</span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">当垃圾回收确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</span></span></span><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">。</span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px">Java 技术允许使用finalize方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。一旦垃圾回收器准备好释放对象占用的空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。<br>简单的说finalize方法是在垃圾收集器删除对象之前对这个对象调用的</span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><br><span style="font-size:17.77777862548828px; color:rgb(17,17,17); font-family:'Microsoft YaHei'; line-height:25px"><strong>System.gc（）：</strong></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">我们可以调用System.gc方法，建议虚拟机进行垃圾回收工作（注意，是建议，但虚拟机会不会这样干，我们也无法预知！）</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:'Microsoft YaHei'"><span style="font-family:Arial,Helvetica,sans-serif"><span style="font-size:14px"><br></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:'Microsoft YaHei'"><span style="font-family:Arial,Helvetica,sans-serif"><span style="font-size:14px">下面来看一个例子来了解<span style="color:rgb(17,17,17); font-family:'Microsoft YaHei'; line-height:25px"><strong>finalize（）</strong></span><span style="color:rgb(17,17,17); font-family:'Microsoft YaHei'; line-height:25px">和<span style="color:rgb(17,17,17); font-family:'Microsoft YaHei'; line-height:25px"><strong>System.gc（）</strong></span><span style="color:rgb(17,17,17); font-family:'Microsoft YaHei'; line-height:25px">的使用：</span></span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Arial,Helvetica,sans-serif; font-size:14px"></span></p><pre name="code" class="java" style="color: rgb(17, 17, 17); font-family: 'Microsoft YaHei'; font-size: 17.77777862548828px; font-weight: bold; line-height: 25px;">public class TestGC {    public TestGC() {}<pre><code>//当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。protected void finalize() {    System.out.println(&amp;quot;我已经被垃圾回收器回收了...&amp;quot;);}public static void main(String [] args) {    TestGC gc = new TestGC();    gc = null;      // 建议虚拟机进行垃圾回收工作    System.gc();}</code></pre><p>}</p></pre><span style="font-size:14px">如上面的例子所示，大家可以猜猜重写的finalize方法会不会执行？</span><p></p><p></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">答案是：<strong>不一定</strong>！</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">因为无论是设置gc的引用为null还是调用System.gc()方法都只是<strong>&quot;建议&quot;</strong>垃圾回收器进行垃圾回收，但是最终所有权还在垃圾回收器手中，它会不会进行回收我们无法预知！<br></span><br><strong><span style="font-family:Microsoft YaHei; font-size:18px">垃圾回收面试题：</span></strong><br><span style="font-family:Arial,Helvetica,sans-serif"><span style="font-size:18px">最后通过网上找到的3道面试题来结束垃圾回收的内容。</span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px">&nbsp;</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:宋体,Verdana,Arial,Helvetica,sans-serif; color:rgb(17,17,17)"><span style="line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px"><strong>面试题一：</strong>&nbsp;</span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:宋体,Verdana,Arial,Helvetica,sans-serif; color:rgb(17,17,17)"><span style="font-size:14.44444465637207px; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"></span></span></span></p><pre name="code" class="java">1．fobj = new Object ( ) ; 2．fobj. Method ( ) ; 3．fobj = new Object ( ) ; 4．fobj. Method ( ) ; </pre><p></p><span style="font-size:14px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>问：</strong>这段代码中，第几行的fobj 符合垃圾收集器的收集标准？&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>答：</strong>第3行。因为第3行的fobj被赋了新&#20540;，产生了一个新的对象，即换了一块新的内存空间，也相当于为第1行中的fobj赋了null&#20540;。这种类型的题是最简单的。&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>面试题二：</strong>&nbsp;</span></span></div><div class="column"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"></span><pre name="code" class="java">1．Object sobj = new Object ( ) ; 2．Object sobj = null ; 3．Object sobj = new Object ( ) ; 4．sobj = new Object ( ) ; </pre><span style="font-size:14px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>问：</strong>这段代码中，第几行的内存空间符合垃圾收集器的收集标准？&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>答：</strong>第2行和第4行。因为第2行为sobj赋&#20540;为null，所以在此第1行的sobj符合垃圾收集器的收集标准。而第4行相当于为sobj赋&#20540;为null，所以在此第3行的sobj也符合垃圾收集器的收集标准。&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">如果有一个对象的句柄a，且你把a作为某个构造器的参数，即 new Constructor ( a )的时候，即使你给a赋&#20540;为null，a也不符合垃圾收集器的收集标准。直到由上面构造器构造的新对象被赋空&#20540;时，a才可以被垃圾收集器收集。&nbsp;</span></span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px; padding:0px; margin:0px"><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:14px"><strong>面试题三：&nbsp;</strong></span></span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px; padding:0px; margin:0px"><pre name="code" class="java">1．Object aobj = new Object ( ) ; 2．Object bobj = new Object ( ) ; 3．Object cobj = new Object ( ) ; 4．aobj = bobj; 5．aobj = cobj; 6．cobj = null; 7．aobj = null; </pre><span style="font-size:14px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>问：</strong>这段代码中，第几行的内存空间符合垃圾收集器的收集标准？&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>答：</strong>第4，7行。注意这类题型是认证考试中可能遇到的最难题型了。&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">行1-3：分别创建了Object类的三个对象：aobj，bobj，cobj</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">行4：此时对象aobj的句柄指向bobj，原来aojb指向的对象已经没有任何引用或变量指向，这时，就符合回收标准。</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">行5：此时对象aobj的句柄指向cobj，所以该行的执行不能使aobj符合垃圾收集器的收集标准。&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">行6：此时仍没有任何一个对象符合垃圾收集器的收集标准。&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">行7：对象cobj符合了垃圾收集器的收集标准，因为cobj的句柄指向单一的地址空间。在第6行的时候，cobj已经被赋&#20540;为null，但由cobj同时还指向了aobj（第5行），所以此时cobj并不符合垃圾收集器的收集标准。而在第7行，aobj所指向的地址空间也被赋予了空&#20540;null，这就说明了，由cobj所指向的地址空间已经被完全地赋予了空&#20540;。所以此时cobj最终符合了垃圾收集器的收集标准。 但对于aobj和bobj，仍然无法判断其是否符合收集标准。&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">总之，在Java语言中，判断一块内存空间是否符合垃圾收集器收集的标准只有两个：&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>1．</strong>给对象赋予了空&#20540;null，以下再没有调用过。&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><strong>2．</strong>给对象赋予了新&#20540;，既重新分配了内存空间。&nbsp;</span><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><br style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px; padding:0px; margin:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px">最后再次提醒一下，一块内存空间符合了垃圾收集器的收集标准，并不意味着这块内存空间就一定会被垃圾收集器收集。</span></span><br><p></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><br></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><br></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633"><strong>资源的回收：</strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="font-size:18px">刚才讲了一堆理论的东西，下面来点实际能用上的，资源的回收：</span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><br></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:18px; color:#111111"><span style="line-height:25px"><strong>Thread（线程）回收：</strong></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">线程中涉及的任何东西GC都不能回收（Anything reachable by a thread cannot be GC'd&nbsp;），<span style="font-family:宋体,Verdana,Arial,Helvetica,sans-serif; color:#111111"><span style="line-height:25px">所以线程很容易造成内存泄露。</span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px"><span style="font-family:宋体,Verdana,Arial,Helvetica,sans-serif; color:#111111"><span style="line-height:25px">如下面代码所示：</span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><pre name="code" class="java" style="color: rgb(17, 17, 17); font-family: 宋体, Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 25px;">Thread t = new Thread() {    public void run() {        while (true) {            try {                Thread.sleep(1000);                System.out.println(&quot;thread is running...&quot;);            } catch (InterruptedException e) {<pre><code>        }    }}</code></pre><p>};<br>t.start();<br>t = null;<br>System.gc();</p></pre><span style="font-size:14px">如上在线程t中每间隔一秒输出一段话，然后将线程设置为null并且调用System.gc方法。</span><p></p><p></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">最后的结果是线程并不会被回收，它会一直的运行下去。</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal"><span style="font-size:14px">因为运行中的线程是称之为垃圾回收根（GC Roots）对象的一种，不会被垃圾回收。当垃圾回收器判断一个对象是否可达，总是使用垃圾回收根对象作为参考点。</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:宋体,Verdana,Arial,Helvetica,sans-serif; color:rgb(17,17,17)"><span style="font-size:14.44444465637207px; line-height:25px"><br></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:#111111"><span style="line-height:25px"><span style="font-family:Microsoft YaHei; font-size:18px"><strong>Cursor（游标）回收：</strong></span><br></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"></span></span></p><p><span style="font-size:14px">Cursor是Android查询数据后得到的一个管理数据集合的类，在使用结束以后。应该保证Cursor占用的内存被及时的释放掉，而不是等待GC来处理。并且Android明显是倾向于编程者手动的将Cursor&nbsp;<wbr><wbr>close掉，因为在源代码中我们发现，如果等到垃圾回收器来回收时，会给用户以错误提示。</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal"><span style="font-size:14px">所以我们使用Cursor的方式一般如下：</span></p><p style="font-size:14px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal"></p><pre name="code" class="java" style="font-size: 14px;">        Cursor cursor = null;        try {            cursor = mContext.getContentResolver().query(uri,null, null,null,null);            if(cursor != null) {                cursor.moveToFirst();                //do something            }        } catch (Exception e) {            e.printStackTrace();        } finally {            if (cursor != null) {                cursor.close();            }        }</pre><span style="font-size:14px">有一种情况下，我们不能直接将Cursor关闭掉，这就是在CursorAdapter中应用的情况，但是注意，CursorAdapter在Acivity结束时并没有自动的将Cursor关闭掉，因此，你需要在onDestroy函数中，手动关闭。</span><br><pre name="code" class="java" style="font-size: 14px;">@Override  protected void onDestroy() {            if (mAdapter != null &amp;&amp; mAdapter.getCurosr() != null) {          mAdapter.getCursor().close();      }      super.onDestroy();   }  </pre><br><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); line-height:25px"><span style="line-height:25.200000762939453px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">Receiver（接收器）回收</span></strong></span><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; line-height:25px"></span></p><div class="column"><span style="font-size:14px"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.200000762939453px">调用registerReceiver()后未调用unregisterReceiver().</span><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.200000762939453px">&nbsp;</span></span></div><div class="column"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif"><span style="line-height:25.200000762939453px"><span style="font-size:14px">当我们Activity中使用了registerReceiver()方法注册了BroadcastReceiver，一定要在Activity的生命周期内调用unregisterReceiver()方法取消注册&nbsp;<br>也就是说registerReceiver()和unregisterReceiver()方法一定要成对出现，通常我们可以重写Activity的onDestory()方法：&nbsp;</span></span></span></div><div class="column" style="font-size:14px"><pre name="code" class="java" style="color: rgb(17, 17, 17); line-height: 25px;">@Override  protected void onDestroy() {        this.unregisterReceiver(receiver);        super.onDestroy();  }  </pre><div><br></div></div><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); line-height:25px"><span style="color:rgb(17,17,17); line-height:25px"><span style="line-height:25.200000762939453px"><span style="font-size:18px"><strong><span style="font-family:Microsoft YaHei">Stream/File（流/文件）回收：</span></strong></span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.200000762939453px"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.200000762939453px">主要针对各种流，文件资源等等如：</span></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.200000762939453px"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.200000762939453px">InputStream/OutputStream，</span><span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14.44444465637207px; line-height:21px">SQLiteOpenHelper，SQLiteDatabase，Cursor，文件，I/O，Bitmap图片等操作等都应该记得显示关闭。</span><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.200000762939453px"></span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.200000762939453px"><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.200000762939453px">和之前介绍的Cursor道理类&#20284;，就不多说了。</span><br></span></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><br></span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:rgb(17,17,17); font-family:宋体,Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px; text-align:center"><strong><span style="color:rgb(204,0,0)"><span style="font-size:32px">Review:</span></span></strong></p><div><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:18px">Review（回顾，检查），大家都知道Code Review的重要性。而这里我说的Review和Code Review差不多，主要目的就是检查代码中存在的不合理和可以改进的地方，当然这个Review需要大家自己来做啦。</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633"><strong>Code Review（代码检查）：</strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:18px">Code Review主要检查代码中存在的一些不合理或可以改进优化的地方，大家可以参考之前写的Reduce，Reuse和Recycle都是侧重讲解这方面的。</span><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:24px; color:#996633"><strong>UI Review（视图检查）：</strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:18px">Android对于视图中控件的布局渲染等会消耗很多的资源和内存，所以这部分也是我们需要注意的。</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><span style="font-family:'Microsoft YaHei'"><strong><span style="font-size:18px">减少视图层级：</span></strong></span></div><div><span style="font-size:14px">减少视图层级可以有效的减少内存消耗，因为视图是一个树形结构，每次刷新和渲染都会遍历一次。</span></div><div><span style="font-size:18px"><span style="font-size:18px"><br></span></span></div><div><strong><span style="font-size:14px">hierarchyviewer：</span></strong></div><div><span style="font-size:14px">想要减少视图层级首先就需要知道视图层级，所以下面介绍一个SDK中自带的一个非常好用的工具hierarchyviewer。</span></div><div><span style="font-size:14px">你可以在下面的地址找到它：<span style="font-family:Arial; font-size:14px; line-height:26px"><strong>your sdk path\sdk\tools</strong></span></span></div><div><span style="font-size:14px"><img src="http://img.blog.csdn.net/20140908210538701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br></span></div><div><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">如上图大家可以看到，</span><span style="font-size:14px">hierarchyviewer</span><span style="font-size:14px">可以非常清楚的看到当前视图的层级结构，并且可以查看视图的执行效率（视图上的小圆点，绿色表示流畅，黄色和红色次之），所以我们可以很方便的查看哪些view可能会影响我们的性能从而去进一步优化它。</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">hierarchyviewer还提供另外一种列表式的查看方式，<span style="font-family:Arial; line-height:26px">可以查看详细的屏幕画面，具体到像素级别的问题都可以通过它发现。</span></span><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:21px"><span style="margin:0px; padding:0px"><strong><span style="font-family:'Microsoft YaHei'"><span style="font-size:14px">ViewStub标签</span></span></strong></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px"><span style="color:rgb(35,35,35); font-family:Verdana,Arial,helvetica,sans-seriff; line-height:21.600000381469727px"><span style="font-size:14px">此标签可以使UI在特殊情况下，直观效果类&#20284;于设置View的不可见性，但是其更大的意义在于被这个标签所包裹的Views在默认状态下不会占用任何内存空间。</span></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px"></span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="font-size:14px"><br></span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="font-size:14px">include标签</span></strong><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">可以通过这个标签直接加载外部的xml到当前结构中，是复用UI资源的常用标签。</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px"><br></span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="font-family:'Microsoft YaHei'"><span style="font-size:14px">merge标签</span></span></strong><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px"><span style="color:rgb(35,35,35); font-family:Verdana,Arial,helvetica,sans-seriff; line-height:21.600000381469727px">它在优化UI结构时起到很重要的作用。目的是通过删减多余或者额外的层级，从而优化整个Android Layout的结构。</span><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px"><br></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">（<span style="color:#ff0000">注意</span>：灵活运用以上3个标签可以有效减少视图层级，具体使用大家可以上网搜搜）</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px"><span style="margin:0px; padding:0px"><strong><span style="font-size:14px">布局用Java代码比写在XML中快</span></strong></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px"><span style="font-size:14px">一般情况下对于Android程序布局往往使用XML文件来编写，这样可以提高开发效率，但是考虑到代码的安全性以及执行效率，可以通过Java代码执行创建，虽然Android编译过的XML是二进制的，但是加载XML解析器的效率对于资源占用还是比较大的，Java处理效率比XML快得多，但是对于一个复杂界面的编写，可能需要一些套嵌考虑，如果你思维灵活的话，使用Java代码来布局你的Android应用程序是一个更好的方法。</span></p><div><br></div><div><br></div><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px">重用系统资源：</span></span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:'Microsoft YaHei'"><strong><span style="font-size:14px">1. 利用系统定义的id</span></strong></span></p><p style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">比如我们有一个定义ListView的xml文件，一般的，我们会写类&#20284;下面的代码片段。</span></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"></p><pre name="code" class="html">&lt;ListView    android:id=&quot;@+id/mylist&quot;    android:layout_width=&quot;fill_parent&quot;    android:layout_height=&quot;fill_parent&quot;/&gt;</pre><p></p><p style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">这里我们定义了一个ListView，定义它的id是&quot;@&#43;id/mylist&quot;。实际上，如果没有特别的需求，就可以利用系统定义的id，类&#20284;下面的样子。</span></p><p style="color:rgb(51,51,51); font-family:Arial; line-height:26px"></p><pre name="code" class="html" style="font-size: 14px;">&lt;ListView    android:id=&quot;@android:id/list&quot;    android:layout_width=&quot;fill_parent&quot;    android:layout_height=&quot;fill_parent&quot;/&gt;</pre><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">在xml文件中引用系统的id，只需要加上“@android:”前缀即可。如果是在Java代码中使用系统资源，和使用自己的资源基本上是一样的。不同的是，需要使用android.R类来使用系统的资源，而不是使用应用程序指定的R类。这里如果要获取ListView可以使用android.R.id.list来获取。</span></span><p></p><p style="color:rgb(51,51,51); line-height:26px"><strong><span style="font-family:'Microsoft YaHei'; font-size:14px">2. 利用系统的图片资源</span></strong><br></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="font-size:14px"><span style="font-size:14px">这样做的好处，一个是美工不需要重复的做一份已有的图片了，可以节约不少工时；另一个是能保证我们的应用程序的风&#26684;与系统一致。</span><br></span></p><p style="color:rgb(51,51,51); line-height:26px"><strong><span style="font-family:'Microsoft YaHei'; font-size:14px">3. 利用系统的字符串资源</span></strong></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="font-size:14px">如果使用系统的字符串，默认就已经支持多语言环境了。如上述代码，直接使用了@android:string/yes和@android:string/no，在简体中文环境下会显示“确定”和“取消”，在英文环境下会显示“OK”和“Cancel”。</span></p><p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:'Microsoft YaHei'"><strong><span style="font-size:14px">4. 利用系统的Style</span></strong></span></p><p style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">&nbsp;假设布局文件中有一个TextView，用来显示窗口的标题，使用中等大小字体。可以使用下面的代码片段来定义TextView的Style。</span></p><p style="color:rgb(51,51,51); font-family:Arial; line-height:26px"></p><pre name="code" class="html" style="font-size: 14px;">&lt;TextView        android:id=&quot;@+id/title&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot; /&gt;</pre><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">其中android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;就是使用系统的style。需要注意的是，使用系统的style，需要在想要使用的资源前面加“?android:”作为前缀，而不是“@android:”。</span></span><br><p></p><p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:'Microsoft YaHei'"><strong><span style="font-size:14px">5. 利用系统的颜色定义</span></strong></span><br></p><p style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">除了上述的各种系统资源以外，还可以使用系统定义好的颜色。在项目中最常用的，就是透明色的使用。</span><br></p><p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="font-size:14px"></span></p><pre name="code" class="html">android:background =&quot;@android:color/transparent&quot;</pre><p><br></p><p style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">除了上面介绍的以外还有很多其他Android系统本身自带的资源，它们在应用中都可以直接使用。具体的，可以进入android-sdk的相应文件夹中去查看。例如：可以进入$android-sdk$\platforms\android-8\data\res，里面的系统资源就一览无余了。</span></p><p style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:14px">开发者需要花一些时间去熟悉这些资源，特别是图片资源和各种Style资源，这样在开发过程中，能重用的尽量重用，而且有时候使用系统提供的效果可能会更好。</span></p><div><br></div><br><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:21px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">其他小tips：</span></strong></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px"><span style="font-size:14px"><strong>1.&nbsp;</strong><span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px">分辨率适配</span><span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px">-ldpi,-mdpi, -hdpi配置不同精度资源，系统会根据设备自适应，包括drawable, layout,style等不同资源。</span></span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px"><span style="font-size:14px"><strong>2.</strong>尽量使用dp(density independent pixel)开发，不用px(pixel)。</span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px"><span style="font-size:14px"><strong>3.</strong>多用wrap_content, match_parent</span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px"><span style="font-size:14px"><strong>4.</strong>永远不要使用AbsoluteLayout</span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px"><span style="font-size:14px"><strong>5.</strong>使用9patch（通过~/tools/draw9patch.bat启动应用程序），png&#26684;式</span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px"><span style="font-size:14px"><strong>6.</strong>将Acitivity中的Window的背景图设置为空。getWindow().setBackgroundDrawable(null);android的默认背景是不是为空。</span></p><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px"><span style="font-size:14px"><strong>7.</strong>View中设置缓存属性.setDrawingCache为true。</span></p><br><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><br></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="font-family:Microsoft YaHei; font-size:24px"></span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(153,102,51)"><strong><span style="font-family:Microsoft YaHei; font-size:24px">Desgin Review（设计检查）：</span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:18px">Desgin Review主要侧重检查一下程序的设计是否合理，包括框架的设计，界面的设计，逻辑的设计<span style="font-size:17.77777862548828px">(其实这些东西开发之前就应该想好了)</span>。</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="font-family:Microsoft YaHei; font-size:18px">框架设计：</span></strong></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14px">是否定义了自己的Activity和fragment等常用控件的基类去避免进行重复的工作</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-size:14.44444465637207px">是否有完善的异常处理机制，即使真的出现OOM也不会直接崩溃导致直接退出程序</span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><br></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="font-family:Microsoft YaHei; font-size:18px"><strong>界面设计：</strong></span></p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"></p><p><span style="font-size:14px"><strong>1.</strong>在视图中加载你所需要的，而不是你所拥有。因为用户不可能同时看到所有东西。</span><span style="font-size:14px">最典型的例子就是ListView中的滑动加载。</span></p><p><span style="font-size:14px"><strong>2.</strong>如果数据特别大，此时应该暗示用户去点击加载，而不是直接加载。</span></p><p><strong><span style="font-size:14px">3.</span></strong>合理运用分屏，转屏等，它是个双刃剑，因为它即可以使程序更加美观功能更加完善，但也相应增加了资源开销。</p><p><strong><br></strong></p><p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>逻辑设计：</strong></span></p><p><span style="font-size:14px">避免子类直接去控制父类中内容，可以使用监听等方式去解决</span></p><p><br></p><p><span style="font-size:18px">关于这三点由于我工作经验比较少，加上一时半会也想不出来多少，如果大家有建议希望可以留言，之后我给加进去。</span></p></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; color:rgb(102,51,51); font-family:&#39;Microsoft YaHei&#39;; font-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/awk/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/awk/</id>
    <published>2019-06-14T02:52:59.701Z</published>
    <updated>2019-06-14T02:52:59.701Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Awk是什么</strong></p><p>Awk、sed与grep，俗称Linux下的三剑客，它们之前有很多相似点，但是同样也各有各的特色，相似的地方是它们都可以匹配文本，其中sed和awk还可以用于文本编辑，而grep则不具备这个功用。sed是一种非交互式且面向字符流的编辑器（a &#8220;non-interactive&#8221; stream-oriented editor），而awk则是一门模式匹配的编程语言，因为它的主要功能是用于匹配文本并处理，同时它有一些编程语言才有的语法，例如函数、分支循环语句、变量等等，当然比起我们常见的编程语言，Awk相对比较简单。</p><p>使用Awk，我们可以做以下事情：</p><p>● 将文本文件视为由字段和记录组成的文本数据库；</p><p>● 在操作文本数据库的过程中能够使用变量；</p><p>● 能够使用数学运算和字符串操作；</p><p>● 能够使用常见的编程结构，例如条件分支与循环；</p><p>● 能够格式化输出；</p><p>● 能够自定义函数；</p><p>● 能够在awk脚本中执行UNIX命令；</p><p>● 能够处理UNIX命令的输出结果；</p><p>装备以上功能，awk能够做得事情非常多。但千里之行，始于足下，我们首先从最基本的命令行语法开始，一步一步得走入awk的编程世界。</p><p>&nbsp;</p><p><strong>命令行语法</strong></p><p>同sed一样，awk的命令行语法也有两种形式：</p><pre class="brush: shell; gutter: true">awk [-F ERE] [-v assignment] ... program [argument ...]awk [-F ERE] -f progfile ...  [-v assignment] ...[argument ...]</pre><p>这里的program类似sed中的script，因为我们一直强调awk是一门编程语言，所以将awk的脚本视为一段代码。而awk的脚本同样可以写到一个文件中，并通过-f参数指定，这一点和sed是一样的。program一般多个pattern和action序列组成，当读入的记录匹配pattern时，才会执行相应的action命令。这里有一点要注意，在第一种形式中，除去命令行选项外，program参数一定要位于第一个位置。</p><p>Awk的输入被解析成多个记录（Record），默认情况下，记录的分隔符是\n，因此可以认为一行就是一个记录，记录的分隔符可以通过内置变量<code>RS</code>更改。当记录匹配某个pattern时，才会执行后续的action命令。</p><p>而每个记录由进一步地被分隔成多个字段（Field），默认情况下字段的分隔符是空白符，例如空格、制表符等等，也可以通过<code>-F ERE</code>选项或者内置变量<code>FS</code>更改。在awk中，可以通过$1，$2&#8230;来访问对应位置的字段，同时$0存放整个记录，这一点有点类似shell下的命令行位置参数。关于这些内容，我们会在下面详细介绍，这里你只要知道有这些东西就好。</p><p>标准的awk命令行参数主要由以下三个：</p><p>● <code>-F ERE</code>：定义字段分隔符，该选项的值可以是扩展的正则表达式（ERE）；</p><p>● <code>-f progfile</code>：指定awk脚本，可以同时指定多个脚本，它们会按照在命令行中出现的顺序连接在一起；</p><p>● <code>-v assignment</code>：定义awk变量，形式同awk中的变量赋值，即name=value，赋值发生在awk处理文本之前；</p><p>为了便于理解，这里举几个简单的例子。通过-F参数设置冒号:为分隔符，并打印各个字段：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ echo &quot;1:2:3&quot; | awk -F: &#039;{print $1 &quot; and &quot; $2 &quot; and &quot; $3}&#039;1 and 2 and 3</pre><p>在awk的脚本中访问通过-v选项设置的变量：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ echo | awk -v a=1 &#039;BEGIN {print a}&#039;1</pre><p>从上面可以看到，通过-v选项设置的变量在<code>BEGIN</code>的位置就可以访问了。<code>BEGIN</code>是一个特殊的pattern，它在awk处理输入之前就会执行，可以认为是一个初始化语句，与此对应的还有<code>END</code>。</p><p>好像还没介绍如何指定处理的文件，是不是最后的argument就是指定的文件？在看我这本书之前，我也是这样认为的，但是实际上arguemnt有两种形式，它们分别是输入文件（file）和变量赋值（assignment）。</p><p>awk可以同时指定多个输入文件，如果输入文件的文件名为&#8217;-'，表示从标准输入读取内容。</p><p>变量赋值类似-v选项，它的形式为name=value。awk中的变量名同一般的编程语言无太多区别，但是不能同awk的保留关键字重名，可以查看awk的man手册查询哪些是保留关键字。而变量值只有两种形式：字符串和数值。变量赋值必须位于脚本参数的后面，与文件名参数无先后顺序的要求，但是位于不同位置的赋值它的执行时机是不同的。</p><p>我们用实际的例子来解释这个区别，假设有两个文件：a和b，它们的内容分别如下所示：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ cat afile a[kodango@devops awk_temp]$ cat bfile b</pre><p>为了说明赋值操作发生的时机，我们在BEGIN，正常处理，END三个地方都打印变量的值。</p><p>第一种情况： 变量赋值位于所有文件名参数之前</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN {print &quot;BEGIN: &quot; var} {print &quot;PROCESS: &quot; var} \END {print &quot;END: &quot; var }&#039; var=1 aBEGIN: PROCESS: 1END: 1</pre><p>结果：赋值操作发生在正常处理之前，<code>BEGIN</code>动作之后。</p><p>第二种情况：变量赋值位于所有文件名之后：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN {print &quot;BEGIN: &quot; var} {print &quot;PROCESS: &quot; var} \END {print &quot;END: &quot; var }&#039; a var=1  BEGIN: PROCESS: END: 1</pre><p>结果：赋值操作发生在正常处理之后，<code>END</code>动作之前。</p><p>第三种情况：变量赋值位于文件名之间：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN {print &quot;BEGIN: &quot; var} {print &quot;PROCESS: &quot; var} \END {print &quot;END: &quot; var }&#039; a var=1 bBEGIN: PROCESS: PROCESS: 1END: 1</pre><p>结果：赋值操作发生在处理前面的文件之后，并且位于处理后面的文件之前；</p><p>总结如下：<br>1. 如果变量赋值在第一个文件参数之前，在<code>BEGIN</code>动作之后执行，影响到正常处理和<code>END</code>动作；</p><p>2. 如果变量赋值在最后一个文件参数之后，在END动作之前执行，仅影响<code>END</code>动作；</p><p>3. 如果文件参数不存在，情况同1所述；</p><p>4. 如果变量赋值位于多个文件参数之间，在变量赋值前面的文件被处理后执行，影响到后续文件的处理和<code>END</code>动作；</p><p>所以变量赋值一定要考虑清楚用途，否则比较容易出错，不过一般情况下也不会用到变量赋值。</p><p>自然地大家会将变量赋值与-v assignment选项进行比较，赋值的形式是一致的，但是-v选项的执行时机比变量赋值要早：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ echo 1 | awk -v var=a &#039;BEGIN {print &quot;BEGIN: &quot; var}&#039;BEGIN: a</pre><p>可见，-v选项的赋值操作在<code>BEGIN</code>动作之前就执行了。</p><p>变量赋值一定要小心不要与保留关键字重名，否则会报错：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ echo 1 | awk -v BEGIN=1 &#039;BEGIN {print &quot;BEGIN: &quot; BEGIN}&#039;awk: fatal: cannot use gawk builtin `BEGIN&#039; as variable name</pre><p>&nbsp;</p><p><strong>记录（Record）与字段（Field)</strong></p><p>对于数据库来说，一个数据库表是由多条记录组成的，每一行表示一条记录（Record）。每条记录由多列组成，每一列表示一个字段（Field)。Awk将一个文本文件视为一个文本数据库，因此它也有记录和字段的概念。默认情况下，记录的分隔符是回车，字段的分隔符是空白符，所以文本文件的每一行表示一个记录，而每一行中的内容被空白分隔成多个字段。利用字段和记录，awk就可以非常灵活地处理文件的内容。</p><p>可以通过-F选项来修改默认的字段分隔符，例如/etc/passwd的每一行都是由冒号分隔成多个字段的，所以这里就需要将分隔符设置成冒号：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk -F: &#039;{print $1}&#039; /etc/passwd | head -3rootbindaemon</pre><p>这里通过$1引用第一人字段，类似地$2表示第二个字段，$3表示第三个字段&#8230;. $0则表示整个记录。内置变量NF记录着字段的个数，所以$NF表示最后一个字段：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk -F: &#039;{print $NF}&#039; /etc/passwd | head -3/bin/bash/bin/false/bin/false</pre><p>当然，$(NF-1)表示倒数第二个。</p><p>内置变量FS也可以用于更改字段分隔符，它记录着当前的字段分隔符：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk -F: &#039;{print FS}&#039; /etc/passwd | head -1:[kodango@devops awk_temp]$ awk -v FS=: &#039;{print $1}&#039; /etc/passwd | head -1root</pre><p>记录的分隔符可以通过内置变量RS更改：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk -v RS=: &#039;{print $0}&#039; /etc/passwd | head -1root</pre><p>如果将RS设置成空，行为有就一点怪异了，它会将连续不为空行的所有行（一个段落）当作一个记录，而且强制回车为字段分隔符：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ cat awk_man.txt <p>The awk utility shall execute programs written in the awk programming language,<br>which is specialized for textual data manipulation. An awk program is a sequence<br>of patterns and corresponding actions.  When  input  is  read  that matches a<br>pattern, the action associated with that pattern is carried out.</p><p>Input shall be interpreted as a sequence of records. By default, a record is a line,<br>less its terminating &lt;newline&gt;, but this can be changed by using the RS built-in<br>variable. Each record of input shall be matched in turn against each pattern in the<br>program. For each pattern matched, the associated action shall be executed.</p><p>[kodango@devops awk_temp]$ awk &#039;BEGIN {RS=&quot;&quot;;FS=&quot;:&quot;} {print &quot;First line: &quot; $1}&#039; awk_man.txt<br>First line: The awk utility shall execute programs written in the awk programming language,<br>First line: Input shall be interpreted as a sequence of records. By default, a record is a line,</p></pre><p></p><p>这里，我们将变量赋值放到<code>BEGIN</code>动作中执行，因为<code>BEGIN</code>动作是在文件处理之前执行的，专门用于放初始化的语句。FS的赋值在这里是无效的，awk依然使用回车符来分隔字段。</p><p>&nbsp;</p><p><strong>脚本（Script）组成</strong></p><p>命令行中的program部分，可以称为awk代码,也可以称为awk脚本。一段awk脚本是由多个&#8217;<code>pattern { action }</code>&#8216;序列组成的。action是一个或者多个语句，它在输入行匹配pattern的时候被执行。如果pattern为空，表明这个action会在每一行处理时都会被执行。下面的例子简单地打印文件的每一行，这里不带任何参数的print语句打印的是整个记录，类似&#8217;<code>print $0</code>&#8216;：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ echo -e &#039;line1\nline2&#039; | awk &#039;{print}&#039; line1line2</pre><p>除了<code><code>pattern { action }</code></code>，还可以在脚本中定义自定义的函数，函数定义格式如下所示：</p><pre class="brush: shell; gutter: true">function name(parameter list) { statements }</pre><p>函数的参数列表用逗号分隔，参数默认是局部变量，无法在函数之外访问，而在函数中定义的变量为全局变量，可以在函数之外访问，如：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ echo line1 | awk &#039;function t(a) {    b=a;    print a;} <p>{    print b;<br>    t(&quot;kodango.me&quot;);<br>    print b;<br>}&#039;</p><p>kodango.me<br>kodango.me</p></pre><p></p><p>Awk脚本中的语句使用空行或者分号分隔，使用分号可以放在同一行，不过有时候会影响可读性，尤其是分支或循环结构中，很容易出错。</p><p>如果Awk中的一个语句太长，要分成多行，可以在行为使用反斜杠&#8217;\'：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ cat test.awk <p>function t(a)<br>{    b=a<br>    print &quot;This is a very long line, so use backslash to escape the newline <br>then we will print the variable a: a=&quot; a<br>} </p><p>{ print b; t(&quot;kodango.me&quot;); print b;}<br>[kodango@devops awk_temp]$ echo 1 | awk -f test.awk </p><p>This is a very long line, so use backslash to escape the newline then we will print the variable a: a=kodango.me<br>kodango.me</p></pre><p></p><p>这里我们将脚本写到文件中，并通过-f参数来指定。但是，在一些特殊符号之后，是可以直接换行的，例如&#8221;, { &amp;&amp; ||&#8221;。</p><p>&nbsp;</p><p><strong>模式（Pattern）</strong></p><p>模式是awk中比较重要的一部分，它有以下几种情况：</p><p>● <code>/regular expression/</code>： 扩展的正则表达式（Extended Regular Expression）， 关于ERE可以参考<span class="exturl" data-url="aHR0cDovL3d3dy5pbmZvcS5jb20vY24vbmV3cy8yMDExLzA3L3JlZ3VsYXItZXhwcmVzc2lvbnMtNi1QT1NJWA==" title="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">这篇文章<i class="fa fa-external-link"></i></span>；</p><p>● <code>relational expression</code>： 关系表达式，例如大于、小于、等于，关系表达式结果为true表示匹配；</p><p>● <code>BEGIN</code>： 特殊的模式，在第一个记录处理之前被执行，常用于初始化语句的执行；</p><p>● <code>END</code>： 特殊的模式，在最后一个记录处理之前被执行，常用于输出汇总信息；</p><p>● <code>pattern, pattern</code>：模式对，匹配两者之间的所有记录，类似sed的地址对；</p><p>例如查找匹配数字3的行：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ seq 1 20 | awk &#039;/3/ {print}&#039;313</pre><p>相反地，可以在在正则表达式之前加上&#8217;!'表示不匹配：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ seq 1 5 | awk &#039;!/3/ {print}&#039;1245</pre><p>除了<code>BEGIN</code>和<code>END</code>这两个特殊的模式外，其余的模式都可以使用&#8217;&amp;&amp;&#8217;或者&#8217;||&#8217;运算符组合，前者表示逻辑与，后者表示逻辑或：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ seq 1 50 | awk &#039;/3/ &amp;&amp; /1/ {print}&#039;1331</pre><p>前面的正则都是整行匹配，有时候仅仅需要匹配某个字符，这样我们可以用表达式<code>$n ~ /ere/</code>：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;$1 ~ /ko/ {print}&#039; /etc/passwdkodango:x:1000:1000::/home/kodango:/bin/bash</pre><p>有时候我们只想显示特定和行，例如显示第一行：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ seq 1 5 | awk &#039;NR==1 {print}&#039;1</pre><p>&nbsp;</p><p><strong>正则表达式（Regular Expression）</strong></p><p>和<span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMzEwMjYv" title="http://blog.jobbole.com/31026/">sed篇<i class="fa fa-external-link"></i></span>一样，这里我不会详细介绍正则表达式。因为正则表达式的内容介绍起来太麻烦，还是推荐同学阅读现有的文章（如<span class="exturl" data-url="aHR0cDovL3d3dy5pbmZvcS5jb20vY24vbmV3cy8yMDExLzA3L3JlZ3VsYXItZXhwcmVzc2lvbnMtNi1QT1NJWA==" title="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">Linux/Unix工具与正则表达式的POSIX规范<i class="fa fa-external-link"></i></span>），里面对各个流派的正则表达式归纳地很清楚了。</p><p>&nbsp;</p><p><strong>表达式（Expressions）</strong></p><p>表达式可以由常量、变量、运算符和函数组成，常数和变量的值可以为字符串和数值。</p><p>Awk中的变量有三种类型：用户定义的变量，内置变量和字段变量。其中，内置变量名都是大写的。变量并不非一定要被声明或者被初始化，未初始化的字符串变量的值为&#8221;"，未初始化的数值变量的值为0。字段变量可以用$n来引用，n的取值范围为[0,NF]。n可以为一个变量，例如$NF代码最后一个字段，而$(NF-1)表示倒数第二个字段。</p><p>&nbsp;</p><p><strong>数组</strong></p><p>数组是一种特殊的变量，在awk中，比较特殊地是，数组的下标可以为数字或者字符串。数组的赋值很简单，下面将value赋值给数组下标为index的元素：</p><pre class="brush: shell; gutter: true">array[index]=value</pre><p>可以用for..in..语法遍历数组元素，其中item是数组元素对应的下标：</p><pre class="brush: shell; gutter: true">for (item in array)</pre><p>当然也可以在if分支判断中使用in操作符：</p><pre class="brush: shell; gutter: true">if (item in array)</pre><p>一个完整的例子如下所示：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ echo &quot;1 2 3&quot; | awk &#039;{for (i=0;i&lt;NF;i++)  a[i]=i;}<p>END {<br>print 3 in a<br>for (i in a)<br>   printf &quot;%s: %s\n&quot;, i, a[i];<br>}&#039;<br>00: 0<br>1: 1<br>2: 2</p></pre><p></p><p>&nbsp;</p><p><strong>内置变量</strong></p><p>Awk在内部维护了许多内置变量，或者称为系统变量，例如之前提到的<code>FS</code>、<code>RS</code>等等。常见的内置变量如下表所示</p><table border="1px"><thead><tr><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>ARGC</td><td>命令行参数的各个，即ARGV数组的长度</td></tr><tr><td>ARGV</td><td>存放命令行参数</td></tr><tr><td>CONVFMT</td><td>定义awk内部数值转换成字符串的格式，默认值为&#8221;%.6g&#8221;</td></tr><tr><td>OFMT</td><td>定义输出时数值转换成字符串的格式，默认值为&#8221;%.6g&#8221;</td></tr><tr><td>ENVIRON</td><td>存放系统环境变量的关联数组</td></tr><tr><td>FILENAME</td><td>当前被处理的文件名</td></tr><tr><td>NR</td><td>记录的总个数</td></tr><tr><td>FNR</td><td>当前文件中的记录的总个数</td></tr><tr><td>FS</td><td>字段分隔符，默认为空白</td></tr><tr><td>NF</td><td>每个记录中字段的个数</td></tr><tr><td>RS</td><td>记录的分隔符，默认为回车</td></tr><tr><td>OFS</td><td>输出时字段的分隔符，默认为空白</td></tr><tr><td>ORS</td><td>输出时记录的分隔符，默认为回车</td></tr><tr><td>RLENGTH</td><td>被match函数匹配的子串长度</td></tr><tr><td>RSTART</td><td>被match函数匹配的子串位于目标字符串的起始下标</td></tr></tbody></table><p>&nbsp;</p><p>下面主要介绍几个比较难理解的内置变量：</p><p><strong>1. <code>ARGV</code>与<code>ARGC</code></strong></p><p><code>ARGV</code>与<code>ARGC</code>的意思比较好理解，就像C语言<code>main(int argc, char **argv)</code>。<code>ARGV</code>数组的下标从0开始到<code>ARGC</code>-1，它存放的是命令行参数，并且排除命令行选项（例如-v/-f）以及program部分。因此事实上<code>ARGV</code>只是存储argument的部分，即文件名（file）以及命令行变量赋值两部分的内容。</p><p>通过下面的例子可以大概了解ARGC与ARGV的用法：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$  awk &#039;BEGIN {&gt;     for (i = 0; i &lt; ARGC; i++)&gt;         print ARGV[i]&gt;  }&#039; inventory-shipped BBS-listawkinventory-shippedBBS-list</pre><p><code>ARGV</code>的用法不仅限于此，它是可以修改的，可以更改数组元素的值，可以增加数组元素或者删除数组元素。</p><p>a. 更改<code>ARGV</code>元素的值</p><p>假设我们有a, b两个文件，它们各有一行内容：file a和file b。现在利用ARGV，我们可以做到偷梁换柱：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN{ARGV[1]=&quot;b&quot;} {print}&#039; afile b</pre><p>这里要注意<code>ARGV[1]="b"</code>的引号不能缺少，否则<code>ARGV[1]=b</code>会将变量b的值赋值给<code>ARGV[1]</code>。</p><p>当awk处理完一个文件之后，它会从<code>ARGV</code>的下一个元素获取参数，如果是一个文件则继续处理，如果是一个变量赋值则执行赋值操作：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN{ARGV[1]=&quot;var=1&quot;} {print var}&#039; a b1</pre><p>为什么这里只打印一次变量值呢？可以回头再看看<span class="exturl" data-url="aHR0cDovL2tvZGFuZ28ubWUvc2VkLWFuZC1hd2stbm90ZXMtcGFydC03" title="Sed&amp;awk笔记之awk篇：快速了解Awk（一）">上一篇<i class="fa fa-external-link"></i></span>中介绍变量赋值的内容。</p><p>而当下一个元素为空时，则跳过不处理，这样可以避开处理某个文件：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN{ARGV[1]=&quot;&quot;} {print}&#039; a bfile b</pre><p>上面的例子中a这个文件就被跳过了。</p><p>而当下一个元素的值为&#8221;-&#8221;时，表明从标准输入读取内容：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN{ARGV[1]=&quot;-&quot;} {print}&#039; a baa    # --&gt; 这里按下CTRL+D停止输入file b</pre><p>b. 删除<code>ARGV</code>元素</p><p>删除<code>ARGV</code>元素和将元素的值赋值为空的效果是一样的，它们都会跳转对某个参数的处理：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN{delete ARGV[1]} {print}&#039; a bfile b</pre><p>删除数组元素可以用<code>delete</code>语句。</p><p>c. 增加<code>ARGV</code>元素</p><p>我第一次看到<code>ARGV</code>变量的时候就在想，能不能利用<code>ARGV</code>变量避免提供命令行参数，就像这样:</p><pre class="brush: shell; gutter: true">awk &#039;BEGIN{ARGV[1]=&quot;a&quot;;} {print}&#039;</pre><p>但是事实上这样不行，awk会依然从标准输入中获取内容。下面的方法倒是可以，首先增加<code>ARGC</code>的值，再增加<code>ARGV</code>元素，我到现在也没搞懂这两者的区别：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN{ARGC+=1;ARGV[1]=&quot;a&quot;} {print}&#039;file a</pre><p><strong>2. <code>CONVFMT</code>与<code>OFMT</code></strong></p><p>Awk中允许数值到字符串相互转换，其中内置变量<code>CONVFMT</code>定义了awk内部数值到字符串转换的格式，它的默认值为&#8221;%.6g&#8221;：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN {    printf &quot;CONVFMT=%s, num=%f, str=%s\n&quot;, CONVFMT, 12.11, 12.11}&#039;   CONVFMT=%.6g, num=12.110000, str=12.11</pre><p>通过更改<code>CONVFMT</code>，我们可以定义自己的转换格式：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN {     CONVFMT=&quot;%d&quot;;    printf &quot;CONVFMT=%s, num=%f, str=%s\n&quot;, CONVFMT, 12.11, 12.11 }&#039;  CONVFMT=%d, num=12.110000, str=12</pre><p>与此对应地还有一个内置变量<strong>OFMT</strong>，它与<code>CONVFMT</code>的作用是类似的，只不过是影响输出的时候数字转换成字符串的格式：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN { OFMT=&quot;%d&quot;;print 12.11 }&#039;  12</pre><p><strong>3. <code>ENVIRON</code></strong></p><p><code>ENVIRON</code>是一个存放系统环境变量的关联数组，它的下标是环境变量名称，值是相应环境变量的值。例如：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN { print ENVIRON[&quot;USER&quot;] }&#039;  kodango</pre><p>利用环境变量也可以将值传递给awk：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ U=hello awk &#039;BEGIN { print ENVIRON[&quot;U&quot;] }&#039;  hello</pre><p>可以利用for..in循环遍历<code>ENVIRON</code>数组：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN { for (env in ENVIRON)     printf &quot;%s=%s\n&quot;, env, ENVIRON[env]; }&#039;</pre><p><strong>4. <code>RLENGTH</code>与<code>RSTART</code></strong></p><p><code>RLENGTH</code>与<code>RSTART</code>都是与<code>match</code>函数相关的，前者表示匹配的子串长度，后者表示匹配的子串位于目标字符串的起始下标。例如：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {match(&quot;hello,world&quot;, /llo/); print RSTART,RLENGTH}&#039;3 3</pre><p>关于<code>match</code>函数，我们会在以后介绍。</p><p>&nbsp;</p><p><strong>运算符</strong></p><p>表达式中必然少不了运算符，awk支持的运算符可以参见man手册中的“Expressions in awk”一小节内容：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ man awk | grep &quot;^ *Table: Expressions in&quot; -A 42 | sed &#039;s/^ *//&#039;                                       Table: Expressions in Decreasing Precedence in awk<p>Syntax                Name                      Type of Result   Associativity<br>( expr )              Grouping                  Type of expr     N/A<br>$expr                 Field reference           String           N/A<br>++ lvalue             Pre-increment             Numeric          N/A<br>– lvalue             Pre-decrement             Numeric          N/A<br>lvalue ++             Post-increment            Numeric          N/A<br>lvalue –             Post-decrement            Numeric          N/A<br>expr ^ expr           Exponentiation            Numeric          Right<br>! expr                Logical not               Numeric          N/A</p><ul><li>expr                Unary plus                Numeric          N/A</li></ul><ul><li>expr                Unary minus               Numeric          N/A<br>expr * expr           Multiplication            Numeric          Left</li></ul><p>…以下省略…</p></pre><p></p><pre class="brush: shell; gutter: true"></pre><p><strong>语句（Statement）</strong></p><p>到目前为止，用得比较多的语句就是<code>print</code>，其它的还有<code>printf、delete、break、continue、exit、next</code>等等。这些语句与函数不同的是，它们不会使用带括号的参数，并且没有返回值。不过也有意外，比如<code>printf</code>就可以像函数一样的调用：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ echo 1 | awk &#039;{printf(&quot;%s\n&quot;, &quot;abc&quot;)}&#039;abc</pre><p><code>break</code>和<code>continue</code>语句，大家应该比较了解，分别用于跳出循环和跳到下一个循环。</p><p><code>delete</code>用于删除数组中的某个元素，这个我们在上面介绍<code>ARGV</code>的时候也使用过。</p><p><code>exit</code>的用法顾名思义，就是退出awk的处理，然后会执行<code>END</code>部分的内容：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ echo $&#039;line1\nline2&#039; | awk &#039;{print;exit} END {print &quot;exit..&quot;}&#039; line1exit..</pre><p><code>next</code>语句类似sed的n命令，它会读取下一条记录，并重新回到脚本的最开始处执行：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ echo $&#039;line1\nline2&#039; | awk &#039;{&gt; print &quot;Before next..&quot;&gt; print $0 &gt; next&gt; print &quot;After next..&quot;&gt; }&#039;Before next..line1Before next..line2</pre><p>从上面可以看出<code>next</code>后面的print语句不会执行。</p><p>print与printf语句是使用最多的，它们将内容输出到标准输出。注意在print语句中，输出的变量之间带不带逗号是有区别的：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ echo &quot;1 2&quot; | awk &#039;{print $1, $2}&#039;1 2[kodango@devops awk_temp]$ echo &quot;1 2&quot; | awk &#039;{print $1 $2}&#039;12</pre><p>print输出时，字段之间的分隔符可以由OFS重新定义：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ echo &quot;1 2&quot; | awk &#039;{OFS=&quot;;&quot;;print $1,$2}&#039;1;2</pre><p>除此之外，print的输出还可以重定向到某个文件中或者某个命令：</p><pre class="brush: shell; gutter: true">print items &gt; output-fileprint items &gt;&gt; output-fileprint items | command</pre><p>假设有这一样一个文件，第一列是语句名称，第二列是对应的说明：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ cat column.txt statement|descriptiondelete|delete item from an arrayexit|exit from the awk processnext|read next input record and process</pre><p>现在我们要将两列的内容分别输出到statement.txt和description.txt两个文件中：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk -F&#039;|&#039; &#039;{&gt; print $1 &gt; &quot;statement.txt&quot;;&gt; print $2 &gt; &quot;description.txt&quot;&gt; }&#039; column.txt [kodango@devops awk_temp]$ cat statement.txt statementdeleteexitnext[kodango@devops awk_temp]$ cat description.txt descriptiondelete item from an arrayexit from the awk processread next input record and process</pre><p>下面是一个重定向到命令的例子，假设我们要对下面的文件进行排序：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ cat num.list 13295</pre><p>可以通过将print的内容重定向到&#8221;sort -n&#8221;命令：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;{print | &quot;sort -n&quot;}&#039; num.list 12359</pre><p>printf命令的用法与print类似，也可以重定向到文件或者输出，只不过printf比print多了格式化字符串的功能。printf的语法也大多数语言包括bash的printf命令类似，这里就不多介绍了。</p><p>awk的函数分成数学函数、字符串函数、I/O处理函数以及用户自定义的函数，其中用户自定义的函数我们在<span class="exturl" data-url="aHR0cDovL2tvZGFuZ28ubWUvc2VkLWFuZC1hd2stbm90ZXMtcGFydC04" title="Sed&amp;awk笔记之awk篇：快速了解Awk（二）">上一篇<i class="fa fa-external-link"></i></span>中也有简单的介绍，下面我们一一来介绍这几类函数。</p><p>&nbsp;</p><p><strong>数学函数</strong></p><p>awk中支持以下数学函数：</p><p>● <code>atan2(y,x)</code>：反正切函数；</p><p>● <code>cos(x)</code>：余弦函数；</p><p>● <code>sin(x)</code>：正弦函数；</p><p>● <code>exp(x)</code>：以自然对数e为底指数函数；</p><p>● <code>log(x)</code>：计算以e 为底的对数值；</p><p>● <code>sqrt(x)</code>：绝对值函数；</p><p>● <code>int(x)</code>：将数值转换成整数；</p><p>● <code>rand()</code>：返回0到1的一个随机数值，不包含1；</p><p>● <code>srand([expr])</code>：设置随机种子，一般与rand函数配合使用，如果参数为空，默认使用当前时间为种子；</p><p>例如，我们使用<code>rand()</code>函数生成一个随机数值：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN {print rand(),rand();}&#039;0.237788 0.291066[kodango@devops awk_temp]$ awk &#039;BEGIN {print rand(),rand();}&#039;0.237788 0.291066</pre><p>但是你会发现，每次awk执行都会生成同样的随机数，但是在一次执行过程中产生的随机数又是不同的。因为每次awk执行都使用了同样的种子，所以我们可以用<code>srand()</code>函数来设置种子:</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN {srand();print rand(),rand();}&#039;0.171625 0.00692412[kodango@devops awk_temp]$ awk &#039;BEGIN {srand();print rand(),rand();}&#039;0.43269 0.782984</pre><p>这样每次生成的随机数就不一样了。</p><p>利用<code>rand()</code>函数我们也可以生成1到n的整数：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;&gt; function randint(n) { return int(n*rand()); }&gt; BEGIN { srand(); print randint(10);&gt; }&#039;3</pre><p><strong>字符串函数</strong></p><p>awk中包含大多数常见的字符串操作函数。</p><p><strong>1. <code>sub(ere, repl[, in])</code></strong></p><p>描述：简单地说，就是将in中匹配ere的部分替换成repl，返回值是替换的次数。如果in参数省略，默认使用$0。替换的动作会直接修改变量的值。</p><p>下面是一个简单的替换的例子：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ echo &quot;hello, world&quot; | awk &#039;{print sub(/ello/, &quot;i&quot;); print}&#039;1hi, world</pre><p>在repl参数中&amp;是一个元字符，它表示匹配的内容，例如：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {var=&quot;kodango&quot;; sub(/kodango/, &quot;hello, &amp;&quot;, var); print var}&#039;hello, kodango</pre><p><strong>2. <code>gsub(ere, repl[, in])</code></strong></p><p>描述：同<code>sub()</code>函数功能类似，只不过是<code>gsub()</code>是全局替换，即替换所有匹配的内容。</p><p><strong>3. <code>index(s, t)</code></strong></p><p>描述：返回字符串t在s中出现的位置，注意这里位置是从1开始计算的，如果没有找到则返回0。</p><p>例如：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {print index(&quot;kodango&quot;, &quot;o&quot;)}&#039;2[kodango@devops ~]$ awk &#039;BEGIN {print index(&quot;kodango&quot;, &quot;w&quot;)}&#039;0</pre><p><strong>4. <code>length[([s])]</code></strong></p><p>描述：返回字符串的长度，如果参数s没有指定，则默认使用$0作为参数。</p><p>例如：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {print length(&#039;kodango&#039;);}&#039;0[kodango@devops ~]$ echo &quot;first line&quot; | awk &#039;{print length();}&#039;10</pre><p><strong>5. <code>match(s, ere)</code></strong></p><p>描述： 返回字符串s匹配ere的起始位置，如果不匹配则返回0。该函数会定义<code>RSTART</code>和<code>RLENGTH</code>两个内置变量。<code>RSTART</code>与返回值相同，<code>RLENGTH</code>记录匹配子串的长度，如果不匹配则为-1。</p><p>例如：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {print match(&quot;kodango&quot;, /dango/);printf &quot;Matched at: %d, Matched substr length: %d\n&quot;, RSTART, RLENGTH;}&#039;3Matched at: 3, Matched substr length: 5</pre><p><strong>6. <code>split(s, a[, fs])</code></strong></p><p>描述：将字符串按照分隔符fs，分隔成多个部分，并存到数组a中。注意，存放的位置是从第1个数组元素开始的。如果fs为空，则默认使用FS分隔。函数返回值分隔的个数。</p><p>例如：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {&gt; split(&quot;1;2;3;4;5&quot;, arr, &quot;;&quot;)&gt; for (i in arr)&gt;     printf &quot;arr[%d]=%d\n&quot;, i, arr[i];&gt; }&#039;arr[4]=4arr[5]=5arr[1]=1arr[2]=2arr[3]=3</pre><p>这里有一个奇怪的地方是for..in..输出的数组不是按顺序输出的，如果要按顺序输出可以用常规的for循环:</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {&gt; split(&quot;1;2;3;4;5&quot;, arr, &quot;;&quot;)&gt; for (i=0;^C[kodango@devops ~]$ awk &#039;BEGIN {&gt; n=split(&quot;1;2;3;4;5&quot;, arr, &quot;;&quot;)&gt; for (i=1; i&lt;=n; i++)&gt;     printf &quot;arr[%d]=%d\n&quot;, i, arr[i];&gt; }&#039;arr[1]=1arr[2]=2arr[3]=3arr[4]=4arr[5]=5</pre><p><strong>7. <code>sprintf(fmt, expr, expr, ...)</code></strong></p><p>描述：类似printf，只不过不会将格式化后的内容输出到标准输出，而是当作返回值返回。</p><p>例如：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {&gt; var=sprintf(&quot;%s=%s&quot;, &quot;name&quot;, &quot;value&quot;)&gt; print var&gt; }&#039;name=value</pre><p><strong>8. <code>substr(s, m[, n])</code></strong></p><p>描述：返回从位置m开始的，长度为n的子串，其中位置从1开始计算，如果未指定n或者n值大于剩余的字符个数，则子串一直到字符串末尾为止。</p><p>例如：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN { print substr(&quot;kodango&quot;, 2, 3); }&#039;oda[kodango@devops ~]$ awk &#039;BEGIN { print substr(&quot;kodango&quot;, 2); }&#039;odango</pre><p><strong>9. <code>tolower(s)</code></strong></p><p>描述：将字符串转换成小写字符。</p><p>例如：</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {print tolower(&quot;KODANGO&quot;);}&#039;kodango</pre><p><strong>10. <code>toupper(s)</code></strong></p><p>描述：将字符串转换成大写字符。</p><p>例如</p><pre class="brush: shell; gutter: true">[kodango@devops ~]$ awk &#039;BEGIN {print tolower(&quot;kodango&quot;);}&#039;KODANGO</pre><p>&nbsp;</p><p><strong>I/O处理函数</strong></p><p><strong>1. <code>getline</code></strong></p><p><code>getline</code>的用法相对比较复杂，它有几种不同的形式。不过它的主要作用就是从输入中每次获取一行输入。</p><p>a. <code>expression | getline [var]</code></p><p>这种形式将前面管道前命令输出的结果作为<code>getline</code>的输入，每次读取一行。如果后面跟有var，则将读取的内容保存到var变量中，否则会重新设置$0和<code>NF</code>。</p><p>例如，我们将上面的statement.txt文件的内容显示作为<code>getline</code>的输入：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN { while(&quot;cat statement.txt&quot; | getline var) print var}&#039; statementdeleteexitnext</pre><p>上面的例子中命令要用双引号，&#8221;<code>cat statement.txt</code>&#8220;，这一点同<code>print/printf</code>是一样的。</p><p>如果不加var，则直接写到$0中，注意<code>NF</code>值也会被更新：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN { while(&quot;cat statement.txt&quot; | getline) print $0,NF}&#039; statement 1delete 1exit 1next 1</pre><p>b. <code>getline [var]</code></p><p>第二种形式是直接使用<code>getline</code>，它会从处理的文件中读取输入。同样地，如果var没有，则会设置$0，并且这时候会更新<code>NF</code>, <code>NR</code>和<code>FNR</code>：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;{      &gt; while (getline) &gt;    print NF, NR, FNR, $0;&gt; }&#039; statement.txt1 2 2 delete1 3 3 exit1 4 4 next</pre><p>c. <code>getline [var] &lt; expression</code></p><p>第三种形式从expression中重定向输入，与第一种方法类似，这里就不加赘述了。</p><p><strong>2. <code>close</code></strong></p><p><code>close</code>函数可以用于关闭已经打开的文件或者管道，例如<code>getline</code>函数的第一种形式用到管道，我们可以用<code>close</code>函数把这个管道关闭，<code>close</code>函数的参数与管道的命令一致：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN {while(&quot;cat statement.txt&quot; | getline) {   print $0;   close(&quot;cat statement.txt&quot;);}}&#039;statementstatementstatementstatementstatement</pre><p>但是每次读了一行后，关闭管道，然后重新打开又重新读取第一行就死循环了。所以要慎用，一般情况下也很少会用到<code>close</code>函数。</p><p><strong>3. <code>system</code></strong></p><p>这个函数很简单，就是用于执行外部命令，例如：</p><pre class="brush: shell; gutter: true">[kodango@devops awk_temp]$ awk &#039;BEGIN {system(&quot;uname -r&quot;);}&#039;3.6.2-1-ARCH</pre><p>&nbsp;</p><p><strong>结束语</strong></p><p>快速了解Awk系列的几篇文章相对比较粗糙，我是参考Awk的man手册以及《Sed &amp; Awk》附录B总结而成的，但是应该可以让大家对awk有一个大致的了解，欢迎大家一起交流。</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Awk是什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Awk、sed与grep，俗称Linux下的三剑客，它们之前有很多相似点，但是同样也各有各的特色，相似的地方是它们都可以匹配文本，其中sed和awk还可以用于文本编辑，而grep则不具备这个功用。sed是一种非交
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/android-memory-prof1/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/android-memory-prof1/</id>
    <published>2019-06-14T02:52:59.697Z</published>
    <updated>2019-06-14T02:52:59.697Z</updated>
    
    <content type="html"><![CDATA[<div style="text-align:justify"><span style="font-family:SimSun; font-size:14px">RAM（random access memory）随机存取存储器。说白了就是内存。</span></div><p style="margin-top:10px; margin-bottom:10px; padding-top:0px; padding-bottom:0px"><span style="font-family:SimSun; font-size:14px">一般Java在内存分配时会涉及到以下区域：</span></p><p style="margin-top:10px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); text-indent:28px; line-height:28px; background-color:rgb(248,248,248)"></p><p style="margin-top:10px; margin-bottom:10px; padding-top:0px; padding-bottom:0px"><span style="font-family:SimSun; font-size:14px"><strong>寄存器（Registers）：</strong><span style="line-height:25.200000762939453px">速度最快的存储场所，因为寄存器位于处理器内部<strong>，</strong></span>我们在程序中无法控制</span></p><p style="margin-top:10px; margin-bottom:10px; padding-top:0px; padding-bottom:0px"><span style="font-family:SimSun; font-size:14px"><strong>栈（Stack）：</strong>存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中</span></p><p style="margin-top:10px; margin-bottom:10px; padding-top:0px; padding-bottom:0px"><span style="font-family:SimSun; font-size:14px"><strong>堆（Heap）：</strong>堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器（GC）来管理。</span></p><p style="margin-top:10px; margin-bottom:10px; padding-top:0px; padding-bottom:0px"><span style="font-family:SimSun; font-size:14px"><strong>静态域（static field）：</strong><span style="line-height:25.200000762939453px">&nbsp; 静态存储区域就是指在固定的位置存放应用程序运行时一直存在的数据，Java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量如静态的数据变量</span></span></p><p style="margin-top:10px; margin-bottom:10px; padding-top:0px; padding-bottom:0px"><span style="font-family:SimSun; font-size:14px"><strong>常量池（constant pool）：</strong><span style="line-height:25.200000762939453px">虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和floating point常量）和对其他类型，字段和方法的符号引用。</span></span></p><p style="margin-top:10px; margin-bottom:10px; padding-top:0px; padding-bottom:0px"><span style="font-family:SimSun; font-size:14px"><strong>非RAM存储：</strong>硬盘等永久存储空间</span></p><p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:SimSun; font-size:14px"></span></p><p><strong><span style="font-family:Microsoft YaHei; font-size:18px; color:#cc6600"><br></span></strong></p><p><strong><span style="font-family:Microsoft YaHei; font-size:18px; color:#cc6600">堆栈特点对比：</span></strong></p><p><span style="text-indent:28px"><span style="font-family:SimSun; font-size:14px">由于篇幅原因，下面只简单的介绍一下堆栈的一些特性。<br></span></span></p><p><span style="font-family:SimSun; font-size:14px"><span style="text-indent:28px"><span style="color:#6666cc"><strong>栈</strong>：当定义一个变量时，Java就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</span></span><br></span></p><p><span style="color:#663333"><span style="font-family:SimSun; font-size:14px"><strong>堆</strong>：当堆中的new产生数组和对象超出其作用域后，它们不会被释放，只有在没有引用变量指向它们的时候才变成垃圾，不能再被使用。即使这样，所占内存也不会立即释放，而是等待被垃圾回收器收走。这也是Java比较占内存的原因。</span></span></p><p><span style="font-family:SimSun; font-size:14px"><br></span></p><p><span style="color:#6666cc"><span style="font-family:SimSun; font-size:14px"><strong>栈</strong>：<span style="text-indent:28px">存取速度比堆要快，仅次于寄存器。</span><span style="text-indent:28px">但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</span></span></span></p><p><span style="text-indent:28px"><span style="color:#663333"><span style="font-family:SimSun; font-size:14px"><strong>堆</strong>：<span style="text-indent:28px">堆是一个运行时数据区，<span style="text-indent:28px">可以动态地分配内存大小，因此<span style="text-indent:28px">存取速度较慢。</span>也正因为这个特点，堆的<span style="text-indent:28px">生存期不必事先告诉编译器，而且</span>Java的垃圾收集器会自动收走这些不再使用的数据。</span></span></span></span></span></p><p><span style="font-family:SimSun; font-size:14px"><br></span></p><p><span style="text-indent:28px"><span style="text-indent:28px"><span style="text-indent:28px"><span style="color:#6666cc"><span style="font-family:SimSun; font-size:14px"><strong>栈</strong>：<span style="text-indent:28px">栈中的数据可以共享，<span style="text-indent:28px">&nbsp;它是由编译器完成的，有利于节省空间。</span></span></span></span></span></span></span></p><p><span style="text-indent:28px"><span style="text-indent:28px"><span style="text-indent:28px"><span style="text-indent:28px"><span style="color:#6666cc"><span style="font-family:SimSun; font-size:14px">例如：需要定义两个变量<span style="text-indent:28px">int a = 3；</span><span style="text-indent:28px">int b = 3；</span></span></span></span></span></span></span></p><p><span style="color:#6666cc"><span style="font-family:SimSun; font-size:14px"><span style="text-indent:28px"><span style="text-indent:28px"><span style="text-indent:28px"><span style="text-indent:28px"></span></span></span></span><span style="text-indent:28px">编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个&#20540;，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个&#20540;，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再</span>让<span style="text-indent:28px">a=4；那么编译器会重新搜索栈中是否有4&#20540;，如果没有，则将4存放进来，并让a指向4；如果已经有了，则直接将a指向这个地址。因此a&#20540;的改变不会影响到b的&#20540;。</span></span></span></p><p><span style="text-indent:28px"><span style="text-indent:28px"><span style="color:#663333"><span style="font-family:SimSun; font-size:14px"><strong>堆</strong>：<span style="text-indent:28px">例如上面栈中a的修改并不会影响到b, 而在堆中一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。</span></span></span></span></span></p><p><span style="text-indent:28px"><br></span></p><p><span style="text-indent:28px"><span style="font-family:Microsoft YaHei; font-size:18px; color:#cc6600"><strong>内存耗用名词解析：</strong></span></span></p><p><span style="text-indent:28px"><strong>VSS</strong></span><span style="text-indent:28px"><strong>&nbsp;</strong>- Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</span></p><p><span style="text-indent:28px"><strong>RSS</strong></span><span style="text-indent:28px"><strong>&nbsp;</strong>- Resident Set Size 实际使用物理内存（包含共享库占用的内存）</span></p><p><span style="text-indent:28px"><strong>PSS</strong></span><span style="text-indent:28px"><strong>&nbsp;</strong>- Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）</span></p><p><span style="text-indent:28px"><strong>USS</strong></span><span style="text-indent:28px"><strong>&nbsp;</strong>- Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）</span></p><p><span style="text-indent:28px">一般来说内存占用大小有如下规律：VSS &gt;= RSS &gt;= PSS &gt;= USS<br></span></p><p><span style="text-indent:28px"><span style="text-indent:28px"><br></span></span></p><p><span style="text-indent:28px"><span style="text-indent:28px"></span></span></p><p><strong><span style="font-family:Microsoft YaHei; font-size:24px; color:#cc0000">OOM：</span></strong></p><p><br></p><p><span style="font-family:Microsoft YaHei; font-size:18px; color:#cc6600"><strong>内存泄露可以引发很多的问题：</strong></span></p><p>1.程序卡顿，响应速度慢（内存占用高时JVM虚拟机会频繁触发GC）</p><p>2.莫名消失（当你的程序所占内存越大，它在后台的时候就越可能被干掉。反之内存占用越小，在后台存在的时间就越长）</p><p>3.直接崩溃（OutOfMemoryError）</p><p style="border-width:0px; padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:8px; list-style:none"><br></p><p><span style="font-family:Microsoft YaHei; font-size:18px; color:#cc6600"><strong>ANDROID内存面临的问题：</strong></span></p><p></p><p>1.有限的堆内存，原始只有16M</p><p>2.内存大小消耗等根据设备，操作系统等级，屏幕尺寸的不同而不同</p><p>3.程序不能直接控制</p><p>4.支持后台多任务处理（multitasking）</p><p>5.运行在虚拟机之上</p><p></p><p><span style="font-family:Microsoft YaHei; font-size:24px; color:#cc0000"><strong><br></strong></span></p><p><span style="font-family:Microsoft YaHei; font-size:24px; color:#cc0000"><strong></strong></span></p><p><span style="font-family:'Microsoft YaHei'; font-size:24px; color:rgb(204,0,0)"><strong>5R：</strong></span></p><p><span style="font-family:'Microsoft YaHei'; font-size:14px">本文主要通过如下的5R方法来对ANDROID内存进行优化：</span></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">1.Reckon（计算）</span></strong></p><p><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>首先需要知道你的app所消耗内存的情况，知己知彼才能百战不殆</span></span></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">2.Reduce（减少）</span></strong></p><p><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>消耗更少的资源</span></span></p><p><span style="font-size:14px"></span></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">3.Reuse（重用）</span></strong></p><p><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>当第一次使用完以后，尽量给其他的使用</span></span></p><p></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px; color:rgb(204,102,0)">5.Recycle（回收）</span></strong></p><p><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>返回资源</span></span></p><p><strong><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(204,102,0)">4.Review（检查）</span><br></span></strong></p><p><span style="white-space:pre"><span style="font-size:14px"><span style="font-family:'Microsoft YaHei'">回顾检查你的程序，看看设计或代码有什么不合理的地方。</span></span></span></p><p><span style="font-size:14px"><span style="font-family:Microsoft YaHei"></span></span></p><p><br></p><p><strong><span style="color:rgb(204,0,0)"><span style="font-family:Microsoft YaHei; font-size:24px">Reckon （计算）：</span></span></strong></p><p><span style="font-family:SimSun; font-size:14px">了解自己应用的内存使用情况是很有必要的。如果当内存使用过高的话就需要对其进行优化，因为更少的使用内存可以减少ANDROID系统终止我们的进程的几率，也可以提高多任务执行效率和体验效果。</span></p><p><span style="font-family:SimSun; font-size:14px">下面从系统内存（system ram）和堆内存(heap)两个方面介绍一些查看和计算内存使用情况的方法：</span></p><p><span style="font-family:SimSun; font-size:14px"><br></span></p><p><strong><span style="font-family:'Microsoft YaHei'; font-size:18px"><span style="color:#cc6600">System Ram(系统内存)：</span></span></strong><br></p><p>观察和计算系统内存使用情况，可以使用Android提供给我们的两个工具<span style="text-indent:16px"><strong>procstats</strong>，<strong>meminfo</strong></span>。他们一个侧重于后台的内存使用，另一个是运行时的内存使用。</p><p></p><h1 style="margin:0px 0px 5px; line-height:1.5em; color:rgb(51,51,51)"><span style="font-family:Microsoft YaHei; font-size:18px">Process Stats:&nbsp;</span></h1><div><span style="text-indent:16px">Android 4.4 KitKat&nbsp;提出了一个新系统服务，叫做procstats。它将帮助你更好的理解你app在后台（background）时的内存使用情况。</span></div><div><span style="text-indent:16px">Procstats可以去监视你app在一段时间的行为，包括在后台运行了多久，并在此段时间使用了多少内存。从而帮助你快速的找到应用中不效率和不规范的地方去避免影响其performs，尤其是在低内存的设备上运行时。</span></div><div><span style="text-indent:16px">你可以通过adb shell命令去<span style="text-indent:16px">使用procstats（<span style="color:#ff0000; background-color:rgb(255,255,204)">adb shell dumpsys procstats --hours 3</span>）</span>，或者更方便的方式是运行Process Stats开发者工具（在4.4版本的手机中点击<span style="text-indent:16px">Settings &gt; Developer options &gt; Process Stats</span>）</span></div><div><span style="text-indent:16px"><span style="font-family:SimSun; font-size:14px"><img src="http://img.blog.csdn.net/20140811223043097?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br></span></span></div><div><span style="text-indent:16px">点击单个条目还可以查看详细信息</span></div><div><span style="font-family:SimSun; font-size:14px"><br></span></div><div><strong><span style="font-size:18px">meminfo：</span></strong><br></div><div>Android还提供了一个工具叫做meminfo。<span style="text-indent:16px">它是根据PSS标准 （Proportional Set Size——实际物理内存）计算每个进程的内存使用并且按照重要程度排序。</span></div><div>你可以通过命令行去执行它：（<span style="color:#ff0000; background-color:rgb(255,255,153)">adb shell dumpsys meminfo</span>）或者使用在设备上点击Settings &gt; Apps &gt; Running（与Procstats不用，它也可以在老版本上运行）</div><div><span style="line-height:26px"><span style="font-family:SimSun; font-size:14px"><img src="http://img.blog.csdn.net/20140811223419281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br></span></span></div><div><span style="line-height:26px"><span style="font-family:SimSun; font-size:14px">更多关于<span style="text-indent:16px"><strong>Procstats</strong>和<strong>meninfo</strong></span>的介绍可以参考我翻译的一篇文章：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MC9hcnRpY2xlL2RldGFpbHMvMzgzOTAxMzU=" title="http://blog.csdn.net/a396901990/article/details/38390135">Process Stats:了解你的APP如何使用内存<i class="fa fa-external-link"></i></span></span></span></div><p><span style="font-family:SimSun; font-size:14px"><br></span></p><p><span style="font-family:'Microsoft YaHei'; font-size:18px"><strong><span style="color:#cc6600">Heap（堆内存）：</span></strong></span></p><p><span style="text-indent:2em">在程序中可以使用如下的方法去查询内存使用情况</span></p><p><span style="text-indent:2em"><br></span></p><p><span style="text-indent:2em"><strong><span style="font-size:18px">ActivityManager#getMemoryClass()</span></strong></span></p><p><span style="text-indent:2em">查询可用堆内存的限制</span></p><p><span style="text-indent:2em">3.0(HoneyComb)以上的版本可以通过largeHeap=“true”来申请更多的堆内存（不过这算作“作弊”）</span></p><p><span style="font-family:SimSun; font-size:14px"><br></span></p><p></p><div><span style="font-size:18px"><strong>ActivityManager#getMemoryInfo(ActivityManager.MemoryInfo)</strong></span></div><div>得到的MemoryInfo中可以查看如下Field的属性：<br></div><div>availMem:表示系统剩余内存</div><div>lowMemory：它是boolean&#20540;，表示系统是否处于低内存运行</div><div>hreshold：它表示当系统剩余内存低于好多时就看成低内存运行</div><br><p></p><p><strong><span style="font-size:18px"><span style="word-wrap:normal; word-break:normal">android.os.Debug#</span><span style="word-wrap:normal; word-break:normal">getMemoryInfo(Debug.MemoryInfo memoryInfo</span><span style="word-wrap:normal; word-break:normal">)</span></span></strong></p><p>得到的MemoryInfo中可以查看如下Field的属性：</p><p></p><div style="color:rgb(54,46,43); font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px; line-height:21px"><span style="word-wrap:normal; word-break:normal">dalvikPrivateDirty</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,51,102)">：&nbsp;<wbr></span><span style="word-wrap:normal; word-break:normal; color:rgb(0,0,128)">The private dirty pages used by dalvik。</span></div><div style="color:rgb(54,46,43); font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px; line-height:21px"><span style="word-wrap:normal; word-break:normal">dalvikPss</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,51,102)">&nbsp;<wbr>：</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,0,128)">The proportional set size for dalvik.</span></div><div style="color:rgb(54,46,43); font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px; line-height:21px"><span style="word-wrap:normal; word-break:normal">dalvikSharedDirty&nbsp;<wbr></span><span style="word-wrap:normal; word-break:normal; color:rgb(0,51,102)">：</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,0,128)">The shared dirty pages used by dalvik.</span></div><div style="color:rgb(54,46,43); font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px; line-height:21px"><span style="word-wrap:normal; word-break:normal">nativePrivateDirty</span>&nbsp;<wbr><span style="word-wrap:normal; word-break:normal">：</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,0,128)">The private dirty pages used by the&nbsp;<wbr></span><span style="word-wrap:normal; word-break:normal; color:rgb(255,102,0)">native heap</span><span style="word-wrap:normal; word-break:normal; color:rgb(153,51,0)">.</span></div><div style="color:rgb(54,46,43); font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px; line-height:21px"><span style="word-wrap:normal; word-break:normal">nativePss</span>&nbsp;<wbr><span style="word-wrap:normal; word-break:normal">：</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,0,128)">The proportional set size for the native heap.</span></div><div style="color:rgb(54,46,43); font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px; line-height:21px"><span style="word-wrap:normal; word-break:normal">nativeSharedDirty</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,51,102)">&nbsp;<wbr>：</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,0,128)">The shared dirty pages used by the&nbsp;<wbr></span><span style="word-wrap:normal; word-break:normal; color:rgb(255,102,0)">native heap.</span></div><div style="color:rgb(54,46,43); font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px; line-height:21px"><span style="word-wrap:normal; word-break:normal">otherPrivateDirty</span>&nbsp;<wbr><span style="word-wrap:normal; word-break:normal">：</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,0,128)">The private dirty pages used by everything else.</span></div><div style="color:rgb(54,46,43); font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px; line-height:21px"><span style="word-wrap:normal; word-break:normal">otherPss</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,51,102)">&nbsp;<wbr>：</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,0,128)">The proportional set size for everything else.</span></div><div style="color:rgb(54,46,43); font-family:Arial,sans-serif,Helvetica,Tahoma; font-size:14px; line-height:21px"><span style="word-wrap:normal; word-break:normal">otherSharedDirty</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,51,102)">&nbsp;<wbr>：</span><span style="word-wrap:normal; word-break:normal; color:rgb(0,0,128)">The shared dirty pages used by everything else.</span></div><p></p><p><span style="word-wrap:normal; word-break:normal"></span></p><div><span style="word-wrap:normal; word-break:normal"></span></div><div><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">dalvik</span><span style="word-wrap:normal; word-break:normal">：</span><span style="word-wrap:normal; word-break:normal">是指</span></span></span><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">dalvik所使用的内存</span><span style="word-wrap:normal; word-break:normal">。</span></span></span></div><div><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">native</span><span style="word-wrap:normal; word-break:normal">：</span><span style="word-wrap:normal; word-break:normal">是被native堆使用的内存。应该指使用C\C&#43;&#43;在堆上分配的</span></span></span><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">内存</span><span style="word-wrap:normal; word-break:normal">。</span></span></div><div><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">other:</span><span style="word-wrap:normal; word-break:normal">是指除</span></span><span style="word-wrap:normal; word-break:normal">dalvik和</span><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">native使用的内存。但是具体是指什么呢？至少包括在C\C&#43;&#43;分配的非堆内存，比如分配在栈上的内存。</span></span></div><div><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">private</span>:</span><span style="word-wrap:normal; word-break:normal">是指私有的。非共享的。</span></span></div><div><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">share</span>:</span><span style="word-wrap:normal; word-break:normal">是指共享的内存</span><span style="word-wrap:normal; word-break:normal">。</span></span></div><div><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">PSS</span>：</span><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">实际使用的物理内存（比例分配共享库占用的内存）</span></span></div><div><div><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">&nbsp;<wbr>PrivateDirty</span></span>：<span style="word-wrap:normal; word-break:normal">它是指非共享的，又不能换页出去（</span></span><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">can not be paged to disk&nbsp;<wbr></span><span style="word-wrap:normal; word-break:normal">）的内存的大小。比如Linux为了提高分配内存速度而缓冲的小对象，即使你的进程结束，该内存也不会释放掉，它只是又重新回到缓冲中而已。</span></span></div><div><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">SharedDirty:参照</span></span><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">PrivateDirty</span><span style="word-wrap:normal; word-break:normal">我认为</span></span><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">它应该是指共享的，又不能换页出去（</span></span><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal">can not be paged to disk&nbsp;<wbr></span><span style="word-wrap:normal; word-break:normal">）的内存的大小。比如Linux为了提高分配内存速度而缓冲的小对象，即使所有共享它的进程结束，该内存也不会释放掉，它只是又重新回到缓冲中而已。</span></span></div></div><div><span style="word-wrap:normal; word-break:normal"><span style="word-wrap:normal; word-break:normal"><br></span></span></div><p></p><p><strong><span style="font-size:18px">android.os.Debug#getNativeHeapSize()</span></strong></p><p>返回的是当前进程navtive堆本身总的内存大小</p><p><strong><span style="font-size:18px">android.os.Debug#getNativeHeapAllocatedSize()</span></strong></p><p>返回的是当前进程navtive堆中已使用的内存大小</p><p><strong><span style="font-size:18px">android.os.Debug#getNativeHeapFreeSize()</span></strong><br></p><p>返回的是当前进程navtive堆中已经剩余的内存大小</p><p><br></p><p></p><p><strong><span style="font-size:18px">Memory Analysis Tool（MAT）：</span></strong></p><p>通常内存泄露分析被认为是一件很有难度的工作，一般由团队中的资深人士进行。不过，今天我们要介绍的 MAT（Eclipse Memory Analyzer）被认为是一个“傻瓜式“的堆转储文件分析工具，你只需要轻轻点击一下鼠标就可以生成一个专业的分析报告。</p><p>如下图：<br></p><p><img src="http://img.blog.csdn.net/20140814225714406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br></p><p>关于详细的MAT使用我推荐下面这篇文章：<span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL29wZW5zb3VyY2Uvb3MtY24tZWNsLW1hL2luZGV4Lmh0bWw=" title="http://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/index.html">使用 Eclipse Memory Analyzer 进行堆转储文件分析<i class="fa fa-external-link"></i></span></p><p><br></p><p><br></p><p><span style="font-family:Microsoft YaHei; font-size:24px; color:#cc0000"><strong>写在最后：</strong></span></p><p><span style="font-size:18px">我准备将文章分为上、中、下三部分。现在已经全部完成：</span></p><p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>内存简介，Recoken（计算）</strong></span><span style="font-size:18px">请看</span><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px">：</span><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MC9hcnRpY2xlL2RldGFpbHMvMzc5MTQ0NjU=" title="http://blog.csdn.net/a396901990/article/details/37914465"><span style="font-size:18px; color:#ff0000">ANDROID内存优化(大汇总——上)</span><i class="fa fa-external-link"></i></span></strong></span></p><p><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><strong>Reduce（减少），Reuse（重用）&nbsp;</strong></span><span style="font-family:SimSun">请看：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MC9hcnRpY2xlL2RldGFpbHMvMzg3MDcwMDc=" title="http://blog.csdn.net/a396901990/article/details/38707007"><span style="color:#ff0000"><strong>ANDROID内存优化(大汇总——中)</strong></span><i class="fa fa-external-link"></i></span></span></span></p><p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>Recycle（回收）, Review（检查）&nbsp;</strong></span><span style="font-family:SimSun"><span style="font-size:18px">请看：</span><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM5NjkwMTk5MC9hcnRpY2xlL2RldGFpbHMvMzg5MDQ1NDM=" title="http://blog.csdn.net/a396901990/article/details/38904543"><span style="font-size:18px; color:#ff0000"><strong>ANDROID内存优化(大汇总——全)</strong></span><i class="fa fa-external-link"></i></span></span></p><p><br></p><p><span style="font-family:SimSun"><span style="font-family:SimSun"><span style="font-size:18px">写这篇文章的目的就是想弄一个大汇总，将零散的内存知识点总结一下，<span style="font-family:SimSun">如果有错误、不足或建议都希望告诉我。</span></span></span><br></span></p><p><span style="font-weight:bold"><span style="color:rgb(204,0,0)"><span style="font-family:SimSun; font-size:14px"><span style="font-family:SimSun; font-size:14px"><br></span></span></span></span></p><p><span style="font-family:Microsoft YaHei; font-size:24px; color:#cc0000"><strong>参考文章：</strong></span></p><p><span style="font-family:Arial; font-size:14px">AnDevCon开发者大会演讲PPT：Putting Your App on a Memory Diet</span></p><p><span style="font-family:Arial; font-size:14px"><span style="text-align:center">深入Java核心 Java内存分配原理精讲(</span><span style="text-align:center">http://developer.51cto.com/art/201009/225071.htm</span><span style="text-align:center">)</span></span></p><p></p><h1 style="margin:0px 0px 5px"><span style="font-family:Arial; font-size:14px; font-weight:normal">Process Stats: Understanding How Your App Uses RAM（http://blog.csdn.net/a396901990/article/details/38390135）</span></h1><h1 style="margin:0px 0px 5px"><span style="font-weight:normal"><span style="font-family:Arial; font-size:14px">Android中如何查看内存（http://blog.csdn.net/hudashi/article/details/7050897）</span></span></h1><p><span style="font-family:Arial; font-size:14px"><span style="text-align:center">Android内存性能优化(内部资料总结)（</span>http://www.2cto.com/kf/201405/303276.html）</span></p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;text-align:justify&quot;&gt;&lt;span style=&quot;font-family:SimSun; font-size:14px&quot;&gt;RAM（random access memory）随机存取存储器。说白了就是内存。&lt;/span&gt;&lt;/div&gt;
&lt;p s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/Developing-Single-Page-Web-Applications/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/Developing-Single-Page-Web-Applications/</id>
    <published>2019-06-14T02:52:59.697Z</published>
    <updated>2019-06-14T02:52:59.697Z</updated>
    
    <content type="html"><![CDATA[ <p>In this post you will learn how to use a micro framework called <span class="exturl" data-url="aHR0cDovL3d3dy5zcGFya2phdmEuY29tLw==" title="http://www.sparkjava.com/">Spark<i class="fa fa-external-link"></i></span> to build a RESTful backend. The RESTful backend is consumed by a single page web application using AngularJS and MongoDB for data storage. I&#8217;ll also show you how to run Java 8 on OpenShift.</p><h2>Application Use Case</h2><p>You will develop a todo application which allows users to create and list todo items. The application will do the following:</p><ul><li>When a user goes to the &#8216;/&#8217; url of the application, they will see a list of all todos stored in the application database. Behind the curtain, AngularJS makes a REST(/api/v1/todos) call to fetch all the todo items.</li></ul><p><img style="display: block; margin-left: auto; margin-right: auto;" src="/wp-content/uploads/imported/spark-blog-list-all-todos.png" alt="TodoApp List All Todos" width="600"></p><ul><li>When a user clicks on the checkbox then a todo is marked done. AngularJS makes a PUT request and update the todo item.</li></ul><p><img style="display: block; margin-left: auto; margin-right: auto;" src="/wp-content/uploads/imported/spark-blog-mark-todo-done.png" alt="TodoApp" width="600"></p><ul><li>Finally, a user can add a new todo by navigating to http://todoapp-shekharblogs.rhcloud.com/#/create. This makes a POST call to the RESTful backend and saves the todo in the MongoDB datastore.</li></ul><p><img style="display: block; margin-left: auto; margin-right: auto;" src="/wp-content/uploads/imported/spark-blog-create-new-todo.png" alt="TodoApp Add New Todo" width="600"></p><h2>What is Spark?</h2><p>Spark is a Java based microframework for building web applications with minimum fuss. It is inspired by a framework written in Ruby called Sinatra. It has a minimalist core providing all the essential features required to build a web application quickly with little code.</p><h2>Prerequisite</h2><p>To build the sample application developed in this blog, you would need the following on your machine.</p><ol><li>Download and install <span class="exturl" data-url="aHR0cHM6Ly9qZGs4LmphdmEubmV0L2Rvd25sb2FkLmh0bWw=" title="https://jdk8.java.net/download.html">JDK 8<i class="fa fa-external-link"></i></span></li><li>Download and install Eclipse or any other IDE. Eclipse users make sure you have <span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNsaXBzZS5vcmcvZG93bmxvYWRzL2luZGV4LWphdmE4LnBocA==" title="https://www.eclipse.org/downloads/index-java8.php">Eclipse with Java 8 support<i class="fa fa-external-link"></i></span>.</li><li>Download and install <span class="exturl" data-url="aHR0cDovL21hdmVuLmFwYWNoZS5vcmcvZG93bmxvYWQuY2dp" title="http://maven.apache.org/download.cgi">Apache Maven<i class="fa fa-external-link"></i></span></li><li>Download and install <span class="exturl" data-url="aHR0cDovL3d3dy5tb25nb2RiLm9yZy9kb3dubG9hZHM=" title="http://www.mongodb.org/downloads">MongoDB<i class="fa fa-external-link"></i></span></li></ol><h2>Github Repository</h2><p>The code for today&#8217;s demo application is available on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoZWtoYXJndWxhdGkvdG9kb2FwcC1zcGFyaw==" title="https://github.com/shekhargulati/todoapp-spark">github: todoapp-spark<i class="fa fa-external-link"></i></span>.</p><h2>Step 1: Create a Maven project</h2><p>Open a new command-line terminal and navigate to the location where you want to create the project. Execute the command shown below to generate the template application.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">$ mvn archetype:generate -DgroupId=com.todoapp -DartifactId=todoapp -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</pre></div><h2>Step 2: Update the maven project to use Java 8</h2><p>Import the project into your IDE and replace the pom.xml with the one shown below.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.todoapp&lt;/groupId&gt;    &lt;artifactId&gt;todoapp&lt;/artifactId&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;name&gt;todoapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;<pre><code>&amp;lt;properties&amp;gt;    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;dependencies&amp;gt;&amp;lt;/dependencies&amp;gt;</code></pre><p>&lt;/project&gt;</p></pre><p></p></div><p>In the pom.xml shown above, we changed the following:</p><ol><li>You updated Maven to use Java 8 by defining maven.compiler.source and maven.compiler.target properties.</li><li>You removed the JUnit dependency from the original pom.xml file.</li></ol><p>Delete App.java and AppTest.java files as we don&#8217;t need them.</p><h2>Step 3: Add Spark and other dependencies</h2><p>The application uses the Spark framework and a MongoDB database. So, update the dependencies section of pom.xml with the one shown below.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.sparkjava&lt;/groupId&gt;            &lt;artifactId&gt;spark-core&lt;/artifactId&gt;            &lt;version&gt;2.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;            &lt;version&gt;1.7.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;            &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;            &lt;version&gt;2.11.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;            &lt;artifactId&gt;gson&lt;/artifactId&gt;            &lt;version&gt;2.2.4&lt;/version&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;</pre></div><p>Spark uses SLF4J for logging, so we added slf4j-simple binding in the dependencies. This is required to view the log and error messages. Also, we added the gson library as its used to convert objects to and from JSON.</p><h2>Step 4: Make Spark Say Hello World</h2><p>Create a new class called Bootstrap and add the following code to it.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">package com.todoapp;<p>import spark.Request;<br>import spark.Response;<br>import spark.Route;</p><p>import static spark.Spark.*;</p><p>public class Bootstrap {</p><pre><code>public static void main(String[] args) {    get(&quot;/&quot;, new Route() {        @Override        public Object handle(Request request, Response response) {            return &quot;Hello World!!&quot;;        }    });}</code></pre><p>}</p></pre><p></p></div><p>This code:</p><ol><li>Imports the required classes from the Spark library.</li><li>Creates a new class called Bootstrap and defines a main method.</li><li>Defines a route that tells Spark that when an HTTP GET request is made to &#8216;/&#8217;, return &#8220;Hello World&#8221;. You use Spark&#8217;s get() method to define the mapping from the URL to the callback.</li></ol><p>To see the application in action, run the main program using your IDE. The application will start the embedded Jetty server at http://0.0.0.0:4567. When you open this link in your web browser, you will see &#8220;Hello World!!&#8221;.</p><p>Take advantage of Java 8 lambda expressions to make your code more concise and clean. Spark is a modern Java web framework that takes advantage of Java 8 features.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">package com.todoapp;<p>import spark.Request;<br>import spark.Response;<br>import spark.Route;</p><p>import static spark.Spark.*;</p><p>public class Bootstrap {</p><pre><code>public static void main(String[] args) {    get(&quot;/&quot;, (request, response) -&amp;gt; &quot;Hello World&quot;);}</code></pre><p>}</p></pre><p></p></div><h2>Step 5: Defining the Domain Model and Service class</h2><p>Our goal is an application that stores and manages ToDo items. Our simple ToDo class is shown below.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">package com.todoapp;<p>import com.mongodb.BasicDBObject;<br>import com.mongodb.DBObject;<br>import org.bson.types.ObjectId;</p><p>import java.util.Date;</p><p>public class Todo {</p><pre><code>private String id;private String title;private boolean done;private Date createdOn = new Date();public Todo(BasicDBObject dbObject) {    this.id = ((ObjectId) dbObject.get(&quot;_id&quot;)).toString();    this.title = dbObject.getString(&quot;title&quot;);    this.done = dbObject.getBoolean(&quot;done&quot;);    this.createdOn = dbObject.getDate(&quot;createdOn&quot;);}public String getTitle() {    return title;}public boolean isDone() {    return done;}public Date getCreatedOn() {    return createdOn;}</code></pre><p>}</p></pre><p></p></div><p>Our TodoService class implement methods that use CRUD operations on the Todo object. It basically Creates, Reads, and Updates Todo documents stored in MongoDB.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">package com.todoapp;<p>import com.google.gson.Gson;<br>import com.mongodb.*;<br>import org.bson.types.ObjectId;</p><p>import java.util.ArrayList;<br>import java.util.Collections;<br>import java.util.Date;<br>import java.util.List;</p><p>public class TodoService {</p><pre><code>private final DB db;private final DBCollection collection;public TodoService(DB db) {    this.db = db;    this.collection = db.getCollection(&quot;todos&quot;);}public List&amp;lt;Todo&amp;gt; findAll() {    List&amp;lt;Todo&amp;gt; todos = new ArrayList&amp;lt;&amp;gt;();    DBCursor dbObjects = collection.find();    while (dbObjects.hasNext()) {        DBObject dbObject = dbObjects.next();        todos.add(new Todo((BasicDBObject) dbObject));    }    return todos;}public void createNewTodo(String body) {    Todo todo = new Gson().fromJson(body, Todo.class);    collection.insert(new BasicDBObject(&quot;title&quot;, todo.getTitle()).append(&quot;done&quot;, todo.isDone()).append(&quot;createdOn&quot;, new Date()));}public Todo find(String id) {    return new Todo((BasicDBObject) collection.findOne(new BasicDBObject(&quot;_id&quot;, new ObjectId(id))));}public Todo update(String todoId, String body) {    Todo todo = new Gson().fromJson(body, Todo.class);    collection.update(new BasicDBObject(&quot;_id&quot;, new ObjectId(todoId)), new BasicDBObject(&quot;$set&quot;, new BasicDBObject(&quot;done&quot;, todo.isDone())));    return this.find(todoId);}</code></pre><p>}</p></pre><p></p></div><p>This code does the following:</p><ol><li>The TodoService class constructor receives the MongoDB database object and stores that in the instance variable. You use the db.getCollection() method to fetch the todos collection. All of the operation are done on the todos collection.</li><li>The findAll() method fetches all of the todo documents from the MongoDB database. The documents fetched from MongoDB are of the DBObject type. You iterated over the DBCursor object and converted the individual documents to Todo objects and then added them to a List. Finally, you returned the list of todos.</li><li>The createNewTodo() method receives a JSON string representing the Todo item. You used GSON to convert the JSON to a Todo object. Finally, you inserted the BasicDBObject into the todos collection.</li><li>The find() method finds the Todo item corresponding to a given id.</li><li>The update() method updates the Todo document for the given todo Id. It also updates the done field of the document.</li></ol><h2>Step 6: Creating the Resource class</h2><p>It is generally not a good idea to add all of the code to one class so we will move the application REST endpoints to another class. This new class is called TodoResource and exposes CRUD operations over Todo objects.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">package com.todoapp;<p>import com.google.gson.Gson;<br>import spark.Request;<br>import spark.Response;<br>import spark.Route;</p><p>import java.util.HashMap;</p><p>import static spark.Spark.get;<br>import static spark.Spark.post;<br>import static spark.Spark.put;</p><p>public class TodoResource {</p><pre><code>private static final String API_CONTEXT = &quot;/api/v1&quot;;private final TodoService todoService;public TodoResource(TodoService todoService) {    this.todoService = todoService;    setupEndpoints();}private void setupEndpoints() {    post(API_CONTEXT + &quot;/todos&quot;, &quot;application/json&quot;, (request, response) -&amp;gt; {        todoService.createNewTodo(request.body());        response.status(201);        return response;    }, new JsonTransformer());    get(API_CONTEXT + &quot;/todos/:id&quot;, &quot;application/json&quot;, (request, response)            -&amp;gt; todoService.find(request.params(&quot;:id&quot;)), new JsonTransformer());    get(API_CONTEXT + &quot;/todos&quot;, &quot;application/json&quot;, (request, response)            -&amp;gt; todoService.findAll(), new JsonTransformer());    put(API_CONTEXT + &quot;/todos/:id&quot;, &quot;application/json&quot;, (request, response)            -&amp;gt; todoService.update(request.params(&quot;:id&quot;), request.body()), new JsonTransformer());}</code></pre><p>}</p></pre><p></p></div><p>The code shown above exposes the TodoService CRUD methods as REST API&#8217;s.</p><p>JsonTransformer in the code shown above is an implementation of Spark&#8217;s ResponseTransformer interface. It allows you to convert response objects to other formats like JSON.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">package com.todoapp;<p>import com.google.gson.Gson;<br>import spark.Response;<br>import spark.ResponseTransformer;</p><p>import java.util.HashMap;</p><p>public class JsonTransformer implements ResponseTransformer {</p><pre><code>private Gson gson = new Gson();@Overridepublic String render(Object model) {    return gson.toJson(model);}</code></pre><p>}</p></pre><p></p></div><h2>Step 7: Bootstrap the application</h2><p>Now we will write the entry point for our application. The Bootstrap class shown below configures all of the components. When you run this class as a Java application, it starts the Jetty server and start listening to requests.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">package com.todoapp;<p>import com.mongodb.*;</p><p>import static spark.Spark.setIpAddress;<br>import static spark.Spark.setPort;<br>import static spark.SparkBase.staticFileLocation;</p><p>public class Bootstrap {<br>    private static final String IP_ADDRESS = System.getenv(“OPENSHIFT_DIY_IP”) != null ? System.getenv(“OPENSHIFT_DIY_IP”) : “localhost”;<br>    private static final int PORT = System.getenv(“OPENSHIFT_DIY_PORT”) != null ? Integer.parseInt(System.getenv(“OPENSHIFT_DIY_PORT”)) : 8080;</p><pre><code>public static void main(String[] args) throws Exception {    setIpAddress(IP_ADDRESS);    setPort(PORT);    staticFileLocation(&quot;/public&quot;);    new TodoResource(new TodoService(mongo()));}private static DB mongo() throws Exception {    String host = System.getenv(&quot;OPENSHIFT_MONGODB_DB_HOST&quot;);    if (host == null) {        MongoClient mongoClient = new MongoClient(&quot;localhost&quot;);        return mongoClient.getDB(&quot;todoapp&quot;);    }    int port = Integer.parseInt(System.getenv(&quot;OPENSHIFT_MONGODB_DB_PORT&quot;));    String dbname = System.getenv(&quot;OPENSHIFT_APP_NAME&quot;);    String username = System.getenv(&quot;OPENSHIFT_MONGODB_DB_USERNAME&quot;);    String password = System.getenv(&quot;OPENSHIFT_MONGODB_DB_PASSWORD&quot;);    MongoClientOptions mongoClientOptions = MongoClientOptions.builder().build();    MongoClient mongoClient = new MongoClient(new ServerAddress(host, port), mongoClientOptions);    mongoClient.setWriteConcern(WriteConcern.SAFE);    DB db = mongoClient.getDB(dbname);    if (db.authenticate(username, password.toCharArray())) {        return db;    } else {        throw new RuntimeException(&quot;Not able to authenticate with MongoDB&quot;);    }}</code></pre><p>}</p></pre><p></p></div><h2>Step 8 : Setup AngularJS and Twitter Bootstrap</h2><p>Create a new directory with name <em>public</em> and place the javascript and css files in it. You can checkout the required directory structure from the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoZWtoYXJndWxhdGkvdG9kb2FwcC1zcGFyay90cmVlL21hc3Rlci9zcmMvbWFpbi9yZXNvdXJjZXM=" title="https://github.com/shekhargulati/todoapp-spark/tree/master/src/main/resources">Github repository<i class="fa fa-external-link"></i></span>. Download the latest copy of <span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyanMub3JnLw==" title="https://angularjs.org/">AngularJS<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cDovL2dldGJvb3RzdHJhcC5jb20v" title="http://getbootstrap.com/">Bootstrap<i class="fa fa-external-link"></i></span> from their respective official websites, or you can copy the resources from this project <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoZWtoYXJndWxhdGkvdG9kb2FwcC1zcGFyay90cmVlL21hc3Rlci9zcmMvbWFpbi9yZXNvdXJjZXMvcHVibGlj" title="https://github.com/shekhargulati/todoapp-spark/tree/master/src/main/resources/public">github repository<i class="fa fa-external-link"></i></span>.</p><h2>Step 9: Create index.html</h2><p>Create a new file called index.html inside of the src/main/resources/public directory and place the following content into it.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">&lt;!DOCTYPE html&gt;&lt;html ng-app="todoapp"&gt;&lt;head&gt;    &lt;title&gt;Todo App&lt;/title&gt;    &lt;link rel="stylesheet" href="/css/bootstrap.css"&gt;    &lt;link rel="stylesheet" href="/css/main.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="navbar navbar-inverse"&gt;    &lt;div class="container-fluid"&gt;        &lt;div class="navbar-header"&gt;            &lt;button type="button" class="navbar-toggle"&gt;                &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt;                &lt;span class="icon-bar"&gt;&lt;/span&gt;                &lt;span class="icon-bar"&gt;&lt;/span&gt;                &lt;span class="icon-bar"&gt;&lt;/span&gt;            &lt;/button&gt;            &lt;a class="navbar-brand" href="/"&gt;TodoApp&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;<p>&lt;div class=”container” ng-view=””&gt;</p><p>&lt;/div&gt;</p><p>&lt;script src=”/js/jquery.js”&gt;&lt;/script&gt;<br>&lt;script src=”/js/angular.js”&gt;&lt;/script&gt;<br>&lt;script src=”/js/angular-route.js”&gt;&lt;/script&gt;<br>&lt;script src=”/js/angular-cookies.js”&gt;&lt;/script&gt;<br>&lt;script src=”/js/angular-sanitize.js”&gt;&lt;/script&gt;<br>&lt;script src=”/js/angular-resource.js”&gt;&lt;/script&gt;</p><p>&lt;script src=”/scripts/app.js”&gt;&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</p></pre><p></p></div><p>In the html shown above:</p><ol><li>You imported all of the required libraries. Our application code is in /scripts/app.js. The app.js file will be created in step 10.</li><li>In Angular, you defined the scope of the project using the ng-app directive. You used ng-app on the html element but we can use it with any other element as well. Using the ng-app directive with html element means that AngularJS is available on the whole index.html. The ng-app directive can take a name. This name is the module name. I used todoapp as this application module name.</li><li>The last interesting thing in the index.html is the use of the ng-view directive. The ng-view directive renders the template corresponding to the current route inside index.html. So that everytime you navigate to a route only the ng-view portion changes.</li></ol><h2>Step 10: Write the Angular application</h2><p>The app.js houses all of the application specific JavaScript. All of the application routes are defined inside it. In the code shown below, we have defined two routes and each has a corresponding Angular controller.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">/** * Created by shekhargulati on 10/06/14. */<p>var app = angular.module(‘todoapp’, [<br>    ‘ngCookies’,<br>    ‘ngResource’,<br>    ‘ngSanitize’,<br>    ‘ngRoute’<br>]);</p><p>app.config(function ($routeProvider) {<br>    $routeProvider.when(‘/‘, {<br>        templateUrl: ‘views/list.html’,<br>        controller: ‘ListCtrl’<br>    }).when(‘/create’, {<br>        templateUrl: ‘views/create.html’,<br>        controller: ‘CreateCtrl’<br>    }).otherwise({<br>        redirectTo: ‘/‘<br>    })<br>});</p><p>app.controller(‘ListCtrl’, function ($scope, $http) {<br>    $http.get(‘/api/v1/todos’).success(function (data) {<br>        $scope.todos = data;<br>    }).error(function (data, status) {<br>        console.log(‘Error ‘ + data)<br>    })</p><pre><code>$scope.todoStatusChanged = function (todo) {    console.log(todo);    $http.put(&apos;/api/v1/todos/&apos; + todo.id, todo).success(function (data) {        console.log(&apos;status changed&apos;);    }).error(function (data, status) {        console.log(&apos;Error &apos; + data)    })}</code></pre><p>});</p><p>app.controller(‘CreateCtrl’, function ($scope, $http, $location) {<br>    $scope.todo = {<br>        done: false<br>    };</p><pre><code>$scope.createTodo = function () {    console.log($scope.todo);    $http.post(&apos;/api/v1/todos&apos;, $scope.todo).success(function (data) {        $location.path(&apos;/&apos;);    }).error(function (data, status) {        console.log(&apos;Error &apos; + data)    })}</code></pre><p>});</p></pre><p></p></div><p>The code shown above does the following:</p><ol><li>First, it configures the Angular module named todoapp and defines all of it&#8217;s dependencies.</li><li>It defines the routes that this application will respond to.</li><li>When a user makes request to &#8216;/&#8217;, the ListCtrl will be invoked. The ListCtrl will make an HTTP GET request to &#8216;/api/v1/todos&#8217; to fetch all of the todo items. The todo items are put on the scope. The list.html uses the ng-repeat directive to iterate over all of the todo items and generate a table.</li><li>When a user clicks on the checkbox next to the item, the todoStatusChanged() function is invoked. This function makes an HTTP PUT request to update the todo item.</li><li>When a user makes a GET request to &#8216;/create&#8217;, create.html is rendered. The create.html renders a bootstrap form. The form HTML element uses the ng-submit directive. On form submit the createTodo function is invoked. The createTodo function makes an HTTP POST request to create a new todo item.</li></ol><p>You can find the respective views for different routes in the application&#8217;s <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoZWtoYXJndWxhdGkvdG9kb2FwcC1zcGFyay90cmVlL21hc3Rlci9zcmMvbWFpbi9yZXNvdXJjZXMvcHVibGljL3ZpZXdz" title="https://github.com/shekhargulati/todoapp-spark/tree/master/src/main/resources/public/views">Github repository<i class="fa fa-external-link"></i></span>.</p><h2>Step 11: Run the application</h2><p>You can either run the application using your IDE or package this application as an executable jar and then run it from the command-line. Add the following plugin to your project pom.xml to create an executable JAR. This plugin provides the capability to package the artifact in an uber-jar, including its dependencies and to shade &#8211; i.e. rename &#8211; the packages of some of the dependencies.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;                &lt;version&gt;2.3&lt;/version&gt;                &lt;configuration&gt;                    &lt;createDependencyReducedPom&gt;true&lt;/createDependencyReducedPom&gt;                    &lt;filters&gt;                        &lt;filter&gt;                            &lt;artifact&gt;*:*&lt;/artifact&gt;                            &lt;excludes&gt;                                &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;                                &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;                                &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;                            &lt;/excludes&gt;                        &lt;/filter&gt;                    &lt;/filters&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;phase&gt;package&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;shade&lt;/goal&gt;                        &lt;/goals&gt;                        &lt;configuration&gt;                            &lt;transformers&gt;                                &lt;transformer                                        implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt;                                    &lt;mainClass&gt;com.todoapp.Bootstrap&lt;/mainClass&gt;                                &lt;/transformer&gt;                            &lt;/transformers&gt;                        &lt;/configuration&gt;                    &lt;/execution&gt;                &lt;/executions&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;&lt;/build&gt;</pre></div><p>To create an executable jar, run the mvn clean install command. This creates a todoapp-1.0-SNAPSHOT.jar in the target directory.</p><p>To run the application:</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">$ java -jar target/todoapp-1.0-SNAPSHOT.jar</pre></div><p>This would print following lines in the terminal.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">== Spark has ignited ...>&gt; Listening on localhost:8080[Thread-2] INFO org.eclipse.jetty.server.Server - jetty-9.0.z-SNAPSHOT[Thread-2] INFO org.eclipse.jetty.server.ServerConnector - Started ServerConnector@5bbf3bfb{HTTP/1.1}{localhost:8080}</pre></div><h2>Step 12: Deploying on OpenShift</h2><p>This blog would not be complete if I didn&#8217;t show you how to run this application on OpenShift. Today OpenShift does not support JDK 8 but that doesn&#8217;t mean you can&#8217;t run Java 8 applications. You can use the DIY cartridge and install your own JDK version. The next command creates the todo application you created in the above mentioned steps. It installs JDK 8 on the DIY gear and configures other settings.</p><div class="geshifilter"><pre class="text geshifilter-text" style="font-family: monospace;">$ rhc app create todoapp diy mongodb-2.4 --repo=todoapp-os --from-code=https://github.com/shekhargulati/spark-openshift-quickstart.git</pre></div><p>After this commands successfully finishes, you will see the todo app running at http://todoapp-{domain-name}.rhcloud.com. Please replace {domain-name} with your OpenShift account domain name.</p><h2>Next Steps</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cub3BlbnNoaWZ0LmNvbS9hcHAvYWNjb3VudC9uZXc=" title="https://www.openshift.com/app/account/new">Sign up for OpenShift Online<i class="fa fa-external-link"></i></span> and try this out yourself</li><li>Promote and show off your awesome app in the <span class="exturl" data-url="aHR0cHM6Ly93d3cub3BlbnNoaWZ0LmNvbS9hcHBsaWNhdGlvbi1nYWxsZXJ5" title="https://www.openshift.com/application-gallery">OpenShift Application Gallery<i class="fa fa-external-link"></i></span> today.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
         &lt;p&gt;In this post you will learn how to use a micro framework called &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5zcGFya2phdmEuY29tLw==&quot; tit
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://miaopei.github.io/2019/06/14/practical-programming-books/src/30-minutes-to-learn-regex/"/>
    <id>http://miaopei.github.io/2019/06/14/practical-programming-books/src/30-minutes-to-learn-regex/</id>
    <published>2019-06-14T02:52:59.697Z</published>
    <updated>2019-06-14T02:52:59.697Z</updated>
    
    <content type="html"><![CDATA[<p>推荐几个正则表达式编辑器</p><ul><li>Debuggex ：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGVidWdnZXguY29tLw==" title="https://www.debuggex.com/">https://www.debuggex.com/<i class="fa fa-external-link"></i></span></li><li>PyRegex：<span class="exturl" data-url="aHR0cDovL3d3dy5weXJlZ2V4LmNvbS8=" title="http://www.pyregex.com/">http://www.pyregex.com/<i class="fa fa-external-link"></i></span></li><li>Regexper：<span class="exturl" data-url="aHR0cDovL3d3dy5yZWdleHBlci5jb20v" title="http://www.regexper.com/">http://www.regexper.com/<i class="fa fa-external-link"></i></span></li></ul><p>正则表达式是一种查找以及字符串替换操作。正则表达式在文本编辑器中广泛使用，比如正则表达式被用于：</p><ul><li><span style="font-family: Simsun; font-size: medium;">检查文本中是否含有指定的特征词</span></li><li><span style="font-family: Simsun; font-size: medium;">找出文中匹配特征词的位置</span></li><li><span style="font-family: Simsun; font-size: medium;">从文本中提取信息，比如：字符串的子串</span></li><li><span style="font-family: Simsun; font-size: medium;">修改文本</span></li></ul><p><span style="font-family: Simsun; font-size: medium;">与文本编辑器相似，几乎所有的高级编程语言都支持正则表达式。在这样的语境下，“文本”也就是一个字符串，可以执行的操作都是类似的。一些编程语言（比如Perl，JavaScript）会检查正则表达式的语法。</span></p><p><strong><span style="font-family: Simsun; font-size: medium;">正则表达式是什么？</span></strong></p><p><span style="font-family: Simsun; font-size: medium;">正则表达式只是一个字符串。没有长度限制，但是，这样的正则表达式长度往往较短。如下所示是一些正则表达式的例子：</span></p><ul><li><code><span style="font-family: Simsun; font-size: medium;">I had a \S+ day today</span></code></li><li><code><span style="font-family: Simsun; font-size: medium;">[A-Za-z0-9\-_]{3,16}</span></code></li><li><code><span style="font-family: Simsun; font-size: medium;">\d\d\d\d-\d\d-\d\d</span></code></li><li><code><span style="font-family: Simsun; font-size: medium;">v(\d+)(\.\d+)*</span></code></li><li><code><span style="font-family: Simsun; font-size: medium;">TotalMessages="(.*?)"</span></code></li><li><code><span style="font-family: Simsun; font-size: medium;">&lt;[^&lt;&gt;]&gt;</span></code></li></ul><div><span style="font-family: Simsun; font-size: medium;">这些字符串实际上都是微型计算机程序。正则表达式的语法，实际上是一种轻量级、简洁、适用于特定领域的编程语言。记住这一点，那么你就很容易理解下面的事情：</span></div><div><ul><li><span style="font-family: Simsun; font-size: medium;">每一个正则表达式，都可以分解为一个指令序列，比如“先找到这样的字符，再找到那样的字符，再从中找到一个字符。。。”<br></span></li><li><span style="font-family: Simsun; font-size: medium;">每一个正则表达式都有输入（文本）和输出（匹配规则的输出，有时是修改后的文本）</span></li><li><span style="font-family: Simsun; font-size: medium;">正则表达式有可能出现语法错误——不是所有的字符串都是正则表达式</span></li><li><span style="font-family: Simsun; font-size: medium;">正则表达式语法很有个性，也可以说很恐怖</span></li><li><span style="font-family: Simsun; font-size: medium;">有时可以通过编译，使得正则表达式执行更快</span></li></ul><p><span style="font-family: Simsun; font-size: medium;">在实现中，正则表达式还有其他的特点。本文将重点讨论正则表达式的核心语法，在几乎所有的正则表达式中都可以见到这些规则。</span></p><p><span style="font-family: Simsun; font-size: medium;">特别提示：正则表达式与文件通配语法无关，比如 *.xml</span></p><h2><span style="font-family: Simsun; font-size: medium;">正则表达式的基础语法</span></h2><h3><span style="font-family: Simsun;">字符</span><span style="font-family: Simsun; font-size: medium;"> </span></h3><p><span style="font-family: Simsun; font-size: medium;">正则表达式中包含了一系列的字符，这些字符只能匹配它们本身。有一些被称为“元字符”的特殊字符，可以匹配一些特殊规则。</span></p><p><span style="font-family: Simsun; font-size: medium;">如下所示的例子中，我用红色标出了元字符。</span></p><ul><li><code><span style="font-family: Simsun; font-size: medium;">I had a <span style="color: #ff0000;">\S+</span> day today</span></code></li><li><span style="color: #ff0000;"><code>[A-Za-z0-9\-_]{3,16}</code></span></li><li><code><span style="font-family: Simsun; font-size: medium;"><span style="color: #ff0000;">\d\d\d\d</span>-<span style="color: #ff0000;">\d\d</span>-<span style="color: #ff0000;">\d\d</span></span></code></li><li><code><span style="font-family: Simsun; font-size: medium;">v<span style="color: #ff0000;">(\d+)(\.\d+)*</span></span></code></li><li><code><span style="font-family: Simsun; font-size: medium;">TotalMessages="<span style="color: #ff0000;">(.*?)</span>"</span></code></li><li><code><span style="font-family: Simsun; font-size: medium;">&lt;<span style="color: #ff0000;">[^&lt;&gt;]*</span>&gt;</span></code><span style="font-family: Simsun; font-size: medium;"> </span></li></ul><p><span style="font-family: Simsun; font-size: medium;">大部分的字符，包括所有的字母和数字字符，是普通字符。也就意味着，它们只能匹配它们自己，如下所示的正则表达式：</span></p><p>cat</p><p><span style="font-family: Simsun; font-size: medium;">意味着，只能匹配一个字符串，以“c”开头，然后是字符“a”，紧跟着是字符“t”的字符串。</span></p><p><span style="font-family: Simsun; font-size: medium;">到目前为止，正则表达式的功能类似于</span></p><ul><li><span style="font-family: Simsun; font-size: medium;">常规的Find功能</span></li><li><span style="font-family: Simsun; font-size: medium;">Java中的 <code>String.indexOf()</code> 函数</span></li><li><span style="font-family: Simsun; font-size: medium;">PHP中的 <code>strpos()</code>函数</span></li><li><span style="font-family: Simsun; font-size: medium;">等等</span></li></ul></div><div><span style="font-family: Simsun; font-size: medium;">注意：不做特殊说明，正则表达式中是区分大小写的。但是，几乎所有正则表达式的实现，都会提供一个Flag用来控制是否区分大小写。</span></div><h3></h3><div><h3><span style="font-family: Simsun;">点“.”</span></h3><p><span style="font-family: Simsun; font-size: medium;">我们第一个要讲解的元字符是“.”。这个符号意味着可以匹配任意一个字符。如下所示的正则表达式：</span></p><p>c.t</p><p><span style="font-family: Simsun; font-size: medium;">意味着匹配“以c开头,之后是任意一个字符，紧跟着是字母t”的字符串。</span></p><p><span style="font-family: Simsun; font-size: medium;">在一段文本中，这样的正则表达式可以用来找出</span><span style="color: #262626; font-family: Simsun; font-size: medium;"><code>cat</code>, <code>cot</code>, <code>czt这样的字符串，甚至可以找出c.t这样的组合，但是不能找到ct或者是coot这样的字符串。</code></span></p><p><span style="font-family: Simsun; font-size: medium;">使用反斜杠“\”可以忽略元字符，使得元字符的功能与普通字符一样。所以，正则表达式</span></p><p>c\.t</p><p><span style="font-family: Simsun; font-size: medium;">表示“找到字母c,然后是一个句号（“.”），紧跟着字母t”</span></p><p><span style="font-family: Simsun; font-size: medium;">反斜杠本身也是一个元字符，这意味着反斜杠本身也可以通过相似的方法变回到普通字符的用途。因此，正则表达式</span></p><p>c\\t</p><p><span style="font-family: Simsun; font-size: medium;">表示匹配“以字符c开头,然后是一个反斜杠，紧跟着是字母t”的字符串。</span></p><div><p><span style="font-family: Simsun; font-size: medium;">注意！在正则表达式的实现中，.是不能用于匹配换行符的。”换行符“的表示方法在不同实现中也不同。实际编程时，请参考相关文档。在本文中，我认为.是可以匹配任意字符的。实现环境通常会提供一个Flag标志位，来控制这一点。</span></p><h2>字符类</h2><p>字符类是一组在方括号内的字符，表示可以匹配其中的任何一个字符。</p><ul><li>正则表达式c[aeiou]t，表示可以匹配的字符串是&#8221;以c开头，接着是aeiou中的任何一个字符，最后以t结尾&#8221;。在文本的实际应用中，这样的正则表达式可以匹配：cat,cet,cit,cot,cut五种字符串。</li><li>正则表达式[0123456789]表示匹配任意一个整数。</li><li>正则表达式[a]表示匹配单字符a。</li></ul><p>包含忽略字符的例子</p><ul><li><p style="text-align:center;"><span class="MathJax_Preview">\[a\]</span><script type="math/tex;  mode=display">a</script></p>表示匹配字符串[a]</li><li>[<code class="tex2jax_ignore">\[\]</code>\ab]表示匹配的字符为&#8221;["或者'']&#8221;或者&#8221;a&#8221;,或者&#8221;b&#8221;</li><li>[\\<code class="tex2jax_ignore">\[\]</code>]表示匹配的字符为&#8221;\&#8221;或者 “[”或者"]&#8220;</li></ul><p>在字符类中，字符的重复和出现顺序并不重要。[dabaaabcc]与[abc]是相同的</p><div><p>重要提示：字符类中和字符类外的规则有时不同，一些字符在字符类中是元字符，在字符类外是普通字符。一些字符正好相反。还有一些字符在字符类中和字符类外都是元字符，这要视情况而定！</p><p>比如，.表示匹配任意一个字符，而[.]表示匹配一个全角句号。这不是一回事！</p></div><h3>字符类的范围</h3><p>在字符集中，你可以通过使用短横线来表示匹配字母或数字的范围。</p><ul><li>[b-f]与[b,c,d,e,f]相同，都是匹配一个字符&#8221;b&#8221;或&#8221;c&#8221;或&#8221;d&#8221;或&#8221;e&#8221;或&#8221;f&#8221;</li><li>[A-Z]与[ABCDEFGHIJKLMNOPQRSTUVWXYZ]相同，都是匹配任意一个大写字母。</li><li>[1-9]与[123456789]相同，都是匹配任意一个非零数字。</li></ul><h4><strong>练习</strong></h4><p>使用目前我们已经讲解的正则表达式相关知识，在字典中匹配找到含有最多连续元音的单词，同时找到含有最多连续辅音的单词。</p><h4><strong>答案</strong></h4><p><code>[aeiou][aeiou][aeiou][aeiou][aeiou][aeiou]</code> 这样的正则表达式，可以匹配连续含有六个元音的单词，比如 <code>euouae</code> 和 <code>euouaes</code>。</p><p><code><span style="font-family: Tahoma; font-size: medium;">同样的，恐怖的正则表达式</span></code><code>[bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz]</code><span style="font-family: Tahoma; font-size: medium;"> 可以找到连续含有十个辅音的单词</span><code>sulphhydryls</code><span style="font-family: Tahoma; font-size: medium;">. </span></p><p><span style="font-family: Tahoma; font-size: medium;">下文中，我们会讲解，怎样有效缩短这样的正则表达式长度。</span></p><p>在字符类之外，短横线没有特殊含义。正则表达式a-z，表示匹配字符串“以a开头，然后是一个短横线，以z结尾”。</p><p>范围和单独的字符可能在一个字符类中同时出现：</p><ul><li>[0-9.,]表明匹配一个数字，或者一个全角句号，或者一个逗号</li><li>[0-9a-fA-F]意味着匹配一个十六进制数</li><li>[a-zA-Z0-9\-]意味着匹配一个字母、数字或者一个短横线</li></ul><h4><strong>练习</strong></h4><p>使用已经介绍过的正则表达式知识，匹配YYYY-MM-DD格式的日期。</p><h4><strong>答案</strong></h4><p><code>[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]</code>.</p><p>同样的，下文中，我们会介绍怎样有效减少这样的正则表达式长度。</p><p>虽然你可以尝试在正则表达式中使用一些非字母或数字作为范围的最后一个符号，比如abc[!-/]def，但是这并不是在每种实现中都合法。即使这样的语法是合法的，这样的语义也是模糊的。最好不要这样使用。</p><p>同时，你必须谨慎选择范围的边界值。即使[A-z]在你使用的实现中，是合法的，也可能会产生无法预料的运行结果。（注意，在z到a之间，是有字符存在的）</p><div><p><b>注意：</b>范围的字符值代表的是字符而已，并不能代表数值范围，比如[1-31]表示匹配一个数字，是1或者2或者3，而不是匹配一个数值在1到31之间的数。</p><div><h3>字符类的反义</h3><p>你可以在字符类的起始位放一个反义符。</p><ul><li>[^a]表示匹配任何不是“a”的字符</li><li>[^a-zA-Z0-9]表示匹配任何不是字母也不是数字的字符</li><li>[\^abc]匹配一个为“^”或者a或者b或者c的字符</li><li>[^\^]表示匹配任何不为“^”的字符</li></ul><div><h4><strong>练习</strong></h4><p>在字典中，找到一个不满足“在e之前有i，但是没有c”的例子。</p><h4><strong>答案</strong></h4></div></div><p>cie和[^c]ei都要可以找到很多这样的例子，比如ancient,science,viel,weigh</p><h3></h3><h3>转义字符类</h3><p>\d这个正则表达式与[0-9]作用相同，都是匹配任何一个数字。（要匹配\d,应该使用正则表达式\\d）</p><p>\w与[0-9A-Za-z]相同，都表示匹配一个数字或字母字符</p><p>\s意味着匹配一个空字符（空格，制表符，回车或者换行）</p><p>另外</p><ul><li>\D与[^0-9]相同，表示匹配一个非数字字符。</li><li>\W与[^0-9A-Za-z]相同，表示匹配一个非数字同时不是字母的字符。</li><li>\S表示匹配一个非空字符。</li></ul><p>这些是你必须掌握的字符。你可能已经注意到了，一个全角句号“.”也是一个字符类，可以匹配任意一个字符。</p><p>很多正则表达式的实现中，提供了更多的字符类，或者是标志位在ASCII码的基础上，扩展现有的字符类。</p><p>特别提示：统一字符集中包含除了0至9之外的更多数字字符，同样的，也包含更多的空字符和字母字符。实际使用正则表达式时，请仔细查看相关文档。</p><div><h4><strong>练习</strong></h4><p>简化正则表达式 <code>[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]</code>.</p><h4><strong>答案</strong></h4><p><code>\d\d\d\d-\d\d-\d\d</code>.</p><h3></h3><h3>重复</h3><p>在字符或字符集之后，你可以使用{ }大括号来表示重复</p><ul><li>正则表达式a{1}与a意思相同，都表示匹配字母a</li><li>a{3}表示匹配字符串“aaa”</li><li>a{0}表示匹配空字符串。从这个正则表达式本身来看，它毫无意义。如果你对任何文本执行这样的正则表达式，你可以定位到搜索的起始位置，即使文本为空。</li><li>a\{2\}表示匹配字符串“a{2}”</li><li>在字符类中，大括号没有特殊含义。[{}]表示匹配一个左边的大括号，或者一个右边的大括号</li></ul><div><h4><strong>练习</strong></h4><p>简化下面的正则表达式</p><ul><li><code>z.......z</code></li><li><code>\d\d\d\d-\d\d-\d\d</code></li><li><code>[aeiou][aeiou][aeiou][aeiou][aeiou][aeiou]</code></li><li><code>[bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz]</code></li></ul><h4><strong>答案</strong></h4><ul><li><code>z.{7}z</code></li><li><code>\d{4}-\d{2}-\d{2}</code></li><li><code>[aeiou]{6}</code></li><li><code>[bcdfghjklmnpqrstvwxyz]{10}</code></li></ul></div><div><p>注意：重复字符是没有记忆性的，比如[abc]{2}表示先匹配&#8221;a或者b或者c&#8221;，再匹配&#8221;a或者b或者c&#8221;，与匹配”aa或者ab或者ac或者ba或者bb或者bc或者ca或者cb或者cc“一样。[abc]{2}并不能表示匹配”aa或者bb或者cc“</p></div></div><div><h3></h3><h3>指定重复次数范围</h3><p>重复次数是可以指定范围的</p><ul><li>x{4,4}与x{4}相同</li><li>colou{0,1}r表示匹配colour或者color</li><li>a{3,5}表示匹配aaaaa或者aaaa或者aaa</li></ul><p><span style="font-family: Tahoma; font-size: medium;">注意这样的正则表达式会优先匹配最长字符串，比如输入 </span><code>I had an aaaaawful day</code><code><span style="font-family: Tahoma;">会匹配单词aaaaawful中的aaaaa，而不会匹配其中的aaa。</span></code></p><p><span style="font-family: Tahoma; font-size: medium;">重复次数是可以有范围的，但是有时候这样的方法也不能找到最佳答案。如果你的输入文本是</span>I had an aaawful daaaaay<span style="font-family: Tahoma; font-size: medium;">那么在第一次匹配时，只能找到aaawful，只有再次执行匹配时才能找到daaaaay中的aaaaa.</span></p><p>重复次数的范围可以是开区间</p><ul><li>a{1，}表示匹配一个或一个以上的连续字符a。依然是匹配最长字符串。当找到第一个a之后，正则表达式会尝试匹配尽量多个的连续字母a。</li><li>.{0,}表示匹配任意内容。无论你输入的文本是什么，即使是一个空字符串，这个正则表达式都会成功匹配全文并返回结果。</li></ul><div><h4><strong>练习</strong></h4><p>使用正则表达式找到双引号。要求输入字符串可能包含任意个字符。</p><p>调整你的正则表达式使得在一对双引号中间不再包含其他的双引号。</p><h4><strong>答案</strong></h4><p><code> ".{0,}"</code>, 然后 <code>"[^"]{0,}"</code>.</p></div></div><div><h3></h3><h3>关于重复的转义字符</h3><p>？与{0,1}相同，比如，colou?r表示匹配colour或者color</p><p>*与{0,}相同。比如，.*表示匹配任意内容</p><p>+与{1，}相同。比如,\w+表示匹配一个词。其中&#8221;一个词&#8221;表示由一个或一个以上的字符组成的字符串，比如_var或者AccountName1.</p><p>这些是你必须知道的常用转义字符，除此之外还有:</p><ul><li>\?\*\+ 表示匹配字符串&#8221;?*+&#8221;</li><li>[?*+]表示匹配一个问号，或者一个*号，或者一个加号</li></ul><div><h4><strong>练习</strong></h4><p>简化下列的正则表达式:</p><ul><li><code>".{0,}"</code> and <code>"[^"]{0,}"</code></li><li><code>x?x?x?</code></li><li><code>y*y*</code></li><li><code>z+z+z+z+</code></li></ul><h4><span style="font-family: Tahoma; font-size: medium;"><b>答案</b></span></h4><ul><li><code>".*"</code> and <code>"[^"]*"</code></li><li><code>x{0,3}</code></li><li><code>y*</code></li><li><code>z{4,</code>}</li></ul><h4></h4><h4><strong>练习</strong></h4><p>写出正则表达式，寻找由非字母字符分隔的两个单词。如果是三个呢？六个呢？</p><p><code>\w+\W+\w+</code>, <code>\w+\W+\w+\W+\w+</code>, <code>\w+\W+\w+\W+\w+\W+\w+\W+\w+\W+\w+</code>.</p><p>下文中，我们将简化这个正则表达式。</p></div></div></div></div></div><h3></h3><h3> 非贪婪匹配</h3><p>正则表达式 &#8220;.*&#8221; 表示匹配双引号，之后是任意内容，之后再匹配一个双引号。注意，其中匹配任意内容也可以是双引号。通常情况下，这并不是很有用。通过在句尾加上一个问号，可以使得字符串重复不再匹配最长字符。</p><ul><li>\d{4,5}?表示匹配\d\d\d\d或者\d\d\d\d\d。也就是和\d{4}一样</li><li>colou??r与colou{0,1}r相同，表示找到color或者colour。这与colou?r一样。</li><li>&#8220;.*?&#8221;表示先匹配一个双引号，然后匹配最少的字符，然后是一个双引号，与上面两个例子不同，这很有用。</li></ul><h3>选择匹配</h3><p>你可以使用|来分隔可以匹配的不同选择:</p><ul><li>cat|dog表示匹配&#8221;cat&#8221;或者&#8221;dog&#8221;</li><li>red|blue|以及red||blue以及|red|blue都表示匹配red或者blue或者一个空字符串</li><li>a|b|c与[abc]相同</li><li>cat|dog|\|表示匹配&#8221;cat&#8221;或者&#8221;dog&#8221;或者一个分隔符”|“</li><li>[cat|dog]表示匹配a或者c或者d或者g或者o或者t或者一个分隔符“|”</li></ul><div><h4><strong>练习</strong></h4><p>简化下列正则表达式:</p><ul><li><code>s|t|u|v|w</code></li><li><code>aa|ab|ba|bb</code></li><li><code>[abc]|[^abc]</code></li><li><code>[^ab]|[^bc]</code></li><li><code>[ab][ab][ab]?[ab]?</code></li></ul><p><span style="font-family: 'Ubuntu Mono', monospace;"><strong><span style="font-size: medium;">答案</span></strong><br></span></p><ul><li><code>[s-w]</code></li><li><code>[ab]{2}</code></li><li><code>.</code></li><li><code>[^b]</code></li><li><code>[ab]{2,4}</code></li></ul></div><div><h4><strong>练习</strong></h4><p>使用正则表达式匹配1到31之间的整数，[1-31]不是正确答案！</p><p>这样的正则表达式不唯一. <code>[1-9]|[12][0-9]|3[01]</code> 是其中之一。</p><h3></h3><h3>分组</h3><p>你可以使用括号表示分组:</p><ul><li><span style="font-family: Tahoma;">通过使用 </span>Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day <span style="font-family: Tahoma; font-size: medium;">匹配一周中的某一天</span></li><li>(\w*)ility <span style="font-family: Tahoma; font-size: medium;"><span style="color: #0000ff;"> </span>与</span> \w*ility <span style="font-family: Tahoma; font-size: medium;">相同。都是匹配一个由&#8221;ility&#8221;结尾的单词。稍后我们会讲解，为何第一种方法更加有用。</span></li><li><span class="MathJax_Preview">\(\)</span><script type="math/tex"></script>表示匹配一对括号。</li><li>[()]表示匹配任意一个左括号或者一个右括号</li></ul><div><h4><strong>练习</strong></h4><p>在《时间机器中》找到一对括号中的内容，然后通过修改正则表达式，找到不含括号的内容。</p><h4><strong>答案</strong></h4><p><code><span class="MathJax_Preview">\(.*\)</span><script type="math/tex">.*</script></code>. 然后是, <code><span class="MathJax_Preview">\([^()]*\)</span><script type="math/tex">[^()]*</script></code>.</p></div><p>分组可以包括空字符串：</p><ul><li>(red|blue)表示匹配red或者blue或者是一个空字符串</li><li>abc()def与abcdef相同</li></ul><p>你也可以在分组的基础上使用重复：</p><ul><li>(red|blue)？与(red|blue|)相同</li><li>\w+(\s+\w+)表示匹配一个或多个由空格分隔的单词</li></ul><h4><strong>练习</strong></h4><p>简化正则表达式 <code>\w+\W+\w+\W+\w+</code> 以及 <code>\w+\W+\w+\W+\w+\W+\w+\W+\w+\W+\w+</code>.</p><h4><strong>答案</strong></h4><p><code>\w+(\W+\w+){2}</code>, <code>\w+(\W+\w+){5}</code>.</p><p>&nbsp;</p><h3>单词分隔符</h3><p>在单词和非单词之间有单词分隔符。记住，一个单词\w是[0-9A-Za-z_]，而非单词字符是\W(大写)，表示[^0-9A-Za-z_].</p><p>在文本的开头和结尾通常也有单词分隔符。</p><p>在输入文本it&#8217;s a cat中，实际有八个单词分隔符。如果我们在cat之后在上一个空格，那就有九个单词分隔符。.</p><ul><li>\b表示匹配一个单词分隔符</li><li>\b\w\w\w\b表示匹配一个三字母单词</li><li>a\ba表示匹配两个a中间有一个单词分隔符。这个正则表达式永远不会有匹配的字符，无论输入怎样的文本。</li></ul><p>单词分隔符本身并不是字符。它们的宽度为0。下列正则表达式的作用不同</p><ul><li><code>(\bcat)\b</code></li><li><code>(\bcat\b)</code></li><li><code>\b(cat)\b</code></li><li><code>\b(cat\b)</code></li></ul><div><h4><strong>练习</strong></h4><p>在词典中找到最长的单词。</p><h4><strong>答案</strong></h4><p>在尝试之后发现，\b.{45,}\b可以在字典中找到最长单词<code><br></code></p></div><p>&nbsp;</p><h3>换行符</h3><p>一篇文本中可以有一行或多行，行与行之间由换行符分隔，比如：</p><ul><li>Line一行文字</li><li>Line break换行符</li><li>Line一行文字</li><li>Line break换行符</li><li>&#8230;</li><li>Line break换行符</li><li>Line一行文字</li></ul><p>注意，所有的文本都是以一行结束的，而不是以换行符结束。但是，任意一行都可能为空，包括最后一行。</p><p>行的起始位置，是在换行符和下一行首字符之间的空间。考虑到单词分隔符，文本的起始位置也可以当做是首行位置。</p><p>最后一行是最后一行的尾字符和换行符之间的空间。考虑到单词分隔符，文本的结束也可以认为是行的结束。</p><p>那么新的格式表示如下:</p><ul><li>Start-of-line, line, end-of-line</li><li>Line break</li><li>Start-of-line, line, end-of-line</li><li>Line break</li><li>&#8230;</li><li>Line break</li><li>Start-of-line, line, end-of-line</li></ul><p>基于上述概念:</p><ul><li>^表示匹配行的开始位置</li><li>$表示匹配行的结束位置</li><li>^&amp;表示一个空行</li><li><code>^.*&amp;</code><code><span style="font-family: Tahoma;"><span style="color: #0000ff;"> </span>表示匹配全文内容，因为行的开始符号也是一个字符，"."会匹配这个符号。找到单独的一行，可以使用</span></code> ^.*?$</li><li>\^\$表示匹配字符串“^$”</li><li>[$]表示匹配一个$。但是，[^]不是合法的正则表达式。记住在方括号中，字符有不同的特殊含义。要想在方括号内匹配^，必须用[\^]</li></ul><p>与字符分隔符一样，换行符也不是字符。它们宽度为0.如下所示的正则表达式作用不同：</p><ul><li><code>(^cat)$</code></li><li><code>(^cat$)</code></li><li><code>^(cat)$</code></li><li><code>^(cat$)</code></li></ul><div><h4><strong>练习</strong></h4><p>使用正则表达式在《时间机器》中找到最长的一行。</p><h4><b>答案</b></h4><p><b></b>使用正则表达式^.{73,}$可以匹配长度为73的一行</p><h3></h3><h3>文本分界</h3><p>在很多的正则表达式实现中，将^和$作为文本的开始符号和结束符号。</p><p>还有一些实现中，用\A和\z作为文本的开始和结束符号。</p><h2></h2><h2>捕捉和替换</h2><p>从这里开始，正则表达式真正体现出了它的强大。</p><h3>捕获组</h3><p>你已经知道了使用括号可以匹配一组符号。使用括号也可以捕获子串。假设正则表达式是一个小型计算机程序，那么捕获子串就是它输出的一部分。</p><p>正则表达式(\w*)ility表示匹配以ility结尾的词。第一个被捕获的部分是由\w*控制的。比如，输入的文本内容中有单词accessibility，那么首先被捕获的部分是accessib。如果输入的文本中有单独的ility，则首先被捕获的是一个空字符串。</p><p>你可能会有很多的捕获字符串，它们可能靠得很近。捕获组从左向右编号。也就是只需要对左括号计数。</p><p>假设有这样的正则表达式：(\w+) had a ((\w+) \w+)</p><p><span style="font-family: Tahoma;"><span style="font-size: medium;">输入的内容是：</span></span>I had a nice day <span style="font-family: Tahoma; font-size: medium;"><br></span></p><ul><li>捕获组1：I</li><li>捕获组2：nice day</li><li>捕获组3:nice</li></ul><p>在一些正则表达式的实现中，你可以从零开始编号，编号零表示匹配整句话：<code>I had a nice day</code>.</p><p>在其他的实现中，如果没有制定捕获组，那么捕获组1会自动地填入捕获组0的信息。</p><p>是的，这也意味着会有很多的括号。有一些正则表达式的实现中，提供了“非捕获组”的语法，但是这样的语法并不是标准语法，因此我们不会介绍。</p><div><p>从一个成功的匹配中返回的捕获组个数，与使用原来的正则表达式获得的捕获组个数相同。记住这一点，你可以解释一些奇怪的现象。.</p><p>正则表达式（（cat）|dog）表示匹配cat或者dog。这里有两个捕获组，如果输入文本是dog，那么捕获组1是dog,捕获组2为空。</p><p>正则表达式a(\w)*表示匹配一个以a开头的单词。这里只有一个捕获组</p><ul><li>如果输入文本为a,捕获组1为空。</li><li>如果输入文本为ad,捕获组为d</li><li>如果输入文本为avocado，捕获组1为v。但是捕获组0表示整个单词avocado.</li></ul></div><h3></h3><h3>替换</h3><p>假如你使用了一个正则表达式去匹配字符串，你可以描述另外一个字符串来替换其中的匹配字符。用来替换的字符串称为替换表达式。它的功能类似于</p><ul><li>常规的Replace会话</li><li>Java中的String.replace()函数</li><li>PHP的str_replace()函数</li><li>等等</li></ul><div><h4><strong>练习</strong></h4><p>将《时间机器》中所有的元音字母替换为r。</p><h4><strong>答案</strong></h4><p>使用正则表达式[aeiou]以及[AEIOU]，对应的替换字符串分别为r,R.</p></div><p>但是，你可以在替换表达式中引用捕获组。这是在替换表达式中，你可以唯一操作的地方。这也是非常有效的，因为这样你就不用重构你找到的字符串。</p><p>假设你正在尝试将美国风格的日期表示MM/DD/YY替换为ISO 8601日期表示YYYY-MM-DD</p><ul><li>从正则表达式<span style="color: #0000ff;">(\d\d)/(\d\d)/(\d\d)</span><span style="font-family: Tahoma; font-size: medium;">开始。注意，这其中有三个捕获组：月份，日期和两位的年份。</span></li></ul><ul><li>.捕获组的内容和捕获组编号之间用反斜杠分隔，因此你的替换表达式应该是<code>20\3-\1-\2</code>.</li><li>如果我们输入的文本中包含03/04/05表示2005年3月4日那么：<ul><li>捕获组1:03</li><li>捕获组2：04</li><li>捕获组3：05</li><li>替换字符串<code style="font-style: inherit; font-weight: inherit;">2005-03-04</code>.</li></ul></li></ul><p>在替换表达式中，你可以多次使用捕获组</p><ul><li>对于双元音，正则表达式为([aeiou])，替换表达式为\l\l</li><li><span style="font-family: Tahoma;">在替换表达式中不能使用反斜杠。</span><span style="color: #888888; font-family: 'Ubuntu Mono', monospace; font-size: medium;">比如，你</span><span style="font-family: Tahoma;">在计算机程序中希望使用字符串中使用部分文本。那么，你必须在每个双引号或者反斜杠之前加上反斜杠。</span></li></ul><ul><li>你的正则表达式可以是<span style="font-family: 'Ubuntu Mono', monospace;"><span style="color: #0000ff;">([\\"])</span><span style="color: #262626;">。</span><span style="color: #262626; font-size: medium;">捕获组1是双引号或者反斜杠</span></span></li><li><span style="color: #262626; font-family: 'Ubuntu Mono', monospace; font-size: medium;">你的替换表达式应该是\\\l</span></li></ul><div><p>在某些实现中，采用美元符号$代替\</p></div><div><h4><strong>练习</strong></h4><p>使用正则表达式和替换表达式，将23h59这样的时间戳转化为23:59.</p><h4><strong>答案</strong></h4><p>正则表达式finds the timestamps, 替换表达式<code>\1:\2</code></p></div><h3></h3><h3>反向引用</h3><p>在一个正则表达式中，你也可以引用捕获组。这称作：反向引用</p><p>比如，[abc]{2}表示匹配aa或者ab或者ac或者ba或者bb或者bc或者ca或者cb或者cc.但是{[abc]}\1表示只匹配aa或者bb或者cc.</p><div><h4><strong>练习</strong></h4><p>在字典中，找到包含两次重复子串的最长单词，比如<code>papa</code>, <code>coco</code></p><p><code>\b(.{6,})\1\b</code> 匹配 <code>chiquichiqui</code>.</p><p><span style="font-family: Tahoma; font-size: medium;">如果我们不在乎单词的完整性，我们可以忽略单词的分解，使用正则表达式 </span><code>(.{7,})\1</code><code><span style="font-family: Tahoma;">匹配</span></code><code>countercountermeasure</code><span style="font-family: Tahoma; font-size: medium;"> 以及 </span><code>countercountermeasures</code><span style="font-family: Tahoma; font-size: medium;">.</span></p><h2>使用正则表达式编程</h2><p>特别提醒：</p><h3>过度使用的反斜杠</h3><p>在一些编程语言，比如Java中，对于包含正则表达式的字符串没有特殊标记。字符串有着自己的过滤规则，这是优先于正则表达式规则的，这是频繁使用反斜杠的原因。</p><p>比如在Java中</p><ul><li>匹配一个数字，使用的正则表达式从\d变为代码中的String re= &#8220;\\d&#8221;</li><li>匹配双引号字符串的正则表达式从<code style="font-style: inherit; font-weight: inherit;">"[^"]*"</code> 变为String re = &#8220;\&#8221;[^\"]*\&#8221;"</li><li><span style="font-family: Tahoma;">匹配反斜杠或者是左边方括号，或者右边方括号的正则表达式从</span><span style="color: #0000ff;">[\\<code class="tex2jax_ignore">\[\]</code>] </span><span style="font-family: Tahoma; font-size: medium;">变为</span>String re = &#8220;[\\\\\<p style="text-align:center;"><span class="MathJax_Preview">\[\\]</span><script type="math/tex;  mode=display">\</script></p>]&#8221;;</li><li><code style="font-style: inherit; font-weight: inherit;">String re = "\\s";</code> 和<code style="font-style: inherit; font-weight: inherit;">String re = "[ \t\r\n]";</code> 是等价的. 注意它们实际执行调用时的层次不同。</li></ul><p>在其他的编程语言中，正则表达式是由特殊标明的，比如使用/。下面是JavaScript的例子：</p><ul><li>匹配一个数字，\d会简单写成 <code style="font-style: inherit; font-weight: inherit;">var regExp = /\d/;</code>.</li><li>匹配一个反斜杠或者一个左边的方括号或者一个右边的方括号， <code style="font-style: inherit; font-weight: inherit;">var regExp = /[\\<code class="tex2jax_ignore">\[\]</code>]/;</code></li><li><code style="font-style: inherit; font-weight: inherit;">var regExp = /\s/;</code> 和 <code style="font-style: inherit; font-weight: inherit;">var regExp = /[ \t\r\n]/;</code> 是等价的</li><li>当然，这意味着在使用/时必须重复两次。比如找到URL必须使用<code style="font-style: inherit; font-weight: inherit;">var regExp = /https?:\/\//;</code>.</li></ul><p>我希望现在你能明白，我为什么让你特别注意反斜杠。</p><h3></h3><h3>动态正则表达式</h3><p>当你动态创建一个正则表达式的时候请特别小心。如果你使用的字符串不够完善的花，可能会有意想不到的匹配结果。这可能导致语法错误，更糟糕的是，你的正则表达式语法正确，但是结果无法预料。</p><p>错误的Java代码：</p><p>String sep = System.getProperty(&#8220;file.separator&#8221;); String[] directories = filePath.split(sep);</p><p><span style="font-family: Tahoma;">Bug:</span><span style="color: #0000ff;">String.split() </span><span style="font-family: Tahoma; font-size: medium;">认为sep是一个正则表达式。但是，在Windows中，Sep是表示匹配一个反斜杠，也就是与正则表达式&#8221;\\&#8221;相同。这个正则表达式是正确的，但是会返回一个异常：</span><code>PatternSyntaxException</code>.</p><p>任何好的编程语言都会提供一种良好的机制来跳过字符串中所有的元字符。在Java中，你可以这样实现：</p><p>String sep = System.getProperty(&#8220;file.separator&#8221;);</p><p>String[] directories = filePath.split(Pattern.quote(sep));</p><h3></h3><h3>循环中的正则表达式</h3><p>将正则表达式字符串加入反复运行的程序中，是一种开销很大的操作。如果你可以在循环中避免使用正则表达式，你可以大大提高效率。</p><h2></h2><h2>其他建议</h2><h3>输入验证</h3><div>正则表达式可以用来进行输入验证。但是严格的输入验证会使得用户体验较差。比如：</div><div></div><h4>信用卡号</h4><p><span style="font-family: Tahoma; font-size: medium;">在一个网站上，我输入了我的卡号比如 </span><code>1234 5678 8765 4321 </code><code><span style="font-family: Tahoma; font-size: medium;">网站拒绝接收。因为它使用了正则表达式\d{16}。</span></code></p><p><code><span style="font-family: Tahoma; font-size: medium;">正则表达式应该考虑到用户输入的空格和短横线。</span></code></p><p>实际上，为什么不先过滤掉所有的非数字字符，然后再进行有效性验证呢？这样做，可以先使用\D以及空的替换表达式。</p><div><h4><strong>练习</strong></h4><p>在不先过滤掉所有的非数字字符的情况下，使用正则表达式验证卡号的正确性。</p><h4><b>答案</b></h4><p><code>\D*(\d\D*){16}</code> is one of several variations which would accomplish this.</p></div><h4></h4><h4>名字</h4><p>不要使用正则表达式来验证姓名。实际上，即使可以，也不要企图验证姓名。</p><p>程序员对名字的错误看法:</p><ul><li>名字中不含空格</li><li>名字中没有连接符号</li><li>名字中只会使用ASCII码字符</li><li>名字中出现的字都在特殊字符集中</li><li>名字至少要有M个字的长度</li><li>名字不会超过N个字的长度</li><li>人们只有一个名</li><li>人们只有一个中间名</li><li>人们只有一个姓（最后三条是从英语的人名考虑）</li></ul><h4></h4><h4>电子邮件地址</h4><p>不要使用正则表达式验证邮箱地址的正确性。</p><p>首先，这样的验证很难是精确的。电子邮件地址是可以用正则表达式验证的，但是表达式会非常的长并且复杂。</p><p>短的正则表达式会导致错误。（你知道吗？电子邮箱地址中会有一些注释）</p><p>第二，即使一个电子邮件地址可以成功匹配正则表达式，也不代表这个邮箱实际存在。邮箱的唯一验证方法，是发送验证邮件。</p><h3></h3><h3>注意</h3><p>在严格的应用场景中，不要使用正则表达式来解析HTML或者XML。解析HTML或者XML：</p><ol><li>使用简单的正则表达式不能完成</li><li>总体来说非常困难</li><li>已经有其他的方法解决</li></ol><p>找到一个已经有的解析库来完成这个工作</p><h2>这就是55分钟的全部内容</h2><p>总结：</p><ul><li>字符: <code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code> etc.</li><li>字符类: <code>.</code> <code>[abc]</code> <code>[a-z]</code> <code>\d</code> <code>\w</code> <code>\s</code><ul><li><code>.</code> 代表任何字符</li><li><code>\d </code><code><span style="color: #262626; font-family: Tahoma; font-size: medium;">表示</span></code><span style="font-family: Tahoma;">&#8220;数字&#8221;</span></li><li><code>\w</code>   表示&#8221;字母&#8221;, <code>[0-9A-Za-z_]</code></li><li><code>\s  </code> 表示 &#8220;空格, 制表符,回车或换行符&#8221;</li><li>否定字符类: <code>[^abc]</code> <code>\D</code> <code>\W</code> <code>\S</code></li></ul></li><li>重复: <code>{4}</code> <code>{3,16}</code> <code>{1,}</code> <code>?</code> <code>*</code> <code>+</code><ul><li><code>?</code> 表示 &#8220;零次或一次&#8221;</li><li><code>*</code> 表示 &#8220;大于零次&#8221;</li><li><code>+</code> 表示 &#8220;一次或一次以上&#8221;</li><li>如果不加上？，所有的重复都是最长匹配的（贪婪）</li></ul></li><li>分组: <code>(Septem|Octo|Novem|Decem)ber</code></li><li>词，行以及文本的分隔: <code>\b</code> <code>^</code> <code>$</code> <code>\A</code> <code>\z</code></li><li>转义字符: <code>\1</code> <code>\2</code> <code>\3</code> etc. (在匹配表达式和替换表达式中都可用)</li></ul><ul><li>元字符: <code>.</code> <code>\</code> <code>[</code> <code>]</code> <code>{</code> <code>}</code> <code>?</code> <code>*</code> <code>+</code> <code>|</code> <code>(</code> <code>)</code> <code>^</code> <code>$</code></li><li>在字符类中使用元字符: <code>[</code> <code>]</code> <code>\</code> <code>-</code> <code>^</code></li><li>使用反斜杠可以忽略元字符: <code>\</code></li></ul><h3> 致谢</h3><p>正则表达式非常常用而且非常有用。每个人在编辑文本或是编写程序时都必须了解怎样使用正则表达式。</p><h4><strong>练习</strong></h4><h4>选择正则表达式的某种实现，阅读相关文档。我保证，你会学到更多。</h4></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;推荐几个正则表达式编辑器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Debuggex ：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuZGVidWdnZXguY29tLw==&quot; title=&quot;https://www.debuggex.com/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FFMpeg实时美颜直播推流</title>
    <link href="http://miaopei.github.io/2019/05/19/FFmpeg/ffmpeg%E5%AE%9E%E6%97%B6%E7%BE%8E%E9%A2%9C%E6%8E%A8%E6%B5%81/"/>
    <id>http://miaopei.github.io/2019/05/19/FFmpeg/ffmpeg实时美颜推流/</id>
    <published>2019-05-19T02:14:50.000Z</published>
    <updated>2019-06-11T09:08:50.443Z</updated>
    
    <content type="html"><![CDATA[<p>实战 - 基于ffmpeg，qt5，opencv视频课程</p><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-直播推流流程分析"><a href="#1-1-直播推流流程分析" class="headerlink" title="1.1 直播推流流程分析"></a>1.1 直播推流流程分析</h3><a id="more"></a><img src="/images/imageFFmpeg/直播.png"><p>rtmp 延时一般 1-3 秒</p><img src="/images/imageFFmpeg/推流流程.png"><h3 id="1-2-直播-rtmp-协议分析"><a href="#1-2-直播-rtmp-协议分析" class="headerlink" title="1.2 直播 rtmp 协议分析"></a>1.2 直播 rtmp 协议分析</h3><img src="/images/imageFFmpeg/协议.png"><img src="/images/imageFFmpeg/传输协议.png"><img src="/images/imageFFmpeg/RTMP.png"><img src="/images/imageFFmpeg/RTMP优缺点.png"><img src="/images/imageFFmpeg/RTMP协议类型.png"><img src="/images/imageFFmpeg/握手.png"><img src="/images/imageFFmpeg/推流.png"><h2 id="2-直播服务器讲解和配置"><a href="#2-直播服务器讲解和配置" class="headerlink" title="2. 直播服务器讲解和配置"></a>2. 直播服务器讲解和配置</h2><img src="/images/imageFFmpeg/流媒体服务器.png"><h3 id="2-1-直播服务器介绍-crtmpserver-编译运行"><a href="#2-1-直播服务器介绍-crtmpserver-编译运行" class="headerlink" title="2.1 直播服务器介绍 crtmpserver 编译运行"></a>2.1 直播服务器介绍 crtmpserver 编译运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-get install wget cmake</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt-get install libssl-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget  https://codeload.github.com/j0sh/crtmpserver/zip/centosinit --no-check-certificate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> unzip centosinit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> builders/cmake</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake . </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./crtmpserver/crtmpserver ./crtmpserver/crtmpserver.lua</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -i test.flv  -f flv rtmp://192.168.1.44/live</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ʹc rtmp://192.168.1.44/live</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ʹplay ffplay rtmp://192.168.1.44/live  -fflags nobuffer</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> error</span></span><br><span class="line">CMake Error at cmake_find_modules/Find_openssl.cmake:99 (MESSAGE):</span><br><span class="line">  Looking for openssl headers - not found</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  CMakeLists.txt:46 (INCLUDE)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -DOPENSSL_ROOT_DIR=/usr/<span class="built_in">local</span>/opt/openssl -DOPENSSL_LIBRARIES=/usr/<span class="built_in">local</span>/opt/openssl/lib</span></span><br></pre></td></tr></table></figure><h3 id="2-2-下载-ffmpeg-工具推流并使用功能-vlc-拉流播放测试"><a href="#2-2-下载-ffmpeg-工具推流并使用功能-vlc-拉流播放测试" class="headerlink" title="2.2 下载 ffmpeg 工具推流并使用功能 vlc 拉流播放测试"></a>2.2 下载 ffmpeg 工具推流并使用功能 vlc 拉流播放测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://nginx.org/download/nginx-1.16.0.tar.gz --no-check-certificate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/arut/nginx-rtmp-module.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --add-module=/home/miaopei/workdir/<span class="built_in">test</span>/ffmpet-test/nginx/nginx-rtmp-module </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/ffmpeg工具推流测试.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx.conf 配置</span></span><br><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4096;</span><br><span class="line">        application live &#123;</span><br><span class="line">            live on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推流命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.mp4 -c copy -f flv rtmp://192.168.2.76/live</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网页查看推流的状态</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    location /stat&#123;</span><br><span class="line">        rtmp_stat all;</span><br><span class="line">        rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">    &#125;</span><br><span class="line">    location /stat.xsl&#123;</span><br><span class="line">        root /home/miaopei/workdir/test/ffmpet-test/nginx/nginx-rtmp-module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reload config:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s reload</span></span><br><span class="line">Reopen Logfile:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s reopen</span></span><br><span class="line">Stop process:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s stop</span></span><br><span class="line">Waiting on exit process</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s quit</span></span><br></pre></td></tr></table></figure><h2 id="3-FFMpeg-SDK-解封和推流"><a href="#3-FFMpeg-SDK-解封和推流" class="headerlink" title="3. FFMpeg SDK 解封和推流"></a>3. FFMpeg SDK 解封和推流</h2><h3 id="3-1-ffmpeg-SDK开发环境准备"><a href="#3-1-ffmpeg-SDK开发环境准备" class="headerlink" title="3.1 ffmpeg SDK开发环境准备"></a>3.1 ffmpeg SDK开发环境准备</h3><img src="/images/imageFFmpeg/使用FFMpegSDK推流.png"><img src="/images/imageFFmpeg/avformat_open_input.png"><img src="/images/imageFFmpeg/AVFormatContext.png"><img src="/images/imageFFmpeg/AVStream.png"><img src="/images/imageFFmpeg/AVPacket.png"><img src="/images/imageFFmpeg/GOP.png"><img src="/images/imageFFmpeg/基于海康或大华相机推流.png"><h2 id="4-OpencvSDK-基础"><a href="#4-OpencvSDK-基础" class="headerlink" title="4. OpencvSDK 基础"></a>4. OpencvSDK 基础</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNjQxOTAvYXJ0aWNsZS9kZXRhaWxzLzc5MTA4NjA4" title="https://blog.csdn.net/u010164190/article/details/79108608">Mac源码安装使用OpenCV<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hcmtzaW0vYXJ0aWNsZS9kZXRhaWxzLzc5MTQ2MzQ2" title="https://blog.csdn.net/marksim/article/details/79146346">在MacOS 10.13.2 下编译 OpenCV3.4.0 + OpenCV Contrib 3.4.0 成 Java 库<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hMzZkNDEyNDFhZTg=" title="https://www.jianshu.com/p/a36d41241ae8">在MacOS上安装OpenCV 3.4(c++)<i class="fa fa-external-link"></i></span></p></blockquote><details><summary>OpenCV 源码编译：</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 OpenCV 3.4.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压，进入到 opencv-3.4.0 目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p build/install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -G <span class="string">"Unix Makefiles"</span> -j8 -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_OSX_ARCHITECTURES=x86_64 -D CMAKE_INSTALL_PREFIX=/Users/miaopei/install/opencv/opencv-3.4.0/build/install ../</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j8</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib/pkgconfig</span><br><span class="line">export PKG_CONFIG_PATH</span><br><span class="line">export LD_LIBRARY_PATH=Users/miaopei/install/opencv/opencv-3.4.0/build/install/bin:SLD_LIBRARY_PATH</span><br><span class="line">export PATH=$&#123;PATH&#125;:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试demo,打印当前版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;opencv2/core/utility.hpp&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;iostream&gt;</span></span><br><span class="line">int main(int argc, const char* argv[])&#123;</span><br><span class="line">  std::cout &lt;&lt; "Welcome to OpenCV " &lt;&lt; CV_VERSION &lt;&lt; std::endl; </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Makefile</span></span><br><span class="line">CXX ?= g++</span><br><span class="line">CXXFLAGS += -c -Wall $(shell pkg-config --cflags opencv)</span><br><span class="line">LDFLAGS += $(shell pkg-config --libs --static opencv)</span><br><span class="line">all: test_version</span><br><span class="line">opencv_example: test_version.o; $(CXX) $&lt; -o $@ $(LDFLAGS)</span><br><span class="line"><span class="meta">%</span><span class="bash">.o: %.cpp; $(CXX) $&lt; -o <span class="variable">$@</span> $(CXXFLAGS)</span></span><br><span class="line">clean: ; rm -f test_version.o test_version</span><br></pre></td></tr></table></figure></details><img src="/images/imageFFmpeg/第一个例子显示图片.png"><img src="/images/imageFFmpeg/waitKey.png"><h3 id="4-1-VideoCapture打开摄像头接口讲解和源码分析"><a href="#4-1-VideoCapture打开摄像头接口讲解和源码分析" class="headerlink" title="4.1 VideoCapture打开摄像头接口讲解和源码分析"></a>4.1 VideoCapture打开摄像头接口讲解和源码分析</h3><img src="/images/imageFFmpeg/打开摄像头接口说明和源码分析.png"><img src="/images/imageFFmpeg/创建和清理mat空间.png"><img src="/images/imageFFmpeg/图像存放方式-连续.png"><img src="/images/imageFFmpeg/isContinuous.png"><img src="/images/imageFFmpeg/直接地址访问连续空间.png"><img src="/images/imageFFmpeg/读取一帧视频.png"><h2 id="5-视频采集编码推流和类封装"><a href="#5-视频采集编码推流和类封装" class="headerlink" title="5. 视频采集编码推流和类封装"></a>5. 视频采集编码推流和类封装</h2><img src="/images/imageFFmpeg/基于opencv采集推流.png"><img src="/images/imageFFmpeg/opencv采集rtsp解码.png"><img src="/images/imageFFmpeg/sws_getCachedContext.png"><img src="/images/imageFFmpeg/sws_scale.png"><img src="/images/imageFFmpeg/avcodec_find_encoder.png"><img src="/images/imageFFmpeg/avcodec_alloc_context3.png"><img src="/images/imageFFmpeg/avcodec_alloc_context3-01.png"><img src="/images/imageFFmpeg/gop-01.png"><img src="/images/imageFFmpeg/avcodec_send_frame.png"><h2 id="6-音频录制编码推流和类封装"><a href="#6-音频录制编码推流和类封装" class="headerlink" title="6. 音频录制编码推流和类封装"></a>6. 音频录制编码推流和类封装</h2><img src="/images/imageFFmpeg/音频.png"><img src="/images/imageFFmpeg/样本类型planar.png"><img src="/images/imageFFmpeg/大小端模式.png"><img src="/images/imageFFmpeg/一帧数据量.png"><p>QT音频录制接口：</p><img src="/images/imageFFmpeg/QAudioFormat.png"><img src="/images/imageFFmpeg/QAudioInput.png"><img src="/images/imageFFmpeg/QIODevice.png"><h2 id="7-音视频同步编码推流处理"><a href="#7-音视频同步编码推流处理" class="headerlink" title="7. 音视频同步编码推流处理"></a>7. 音视频同步编码推流处理</h2><img src="/images/imageFFmpeg/视频录制接口封装.png"><img src="/images/imageFFmpeg/音视频同步.png"><h2 id="8-XRtmpStreamer-项目完成（界面和美颜）"><a href="#8-XRtmpStreamer-项目完成（界面和美颜）" class="headerlink" title="8. XRtmpStreamer 项目完成（界面和美颜）"></a>8. XRtmpStreamer 项目完成（界面和美颜）</h2><p>直播推流要求实时性，一秒钟25帧，做美颜的总耗时一定要低于40ms（每帧消耗40ms）</p><p>现在视频推流一般都是1280 X 720</p><p>手机端是基于GPU 第三方库做的计算</p><p>美颜算法一般都是基于GPU做的</p><img src="/images/imageFFmpeg/使用opencv磨皮.png"><img src="/images/imageFFmpeg/bilateralFilter双边滤波-边缘平滑.png"><img src="/images/imageFFmpeg/自定义过滤器类XFilter.png"><img src="/images/imageFFmpeg/XController.png"><img src="/images/imageFFmpeg/类图.png"><p><strong>头文件尽量不用引用命名空间，因为不知道谁来调用，可能会出现问题</strong>。</p><p><strong>头文件中尽量不要引用第三方库文件，应为涉及到第三方库版本升级之类的，第三方头文件的引用应该在代码中引用</strong>。</p><h2 id="9-补充"><a href="#9-补充" class="headerlink" title="9. 补充"></a>9. 补充</h2><h3 id="9-0-流媒体协议介绍（rtp-rtcp-rtsp-rtmp-mms-hls）"><a href="#9-0-流媒体协议介绍（rtp-rtcp-rtsp-rtmp-mms-hls）" class="headerlink" title="9.0 流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）"></a>9.0 流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）</h3><p><strong>1. RTP</strong>：</p><blockquote><p>参考文档 RFC3550/RFC3551</p></blockquote><p>(Real-time Transport Protocol) 是用于 Internet 上针对多媒体数据流的一种传输层协议。RTP 协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP 协议常用于流媒体系统（配合 RTCP协议），视频会议和一键通（Push to Talk）系统（配合 H.323 或 SIP），使它成为 IP 电话产业的技术基础。<strong>RTP 协议和 RTP 控制协议 RTCP 一起使用</strong>，而且它是建立在 <strong>UDP</strong> 协议上的。</p><p><strong>RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证</strong>，它依赖于低层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。</p><p><strong>RTP 由两个紧密链接部分组成</strong>： </p><ul><li>RTP ― 传送具有实时属性的数据；</li><li>RTP 控制协议（RTCP） ― 监控服务质量并传送正在进行的会话参与者的相关信息。</li></ul><p><strong>2. RTCP</strong></p><p>实时传输控制协议（Real-time Transport Control Protocol 或 RTP Control Protocol 或简写 RTCP）是实时传输协议（RTP）的一个姐妹协议。RTCP 为 RTP 媒体流提供信道外（out-of-band）控制。<strong>RTCP 本身并不传输数据，但和 RTP 一起协作将多媒体数据打包和发送</strong>。RTCP 定期在流多媒体会话参加者之间传输控制数据。RTCP 的主要功能是为 RTP 所提供的服务质量（Quality of Service）提供反馈。</p><p>RTCP 收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等等。网络应用程序可以利用 RTCP 所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP 本身不提供数据加密或身份认证。SRTCP 可以用于此类用途。</p><p><strong>3. SRTP &amp; SRTCP</strong></p><blockquote><p>参考文档 RFC3711</p></blockquote><p>安全实时传输协议（Secure Real-time Transport Protocol 或 SRTP）是在实时传输协议（Real-time Transport Protocol 或 RTP）基础上所定义的一个协议，<strong>旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护</strong>。它是由 David Oran（思科）和 Rolf Blom（爱立信）开发的，并最早由 IETF 于 2004年3月作为 RFC3711 发布。</p><p>由于实时传输协议和可以被用来控制实时传输协议的会话的实时传输控制协议（RTP Control Protocol 或 RTCP）有着紧密的联系，安全实时传输协议同样也有一个伴生协议，它被称为安全实时传输控制协议（Secure RTCP 或 SRTCP）；安全实时传输控制协议为实时传输控制协议提供类似的与安全有关的特性，就像安全实时传输协议为实时传输协议提供的那些一样。</p><p>在使用实时传输协议或实时传输控制协议时，使不使用安全实时传输协议或安全实时传输控制协议是可选的；但即使使用了安全实时传输协议或安全实时传输控制协议，所有它们提供的特性（如加密和认证）也都是可选的，这些特性可以被独立地使用或禁用。唯一的例外是在使用安全实时传输控制协议时，必须要用到其消息认证特性。</p><p><strong>4. RTSP</strong></p><blockquote><p>参考文档 RFC2326</p></blockquote><p>是由 Real Networks 和 Netscape 共同提出的。该协议定义了一对多应用程序如何有效地通过 IP 网络传送多媒体数据。RTSP 提供了一个可扩展框架，使实时数据，如音频与视频的受控、点播成为可能。数据源包括现场数据与存储在剪辑中的数据。<strong>该协议目的在于控制多个数据发送连接，为选择发送通道，如UDP、多播UDP与TCP提供途径，并为选择基于RTP上发送机制提供方法</strong>。</p><p>RTSP（Real Time Streaming Protocol）是用来控制声音或影像的多媒体串流协议，并允许同时多个串流需求控制，传输时所用的网络通讯协定并不在其定义的范围内，服务器端可以自行选择使用 TCP 或 UDP来传送串流内容，它的语法和运作跟 HTTP 1.1 类似，<strong>但并不特别强调时间同步，所以比较能容忍网络延迟</strong>。而前面提到的允许同时多个串流需求控制（Multicast），除了可以降低服务器端的网络用量，更进而支持多方视讯会议（Video Conference）。 因为与 HTTP1.1 的运作方式相似，所以代理服务器《Proxy》的快取功能《Cache》也同样适用于 RTSP，并因 RTSP 具有重新导向功能，可视实际负载情况来转换提供服务的服务器，以避免过大的负载集中于同一服务器而造成延迟。</p><p><strong>5. RTSP 和 RTP 的关系</strong></p><p>RTP 不象 http 和 ftp 可完整的下载整个影视文件，它是以固定的数据率在网络上发送数据，客户端也是按照这种速度观看影视文件，当影视画面播放过后，就不可以再重复播放，除非重新向服务器端要求数据。</p><p>RTSP 与 RTP 最大的区别在于：RTSP 是一种双向实时数据传输协议，它允许客户端向服务器端发送请求，如回放、快进、倒退等操作。当然，RTSP 可基于 RTP 来传送数据，还可以选择 TCP、UDP、组播 UDP 等通道来发送数据，具有很好的扩展性。它是一种类似与 http 协议的网络应用层协议。目前碰到的一个应用：服务器端实时采集、编码并发送两路视频，客户端接收并显示两路视频。由于客户端不必对视频数据做任何回放、倒退等操作，可直接采用 UDP + RTP + 组播实现。</p><img src="/images/imageFFmpeg/RTSP和RTP的关系.png"><p>RTP：实时传输协议（Real-time Transport Protocol） </p><ul><li><p>RTP/RTCP 是实际传输数据的协议 </p></li><li><p>RTP 传输音频/视频数据，如果是 PLAY，Server 发送到 Client 端，如果是 RECORD，可以由Client 发送到 Server </p></li><li><p>整个 RTP 协议由两个密切相关的部分组成：</p><ul><li>RTP数据协议</li><li>RTP控制协议（即RTCP） </li></ul></li></ul><p>RTSP：实时流协议（Real Time Streaming Protocol，RTSP） </p><ul><li><p>RTSP 的请求主要有 DESCRIBE, SETUP, PLAY, PAUSE, TEARDOWN, OPTIONS 等，顾名思义可以知道起对话和控制作用 </p></li><li><p>RTSP 的对话过程中 SETUP 可以确定 RTP/RTCP 使用的端口，PLAY/PAUSE/TEARDOWN 可以开始或者停止 RTP 的发送，等等 </p></li></ul><p>RTCP： </p><ul><li>RTCP 包括 Sender Report 和 Receiver Report，用来进行音频/视频的同步以及其他用途，是一种控制协议</li></ul><p><strong>6. SDP</strong></p><p>会话描述协议（SDP）为会话通知、会话邀请和其它形式的多媒体会话初始化等目的提供了多媒体会话描述。</p><p>会话目录用于协助多媒体会议的通告，并为会话参与者传送相关设置信息。SDP 即用于将这种信息传输到接收端。<strong>SDP 完全是一种会话描述格式 ― 它不属于传输协议 ― 它只使用不同的适当的传输协议，包括会话通知协议（SAP）、会话初始协议（SIP）、实时流协议（RTSP）、MIME 扩展协议的电子邮件以及超文本传输协议（HTTP）</strong>。</p><p>SDP 的设计宗旨是通用性，它可以应用于大范围的网络环境和应用程序，而不仅仅局限于组播会话目录，<strong>但 SDP 不支持会话内容或媒体编码的协商</strong>。</p><p>在因特网组播骨干网（Mbone）中，会话目录工具被用于通告多媒体会议，并为参与者传送会议地址和参与者所需的会议特定工具信息，这由 SDP 完成。SDP 连接好会话后，传送足够的信息给会话参与者。SDP 信息发送利用了会话通知协议（SAP），它周期性地组播通知数据包到已知组播地址和端口处。这些信息是 UDP 数据包，其中包含 SAP 协议头和文本有效载荷（text payload）。这里文本有效载荷指的是 SDP 会话描述。此外信息也可以通过电子邮件或 WWW （World Wide Web） 进行发送。</p><p><strong>SDP 文本信息包括</strong>：</p><ul><li>会话名称和意图；</li><li>会话持续时间；</li><li>构成会话的媒体；</li><li>有关接收媒体的信息（地址等）。</li><li>协议结构</li></ul><p><strong>SDP 信息是文本信息，采用 UTF-8 编 码中的 ISO 10646 字符集。SDP 会话描述如下：（标注 * 符号的表示可选字段）</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v = （协议版本）</span><br><span class="line">o = （所有者/创建者和会话标识符）</span><br><span class="line">s = （会话名称）</span><br><span class="line">i = * （会话信息）</span><br><span class="line">u = * （URI 描述）</span><br><span class="line">e = * （Email 地址）</span><br><span class="line">p = * （电话号码）</span><br><span class="line">c = * （连接信息 ― 如果包含在所有媒体中，则不需要该字段）</span><br><span class="line">b = * （带宽信息）</span><br></pre></td></tr></table></figure><p>一个或更多时间描述（如下所示）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z = * （时间区域调整）</span><br><span class="line">k = * （加密密钥）</span><br><span class="line">a = * （0 个或多个会话属性行）</span><br></pre></td></tr></table></figure><p>0个或多个媒体描述（如下所示）</p><p>时间描述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = （会话活动时间）</span><br><span class="line">r = * （0或多次重复次数）</span><br></pre></td></tr></table></figure><p>媒体描述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = （媒体名称和传输地址）</span><br><span class="line">i = * （媒体标题）</span><br><span class="line">c = * （连接信息 — 如果包含在会话层则该字段可选）</span><br><span class="line">b = * （带宽信息）</span><br><span class="line">k = * （加密密钥）</span><br><span class="line">a = * （0 个或多个会话属性行）</span><br></pre></td></tr></table></figure><p><strong>7. RTMP/RTMPS</strong></p><p>RTMP(Real Time Messaging Protocol) 实时消息传送协议是 Adobe Systems 公司为 Flash 播放器和服务器之间音频、视频和数据传输 开发的开放协议。</p><p>它有三种变种：</p><blockquote><p>1) 工作在 TCP 之上的明文协议，使用端口1935；</p><p>2) RTMPT 封装在 HTTP 请求之中，可穿越防火墙；</p><p>3) RTMPS 类似 RTMPT，但使用的是 HTTPS 连接；</p></blockquote><p>RTMP 协议(Real Time Messaging Protocol)是被 Flash 用于对象, 视频, 音频的传输. <strong>这个协议建立在 TCP 协议或者轮询 HTTP 协议之上</strong>.</p><p>RTMP 协议就像一个用来装数据包的容器, 这些数据既可以是 AMF 格式的数据,也可以是 FLV 中的视/音频数据. 一个单一的连接可以通过不同的通道传输多路网络流. 这些通道中的包都是按照固定大小的包传输的.</p><p><strong>8. mms</strong></p><p>MMS (Microsoft Media Server Protocol)，中文“微软媒体服务器协议”，用来访问并流式接收 Windows Media 服务器中 <code>.asf</code> 文件的一种协议。MMS 协议用于访问 Windows Media 发布点上的单播内容。MMS 是连接 Windows Media 单播服务的默认方法。若观众在 Windows Media Player 中键入一个 URL 以连接内容，而不是通过超级链接访问内容，则他们必须使用MMS 协议引用该流。MMS的预设埠（端口）是1755</p><p>当使用 MMS 协议连接到发布点时，使用协议翻转以获得最佳连接。“协议翻转”始于试图通过 MMSU 连接客户端。 MMSU 是 MMS 协议结合 UDP 数据传送。如果 MMSU 连接不成功，则服务器试图使用 MMST。MMST 是 MMS 协议结合 TCP 数据传送。</p><p>如果连接到编入索引的 <code>.asf</code> 文件，想要快进、后退、暂停、开始和停止流，则必须使用 MMS。不能用 UNC 路径快进或后退。若您从独立的 Windows Media Player 连接到发布点，则必须指定单播内容的 URL。若内容在主发布点点播发布，则 URL 由服务器名和 <code>.asf</code> 文件名组成。例如：<code>mms://windows_media_server/sample.asf</code>。其中 windows_media_server 是 Windows Media 服务器名，sample.asf 是您想要使之转化为流的 <code>.asf</code> 文件名。</p><p>若您有实时内容要通过广播单播发布，则该 URL 由服务器名和发布点别名组成。例如：<code>mms://windows_media_server/LiveEvents</code>。这里 windows_media_server 是 Windows Media 服务器名，而 LiveEvents 是发布点名</p><p><strong>9. HLS</strong></p><p>HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在 iOS 系统，为 iOS 设备（如iPhone、iPad）提供音视频直播和点播方案。HLS 点播，基本上就是常见的分段 HTTP 点播，不同在于，它的分段非常小。</p><p>相对于常见的流媒体直播协议，例如 RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS 协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，<strong>HLS 是以点播的技术方式来实现直播</strong>。由于数据通过 HTTP 协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过 HLS 的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。　</p><p>根据以上的了解要实现 HTTP Live Streaming 直播，需要研究并实现以下技术关键点：</p><ul><li>采集视频源和音频源的数据</li><li>对原始数据进行H264编码和AAC编码</li><li>视频和音频数据封装为MPEG-TS包</li><li>HLS分段生成策略及m3u8索引文件</li><li>HTTP传输协议</li></ul><h3 id="9-1-HLS，RTSP，RTMP的区别"><a href="#9-1-HLS，RTSP，RTMP的区别" class="headerlink" title="9.1 HLS，RTSP，RTMP的区别"></a>9.1 HLS，RTSP，RTMP的区别</h3><ul><li><p>HLS （ HTTP Live Streaming）苹果公司提出的流媒体协议，直接把流媒体切片成一段段，信息保存到m3u列表文件中，可以将不同速率的版本切成相应的片；播放器可以直接使用http协议请求流数据，可以在不同速率的版本间自由切换，实现无缝播放；省去使用其他协议的烦恼。缺点是延迟大小受切片大小影响，不适合直播，适合视频点播。</p></li><li><p>RTSP （Real-Time Stream Protocol）由Real Networks 和 Netscape共同提出的，基于文本的多媒体播放控制协议。RTSP定义流格式，流数据经由RTP传输；RTSP实时效果非常好，适合视频聊天，视频监控等方向。</p></li><li><p>RTMP（Real Time Message Protocol） 有 Adobe 公司提出，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题，优势在于低延迟，稳定性高，支持所有摄像头格式，浏览器加载 flash插件就可以直接播放。</p></li></ul><p>总结：HLS 延迟大，适合视频点播；RTSP虽然实时性最好，但是实现复杂，适合视频聊天和视频监控；RTMP强在浏览器支持好，加载flash插件后就能直接播放，所以非常火，相反在浏览器里播放rtsp就很困难了。</p><h3 id="9-2-RTSP、RTCP、RTP区别"><a href="#9-2-RTSP、RTCP、RTP区别" class="headerlink" title="9.2 RTSP、RTCP、RTP区别"></a>9.2 RTSP、RTCP、RTP区别</h3><p><strong>1：RTSP实时流协议</strong></p><p>作为一个应用层协议，RTSP提供了一个可供扩展的框架，它的意义在于使得实时流媒体数据的受控和点播变得可能。总的说来，RTSP是一个流媒体表示 协议，主要用来控制具有实时特性的数据发送，但它本身并不传输数据，而是必须依赖于下层传输协议所提供的某些服务。RTSP可以对流媒体提供诸如播放、暂 停、快进等操作，它负责定义具体的控制消息、操作方法、状态码等，此外还描述了与RTP间的交互操作（RFC2326）。</p><p><strong>2：RTCP控制协议</strong></p><p>RTCP控制协议需要与RTP数据协议一起配合使用，当应用程序启动一个RTP会话时将同时占用两个端口，分别供RTP和RTCP使用。RTP本身并 不能为按序传输数据包提供可靠的保证，也不提供流量控制和拥塞控制，这些都由RTCP来负责完成。通常RTCP会采用与RTP相同的分发机制，向会话中的 所有成员周期性地发送控制信息，应用程序通过接收这些数据，从中获取会话参与者的相关资料，以及网络状况、分组丢失概率等反馈信息，从而能够对服务质量进 行控制或者对网络状况进行诊断。</p><p>RTCP协议的功能是通过不同的RTCP数据报来实现的，主要有如下几种类型：</p><ul><li><p>SR：发送端报告，所谓发送端是指发出RTP数据报的应用程序或者终端，发送端同时也可以是接收端。(SERVER定时间发送给CLIENT)。</p></li><li><p>RR：接收端报告，所谓接收端是指仅接收但不发送RTP数据报的应用程序或者终端。(SERVER接收CLIENT端发送过来的响应)。</p></li><li><p>SDES：源描述，主要功能是作为会话成员有关标识信息的载体，如用户名、邮件地址、电话号码等，此外还具有向会话成员传达会话控制信息的功能。</p></li><li><p>BYE：通知离开，主要功能是指示某一个或者几个源不再有效，即通知会话中的其他成员自己将退出会话。</p></li><li><p>APP：由应用程序自己定义，解决了RTCP的扩展性问题，并且为协议的实现者提供了很大的灵活性。</p></li></ul><p><strong>3：RTP数据协议</strong></p><p>RTP数据协议负责对流媒体数据进行封包并实现媒体流的实时传输，每一个RTP数据报都由头部（Header）和负载（Payload）两个部分组成，其中头部前12个字节的含义是固定的，而负载则可以是音频或者视频数据。</p><p>RTP用到的地方就是 PLAY ，服务器往客户端传输数据用UDP协议，RTP是在传输数据的前面加了个12字节的头(描述信息)。</p><p>RTP载荷封装设计本文的网络传输是基于IP协议，所以最大传输单元(MTU)最大为1500字节，在使用IP／UDP／RTP的协议层次结构的时候，这 其中包括至少20字节的IP头，8字节的UDP头，以及12字节的RTP头。这样，头信息至少要占用40个字节，那么RTP载荷的最大尺寸为1460字 节。以H264 为例，如果一帧数据大于1460，则需要分片打包，然后到接收端再拆包，组合成一帧数据，进行解码播放。</p><h3 id="9-3-RTSP、-RTMP、HTTP的共同点、区别"><a href="#9-3-RTSP、-RTMP、HTTP的共同点、区别" class="headerlink" title="9.3 RTSP、 RTMP、HTTP的共同点、区别"></a>9.3 RTSP、 RTMP、HTTP的共同点、区别</h3><p>共同点：</p><ul><li>RTSP RTMP HTTP都是在应用应用层。</li><li>理论上RTSP RTMPHTTP都可以做直播和点播，但一般做直播用RTSP RTMP，做点播用HTTP。做视频会议的时候原来用SIP协议，现在基本上被RTMP协议取代了。</li></ul><p>区别：</p><ul><li><p>HTTP: 即超文本传送协议(ftp即文件传输协议)。</p><ul><li><p>HTTP:（Real Time Streaming Protocol），实时流传输协议。</p></li><li><p>HTTP全称Routing Table Maintenance Protocol（路由选择表维护协议）。</p></li></ul></li><li><p>HTTP将所有的数据作为文件做处理。http协议不是流媒体协议。</p><ul><li>RTMP 和 RTSP协议是流媒体协议。</li></ul></li><li><p>RTMP协议是Adobe的私有协议,未完全公开，RTSP协议和HTTP协议是共有协议，并有专门机构做维护。</p></li><li><p>RTMP协议一般传输的是flv，f4v格式流，RTSP协议一般传输的是ts,mp4格式的流。HTTP没有特定的流。</p></li><li><p>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实战 - 基于ffmpeg，qt5，opencv视频课程&lt;/p&gt;
&lt;h2 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1. 基础知识&quot;&gt;&lt;/a&gt;1. 基础知识&lt;/h2&gt;&lt;h3 id=&quot;1-1-直播推流流程分析&quot;&gt;&lt;a href=&quot;#1-1-直播推流流程分析&quot; class=&quot;headerlink&quot; title=&quot;1.1 直播推流流程分析&quot;&gt;&lt;/a&gt;1.1 直播推流流程分析&lt;/h3&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC</title>
    <link href="http://miaopei.github.io/2019/05/14/WebRTC/webrtc/"/>
    <id>http://miaopei.github.io/2019/05/14/WebRTC/webrtc/</id>
    <published>2019-05-14T02:14:50.000Z</published>
    <updated>2019-06-11T09:10:45.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h1><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYlJUQ19BUEk=" title="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API">WebRTC API<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkv" title="http://nodejs.cn/api/">Node.js v10.15.3 文档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI1MjM1MzU5MDQw" title="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040">廖雪峰 - nodejs<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-WebRTC-介绍"><a href="#1-WebRTC-介绍" class="headerlink" title="1. WebRTC 介绍"></a>1. WebRTC 介绍</h2><a id="more"></a><ul><li>Google 开源</li><li>跨平台</li><li>用于浏览器</li><li>实时传输<ul><li>100ms 延迟 通话质量非常好</li><li>200ms 延迟 通话质量比较优质</li><li>500ms 延迟 可以接受</li><li>超过1s 非常迟滞</li></ul></li><li>音视频引擎</li></ul><p>WebRTC 应用：</p><img src="/images/imageWebRTC/webrtc应用.png"><p>WebRTC 愿景：</p><img src="/images/imageWebRTC/webrtc愿景.png"><p>学习 WebRTC 的难点：</p><img src="/images/imageWebRTC/学习WebRTC的难点.png"><p>学习路线：</p><img src="/images/imageWebRTC/学习路线.png"><p>学习内容：</p><img src="/images/imageWebRTC/学习内容.png"><p>学习收获：</p><img src="/images/imageWebRTC/学习收获.png"><p>WebRTC能做啥：</p><img src="/images/imageWebRTC/WebRTC能做啥.png"><p>能学到什么：</p><img src="/images/imageWebRTC/能学到什么.png"><p>google webrtc 示例：<span class="exturl" data-url="aHR0cHM6Ly9hcHByLnRjLw==" title="https://appr.tc/">https://appr.tc/<i class="fa fa-external-link"></i></span></p><h2 id="2-WebRTC-原理与架构"><a href="#2-WebRTC-原理与架构" class="headerlink" title="2. WebRTC 原理与架构"></a>2. WebRTC 原理与架构</h2><p>WebRTC 整体架构：</p><img src="/images/imageWebRTC/webrtc架构.png"><p>WebRTC 的目录结构图：</p><img src="/images/imageWebRTC/WebRTC目录结构-01.png"><img src="/images/imageWebRTC/WebRTC目录结构-02.png"><img src="/images/imageWebRTC/WebRTCModules目录-01.png"><img src="/images/imageWebRTC/WebRTCModules目录-02.png"><p>WebRTC 两个基本概念：轨与流</p><ul><li>Track</li><li>MediaStream</li></ul><p>WebRTC重要类：</p><ul><li>MediaStream</li><li>RTCPeerConnection</li><li>RTCDataChannel</li></ul><p>PeerConnection调用过程：</p><img src="/images/imageWebRTC/PeerConnection调用过程.png"><p>调用时序图：</p><img src="/images/imageWebRTC/调用时序图.png"><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3RoZXIvcC9teVBlZXJDb25uZWN0aW9uLmh0bWw=" title="https://www.cnblogs.com/cther/p/myPeerConnection.html">WebRTC之PeerConnection的建立过程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80Mzk1N2VlMThmMWE=" title="https://www.jianshu.com/p/43957ee18f1a">WebRTC系列（3）：PeerConnection通信建立流程<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="3-Web服务器原理与Nodejs搭建"><a href="#3-Web服务器原理与Nodejs搭建" class="headerlink" title="3. Web服务器原理与Nodejs搭建"></a>3. Web服务器原理与Nodejs搭建</h2><p>Web服务器选型：</p><ul><li>Nodejs</li><li>Nginx</li><li>Apache</li></ul><p>Web服务工作原理：</p><img src="/images/imageWebRTC/web服务工作原理.png"><p>Nodejs工作原理：</p><img src="/images/imageWebRTC/Nodejs工作原理.png"><p>JavaScript解析：</p><img src="/images/imageWebRTC/JavaScript解析.png"><p>Nodejs 事件处理：</p><img src="/images/imageWebRTC/Nodejs事件处理.png"><p>两个V8引擎：</p><img src="/images/imageWebRTC/两个V8引擎.png"><p>最简单的http服务：</p><ul><li><strong>require</strong> 引入http模块</li><li>创建http服务</li><li>侦听端口</li></ul><p>启动Nodejs服务：</p><ul><li>node app.js</li><li>nohub node app.js</li><li>forever start app.js</li><li>pm2 start app.js</li></ul><p>Https基本原理：</p><img src="/images/imageWebRTC/https基本原理.png"><p>Nodejs 搭建 https 服务：</p><ul><li>生成 HTTPS证书</li><li>引入 HTTPS模块</li><li>指定证书位置，并创建 HTTPS 服务</li></ul><p>真正的Web服务：</p><ul><li>引用 express 模块</li><li>引入 server-index 模块</li><li>指定发布目录</li></ul><h2 id="4-JavaScript-必备知识回顾"><a href="#4-JavaScript-必备知识回顾" class="headerlink" title="4. JavaScript 必备知识回顾"></a>4. JavaScript 必备知识回顾</h2><p>基础知识：</p><ul><li>变量与类型</li><li>基本运算</li><li><code>if/else</code></li><li>for循环</li><li>函数</li><li>日志打印</li></ul><p>变量与类型：</p><img src="/images/imageWebRTC/变量与类型.png"><p>基本运算：</p><img src="/images/imageWebRTC/基本运算.png"><img src="/images/imageWebRTC/ifelse.png"><img src="/images/imageWebRTC/for循环.png"><img src="/images/imageWebRTC/函数.png"><h2 id="5-WebRTC设备管理"><a href="#5-WebRTC设备管理" class="headerlink" title="5. WebRTC设备管理"></a>5. WebRTC设备管理</h2><p>enumerateDevices：</p><img src="/images/imageWebRTC/enumerateDevices.png"><p>JavaScript中的Promise：</p><img src="/images/imageWebRTC/JavaScript中的Promise.png"><h2 id="6-WebRTC音视频数据采集"><a href="#6-WebRTC音视频数据采集" class="headerlink" title="6. WebRTC音视频数据采集"></a>6. WebRTC音视频数据采集</h2><p>音视频采集API：</p><img src="/images/imageWebRTC/音视频采集API.png"><p>getUserMedia的不同实现：</p><img src="/images/imageWebRTC/getUserMedia的不同实现.png"><p>适配置不同浏览器的方法：</p><img src="/images/imageWebRTC/适配置不同浏览器的方法.png"><p><code>https://webrtc.github.io/adapter/adapter-latest.js</code></p><p>WebRTC音视频采集约束：</p><p>约束详解：</p><ul><li><p>width</p></li><li><p>height</p><p>宽高比例：<code>4:3</code>  <code>16:9</code></p></li><li><p>aspectRatio</p></li><li><p>frameRate</p></li><li><p>facingMode</p><ul><li>user - 前置摄像头</li><li>environment - 后置摄像头</li><li>left - 前置左侧摄像头</li><li>right - 前置右侧摄像头</li></ul></li><li><p>resizeMode</p></li></ul><p>音频约束详解：</p><ul><li>volume - <code>范围 0 - 1.0</code></li><li>sampleRate</li><li>sampleSize -  一般16位</li><li>echoCancellation - 回音消除</li><li>autoGainControl - 是否在原有声音基础上增加音量</li><li>noiseSuppression - 降噪</li><li>latency - 延迟大小</li><li>channelCount - 声道  乐器一般是双声道</li><li>deviceID - 作用是多个设备切换</li><li>groupID </li></ul><p>WebRTC约束例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    audio: true,</span><br><span class="line">    video: &#123;</span><br><span class="line">        width: &#123;</span><br><span class="line">            min: 300,</span><br><span class="line">            max: 640,</span><br><span class="line">        &#125;,</span><br><span class="line">        height: &#123;</span><br><span class="line">            min: 300,</span><br><span class="line">            max: 480,</span><br><span class="line">        &#125;,</span><br><span class="line">        frameRate: &#123;</span><br><span class="line">            min: 15,</span><br><span class="line">            max: 30,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器视频特效：</p><ul><li>CSS filter，<code>-webkit-filter/filter</code></li><li>如何将 video 与 filter 关联</li><li>OpenGL/Metal/…</li></ul><p>支持的特效种类：</p><img src="/images/imageWebRTC/支持的特效种类.png"><p>保存图片是实现滤镜效果，可以对 canvas.data 进行数据修改。</p><p>MediaStream API 获取视频约束：</p><img src="/images/imageWebRTC/MediaStream.png"><img src="/images/imageWebRTC/MediaStream事件.png"><h2 id="7-WebRTC音视频录制实战"><a href="#7-WebRTC音视频录制实战" class="headerlink" title="7. WebRTC音视频录制实战"></a>7. WebRTC音视频录制实战</h2><h3 id="7-1-WebRTC录制基本知识"><a href="#7-1-WebRTC录制基本知识" class="headerlink" title="7.1 WebRTC录制基本知识"></a>7.1 WebRTC录制基本知识</h3><p>MediaRecoder类：</p><img src="/images/imageWebRTC/MediaRecoder.png"><img src="/images/imageWebRTC/MediaRecorder参数.png"><img src="/images/imageWebRTC/MediaRecorderAPI-01.png"><img src="/images/imageWebRTC/MediaRecorderAPI-02.png"><img src="/images/imageWebRTC/MediaRecorder事件.png"><img src="/images/imageWebRTC/JavaScript几种存储数据的方式.png"><h3 id="7-2-WebRTC-捕获桌面"><a href="#7-2-WebRTC-捕获桌面" class="headerlink" title="7.2 WebRTC 捕获桌面"></a>7.2 WebRTC 捕获桌面</h3><img src="/images/imageWebRTC/getDisplayMedia.png"><p>捕获桌面需要设置Chrome，具体 操作：<span class="exturl" data-url="Y2hyb21lOi8vZmxhZ3MvI2VuYWJsZS1leHBlcmltZW50YWwtd2ViLXBsYXRmb3JtLWZlYXR1cmVz" title="chrome://flags/#enable-experimental-web-platform-features">chrome://flags/#enable-experimental-web-platform-features<i class="fa fa-external-link"></i></span></p><ul><li>Experimental Web Platform features 设置为 enable</li></ul><h2 id="8-WebRTC信令服务器实现"><a href="#8-WebRTC信令服务器实现" class="headerlink" title="8. WebRTC信令服务器实现"></a>8. WebRTC信令服务器实现</h2><p>如果没有信令服务器WebRTC之间是不能通信的。</p><p>两个client之间通信必须有两个信息通过信令服务器的：</p><ul><li>媒体信息， SDP</li><li>网络信息</li><li>具体的业务</li></ul><img src="/images/imageWebRTC/信令服务器的作用.png"><img src="/images/imageWebRTC/为什么要使用socketio.png"><img src="/images/imageWebRTC/socketio工作原理.png"><p>Socket.IO 发送消息：</p><ul><li><p>给本次连接发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.emit()</span><br></pre></td></tr></table></figure></li><li><p>给某个房间内所有人发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.in(room).emit()</span><br></pre></td></tr></table></figure></li><li><p>除本链接外，给某个房间内所有人发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.to(room).emit()</span><br></pre></td></tr></table></figure></li><li><p>除本链接外，给所有人发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.broadcast.emit()</span><br></pre></td></tr></table></figure></li></ul><p>Socket.IO 客户端处理消息：</p><ul><li><p>发送 action 命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>);</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送了一个 action 命令，还有 data 数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>, data);</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送了 action 命令，还有两个数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>, arg1, arg2);</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送了一个 action 命令，在 emit 方法中包含回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>, data, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)</span>&#123;...&#125;;</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, fn</span>)</span>&#123;fn(<span class="string">'a'</span>, <span class="string">'b'</span>);&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-1-实战-通过-socket-io-实现信令服务器"><a href="#8-1-实战-通过-socket-io-实现信令服务器" class="headerlink" title="8.1 [实战] 通过 socket.io 实现信令服务器"></a>8.1 [实战] 通过 socket.io 实现信令服务器</h3><p>改造服务端的基本流程：</p><ul><li>安装 socket.io</li><li>引入 socket.io</li><li>处理 connection 消息</li></ul><h2 id="9-WebRTC网络基础补充：P2P-STUN-TRUN-ICE知识"><a href="#9-WebRTC网络基础补充：P2P-STUN-TRUN-ICE知识" class="headerlink" title="9. WebRTC网络基础补充：P2P/STUN/TRUN/ICE知识"></a>9. WebRTC网络基础补充：P2P/STUN/TRUN/ICE知识</h2><h3 id="9-1-WebRTC-网络传输基本知识"><a href="#9-1-WebRTC-网络传输基本知识" class="headerlink" title="9.1 WebRTC 网络传输基本知识"></a>9.1 WebRTC 网络传输基本知识</h3><p>WebRTC 传输基本知识：</p><ul><li>NAT（Network Address Translator）</li><li>STUN（Simple Traversal of UDP Through NAT）</li><li>TURN（Travelsal Using Relays around NAT）</li><li>ICE（Interactive Connectivity Establishment）</li></ul><img src="/images/imageWebRTC/NAT.png"><p>NAT 产生的原因：</p><ul><li>由于IPv4的地址不够</li><li>处于网络安全的原因</li></ul><p>NAT 的种类：</p><ul><li>完全锥型 NAT（Full Cone NAT）</li><li>地址限制锥型 NAT（Address Restricted Cone NAT）</li><li>端口限制锥型 NAT（Port Restricted Cone NAT）</li><li>对称型 NAT（Symmetric NAT）</li></ul><h3 id="9-2-NAT-打洞原理"><a href="#9-2-NAT-打洞原理" class="headerlink" title="9.2 NAT 打洞原理"></a>9.2 NAT 打洞原理</h3><img src="/images/imageWebRTC/完全锥型NAT.png"><img src="/images/imageWebRTC/地址限制锥型NAT.png"><img src="/images/imageWebRTC/端口限制锥型NAT.png"><img src="/images/imageWebRTC/对称型NAT.png"><p>NAT 穿越原理：</p><ul><li>C1，C2 向 STUN 发消息</li><li>交换公网 IP 及 端口</li><li>C1 -&gt; C2，C2 -&gt; C1，甚至是端口猜测</li></ul><img src="/images/imageWebRTC/NAT穿越组合.png"><h3 id="9-3-NAT-类型检测"><a href="#9-3-NAT-类型检测" class="headerlink" title="9.3 NAT 类型检测"></a>9.3 NAT 类型检测</h3><img src="/images/imageWebRTC/NAT类型判断.png"><p>公网 IP：</p><img src="/images/imageWebRTC/NAT类型检测-01.png"><p>如果 Client 收到的 IP 和第一次发出去的 IP 是不一样的，则是对称型 NAT，如果是一样的需要进一步判断：</p><img src="/images/imageWebRTC/NAT类型检测-02.png"><p>Client 通过 Port2 发送消息到 STUN Port1，STUN Server 通过 Port2 给 Client 回消息，如果 Client 能收到消息，则说明是 IP 限制型的；如果不能收到，则说明是端口限制型的：</p><img src="/images/imageWebRTC/NAT类型检测-03.png"><h3 id="9-4-【协议规范】STUN-协议一"><a href="#9-4-【协议规范】STUN-协议一" class="headerlink" title="9.4 【协议规范】STUN 协议一"></a>9.4 【协议规范】STUN 协议一</h3><p>STUN 介绍：</p><ul><li>STUN 存在的目的就是进行 NAT 穿越</li><li>STUN 是典型的客户端 / 服务器模式。客户端发送请求，服务端进行响应</li></ul><p>RFC STUN 规范：</p><ul><li><p><strong>RFC3489/STUN</strong></p><p>SImple Traversal of UDP Trough NAT</p></li><li><p><strong>RFC5389/STUN</strong> — 包含UDP和TCP</p><p>Session Traversal Utilities for NAT</p></li></ul><p>STUN 协议：</p><ul><li>包括 20 字节的 STUN header</li><li>Body 中可以有 0 个或多个 Attribute</li></ul><p>STUN header（RFC3489）：</p><ul><li>其中 2 个字节（16bit）类型</li><li>2 个字节（16bit）消息长度，不包括消息头</li><li>16 个字节（128bit）事物ID，请求与响应事物 ID 相同</li></ul><p>STUN header（RFC5389）格式：</p><img src="/images/imageWebRTC/STUNHeader格式.png"><img src="/images/imageWebRTC/STUNMessageType.png"><p>M 代表请求值，C 代表分类：</p><img src="/images/imageWebRTC/STUNMessageType-01.png"><img src="/images/imageWebRTC/C0C1.png"><p>RFC5389 把私密类型去掉了：</p><img src="/images/imageWebRTC/STUN消息类型.png"><h3 id="9-5-【协议规范】STUN-协议二"><a href="#9-5-【协议规范】STUN-协议二" class="headerlink" title="9.5 【协议规范】STUN 协议二"></a>9.5 【协议规范】STUN 协议二</h3><p>Inter 机子都是小端模式：</p><img src="/images/imageWebRTC/大小端模式.png"><img src="/images/imageWebRTC/STUNMessageType-02.png"><img src="/images/imageWebRTC/TransactionID.png"><img src="/images/imageWebRTC/STUNMessageBody.png"><img src="/images/imageWebRTC/TLV.png"><img src="/images/imageWebRTC/RFC3489定义的属性.png"><img src="/images/imageWebRTC/Attribute的使用.png"><h3 id="9-6-【协议规范】TURN-协议"><a href="#9-6-【协议规范】TURN-协议" class="headerlink" title="9.6 【协议规范】TURN 协议"></a>9.6 【协议规范】TURN 协议</h3><p>TURN 介绍：</p><ul><li>其目的是解决对称 NAT 无法穿越的问题</li><li>其建立在 STUN 之上，消息格式使用 STUN 格式消息</li><li>TURN Client 要求服务端分配一个公共 IP 和 Port 用于接受 或 发送数据</li></ul><img src="/images/imageWebRTC/TURN例子.png"><img src="/images/imageWebRTC/TURN使用的传输协议.png"><img src="/images/imageWebRTC/TURNAllocate.png"><p>TURN 发送机制：</p><ul><li>Send 和 Data</li><li>Channel</li></ul><img src="/images/imageWebRTC/TURNSendAndData.png"><img src="/images/imageWebRTC/TURNChannel.png"><img src="/images/imageWebRTC/TURN的使用.png"><h3 id="9-7-【协议规范】ICE-框架"><a href="#9-7-【协议规范】ICE-框架" class="headerlink" title="9.7 【协议规范】ICE 框架"></a>9.7 【协议规范】ICE 框架</h3><img src="/images/imageWebRTC/ICE.png"><img src="/images/imageWebRTC/ICECandidate.png"><p>Candidate 类型：</p><ul><li>主机候选者</li><li>反射侯选者</li><li>中继候选者</li></ul><p>ICE 具体做些什么：</p><ul><li>收集 Candidate</li><li>对 Candidate Pair 排序</li><li>连通性检查</li></ul><img src="/images/imageWebRTC/Candidate关系图.png"><p>收集 Candidate：</p><ul><li>Host Candidate：本机所有 IP 和指定端口</li><li>Reflexive Candidate：STUN/TURN</li><li>Relay Candidate：TURN</li></ul><p>什么是 SDP：</p><ul><li><strong>SDP（Session Description Protocol）</strong> 它只是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息。</li></ul><img src="/images/imageWebRTC/SDP例子.png"><p>形成 Candidate Pair：</p><ul><li>一方收集到所有候选者后，通过信令传给对方</li><li>同样，另一方收到候选者后，也做收集工作</li><li>当双方拿到全部列表后，将侯选者形成匹配对儿</li></ul><p>连通性检查：</p><ul><li>对侯选者进行优先级排序</li><li>对每个侯选对进行发送检查</li><li>对每个侯选对进行接收检查</li></ul><img src="/images/imageWebRTC/连通性过程.png"><h3 id="9-8-网络协议分析方法-tcpdump-与-wireshark讲解"><a href="#9-8-网络协议分析方法-tcpdump-与-wireshark讲解" class="headerlink" title="9.8 网络协议分析方法 tcpdump 与 wireshark讲解"></a>9.8 网络协议分析方法 tcpdump 与 wireshark讲解</h3><p>常用工具：</p><ul><li>Linux 服务端用 tcpdump</li><li>其它端 WireShark</li></ul><img src="/images/imageWebRTC/tcpdump.png"><h3 id="9-9-网络协议分析方法-tcpdump-与-wireshark-实战"><a href="#9-9-网络协议分析方法-tcpdump-与-wireshark-实战" class="headerlink" title="9.9 网络协议分析方法 tcpdump 与 wireshark 实战"></a>9.9 网络协议分析方法 tcpdump 与 wireshark 实战</h3><p>vim 打开二进制数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：%！xxd</span><br></pre></td></tr></table></figure><p>WireShark 中的逻辑运算：</p><ul><li>与：and 或 &amp;&amp;</li><li>或：or 或 ||</li><li>非：not 或 ！</li></ul><p>WireShark 中判断语句：</p><ul><li>等于：eq 或 ==</li><li>小于：lt 或 &lt;</li><li>大于：gt 或 &gt;</li><li>小于等于：le 或 &lt;=</li><li>大于等于：ge 或 &gt;=</li><li>不等于：ne 或 !=</li></ul><p>WireShark 按协议过滤：</p><ul><li>stun</li><li>tcp</li><li>udp</li></ul><p>模拟STUN数据可以使用这个网站中的工具：<span class="exturl" data-url="aHR0cHM6Ly93ZWJydGMuZ2l0aHViLmlvL3NhbXBsZXM=" title="https://webrtc.github.io/samples">https://webrtc.github.io/samples<i class="fa fa-external-link"></i></span></p><p>Wireshark 按 IP 过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip.dst == 192.168.1.2</span><br><span class="line">ip.src == 192.168.1.2</span><br><span class="line">ip.addr == 192.168.1.2</span><br></pre></td></tr></table></figure><p>WireShark 按 port 过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == 8080</span><br><span class="line">udp.port == 3478</span><br><span class="line">udp.dstport == 3478</span><br><span class="line">udp.srcport == 3478</span><br></pre></td></tr></table></figure><p>WireShark 过滤长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">udp.length &lt; 30</span><br><span class="line">tcp.length &lt; 30</span><br><span class="line">http.content_length &lt; 30</span><br></pre></td></tr></table></figure><p>WireShark 过滤内容：</p><p>TODO</p><h2 id="10-端对端1V1传输基本流程"><a href="#10-端对端1V1传输基本流程" class="headerlink" title="10. 端对端1V1传输基本流程"></a>10. 端对端1V1传输基本流程</h2><h3 id="10-1-媒体能力协商过程"><a href="#10-1-媒体能力协商过程" class="headerlink" title="10.1 媒体能力协商过程"></a>10.1 媒体能力协商过程</h3><p>WebRTC 端对端连接：</p><p><strong>RTCPeerConnection</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc = <span class="keyword">new</span> RTCPeerConnection([configuration]);</span><br></pre></td></tr></table></figure></li></ul><p><strong>RTCPeerConnection 方法分类</strong>：</p><ul><li>媒体协商</li><li>Stream/Track</li><li>传输相关方法</li><li>统计相关方法</li></ul><img src="/images/imageWebRTC/媒体协商过程.png"><img src="/images/imageWebRTC/协商状态变化.png"><p><strong>媒体协商方法</strong>：</p><ul><li>createOffer</li><li>createAnswer</li><li>setLocakDescription</li><li>setRemoteDescription</li></ul><p><strong>createOffer</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPeerConnection.createOffer([options]);</span><br></pre></td></tr></table></figure></li></ul><p><strong>createAnswer</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPeerConnection.createAnswer([options]);</span><br></pre></td></tr></table></figure></li></ul><p><strong>setLocakDescription</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPc.setLocalDescription(sessionDescription);</span><br></pre></td></tr></table></figure></li></ul><p><strong>setRemoteDescription</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPc.setRemoteDescription(sessionDescription);</span><br></pre></td></tr></table></figure></li></ul><p><strong>Track 方法</strong>：</p><ul><li>addTrack</li><li>removeTrack</li></ul><p><strong>addTrack</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtpSender = myPc.addTrack(track, stream...);</span><br></pre></td></tr></table></figure></li><li><p>Parameters</p><img src="/images/imageWebRTC/addTrackParameters.png"></li></ul><p><strong>removeTrack</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPc.remoteTrack(rtpSender);</span><br></pre></td></tr></table></figure></li></ul><p><strong>重要事件</strong>：</p><ul><li>onnegotiationneeded  - 协商的时候触发这个事件</li><li>onicecandidate - 当收到 ICE 候选者的时候触发这个事件</li></ul><h3 id="10-2-1-1-连接的基本流程"><a href="#10-2-1-1-连接的基本流程" class="headerlink" title="10.2 1:1 连接的基本流程"></a>10.2 1:1 连接的基本流程</h3><img src="/images/imageWebRTC/端对端连接的基本流程.png"><p><strong>A 与 B 通信，大的方向分为三部分</strong>：</p><ul><li>媒体协商部分</li><li>ICE 候选者的交换、连接、检测部分</li><li>媒体数据流的通信部分</li></ul><h3 id="10-3-【实战】WebRTC-视频传输"><a href="#10-3-【实战】WebRTC-视频传输" class="headerlink" title="10.3 【实战】WebRTC 视频传输"></a>10.3 【实战】WebRTC 视频传输</h3><p>TODO</p><h3 id="10-4-【实战】显示通讯双方的-SDP-内容"><a href="#10-4-【实战】显示通讯双方的-SDP-内容" class="headerlink" title="10.4 【实战】显示通讯双方的 SDP 内容"></a>10.4 【实战】显示通讯双方的 SDP 内容</h3><p>TODO</p><h2 id="11-WebRTC核心之SDP详解"><a href="#11-WebRTC核心之SDP详解" class="headerlink" title="11. WebRTC核心之SDP详解"></a>11. WebRTC核心之SDP详解</h2><h3 id="11-1-【协议规范】SDP-规范"><a href="#11-1-【协议规范】SDP-规范" class="headerlink" title="11.1 【协议规范】SDP 规范"></a>11.1 【协议规范】SDP 规范</h3><p><strong>SDP 规范</strong>：</p><ul><li>会话层</li><li>媒体层</li></ul><p>可以把会话层看做树根，媒体层看成树干。</p><p><strong>会话层</strong>：</p><ul><li>会话的名称与目的</li><li>会话的存活时间</li><li>会话中包含多个媒体信息</li></ul><p><strong>SDP 媒体信息</strong>：</p><ul><li>媒体格式</li><li>传输协议</li><li>传输 IP 和 端口</li><li>媒体负载类型</li></ul><p><strong>SDP 格式</strong>：</p><ul><li>由多个 <code>&lt;type&gt;=&lt;value&gt;</code> 组成</li><li>一个会话级描述</li><li>多个媒体级描述</li></ul><p><strong>SDP 结构</strong>：</p><ul><li>Session Description</li><li>Time Description</li><li>Media Description</li></ul><img src="/images/imageWebRTC/SessionDescription.png"><img src="/images/imageWebRTC/TimeDescription.png"><img src="/images/imageWebRTC/MediaDescription.png"><img src="/images/imageWebRTC/字段含义-01.png"><img src="/images/imageWebRTC/字段含义-02.png"><img src="/images/imageWebRTC/字段含义-03.png"><img src="/images/imageWebRTC/字段含义-04.png"><img src="/images/imageWebRTC/字段含义-05.png"><img src="/images/imageWebRTC/字段含义-06.png"><img src="/images/imageWebRTC/字段含义-07.png"><h3 id="11-2-【协议规范】WebRTC-中的-SDP"><a href="#11-2-【协议规范】WebRTC-中的-SDP" class="headerlink" title="11.2 【协议规范】WebRTC 中的 SDP"></a>11.2 【协议规范】WebRTC 中的 SDP</h3><img src="/images/imageWebRTC/WebRTC中的SDP.png"><h3 id="11-3-【详解】WebRTC-中-Offer-Answer-SDP"><a href="#11-3-【详解】WebRTC-中-Offer-Answer-SDP" class="headerlink" title="11.3 【详解】WebRTC 中 Offer_Answer SDP"></a>11.3 【详解】WebRTC 中 Offer_Answer SDP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-实现1V1音视频实时互动直播系统"><a href="#12-实现1V1音视频实时互动直播系统" class="headerlink" title="12. 实现1V1音视频实时互动直播系统"></a>12. 实现1V1音视频实时互动直播系统</h2><h3 id="12-1-STUN-TURN-服务器搭建"><a href="#12-1-STUN-TURN-服务器搭建" class="headerlink" title="12.1 STUN/TURN 服务器搭建"></a>12.1 STUN/TURN 服务器搭建</h3><p>coTurn Download Address：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvdHVybi9jb3R1cm4=" title="https://github.com/coturn/coturn">https://github.com/coturn/coturn<i class="fa fa-external-link"></i></span></p><p>ICE 测试地址：<span class="exturl" data-url="aHR0cHM6Ly93ZWJydGMuZ2l0aHViLmlvL3NhbXBsZXM=" title="https://webrtc.github.io/samples">https://webrtc.github.io/samples<i class="fa fa-external-link"></i></span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 turn server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> turnserver -c /usr/<span class="built_in">local</span>/coturn/etc/turnserver.conf</span></span><br></pre></td></tr></table></figure><img src="/images/imageWebRTC/STUNTURN服务器选型.png"><img src="/images/imageWebRTC/coTurn服务器搭建与部署.png"><img src="/images/imageWebRTC/coTurn服务器配置.png"><img src="/images/imageWebRTC/测试turn服务.png"><h3 id="12-2-【参数介绍】再论-RTCPeerConnection"><a href="#12-2-【参数介绍】再论-RTCPeerConnection" class="headerlink" title="12.2 【参数介绍】再论 RTCPeerConnection"></a>12.2 【参数介绍】再论 RTCPeerConnection</h3><img src="/images/imageWebRTC/RTCPeerConnection-01.png"><img src="/images/imageWebRTC/Configurations-01.png"><img src="/images/imageWebRTC/Configurations-02.png"><img src="/images/imageWebRTC/Configurations-03.png"><img src="/images/imageWebRTC/Configurations-04.png"><img src="/images/imageWebRTC/addIceCandidate.png"><h3 id="12-3-直播系统中的信令及其逻辑关系"><a href="#12-3-直播系统中的信令及其逻辑关系" class="headerlink" title="12.3 直播系统中的信令及其逻辑关系"></a>12.3 直播系统中的信令及其逻辑关系</h3><p>【实战】真正的音视频传输</p><p><strong>客户端信令消息</strong>：</p><ul><li>join 加入房间</li><li>leave 离开房间</li><li>message 端到端消息</li></ul><p><strong>端到端信令消息</strong>：</p><ul><li>Offer 消息</li><li>Answer 消息</li><li>Candidate 消息</li></ul><p><strong>服务端信令消息</strong>：</p><ul><li>joined 已加入房间</li><li>otherjoin 其它用户加入房间</li><li>full 房间人数已满</li><li>leaved 已离开房间</li><li>bye 对方离开房间</li></ul><img src="/images/imageWebRTC/直播系统消息处理流程.png"><h3 id="12-4-实现-1：1-音视频实时互动信令服务器"><a href="#12-4-实现-1：1-音视频实时互动信令服务器" class="headerlink" title="12.4 实现 1：1 音视频实时互动信令服务器"></a>12.4 实现 1：1 音视频实时互动信令服务器</h3><p>信令服务器改造</p><p>TODO</p><h3 id="12-5-再论CreateOffer"><a href="#12-5-再论CreateOffer" class="headerlink" title="12.5 再论CreateOffer"></a>12.5 再论CreateOffer</h3><img src="/images/imageWebRTC/createOffer.png"><p><strong>CreateOffer 实战</strong>：</p><ul><li>接收远端音频</li><li>接收远端视频</li><li>静音检测</li><li>ICE restart</li></ul><h3 id="12-6-WebRTC-客户端状态机及处理逻辑"><a href="#12-6-WebRTC-客户端状态机及处理逻辑" class="headerlink" title="12.6 WebRTC 客户端状态机及处理逻辑"></a>12.6 WebRTC 客户端状态机及处理逻辑</h3><p>直播客户端的实现：</p><img src="/images/imageWebRTC/客户端状态机.png"><img src="/images/imageWebRTC/客户端流程图.png"><img src="/images/imageWebRTC/客户端流程图-01.png"><img src="/images/imageWebRTC/端对端连接的基本流程.png"><h3 id="12-7-WebRTC-客户端的实现"><a href="#12-7-WebRTC-客户端的实现" class="headerlink" title="12.7 WebRTC 客户端的实现"></a>12.7 WebRTC 客户端的实现</h3><img src="/images/imageWebRTC/注意要点.png"><h3 id="12-8-共享远程桌面"><a href="#12-8-共享远程桌面" class="headerlink" title="12.8 共享远程桌面"></a>12.8 共享远程桌面</h3><img src="/images/imageWebRTC/getDisplayMedia-01.png"><img src="/images/imageWebRTC/需要注意的点.png"><h2 id="13-WebRTC核心之RTP媒体控制与数据统计"><a href="#13-WebRTC核心之RTP媒体控制与数据统计" class="headerlink" title="13. WebRTC核心之RTP媒体控制与数据统计"></a>13. WebRTC核心之RTP媒体控制与数据统计</h2><h3 id="13-1-RTPPReceiver-发送器"><a href="#13-1-RTPPReceiver-发送器" class="headerlink" title="13.1 RTPPReceiver 发送器"></a>13.1 RTPPReceiver 发送器</h3><p>RTP Media</p><img src="/images/imageWebRTC/Receiver和Sender.png"><img src="/images/imageWebRTC/RTCRtpSender属性.png"><img src="/images/imageWebRTC/RTCRtpReceiver.png"><h3 id="13-2-RTPSender-发送器"><a href="#13-2-RTPSender-发送器" class="headerlink" title="13.2 RTPSender 发送器"></a>13.2 RTPSender 发送器</h3><img src="/images/imageWebRTC/RTCRtpSender.png"><img src="/images/imageWebRTC/RTPMedia.png"><img src="/images/imageWebRTC/RTCRtpTransceiver.png"><h3 id="13-3-传输速率的控制"><a href="#13-3-传输速率的控制" class="headerlink" title="13.3 传输速率的控制"></a>13.3 传输速率的控制</h3><img src="/images/imageWebRTC/RTPMedia-01.png"><img src="/images/imageWebRTC/chromeWebRTC-internals.png"><p>chrome WebRTC 状态查询地址：<span class="exturl" data-url="Y2hyb21lOi8vd2VicnRjLWludGVybmFscw==" title="chrome://webrtc-internals">chrome://webrtc-internals<i class="fa fa-external-link"></i></span></p><h3 id="13-4-【实战】WebRTC统计信息"><a href="#13-4-【实战】WebRTC统计信息" class="headerlink" title="13.4 【实战】WebRTC统计信息"></a>13.4 【实战】WebRTC统计信息</h3><p>TODO</p><h2 id="14-WebRTC非音视频数据传输"><a href="#14-WebRTC非音视频数据传输" class="headerlink" title="14. WebRTC非音视频数据传输"></a>14. WebRTC非音视频数据传输</h2><h3 id="14-1-传输非音视频数据基础知识"><a href="#14-1-传输非音视频数据基础知识" class="headerlink" title="14.1 传输非音视频数据基础知识"></a>14.1 传输非音视频数据基础知识</h3><img src="/images/imageWebRTC/createDataChannel.png"><img src="/images/imageWebRTC/option-01.png"><img src="/images/imageWebRTC/option-02.png"><img src="/images/imageWebRTC/使用Options.png"><img src="/images/imageWebRTC/DataChannel事件.png"><img src="/images/imageWebRTC/创建RTCDataChannel.png"><img src="/images/imageWebRTC/非音视频数据传输方式.png"><ul><li>Reliability：可靠性</li><li>Delivery：可达性</li><li>Transmission：传输方式</li><li>Flow control：流控</li><li>Congestion control：拥塞控制</li></ul><h3 id="14-2-端到端文本聊天"><a href="#14-2-端到端文本聊天" class="headerlink" title="14.2 端到端文本聊天"></a>14.2 端到端文本聊天</h3><p>TODO</p><h3 id="14-3-文件实时传输"><a href="#14-3-文件实时传输" class="headerlink" title="14.3 文件实时传输"></a>14.3 文件实时传输</h3><img src="/images/imageWebRTC/知识点.png"><h2 id="15-WebRTC实时数据传输网络协议详解"><a href="#15-WebRTC实时数据传输网络协议详解" class="headerlink" title="15. WebRTC实时数据传输网络协议详解"></a>15. WebRTC实时数据传输网络协议详解</h2><h3 id="15-1-【协议规范】RTP-SRTP协议头详解"><a href="#15-1-【协议规范】RTP-SRTP协议头详解" class="headerlink" title="15.1 【协议规范】RTP-SRTP协议头详解"></a>15.1 【协议规范】RTP-SRTP协议头详解</h3><img src="/images/imageWebRTC/协议栈.png"><img src="/images/imageWebRTC/传输协议.png"><img src="/images/imageWebRTC/RTP协议.png"><img src="/images/imageWebRTC/RTP字段说明.png"><h3 id="15-2-【协议规范】RTCP-中的-SR-与-RR-报文"><a href="#15-2-【协议规范】RTCP-中的-SR-与-RR-报文" class="headerlink" title="15.2 【协议规范】RTCP 中的 SR 与 RR 报文"></a>15.2 【协议规范】RTCP 中的 SR 与 RR 报文</h3><img src="/images/imageWebRTC/RTCP包.png"><img src="/images/imageWebRTC/RTCPPayloadType.png"><img src="/images/imageWebRTC/RTCPHeader.png"><img src="/images/imageWebRTC/RTCPHeader说明.png"><img src="/images/imageWebRTC/RTCPSenderReport.png"><img src="/images/imageWebRTC/SenderInfomationBlock.png"><img src="/images/imageWebRTC/SenderInfo说明.png"><img src="/images/imageWebRTC/ReportBlock.png"><img src="/images/imageWebRTC/ReceiveReportBlock.png"><img src="/images/imageWebRTC/RTCPReceiverReport.png"><img src="/images/imageWebRTC/RTCPSR-RR发送时机.png"><img src="/images/imageWebRTC/RTCPSDES.png"><img src="/images/imageWebRTC/SDESitem.png"><img src="/images/imageWebRTC/SDES说明.png"><img src="/images/imageWebRTC/RTCPBYE.png"><img src="/images/imageWebRTC/RTCPAPP.png"><img src="/images/imageWebRTC/RTCPAPP字段说明.png"><h3 id="15-3-【协议规范】DTSL"><a href="#15-3-【协议规范】DTSL" class="headerlink" title="15.3 【协议规范】DTSL"></a>15.3 【协议规范】DTSL</h3><img src="/images/imageWebRTC/DTLS.png"><img src="/images/imageWebRTC/SRTP.png"><h3 id="15-4-wireshark-分析-rtp-rtcp-包"><a href="#15-4-wireshark-分析-rtp-rtcp-包" class="headerlink" title="15.4 wireshark 分析 rtp-rtcp 包"></a>15.4 wireshark 分析 rtp-rtcp 包</h3><p>TODO</p><h2 id="16-Android端与浏览器互通"><a href="#16-Android端与浏览器互通" class="headerlink" title="16. Android端与浏览器互通"></a>16. Android端与浏览器互通</h2><h3 id="16-1-Android-与浏览器互通"><a href="#16-1-Android-与浏览器互通" class="headerlink" title="16.1 Android 与浏览器互通"></a>16.1 Android 与浏览器互通</h3><img src="/images/imageWebRTC/主要内容.png"><img src="/images/imageWebRTC/需要权限.png"><img src="/images/imageWebRTC/Android权限管理.png"><img src="/images/imageWebRTC/引入库.png"><img src="/images/imageWebRTC/信令处理.png"><img src="/images/imageWebRTC/AndroidSocketio.png"><img src="/images/imageWebRTC/socketio接收消息.png"><h3 id="16-2-WebRTCNative-开发逻辑"><a href="#16-2-WebRTCNative-开发逻辑" class="headerlink" title="16.2 WebRTCNative 开发逻辑"></a>16.2 WebRTCNative 开发逻辑</h3><img src="/images/imageWebRTC/结构图.png"><img src="/images/imageWebRTC/呼叫端时序图.png"><img src="/images/imageWebRTC/被叫端时序图.png"><img src="/images/imageWebRTC/关闭时序图.png"><img src="/images/imageWebRTC/webrtc处理流程.png"><img src="/images/imageWebRTC/重要类-01.png"><img src="/images/imageWebRTC/重要类-02.png"><img src="/images/imageWebRTC/两个观察者.png"><h3 id="16-3-实战-权限申请-库的引入与界面"><a href="#16-3-实战-权限申请-库的引入与界面" class="headerlink" title="16.3 实战-权限申请-库的引入与界面"></a>16.3 实战-权限申请-库的引入与界面</h3><img src="/images/imageWebRTC/权限库界面.png"><h3 id="16-4-实战-通过-socket-io-实现信令收发"><a href="#16-4-实战-通过-socket-io-实现信令收发" class="headerlink" title="16.4 实战-通过 socket.io 实现信令收发"></a>16.4 实战-通过 socket.io 实现信令收发</h3><img src="/images/imageWebRTC/收发信令.png"><h3 id="16-5-实战-Android-与浏览器互通"><a href="#16-5-实战-Android-与浏览器互通" class="headerlink" title="16.5 实战-Android 与浏览器互通"></a>16.5 实战-Android 与浏览器互通</h3><p>创建 PeerConnection：</p><ul><li>音视频数据采集</li><li>创建 PeerConnection</li></ul><p>媒体能力协商：</p><ul><li>协商媒体能力</li><li>Candidate 连通</li><li>视频渲染</li></ul><h2 id="17-iOS端与浏览器互通"><a href="#17-iOS端与浏览器互通" class="headerlink" title="17. iOS端与浏览器互通"></a>17. iOS端与浏览器互通</h2><h3 id="17-1-IOS权限获取"><a href="#17-1-IOS权限获取" class="headerlink" title="17.1 IOS权限获取"></a>17.1 IOS权限获取</h3><img src="/images/imageWebRTC/主要内容-01.png"><img src="/images/imageWebRTC/主要内容-02.png"><h3 id="17-2-IOS引入WebRTC库"><a href="#17-2-IOS引入WebRTC库" class="headerlink" title="17.2 IOS引入WebRTC库"></a>17.2 IOS引入WebRTC库</h3><img src="/images/imageWebRTC/引入WebRTC库的方式.png"><img src="/images/imageWebRTC/引入WebRTC库.png"><img src="/images/imageWebRTC/Podfile.png"><h3 id="17-3-IOS端SocketIO的使用"><a href="#17-3-IOS端SocketIO的使用" class="headerlink" title="17.3 IOS端SocketIO的使用"></a>17.3 IOS端SocketIO的使用</h3><img src="/images/imageWebRTC/socketio的使用.png"><img src="/images/imageWebRTC/连接服务器.png"><img src="/images/imageWebRTC/发送消息.png"><img src="/images/imageWebRTC/注册侦听消息.png"><h3 id="17-4-IOS界面布局"><a href="#17-4-IOS界面布局" class="headerlink" title="17.4 IOS界面布局"></a>17.4 IOS界面布局</h3><p>TODO</p><h3 id="17-5-IOS本地视频采集与展示"><a href="#17-5-IOS本地视频采集与展示" class="headerlink" title="17.5 IOS本地视频采集与展示"></a>17.5 IOS本地视频采集与展示</h3><p>TODO</p><h3 id="17-6-IOS端RTCPeerConnection"><a href="#17-6-IOS端RTCPeerConnection" class="headerlink" title="17.6 IOS端RTCPeerConnection"></a>17.6 IOS端RTCPeerConnection</h3><p>TODO</p><h3 id="17-7-IOS媒体协商"><a href="#17-7-IOS媒体协商" class="headerlink" title="17.7 IOS媒体协商"></a>17.7 IOS媒体协商</h3><img src="/images/imageWebRTC/媒体协商.png"><img src="/images/imageWebRTC/信令时序图.png"><h3 id="17-8-IOS远端视频渲染"><a href="#17-8-IOS远端视频渲染" class="headerlink" title="17.8 IOS远端视频渲染"></a>17.8 IOS远端视频渲染</h3><img src="/images/imageWebRTC/RTCPeerConnection委托.png"><h2 id="18-课程总结"><a href="#18-课程总结" class="headerlink" title="18. 课程总结"></a>18. 课程总结</h2><img src="/images/imageWebRTC/小结.png"><img src="/images/imageWebRTC/信令服务器.png"><img src="/images/imageWebRTC/JS客户端实现.png"><img src="/images/imageWebRTC/JS客户端实现-01.png"><img src="/images/imageWebRTC/进阶.png"><img src="/images/imageWebRTC/进阶-01.png"><img src="/images/imageWebRTC/行业痛点.png"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzUxMTIxOWU1MWQ0NTUyMmMzMDY2Yzk=" title="https://juejin.im/post/5c511219e51d45522c3066c9">JavaScript 是如何工作的:WebRTC 和对等网络的机制！<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTQwMzU5Nw==" title="https://segmentfault.com/a/1190000011403597">深入理解WebRTC<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2htYWkvYXJ0aWNsZS9kZXRhaWxzLzY5NjgxNTk1" title="https://blog.csdn.net/fishmai/article/details/69681595">WebRTC架构简介<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFycmV0bGVlLmNvbS9ibG9nLzIwMTUvMTAvMDUvaG93LXRvLWJ1aWxkLWEtaHR0cHMtc2VydmVyLw==" title="https://www.barretlee.com/blog/2015/10/05/how-to-build-a-https-server/">HTTPS证书生成原理和部署细节<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85MDkxZWJkNDM5YTA=" title="https://www.jianshu.com/p/9091ebd439a0">SSL证书生成流程<i class="fa fa-external-link"></i></span></p></blockquote><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ncmFkbGUub3JnL2luc3RhbGwv" title="https://gradle.org/install/">Gradle官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3Rvb2xzLmFuZHJvaWQtc3R1ZGlvLm9yZy9pbmRleC5waHAvOS10b29scy8xMDktYW5kcm9pZC10b29scy1kb3dubG9hZA==" title="http://tools.android-studio.org/index.php/9-tools/109-android-tools-download">Gradle 包<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zNmU1NjljMWJiMTI=" title="https://www.jianshu.com/p/36e569c1bb12">Mac下AndroidStudio中手动配置Gradle<i class="fa fa-external-link"></i></span></p></blockquote><p>WebRTC的分层协议图：</p><img src="/images/imageWebRTC/webrtc分层协议图.png"><p>信令，会话和协议：</p><img src="/images/imageWebRTC/信令会话协议.png"><h2 id="问题解决里程"><a href="#问题解决里程" class="headerlink" title="问题解决里程"></a>问题解决里程</h2><p>node 启动 server 报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">events.js:141</span><br><span class="line">      throw er; // Unhandled 'error' event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EACCES 0.0.0.0:443</span><br><span class="line">    at Object.exports._errnoException (util.js:870:11)</span><br><span class="line">    at exports._exceptionWithHostPort (util.js:893:20)</span><br><span class="line">    at Server._listen2 (net.js:1224:19)</span><br><span class="line">    at listen (net.js:1273:10)</span><br><span class="line">    at net.js:1382:9</span><br><span class="line">    at nextTickCallbackWith3Args (node.js:452:9)</span><br><span class="line">    at process._tickCallback (node.js:358:17)</span><br><span class="line">    at Function.Module.runMain (module.js:444:11)</span><br><span class="line">    at startup (node.js:136:18)</span><br><span class="line">    at node.js:966:3</span><br><span class="line"><span class="meta">[Solve]$</span><span class="bash"> sudo <span class="built_in">setcap</span> <span class="string">'cap_net_bind_service=+ep'</span> $(readlink -f $(<span class="built_in">which</span> node))</span></span><br></pre></td></tr></table></figure><p>查询端口是否别占用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -ntpl | grep 443</span></span><br></pre></td></tr></table></figure><h2 id="VIM-快捷键温习"><a href="#VIM-快捷键温习" class="headerlink" title="VIM 快捷键温习"></a>VIM 快捷键温习</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93eG5hY3kuY29tLzIwMTcvMDkvMjIvdmltLXBsdWdpbi10ZXJuLw==" title="https://wxnacy.com/2017/09/22/vim-plugin-tern/">Vim 插件 tern_for_vim Javascript 自动补全<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hcmNoaXZlLzIwMTIvMDYvMTQvdmltX25vdGVzLmh0bWwjaWQxMDc=" title="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107">最全的vim快捷键<i class="fa fa-external-link"></i></span></p></blockquote><p>vim 格式化文本，调整缩进：</p><blockquote><p>= 是格式化文本的快捷方法， 当你发现代码缩进的不整齐的，可以用这个快速对齐它们。</p><p>直接按＝号就可以，不能进入命令模式（以 “:” 冒号开始的命令行）。</p><p>gg=G ：从头格到尾，爽。</p><p>＝＝ 格式化一行</p><p>如要格式化一段代码，可以先选中这些代码，再按＝号。</p><p>调整缩进还有个比较慢的办法，按＞＞，向右缩进一格，＜＜向左缩进一格。</p></blockquote><p>vim常用快捷键总结：</p><ul><li><p>光标移动到行首：0</p></li><li><p>光标移动到行尾：$</p></li><li><p>光标移动到文件开始：GG</p></li><li><p>光标移动到文件末尾：shift +G</p></li><li><p>先前翻页：Ctrl+f</p></li><li><p>向后翻页：Ctrl+b</p></li><li><p>删至行首：d0</p></li><li><p>删至行尾：d$</p></li><li><p>删除当前行及其后面n-1行：ndd</p></li><li><p>删除当前字符：x</p></li><li><p>删除当前字符的前一个字符：X</p></li><li><p>删除当前字符：dl</p></li><li><p>删除到第三个字符的结尾位置：d3w</p></li><li><p>删除到某个单词的末尾：dw</p></li><li><p>删除到某个单词的开始：db</p></li><li><p>删除当前行到文件的末尾：dG</p></li><li><p>删除当前行到文件第一行：dH</p></li><li><p>删除知道屏幕上最后一行：dL</p></li><li><p>替换当前行所有temp为hehe：:s/temp/hehe/g</p></li><li><p>替换每行中第一个#include为hehe：:%s/#include/hehe/</p></li><li><p>替换每行中所有的#include为hehe：:%s/#include/hehe/g</p></li><li><p>替换第n行开始到最后一行中每一行的第一个#include为hehe：:n,$s/#include/hehe/</p></li><li><p>替换第n行开始到最后一行中每一行的所有#include为hehe：:n,$s/#include/hehe/g</p></li><li><p>替换当前行到末尾的所有#include为hehe：:.,$s/#include/hehe/g</p></li><li><p>替换正文中所有出现的#include为hehe：:1,$s/#include/hehe/g</p></li><li><p>回复上一步操作：u</p></li><li><p>全部回复操作：shift + u</p></li><li><p>重做上一步操作：Ctrl + r</p></li><li><p>把下一行合并到当前行尾：J</p></li><li><p>选中当前行及其后面的n-1行：nV</p></li><li><p>复制当前光标到此单词末尾：yw</p></li><li><p>批量添加注释：Ctrl+v可视模式，上、下、左、右移动光标选择若干行开头；Shift+i进入插入模式；输入// 者；按Esc</p></li><li><p>批量去掉注释：Ctrl+v可视模式，上、下、左、右移动关闭选择要删除的注释符，如//或#；按d删除</p></li><li><p>横向打开另一个窗口：:sp 文件名</p></li><li><p>竖向打开另一个窗口：:vsp 文件名</p></li><li><p>关闭当前打开的所有窗口：:qa</p></li><li><p>选择当前字符所在的单词：Ctrl+v可视模式，然后a+w或i+w</p></li><li><p>选择当前字符所在的段落：Ctrl+v可视模视，然后i+p或a+p</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WebRTC&quot;&gt;&lt;a href=&quot;#WebRTC&quot; class=&quot;headerlink&quot; title=&quot;WebRTC&quot;&gt;&lt;/a&gt;WebRTC&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYlJUQ19BUEk=&quot; title=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API&quot;&gt;WebRTC API&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL25vZGVqcy5jbi9hcGkv&quot; title=&quot;http://nodejs.cn/api/&quot;&gt;Node.js v10.15.3 文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI1MjM1MzU5MDQw&quot; title=&quot;https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040&quot;&gt;廖雪峰 - nodejs&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-WebRTC-介绍&quot;&gt;&lt;a href=&quot;#1-WebRTC-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. WebRTC 介绍&quot;&gt;&lt;/a&gt;1. WebRTC 介绍&lt;/h2&gt;
    
    </summary>
    
      <category term="WebRTC" scheme="http://miaopei.github.io/categories/WebRTC/"/>
    
    
      <category term="WebRTC" scheme="http://miaopei.github.io/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg编程基础和一些常见问题的解答</title>
    <link href="http://miaopei.github.io/2019/05/09/FFmpeg/ffmpeg%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94/"/>
    <id>http://miaopei.github.io/2019/05/09/FFmpeg/ffmpeg编程基础和一些常见问题的解答/</id>
    <published>2019-05-09T02:14:50.000Z</published>
    <updated>2019-06-10T07:29:14.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMTcwMDUvYXJ0aWNsZS9kZXRhaWxzLzUxMDgzNzQ1" title="https://blog.csdn.net/u010317005/article/details/51083745">ffmpeg编程基础和一些常见问题的解答<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="FFMpeg-编程的大致框架"><a href="#FFMpeg-编程的大致框架" class="headerlink" title="FFMpeg 编程的大致框架"></a>FFMpeg 编程的大致框架</h2><a id="more"></a><img src="/images/imageFFmpeg/ffmpeg编程大致框架.png"><p><strong>进一步的详解，具体到函数调用级别</strong></p><img src="/images/imageFFmpeg/ffmpeg函数调用级别.png"><p>详细步骤：</p><ul><li><p>注册所有容器格式和 <code>CODEC:av_register_all(）</code></p></li><li><p>打开文件: <code>av_open_input_file()</code></p></li><li><p>从文件中提取流信息 : <code>av_find_stream_info()</code></p></li><li><p>穷举所有的流，查找其中种类为 <code>CODEC_TYPE_VIDEO</code></p></li><li><p>查找对应的解码器 : <code>avcodec_find_decoder()</code></p></li><li><p>打开编解码器 : <code>avcodec_open()</code></p></li><li><p>为解码帧分配内存 : <code>avcodec_alloc_frame()</code></p></li><li><p>不停地从码流中提取出帧数据 : <code>av_read_frame()</code></p></li><li><p>判断帧的类型，对于视频帧调用 : <code>avcodec_decode_video()</code></p></li><li><p>解码完后，释放解码器 : <code>avcodec_close()</code></p></li><li><p>关闭输入文件 : <code>av_close_input_file()</code></p></li></ul><p>首先第一件事情就是<strong>开一个视频文件并从中得到流</strong>。</p><p>我们要做的第一件事情就是<strong>使用</strong> <code>av_register_all()</code> ;来初始化 <code>libavformat/libavcodec</code> :</p><p>这一步注册库中含有的所有可用的文件格式和编码器，这样当打开一个文件时，它们才能够自动选择相应的文件格式和编码器。<code>av_register_all()</code> 只需调用一次，所以，要放在初始化代码中。也可以仅仅注册个人的文件格式和编码。</p><p>下一步，<strong>打开文件</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *pFormatCtx;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>      *filename = <span class="string">"myvideo.mpg"</span>;</span><br><span class="line">av_open_input_file(&amp;pFormatCtx, filename, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>)；   <span class="comment">// 打开视频文件</span></span><br></pre></td></tr></table></figure><p>最后三个参数描述了文件格式，缓冲区大小（<em>size</em>）和格式参数；我们通过简单地指明<em>NULL</em>或<em>0</em>告诉 <code>libavformat</code> 去自动探测文件格式并且使用默认的缓冲区大小。这里的格式参数指的是视频输出参数，比如宽高的坐标。</p><p>下一步，我们需要<strong>取出包含在文件中的流信息</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">av_find_stream_info(pFormatCtx)；  <span class="comment">// 取出流信息</span></span><br><span class="line">dump_format(pFormatCtx, <span class="number">0</span>, filename, <span class="literal">false</span>);  <span class="comment">//我们可以使用这个函数把获取到得参数全部输出。</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)  <span class="comment">//区分视频流和音频流</span></span><br><span class="line"><span class="keyword">if</span>(pFormatCtx-&gt;streams-&gt;codec.codec_type == CODEC_TYPE_VIDEO) <span class="comment">//找到视频流，这里也可以换成音频</span></span><br><span class="line">&#123;</span><br><span class="line">   videoStream = i;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就需要<strong>寻找解码器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVCodec *pCodec;</span><br><span class="line">pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">avcodec_open(pCodecCtx, pCodec)；    <span class="comment">// 打开解码器</span></span><br></pre></td></tr></table></figure><p><strong>给视频帧分配空间以便存储解码后的图片</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVFrame *pFrame;</span><br><span class="line">pFrame = avcodec_alloc_frame();</span><br></pre></td></tr></table></figure><p><strong>////////////////////////////////////////开始解码///////////////////////////////////////////</strong></p><p>第一步当然是<strong>读数据</strong>：</p><p>我们将要做的是通过读取包来读取整个视频流，然后把它解码成帧，最后转换格式并且保存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="number">0</span>) &#123;  <span class="comment">//读数据</span></span><br><span class="line"><span class="keyword">if</span>(packet.stream_index==videoStream)&#123;      <span class="comment">//判断是否视频流</span></span><br><span class="line">avcodec_decode_video(pCodecCtx, pFrame, &amp;frameFinished, packet.data, packet.size);   <span class="comment">//解码</span></span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">if</span>(frameFinished) &#123;</span><br><span class="line">img_convert((AVPicture *)pFrameRGB, PIX_FMT_RGB24,(AVPicture*)pFrame, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-          &gt;height); <span class="comment">//转换   </span></span><br><span class="line">&#125;</span><br><span class="line">SaveFrame(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, i); <span class="comment">//保存数据</span></span><br><span class="line">av_free_packet(&amp;packet);  <span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>av_read_frame()</code> 读取一个包并且把它保存到 <code>AVPacket</code> 结构体中。这些数据可以在后面通过 <code>av_free_packet()</code> 来释放。函数 <code>avcodec_decode_video()</code> 把包转换为帧。然而当解码一个包的时候，我们可能没有得到我们需要的关于帧的信息。因此，当我们得到下一帧的时候， <code>avcodec_decode_video()</code> 为我们设置了帧结束标志 <code>frameFinished</code>。最后，我们使用  <code>img_convert()</code> 函数来把帧从原始格式（<code>pCodecCtx-&gt;pix_fmt</code>）转换成为 <code>RGB</code> 格式。要记住，你可以把一个 <code>AVFrame</code> 结构体的指针转换为 <code>AVPicture</code> 结构体的指针。最后，我们把帧和高度宽度信息传递给我们的 <code>SaveFrame</code> 函数。</p><p>到此解码完毕，显示过程使用 <code>SDL</code> 完成考虑到我们以后会使用 <code>firmware</code> 进行显示操作，<code>SDL</code> 忽略不讲。</p><h2 id="音视频同步"><a href="#音视频同步" class="headerlink" title="音视频同步"></a>音视频同步</h2><p><strong><em>DTS</em>（解码时间戳）和 <em>PTS</em>（显示时间戳）</strong></p><p>当我们调用 <code>av_read_frame()</code> 得到一个包的时候，<strong><em>PTS</em></strong> 和 <strong><em>DTS</em></strong> 的信息也会保存在包中。但是我们真正想要的 <strong><em>PTS</em></strong> 是我们刚刚解码出来的原始帧的 <strong><em>PTS</em></strong>，这样我们才能知道什么时候来显示它。然而，我们从 <code>avcodec_decode_video()</code> 函数中得到的帧只是一个 <code>AVFrame</code>，其中并没有包含有用的 <strong><em>PTS</em></strong> 值（注意：<code>AVFrame</code> 并没有包含时间戳信息，但当我们等到帧的时候并不是我们想要的样子）。</p><p>我们保存一帧的第一个包的 <strong><em>PTS</em></strong>：这将作为整个这一帧的 <strong><em>PTS</em></strong>。我们可以通过函数 <code>avcodec_decode_video()</code> 来计算出哪个包是一帧的第一个包。</p><p>怎样实现呢？任何时候当一个包开始一帧的时候，<code>avcodec_decode_video()</code> 将调用一个函数来为一帧申请一个缓冲。当然，<code>ffmpeg</code> 允许我们重新定义那个分配内存的函数。计算前一帧和现在这一帧的时间戳来预测出下一个时间戳的时间。同时，我们需要同步视频到音频。我们将设置一个音频时间 <code>audioclock</code>；一个内部值记录了我们正在播放的音频的位置。就像从任意的 <em>mp3</em> 播放器中读出来的数字一样。既然我们把视频同步到音频，视频线程使用这个值来算出是否太快还是太慢。</p><p><strong>用 FFMPEG SDK 进行视频转码压缩时解决音视频不同步问题的方法:</strong></p><p>用 <em>FFMPEG SDK</em> 进行视频转码压缩的时候，转码成功后去看视频的内容，发现音视频是不同步的。这个的确是一个恼火的事情。我在用 <em>FFMPEG SDK</em> 做 <em>h264</em> 格式的 <em>FLV</em> 文件编码 <em>Filter</em> 的时候就碰到了这个问题。</p><p>经过研究发现，<em>FFMPEG SDK</em> 写入视频的时候有两个地方用来控制写入的时间戳，一个是 <code>AvPacket</code> 一个是 <code>AvFrame</code> 。在调用 <code>avcodec_encode_video</code> 的时候需要传入 <code>AvFrame</code> 的对象指针，也就是传入一帧未压缩的视频进行压缩处理，<code>AvFrame</code> 包含一个 <strong><em>pts</em></strong> 的参数，这个参数就是当前帧将来在还原播放的时候的时间戳。而 <code>AvPacket</code> 里面也有 <strong><em>pts</em></strong>，还有 <strong><em>dts</em></strong>。说起这个就必须要说明一下 <code>I , P , B</code> 三种视频压缩帧。<code>I</code> 帧就是关键帧，不依赖于其他视频帧，<code>P</code> 帧是向前预测的帧，只依赖于前面的视频帧，而 <code>B</code> 帧是双向预测视频帧，依赖于前后视频帧。由于 <code>B</code> 帧的存在，因为它是双向的，必须知道前面的视频帧和后面的视频帧的详细内容后，才能知道本 <code>B</code> 帧最终该呈现什么图像。而 <strong><em>pts</em></strong> 和 <strong><em>dts</em></strong> 两个参数就是用来控制视频帧的显示和解码的顺序。</p><p><strong><em>pts</em></strong> 就是帧显示的顺序。<strong><em>dts</em></strong> 就是帧被读取进行解码的顺序。如果没有 <code>B</code> 帧存在，<strong><em>dts</em></strong> 和 <strong><em>pts</em></strong> 是相同的。反之，则是不相同的。关于这个的详细介绍可以参考一下 <em>mpeg</em> 的原理。</p><p><strong>AvPacket 包含的 pts 和 dts 两个到底该设置什么值？</strong></p><p><strong><em>pts</em></strong> 和 <strong><em>dts</em></strong> 需要设置的就是视频帧解码和显示的顺序。每增加一帧就加一，并不是播放视频的时间戳。但是实践证明经过 <em>rmvb</em> 解码的视频有时候并不是固定帧率的，而是变帧率的，这样，如果每压缩一帧，<strong><em>pts</em></strong> 和 <strong><em>dts</em></strong> 加一的方案为导致音视频不同步。</p><p><strong>那怎么来解决音视频同步的问题呢？</strong></p><p>请看如下代码段。</p><p><code>lTimeStamp</code> 是通过 <code>directshow</code> 获取的当前的视频帧的时间戳。<code>m_llframe_index</code> 为当前已经经过压缩处理的帧的数量。</p><p>首先 <code>av_rescale</code> 计算得到当前压缩处理已经需要处理什么时间戳的视频帧，如果该时间戳尚未到达 <code>directshow</code> 当前提供的视频帧的时间戳，则将该帧丢弃掉。</p><p>否则进行压缩操作。并设置 <code>AVPacket</code> 的 <strong><em>pts</em></strong> 和 <strong><em>dts</em></strong>。这里假设 <code>B</code> 帧不存在。</p><p>因为在将来播放的时候视频以我们设定的固定播放帧率进行播放，所以需要根据设定的播放帧率计算得到的视频帧时间戳和 <code>directshow</code> 提供的当前视频帧的时间戳进行比较，设定是否需要进行实施延缓播放的策略。如果需要延缓播放，则将 <strong><em>pts</em></strong> 增加步长 <code>2</code>，否则以普通速度播放，则设置为 <code>1.dts</code> 与之相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__int64 x =av_rescale(m_llframe_index,AV_TIME_BASE*(<span class="keyword">int64_t</span>)c-&gt;time_base.num,c-&gt;time_base.den);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( x &gt; lTimeStamp )&#123;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">m_pVideoFrame2-&gt;pts = lTimeStamp;</span><br><span class="line">m_pVideoFrame2-&gt;pict_type = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> out_size = avcodec_encode_video( c, m_pvideo_outbuf, video_outbuf_size,m_pVideoFrame2 );</span><br><span class="line"><span class="comment">/* if zero size, it means the image was buffered */</span></span><br><span class="line"><span class="keyword">if</span> (out_size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      AVPacket pkt;</span><br><span class="line">      av_init_packet(&amp;pkt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( x &gt; lTimeStamp )</span><br><span class="line">&#123;</span><br><span class="line">   pkt.pts = pkt.dts = m_llframe_index;</span><br><span class="line">   pkt.duration = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">   pkt.duration = (lTimeStamp - x)*c-&gt;time_base.den/<span class="number">1000000</span> + <span class="number">1</span>;</span><br><span class="line">   pkt.pts = m_llframe_index;</span><br><span class="line">   pkt.dts = pkt.pts;</span><br><span class="line">   m_llframe_index += pkt.duration;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//pkt.pts = lTimeStamp * (__int64)frame_rate.den / 1000;</span></span><br><span class="line"><span class="keyword">if</span>( c-&gt;coded_frame &amp;&amp; c-&gt;coded_frame-&gt;key_frame )&#123;</span><br><span class="line">    pkt.flags |= PKT_FLAG_KEY;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">pkt.stream_index= m_pVideoStream-&gt;index;</span><br><span class="line">pkt.data= m_pvideo_outbuf;</span><br><span class="line">pkt.size= out_size;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* write the compressed frame in the media file */</span></span><br><span class="line">ret = av_interleaved_write_frame( m_pAvFormatContext, &amp;pkt );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>avcodec_decode_video 解码的帧为什么后面的比前面的 pts 小呢？</strong></p><p>请问如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( av_read_frame(pFormatCtxSource,&amp;packet)&gt;=<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( packet.stream_index == videoStream )&#123;</span><br><span class="line">        <span class="keyword">int</span> out_size = avcodec_decode_video(pCodecCtxSource, pFrameSource, &amp;bFrameFinished, packet.data, packet.size);</span><br><span class="line">        <span class="keyword">if</span>( bFrameFinished )&#123;</span><br><span class="line">            pFrameSource-&gt;pts = av_rescale_q(packet.pts, pCodecCtxSource-&gt;time_base, pStCodec-&gt;time_base);</span><br><span class="line">            <span class="keyword">int</span> out_size = avcodec_encode_video(pStCodec, video_buffer, <span class="number">200000</span>, pFrameSource); <span class="comment">// Encodeto output</span></span><br><span class="line">            <span class="keyword">if</span>( out_size&gt;<span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    av_free_packet(&amp;packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我<em>Decode</em>的时候，第一帧得到的 <em>pFrameSource-&gt;pts</em> 是<em>96</em>，再解第二帧的时候，<em>pFrameSource-&gt;pts</em>计算完后就成了<em>80</em>几，后几帧也是比<em>96</em>小，过一会又会解出来一个<em>100</em>多的，接下来又是比<em>100</em>多小的，这是为什么？在<em>Encode</em>的时候，先<em>Encode</em>一个<em>pts=96</em>的，再去<em>Encode</em>比<em>96</em>小的帧就返回<em>-1</em>了，直到找到一个比<em>96</em>大的。</p><p><strong>理解：</strong></p><p><em>Decoder</em>后<em>output</em>的<em>pts</em>是按正常的顺序，即显示的顺序输出的，如果有<em>B</em>帧，<em>decoder</em>会缓存。</p><p>但<em>encoder</em>后，输出的是按<em>dts</em>输出的。</p><p><em>Pts,dts</em>并不是时间戳，而更应该理解为<em>frame</em>的顺序序列号。由于每帧<em>frame</em>的帧率并不一定是一致的，可能会变化的。转换为时间戳的话，应该是（<em>pts</em> 帧率）。为加深理解</p><p>可以将<em>pts</em>比做是第<em>pts</em>帧<em>frame</em>，假设每帧的帧率不变的话，则显示的时间戳为（<em>pts**帧率），如果考虑帧率变化的，则要想办法将（</em>pts 当前的帧率）累加到后面。</p><p>可以看出有的<em>pts</em>是<em>+1</em>累加，有的是加了很多，但都是按顺序累加的。当传人<em>decoder</em>前的<em>packet</em>有<em>pts</em>时，则<em>decoder</em>后获取的<em>frame</em>将会赋值<em>packet</em>的<em>pts</em>；当传人的<em>packet</em>只是一帧的部分数据或是<em>B</em>帧，由于<em>decoder</em>出来的<em>frame</em>要按正常的<em>pts</em>顺序输出，有可能<em>decoder</em>不会获取到<em>frame</em>，或<em>decoder</em>内部会缓存也不会输出<em>frame</em>，即<em>frame</em>的<em>pts</em>会为空。<em>Frame pts</em>（即<em>opaque</em>）为空的话则会看<em>frame-&gt;dts,dts</em>都没有的话才认为<em>frame-&gt;pts</em>为<em>0.</em></p><p>对于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pts *= av_q2d(is-&gt;video_st-&gt;time_base);  <span class="comment">// 即pts帧率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Did we get avideo frame?</span></span><br><span class="line"><span class="keyword">if</span>(frameFinished) &#123;</span><br><span class="line">pts=synchronize_video(is, pFrame, pts);</span><br></pre></td></tr></table></figure><p><em>synchronize_video</em> 考虑了 3中情况：</p><p><em>1.    pts</em> 拿到的话就用该<em>pts</em></p><p><em>2.    pts</em>没有拿到的话就用前一帧的<em>pts</em>时间</p><p><em>3.</em>    如果该帧要重复显示，则将显示的<code>数量 * 帧率</code>，再加到前面的 <em>pts</em> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;<span class="comment">/////传人decoder后的帧队列中，以便后续去获取show。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">synchronize_video</span><span class="params">(VideoState *is, AVFrame*src_frame, <span class="keyword">double</span> pts)</span> </span>&#123; </span><br><span class="line">  doubleframe_delay; </span><br><span class="line">  <span class="keyword">if</span>(pts != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* if we havepts, set video clock to it */</span></span><br><span class="line">    is-&gt;video_clock = pts;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* if we aren'tgiven a pts, set it to the clock */</span></span><br><span class="line">    pts =is-&gt;video_clock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* update thevideo clock */</span></span><br><span class="line">   <span class="comment">/////很关键：前面传进来的pts已经是时间戳了，是当前frame开始播放的时间戳，</span></span><br><span class="line">   <span class="comment">/////下面frame_delay是该帧显示完将要花费的时间，（pts+frame_delay）也即是/////预测的下一帧将要播放的时间戳。</span></span><br><span class="line">  frame_delay =av_q2d(is-&gt;video_st-&gt;codec-&gt;time_base);</span><br><span class="line">  <span class="comment">/* if we arerepeating a frame, adjust clock accordingly */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//////重复多帧的话要累加上</span></span><br><span class="line">  frame_delay +=src_frame-&gt;repeat_pict * (frame_delay * <span class="number">0.5</span>);</span><br><span class="line">  is-&gt;video_clock += frame_delay;</span><br><span class="line">  <span class="keyword">return</span> pts;<span class="comment">/////此时返回的值即为下一帧将要开始显示的时间戳。</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">///////开定时器去显示帧队列中的已经decode过的数据，按前面的分析我们已经知道帧队列中的数据已经是按pts顺序插入到队列中的。Timer的作用就是有帧率不一致及重复帧的情况造成时间戳不是线性的，有快有慢，从而tutorial5才有timer的方式来播放追赶</span></span><br></pre></td></tr></table></figure><p>以下是一个网友很直观浅显的例子解释：</p><p><code>if(packet-&gt;dts == AV_NOPTS_VALUE</code> 是不是就是没有获取到 <em>dts</em> 的情况？</p><p>就是有一把尺子一只蚂蚁跟着一个标杆走</p><p>标杆是匀速的蚂蚁或快或慢</p><p>慢了你就抽让他跑起来快了就拽它</p><p>这样音（标杆）视频（蚂蚁）就能同步了</p><p>这里最大的问题就是音频是匀速的视频是非线性的</p><p>另外：此时 <em>vp–&gt;pts</em> 获取到的 <em>pts</em> 已经转化为时间戳了，这个时间戳为就是当前帧显示结束的时间戳，也即是下一帧将显示的预测时间戳。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">video_refresh_timer</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">  VideoState *is = (VideoState*)userdata;</span><br><span class="line">  VideoPicture *vp;</span><br><span class="line">  <span class="keyword">double</span> actual_delay, delay,sync_threshold, ref_clock, diff;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(is-&gt;video_st) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;pictq_size == <span class="number">0</span>) &#123;</span><br><span class="line">      schedule_refresh(is, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vp =&amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line">      delay = vp-&gt;pts -is-&gt;frame_last_pts; <span class="comment">/* the pts from last time */</span>  <span class="comment">////这是当前要显示的frame和下一副                                                        //////将要显示的frame的间隔时间</span></span><br><span class="line">      <span class="keyword">if</span>(delay &lt;= <span class="number">0</span> || delay&gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">         <span class="comment">/* if incorrect delay, useprevious one */</span></span><br><span class="line">         delay =is-&gt;frame_last_delay;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* save for next time */</span></span><br><span class="line">      is-&gt;frame_last_delay =delay;</span><br><span class="line">      is-&gt;frame_last_pts =vp-&gt;pts;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* update delay to sync toaudio */</span></span><br><span class="line">      ref_clock = get_audio_clock(is);<span class="comment">/////获取到声音当前播放的时间戳。</span></span><br><span class="line">      diff = vp-&gt;pts -ref_clock;<span class="comment">////// vp-&gt;pts实际上是预测的下一帧将要播放的开始时间,</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">//也就是说在diff这段时间中声音是匀速发生的，但是在delay这段时间frame的显示可能就会有快//////////慢的区别。   </span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Skip or repeat the frame.Take delay into account</span></span><br><span class="line"><span class="comment">          FFPlay still doesn't "know if this is thebest guess." */</span></span><br><span class="line">      sync_threshold = (delay &gt;AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">         <span class="keyword">if</span>(diff &lt;=-sync_threshold) &#123;</span><br><span class="line">           delay = <span class="number">0</span>;<span class="comment">//////下一帧画面显示的时间和当前的声音很近的话加快显示下一帧（即后面video_display显示完当前帧后开启定时器很快          去显示下一帧）</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span>(diff &gt;=sync_threshold) &#123;</span><br><span class="line">           delay = <span class="number">2</span> * delay;       <span class="comment">//////下一帧开始显示的时间和当前声音的时间隔的比较长则延缓，即两帧画面间话的显示的时间长度大于两帧画面  间的声音播放的时间，则我们将两帧画显示的时候加倍拖长点，比如帧1和帧2的时间显示间隔为40ms，但帧1和帧2的声音播放时间为55ms，怎么办呢？我们不可能去打乱声音的质量的，则我们采用的方法是：将两帧画面的播放间隔加大，本来是过30ms就要开始播下一帧的，我们改成60ms后才播下一帧。</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="comment">///当然如果diff大于AV_NOSYNC_THRESHOLD，即快进的模式了，画面跳动太大，不存在音视频同步的问题了。</span></span><br><span class="line"> </span><br><span class="line">      is-&gt;frame_timer += delay;</span><br><span class="line">      <span class="comment">/* computer the REAL delay*/</span></span><br><span class="line">      actual_delay =is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line">      <span class="keyword">if</span>(actual_delay &lt; <span class="number">0.010</span>)&#123;</span><br><span class="line">         <span class="comment">/* Really it should skipthe picture instead */</span></span><br><span class="line">         actual_delay = <span class="number">0.010</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      schedule_refresh(is,(<span class="keyword">int</span>)(actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));<span class="comment">////开定时器去显示下一帧</span></span><br><span class="line">      <span class="comment">/* show the picture! */</span></span><br><span class="line">      video_display(is);<span class="comment">////立马显示当前帧</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">/* update queue for nextpicture! */</span></span><br><span class="line">      <span class="keyword">if</span>(++is-&gt;pictq_rindex ==VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">         is-&gt;pictq_rindex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">      is-&gt;pictq_size--;</span><br><span class="line">     SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">     SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    schedule_refresh(is, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMTcwMDUvYXJ0aWNsZS9kZXRhaWxzLzUxMDgzNzQ1&quot; title=&quot;https://blog.csdn.net/u010317005/article/details/51083745&quot;&gt;ffmpeg编程基础和一些常见问题的解答&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;FFMpeg-编程的大致框架&quot;&gt;&lt;a href=&quot;#FFMpeg-编程的大致框架&quot; class=&quot;headerlink&quot; title=&quot;FFMpeg 编程的大致框架&quot;&gt;&lt;/a&gt;FFMpeg 编程的大致框架&lt;/h2&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg命令大全</title>
    <link href="http://miaopei.github.io/2019/05/04/FFmpeg/FFmpeg%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://miaopei.github.io/2019/05/04/FFmpeg/FFmpeg命令大全/</id>
    <published>2019-05-04T02:14:50.000Z</published>
    <updated>2019-06-05T04:03:57.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p><p>本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。</p><a id="more"></a><h2 id="2-FFMPEG-目录及作用"><a href="#2-FFMPEG-目录及作用" class="headerlink" title="2. FFMPEG 目录及作用"></a>2. FFMPEG 目录及作用</h2><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各类工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h2 id="3-FFMPEG-基本概念"><a href="#3-FFMPEG-基本概念" class="headerlink" title="3. FFMPEG 基本概念"></a>3. FFMPEG 基本概念</h2><p>在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。</p><ul><li><p>音／视频流</p><p>在音视频领域，我们把一路音／视频称为一路<strong>流</strong>。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p></li><li><p>容器</p><p>我们一般把 MP4､ FLV、MOV 等文件格式称之为<strong>容器</strong>。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p></li><li><p>channel</p><p>channel 是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p></li></ul><h2 id="4-FFMPEG-命令"><a href="#4-FFMPEG-命令" class="headerlink" title="4. FFMPEG 命令"></a>4. FFMPEG 命令</h2><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解 / 复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><img src="/images/imageFFmpeg/音视频处理流程.png"><p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。</p><p>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。</p><p>您可以通过使用 <code>-vn / -an / -sn / -dn</code> 选项来禁用某些默认设置。 要进行全面的手动控制，请使用 <code>-map</code>选项，该选项禁用刚描述的默认设置。</p><p>下面我们就来详细介绍一下这些命令。</p><h2 id="5-基本信息查询命令"><a href="#5-基本信息查询命令" class="headerlink" title="5. 基本信息查询命令"></a>5. 基本信息查询命令</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 <code>ffmpeg -filters</code> 来查询。详细参数说明如下：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-version</td><td>显示版本。</td></tr><tr><td>-formats</td><td>显示可用的格式（包括设备）。</td></tr><tr><td>-demuxers</td><td>显示可用的demuxers。</td></tr><tr><td>-muxers</td><td>显示可用的muxers。</td></tr><tr><td>-devices</td><td>显示可用的设备。</td></tr><tr><td>-codecs</td><td>显示libavcodec已知的所有编解码器。</td></tr><tr><td>-decoders</td><td>显示可用的解码器。</td></tr><tr><td>-encoders</td><td>显示所有可用的编码器。</td></tr><tr><td>-bsfs</td><td>显示可用的比特流filter。</td></tr><tr><td>-protocols</td><td>显示可用的协议。</td></tr><tr><td>-filters</td><td>显示可用的libavfilter过滤器。</td></tr><tr><td>-pix_fmts</td><td>显示可用的像素格式。</td></tr><tr><td>-sample_fmts</td><td>显示可用的采样格式。</td></tr><tr><td>-layouts</td><td>显示channel名称和标准channel布局。</td></tr><tr><td>-colors</td><td>显示识别的颜色名称。</td></tr></tbody></table><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。</p><h2 id="6-命令基本格式及参数"><a href="#6-命令基本格式及参数" class="headerlink" title="6. 命令基本格式及参数"></a>6. 命令基本格式及参数</h2><p>下面是 FFMPEG 的基本命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ...</span></span><br><span class="line">                         &#123;[output_file_options] output_url&#125; ...</span><br></pre></td></tr></table></figure><p>ffmpeg 通过 <code>-i</code> 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等），并写入任意数量的输出“文件”。</p><p>原则上，每个输入 / 输出“文件”都可以包含任意数量的不同类型的视频流（视频 / 音频 / 字幕 / 附件 / 数据）。 <strong>流的数量和 / 或类型是由容器格式来限制</strong>。 选择从哪个输入进入到哪个输出将自动完成或使用 <code>-map</code> 选项。</p><p>要引用选项中的输入文件，您必须使用它们的索引（从 0 开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 <strong>例如： 2：3 是指第三个输入文件中的第四个流</strong>。</p><p>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p><h3 id="6-1-主要参数"><a href="#6-1-主要参数" class="headerlink" title="6.1 主要参数"></a>6.1 主要参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-f fmt（输入/输出）</td><td>强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。</td></tr><tr><td>-i url（输入）</td><td>输入文件的网址</td></tr><tr><td>-y（全局参数）</td><td>覆盖输出文件而不询问。</td></tr><tr><td>-n（全局参数）</td><td>不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。</td></tr><tr><td>-c [：stream_specifier] codec（输入/输出，每个流）</td><td>选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：<code>ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT</code></td></tr><tr><td>-codec [：stream_specifier]编解码器（输入/输出，每个流）</td><td>同 -c</td></tr><tr><td>-t duration（输入/输出）</td><td>当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</td></tr><tr><td>-ss位置（输入/输出）</td><td>当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</td></tr><tr><td>-frames [：stream_specifier] framecount（output，per-stream）</td><td>停止在帧计数帧之后写入流。</td></tr><tr><td>-filter [：stream_specifier] filtergraph（output，per-stream）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</td></tr></tbody></table><h3 id="6-2-视频参数"><a href="#6-2-视频参数" class="headerlink" title="6.2 视频参数"></a>6.2 视频参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-vframes num（输出）</td><td>设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。</td></tr><tr><td>-r [：stream_specifier] fps（输入/输出，每个流）</td><td>设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。</td></tr><tr><td>-s [：stream_specifier]大小（输入/输出，每个流）</td><td>设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。</td></tr><tr><td>-aspect [：stream_specifier] 宽高比（输出，每个流）</td><td>设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。</td></tr><tr><td>-vn（输出）</td><td>禁用视频录制。</td></tr><tr><td>-vcodec编解码器（输出）</td><td>设置视频编解码器。这是 <code>-codec：v</code> 的别名。</td></tr><tr><td>-vf filtergraph（输出）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><h3 id="6-3-音频参数"><a href="#6-3-音频参数" class="headerlink" title="6.3 音频参数"></a>6.3 音频参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-aframes（输出）</td><td>设置要输出的音频帧的数量。这是 <code>-frames：a</code> 的一个过时的别名。</td></tr><tr><td>-ar [：stream_specifier] freq（输入/输出，每个流）</td><td>设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td>-ac [：stream_specifier]通道（输入/输出，每个流）</td><td>设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td>-an（输出）</td><td>禁用录音。</td></tr><tr><td>-acodec编解码器（输入/输出）</td><td>设置音频编解码器。这是-codec的别名：a。</td></tr><tr><td>-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</td><td>设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。</td></tr><tr><td>-af filtergraph（输出）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><p>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p><h2 id="7-录制"><a href="#7-录制" class="headerlink" title="7. 录制"></a>7. 录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -list_devices <span class="literal">true</span> -i <span class="string">""</span></span></span><br></pre></td></tr></table></figure><p><strong>录屏</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span></span><br></pre></td></tr></table></figure><ul><li><p>-f 指定使用 avfoundation 采集数据。</p></li><li><p>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</p></li><li><p>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而 -r 用于限制输出。</p></li></ul><p>注意：桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</p><p><strong>录屏+声音</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</span></span><br></pre></td></tr></table></figure><ul><li><p>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</p></li><li><p>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</p></li><li><p>-crf 是 x264 的参数。 0 表式无损压缩。</p></li><li><p>-c:a 与参数 -acodec 一样，表示音频编码器。</p></li><li><p>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</p></li><li><p>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</p></li></ul><p><strong>录视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</p></li><li><p>-f 指定使用 avfoundation 采集数据。</p></li><li><p>-i 指定视频设备的索引号。</p></li></ul><p><strong>视频+音频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</span></span><br></pre></td></tr></table></figure><p><strong>录音</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -i :0 out.wav</span></span><br></pre></td></tr></table></figure><p><strong>录制音频裸数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</span></span><br></pre></td></tr></table></figure><h2 id="8-分解与复用"><a href="#8-分解与复用" class="headerlink" title="8. 分解与复用"></a>8. 分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p><img src="/images/imageFFmpeg/分解与复用.png"><p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p><p><strong>抽取音频流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -acodec copy -vn out.aac</span></span><br></pre></td></tr></table></figure><ul><li><p>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</p></li><li><p>vn: v 代表视频，n 代表 no 也就是无视频的意思。</p></li></ul><p><strong>抽取视频流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -vcodec copy -an out.h264</span></span><br></pre></td></tr></table></figure><ul><li><p>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</p></li><li><p>an: a 代表视频，n 代表 no 也就是无音频的意思。</p></li></ul><p><strong>转格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span></span><br></pre></td></tr></table></figure><p>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了 flv。</p><p><strong>音视频合并</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</span></span><br></pre></td></tr></table></figure><h2 id="9-处理原始数据"><a href="#9-处理原始数据" class="headerlink" title="9. 处理原始数据"></a>9. <strong>处理原始数据</strong></h2><p><strong>提取YUV数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffplay -s wxh out.yuv</span></span><br></pre></td></tr></table></figure><ul><li><p>-c:v rawvideo 指定将视频转成原始数据</p></li><li><p>-pixel_format yuv420p 指定转换格式为 yuv420p</p></li></ul><p><strong>YUV 转 H264</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</span></span><br></pre></td></tr></table></figure><p><strong>提取 PCM 数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</span></span><br></pre></td></tr></table></figure><p><strong>PCM 转 WAV</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</span></span><br></pre></td></tr></table></figure><h2 id="10-滤镜"><a href="#10-滤镜" class="headerlink" title="10. 滤镜"></a>10. <strong>滤镜</strong></h2><p>在编码之前，ffmpeg 可以使用 libavfilter 库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg 区分两种类型的过滤器图形：简单和复杂。</p><h3 id="10-1-简单滤镜"><a href="#10-1-简单滤镜" class="headerlink" title="10.1 简单滤镜"></a>10.1 简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p><img src="/images/imageFFmpeg/简单滤镜.png"><p>简单的 filtergraphs 配置了 per-stream-filter 选项（分别为视频和音频使用 <code>-vf</code> 和 <code>-af</code> 别名）。 一个简单的视频 filtergraph 可以看起来像这样的例子：</p><img src="/images/imageFFmpeg/简单滤镜-01.png"><p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的 fps 过滤器会改变帧数，但不会触及帧内容。 另一个例子是 setpts 过滤器，它只设置时间戳，否则不改变帧。</p><h3 id="10-2-复杂滤镜"><a href="#10-2-复杂滤镜" class="headerlink" title="10.2 复杂滤镜"></a>10.2 复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p><img src="/images/imageFFmpeg/复杂滤镜.png"><p>复杂的过滤器图使用 <code>-filter_complex</code> 选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。</p><p><code>-lavfi</code> 选项等同于 <code>-filter_complex</code>。</p><p>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是 amix 滤波器。</p><p><strong>添加水印</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4  -vf <span class="string">"movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]"</span> water.mp4</span></span><br></pre></td></tr></table></figure><ul><li>-vf 中的 movie 指定 logo 位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。</li></ul><p><strong>删除水印</strong></p><p>先通过 ffplay 找到要删除 LOGO 的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -i test.flv -vf delogo=x=806:y=20:w=70:h=80:show=1</span></span><br></pre></td></tr></table></figure><p>使用 delogo 滤镜删除 LOGO</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.flv -vf delogo=x=806:y=20:w=70:h=80 output.flv</span></span><br></pre></td></tr></table></figure><p><strong>视频缩小一倍</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4</span></span><br></pre></td></tr></table></figure><ul><li>-vf scale 指定使用简单过滤器 scale，<code>iw/2:-1</code> 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</li></ul><p><strong>视频裁剪</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i VR.mov  -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</span></span><br></pre></td></tr></table></figure><p>crop 格式：<code>crop=out_w:out_h:x:y</code></p><ul><li><p>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</p></li><li><p>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</p></li><li><p>x : X坐标</p></li><li><p>y : Y坐标</p></li></ul><p>如果 x 和 y 设置为 0, 说明从左上角开始裁剪。如果不写是从中心点裁剪。</p><p><strong>倍速播放</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -filter_complex <span class="string">"[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]"</span> -map <span class="string">"[v]"</span> -map <span class="string">"[a]"</span> speed2.0.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-filter_complex 复杂滤镜，<code>[0:v]</code> 表示第一个（文件索引号是 0）文件的视频作为输入。<code>setpts=0.5*PTS</code> 表示每帧视频的 pts 时间戳都乘 0.5 ，也就是差少一半。<code>[v]</code> 表示输出的别名。音频同理就不详述了。</p></li><li><p>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</p></li></ul><p><strong>对称视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -i out.mp4 -filter_complex <span class="string">"[0:v]pad=w=2*iw[a];[0:v]hflip[b];[a][b]overlay=x=w"</span> duicheng.mp4</span></span><br></pre></td></tr></table></figure><ul><li>hflip 水平翻转</li></ul><p>如果要修改为垂直翻转可以用 vflip。</p><p><strong>画中画</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -i out1.mp4 -filter_complex <span class="string">"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart new.mp4</span></span><br></pre></td></tr></table></figure><p><strong>录制画中画</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation -i <span class="string">"0:0"</span> </span></span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast </span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 </span><br><span class="line">-filter_complex "[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[a];[0:v][a]overlay=x=W-w-10:y=0[out]" </span><br><span class="line">-map "[out]" -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure><p><strong>多路视频拼接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation   -i <span class="string">"0:0"</span> -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex <span class="string">"[0:v]scale=320:240[a];[a]pad=640:240[b];[b][1:v]overlay=320:0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart  -map 1:a  c.mp4</span></span><br></pre></td></tr></table></figure><h2 id="11-音视频的拼接与裁剪"><a href="#11-音视频的拼接与裁剪" class="headerlink" title="11. 音视频的拼接与裁剪"></a>11. <strong>音视频的拼接与裁剪</strong></h2><p><strong>裁剪</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-ss 指定裁剪的开始时间，精确到秒</p></li><li><p>-t 被裁剪后的时长。</p></li></ul><p><strong>合并</strong></p><p>首先创建一个 inputs.txt 文件，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'1.flv'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'2.flv'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'3.flv'</span></span></span><br></pre></td></tr></table></figure><p>然后执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f concat -i inputs.txt -c copy output.flv</span></span><br></pre></td></tr></table></figure><p><strong>hls切片</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</span></span><br></pre></td></tr></table></figure><ul><li><p>-strict -2 指明音频使有AAC。</p></li><li><p>-f hls 转成 m3u8 格式。</p></li></ul><h2 id="12-视频图片互转"><a href="#12-视频图片互转" class="headerlink" title="12. 视频图片互转"></a>12. 视频图片互转</h2><p><strong>视频转 JPEG</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</span></span><br></pre></td></tr></table></figure><p><strong>视频转 gif</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</span></span><br></pre></td></tr></table></figure><p><strong>图片转视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</span></span><br></pre></td></tr></table></figure><h2 id="13-直播相关"><a href="#13-直播相关" class="headerlink" title="13. 直播相关"></a>13. <strong>直播相关</strong></h2><p><strong>推流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span></span><br></pre></td></tr></table></figure><p><strong>拉流保存</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><p><strong>转流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream</span></span><br></pre></td></tr></table></figure><p><strong>实时推流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 15 -f avfoundation -i <span class="string">"1"</span> -s 1280x720 -c:v libx264  -f  flv rtmp://localhost:1935/live/room</span></span><br></pre></td></tr></table></figure><h2 id="14-ffplay"><a href="#14-ffplay" class="headerlink" title="14. ffplay"></a>14. <strong>ffplay</strong></h2><p><strong>播放 YUV 数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -pix_fmt nv12 -s 192x144 1.yuv</span></span><br></pre></td></tr></table></figure><p><strong>播放 YUV 中的 Y 平面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes=<span class="string">'y'</span> 1.yuv</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。&lt;/p&gt;
&lt;p&gt;本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频核心技术</title>
    <link href="http://miaopei.github.io/2019/04/30/FFmpeg/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>http://miaopei.github.io/2019/04/30/FFmpeg/音视频核心技术/</id>
    <published>2019-04-30T06:14:50.000Z</published>
    <updated>2019-06-12T06:47:34.994Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><img src="/images/imageFFmpeg/FFmpeg音视频架构-01.png"><img src="/images/imageFFmpeg/FFmpeg音视频架构-02.png"><h2 id="1-学习大纲"><a href="#1-学习大纲" class="headerlink" title="1. 学习大纲"></a>1. 学习大纲</h2><p><strong>FFmpeg 常用命令</strong>：</p><ul><li>视频录制命令</li><li>多媒体文件的分解/复用命令</li><li>裁剪与合并命令</li><li>图片/视频互转命令</li><li>直播相关命令</li><li>各种滤镜命令</li></ul><p><strong>FFmpeg 基本开发</strong>：</p><ul><li>C 语言回顾</li><li>FFmpeg 核心概念与常用结构体</li><li>实战 - 多媒体文件的分解与复用</li><li>实战 - 多媒体格式的互转</li><li>实战 - 从 MP4 裁剪一段视频</li><li>作业 - 实现一个简单的小咖秀</li></ul><p><strong>音视频编解码实战</strong>：</p><ul><li>实战 - H264 解码</li><li>实战 - H264 编码</li><li>实战 - 音频 AAC 解码</li><li>实战 - 音频 AAC 编码</li><li>实战 - 视频转图片</li></ul><p><strong>音视频渲染实战</strong>：</p><ul><li>SDL 事件处理</li><li>SDL 视频文理渲染</li><li>SDL 音频渲染</li><li>实战1 - 实现 YUV 视频播放</li><li>实战2 - YUV 视频倍数播放</li><li>实战3 - 实现 PCM 播放器</li></ul><p><strong>FFmpeg 开发播放器核心功能</strong>：</p><ul><li>实战 - 实现 MP4 文件的视频播放</li><li>实战 - 实现 MP4 文件的音频播放</li><li>实战 - 实现一个初级播放器</li><li>实战 - 音视频同步</li><li>实战 - 实现播放器内核</li></ul><p><strong>Android 中实战 FFmpeg</strong>：</p><ul><li>编译 Android 端可以使用的 FFmpeg</li><li>Java 与 C 语言相互调用</li><li>实战 - Android 调用 FFmpeg</li></ul><p><strong>学习建议</strong>：</p><ul><li>牢牢抓住音视频的处理机制，了解其本质</li><li>勤加练习，熟能生巧</li><li>待着问题去学习，事半功倍</li></ul><p><strong>音视频的广泛应用</strong>：</p><ul><li>直播类：音视频会议、教育直播、娱乐/游戏直播</li><li>短视频：抖音、快手、小咖秀</li><li>网络视频：优酷、腾讯视频、爱奇艺等</li><li>音视频通话：微信、QQ、Skype等</li><li>视频监控</li><li>人工智能：人脸识别，智能音箱等，更关注算法</li></ul><p><strong>播放器架构</strong>：</p><img src="/images/imageFFmpeg/播放器架构.png"><p><strong>渲染流程</strong>：</p><img src="/images/imageFFmpeg/渲染流程.png"><p><strong>FFmpeg 都能做啥</strong>：</p><ul><li>FFmpeg 是一个非常优秀的多媒体框架</li><li>FFmpeg 可以运行在 Linux、Mac、Windows 等平台上</li><li>能够解码、编码、转码、复用、解复用、过滤音视频数据</li></ul><p><strong>FFmpeg 下载与安装</strong>：</p><details><summary>FFMpeg 下载与安装</summary> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://git.ffmpeg.org/ffmpeg.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> config -- <span class="built_in">help</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure></details><h2 id="2-FFmpeg-常用命令实战"><a href="#2-FFmpeg-常用命令实战" class="headerlink" title="2. FFmpeg 常用命令实战"></a>2. FFmpeg 常用命令实战</h2><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解 / 复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><img src="/images/imageFFmpeg/FFmpeg处理音视频流程.png"><img src="/images/imageFFmpeg/FFmpeg基本信息查询命令.png"><img src="/images/imageFFmpeg/FFmpeg录屏命令.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -s 2560x1600 -pix_fmt uyvy422 out.yuv</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/分解与复用-01.png"><img src="/images/imageFFmpeg/多媒体格式转换.png"><h2 id="3-初级开发内容"><a href="#3-初级开发内容" class="headerlink" title="3. 初级开发内容"></a>3. 初级开发内容</h2><ul><li>FFmpeg 日志的使用及目录的操作</li><li>介绍 FFmpeg 的基本概念及常用的结构体</li><li>对复用/解复用及流程操作的各种实践</li></ul><p>FFmpeg 代码结构：</p><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各类工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h3 id="3-1-FFmpeg-日志系统"><a href="#3-1-FFmpeg-日志系统" class="headerlink" title="3.1 FFmpeg 日志系统"></a>3.1 FFmpeg 日志系统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">av_log_set_level(AV_LOG_DEBUG)</span><br><span class="line">    </span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"...%s\n"</span>, op)</span><br></pre></td></tr></table></figure><ul><li>AV_LOG_ERROR</li><li>AV_LOG_WARNING</li><li>AV_LOG_INFO</li></ul><details><summary>FFmpeg日志系统使用</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line"></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"hello world: %s!\n"</span>, <span class="string">"aaa"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="3-2-FFmpeg-文件与目录操作"><a href="#3-2-FFmpeg-文件与目录操作" class="headerlink" title="3.2 FFmpeg 文件与目录操作"></a>3.2 FFmpeg 文件与目录操作</h3><p>文件的删除与重命名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">avpriv_io_delete()</span><br><span class="line">    </span><br><span class="line">avpriv_io_move(src, dst)</span><br></pre></td></tr></table></figure><details><summary>FFmpeg文件与目录操作</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = avpriv_io_delete(<span class="string">"./mytestfile.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to delete file mytestfile.txt\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = avpriv_io_move(<span class="string">"111.txt"</span>, <span class="string">"222.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Filed to rename\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --libs libavformat`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pkg-config --libs libavformat 指令可以搜索libavformat库所在路径</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> pkg-config --libs libavformat</span></span><br><span class="line">-L/usr/local/ffmpeg/lib -lavformat</span><br></pre></td></tr></table></figure></details><h3 id="3-3-FFmpeg-操作目录重要函数"><a href="#3-3-FFmpeg-操作目录重要函数" class="headerlink" title="3.3 FFmpeg 操作目录重要函数"></a>3.3 FFmpeg 操作目录重要函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avio_open_dir()</span><br><span class="line">avio_read_dir()</span><br><span class="line">avio_close_dir()</span><br></pre></td></tr></table></figure><p>操作目录重要结构体：</p><ul><li><p>AVIODirContext</p><p>操作目录的上下文</p></li><li><p>AVIODirEntry</p><p>目录项。用于存放文件名，文件大小等信息</p></li></ul><details><summary>FFmpeg操作目录</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVIODirContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVIODirEntry *entry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = avio_open_dir(&amp;ctx, <span class="string">"./"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant open dir:%s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = avio_read_dir(ctx, &amp;entry);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant read dir: %s\n"</span>, av_err2str(ret));</span><br><span class="line">            <span class="keyword">goto</span> __fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"%l2"</span>PRId64<span class="string">" %s\n"</span>,</span><br><span class="line">               entry-&gt;size,</span><br><span class="line">               entry-&gt;name);</span><br><span class="line"></span><br><span class="line">        avio_free_directory_entry(&amp;entry);</span><br><span class="line">    &#125;</span><br><span class="line">__fail:</span><br><span class="line">    avio_close_dir(&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o list ffmpeg_list.c `pkg-config --libs libavformat libavutil`</span></span><br></pre></td></tr></table></figure></details><h3 id="3-4-多媒体文件的基本概念"><a href="#3-4-多媒体文件的基本概念" class="headerlink" title="3.4 多媒体文件的基本概念"></a>3.4 多媒体文件的基本概念</h3><ul><li>多媒体文件其实是个容器</li><li>在容器里有很多流（Stream/Track)</li><li>每种流是由不同的编码器编码的</li><li>从流中读出的数据称为包</li><li>在一个包中包含着一个或多个帧</li></ul><p>几个重要的结构体：</p><ul><li>AVFormatContext</li><li>AVStream</li><li>AVPacket</li></ul><p>FFmpeg 操作流数据的基本步骤：</p><p>解复用 —&gt; 获取流 —&gt; 读取数据包 —&gt;  释放资源</p><h3 id="3-5-实战-打印音-视频信息"><a href="#3-5-实战-打印音-视频信息" class="headerlink" title="3.5 [实战] 打印音/视频信息"></a>3.5 [实战] 打印音/视频信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_register_all()</span><br><span class="line">avformat_open_input() / avformat_close_input()</span><br><span class="line">av_dump_format()</span><br></pre></td></tr></table></figure><details><summary>[实战] 打印音/视频信息</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    ret = avformat_open_input(&amp;fmt_ctx, <span class="string">"./test.mp4"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open file: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, <span class="string">"./test.mp4"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;fmt_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="3-6-实战-抽取音频数据"><a href="#3-6-实战-抽取音频数据" class="headerlink" title="3.6 [实战] 抽取音频数据"></a>3.6 [实战] 抽取音频数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_init_packet()</span><br><span class="line">av_find_best_stream()</span><br><span class="line">av_read_frame() / av_packet_unref()</span><br></pre></td></tr></table></figure><details><summary>[实战] 抽取音频数据</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> audio_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *src = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *dst = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. read two params form console</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"eg: %s in_file out_file\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    src = argv[<span class="number">1</span>];</span><br><span class="line">    dst = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (!src || !dst) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"src or dst is null\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = avformat_open_input(&amp;fmt_ctx, src, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open file: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *dst_fd = fopen(dst, <span class="string">"wb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dst_fd) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open out file!\n"</span>);</span><br><span class="line">        avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, src, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. get stream</span></span><br><span class="line">    ret = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't find the best stream!\n"</span>);</span><br><span class="line">        avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">        fclose(dst_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_index = ret;</span><br><span class="line">    av_init_packet(&amp;pkt);</span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(fmt_ctx, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt.stream_index == audio_index) &#123;</span><br><span class="line">            <span class="comment">// 3. write audio data to aac file.</span></span><br><span class="line">            len = fwrite(pkt.data, <span class="number">1</span>, pkt.size, dst_fd);</span><br><span class="line">            <span class="keyword">if</span> (len != pkt.size) &#123;</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">"warning, length of data is not equal size of pkt!\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">    <span class="keyword">if</span> (dst_fd) &#123;</span><br><span class="line">        fclose(dst_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lang -g -o extra_audio extra_audio.c `pkg-config --libs libavutil libavformat`</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./extra_audio test.mp4 killer.aa</span></span><br></pre></td></tr></table></figure></details><h3 id="3-7-实战-抽取视频数据"><a href="#3-7-实战-抽取视频数据" class="headerlink" title="3.7 [实战] 抽取视频数据"></a>3.7 [实战] 抽取视频数据</h3><ul><li>Start code</li><li>SPS/PPS</li><li>codec -&gt; extradata</li></ul><h3 id="3-8-实战-将-MP4-转成-FLV-格式"><a href="#3-8-实战-将-MP4-转成-FLV-格式" class="headerlink" title="3.8 [实战] 将 MP4 转成 FLV 格式"></a>3.8 [实战] 将 MP4 转成 FLV 格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">avformat_alloc_output_context2() / avformat_free_context();</span><br><span class="line">avformat_new_stream();</span><br><span class="line">avcodec_parameters_copy();</span><br><span class="line">avformat_write_header();</span><br><span class="line">av_write_frame() / av_interleaved_write_frame();</span><br><span class="line">av_write_trailer()</span><br></pre></td></tr></table></figure><h3 id="3-9-实战-从-MP4-截取一段视频"><a href="#3-9-实战-从-MP4-截取一段视频" class="headerlink" title="3.9 [实战] 从 MP4 截取一段视频"></a>3.9 [实战] 从 MP4 截取一段视频</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_seek_frame()</span><br></pre></td></tr></table></figure><details><summary>从 MP4 截取一段视频代码:</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_packet</span><span class="params">(<span class="keyword">const</span> AVFormatContext *fmt_ctx, <span class="keyword">const</span> AVPacket *pkt, <span class="keyword">const</span> <span class="keyword">char</span> *tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVRational *time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\n"</span>,</span><br><span class="line">           tag,</span><br><span class="line">           av_ts2str(pkt-&gt;pts), av_ts2timestr(pkt-&gt;pts, time_base),</span><br><span class="line">           av_ts2str(pkt-&gt;dts), av_ts2timestr(pkt-&gt;dts, time_base),</span><br><span class="line">           av_ts2str(pkt-&gt;duration), av_ts2timestr(pkt-&gt;duration, time_base),</span><br><span class="line">           pkt-&gt;stream_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_video</span><span class="params">(<span class="keyword">double</span> from_seconds, <span class="keyword">double</span> end_seconds, <span class="keyword">const</span> <span class="keyword">char</span>* in_filename, <span class="keyword">const</span> <span class="keyword">char</span>* out_filename)</span> </span>&#123;</span><br><span class="line">    AVOutputFormat *ofmt = <span class="literal">NULL</span>;</span><br><span class="line">    AVFormatContext *ifmt_ctx = <span class="literal">NULL</span>, *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    <span class="keyword">int</span> ret, i;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = avformat_open_input(&amp;ifmt_ctx, in_filename, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open input file '%s'"</span>, in_filename);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = avformat_find_stream_info(ifmt_ctx, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to retrieve input stream information"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_dump_format(ifmt_ctx, <span class="number">0</span>, in_filename, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, out_filename);</span><br><span class="line">    <span class="keyword">if</span> (!ofmt_ctx) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not create output context\n"</span>);</span><br><span class="line">        ret = AVERROR_UNKNOWN;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ofmt = ofmt_ctx-&gt;oformat;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *in_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        AVStream *out_stream = avformat_new_stream(ofmt_ctx, in_stream-&gt;codec-&gt;codec);</span><br><span class="line">        <span class="keyword">if</span> (!out_stream) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed allocating output stream\n"</span>);</span><br><span class="line">            ret = AVERROR_UNKNOWN;</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ret = avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy context from input to output stream codec context\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        out_stream-&gt;codec-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)</span><br><span class="line">            out_stream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line">    av_dump_format(ofmt_ctx, <span class="number">0</span>, out_filename, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">        ret = avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open output file '%s'"</span>, out_filename);</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error occurred when opening output file\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    int indexs[8] = &#123;0&#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    int64_t start_from = 8*AV_TIME_BASE;</span></span><br><span class="line">    ret = av_seek_frame(ifmt_ctx, <span class="number">-1</span>, from_seconds*AV_TIME_BASE, AVSEEK_FLAG_ANY);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error seek\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int64_t</span> *dts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="built_in">memset</span>(dts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="keyword">int64_t</span> *pts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="built_in">memset</span>(pts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        AVStream *in_stream, *out_stream;</span><br><span class="line">    </span><br><span class="line">        ret = av_read_frame(ifmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">        in_stream  = ifmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">        out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">    </span><br><span class="line">        log_packet(ifmt_ctx, &amp;pkt, <span class="string">"in"</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (av_q2d(in_stream-&gt;time_base) * pkt.pts &gt; end_seconds) &#123;</span><br><span class="line">            av_free_packet(&amp;pkt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (dts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            dts_start_from[pkt.stream_index] = pkt.dts;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"dts_start_from: %s\n"</span>, av_ts2str(dts_start_from[pkt.stream_index]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            pts_start_from[pkt.stream_index] = pkt.pts;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"pts_start_from: %s\n"</span>, av_ts2str(pts_start_from[pkt.stream_index]));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* copy packet */</span></span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts - pts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts - dts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);</span><br><span class="line">        <span class="keyword">if</span> (pkt.pts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.pts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pkt.dts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.dts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pkt.duration = (<span class="keyword">int</span>)av_rescale_q((<span class="keyword">int64_t</span>)pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line">        log_packet(ofmt_ctx, &amp;pkt, <span class="string">"out"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">        ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error muxing packet\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        av_free_packet(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(dts_start_from);</span><br><span class="line">    <span class="built_in">free</span>(pts_start_from);</span><br><span class="line">    </span><br><span class="line">    av_write_trailer(ofmt_ctx);</span><br><span class="line">    </span><br><span class="line">end:</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* close output */</span></span><br><span class="line">    <span class="keyword">if</span> (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">        avio_closep(&amp;ofmt_ctx-&gt;pb);</span><br><span class="line">    avformat_free_context(ofmt_ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error occurred: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: \</span></span><br><span class="line"><span class="string">                command startime, endtime, srcfile, outfile"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> startime = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">double</span> endtime = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    cut_video(startime, endtime, argv[<span class="number">3</span>], argv[<span class="number">4</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="3-10-实战-一个简单的小咖秀"><a href="#3-10-实战-一个简单的小咖秀" class="headerlink" title="3.10 [实战] 一个简单的小咖秀"></a>3.10 [实战] 一个简单的小咖秀</h3><ul><li><p>将两个媒体文件中分别抽取音频与视频轨</p></li><li><p>将音频与视频轨合并成一个新文件</p></li><li><p>对音频与视频轨进行裁剪</p><h2 id="4-FFmpeg-中级开发内容"><a href="#4-FFmpeg-中级开发内容" class="headerlink" title="4. FFmpeg 中级开发内容"></a>4. FFmpeg 中级开发内容</h2></li><li><p>FFmpeg H264 解码</p></li><li><p>FFmpeg H264 编码</p></li><li><p>FFmpeg AAC 解码</p></li><li><p>FFmpeg AAC 编码</p></li></ul><h3 id="4-1-FFmpeg-H264-解码"><a href="#4-1-FFmpeg-H264-解码" class="headerlink" title="4.1 FFmpeg H264 解码"></a>4.1 FFmpeg H264 解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>常用数据结构：</p><ul><li><p>AVCodec 编码器结构体</p></li><li><p>AVCodecContext 编码器上下文</p></li><li><p>AVFrame 解码后的帧</p><p>结构体内存的分配与释放：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_frame_alloc / av_frame_free();</span><br><span class="line">avcodec_alloc_context3();</span><br><span class="line">avcodec_free_context();</span><br></pre></td></tr></table></figure><p>解码步骤：</p><ul><li>查找解码器（avcodec_find_decoder）</li><li>打开解码器（avcodec_open2）</li><li>解码（avcodec_decode_video2）</li></ul><h3 id="4-2-FFmpeg-H264-编码"><a href="#4-2-FFmpeg-H264-编码" class="headerlink" title="4.2 FFmpeg H264 编码"></a>4.2 FFmpeg H264 编码</h3><p>H264编码流程：</p><ul><li>查找编码器（avcodec_find_encoder_by_name）</li><li>设置参数，打开编码器（avcondec_open2）</li><li>编码（avcondec_encode_video2）</li></ul><h3 id="4-3-视频转图片"><a href="#4-3-视频转图片" class="headerlink" title="4.3 视频转图片"></a>4.3 视频转图片</h3><p>TODO</p><h3 id="4-4-FFmpeg-AAC-编码"><a href="#4-4-FFmpeg-AAC-编码" class="headerlink" title="4.4 FFmpeg AAC 编码"></a>4.4 FFmpeg AAC 编码</h3><ul><li>编码流程与视频相同</li><li>编码函数 avcodec_encodec_audio2</li></ul><h2 id="5-SDL-介绍"><a href="#5-SDL-介绍" class="headerlink" title="5. SDL 介绍"></a>5. SDL 介绍</h2><blockquote><p><a href="[http://www.libsdl.org](http://www.libsdl.org/)">SDL 官网</a></p></blockquote><ul><li>SDL（Simple DirectMedia Layer） 是一套<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTk2JThCJUU2JTk0JUJFJUU1JThFJTlGJUU1JUE3JThCJUU3JUEyJUJD" title="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%8E%9F%E5%A7%8B%E7%A2%BC">开放源代码<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUE4JUU1JUI5JUIzJUU1JThGJUIw" title="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JTlBJUU1JUFBJTkyJUU5JUFCJTk0" title="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E9%AB%94">多媒体<i class="fa fa-external-link"></i></span>开发<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg3JUJEJUU1JUJDJThGJUU1JUJBJUFC" title="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">库<i class="fa fa-external-link"></i></span></li><li>由 C 语言实现的跨平台的媒体开源库</li><li>多用于开发游戏、模拟器、媒体播放器等多媒体应用领域</li></ul><p>语法与子系统：</p><p>SDL将功能分成下列数个子系统（subsystem）：</p><ul><li><strong>Video（图像）</strong>—图像控制以及线程（thread）和事件管理（event）。</li><li><strong>Audio（声音）</strong>—声音控制</li><li><strong>Joystick（摇杆）</strong>—游戏摇杆控制</li><li><strong>CD-ROM（光盘驱动器）</strong>—光盘媒体控制</li><li><strong>Window Management（视窗管理）</strong>－与视窗程序设计集成</li><li><strong>Event（事件驱动）</strong>－处理事件驱动</li></ul><p>以下是一支用C语言写成、非常简单的SDL示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Headers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SDL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize SDL</span></span><br><span class="line">    <span class="keyword">if</span>(SDL_Init(SDL_INIT_EVERYTHING) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delay 2 seconds</span></span><br><span class="line">    SDL_Delay(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Quit SDL</span></span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序会加载所有SDL子系统（出错则退出程序），然后暂停两秒，最后关闭SDL并退出程序。</p><h3 id="5-1-SDL-编译与安装"><a href="#5-1-SDL-编译与安装" class="headerlink" title="5.1 SDL 编译与安装"></a>5.1 SDL 编译与安装</h3><ul><li>下载 SDL 源码</li><li>生成Makefile configure –prefix=/usr/local</li><li>安装 sudo make -j 8 &amp;&amp; make install</li></ul><h3 id="5-2-使用-SDL-基本步骤"><a href="#5-2-使用-SDL-基本步骤" class="headerlink" title="5.2 使用 SDL 基本步骤"></a>5.2 使用 SDL 基本步骤</h3><ul><li>添加头文件 #include &lt;SDL.h&gt;</li><li>初始化 SDL</li><li>退出 SDL</li></ul><p>SDL 渲染窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_Init() / SDL_Quit();</span><br><span class="line">SDL_CreateWindow() / SDL_DestoryWindow();</span><br><span class="line">SDL_CreateRender();  <span class="comment">// 创建渲染器</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o first_sdl first_sdl.c `pkg-config --libs sdl2`</span></span><br></pre></td></tr></table></figure><p>SDL 渲染窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateRender() / SDL_DestoryRenderer();</span><br><span class="line">SDL_RenderClear();</span><br><span class="line">SDL_RenderPresent();</span><br></pre></td></tr></table></figure><h3 id="5-3-SDL-事件基本原理"><a href="#5-3-SDL-事件基本原理" class="headerlink" title="5.3 SDL 事件基本原理"></a>5.3 SDL 事件基本原理</h3><ul><li>SDL 将所有的事件都存放在一个队列中</li><li>所有对事件的操作，其实就是队列的操作</li></ul><p>SDL 事件种类：</p><ul><li>SDL_WindowEvent：窗口事件</li><li>SDL_KeyboardEvent：键盘事件</li><li>SDL_MouseMotionEvent：鼠标事件</li><li>自定义事件</li></ul><p>SDL 事件处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_PollEvent(); <span class="comment">// 轮询检测</span></span><br><span class="line">SDL_WaitEvent(); <span class="comment">// 常用的方式</span></span><br><span class="line">SDL_WaitEventTimeout();</span><br></pre></td></tr></table></figure><h3 id="5-4-文理渲染"><a href="#5-4-文理渲染" class="headerlink" title="5.4 文理渲染"></a>5.4 文理渲染</h3><p>SDL 渲染基本原理：</p><img src="/images/imageFFmpeg/SDL渲染基本原理.png"><p>SDL 文理相关 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateTexture();</span><br><span class="line">- format: YUV, RGB</span><br><span class="line">- access: Texture 类型， Target， Stream</span><br><span class="line"></span><br><span class="line">SDL_DestroyTexture();</span><br></pre></td></tr></table></figure><p>SDL 渲染相关 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_SetRenderTarget();</span><br><span class="line">SDL_RenderClear();</span><br><span class="line">SDL_RenderCopy();</span><br><span class="line">SDL_RenderPresent();</span><br></pre></td></tr></table></figure><h3 id="5-5-实战-YUV-视频播放器"><a href="#5-5-实战-YUV-视频播放器" class="headerlink" title="5.5 [实战] YUV 视频播放器"></a>5.5 [实战] YUV 视频播放器</h3><p>创建线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateThread();</span><br><span class="line">- fn: 线程执行函数</span><br><span class="line">- name: 线程名</span><br><span class="line">- data: 执行函数参数</span><br></pre></td></tr></table></figure><p>SDL 更新文理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_UpdateTexture();</span><br><span class="line">SDL_UpdateYUVTexture();</span><br></pre></td></tr></table></figure><h3 id="5-6-SDL-播放音频"><a href="#5-6-SDL-播放音频" class="headerlink" title="5.6 SDL 播放音频"></a>5.6 SDL 播放音频</h3><p>播放音频基本流程：</p><img src="/images/imageFFmpeg/播放音频基本流程.png"><p>播放音频的基本原则：</p><ul><li>声卡向你要数据而不是你主动推给声卡</li><li>数据的多少由音频参数决定的</li></ul><p>SDL 音频 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_OpenAudio() / SDL_CloseAudio();</span><br><span class="line">SDL_PauseAudio();</span><br><span class="line">SDL_MixAudio();</span><br></pre></td></tr></table></figure><h3 id="5-7-实现-PCM-播放器"><a href="#5-7-实现-PCM-播放器" class="headerlink" title="5.7 实现 PCM 播放器"></a>5.7 实现 PCM 播放器</h3><p>TODO</p><h2 id="6-最简单的播放器"><a href="#6-最简单的播放器" class="headerlink" title="6. 最简单的播放器"></a>6. 最简单的播放器</h2><ul><li>该播放器只实现视频播放</li><li>将 FFmpeg 与 SDL 结合到一起</li><li>通过 FFmpeg 解码视频数据</li><li>通过 SDL 进行渲染</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o player2 player2.c `pkg-config --cflags --libs sdl2 libavformat libavutil libswscale libavcodec libswresample`</span></span><br></pre></td></tr></table></figure><p>最简单的播放器之二：</p><ul><li>可以同时播放音频与视频</li><li>使用队列存放音频包</li></ul><h3 id="6-1-多线程与锁"><a href="#6-1-多线程与锁" class="headerlink" title="6.1 多线程与锁"></a>6.1 多线程与锁</h3><p>为什么要用多线程：</p><ul><li>多线程的好处</li><li>多线程带来的问题</li></ul><p>线程的互斥与同步：</p><ul><li><p>互斥</p></li><li><p>同步</p><p>大的任务分为很多小任务通过信号协调</p></li></ul><p>锁与信号量：</p><ul><li>锁的种类</li><li>通过信号进行同步</li></ul><p>锁的中种类：</p><ul><li>读写锁</li><li>自旋锁</li><li>可重入锁</li></ul><p>SDL 线程的创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateThread();</span><br><span class="line">SDL_WaitThread();</span><br></pre></td></tr></table></figure><p>SDL 锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateMutex() / SDL_DestroyMutex();  <span class="comment">// 创建互斥量</span></span><br><span class="line">SDL_LockMutex() / SDL_UnlockMutex(); <span class="comment">// 锁互斥量于解锁互斥量</span></span><br></pre></td></tr></table></figure><p>SDL 条件变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateCond() / SDL_DestroyCond();</span><br><span class="line">SDL_CondWait() / SDL_CondSignal();</span><br></pre></td></tr></table></figure><h3 id="6-2-锁与条件变量的使用"><a href="#6-2-锁与条件变量的使用" class="headerlink" title="6.2 锁与条件变量的使用"></a>6.2 锁与条件变量的使用</h3><p>TODO</p><h3 id="6-3-播放器线程模型"><a href="#6-3-播放器线程模型" class="headerlink" title="6.3 播放器线程模型"></a>6.3 播放器线程模型</h3><img src="/images/imageFFmpeg/播放器线程模型.png"><h3 id="6-4-线程的退出机制"><a href="#6-4-线程的退出机制" class="headerlink" title="6.4 线程的退出机制"></a>6.4 线程的退出机制</h3><ul><li>主线程接收到退出事件</li><li>解复用线程在循环分流时对 quit 进行判断</li><li>视频解码线程从视频流队列中取包时对 quit 进行判断</li><li>音视解码从音频流队列中取包时对 quit 进行判断</li><li>音视循环解码时对 quit 进行判断</li><li>在收到信号变量消息时对 quit 进行判断</li></ul><h3 id="6-5-音视频同步"><a href="#6-5-音视频同步" class="headerlink" title="6.5 音视频同步"></a>6.5 音视频同步</h3><p>时间戳：</p><ul><li>PTS：Presentation timestamp  渲染时间戳</li><li>DTS：Decoding timestamp 解码时间戳</li><li>I（intra）/ B（bidirectional）/ P（predicted）帧</li></ul><p>时间戳顺序：</p><ul><li>实际帧顺序：I B B P</li><li>存放帧顺序：I P B B</li><li>解码时间戳：1 4 2 3</li><li>展示时间戳：1 2 3 4</li></ul><p>从哪儿获得 PTS：</p><ul><li>AVPacket 中的 PTS</li><li>AVFrame 中的 PTS</li><li>av_frame_get_best_effort_timestamp()</li></ul><p>时间基：</p><ul><li>tbr：帧率</li><li>tbn：time base of stream 流的时间基</li><li>tbc：time base of codec 解码的时间基</li></ul><p>计算当前帧的 PTS：</p><ul><li><code>PTS = PTS * av_q2d(video_stream-&gt;time_base)</code></li><li><code>av_q2d(AVRotional a){ return a.num / (double)a.den; }</code></li></ul><p>计算下一帧的 PTS：</p><ul><li>video_clock：预测的下一帧视频的 PTS</li><li>frame_delay：1/tbr</li><li>audio_clock：音频当前播放的时间戳</li></ul><p>音视频同步方式：</p><ul><li>视频同步到音频</li><li>音频同步到视频</li><li>音频和视频都同步到系统时钟  </li></ul><p>视频播放的基本思路：</p><ul><li>一般的做法，展示第一帧视频帧后，获得要显示的下一个视频帧的 PTS，然后设置一个定时器，当定时器超时时后，刷新新的视屏帧，如此反复操作。</li></ul><details><summary>最简单的播放器：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compatibility with newer API</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> av_frame_free avcodec_free_frame</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000 <span class="comment">//channels(2) * data_size(2) * sample_rate(48000)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_AUDIO_MASTER <span class="comment">//AV_SYNC_VIDEO_MASTER</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span></span><br><span class="line">AVPacketList *first_pkt, *last_pkt;</span><br><span class="line">    <span class="keyword">int</span> nb_packets;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    SDL_mutex *mutex;</span><br><span class="line">    SDL_cond *cond;</span><br><span class="line">&#125; PacketQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoPicture</span> &#123;</span></span><br><span class="line">    AVPicture *bmp;</span><br><span class="line">    <span class="keyword">int</span> width, height; <span class="comment">/* source height &amp; width */</span></span><br><span class="line">    <span class="keyword">int</span> allocated;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">&#125; VideoPicture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoState</span> &#123;</span></span><br><span class="line">    <span class="comment">//multi-media file</span></span><br><span class="line">    <span class="keyword">char</span>            filename[<span class="number">1024</span>];</span><br><span class="line">    AVFormatContext *pFormatCtx;</span><br><span class="line">    <span class="keyword">int</span>             videoStream, audioStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sync</span></span><br><span class="line">    <span class="keyword">int</span>             av_sync_type;</span><br><span class="line">    <span class="keyword">double</span>          external_clock; <span class="comment">/* external clock base */</span></span><br><span class="line">    <span class="keyword">int64_t</span>         external_clock_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>          audio_diff_cum; <span class="comment">/* used for AV difference average computation */</span></span><br><span class="line">    <span class="keyword">double</span>          audio_diff_avg_coef;</span><br><span class="line">    <span class="keyword">double</span>          audio_diff_threshold;</span><br><span class="line">    <span class="keyword">int</span>             audio_diff_avg_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>          audio_clock;</span><br><span class="line">    <span class="keyword">double</span>          frame_timer;</span><br><span class="line">    <span class="keyword">double</span>          frame_last_pts;</span><br><span class="line">    <span class="keyword">double</span>          frame_last_delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>          video_clock; <span class="comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span></span><br><span class="line">    <span class="keyword">double</span>          video_current_pts; <span class="comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span></span><br><span class="line">    <span class="keyword">int64_t</span>         video_current_pts_time;  <span class="comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//audio</span></span><br><span class="line">    AVStream        *audio_st;</span><br><span class="line">    AVCodecContext  *audio_ctx;</span><br><span class="line">    PacketQueue     audioq;</span><br><span class="line">    <span class="keyword">uint8_t</span>         audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="number">3</span>) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    audio_buf_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    audio_buf_index;</span><br><span class="line">    AVFrame         audio_frame;</span><br><span class="line">    AVPacket        audio_pkt;</span><br><span class="line">    <span class="keyword">uint8_t</span>         *audio_pkt_data;</span><br><span class="line">    <span class="keyword">int</span>             audio_pkt_size;</span><br><span class="line">    <span class="keyword">int</span>             audio_hw_buf_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//video</span></span><br><span class="line">    AVStream        *video_st;</span><br><span class="line">    AVCodecContext  *video_ctx;</span><br><span class="line">    PacketQueue     videoq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">video_sws_ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_swr_ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];</span><br><span class="line">    <span class="keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;</span><br><span class="line">    SDL_mutex       *pictq_mutex;</span><br><span class="line">    SDL_cond        *pictq_cond;</span><br><span class="line"></span><br><span class="line">    SDL_Thread      *parse_tid;</span><br><span class="line">    SDL_Thread      *video_tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>             quit;</span><br><span class="line">&#125; VideoState;</span><br><span class="line"></span><br><span class="line">SDL_mutex    *text_mutex;</span><br><span class="line">SDL_Window   *win = <span class="literal">NULL</span>;</span><br><span class="line">SDL_Renderer *renderer;</span><br><span class="line">SDL_Texture  *texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    AV_SYNC_AUDIO_MASTER,</span><br><span class="line">    AV_SYNC_VIDEO_MASTER,</span><br><span class="line">    AV_SYNC_EXTERNAL_MASTER,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE *yuvfd = <span class="literal">NULL</span>;</span><br><span class="line">FILE *audiofd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Since we only have one decoding thread, the Big Struct</span></span><br><span class="line"><span class="comment">   can be global in case we need it. */</span></span><br><span class="line">VideoState *global_video_state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_queue_init</span><span class="params">(PacketQueue *q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span>(PacketQueue));</span><br><span class="line">    q-&gt;mutex = SDL_CreateMutex();</span><br><span class="line">    q-&gt;cond = SDL_CreateCond();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">packet_queue_put</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span> </span>&#123;</span><br><span class="line">    AVPacketList *pkt1;</span><br><span class="line">    <span class="keyword">if</span>(av_dup_packet(pkt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pkt1 = av_malloc(<span class="keyword">sizeof</span>(AVPacketList));</span><br><span class="line">    <span class="keyword">if</span> (!pkt1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pkt1-&gt;pkt = *pkt;</span><br><span class="line">    pkt1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    SDL_LockMutex(q-&gt;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;last_pkt)</span><br><span class="line">        q-&gt;first_pkt = pkt1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q-&gt;last_pkt-&gt;next = pkt1;</span><br><span class="line">    q-&gt;last_pkt = pkt1;</span><br><span class="line">    q-&gt;nb_packets++;</span><br><span class="line">    q-&gt;size += pkt1-&gt;pkt.size;</span><br><span class="line">    </span><br><span class="line">    SDL_CondSignal(q-&gt;cond);</span><br><span class="line">    SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVPacketList *pkt1;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    SDL_LockMutex(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(global_video_state-&gt;quit) &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt1 = q-&gt;first_pkt;</span><br><span class="line">        <span class="keyword">if</span> (pkt1) &#123;</span><br><span class="line">            q-&gt;first_pkt = pkt1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!q-&gt;first_pkt)</span><br><span class="line">                q-&gt;last_pkt = <span class="literal">NULL</span>;</span><br><span class="line">            q-&gt;nb_packets--;</span><br><span class="line">            q-&gt;size -= pkt1-&gt;pkt.size;</span><br><span class="line">            *pkt = pkt1-&gt;pkt;</span><br><span class="line">            av_free(pkt1);</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SDL_CondWait(q-&gt;cond, q-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_audio_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">    <span class="keyword">int</span> hw_buf_size, bytes_per_sec, n;</span><br><span class="line"></span><br><span class="line">    pts = is-&gt;audio_clock; <span class="comment">/* maintained in the audio thread */</span></span><br><span class="line">    hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">    bytes_per_sec = <span class="number">0</span>;</span><br><span class="line">    n = is-&gt;audio_ctx-&gt;channels * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;audio_st) &#123;</span><br><span class="line">        bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bytes_per_sec) &#123;</span><br><span class="line">        pts -= (<span class="keyword">double</span>)hw_buf_size / bytes_per_sec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_video_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> delta;</span><br><span class="line">    delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="keyword">return</span> is-&gt;video_current_pts + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_external_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_master_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> get_video_clock(is);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> get_audio_clock(is);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get_external_clock(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add or subtract samples to get a better sync, return new</span></span><br><span class="line"><span class="comment">   audio buffer size */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">synchronize_audio</span><span class="params">(VideoState *is, <span class="keyword">short</span> *samples,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> samples_size, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> ref_clock;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">        <span class="keyword">double</span> diff, avg_diff;</span><br><span class="line">        <span class="keyword">int</span> wanted_size, min_size, max_size <span class="comment">/*, nb_samples */</span>;</span><br><span class="line"></span><br><span class="line">        ref_clock = get_master_clock(is);</span><br><span class="line">        diff = get_audio_clock(is) - ref_clock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// accumulate the diffs</span></span><br><span class="line">            is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef</span><br><span class="line">                * is-&gt;audio_diff_cum;</span><br><span class="line">            <span class="keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) &#123;</span><br><span class="line">                is-&gt;audio_diff_avg_count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                avg_diff = is-&gt;audio_diff_cum * (<span class="number">1.0</span> - is-&gt;audio_diff_avg_coef);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123;</span><br><span class="line">                    wanted_size = samples_size + ((<span class="keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);</span><br><span class="line">                    min_size = samples_size * ((<span class="number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>);</span><br><span class="line">                    max_size = samples_size * ((<span class="number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">if</span>(wanted_size &lt; min_size) &#123;</span><br><span class="line">                        wanted_size = min_size;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wanted_size &gt; max_size) &#123;</span><br><span class="line">                        wanted_size = max_size;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(wanted_size &lt; samples_size) &#123;</span><br><span class="line">                        <span class="comment">/* remove samples */</span></span><br><span class="line">                        samples_size = wanted_size;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wanted_size &gt; samples_size) &#123;</span><br><span class="line">                        <span class="keyword">uint8_t</span> *samples_end, *q;</span><br><span class="line">                        <span class="keyword">int</span> nb;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* add samples by copying final sample*/</span></span><br><span class="line">                        nb = (samples_size - wanted_size);</span><br><span class="line">                        samples_end = (<span class="keyword">uint8_t</span> *)samples + samples_size - n;</span><br><span class="line">                        q = samples_end + n;</span><br><span class="line">                        <span class="keyword">while</span>(nb &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">memcpy</span>(q, samples_end, n);</span><br><span class="line">                            q += n;</span><br><span class="line">                            nb -= n;</span><br><span class="line">                        &#125;</span><br><span class="line">                        samples_size = wanted_size;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* difference is TOO big; reset diff stuff */</span></span><br><span class="line">            is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">            is-&gt;audio_diff_cum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> samples_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">audio_decode_frame</span><span class="params">(VideoState *is, <span class="keyword">uint8_t</span> *audio_buf, </span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> buf_size, <span class="keyword">double</span> *pts_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1, data_size = <span class="number">0</span>;</span><br><span class="line">    AVPacket *pkt = &amp;is-&gt;audio_pkt;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">            len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);</span><br><span class="line">            <span class="keyword">if</span>(len1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* if error, skip frame */</span></span><br><span class="line">                is-&gt;audio_pkt_size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data_size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(got_frame) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">data_size = av_samples_get_buffer_size(NULL, </span></span><br><span class="line"><span class="comment">       is-&gt;audio_ctx-&gt;channels,</span></span><br><span class="line"><span class="comment">       is-&gt;audio_frame.nb_samples,</span></span><br><span class="line"><span class="comment">       is-&gt;audio_ctx-&gt;sample_fmt,</span></span><br><span class="line"><span class="comment">       1);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">                data_size = <span class="number">2</span> * is-&gt;audio_frame.nb_samples * <span class="number">2</span>;</span><br><span class="line">                assert(data_size &lt;= buf_size);</span><br><span class="line"></span><br><span class="line">                swr_convert(is-&gt;audio_swr_ctx,</span><br><span class="line">                            &amp;audio_buf,</span><br><span class="line">                            MAX_AUDIO_FRAME_SIZE*<span class="number">3</span>/<span class="number">2</span>,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)is-&gt;audio_frame.data,</span><br><span class="line">                            is-&gt;audio_frame.nb_samples);</span><br><span class="line"></span><br><span class="line">                fwrite(audio_buf, <span class="number">1</span>, data_size, audiofd);</span><br><span class="line">                <span class="comment">//memcpy(audio_buf, is-&gt;audio_frame.data[0], data_size);</span></span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_pkt_data += len1;</span><br><span class="line">            is-&gt;audio_pkt_size -= len1;</span><br><span class="line">            <span class="keyword">if</span>(data_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* No data yet, get more frames */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pts = is-&gt;audio_clock;</span><br><span class="line">            *pts_ptr = pts;</span><br><span class="line">            n = <span class="number">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class="line">            is-&gt;audio_clock += (<span class="keyword">double</span>)data_size /</span><br><span class="line">                (<span class="keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class="line">            <span class="comment">/* We have data, return it and come back for more later */</span></span><br><span class="line">            <span class="keyword">return</span> data_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pkt-&gt;data)</span><br><span class="line">            av_free_packet(pkt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* next packet */</span></span><br><span class="line">        <span class="keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        is-&gt;audio_pkt_data = pkt-&gt;data;</span><br><span class="line">        is-&gt;audio_pkt_size = pkt-&gt;size;</span><br><span class="line">        <span class="comment">/* if update, update the audio clock w/pts */</span></span><br><span class="line">        <span class="keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">audio_callback</span><span class="params">(<span class="keyword">void</span> *userdata, Uint8 *stream, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *)userdata;</span><br><span class="line">    <span class="keyword">int</span> len1, audio_size;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">            <span class="comment">/* We have already sent all our data; get more */</span></span><br><span class="line">            audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);</span><br><span class="line">            <span class="keyword">if</span>(audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* If error, output silence */</span></span><br><span class="line">                is-&gt;audio_buf_size = <span class="number">1024</span> * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">memset</span>(is-&gt;audio_buf, <span class="number">0</span>, is-&gt;audio_buf_size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                audio_size = synchronize_audio(is, (<span class="keyword">int16_t</span> *)is-&gt;audio_buf, audio_size, pts);</span><br><span class="line">                is-&gt;audio_buf_size = audio_size;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len)</span><br><span class="line">            len1 = len;</span><br><span class="line">        SDL_MixAudio(stream,(<span class="keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME);</span><br><span class="line">        <span class="comment">//memcpy(stream, (uint8_t *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span></span><br><span class="line">        len -= len1;</span><br><span class="line">        stream += len1;</span><br><span class="line">        is-&gt;audio_buf_index += len1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Uint32 <span class="title">sdl_refresh_timer_cb</span><span class="params">(Uint32 interval, <span class="keyword">void</span> *opaque)</span> </span>&#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    event.type = FF_REFRESH_EVENT;</span><br><span class="line">    event.user.data1 = opaque;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 0 means stop timer */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* schedule a video refresh in 'delay' ms */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_refresh</span><span class="params">(VideoState *is, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">    SDL_AddTimer(delay, sdl_refresh_timer_cb, is);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">video_display</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    SDL_Rect rect;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    <span class="keyword">float</span> aspect_ratio;</span><br><span class="line">    <span class="keyword">int</span> w, h, x, y;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line">    <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line"></span><br><span class="line">        SDL_UpdateYUVTexture(texture, <span class="literal">NULL</span>, </span><br><span class="line">                             vp-&gt;bmp-&gt;data[<span class="number">0</span>], vp-&gt;bmp-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                             vp-&gt;bmp-&gt;data[<span class="number">1</span>], vp-&gt;bmp-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                             vp-&gt;bmp-&gt;data[<span class="number">2</span>], vp-&gt;bmp-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        rect.x = <span class="number">0</span>;</span><br><span class="line">        rect.y = <span class="number">0</span>;</span><br><span class="line">        rect.w = is-&gt;video_ctx-&gt;width;</span><br><span class="line">        rect.h = is-&gt;video_ctx-&gt;height;</span><br><span class="line">        SDL_LockMutex(text_mutex);</span><br><span class="line">        SDL_RenderClear( renderer );</span><br><span class="line">        SDL_RenderCopy( renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">        SDL_RenderPresent( renderer );</span><br><span class="line">        SDL_UnlockMutex(text_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">video_refresh_timer</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *)userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    <span class="keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;video_st) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;pictq_size == <span class="number">0</span>) &#123;</span><br><span class="line">            schedule_refresh(is, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//fprintf(stderr, "no picture in the queue!!!\n");</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//fprintf(stderr, "get picture from queue!!!\n");</span></span><br><span class="line">            vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line"></span><br><span class="line">            is-&gt;video_current_pts = vp-&gt;pts;</span><br><span class="line">            is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line">            delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="comment">/* the pts from last time */</span></span><br><span class="line">            <span class="keyword">if</span>(delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="comment">/* if incorrect delay, use previous one */</span></span><br><span class="line">                delay = is-&gt;frame_last_delay;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* save for next time */</span></span><br><span class="line">            is-&gt;frame_last_delay = delay;</span><br><span class="line">            is-&gt;frame_last_pts = vp-&gt;pts;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update delay to sync to audio if not master source */</span></span><br><span class="line">            <span class="keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">                ref_clock = get_master_clock(is);</span><br><span class="line">                diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Skip or repeat the frame. Take delay into account</span></span><br><span class="line"><span class="comment">       FFPlay still doesn't "know if this is the best guess." */</span></span><br><span class="line">                sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(diff &lt;= -sync_threshold) &#123;</span><br><span class="line">                        delay = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(diff &gt;= sync_threshold) &#123;</span><br><span class="line">                        delay = <span class="number">2</span> * delay;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;frame_timer += delay;</span><br><span class="line">            <span class="comment">/* computer the REAL delay */</span></span><br><span class="line">            actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line">            <span class="keyword">if</span>(actual_delay &lt; <span class="number">0.010</span>) &#123;</span><br><span class="line">                <span class="comment">/* Really it should skip the picture instead */</span></span><br><span class="line">                actual_delay = <span class="number">0.010</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            schedule_refresh(is, (<span class="keyword">int</span>)(actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* show the picture! */</span></span><br><span class="line">            video_display(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update queue for next picture! */</span></span><br><span class="line">            <span class="keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">                is-&gt;pictq_rindex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">            is-&gt;pictq_size--;</span><br><span class="line">            SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">            SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        schedule_refresh(is, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc_picture</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *)userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line"></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line">    <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line">        <span class="comment">// we already have one make another, bigger/smaller</span></span><br><span class="line">        avpicture_free(vp-&gt;bmp);</span><br><span class="line">        <span class="built_in">free</span>(vp-&gt;bmp);</span><br><span class="line">        vp-&gt;bmp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a place to put our YUV image on that screen</span></span><br><span class="line">    SDL_LockMutex(text_mutex);</span><br><span class="line"></span><br><span class="line">    vp-&gt;bmp = (AVPicture*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVPicture));</span><br><span class="line">    ret = avpicture_alloc(vp-&gt;bmp, AV_PIX_FMT_YUV420P, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate temporary picture: %s\n"</span>, av_err2str(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_UnlockMutex(text_mutex);</span><br><span class="line"></span><br><span class="line">    vp-&gt;width = is-&gt;video_ctx-&gt;width;</span><br><span class="line">    vp-&gt;height = is-&gt;video_ctx-&gt;height;</span><br><span class="line">    vp-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_picture</span><span class="params">(VideoState *is, AVFrame *pFrame, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until we have space for a new pic */</span></span><br><span class="line">    SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    <span class="keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;</span><br><span class="line">          !is-&gt;quit) &#123;</span><br><span class="line">        SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;quit)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// windex is set to 0 initially</span></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate or resize the buffer! */</span></span><br><span class="line">    <span class="keyword">if</span>(!vp-&gt;bmp ||</span><br><span class="line">       vp-&gt;width != is-&gt;video_ctx-&gt;width ||</span><br><span class="line">       vp-&gt;height != is-&gt;video_ctx-&gt;height) &#123;</span><br><span class="line"></span><br><span class="line">        vp-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">        alloc_picture(is);</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have a place to put our picture on the queue */</span></span><br><span class="line">    <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line">        vp-&gt;pts = pts;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert the image into YUV format that SDL uses</span></span><br><span class="line">        sws_scale(is-&gt;video_sws_ctx, (<span class="keyword">uint8_t</span> <span class="keyword">const</span> * <span class="keyword">const</span> *)pFrame-&gt;data,</span><br><span class="line">                  pFrame-&gt;linesize, <span class="number">0</span>, is-&gt;video_ctx-&gt;height,</span><br><span class="line">                  vp-&gt;bmp-&gt;data, vp-&gt;bmp-&gt;linesize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* now we inform our display thread that we have a pic ready */</span></span><br><span class="line">        <span class="keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">            is-&gt;pictq_windex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        is-&gt;pictq_size++;</span><br><span class="line">        SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">synchronize_video</span><span class="params">(VideoState *is, AVFrame *src_frame, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> frame_delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pts != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* if we have pts, set video clock to it */</span></span><br><span class="line">        is-&gt;video_clock = pts;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* if we aren't given a pts, set it to the clock */</span></span><br><span class="line">        pts = is-&gt;video_clock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* update the video clock */</span></span><br><span class="line">    frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);</span><br><span class="line">    <span class="comment">/* if we are repeating a frame, adjust clock accordingly */</span></span><br><span class="line">    frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="number">0.5</span>);</span><br><span class="line">    is-&gt;video_clock += frame_delay;</span><br><span class="line">    <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode_video_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *)arg;</span><br><span class="line">    AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line">    <span class="keyword">int</span> frameFinished;</span><br><span class="line">    AVFrame *pFrame;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// means we quit getting packets</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decode video frame</span></span><br><span class="line">        avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) != AV_NOPTS_VALUE) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Did we get a video frame?</span></span><br><span class="line">        <span class="keyword">if</span>(frameFinished) &#123;</span><br><span class="line">            pts = synchronize_video(is, pFrame, pts);</span><br><span class="line">            <span class="keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stream_component_open</span><span class="params">(VideoState *is, <span class="keyword">int</span> stream_index)</span> </span>&#123;</span><br><span class="line">    AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;</span><br><span class="line">    AVCodecContext *codecCtx = <span class="literal">NULL</span>;</span><br><span class="line">    AVCodec *codec = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_AudioSpec wanted_spec, spec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stream_index &lt; <span class="number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codecCtx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = avcodec_parameters_to_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codecpar);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span>(!codec) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unsupported codec!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">        <span class="comment">// Set audio settings from codec info</span></span><br><span class="line">        wanted_spec.freq = codecCtx-&gt;sample_rate;</span><br><span class="line">        wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">        wanted_spec.channels = <span class="number">2</span>;<span class="comment">//codecCtx-&gt;channels;</span></span><br><span class="line">        wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">        wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</span><br><span class="line">        wanted_spec.callback = audio_callback;</span><br><span class="line">        wanted_spec.userdata = is;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"wanted spec: channels:%d, sample_fmt:%d, sample_rate:%d \n"</span>,</span><br><span class="line">                <span class="number">2</span>, AUDIO_S16SYS, codecCtx-&gt;sample_rate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        is-&gt;audio_hw_buf_size = spec.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unsupported codec!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(codecCtx-&gt;codec_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            is-&gt;audioStream = stream_index;</span><br><span class="line">            is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">            is-&gt;audio_ctx = codecCtx;</span><br><span class="line">            is-&gt;audio_buf_size = <span class="number">0</span>;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="number">0</span>, <span class="keyword">sizeof</span>(is-&gt;audio_pkt));</span><br><span class="line">            packet_queue_init(&amp;is-&gt;audioq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Out Audio Param</span></span><br><span class="line">            <span class="keyword">uint64_t</span> out_channel_layout=AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//AAC:1024  MP3:1152</span></span><br><span class="line">            <span class="keyword">int</span> out_nb_samples= is-&gt;audio_ctx-&gt;frame_size;</span><br><span class="line">            <span class="comment">//AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> out_sample_rate=is-&gt;audio_ctx-&gt;sample_rate;</span><br><span class="line">            <span class="keyword">int</span> out_channels=av_get_channel_layout_nb_channels(out_channel_layout);</span><br><span class="line">            <span class="comment">//Out Buffer Size</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int out_buffer_size=av_samples_get_buffer_size(NULL,</span></span><br><span class="line"><span class="comment">                                                   out_channels,</span></span><br><span class="line"><span class="comment">                                                   out_nb_samples,</span></span><br><span class="line"><span class="comment">                                                   AV_SAMPLE_FMT_S16,</span></span><br><span class="line"><span class="comment">                                                   1);</span></span><br><span class="line"><span class="comment">                                                   */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//uint8_t *out_buffer=(uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE*2);</span></span><br><span class="line">            <span class="keyword">int64_t</span> in_channel_layout=av_get_default_channel_layout(is-&gt;audio_ctx-&gt;channels);</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_convert_ctx</span>;</span></span><br><span class="line">            audio_convert_ctx = swr_alloc();</span><br><span class="line">            swr_alloc_set_opts(audio_convert_ctx,</span><br><span class="line">                               out_channel_layout,</span><br><span class="line">                               AV_SAMPLE_FMT_S16,</span><br><span class="line">                               out_sample_rate,</span><br><span class="line">                               in_channel_layout,</span><br><span class="line">                               is-&gt;audio_ctx-&gt;sample_fmt,</span><br><span class="line">                               is-&gt;audio_ctx-&gt;sample_rate,</span><br><span class="line">                               <span class="number">0</span>,</span><br><span class="line">                               <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"swr opts: out_channel_layout:%lld, out_sample_fmt:%d, out_sample_rate:%d, in_channel_layout:%lld, in_sample_fmt:%d, in_sample_rate:%d"</span>,</span><br><span class="line">                    out_channel_layout, </span><br><span class="line">                    AV_SAMPLE_FMT_S16, </span><br><span class="line">                    out_sample_rate, </span><br><span class="line">                    in_channel_layout, </span><br><span class="line">                    is-&gt;audio_ctx-&gt;sample_fmt, </span><br><span class="line">                    is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class="line">            swr_init(audio_convert_ctx);</span><br><span class="line">            is-&gt;audio_swr_ctx = audio_convert_ctx;</span><br><span class="line"></span><br><span class="line">            SDL_PauseAudio(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            is-&gt;videoStream = stream_index;</span><br><span class="line">            is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">            is-&gt;video_ctx = codecCtx;</span><br><span class="line"></span><br><span class="line">            is-&gt;frame_timer = (<span class="keyword">double</span>)av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">            is-&gt;frame_last_delay = <span class="number">40e-3</span>;</span><br><span class="line">            is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line"></span><br><span class="line">            packet_queue_init(&amp;is-&gt;videoq);</span><br><span class="line">            is-&gt;video_sws_ctx = sws_getContext(</span><br><span class="line">                is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">                        is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,</span><br><span class="line">                        is-&gt;video_ctx-&gt;height, AV_PIX_FMT_YUV420P,</span><br><span class="line">                        SWS_BILINEAR, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            is-&gt;video_tid = SDL_CreateThread(decode_video_thread, <span class="string">"decode_video_thread"</span>, is);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">demux_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err_code;</span><br><span class="line">    <span class="keyword">char</span> errors[<span class="number">1024</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *)arg;</span><br><span class="line">    AVFormatContext *pFormatCtx;</span><br><span class="line">    AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> video_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> audio_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    is-&gt;videoStream=<span class="number">-1</span>;</span><br><span class="line">    is-&gt;audioStream=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    global_video_state = is;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open input file, and allocate format context */</span></span><br><span class="line">    <span class="keyword">if</span> ((err_code=avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_strerror(err_code, errors, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open source file %s, %d(%s)\n"</span>, is-&gt;filename, err_code, errors);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    is-&gt;pFormatCtx = pFormatCtx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve stream information</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Couldn't find stream information</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dump information about file onto standard error</span></span><br><span class="line">    av_dump_format(pFormatCtx, <span class="number">0</span>, is-&gt;filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the first video stream</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">           video_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            video_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">           audio_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            audio_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(audio_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, audio_index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(video_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, video_index);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;videoStream &lt; <span class="number">0</span> || is-&gt;audioStream &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: could not open codecs\n"</span>, is-&gt;filename);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//creat window from SDL</span></span><br><span class="line">    win = SDL_CreateWindow(<span class="string">"Media Player"</span>,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">                           SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);</span><br><span class="line">    <span class="keyword">if</span>(!win) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SDL: could not set video mode - exiting\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer = SDL_CreateRenderer(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IYUV: Y + U + V  (3 planes)</span></span><br><span class="line">    <span class="comment">//YV12: Y + V + U  (3 planes)</span></span><br><span class="line">    Uint32 pixformat= SDL_PIXELFORMAT_IYUV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create texture for render</span></span><br><span class="line">    texture = SDL_CreateTexture(renderer,</span><br><span class="line">                                pixformat,</span><br><span class="line">                                SDL_TEXTUREACCESS_STREAMING,</span><br><span class="line">                                is-&gt;video_ctx-&gt;width,</span><br><span class="line">                                is-&gt;video_ctx-&gt;height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main decode loop</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// seek stuff goes here</span></span><br><span class="line">        <span class="keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||</span><br><span class="line">           is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) &#123;</span><br><span class="line">            SDL_Delay(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="number">0</span>) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">100</span>); <span class="comment">/* no error; wait for user input */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Is this a packet from the video stream?</span></span><br><span class="line">        <span class="keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            av_free_packet(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* all done - wait for it */</span></span><br><span class="line">    <span class="keyword">while</span>(!is-&gt;quit) &#123;</span><br><span class="line">        SDL_Delay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        SDL_Event event;</span><br><span class="line">        event.type = FF_QUIT_EVENT;</span><br><span class="line">        event.user.data1 = is;</span><br><span class="line">        SDL_PushEvent(&amp;event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    SDL_Event       event;</span><br><span class="line">    VideoState      *is;</span><br><span class="line"></span><br><span class="line">    is = av_mallocz(<span class="keyword">sizeof</span>(VideoState));</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: test &lt;file&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yuvfd = fopen(<span class="string">"testout.yuv"</span>, <span class="string">"wb+"</span>);</span><br><span class="line">    audiofd = fopen(<span class="string">"testout.pcm"</span>, <span class="string">"wb+"</span>);</span><br><span class="line">    <span class="comment">// Register all formats and codecs</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    text_mutex = SDL_CreateMutex();</span><br><span class="line">    av_strlcpy(is-&gt;filename, argv[<span class="number">1</span>], <span class="keyword">sizeof</span>(is-&gt;filename));</span><br><span class="line">    is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class="line">    is-&gt;pictq_cond = SDL_CreateCond();</span><br><span class="line"></span><br><span class="line">    schedule_refresh(is, <span class="number">40</span>);</span><br><span class="line">    is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;</span><br><span class="line">    is-&gt;parse_tid = SDL_CreateThread(demux_thread,<span class="string">"demux_thread"</span>, is);</span><br><span class="line">    <span class="keyword">if</span>(!is-&gt;parse_tid) &#123;</span><br><span class="line">        av_free(is);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        SDL_WaitEvent(&amp;event);</span><br><span class="line">        <span class="keyword">switch</span>(event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> FF_QUIT_EVENT:</span><br><span class="line">            <span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">                is-&gt;quit = <span class="number">1</span>;</span><br><span class="line">                SDL_Quit();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FF_REFRESH_EVENT:</span><br><span class="line">                video_refresh_timer(event.user.data1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(yuvfd);</span><br><span class="line">    fclose(audiofd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="7-如何在-Android-下使用-FFmpeg"><a href="#7-如何在-Android-下使用-FFmpeg" class="headerlink" title="7. 如何在 Android 下使用 FFmpeg"></a>7. 如何在 Android 下使用 FFmpeg</h2><p>Android 架构：</p><img src="/images/imageFFmpeg/Android架构.png"><p>内容：</p><ul><li>Java 与 C 之间的相互调用</li><li>Android 下 FFmpeg 的编译</li><li>Android 下如何使用FFmpeg</li></ul><p>第一个 JNI 程序：</p><p>TODO</p><p>JNI 基本概念：</p><ul><li>JNIEnv</li><li>JavaVM  一个Android APP只有一个 JavaVM， 一个 JavaVM 可以有多个JNIEnv</li><li>线程  一个线程对应一个JNIEnv</li></ul><p>Java调用C/C++ 方法一：</p><ul><li><p>在Java层定义 native 关键字函数</p></li><li><p>方法一：在C/C++层创建</p><p>Java_packname_classname_methodname 函数</p></li></ul><p>Java调用C/C++方法二：</p><img src="/images/imageFFmpeg/java调用c方法二.png"><img src="/images/imageFFmpeg/注册Native方法的最佳时机.png"><p>什么是Signature：</p><ul><li>Java与C/C++ 相互调用时，表式函数参数的描述符</li><li>输入参数放在（）内，输出参数放在（）外</li><li>多个参数之间顺序存放，且用 “；” 分割</li></ul><img src="/images/imageFFmpeg/原始类型的Signature.png"><img src="/images/imageFFmpeg/类的Signature.png"> <img src="/images/imageFFmpeg/例子.png"><p>C/C++ 调用 Java 方法：</p><ul><li>FindClass</li><li>GetMethodID / GetFieldID</li><li>NewObject</li><li><code>Call&lt;TYPE&gt;Method / [G/S]et&lt;type&gt;Field</code></li></ul><h3 id="7-1-实战-Android-下的播放器"><a href="#7-1-实战-Android-下的播放器" class="headerlink" title="7.1 [实战] Android 下的播放器"></a>7.1 [实战] Android 下的播放器</h3><p>TODO</p><h2 id="8-IOS-下使用-FFmpeg"><a href="#8-IOS-下使用-FFmpeg" class="headerlink" title="8. IOS 下使用 FFmpeg"></a>8. IOS 下使用 FFmpeg</h2><p>TODO</p><h2 id="9-音视频进阶"><a href="#9-音视频进阶" class="headerlink" title="9. 音视频进阶"></a>9. 音视频进阶</h2><ul><li>FFmpeg Filter 的使用 </li><li>FFmpeg 裁剪与优化</li><li>视频渲染（OpenGL / Metal）</li><li>声音的特效</li><li>网络传输</li><li>Webrtc - 实时互动、直播、P2P音视频传输</li><li>AR技术</li><li>OpenCV</li></ul><p>行业痛点：</p><ul><li>回音消除</li><li>降噪</li><li>视频秒开</li><li>多人多视频实时互动</li><li>PC端/APP/网页实时视频互通</li><li>实时互动与大并发负载</li></ul><h2 id="FFmpeg音视频同步原理与实现"><a href="#FFmpeg音视频同步原理与实现" class="headerlink" title="FFmpeg音视频同步原理与实现"></a>FFmpeg音视频同步原理与实现</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaG95cy9hcmNoaXZlLzIwMTEvMDYvMDgvMjA3NTE1OS5odG1s" title="https://www.cnblogs.com/hoys/archive/2011/06/08/2075159.html">音视频同步解决方案<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy54bWwtZGF0YS5vcmcvR0RHWURYWEIvaHRtbC8yMDE3MDQxMS5odG0=" title="http://www.xml-data.org/GDGYDXXB/html/20170411.htm">一种基于FFMPEG的音视频同步算法<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="音视频同步原理"><a href="#音视频同步原理" class="headerlink" title="音视频同步原理"></a>音视频同步原理</h3><p>如果简单的按照音频的采样率与视频的帧率去播放，由于机器运行速度，解码效率等种种造成时间差异的因素影响，很难同步，音视频时间差将会呈现线性增长。所以要做音视频的同步，有三种方式：</p><p>参考一个外部时钟，将音频与视频同步至此时间。我首先想到这种方式，但是并不好，由于某些生物学的原理，人对声音的变化比较敏感，但是对视觉变化不太敏感。所以频繁的去调整声音的播放会有些刺耳或者杂音吧影响用户体验。（ps：顺便科普生物学知识，自我感觉好高大上_）。</p><ul><li>以视频为基准，音频去同步视频的时间。不采用，理由同上。</li><li>以音频为基准，视频去同步音频的时间。 所以这个办法了。</li></ul><p>所以，原理就是以音频时间为基准，判断视频快了还是慢了，从而调整视频速度。其实是一个动态的追赶与等待的过程。</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>音视频中都有 <code>DTS</code> 与 <code>PTS</code>。</p><ul><li>DTS ，Decoding Time Stamp，解码时间戳，告诉解码器packet的解码顺序。</li><li>PTS ，Presentation Time Stamp，显示时间戳，指示从packet中解码出来的数据的显示顺序。</li><li>音频中二者是相同的，但是视频由于B帧（双向预测）的存在，会造成解码顺序与显示顺序并不相同，也就是视频中 DTS 与 PTS 不一定相同。</li></ul><p>时间基 : 看 FFmpeg 源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVRational time_base;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* rational number numerator/denominator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> num; <span class="comment">///&lt; numerator</span></span><br><span class="line">   <span class="keyword">int</span> den; <span class="comment">///&lt; denominator</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><p>个人理解，其实就是 ffmpeg中 的用分数表示时间单位，num 为分子，den 为分母。并且 ffmpeg 提供了计算方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Convert rational to double.</span></span><br><span class="line"><span class="comment">* @param a rational to convert</span></span><br><span class="line"><span class="comment">* @return (double) a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">av_q2d</span><span class="params">(AVRational a)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a.num / (<span class="keyword">double</span>) a.den;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 视频中某帧的显示时间 计算方式为(单位为妙)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time = pts * av_q2d(time_base);</span><br></pre></td></tr></table></figure><h3 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h3><p><strong>音频部分</strong></p><p>clock 为音频的播放时长（从开始到当前的时间）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (packet-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    audio-&gt;clock = av_q2d(audio-&gt;time_base) * packet-&gt;pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后加上此 packet 中数据需要播放的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> time = datalen/((<span class="keyword">double</span>) <span class="number">44100</span> *<span class="number">2</span> * <span class="number">2</span>);</span><br><span class="line">audio-&gt;clock = audio-&gt;clock +time;</span><br></pre></td></tr></table></figure><p>datalen 为数据长度。采样率为 44100，采样位数为 16，通道数为 2。所以 数据长度 / 每秒字节数。</p><p>ps：此处计算方式不是很完美，有很多问题，回头研究在再补上。</p><p><strong>视频部分</strong></p><details><summary>先定义几个值：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>  last_play  <span class="comment">//上一帧的播放时间</span></span><br><span class="line">   ,play             <span class="comment">//当前帧的播放时间</span></span><br><span class="line">   , last_delay    <span class="comment">// 上一次播放视频的两帧视频间隔时间</span></span><br><span class="line">   ,delay         <span class="comment">//两帧视频间隔时间</span></span><br><span class="line">   ,audio_clock <span class="comment">//音频轨道 实际播放时间</span></span><br><span class="line">   ,diff   <span class="comment">//音频帧与视频帧相差时间</span></span><br><span class="line">   ,sync_threshold <span class="comment">//合理的范围</span></span><br><span class="line">   ,start_time  <span class="comment">//从第一帧开始的绝对时间</span></span><br><span class="line">   ,pts</span><br><span class="line">   ,actual_delay<span class="comment">//真正需要延迟时间</span></span><br><span class="line">   start_time = av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line"><span class="comment">//        获取pts</span></span><br><span class="line">       <span class="keyword">if</span> ((pts = av_frame_get_best_effort_timestamp(frame)) == AV_NOPTS_VALUE) &#123;</span><br><span class="line">           pts = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       play = pts * av_q2d(vedio-&gt;time_base);</span><br><span class="line"><span class="comment">//        纠正时间</span></span><br><span class="line">       play = vedio-&gt;synchronize(frame, play);</span><br><span class="line">       delay = play - last_play;</span><br><span class="line">       <span class="keyword">if</span> (delay &lt;= <span class="number">0</span> || delay &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           delay = last_delay;</span><br><span class="line">       &#125;</span><br><span class="line">       audio_clock = vedio-&gt;audio-&gt;clock;</span><br><span class="line">       last_delay = delay;</span><br><span class="line">       last_play = play;</span><br><span class="line"><span class="comment">//音频与视频的时间差</span></span><br><span class="line">       diff = vedio-&gt;clock - audio_clock;</span><br><span class="line"><span class="comment">//        在合理范围外  才会延迟  加快</span></span><br><span class="line">       sync_threshold = (delay &gt; <span class="number">0.01</span> ? <span class="number">0.01</span> : delay);</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">fabs</span>(diff) &lt; <span class="number">10</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (diff &lt;= -sync_threshold) &#123;</span><br><span class="line">               delay = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold) &#123;</span><br><span class="line">               delay = <span class="number">2</span> * delay;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       start_time += delay;</span><br><span class="line">       actual_delay = start_time - av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">       <span class="keyword">if</span> (actual_delay &lt; <span class="number">0.01</span>) &#123;</span><br><span class="line">           actual_delay = <span class="number">0.01</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//  休眠时间 ffmpeg 建议这样写  为什么 要这样写 有待研究</span></span><br><span class="line">       av_usleep(actual_delay * <span class="number">1000000.0</span> + <span class="number">6000</span>);</span><br><span class="line">纠正play （播放时间）的方法 repeat_pict / (<span class="number">2</span> * fps) 是ffmpeg注释里教的</span><br><span class="line">synchronize(AVFrame *frame, <span class="keyword">double</span> play) &#123;</span><br><span class="line">   <span class="comment">//clock是当前播放的时间位置</span></span><br><span class="line">   <span class="keyword">if</span> (play != <span class="number">0</span>)</span><br><span class="line">       clock=play;</span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//pst为0 则先把pts设为上一帧时间</span></span><br><span class="line">       play = clock;</span><br><span class="line">   <span class="comment">//可能有pts为0 则主动增加clock</span></span><br><span class="line">   <span class="comment">//需要求出扩展延时：</span></span><br><span class="line">   <span class="keyword">double</span> repeat_pict = frame-&gt;repeat_pict;</span><br><span class="line">   <span class="comment">//使用AvCodecContext的而不是stream的</span></span><br><span class="line">   <span class="keyword">double</span> frame_delay = av_q2d(codec-&gt;time_base);</span><br><span class="line">   <span class="comment">//fps </span></span><br><span class="line">   <span class="keyword">double</span> fps = <span class="number">1</span> / frame_delay;</span><br><span class="line">   <span class="comment">//pts 加上 这个延迟 是显示时间  </span></span><br><span class="line">   <span class="keyword">double</span> extra_delay = repeat_pict / (<span class="number">2</span> * fps);</span><br><span class="line">   <span class="keyword">double</span> delay = extra_delay + frame_delay;</span><br><span class="line">   clock += delay;</span><br><span class="line">   <span class="keyword">return</span> play;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="FFmpeg-痛点解决"><a href="#FFmpeg-痛点解决" class="headerlink" title="FFmpeg 痛点解决"></a>FFmpeg 痛点解决</h2><p><strong>回音消除解决方案：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoYW9nL2FydGljbGUvZGV0YWlscy83MTE1Mjc0Mw==" title="https://blog.csdn.net/shichaog/article/details/71152743">语音自适应回声消除（AEC）算法<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmdiZWk5MDI5L2FydGljbGUvZGV0YWlscy84MTIzNzQwMg==" title="https://blog.csdn.net/longbei9029/article/details/81237402">回声消除(AEC)原理<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9RT3A0SU9hb19ESko2ZU5zSU9YcA==" title="https://www.infoq.cn/article/QOp4IOao_DJJ6eNsIOXp">音频降噪在 58 直播中的研究与实现<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>视频秒开：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoYXJlVXMvYXJ0aWNsZS9kZXRhaWxzLzc5MTE1ODE2" title="https://blog.csdn.net/ShareUs/article/details/79115816">直播视频秒开及视频优化<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGVhZjQ5YThkNmQ4MTAwNjE4YmMyMzg=" title="https://juejin.im/post/58eaf49a8d6d8100618bc238">视频直播秒开背后的技术与优化经验<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDQwNTkxMw==" title="https://segmentfault.com/a/1190000014405913">短视频“秒播”那点事<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy52b2lkY24uY29tL2FydGljbGUvcC1xa2R2dHR1ZS1ibWQuaHRtbA==" title="http://www.voidcn.com/article/p-qkdvttue-bmd.html">百度LSS 音视频直播 秒开<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDE1OTkxMA==" title="https://zhuanlan.zhihu.com/p/34159910">播放器的“妥协”造就了视频“秒开”的实现！<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>多人视频实时互动：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Y2IwMDhjMjZmYjlhMDY4NTQ3MzQ1ZWI=" title="https://juejin.im/post/5cb008c26fb9a068547345eb">WebRTC现状以及多人视频通话分析<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5wb2x5di5uZXQvbmV3cy8yMDE5LzAyL2h5MDM5Ni8=" title="http://www.polyv.net/news/2019/02/hy0396/">多人视频连麦——直播高效互动方式<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>实时互动与大并发负载：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy5tZWRpYXByby5jYy9ydHDovazlj5HmnI3liqHlmagv" title="http://www.mediapro.cc/rtp转发服务器/">RTP直播分发服务器集群方案<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzA1NTY1OQ==" title="https://zhuanlan.zhihu.com/p/23055659">海量用户实时互动直播架构探索<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuaXRwdWIubmV0LzY5OTA3OTgxL3ZpZXdzcGFjZS0yNTY0NDc5Lw==" title="http://blog.itpub.net/69907981/viewspace-2564479/">直播开发过程中关于直播技术的架构问题<i class="fa fa-external-link"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;img src=&quot;/images/imageFFmpeg/FFmpeg音视频架构-01.png&quot;&gt;

&lt;img src=&quot;/images/imageFFmpeg/FFmpeg音视频架构-02.png&quot;&gt;

&lt;h2 id=&quot;1-学习大纲&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频入门知识</title>
    <link href="http://miaopei.github.io/2019/04/23/FFmpeg/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8/"/>
    <id>http://miaopei.github.io/2019/04/23/FFmpeg/移动端音视频入门/</id>
    <published>2019-04-23T02:14:50.000Z</published>
    <updated>2019-06-13T02:01:37.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85N2I0ZGM4YzdmMDA=" title="https://www.jianshu.com/p/97b4dc8c7f00">H264基本原理<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-万人直播架构讲解"><a href="#1-万人直播架构讲解" class="headerlink" title="1. 万人直播架构讲解"></a>1. 万人直播架构讲解</h2><p>直播产品的种类：</p><ul><li><p>泛娱乐化直播</p><p>花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播</p></li><li><p>实时互动直播</p><p>音视频会议、教育直播等，像 思科、全时、声网</p></li></ul><a id="more"></a><p>泛娱乐化直播架构</p><blockquote><p>信令服务器：创建房间、聊天、礼物。。。。</p><p>美女主播 –信令–&gt; 信令服务器</p><p>信令服务器–rtmp流地址–&gt;美女主播</p><p>美女主播 –推流–&gt; 流媒体云CDN</p><p>观众 –信令–&gt; 信令服务器：将观众加入到美女主播间</p><p>信令服务器–rmtp流地址–&gt; 观众</p><p>观众 &lt;–拉流–&gt; 流媒体云CDN</p></blockquote><p>泛娱乐化直播架构</p><p>基于TCP协议实现</p><ol><li>发送信令到信令服务器, 服务器收到\执行后, 返回给共享端一个流媒体云的地址</li><li>共享端采集自己音视频数据, 形成rtmp流, 推送到CDN网络(推流)</li><li>获取流媒体云地址</li><li>拉流</li></ol><img src="/images/imageFFmpeg/泛娱乐化直播架构.png"><p>实时互动直播架构</p><p>基于UDP实现</p><ol><li>自有网络: UDP没有自有网络, 需自己搭建</li><li>多个节点: 为了保障服务的稳定性以及负载均衡</li><li>控制中心: 每个节点定期(心跳)向控制中心报告健康程度, 控制中心根据响应的数据做出决策</li><li>内总线: 数据安全性\吞吐量等可靠性得以保障</li><li>媒体服务器: 将RTP协议的数据转换成RTMP协议的数据</li><li>CDN网络: 根据用户需求进行拉流</li></ol><img src="/images/imageFFmpeg/实时互动直播架构.png"><h2 id="2-CDN网络介绍"><a href="#2-CDN网络介绍" class="headerlink" title="2. CDN网络介绍"></a>2. CDN网络介绍</h2><blockquote><p>CDN网络是为了解决什么问题而出现的？</p><p>总结为一句话：CDN网络是为了解决用户访问网络资源慢而出现的一个技术，两个原因：</p><ol><li>网络链路太长</li><li>人为因素（南电信北联通，利益相关）</li></ol></blockquote><p>CDN构成：</p><p>边缘结点：用户从边缘节点上获取数据</p><p>二级节点：主干网节点，主要用于缓存、减转源站压力</p><p>源站：CP(内容提供方)将内容放到源站</p><p>查找顺序：边缘结点-&gt;二级节点-&gt;源站</p><img src="/images/imageFFmpeg/CDN网络.png"><h2 id="3-亲手搭建一套简单的直播系统"><a href="#3-亲手搭建一套简单的直播系统" class="headerlink" title="3. 亲手搭建一套简单的直播系统"></a>3. 亲手搭建一套简单的直播系统</h2><p>安装nginx 配置rtmp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install nginx-full --with-rtmp-module</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">(这一步卡了我好久，安装nginx提示一直找不到nginx-full,网上相关的教程没更新，原因在于nginx仓库已搬迁)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew tap denji/nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nginx -s reload 重启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nginx  启动</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/nginx-trmp配置.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/FFMPEG直播命令.png"><img src="/images/imageFFmpeg/测试流媒体服务器.png"><h2 id="4-音频基础知识"><a href="#4-音频基础知识" class="headerlink" title="4. 音频基础知识"></a>4. 音频基础知识</h2><img src="/images/imageFFmpeg/声音三要素.png"><p>图一音量：甲乙的振动频率相同、振幅不同。图二音调：甲乙振幅相同、频率不同</p><img src="/images/imageFFmpeg/音量与音调.png"><img src="/images/imageFFmpeg/音色.png"><img src="/images/imageFFmpeg/人类听觉范围.png"><img src="/images/imageFFmpeg/听觉-发声范围.png"><h2 id="5-音频的量化与编码"><a href="#5-音频的量化与编码" class="headerlink" title="5. 音频的量化与编码"></a>5. 音频的量化与编码</h2><p>模拟信号进行采样，采样时分频率的从模拟信号获取数据波形值，采样后，进行数据量化，量化后进行编码，把采样的十进制转化为计算机的二进制，也就是数字信号。</p><p>模拟数据——》采样——》量化——》编码——》数字信号</p><img src="/images/imageFFmpeg/音频量化过程.png"><p>采样大小决定了音频的振幅的高度，采样时指一个采样用多少bit存放，常用的是16bit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bit：位     一个二进制数据0或1，是1bit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> byte：字节  存储空间的基本计量单位，如：MySQL中定义 VARCHAR(45) 即是指 45个字节；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 Byte = 8 Bit = 1 字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2^8 = 256, 2^16 = 65535</span></span><br></pre></td></tr></table></figure><p>aac通常44.1k采样率</p><p>采样率:采样频率8k/秒、16k/秒、32k/秒、44.1k/秒、48k/秒</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzUxNjky" title="https://www.zhihu.com/question/20351692">什么是音频的采样率？采样率和音质有没有关系？<i class="fa fa-external-link"></i></span> - 知乎</p></blockquote><img src="/images/imageFFmpeg/量化基本概念.png"><p>人能听到的声音范围是20hz-2whz</p><p>码率 = 采样率 x 采样大小 x 声道数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 宽带速率的单位用 bps(或b/s)表示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 B = 8 b   1 B/s = 8 b/s</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/码率计算.png"><p>原始的wav文件，大小是1411.2Kb/s</p><p>做完aaclc的编码，大小是128Kb/s</p><p>如果是aache-vr这种编码，大小是32Kb/s</p><h2 id="6-音频压缩技术讲解"><a href="#6-音频压缩技术讲解" class="headerlink" title="6. 音频压缩技术讲解"></a>6. 音频压缩技术讲解</h2><p>音频压缩技术</p><p>1、消除冗余数据（有损压缩技术）。</p><p>压缩的主要方法是去除采集到的音频冗余信息，所谓冗余信息包括人耳听觉范围外的音频信号以及被掩蔽掉的音频信号</p><p>信号的掩蔽可分为频域掩蔽和时域掩蔽</p><p>频域掩蔽：一个强纯音会掩蔽在其附近同时发声的弱纯音。也称同时掩蔽</p><p>时域掩蔽：在时间上相邻的声音之间也有掩蔽现象，主要原因是人的大脑处理信息需要花费时间。</p><p>同步掩蔽效应和不同频率声音的频率和相对竟是有关，而时间掩蔽则仅仅和时间有关。如果两个声音在时间上特别接近，分辨会有困难（如两个声音音量相差较大且两个声音间隔时间低于5毫秒，则其中弱的那个声音会听不到）。</p><p>2、哈夫曼无损编码</p><img src="/images/imageFFmpeg/音频压缩技术.png"><p>音频压缩：频域，时域。</p><ul><li><p>频域: 截取人耳能听到的频率范围，滤掉响度低的声音，去掉某个高频周围低频的声音；</p></li><li><p>时域: 滤掉某个长时间说话中的低音</p></li></ul><img src="/images/imageFFmpeg/音频冗余信息.png"><img src="/images/imageFFmpeg/频域掩蔽效应.png"><img src="/images/imageFFmpeg/时域掩蔽效应.png"><img src="/images/imageFFmpeg/音频编码过程.png"><h2 id="7-音频编解码器选型"><a href="#7-音频编解码器选型" class="headerlink" title="7. 音频编解码器选型"></a>7. 音频编解码器选型</h2><p>网上测评结果：音频编解码器 opus &gt; aac &gt; vorbis </p><p>音频编解码器：</p><p>1：opus，</p><ul><li>口模型：实时互动，对实时性要求非常高 </li><li>耳模型：高保真，对质量要求非常高</li></ul><p>至于什么时候使用那个模型，由opus自己内部来决定，同时，他是性能最好的，压缩率最好。</p><p>2：AAC，经常用于泛娱乐化直播，因为其对实时性要求不是很高但是对音质要求可能较高，所以，选用AAC，当然也可以选用opus的耳模型</p><p>3：sppex，最大的特点就是不仅可以编码音频，还可以对音频进行降噪，优化，尽可能的获取原音频数据</p><p>4：G.711(722)，主要用于音视频会议，为了和固话进行相应的融合</p><img src="/images/imageFFmpeg/常见的音频编码器.png"><img src="/images/imageFFmpeg/音频编码器性能对比.png"><h2 id="8-AAC-讲解"><a href="#8-AAC-讲解" class="headerlink" title="8. AAC 讲解"></a>8. AAC 讲解</h2><p>cdn，rtmp  支持 aac</p><p>AAC 产生的目的是取代 MP3 格式：</p><p>AAC 相对优点：压缩率高，损耗低</p><img src="/images/imageFFmpeg/AAC介绍.png"><img src="/images/imageFFmpeg/AAC规格.png"><p>aac 三种类型<br>aac<br>aacv1: aac+sbr(频率复用-高频部分采样率高，低频部分采样率低)<br>aacv2: aac+sbr+ps(声道关联，一个声道采集全部，一个声道只采集相对不同的声音)</p><p>AAC规格描述（AAC、AAC HE、AAC HE V2）–&gt; AAC+SBR=AAC HE V1, AAC + SBR + PS = AAC HE V2</p><img src="/images/imageFFmpeg/AAC规格描述.png"><p>AAC格式：</p><p>1、ADIF(Audio Data Interchange Format):只能从头开始解码，常用在磁盘文件中。</p><p>2、ADTS(Audio Data Transport Stream)：这种格式每一帧都有一个同步字，可以在音频流的任何位置开始解码，它似于数据流格式（缺点：文件比ADIF大，优点:每个帧都可以被单独解码播放）</p><img src="/images/imageFFmpeg/AAC格式.png"><p>aac 编码库 ffmpeg AAC，libfdk AAC</p><img src="/images/imageFFmpeg/AAC编码库那个好.png"><h2 id="9-视频基本知识"><a href="#9-视频基本知识" class="headerlink" title="9. 视频基本知识"></a>9. 视频基本知识</h2><p>I帧：关键帧，采用帧内压缩技术</p><p>P帧：向前参考帧，压缩时只参考前一个帧，属于帧间压缩技术</p><p>B帧：双向参考帧，压缩时即参考前一帧也参考后一帧，属于帧间压缩技术</p><p>一般实时互动都不会使用 B 帧</p><img src="/images/imageFFmpeg/H264基本概念.png"><p>GOF(group of frame): 一组帧，可以将一段时间内画面变化不大的所有帧划为一组帧</p><img src="/images/imageFFmpeg/GOF.png"><p>SPS与PPS（这两种都划为 I 帧）：</p><ul><li><p>SPS(Sequence Parameter Set): </p><p>序列参数集，存放帧数、参考帧数目、解码图像尺寸、帧场编码模式选择标识等。</p></li><li><p>PPS(Picture Parameter Set):</p><p>图像参数集，存放熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系统数调整标识等</p></li></ul><img src="/images/imageFFmpeg/SPS与PPS.png"><p>视频花屏/卡顿原因：</p><p>1、如果 GOP 分组中的 P 帧丢失会造成解码端的图像发生错误（于是形成了花屏）。</p><p>2、为了避免花屏问题的发生，一般如果发现 P 帧或者I帧丢失，就不显示本 GOP 内的所有帧，直到下一个 I 帧来后重新刷新图像（因为丢了一组数据，所以形成了卡顿）</p><img src="/images/imageFFmpeg/视频花屏卡顿的原因.png"><p>视频编码器：</p><p>1、x264/x265。</p><p>2、openH264(支持 SVC（分层传输） 技术)。</p><p>3、vp8/vp9</p><img src="/images/imageFFmpeg/视频都有哪些视频编码器.png"><h2 id="10-H264-宏块的划分与帧分组"><a href="#10-H264-宏块的划分与帧分组" class="headerlink" title="10. H264 宏块的划分与帧分组"></a>10. H264 宏块的划分与帧分组</h2><p>H264压缩技术</p><ol><li>帧内预测压缩，解决的是空域数据冗余问题（将一幅图里的人眼不是很敏感的色彩、光亮等数据剔除）</li><li>帧间预测压缩，解决的是时域数据冗余问题（将一组图里面连续的重复性高的帧剔除）</li><li>整数离散余弦变换(DCT)，将空间上的相关性变为频域上无关的数据然后进行量化</li><li>CABAC压缩，也叫上下文适应无损压缩</li></ol><img src="/images/imageFFmpeg/H264压缩技术.png"><p>宏块的划分与分组：</p><p>H264宏块划分与子块划分：宏块里面可以再包含很多子块</p><img src="/images/imageFFmpeg/H264宏块划分.png"><img src="/images/imageFFmpeg/宏块划分完成.png"><p>子块划分：</p><img src="/images/imageFFmpeg/子块划分.png"><p>帧分组(一组连续的图片，一幅图片为一帧)</p><img src="/images/imageFFmpeg/帧分组.png"><h2 id="11-视频压缩技术详解"><a href="#11-视频压缩技术详解" class="headerlink" title="11. 视频压缩技术详解"></a>11. 视频压缩技术详解</h2><ul><li><p>帧间预测: </p><p>解决时间数据冗余，比较相邻两帧不同给出运动矢量 + 残差值</p></li><li><p>帧内预测: </p><p>解决空间数据冗余，每一个宏块有一个预测模式，然后讲预测后的图像与原图比较算差值，最后存储预测模式和差值即可。帧内压缩是针对于 I 帧的</p></li></ul><h3 id="11-1-帧间预测"><a href="#11-1-帧间预测" class="headerlink" title="11.1 帧间预测"></a>11.1 帧间预测</h3><p>组内宏块查找：</p><img src="/images/imageFFmpeg/组内宏块查找.png"><img src="/images/imageFFmpeg/运动估算.png"><img src="/images/imageFFmpeg/运动矢量与补偿压缩.png"><h3 id="11-2-帧内预测"><a href="#11-2-帧内预测" class="headerlink" title="11.2 帧内预测"></a>11.2 帧内预测</h3><img src="/images/imageFFmpeg/帧内预测.png"><img src="/images/imageFFmpeg/计算帧内预测残差值.png"><img src="/images/imageFFmpeg/预测模式与残差值压缩.png"><h3 id="11-3-DCT-压缩"><a href="#11-3-DCT-压缩" class="headerlink" title="11.3 DCT 压缩"></a>11.3 DCT 压缩</h3><img src="/images/imageFFmpeg/DCT压缩.png"><img src="/images/imageFFmpeg/压缩后的结果.png"><h3 id="11-4-VLC-压缩"><a href="#11-4-VLC-压缩" class="headerlink" title="11.4 VLC 压缩"></a>11.4 VLC 压缩</h3><img src="/images/imageFFmpeg/VLC压缩.png"><h3 id="11-5-CABAC-压缩"><a href="#11-5-CABAC-压缩" class="headerlink" title="11.5 CABAC 压缩"></a>11.5 CABAC 压缩</h3><img src="/images/imageFFmpeg/CABAC压缩.png"><h2 id="12-H264-结构与码流"><a href="#12-H264-结构与码流" class="headerlink" title="12. H264 结构与码流"></a>12. H264 结构与码流</h2><p>H264编码分层：</p><p>1、NAL层（Network Abstraction Layer）, 视频数据网络抽象层。</p><p>2、VCL层（Video Coding Layer），视频数据编码层，对原始数据进行压缩</p><p>码流基本概念：</p><p>1、SODB（String Of Data Bits）,原始数据比特流，长度不一定是8的倍数，它是由VCL层产生的。</p><p>2、RBSP（Raw Byte Sequence Payload,SODB+trailing bits），算法是在SODB最后一位补1，不按字节对齐则补0。</p><p>3、EBSP(Encapsulate Byte Sequence Payload)，需到两个连续的0x00就增加一个0x03。</p><p>4、NALU，NAL Header(1B)+EBSP</p><img src="/images/imageFFmpeg/H264结构图.png"><p>以太网最大传输字节 1500 字节。</p><img src="/images/imageFFmpeg/H264编码分层.png"><img src="/images/imageFFmpeg/码流基本概念一.png"><img src="/images/imageFFmpeg/码流基本概念二.png"><p>一个H264帧最少要有一个切片(NAL Unit)</p><img src="/images/imageFFmpeg/NALUnit.png"><p>切片与宏块的关系：</p><ul><li>每个切片都包括切片头和切片数据，</li><li>每个切片数据又包括了很多宏块，</li><li>每个宏块又包括了宏块的类型、宏块的预测、编码的残渣数据等</li></ul><img src="/images/imageFFmpeg/切片与宏.png"><img src="/images/imageFFmpeg/H264切片.png"><img src="/images/imageFFmpeg/H264码流分层.png"><h2 id="13-NAL-单元详解"><a href="#13-NAL-单元详解" class="headerlink" title="13. NAL 单元详解"></a>13. NAL 单元详解</h2><img src="/images/imageFFmpeg/NALHeader.png"><p>5 - 关键帧</p><p>7- SPS 序列参数集</p><p>8- PPS 图像参数集</p><img src="/images/imageFFmpeg/NALType一.png"><img src="/images/imageFFmpeg/NALType二.png"><img src="/images/imageFFmpeg/NAL类型介绍.png"><img src="/images/imageFFmpeg/单一NALU的RTP包.png"><img src="/images/imageFFmpeg/组合NALU的RTP包.png"><p>如：</p><p>P帧B帧很多都是单一类型。</p><p>SPS和PPS这两个NAL单元一般放在同一个RTP包里头</p><img src="/images/imageFFmpeg/分片NALU的RTP包.png"><img src="/images/imageFFmpeg/FUHeader.png"><h2 id="14-YUV-讲解"><a href="#14-YUV-讲解" class="headerlink" title="14. YUV 讲解"></a>14. YUV 讲解</h2><img src="/images/imageFFmpeg/图像除了RGB还是有YUV.png"><img src="/images/imageFFmpeg/YUV.png"><p>YUV常见格式：YUV4:2:0、YUV4:2:2、YUV4:4:4</p><p>RGB8:8:8</p><img src="/images/imageFFmpeg/YUV常见格式.png"><img src="/images/imageFFmpeg/YUV420.png"><ul><li>UV 混存则为packed(打包存储)，</li><li>UV分开存则为planar(平面存储) </li></ul><img src="/images/imageFFmpeg/YUV存储格式.png"><h2 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h2><img src="/images/imageFFmpeg/小结.png"><img src="/images/imageFFmpeg/音频小结.png"><img src="/images/imageFFmpeg/视频小结.png"><p>rtmp 实时消息传输: tcp/ip 应用层协议  推送/直播  基本数据单元为消息</p><p>1B 消息类型  2B 长度  3B 时间 4B  流id 消息体</p><p>传输时 消息回被拆分成消息块 chunk chunk header + chunk data</p><p>flv: 大块音视频 加入标记头信息   延迟表现和大规模并发成熟 </p><p>HLS：分成5-10s 用m3u8索引管理 用于朋友圈分享  </p><p>m3u8索引： 直播信号源–视频编码器（后台视频处理）–流切片器–各种ts媒体文件（分发模块）–索引文件（数据库）–客户端</p><p>cdn网络 为了解决用户访问资源慢出现的技术</p><p>边缘节点  二级节点（大城市） 源站</p><p>搭建流媒体服务：</p><p>准备流媒体服务器 linux max 编译安装nginx服务  配置rtmp服务并启动nginx服务</p><p>声音三要素：音调 音量 音色</p><p>音频量化(模数转换)：模拟数据 采样  量化 编码  数字信号  == 0101001110</p><p>码率 = 采样率（1.6w/44.1/48k）x 采样大小(8位-电话/16位-常见) x 声道数（单/双）</p><p>音频压缩： 有损消除冗余数据   哈夫曼无损编码</p><p>音频编码： 时域转频域—心里声学模型—量化编码—比特流格式化—比特流</p><p>音频编解码 ： opus（口 耳 实时互动 最快）  aac(直播用 次快)  speed(回音 降噪等)   g.711（固话）</p><p>aac : 取代mp3 加入 sir ps 技术  </p><p>aac lc 128k / aac he v2 64k /  aac he v2 32k/</p><p>aac 格式 ： adif 从头开始解码，用在磁盘文件中  adts 每一帧都有一个同步字，可以在任何位置解码</p><p>aac 编码库 ： libfdk_aac &gt; ffmpeg aac &gt;libfaac&gt; libvo_aacenc</p><p>H264： I帧 关键 帧内压缩  / p帧 向前参考1帧 / B帧 双向参考帧</p><p>sps: 序列参数集/pps:图像参数集 </p><p>GOF： 一组帧数  p帧丢失 会花屏卡顿</p><p>视频编码器： x264/x265 /open h264(svc)/vp8/vp9</p><p>h264 压缩技术-编码原理： 帧内预测压缩，空域冗余数据/帧间预测压缩，时域冗余数据/dcp整数离散余炫变换，傅立叶变换/cabac压缩</p><p>h264结构：视频序列–图像–片–宏块–子快</p><p>h264编码分层：nal 视频数据网络抽象层–vcl 视频数据编码层</p><p>码率：sodb 原始比特流 / rbsp sodb最后补1 / ebsp 起始码增加一个起始位0x03 /  nalu nal+ebsp</p><p>nal unit = nalu 头部 + 一个切片（头/数据） 切片 </p><p>yuv格式：4：4:4/4:4:2/4：2:0 （平坦编码 /半平坦编码）</p><img src="/images/imageFFmpeg/后续.png"><img src="/images/imageFFmpeg/音视频知识01.png"><img src="/images/imageFFmpeg/音视频知识02.png"><img src="/images/imageFFmpeg/音视频知识03.png"><img src="/images/imageFFmpeg/行业痛点-01.png"><img src="/images/imageFFmpeg/行业痛点-02.png">]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85N2I0ZGM4YzdmMDA=&quot; title=&quot;https://www.jianshu.com/p/97b4dc8c7f00&quot;&gt;H264基本原理&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-万人直播架构讲解&quot;&gt;&lt;a href=&quot;#1-万人直播架构讲解&quot; class=&quot;headerlink&quot; title=&quot;1. 万人直播架构讲解&quot;&gt;&lt;/a&gt;1. 万人直播架构讲解&lt;/h2&gt;&lt;p&gt;直播产品的种类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;泛娱乐化直播&lt;/p&gt;
&lt;p&gt;花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实时互动直播&lt;/p&gt;
&lt;p&gt;音视频会议、教育直播等，像 思科、全时、声网&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>值得推荐的C/C++框架和库</title>
    <link href="http://miaopei.github.io/2018/06/08/Program-C/c-open-project/"/>
    <id>http://miaopei.github.io/2018/06/08/Program-C/c-open-project/</id>
    <published>2018-06-08T02:14:50.000Z</published>
    <updated>2019-06-14T06:11:05.638Z</updated>
    
    <content type="html"><![CDATA[<ul><li>目录<br>{:toc}</li></ul><h2 id="值得学习的C语言开源项目"><a href="#值得学习的C语言开源项目" class="headerlink" title="值得学习的C语言开源项目"></a>值得学习的C语言开源项目</h2><p><strong>Libev</strong></p><p>libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。</p><p>下载链接：<span class="exturl" data-url="aHR0cDovL3NvZnR3YXJlLnNjaG1vcnAuZGUvcGtnL2xpYmV2Lmh0bWw=" title="http://software.schmorp.de/pkg/libev.html">http://software.schmorp.de/pkg/libev.html<i class="fa fa-external-link"></i></span></p><p><strong>Memcached</strong></p><p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL21lbWNhY2hlZC5vcmcv" title="http://memcached.org/">http://memcached.org/<i class="fa fa-external-link"></i></span></p><p><strong>Redis</strong></p><p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。Redis支持的操作和数据类型比Memcached要多，现在主要用于缓存，支持主从同步机制，Redis的学习可以参考&lt;&lt;Redis设计与实现&gt;&gt;一书。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL3JlZGlzLmlvLw==" title="http://redis.io/">http://redis.io/<i class="fa fa-external-link"></i></span></p><p><strong>Webbench</strong></p><p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。</p><p>下载链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL1dlYkJlbmNo" title="https://github.com/LippiOuYang/WebBench">https://github.com/LippiOuYang/WebBenchl<i class="fa fa-external-link"></i></span></p><p><strong>APR（Apache Portable Runtime）</strong></p><p>这是由 Apache 社区维护的 C 开源库，主要提供操作系统相关的功能（文件系统、进程、线程、用户、IPC）。此外还提供了一些网络相关的功能。</p><p>APR 原先是 Apache Web 服务器的一个组成部分，后来独立出来，成为一个单独的开源项目。<br>主页：<span class="exturl" data-url="aHR0cHM6Ly9hcHIuYXBhY2hlLm9yZy8=" title="https://apr.apache.org/">https://apr.apache.org<i class="fa fa-external-link"></i></span></p><p><strong>Tinyhttpd</strong></p><p>tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。</p><p>下载链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL1RpbnlodHRwZA==" title="https://github.com/LippiOuYang/Tinyhttpd">https://github.com/LippiOuYang/Tinyhttpd<i class="fa fa-external-link"></i></span></p><p><strong>cJSON</strong></p><p>cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。</p><p>cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。</p><p>项目主页:<span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy9janNvbi8=" title="http://sourceforge.net/projects/cjson/">http://sourceforge.net/projects/cjson/<i class="fa fa-external-link"></i></span></p><p><strong>CMockery</strong></p><p>cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。</p><p>主要特点：</p><ul><li>免费且开源，google提供技术支持；</li><li>轻量级的框架，使测试更加快速简单；</li><li>避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;</li><li>并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用</li></ul><p>下载链接：<span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2Ntb2NrZXJ5L2Rvd25sb2Fkcy9saXN0" title="http://code.google.com/p/cmockery/downloads/list">http://code.google.com/p/cmockery/downloads/list<i class="fa fa-external-link"></i></span></p><p><strong>Lua</strong></p><p>Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。</p><p>让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL3d3dy5sdWEub3JnLw==" title="http://www.lua.org/">http://www.lua.org/<i class="fa fa-external-link"></i></span></p><p><strong>SQLite</strong></p><p>SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。</p><p> 下载地址：<span class="exturl" data-url="aHR0cDovL3d3dy5zcWxpdGUub3JnLw==" title="http://www.sqlite.org/">http://www.sqlite.org/<i class="fa fa-external-link"></i></span> 。</p><p><strong>UNIX v6</strong></p><p>UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？</p><p>另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL21pbm5pZS50dWhzLm9yZy9jZ2ktYmluL3V0cmVlLnBsP2ZpbGU9VjY=" title="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6">http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6<i class="fa fa-external-link"></i></span></p><p><strong>NETBSD</strong></p><p>NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL3d3dy5uZXRic2Qub3JnLw==" title="http://www.netbsd.org/">http://www.netbsd.org/<i class="fa fa-external-link"></i></span></p><h2 id="C-资源大全"><a href="#C-资源大全" class="headerlink" title="C++ 资源大全"></a>C++ 资源大全</h2><p>关于 C++ 框架、库和资源的一些汇总列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。</p><p>&nbsp;</p><h3>标准库</h3><p>C++标准库，包括了STL容器，算法和函数等。</p><ul><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DJTJCJTJCX1N0YW5kYXJkX0xpYnJhcnk=" title="http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library">C++ Standard Library<i class="fa fa-external-link"></i></span>：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。</li><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9UZW1wbGF0ZV9MaWJyYXJ5" title="http://en.wikipedia.org/wiki/Standard_Template_Library">Standard Template Library<i class="fa fa-external-link"></i></span>：标准模板库</li><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DX1BPU0lYX2xpYnJhcnk=" title="http://en.wikipedia.org/wiki/C_POSIX_library">C POSIX library<i class="fa fa-external-link"></i></span> ： POSIX系统的C标准库规范</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NwbHVzcGx1cw==" title="https://github.com/cplusplus">ISO C++ Standards Committee<i class="fa fa-external-link"></i></span> ：C++标准委员会</li></ul><p>&nbsp;</p><h3>框架</h3><p>C++通用框架和库</p><ul><li><span class="exturl" data-url="aHR0cDovL3N0ZGN4eC5hcGFjaGUub3JnLw==" title="http://stdcxx.apache.org/">Apache C++ Standard Library<i class="fa fa-external-link"></i></span>：是一系列算法，容器，迭代器和其他基本组件的集合</li><li><span class="exturl" data-url="aHR0cDovL3N0bGFiLmFkb2JlLmNvbS8=" title="http://stlab.adobe.com/">ASL<i class="fa fa-external-link"></i></span> ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jvb3N0b3Jn" title="https://github.com/boostorg">Boost<i class="fa fa-external-link"></i></span> ：大量通用C++库的集合。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jsb29tYmVyZy9iZGU=" title="https://github.com/bloomberg/bde">BDE<i class="fa fa-external-link"></i></span> ：来自于彭博资讯实验室的开发环境。</li><li><span class="exturl" data-url="aHR0cDovL2xpYmNpbmRlci5vcmcv" title="http://libcinder.org/">Cinder<i class="fa fa-external-link"></i></span>：提供专业品质创造性编码的开源开发社区。</li><li><span class="exturl" data-url="aHR0cDovL3J5YW4uZ3VsaXguY2wvZm9zc2lsLmNnaS9jeHhvbWZvcnQv" title="http://ryan.gulix.cl/fossil.cgi/cxxomfort/">Cxxomfort<i class="fa fa-external-link"></i></span>：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。</li><li><span class="exturl" data-url="aHR0cDovL2RsaWIubmV0Lw==" title="http://dlib.net/">Dlib<i class="fa fa-external-link"></i></span>：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhdWxob2RnZS9FQVNUTA==" title="https://github.com/paulhodge/EASTL">EASTL<i class="fa fa-external-link"></i></span> ：EA-STL公共部分</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N1bWVldGNoaGV0cmkvZmZlYWQtY3Bw" title="https://github.com/sumeetchhetri/ffead-cpp">ffead-cpp<i class="fa fa-external-link"></i></span> ：企业应用程序开发框架</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZvbGx5" title="https://github.com/facebook/folly">Folly<i class="fa fa-external-link"></i></span>：由Facebook开发和使用的开源C++库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1bGlhbnN0b3Jlci9KVUNF" title="https://github.com/julianstorer/JUCE">JUCE<i class="fa fa-external-link"></i></span> ：包罗万象的C++类库，用于开发跨平台软件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2xpYnBoZW5vbQ==" title="https://github.com/facebook/libphenom">libPhenom<i class="fa fa-external-link"></i></span>：用于构建高性能和高度可扩展性系统的事件框架。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvdXJjZXkvbGlic291cmNleQ==" title="https://github.com/sourcey/libsourcey">LibSourcey<i class="fa fa-external-link"></i></span> ：用于实时的视频流和高性能网络应用程序的C++11 evented IO</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tvYW5sb2dpYy9saWJ1" title="https://github.com/koanlogic/libu">LibU<i class="fa fa-external-link"></i></span> ： C语言写的多平台工具库</li><li><span class="exturl" data-url="aHR0cDovL2xva2ktbGliLnNvdXJjZWZvcmdlLm5ldC8=" title="http://loki-lib.sourceforge.net/">Loki<i class="fa fa-external-link"></i></span> ：C++库的设计，包括常见的设计模式和习语的实现。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9taWxpLw==" title="https://code.google.com/p/mili/">MiLi<i class="fa fa-external-link"></i></span> ：只含头文件的小型C++库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZnJhbWV3b3Jrcy5jYy8=" title="http://www.openframeworks.cc/">openFrameworks<i class="fa fa-external-link"></i></span> ：开发C++工具包，用于创意性编码。</li><li><span class="exturl" data-url="aHR0cDovL3F0LXByb2plY3Qub3JnLw==" title="http://qt-project.org/">Qt<i class="fa fa-external-link"></i></span> ：跨平台的应用程序和用户界面框架</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3JlYXNvbi8=" title="http://code.google.com/p/reason/">Reason<i class="fa fa-external-link"></i></span> ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。</li><li><span class="exturl" data-url="aHR0cDovL3Jvb3QuY2Vybi5jaC8=" title="http://root.cern.ch/">ROOT<i class="fa fa-external-link"></i></span> ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdGxwb3J0Lm9yZy8=" title="http://www.stlport.org/">STLport<i class="fa fa-external-link"></i></span>：是STL具有代表性的版本</li><li><span class="exturl" data-url="aHR0cDovL3N0eHhsLnNvdXJjZWZvcmdlLm5ldC8=" title="http://stxxl.sourceforge.net/">STXXL<i class="fa fa-external-link"></i></span>：用于额外的大型数据集的标准模板库。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy51bHRpbWF0ZXBwLm9yZy8=" title="http://www.ultimatepp.org/">Ultimate++<i class="fa fa-external-link"></i></span> ：C++跨平台快速应用程序开发框架</li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy93dGwv" title="http://sourceforge.net/projects/wtl/">Windows Template Library<i class="fa fa-external-link"></i></span>：用于开发Windows应用程序和UI组件的C++库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2psbDYzL3lvbW0xMQ==" title="https://github.com/jll63/yomm11">Yomm11<i class="fa fa-external-link"></i></span> ：C++11的开放multi-methods.</li></ul><p>&nbsp;</p><h3>人工智能</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FpZ2FtZWRldi9idHNr" title="https://github.com/aigamedev/btsk">btsk<i class="fa fa-external-link"></i></span> ：游戏行为树启动器工具</li><li><span class="exturl" data-url="aHR0cDovL2VvZGV2LnNvdXJjZWZvcmdlLm5ldC8=" title="http://eodev.sourceforge.net/">Evolving Objects<i class="fa fa-external-link"></i></span>：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuZHJvbWV0YS9uZXU=" title="https://github.com/andrometa/neu">Neu<i class="fa fa-external-link"></i></span>：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。</li></ul><p>&nbsp;</p><h3>异步事件循环</h3><ul><li><span class="exturl" data-url="aHR0cDovL3RoaW5rLWFzeW5jLmNvbS8=" title="http://think-async.com/">Boost.Asio<i class="fa fa-external-link"></i></span>：用于网络和底层I/O编程的跨平台的C++库。</li><li><span class="exturl" data-url="aHR0cDovL2xpYmV2LnNjaG1vcnAuZGUv" title="http://libev.schmorp.de/">libev<i class="fa fa-external-link"></i></span> ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。</li><li><span class="exturl" data-url="aHR0cDovL2xpYmV2ZW50Lm9yZy8=" title="http://libevent.org/">libevent<i class="fa fa-external-link"></i></span> ：事件通知库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9saWJ1dg==" title="https://github.com/joyent/libuv">libuv<i class="fa fa-external-link"></i></span> ：跨平台异步I/O。</li></ul><p>&nbsp;</p><h3>音频</h3><p>音频，声音，音乐，数字化音乐库</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5mbW9kLm9yZy8=" title="http://www.fmod.org/">FMOD<i class="fa fa-external-link"></i></span> ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY2tub2lzZS9NYXhpbWlsaWFu" title="https://github.com/micknoise/Maximilian">Maximilian<i class="fa fa-external-link"></i></span> ：C++音频和音乐数字信号处理库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuYWwub3JnLw==" title="http://www.openal.org/">OpenAL<i class="fa fa-external-link"></i></span> ：开源音频库&#8212;跨平台的音频API</li><li><span class="exturl" data-url="aHR0cDovL29wdXMtY29kZWMub3JnLw==" title="http://opus-codec.org/">Opus<i class="fa fa-external-link"></i></span>：一个完全开放的，免版税的，高度通用的音频编解码器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zcGVleC5vcmcv" title="http://www.speex.org/">Speex<i class="fa fa-external-link"></i></span>：免费编解码器，为Opus所废弃</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RvbmljQXVkaW8vVG9uaWM=" title="https://github.com/TonicAudio/Tonic">Tonic<i class="fa fa-external-link"></i></span>： C++易用和高效的音频合成</li><li><span class="exturl" data-url="aHR0cDovL3hpcGgub3JnL3ZvcmJpcy8=" title="http://xiph.org/vorbis/">Vorbis<i class="fa fa-external-link"></i></span>： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。</li></ul><p>&nbsp;</p><h3>生态学</h3><p>生物信息，基因组学和生物技术</p><ul><li><span class="exturl" data-url="aHR0cDovL21vbHBvcGdlbi5naXRodWIuaW8vbGlic2VxdWVuY2Uv" title="http://molpopgen.github.io/libsequence/">libsequence<i class="fa fa-external-link"></i></span>：用于表示和分析群体遗传学数据的C++库。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zZXFhbi5kZS8=" title="http://www.seqan.de/">SeqAn<i class="fa fa-external-link"></i></span>：专注于生物数据序列分析的算法和数据结构。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VrZy92Y2ZsaWI=" title="https://github.com/ekg/vcflib">Vcflib<i class="fa fa-external-link"></i></span> ：用于解析和处理VCF文件的C++库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pld21hbmNodWUvd2hhbQ==" title="https://github.com/jewmanchue/wham">Wham<i class="fa fa-external-link"></i></span>：直接把联想测试应用到BAM文件的基因结构变异。</li></ul><p>&nbsp;</p><h3>压缩</h3><p>压缩和归档库</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5iemlwLm9yZy8=" title="http://www.bzip.org/">bzip2<i class="fa fa-external-link"></i></span>：一个完全免费，免费专利和高质量的数据压缩</li><li><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL2F0dGlsYV9hZnJhL2RvYm96L292ZXJ2aWV3" title="https://bitbucket.org/attila_afra/doboz/overview">doboz<i class="fa fa-external-link"></i></span>：能够快速解压缩的压缩库</li><li><span class="exturl" data-url="aHR0cHM6Ly9pY2N1bHVzLm9yZy9waHlzZnMv" title="https://icculus.org/physfs/">PhysicsFS<i class="fa fa-external-link"></i></span>：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。</li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9qZWN0cy5rZGUub3JnL3Byb2plY3RzL2ZyYW1ld29ya3Mva2FyY2hpdmU=" title="https://projects.kde.org/projects/frameworks/karchive">KArchive<i class="fa fa-external-link"></i></span>：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9sejQv" title="https://code.google.com/p/lz4/">LZ4<i class="fa fa-external-link"></i></span> ：非常快速的压缩算法</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9semhhbS8=" title="https://code.google.com/p/lzham/">LZHAM<i class="fa fa-external-link"></i></span> ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy43LXppcC5vcmcvc2RrLmh0bWw=" title="http://www.7-zip.org/sdk.html">LZMA<i class="fa fa-external-link"></i></span> ：7z格式默认和通用的压缩方法。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tYXRjb2RlLmNvbS9sem1hdC5odG0=" title="http://www.matcode.com/lzmat.htm">LZMAT<i class="fa fa-external-link"></i></span> ：及其快速的实时无损数据压缩库</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9taW5pei8=" title="https://code.google.com/p/miniz/">miniz<i class="fa fa-external-link"></i></span>：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25tb2ludmF6L21pbml6aXA=" title="https://github.com/nmoinvaz/minizip">Minizip<i class="fa fa-external-link"></i></span>：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9zbmFwcHkv" title="https://code.google.com/p/snappy/">Snappy<i class="fa fa-external-link"></i></span> ：快速压缩和解压缩</li><li><span class="exturl" data-url="aHR0cDovL3psaWIubmV0Lw==" title="http://zlib.net/">ZLib<i class="fa fa-external-link"></i></span> ：非常紧凑的数据流压缩库</li><li><span class="exturl" data-url="aHR0cDovL3p6aXBsaWIuc291cmNlZm9yZ2UubmV0Lw==" title="http://zziplib.sourceforge.net/">ZZIPlib<i class="fa fa-external-link"></i></span>：提供ZIP归档的读权限。</li></ul><p>&nbsp;</p><h3>并发性</h3><p>并发执行和多线程</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t5bGVsdXR6L2NvbXB1dGU=" title="https://github.com/kylelutz/compute">Boost.Compute<i class="fa fa-external-link"></i></span> ：用于OpenCL的C++GPU计算库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hTQS1MaWJyYXJpZXMvQm9sdA==" title="https://github.com/HSA-Libraries/Bolt">Bolt<i class="fa fa-external-link"></i></span> ：针对GPU进行优化的C++模板库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaGxhbmdzdGVyL2NwcC5yZWFjdA==" title="https://github.com/schlangster/cpp.react">C++React<i class="fa fa-external-link"></i></span> ：用于C++11的反应性编程库</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGhyZWFkaW5nYnVpbGRpbmdibG9ja3Mub3JnLw==" title="https://www.threadingbuildingblocks.org/">Intel TBB<i class="fa fa-external-link"></i></span> ：Intel线程构件块</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYmNsc3BoL2xpYmNsc3Bo" title="https://github.com/libclsph/libclsph">Libclsph<i class="fa fa-external-link"></i></span>：基于OpenCL的GPU加速SPH流体仿真库</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmNsLw==" title="https://www.khronos.org/opencl/">OpenCL<i class="fa fa-external-link"></i></span> ：并行编程的异构系统的开放标准</li><li><span class="exturl" data-url="aHR0cDovL29wZW5tcC5vcmcv" title="http://openmp.org/">OpenMP<i class="fa fa-external-link"></i></span>：OpenMP API</li><li><span class="exturl" data-url="aHR0cDovL3RocnVzdC5naXRodWIuaW8v" title="http://thrust.github.io/">Thrust<i class="fa fa-external-link"></i></span> ：类似于C++标准模板库的并行算法库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NURWxsQVItR1JPVVAvaHB4Lw==" title="https://github.com/STEllAR-GROUP/hpx/">HPX<i class="fa fa-external-link"></i></span> ：用于任何规模的并行和分布式应用程序的通用C++运行时系统</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RkZW1pZG92L3ZleGNs" title="https://github.com/ddemidov/vexcl">VexCL<i class="fa fa-external-link"></i></span> ：用于OpenCL/CUDA 的C++向量表达式模板库。</li></ul><p>&nbsp;</p><h3>容器</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcHAtYnRyZWUv" title="https://code.google.com/p/cpp-btree/">C++ B-tree<i class="fa fa-external-link"></i></span> ：基于B树数据结构，实现命令内存容器的模板库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb3NzYWVydC9oYXNobWFw" title="https://github.com/goossaert/hashmap">Hashmaps<i class="fa fa-external-link"></i></span>： C++中开放寻址哈希表算法的实现</li></ul><p>&nbsp;</p><h3>密码学</h3><ul><li><span class="exturl" data-url="aHR0cDovL2JjcnlwdC5zb3VyY2Vmb3JnZS5uZXQv" title="http://bcrypt.sourceforge.net/">Bcrypt<i class="fa fa-external-link"></i></span> ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZmZmFyYXovYXdlc29tZS1jcHAvYmxvYi9tYXN0ZXI=" title="https://github.com/fffaraz/awesome-cpp/blob/master">BeeCrypt<i class="fa fa-external-link"></i></span>：</li><li><span class="exturl" data-url="aHR0cDovL2JvdGFuLnJhbmRvbWJpdC5uZXQv" title="http://botan.randombit.net/">Botan<i class="fa fa-external-link"></i></span>： C++加密库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcnlwdG9wcC5jb20v" title="http://www.cryptopp.com/">Crypto++<i class="fa fa-external-link"></i></span>：一个有关加密方案的免费的C++库</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ251cGcub3JnLw==" title="https://www.gnupg.org/">GnuPG<i class="fa fa-external-link"></i></span>： OpenPGP标准的完整实现</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnV0bHMub3JnLw==" title="http://www.gnutls.org/">GnuTLS<i class="fa fa-external-link"></i></span> ：实现了SSL，TLS和DTLS协议的安全通信库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2xpYmdjcnlwdC8=" title="http://www.gnu.org/software/libgcrypt/">Libgcrypt<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZmZmFyYXovYXdlc29tZS1jcHAvYmxvYi9tYXN0ZXI=" title="https://github.com/fffaraz/awesome-cpp/blob/master">libmcrypt<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWJyZXNzbC5vcmcv" title="http://www.libressl.org/">LibreSSL<i class="fa fa-external-link"></i></span>：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYnRvbS9saWJ0b21jcnlwdA==" title="https://github.com/libtom/libtomcrypt">LibTomCrypt<i class="fa fa-external-link"></i></span>：一个非常全面的，模块化的，可移植的加密工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plZGlzY3QxL2xpYnNvZGl1bQ==" title="https://github.com/jedisct1/libsodium">libsodium<i class="fa fa-external-link"></i></span>：基于NaCI的加密库，固执己见，容易使用</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5seXNhdG9yLmxpdS5zZS9+bmlzc2UvbmV0dGxlLw==" title="http://www.lysator.liu.se/~nisse/nettle/">Nettle<i class="fa fa-external-link"></i></span> 底层的加密库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuc3NsLm9yZy8=" title="http://www.openssl.org/">OpenSSL<i class="fa fa-external-link"></i></span> ： 一个强大的，商用的，功能齐全的，开放源代码的加密库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tva2tlL3RpbnktQUVTMTI4LUM=" title="https://github.com/kokke/tiny-AES128-C">Tiny AES128 in C<i class="fa fa-external-link"></i></span> ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法</li></ul><p>&nbsp;</p><h3>数据库</h3><p>数据库，SQL服务器，ODBC驱动程序和工具</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhdWxmdHcvaGliZXJsaXRl" title="https://github.com/paulftw/hiberlite">hiberlite<i class="fa fa-external-link"></i></span> ：用于Sqlite3的C++对象关系映射</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZGlzL2hpcmVkaXM=" title="https://github.com/redis/hiredis">Hiredis<i class="fa fa-external-link"></i></span>： 用于Redis数据库的很简单的C客户端库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://github.com/google/leveldb">LevelDB<i class="fa fa-external-link"></i></span>： 快速键值存储库</li><li><span class="exturl" data-url="aHR0cDovL3N5bWFzLmNvbS9tZGIv" title="http://symas.com/mdb/">LMDB<i class="fa fa-external-link"></i></span>：符合数据库四大基本元素的嵌入键值存储</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50YW5nZW50c29mdC5uZXQvbXlzcWwrKy8=" title="http://www.tangentsoft.net/mysql++/">MySQL++<i class="fa fa-external-link"></i></span>：封装了MySql的C API的C++ 包装器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGI=" title="https://github.com/facebook/rocksdb">RocksDB<i class="fa fa-external-link"></i></span>：来自Facebook的嵌入键值的快速存储</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zcWxpdGUub3JnLw==" title="http://www.sqlite.org/">SQLite<i class="fa fa-external-link"></i></span>：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。</li></ul><p>&nbsp;</p><h3>调试</h3><p>调试库， 内存和资源泄露检测，单元测试</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ib29zdC5vcmcvZG9jL2xpYnMvbWFzdGVyL2xpYnMvdGVzdC9kb2MvaHRtbC9pbmRleC5odG1s" title="http://www.boost.org/doc/libs/master/libs/test/doc/html/index.html">Boost.Test<i class="fa fa-external-link"></i></span>：Boost测试库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BoaWxzcXVhcmVkL0NhdGNo" title="https://github.com/philsquared/Catch">Catch<i class="fa fa-external-link"></i></span>：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5mcmVlZGVza3RvcC5vcmcvd2lraS9Tb2Z0d2FyZS9jcHB1bml0Lw==" title="http://www.freedesktop.org/wiki/Software/cppunit/">CppUnit<i class="fa fa-external-link"></i></span>：由JUnit移植过来的C++测试框架</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbWFrZS5vcmcvY21ha2UvaGVscC92Mi44LjgvY3Rlc3QuaHRtbA==" title="http://www.cmake.org/cmake/help/v2.8.8/ctest.html">CTest<i class="fa fa-external-link"></i></span>：CMake测试驱动程序</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZXRlc3Qv" title="http://code.google.com/p/googletest/">googletest<i class="fa fa-external-link"></i></span>：谷歌C++测试框架</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RlcGxpbmVub2lzZS9pZy1kZWJ1Z2hlYXA=" title="https://github.com/deplinenoise/ig-debugheap">ig-debugheap<i class="fa fa-external-link"></i></span>：用于跟踪内存错误的多平台调试堆</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pvcmduYXgvbGlidGFw" title="https://github.com/zorgnax/libtap">libtap<i class="fa fa-external-link"></i></span>：用C语言编写测试</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5hbG1vc3RpbmZpbml0ZS5jb20vbWVtdHJhY2suaHRtbA==" title="http://www.almostinfinite.com/memtrack.html">MemTrack<i class="fa fa-external-link"></i></span> —用于C++跟踪内存分配</li><li><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL2pvbmFzbWV5ZXIvbWljcm9wcm9maWxlL292ZXJ2aWV3" title="https://bitbucket.org/jonasmeyer/microprofile/overview">microprofile<i class="fa fa-external-link"></i></span>- 跨平台的网络试图分析器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5qZXJhLmNvbS90ZWNoaW5mby9qdG5zL2p0bjAwMi5odG1s" title="http://www.jera.com/techinfo/jtns/jtn002.html">minUnit<i class="fa fa-external-link"></i></span> ：使用C写的迷你单元测试框架，只使用了两个宏</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NlbHRveXMvUmVtb3Rlcnk=" title="https://github.com/Celtoys/Remotery">Remotery<i class="fa fa-external-link"></i></span>：用于web视图的单一C文件分析器</li><li><span class="exturl" data-url="aHR0cDovL3VuaXR0ZXN0LWNwcC5zb3VyY2Vmb3JnZS5uZXQv" title="http://unittest-cpp.sourceforge.net/">UnitTest++<i class="fa fa-external-link"></i></span>：轻量级的C++单元测试框架</li></ul><p>&nbsp;</p><h3>游戏引擎</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2NvczJkLXgub3JnLw==" title="http://www.cocos2d-x.org/">Cocos2d-x<i class="fa fa-external-link"></i></span> ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。</li><li><span class="exturl" data-url="aHR0cDovL2dyaXRlbmdpbmUuY29tLw==" title="http://gritengine.com/">Grit<i class="fa fa-external-link"></i></span> ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。</li><li><span class="exturl" data-url="aHR0cDovL2lycmxpY2h0LnNvdXJjZWZvcmdlLm5ldC8=" title="http://irrlicht.sourceforge.net/">Irrlicht<i class="fa fa-external-link"></i></span> ：C++语言编写的开源高性能的实时#D引擎</li><li><span class="exturl" data-url="aHR0cDovL3BvbHljb2RlLm9yZy8=" title="http://polycode.org/">Polycode<i class="fa fa-external-link"></i></span>：C++实现的用于创建游戏的开源框架（与Lua绑定）。</li></ul><p>&nbsp;</p><h3>图形用户界面</h3><ul><li><span class="exturl" data-url="aHR0cDovL2NlZ3VpLm9yZy51ay8=" title="http://cegui.org.uk/">CEGUI<i class="fa fa-external-link"></i></span> ： 很灵活的跨平台GUI库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5mbHRrLm9yZy9pbmRleC5waHA=" title="http://www.fltk.org/index.php">FLTK<i class="fa fa-external-link"></i></span> ：快速，轻量级的跨平台的C++GUI工具包。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ndGsub3JnLw==" title="http://www.gtk.org/">GTK+<i class="fa fa-external-link"></i></span>： 用于创建图形用户界面的跨平台工具包</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ndGttbS5vcmcvZW4v" title="http://www.gtkmm.org/en/">gtkmm<i class="fa fa-external-link"></i></span> ：用于受欢迎的GUI库GTK+的官方C++接口。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29jb3JudXQvaW1ndWk=" title="https://github.com/ocornut/imgui">imgui<i class="fa fa-external-link"></i></span>：拥有最小依赖关系的立即模式图形用户界面</li><li><span class="exturl" data-url="aHR0cDovL2xpYnJvY2tldC5jb20v" title="http://librocket.com/">libRocket<i class="fa fa-external-link"></i></span> ：<span class="exturl" data-url="aHR0cDovL2xpYnJvY2tldC5jb20v" title="http://librocket.com/">libRocket<i class="fa fa-external-link"></i></span> 是一个C++ HTML/CSS 游戏接口中间件</li><li><span class="exturl" data-url="aHR0cDovL215Z3VpLmluZm8v" title="http://mygui.info/">MyGUI<i class="fa fa-external-link"></i></span> ：快速，灵活，简单的GUI</li><li><span class="exturl" data-url="aHR0cDovL2ludmlzaWJsZS1pc2xhbmQubmV0L25jdXJzZXMv" title="http://invisible-island.net/ncurses/">Ncurses<i class="fa fa-external-link"></i></span>：终端用户界面</li><li><span class="exturl" data-url="aHR0cDovL3FjdXN0b21wbG90LmNvbS8=" title="http://qcustomplot.com/">QCustomPlot<i class="fa fa-external-link"></i></span> ：没有更多依赖关系的Qt绘图控件</li><li><span class="exturl" data-url="aHR0cDovL3F3dC5zb3VyY2Vmb3JnZS5uZXQv" title="http://qwt.sourceforge.net/">Qwt<i class="fa fa-external-link"></i></span> ：用户与技术应用的Qt 控件</li><li><span class="exturl" data-url="aHR0cDovL3F3dHBsb3QzZC5zb3VyY2Vmb3JnZS5uZXQv" title="http://qwtplot3d.sourceforge.net/">QwtPlot3D<i class="fa fa-external-link"></i></span> ：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R3b2xld2lzL090dGVyVUk=" title="https://github.com/Twolewis/OtterUI">OtterUI<i class="fa fa-external-link"></i></span> ：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R3b2xld2lzL090dGVyVUk=" title="https://github.com/Twolewis/OtterUI">OtterUI<i class="fa fa-external-link"></i></span> 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案</li><li><span class="exturl" data-url="aHR0cDovL3BkY3Vyc2VzLnNvdXJjZWZvcmdlLm5ldC8=" title="http://pdcurses.sourceforge.net/">PDCurses<i class="fa fa-external-link"></i></span> 包含源代码和预编译库的公共图形函数库</li><li><span class="exturl" data-url="aHR0cDovL3d4d2lkZ2V0cy5vcmcv" title="http://wxwidgets.org/">wxWidgets<i class="fa fa-external-link"></i></span> C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序</li></ul><p>&nbsp;</p><h3>图形</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JrYXJhZHppYy9iZ2Z4" title="https://github.com/bkaradzic/bgfx">bgfx<i class="fa fa-external-link"></i></span>：跨平台的渲染库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jYWlyb2dyYXBoaWNzLm9yZy8=" title="http://www.cairographics.org/">Cairo<i class="fa fa-external-link"></i></span>：支持多种输出设备的2D图形库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvcmRlM2QvSG9yZGUzRA==" title="https://github.com/horde3d/Horde3D">Horde3D<i class="fa fa-external-link"></i></span> 一个小型的3D渲染和动画引擎</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vc3JhL21hZ251bQ==" title="https://github.com/mosra/magnum">magnum<i class="fa fa-external-link"></i></span> C++11和OpenGL 2D/3D 图形引擎</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vZ3JlM2Qub3JnLw==" title="http://www.ogre3d.org/">Ogre 3D<i class="fa fa-external-link"></i></span> 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuc2NlbmVncmFwaC5vcmcv" title="http://www.openscenegraph.org/">OpenSceneGraph<i class="fa fa-external-link"></i></span> 具有高性能的开源3D图形工具包</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5wYW5kYTNkLm9yZy8=" title="http://www.panda3d.org/">Panda3D<i class="fa fa-external-link"></i></span> 用于3D渲染和游戏开发的框架，用Python和C++编写。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9za2lh" title="https://github.com/google/skia">Skia<i class="fa fa-external-link"></i></span> 用于绘制文字，图形和图像的完整的2D图形库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VyaG8zZC9VcmhvM0Q=" title="https://github.com/urho3d/Urho3D">urho3d<i class="fa fa-external-link"></i></span> 跨平台的渲染和游戏引擎。</li></ul><p>&nbsp;</p><h3>图像处理</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ib29zdC5vcmcvZG9jL2xpYnMvMV81Nl8wL2xpYnMvZ2lsL2RvYy9pbmRleC5odG1s" title="http://www.boost.org/doc/libs/1_56_0/libs/gil/doc/index.html">Boost.GIL<i class="fa fa-external-link"></i></span>：通用图像库</li><li><span class="exturl" data-url="aHR0cDovL2NpbWcuc291cmNlZm9yZ2UubmV0Lw==" title="http://cimg.sourceforge.net/">CImg<i class="fa fa-external-link"></i></span> ：用于图像处理的小型开源C++工具包</li><li><span class="exturl" data-url="aHR0cDovL3d3dy54ZHAuaXQvY3hpbWFnZS5odG0=" title="http://www.xdp.it/cximage.htm">CxImage<i class="fa fa-external-link"></i></span> ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。</li><li><span class="exturl" data-url="aHR0cDovL2ZyZWVpbWFnZS5zb3VyY2Vmb3JnZS5uZXQv" title="http://freeimage.sourceforge.net/">FreeImage<i class="fa fa-external-link"></i></span> ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。</li><li><span class="exturl" data-url="aHR0cDovL2dkY20uc291cmNlZm9yZ2UubmV0L3dpa2kvaW5kZXgucGhwL01haW5fUGFnZQ==" title="http://gdcm.sourceforge.net/wiki/index.php/Main_Page">GDCM<i class="fa fa-external-link"></i></span>：Grassroots DICOM 库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pdGsub3JnLw==" title="http://www.itk.org/">ITK<i class="fa fa-external-link"></i></span>：跨平台的开源图像分析系统</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmcvc2NyaXB0L2FwaS5waHA=" title="http://www.imagemagick.org/script/api.php">Magick++<i class="fa fa-external-link"></i></span>：ImageMagick程序的C++接口</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmcvc2NyaXB0L2FwaS5waHA=" title="http://www.imagemagick.org/script/api.php">MagickWnd<i class="fa fa-external-link"></i></span>：ImageMagick程序的C++接口</li><li><span class="exturl" data-url="aHR0cDovL29wZW5jdi5vcmcv" title="http://opencv.org/">OpenCV<i class="fa fa-external-link"></i></span> ： 开源计算机视觉类库</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC90ZXNzZXJhY3Qtb2NyLw==" title="https://code.google.com/p/tesseract-ocr/">tesseract-ocr<i class="fa fa-external-link"></i></span>：OCR引擎</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Vrb2V0aGUvdmlncmE=" title="https://github.com/ukoethe/vigra">VIGRA<i class="fa fa-external-link"></i></span> ：用于图像分析通用C++计算机视觉库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy52dGsub3JnLw==" title="http://www.vtk.org/">VTK<i class="fa fa-external-link"></i></span> ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</li></ul><p>&nbsp;</p><h3>国际化</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2dldHRleHQv" title="http://www.gnu.org/software/gettext/">gettext<i class="fa fa-external-link"></i></span> ：GNU `gettext&#8217;</li><li><span class="exturl" data-url="aHR0cDovL3NpdGUuaWN1LXByb2plY3Qub3JnLw==" title="http://site.icu-project.org/">IBM ICU<i class="fa fa-external-link"></i></span>：提供Unicode 和全球化支持的C、C++ 和Java库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2xpYmljb252Lw==" title="http://www.gnu.org/software/libiconv/">libiconv<i class="fa fa-external-link"></i></span> ：用于不同字符编码之间的编码转换库</li></ul><p>&nbsp;</p><h3>Jason</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvZnJvemVu" title="https://github.com/cesanta/frozen">frozen<i class="fa fa-external-link"></i></span> ： C/C++的Jason解析生成器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FraGVyb24vamFuc3Nvbg==" title="https://github.com/akheron/jansson">Jansson<i class="fa fa-external-link"></i></span> ：进行编解码和处理Jason数据的C语言库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NocmlzbWFubmluZy9qYnNvbg==" title="https://github.com/chrismanning/jbson">jbson<i class="fa fa-external-link"></i></span> ：C++14中构建和迭代BSON data,和Json 文档的库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plYXllL2plYXllc29u" title="https://github.com/jeaye/jeayeson">JeayeSON<i class="fa fa-external-link"></i></span>：非常健全的C++ JSON库，只包含头文件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqaWFuZy9qc29ueHg=" title="https://github.com/hjiang/jsonxx">JSON++<i class="fa fa-external-link"></i></span> ： C++ JSON 解析器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VkcC9qc29uLXBhcnNlcg==" title="https://github.com/udp/json-parser">json-parser<i class="fa fa-external-link"></i></span>：用可移植的ANSI C编写的JSON解析器，占用内存非常少</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Ryb3Bib3gvanNvbjEx" title="https://github.com/dropbox/json11">json11<i class="fa fa-external-link"></i></span> ：一个迷你的C++11 JSON库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtaXItcy9qdXRl" title="https://github.com/amir-s/jute">jute<i class="fa fa-external-link"></i></span> ：非常简单的C++ JSON解析器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZpbmNlbnRoei9saWJqc29u" title="https://github.com/vincenthz/libjson">ibjson<i class="fa fa-external-link"></i></span>：C语言中的JSON解析和打印库，很容易和任何模型集成。</li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy9saWJqc29uLw==" title="http://sourceforge.net/projects/libjson/">libjson<i class="fa fa-external-link"></i></span>：轻量级的JSON库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2thenVoby9waWNvanNvbg==" title="https://github.com/kazuho/picojson">PicoJSON<i class="fa fa-external-link"></i></span>：C++中JSON解析序列化，只包含头文件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dhdWRlY2tlci9xdC1qc29u" title="https://github.com/gaudecker/qt-json">qt-json<i class="fa fa-external-link"></i></span> ：用于JSON数据和 QVariant层次间的相互解析的简单类</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsYXZpby9xanNvbg==" title="https://github.com/flavio/qjson">QJson<i class="fa fa-external-link"></i></span>：将JSON数据映射到QVariant对象的基于Qt的库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pbG95aXAvcmFwaWRqc29u" title="https://github.com/miloyip/rapidjson">RapidJSON<i class="fa fa-external-link"></i></span>： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xsb3lkL3lhamw=" title="https://github.com/lloyd/yajl">YAJL<i class="fa fa-external-link"></i></span> ：C语言中快速流JSON解析库</li></ul><p>&nbsp;</p><h3>日志</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ib29zdC5vcmcvZG9jL2xpYnMvMV81Nl8wL2xpYnMvbG9nL2RvYy9odG1sL2luZGV4Lmh0bWw=" title="http://www.boost.org/doc/libs/1_56_0/libs/log/doc/html/index.html">Boost.Log<i class="fa fa-external-link"></i></span> ：设计非常模块化，并且具有扩展性</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Vhc3lsb2dnaW5nL2Vhc3lsb2dnaW5ncHA=" title="https://github.com/easylogging/easyloggingpp">easyloggingpp<i class="fa fa-external-link"></i></span>：C++日志库，只包含单一的头文件。</li><li><span class="exturl" data-url="aHR0cDovL2xvZzRjcHAuc291cmNlZm9yZ2UubmV0Lw==" title="http://log4cpp.sourceforge.net/">Log4cpp<i class="fa fa-external-link"></i></span> ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50ZW1wbG9nLm9yZy8=" title="http://www.templog.org/">templog<i class="fa fa-external-link"></i></span>：轻量级C++库，可以添加日志到你的C++应用程序中</li></ul><p>&nbsp;</p><h3>机器学习</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JWTEMvY2FmZmU=" title="https://github.com/BVLC/caffe">Caffe<i class="fa fa-external-link"></i></span> ：快速的神经网络框架</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdWxpdS9jY3Y=" title="https://github.com/liuliu/ccv">CCV<i class="fa fa-external-link"></i></span> ：以C语言为核心的现代计算机视觉库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tbHBhY2sub3JnLw==" title="http://www.mlpack.org/">mlpack<i class="fa fa-external-link"></i></span> ：可扩展的C++机器学习库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0l0c2Vlei9vcGVuY3Y=" title="https://github.com/Itseez/opencv">OpenCV<i class="fa fa-external-link"></i></span>：开源计算机视觉库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dIYW1yb3VuaS9SZWNvbW1lbmRlcg==" title="https://github.com/GHamrouni/Recommender">Recommender<i class="fa fa-external-link"></i></span>：使用协同过滤进行产品推荐/建议的C语言库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nob2d1bi10b29sYm94L3Nob2d1bg==" title="https://github.com/shogun-toolbox/shogun">SHOGUN<i class="fa fa-external-link"></i></span>：Shogun 机器学习工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9zb2ZpYS1tbC8=" title="https://code.google.com/p/sofia-ml/">sofia-ml<i class="fa fa-external-link"></i></span> ：用于机器学习的快速增量算法套件</li></ul><p>&nbsp;</p><h3>数学</h3><ul><li><span class="exturl" data-url="aHR0cDovL2FybWEuc291cmNlZm9yZ2UubmV0Lw==" title="http://arma.sourceforge.net/">Armadillo<i class="fa fa-external-link"></i></span> ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9ibGF6ZS1saWIv" title="https://code.google.com/p/blaze-lib/">blaze<i class="fa fa-external-link"></i></span>：高性能的C++数学库，用于密集和稀疏算法。</li><li><span class="exturl" data-url="aHR0cDovL2NlcmVzLXNvbHZlci5vcmcv" title="http://ceres-solver.org/">ceres-solver<i class="fa fa-external-link"></i></span> ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jZ2FsLm9yZy8=" title="http://www.cgal.org/">CGal<i class="fa fa-external-link"></i></span>： 高效，可靠的集合算法集合</li><li><span class="exturl" data-url="aHR0cDovL2NtbGRldi5uZXQv" title="http://cmldev.net/">cml<i class="fa fa-external-link"></i></span> ：用于游戏和图形的免费C++数学库</li><li><span class="exturl" data-url="aHR0cDovL2VpZ2VuLnR1eGZhbWlseS5vcmcv" title="http://eigen.tuxfamily.org/">Eigen<i class="fa fa-external-link"></i></span> ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。</li><li><span class="exturl" data-url="aHR0cDovL2dndC5zb3VyY2Vmb3JnZS5uZXQv" title="http://ggt.sourceforge.net/">GMTL<i class="fa fa-external-link"></i></span>：数学图形模板库是一组广泛实现基本图形的工具。</li><li><span class="exturl" data-url="aHR0cHM6Ly9nbXBsaWIub3JnLw==" title="https://gmplib.org/">GMP<i class="fa fa-external-link"></i></span>：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。</li></ul><p>&nbsp;</p><h3>多媒体</h3><ul><li><span class="exturl" data-url="aHR0cDovL2dzdHJlYW1lci5mcmVlZGVza3RvcC5vcmcv" title="http://gstreamer.freedesktop.org/">GStreamer<i class="fa fa-external-link"></i></span> ：构建媒体处理组件图形的库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saXZlNTU1LmNvbS9saXZlTWVkaWEv" title="http://www.live555.com/liveMedia/">LIVE555 Streaming Media<i class="fa fa-external-link"></i></span> ：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库</li><li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLnZpZGVvbGFuLm9yZy9MaWJWTEM=" title="https://wiki.videolan.org/LibVLC">libVLC<i class="fa fa-external-link"></i></span> ：libVLC (VLC SDK)媒体框架</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmctYmluL1F0QVY=" title="https://github.com/wang-bin/QtAV">QtAv<i class="fa fa-external-link"></i></span>：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWJzZGwub3JnLw==" title="http://www.libsdl.org/">SDL<i class="fa fa-external-link"></i></span> ：简单直控媒体层</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zZm1sLWRldi5vcmcv" title="http://www.sfml-dev.org/">SFML<i class="fa fa-external-link"></i></span> ：快速，简单的多媒体库</li></ul><p>&nbsp;</p><h3>网络</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcy53dXN0bC5lZHUvfnNjaG1pZHQvQUNFLmh0bWw=" title="http://www.cs.wustl.edu/~schmidt/ACE.html">ACE<i class="fa fa-external-link"></i></span>：C++面向对象网络变成工具包</li><li><span class="exturl" data-url="aHR0cDovL3RoaW5rLWFzeW5jLmNvbS8=" title="http://think-async.com/">Boost.Asio<i class="fa fa-external-link"></i></span>：用于网络和底层I/O编程的跨平台的C++库</li><li><span class="exturl" data-url="aHR0cDovL2Nhc2FibGFuY2EuY29kZXBsZXguY29tLw==" title="http://casablanca.codeplex.com/">Casablanca<i class="fa fa-external-link"></i></span>：C++ REST SDK</li><li><span class="exturl" data-url="aHR0cDovL2NwcC1uZXRsaWIub3JnLw==" title="http://cpp-netlib.org/">cpp-netlib<i class="fa fa-external-link"></i></span>：高级网络编程的开源库集合</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J4aS9keWFk" title="https://github.com/rxi/dyad">Dyad.c<i class="fa fa-external-link"></i></span>：C语言的异步网络</li><li><span class="exturl" data-url="aHR0cDovL2N1cmwuaGF4eC5zZS9saWJjdXJsLw==" title="http://curl.haxx.se/libcurl/">libcurl<i class="fa fa-external-link"></i></span> :多协议文件传输库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvbW9uZ29vc2U=" title="https://github.com/cesanta/mongoose">Mongoose<i class="fa fa-external-link"></i></span><span style="text-decoration: underline;">：</span>非常轻量级的网络服务器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZW5zaHVvL211ZHVv" title="https://github.com/chenshuo/muduo">Muduo<i class="fa fa-external-link"></i></span> ：用于Linux多线程服务器的C++非阻塞网络库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvbmV0X3NrZWxldG9u" title="https://github.com/cesanta/net_skeleton">net_skeleton<i class="fa fa-external-link"></i></span> ：C/C++的TCP 客户端/服务器库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Jpb2xldC9ub3BlLmM=" title="https://github.com/riolet/nope.c">nope.c<i class="fa fa-external-link"></i></span> ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhdmlkbW9yZW5vL29uaW9u" title="https://github.com/davidmoreno/onion">Onion<i class="fa fa-external-link"></i></span> :C语言HTTP服务器库，其设计为轻量级，易使用。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvY29wcm9qZWN0" title="https://github.com/pocoproject">POCO<i class="fa fa-external-link"></i></span>：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09jdWx1c1ZSL1Jha05ldA==" title="https://github.com/OculusVR/RakNet">RakNet<i class="fa fa-external-link"></i></span>：为游戏开发人员提供的跨平台的开源C++网络引擎。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Zpbmlwc21ha2VyL3R1ZmFv" title="https://github.com/vinipsmaker/tufao">Tuf o<i class="fa fa-external-link"></i></span> ：用于Qt之上的C++构建的异步Web框架。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3phcGhveWQvd2Vic29ja2V0cHA=" title="https://github.com/zaphoyd/websocketpp">WebSocket++<i class="fa fa-external-link"></i></span> ：基于C++/Boost Aiso的websocket 客户端/服务器库</li><li><span class="exturl" data-url="aHR0cDovL3plcm9tcS5vcmcv" title="http://zeromq.org/">ZeroMQ<i class="fa fa-external-link"></i></span> ：高速，模块化的异步通信库</li></ul><p>&nbsp;</p><h3>物理学</h3><p>动力学仿真引擎</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9ib3gyZC8=" title="https://code.google.com/p/box2d/">Box2D<i class="fa fa-external-link"></i></span>：2D的游戏物理引擎。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2J1bGxldHBoeXNpY3MvYnVsbGV0Mw==" title="https://github.com/bulletphysics/bullet3">Bullet<i class="fa fa-external-link"></i></span> ：3D的游戏物理引擎。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NsZW1iY2tlL0NoaXBtdW5rMkQ=" title="https://github.com/slembcke/Chipmunk2D">Chipmunk<i class="fa fa-external-link"></i></span> ：快速，轻量级的2D游戏物理库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9saXF1aWRmdW4=" title="https://github.com/google/liquidfun">LiquidFun<i class="fa fa-external-link"></i></span>：2D的游戏物理引擎</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vZGUub3JnLw==" title="http://www.ode.org/">ODE<i class="fa fa-external-link"></i></span> ：开放动力学引擎-开源，高性能库，模拟刚体动力学。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZhbmRlcmxpbi9vZnhCb3gyZA==" title="https://github.com/vanderlin/ofxBox2d">ofxBox2d<i class="fa fa-external-link"></i></span>：Box2D开源框架包装器。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpbWJvZHkvc2ltYm9keQ==" title="https://github.com/simbody/simbody">Simbody<i class="fa fa-external-link"></i></span> ：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。</li></ul><p>&nbsp;</p><h3>机器人学</h3><ul><li><span class="exturl" data-url="aHR0cDovL21vb3MtaXZwLm9yZy8=" title="http://moos-ivp.org/">MOOS-IvP<i class="fa fa-external-link"></i></span> ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tcnB0Lm9yZy8=" title="http://www.mrpt.org/">MRPT<i class="fa fa-external-link"></i></span>：移动机器人编程工具包</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BvaW50Q2xvdWRMaWJyYXJ5L3BjbA==" title="https://github.com/PointCloudLibrary/pcl">PCL<i class="fa fa-external-link"></i></span> ：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5yb2JvdGljc2xpYnJhcnkub3JnLw==" title="http://www.roboticslibrary.org/">Robotics Library (RL)<i class="fa fa-external-link"></i></span>： 一个独立的C++库，包括机器人动力学，运动规划和控制。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5yb2J3b3JrLmRrL2pyb2J3b3JrLw==" title="http://www.robwork.dk/jrobwork/">RobWork<i class="fa fa-external-link"></i></span>：一组C++库的集合，用于机器人系统的仿真和控制。</li><li><span class="exturl" data-url="aHR0cDovL3dpa2kucm9zLm9yZy8=" title="http://wiki.ros.org/">ROS<i class="fa fa-external-link"></i></span> ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。</li></ul><p>&nbsp;</p><h3>科学计算</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5mZnR3Lm9yZy8=" title="http://www.fftw.org/">FFTW<i class="fa fa-external-link"></i></span> :用一维或者多维计算DFT的C语言库。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2dzbC8=" title="http://www.gnu.org/software/gsl/">GSL<i class="fa fa-external-link"></i></span>：GNU科学库。</li></ul><p>&nbsp;</p><h3>脚本</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NoYWlTY3JpcHQvQ2hhaVNjcmlwdC8=" title="https://github.com/ChaiScript/ChaiScript/">ChaiScript<i class="fa fa-external-link"></i></span> ：用于C++的易于使用的嵌入式脚本语言。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5sdWEub3JnLw==" title="http://www.lua.org/">Lua<i class="fa fa-external-link"></i></span> ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhZnJpdG8vbHVhY3h4" title="https://github.com/dafrito/luacxx">luacxx<i class="fa fa-external-link"></i></span>：用于创建Lua绑定的C++ 11 API</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zd2lnLm9yZy8=" title="http://www.swig.org/">SWIG<i class="fa fa-external-link"></i></span> ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvdjc=" title="https://github.com/cesanta/v7">V7<i class="fa fa-external-link"></i></span>：嵌入式的JavaScript 引擎。</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4Lw==" title="http://code.google.com/p/v8/">V8<i class="fa fa-external-link"></i></span> ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。</li></ul><p>&nbsp;</p><h3>序列化</h3><ul><li><span class="exturl" data-url="aHR0cDovL2tlbnRvbnYuZ2l0aHViLmlvL2NhcG5wcm90by8=" title="http://kentonv.github.io/capnproto/">Cap&#8217;n Proto<i class="fa fa-external-link"></i></span> ：快速数据交换格式和RPC系统。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VTQ2lMYWIvY2VyZWFs" title="https://github.com/USCiLab/cereal">cereal<i class="fa fa-external-link"></i></span> ：C++11 序列化库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9mbGF0YnVmZmVycw==" title="https://github.com/google/flatbuffers">FlatBuffers<i class="fa fa-external-link"></i></span> ：内存高效的序列化库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21zZ3BhY2svbXNncGFjay1j" title="https://github.com/msgpack/msgpack-c">MessagePack<i class="fa fa-external-link"></i></span> ：C/C++的高效二进制序列化库，例如 JSON</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Byb3RvYnVmLw==" title="http://code.google.com/p/protobuf/">protobuf<i class="fa fa-external-link"></i></span> ：协议缓冲，谷歌的数据交换格式。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Byb3RvYnVmLWMvcHJvdG9idWYtYw==" title="https://github.com/protobuf-c/protobuf-c">protobuf-c<i class="fa fa-external-link"></i></span> ：C语言的协议缓冲实现</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlYWwtbG9naWMvc2ltcGxlLWJpbmFyeS1lbmNvZGluZw==" title="https://github.com/real-logic/simple-binary-encoding">SimpleBinaryEncoding<i class="fa fa-external-link"></i></span>：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。</li><li><span class="exturl" data-url="aHR0cHM6Ly90aHJpZnQuYXBhY2hlLm9yZy8=" title="https://thrift.apache.org/">Thrift<i class="fa fa-external-link"></i></span> ：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。</li></ul><p>&nbsp;</p><h3>视频</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy53ZWJtcHJvamVjdC5vcmcvY29kZS8=" title="http://www.webmproject.org/code/">libvpx<i class="fa fa-external-link"></i></span> ：VP8/VP9编码解码SDK</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZmZtcGVnLm9yZy8=" title="https://www.ffmpeg.org/">FFmpeg<i class="fa fa-external-link"></i></span> ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0cnVrdHVyYWcvbGliZGUyNjU=" title="https://github.com/strukturag/libde265">libde265<i class="fa fa-external-link"></i></span> ：开放的h.265视频编解码器的实现。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Npc2NvL29wZW5oMjY0" title="https://github.com/cisco/openh264">OpenH264<i class="fa fa-external-link"></i></span>：开源H.364 编解码器。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50aGVvcmEub3JnLw==" title="http://www.theora.org/">Theora<i class="fa fa-external-link"></i></span> ：免费开源的视频压缩格式。</li></ul><p>&nbsp;</p><h3>虚拟机</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rla2tub2xhZ2kvY2FycA==" title="https://github.com/tekknolagi/carp">CarpVM<i class="fa fa-external-link"></i></span>：C中有趣的VM，让我们一起来看看这个。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3JvcHl0aG9uL21pY3JvcHl0aG9u" title="https://github.com/micropython/micropython">MicroPython<i class="fa fa-external-link"></i></span> ：旨在实现单片机上Python3.x的实现</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pha29ndXQvdGlueXZt" title="https://github.com/jakogut/tinyvm">TinyVM<i class="fa fa-external-link"></i></span>：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。</li></ul><p>&nbsp;</p><h3>Web应用框架</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JlbDIxMjUvY2l2ZXR3ZWI=" title="https://github.com/bel2125/civetweb">Civetweb<i class="fa fa-external-link"></i></span> ：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。</li><li><span class="exturl" data-url="aHR0cDovL2NwcGNtcy5jb20v" title="http://cppcms.com/">CppCMS<i class="fa fa-external-link"></i></span> ：免费高性能的Web开发框架（不是 CMS）.</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lwa24vY3Jvdw==" title="https://github.com/ipkn/crow">Crow<i class="fa fa-external-link"></i></span> ：一个C++微型web框架（灵感来自于Python Flask）</li><li><span class="exturl" data-url="aHR0cHM6Ly9rb3JlLmlvLw==" title="https://kore.io/">Kore<i class="fa fa-external-link"></i></span> :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb3JhbGJpdHMuY29tL2xpYm9uaW9uLw==" title="http://www.coralbits.com/libonion/">libOnion<i class="fa fa-external-link"></i></span>：轻量级的库，帮助你使用C编程语言创建web服务器。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2psYWluZS9xZGphbmdvLw==" title="https://github.com/jlaine/qdjango/">QDjango<i class="fa fa-external-link"></i></span>：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy53ZWJ0b29sa2l0LmV1L3d0" title="http://www.webtoolkit.eu/wt">Wt<i class="fa fa-external-link"></i></span> ：开发Web应用的C++库。</li></ul><p>&nbsp;</p><h3>XML</h3><p>XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWJleHBhdC5vcmcv" title="http://www.libexpat.org/">Expat<i class="fa fa-external-link"></i></span> ：用C语言编写的xml解析库</li><li><span class="exturl" data-url="aHR0cDovL3htbHNvZnQub3JnLw==" title="http://xmlsoft.org/">Libxml2<i class="fa fa-external-link"></i></span> ：Gnome的xml C解析器和工具包</li><li><span class="exturl" data-url="aHR0cDovL2xpYnhtbHBsdXNwbHVzLnNvdXJjZWZvcmdlLm5ldC8=" title="http://libxmlplusplus.sourceforge.net/">libxml++<i class="fa fa-external-link"></i></span> ：C++的xml解析器</li><li><span class="exturl" data-url="aHR0cDovL3B1Z2l4bWwub3JnLw==" title="http://pugixml.org/">PugiXML<i class="fa fa-external-link"></i></span> ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。</li><li><span class="exturl" data-url="aHR0cDovL3JhcGlkeG1sLnNvdXJjZWZvcmdlLm5ldC8=" title="http://rapidxml.sourceforge.net/">RapidXml<i class="fa fa-external-link"></i></span> ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy90aW55eG1sLw==" title="http://sourceforge.net/projects/tinyxml/">TinyXML<i class="fa fa-external-link"></i></span> ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlZXRob21hc29uL3Rpbnl4bWwy" title="https://github.com/leethomason/tinyxml2">TinyXML2<i class="fa fa-external-link"></i></span>：简单快速的C++CML解析器，可以很容易集成到其它项目中。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC90aWNwcC8=" title="https://code.google.com/p/ticpp/">TinyXML++<i class="fa fa-external-link"></i></span>：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</li><li><span class="exturl" data-url="aHR0cDovL3hlcmNlcy5hcGFjaGUub3JnL3hlcmNlcy1jLw==" title="http://xerces.apache.org/xerces-c/">Xerces-C++<i class="fa fa-external-link"></i></span> ：用可移植的C++的子集编写的XML验证解析器。</li></ul><p>&nbsp;</p><h3>多项混杂</h3><p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NwcGZvcm1hdC9jcHBmb3JtYXQ=" title="https://github.com/cppformat/cppformat">C++ Format<i class="fa fa-external-link"></i></span> ：C++的小型，安全和快速格式化库</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jYXNhY29yZS8=" title="https://code.google.com/p/casacore/">casacore<i class="fa fa-external-link"></i></span> ：从aips++ 派生的一系列C++核心库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xvdWlzZHgvY3h4LXByZXR0eXByaW50" title="https://github.com/louisdx/cxx-prettyprint">cxx-prettyprint<i class="fa fa-external-link"></i></span>：用于C++容器的打印库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5keW5hZm9ybXMuY29tLw==" title="http://www.dynaforms.com/">DynaPDF<i class="fa fa-external-link"></i></span> ：易于使用的PDF生成库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlYWZzci9nY2MtcG9pc29u" title="https://github.com/leafsr/gcc-poison">gcc-poison<i class="fa fa-external-link"></i></span> ：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZW1vY2sv" title="http://code.google.com/p/googlemock/">googlemock<i class="fa fa-external-link"></i></span>：编写和使用C++模拟类的库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9odHRwLXBhcnNlcg==" title="https://github.com/joyent/http-parser">HTTP Parser<i class="fa fa-external-link"></i></span> ：C的http请求/响应解析器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FucmllZmYvbGliY3B1aWQ=" title="https://github.com/anrieff/libcpuid">libcpuid<i class="fa fa-external-link"></i></span> ：用于x86 CPU检测盒特征提取的小型C库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F2YXRpL2xpYmV2aWw=" title="https://github.com/avati/libevil">libevil<i class="fa fa-external-link"></i></span> ：许可证管理器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWJ1c2Iub3JnLw==" title="http://www.libusb.org/">libusb<i class="fa fa-external-link"></i></span>：允许移动访问USB设备的通用USB库</li><li><span class="exturl" data-url="aHR0cDovL3BjcmUub3JnLw==" title="http://pcre.org/">PCRE<i class="fa fa-external-link"></i></span>：正则表达式C库，灵感来自于Perl中正则表达式的功能。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5kZWx0YXZzb2Z0LmNvbS8=" title="http://www.deltavsoft.com/">Remote Call Framework<i class="fa fa-external-link"></i></span> ：C++的进程间通信框架。</li><li><span class="exturl" data-url="aHR0cDovL3NjaW50aWxsYS5vcmcv" title="http://scintilla.org/">Scintilla<i class="fa fa-external-link"></i></span> ：开源的代码编辑控件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dqd3dvb2Qvc2VyaWFs" title="https://github.com/wjwwood/serial">Serial Communication Library<i class="fa fa-external-link"></i></span> ：C++语言编写的跨平台，串口库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FudGlyZXovc2Rz" title="https://github.com/antirez/sds">SDS<i class="fa fa-external-link"></i></span>：C的简单动态字符串库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvc2xkcg==" title="https://github.com/cesanta/sldr">SLDR<i class="fa fa-external-link"></i></span> ：超轻的DNS解析器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvc2xyZQ==" title="https://github.com/cesanta/slre">SLRE<i class="fa fa-external-link"></i></span>： 超轻的正则表达式库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J0di9TdGFnZQ==" title="https://github.com/rtv/Stage">Stage<i class="fa fa-external-link"></i></span> ：移动机器人模拟器</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92YXJ0eXBlcy8=" title="https://code.google.com/p/vartypes/">VarTypes<i class="fa fa-external-link"></i></span>：C++/Qt4功能丰富，面向对象的管理变量的框架。</li><li><span class="exturl" data-url="aHR0cDovL3piYXIuc291cmNlZm9yZ2UubmV0Lw==" title="http://zbar.sourceforge.net/">ZBar<i class="fa fa-external-link"></i></span>：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZlcmJhbEV4cHJlc3Npb25zL0NwcFZlcmJhbEV4cHJlc3Npb25z" title="https://github.com/VerbalExpressions/CppVerbalExpressions">CppVerbalExpressions<i class="fa fa-external-link"></i></span> ：易于使用的C++正则表达式</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZlcmJhbEV4cHJlc3Npb25zL1F0VmVyYmFsRXhwcmVzc2lvbnM=" title="https://github.com/VerbalExpressions/QtVerbalExpressions">QtVerbalExpressions<i class="fa fa-external-link"></i></span>：基于C++ VerbalExpressions 库的Qt库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvcGVybmljYU1hcmtldGluZ1NvZnR3YXJlL1BIUC1DUFA=" title="https://github.com/CopernicaMarketingSoftware/PHP-CPP">PHP-CPP<i class="fa fa-external-link"></i></span>：使用C++来构建PHP扩展的库</li><li><span class="exturl" data-url="aHR0cDovL2JzdHJpbmcuc291cmNlZm9yZ2UubmV0Lw==" title="http://bstring.sourceforge.net/">Better String<i class="fa fa-external-link"></i></span> ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。</li></ul><p>&nbsp;</p><h3>软件</h3><p>用于创建开发环境的软件</p><h3>编译器</h3><p>C/C++编译器列表</p><ul><li><span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnLw==" title="http://clang.llvm.org/">Clang<i class="fa fa-external-link"></i></span> :由苹果公司开发的</li><li><span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy8=" title="https://gcc.gnu.org/">GCC<i class="fa fa-external-link"></i></span>：GNU编译器集合</li><li><span class="exturl" data-url="aHR0cHM6Ly9zb2Z0d2FyZS5pbnRlbC5jb20vZW4tdXMvYy1jb21waWxlcnM=" title="https://software.intel.com/en-us/c-compilers">Intel C++ Compiler<i class="fa fa-external-link"></i></span> ：由英特尔公司开发</li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnLw==" title="http://llvm.org/">LLVM<i class="fa fa-external-link"></i></span> ：模块化和可重用编译器和工具链技术的集合</li><li><span class="exturl" data-url="aHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy92c3R1ZGlvL2hoMzg2MzAyLmFzcHg=" title="http://msdn.microsoft.com/en-us/vstudio/hh386302.aspx">Microsoft Visual C++<i class="fa fa-external-link"></i></span> ：MSVC，由微软公司开发</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVud2F0Y29tLm9yZy9pbmRleC5waHAvTWFpbl9QYWdl" title="http://www.openwatcom.org/index.php/Main_Page">Open WatCom<i class="fa fa-external-link"></i></span> ：Watcom，C，C++和Fortran交叉编译器和工具</li><li><span class="exturl" data-url="aHR0cDovL2JlbGxhcmQub3JnL3RjYy8=" title="http://bellard.org/tcc/">TCC<i class="fa fa-external-link"></i></span> ：轻量级的C语言编译器</li></ul><p>&nbsp;</p><h3>在线编译器</h3><p>在线C/C++编译器列表</p><ul><li><span class="exturl" data-url="aHR0cDovL2NvZGVwYWQub3JnLw==" title="http://codepad.org/">codepad<i class="fa fa-external-link"></i></span> ：在线编译器/解释器，一个简单的协作工具</li><li><span class="exturl" data-url="aHR0cDovL2NvZGV0d2lzdC5jb20v" title="http://codetwist.com/">CodeTwist<i class="fa fa-external-link"></i></span>：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果</li><li><span class="exturl" data-url="aHR0cDovL2NvbGlydS5zdGFja2VkLWNyb29rZWQuY29tLw==" title="http://coliru.stacked-crooked.com/">coliru<i class="fa fa-external-link"></i></span> ：在线编译器/shell， 支持各种C++编译器</li><li><span class="exturl" data-url="aHR0cDovL2djYy5nb2Rib2x0Lm9yZy8=" title="http://gcc.godbolt.org/">Compiler Explorer<i class="fa fa-external-link"></i></span>：交互式编译器，可以进行汇编输出</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb21waWxlb25saW5lLmNvbS9jb21waWxlX2NwcDExX29ubGluZS5waHA=" title="http://www.compileonline.com/compile_cpp11_online.php">CompileOnline<i class="fa fa-external-link"></i></span>：Linux上在线编译和执行C++程序</li><li><span class="exturl" data-url="aHR0cDovL2lkZW9uZS5jb20v" title="http://ideone.com/">Ideone<i class="fa fa-external-link"></i></span> ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。</li></ul><p>&nbsp;</p><h3>调试器</h3><p>C/C++调试器列表</p><ul><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21wYXJpc29uX29mX2RlYnVnZ2Vycw==" title="http://en.wikipedia.org/wiki/Comparison_of_debuggers">Comparison of debuggers<i class="fa fa-external-link"></i></span> ：来自维基百科的调试器列表</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9nZGI=" title="https://www.gnu.org/software/gdb">GDB<i class="fa fa-external-link"></i></span> ：GNU调试器</li><li><span class="exturl" data-url="aHR0cDovL3ZhbGdyaW5kLm9yZy8=" title="http://valgrind.org/">Valgrind<i class="fa fa-external-link"></i></span>：内存调试，内存泄露检测，性能分析工具。</li></ul><p>&nbsp;</p><h3>集成开发环境（IDE）</h3><p>C/C++集成开发环境列表</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5qZXRicmFpbnMuY29tL29iamMv" title="http://www.jetbrains.com/objc/">AppCode<i class="fa fa-external-link"></i></span> ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5qZXRicmFpbnMuY29tL2NsaW9uLw==" title="http://www.jetbrains.com/clion/">CLion<i class="fa fa-external-link"></i></span>：来自JetBrains的跨平台的C/C++的集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2RlYmxvY2tzLm9yZy8=" title="http://www.codeblocks.org/">Code::Blocks<i class="fa fa-external-link"></i></span> ：免费C，C++和Fortran的集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL2NvZGVsaXRlLm9yZy8=" title="http://codelite.org/">CodeLite<i class="fa fa-external-link"></i></span> ：另一个跨平台的免费的C/C++集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy9vcndlbGxkZXZjcHAv" title="http://sourceforge.net/projects/orwelldevcpp/">Dev-C++<i class="fa fa-external-link"></i></span>：可移植的C/C++/C++11集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lY2xpcHNlLm9yZy9jZHQv" title="http://www.eclipse.org/cdt/">Eclipse CDT<i class="fa fa-external-link"></i></span>：基于Eclipse平台的功能齐全的C和C++集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nZWFueS5vcmcv" title="http://www.geany.org/">Geany<i class="fa fa-external-link"></i></span> ：轻量级的快速，跨平台的集成开发环境。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy0wMy5pYm0uY29tL3NvZnR3YXJlL3Byb2R1Y3RzL2VuL3Zpc2dlbg==" title="http://www-03.ibm.com/software/products/en/visgen">IBM VisualAge<i class="fa fa-external-link"></i></span> ：来自IBM的家庭计算机集成开发环境。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NhcmNhc20vaXJvbnktbW9kZQ==" title="https://github.com/Sarcasm/irony-mode">Irony-mode<i class="fa fa-external-link"></i></span>：由libclang驱动的用于Emacs的C/C++微模式</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2RldmVsb3Aub3JnLw==" title="https://www.kdevelop.org/">KDevelop<i class="fa fa-external-link"></i></span>：免费开源集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy52aXN1YWxzdHVkaW8uY29tLw==" title="http://www.visualstudio.com/">Microsoft Visual Studio<i class="fa fa-external-link"></i></span> ：来自微软的集成开发环境</li><li><span class="exturl" data-url="aHR0cHM6Ly9uZXRiZWFucy5vcmcv" title="https://netbeans.org/">NetBeans<i class="fa fa-external-link"></i></span> ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。</li><li><span class="exturl" data-url="aHR0cDovL3F0LXByb2plY3Qub3JnLw==" title="http://qt-project.org/">Qt Creator<i class="fa fa-external-link"></i></span>：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FuZGVyc2Jha2tlbi9ydGFncw==" title="https://github.com/Andersbakken/rtags">rtags<i class="fa fa-external-link"></i></span>：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成</li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3hjb2RlLw==" title="https://developer.apple.com/xcode/">Xcode<i class="fa fa-external-link"></i></span> ：由苹果公司开发</li><li><span class="exturl" data-url="aHR0cHM6Ly92YWxsb3JpYy5naXRodWIuaW8vWW91Q29tcGxldGVNZS8=" title="https://valloric.github.io/YouCompleteMe/">YouCompleteMe<i class="fa fa-external-link"></i></span>：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</li></ul><p>&nbsp;</p><h3>构建系统</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JpenNvdHRvL0JlYXI=" title="https://github.com/rizsotto/Bear">Bear<i class="fa fa-external-link"></i></span> ：用于为clang工具生成编译数据库的工具</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlpY29kZS5jb20v" title="https://www.biicode.com/">Biicode<i class="fa fa-external-link"></i></span>：基于文件的简单依赖管理器。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbWFrZS5vcmcv" title="http://www.cmake.org/">CMake<i class="fa fa-external-link"></i></span> ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lhdW5zL2NwbQ==" title="https://github.com/iauns/cpm">CPM<i class="fa fa-external-link"></i></span>：基于CMake和Git的C++包管理器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5mYXN0YnVpbGQub3JnL2RvY3MvaG9tZS5odG1s" title="http://www.fastbuild.org/docs/home.html">FASTBuild<i class="fa fa-external-link"></i></span>：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</li><li><span class="exturl" data-url="aHR0cDovL21hcnRpbmUuZ2l0aHViLmlvL25pbmphLw==" title="http://martine.github.io/ninja/">Ninja<i class="fa fa-external-link"></i></span> ：专注于速度的小型构建系统</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zY29ucy5vcmcv" title="http://www.scons.org/">Scons<i class="fa fa-external-link"></i></span> ：使用Python scipt 配置的软件构建工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RlcGxpbmVub2lzZS90dW5kcmE=" title="https://github.com/deplinenoise/tundra">tundra<i class="fa fa-external-link"></i></span> ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</li><li><span class="exturl" data-url="aHR0cDovL2dpdHR1cC5vcmcvdHVwLw==" title="http://gittup.org/tup/">tup<i class="fa fa-external-link"></i></span>：基于文件的构建系统，用于后台监控变化的文件。</li></ul><p>&nbsp;</p><h3>静态代码分析</h3><p>提高质量，减少瑕疵的代码分析工具列表</p><ul><li><span class="exturl" data-url="aHR0cDovL2NwcGNoZWNrLnNvdXJjZWZvcmdlLm5ldC8=" title="http://cppcheck.sourceforge.net/">Cppcheck<i class="fa fa-external-link"></i></span> ：静态C/C++代码分析工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9pbmNsdWRlLXdoYXQteW91LXVzZS8=" title="https://code.google.com/p/include-what-you-use/">include-what-you-use<i class="fa fa-external-link"></i></span> ：使用clang进行代码分析的工具，可以#include在C和C++文件中。</li><li><span class="exturl" data-url="aHR0cDovL29jbGludC5vcmcv" title="http://oclint.org/">OCLint<i class="fa fa-external-link"></i></span> ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</li><li><span class="exturl" data-url="aHR0cDovL2NsYW5nLWFuYWx5emVyLmxsdm0ub3JnL2luZGV4Lmh0bWw=" title="http://clang-analyzer.llvm.org/index.html">Clang Static Analyzer<i class="fa fa-external-link"></i></span>：查找C，C++和Objective-C程序bug的源代码分析工具</li><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX3Rvb2xzX2Zvcl9zdGF0aWNfY29kZV9hbmFseXNpcyNDLjJGQy4yQi4yQg==" title="http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2FC.2B.2B">List of tools for static code analysis<i class="fa fa-external-link"></i></span> ：来自维基百科的静态代码分析工具列表</li></ul><p>感谢平凡之路和fffaraz 的整理，转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>计算机相关技术资料整理</title>
    <link href="http://miaopei.github.io/2018/05/13/practical-programming-books/README/"/>
    <id>http://miaopei.github.io/2018/05/13/practical-programming-books/README/</id>
    <published>2018-05-13T02:14:50.000Z</published>
    <updated>2019-06-14T03:34:11.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VaTGlwcGkvcHJhY3RpY2FsLXByb2dyYW1taW5nLWJvb2tz" title="https://github.com/EZLippi/practical-programming-books">文章来源<i class="fa fa-external-link"></i></span></p></blockquote><p>这里收录比较实用的计算机相关技术书籍，可以在短期之内入门的简单实用教程、一些技术网站以及一些写的比较好的博文，欢迎Fork，你也可以通过Pull Request参与编辑。</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5lemxpcHBpLmNvbS9ibG9nLzIwMTQvMDcvcXVhbGlmaWVkLXByb2dyYW1tZXItc2hvdWxkLXJlYWQtd2hhdC1ib29rcy5odG1s" title="http://www.ezlippi.com/blog/2014/07/qualified-programmer-should-read-what-books.html">程序员必读书籍<i class="fa fa-external-link"></i></span></li></ul><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="#语言相关类">语言相关类</a></p><ul><li><a href="#android">Android</a></li><li><a href="#awk">AWK</a></li><li><a href="#SED">SED</a></li><li><a href="#cc">C/C++</a></li><li><a href="#css">CSS/HTML</a></li><li><a href="#dart">Dart</a></li><li><a href="#erlang">Erlang</a></li><li><a href="#fortran">Fortran</a></li><li><a href="#go">Go</a></li><li><a href="#groovy">Groovy</a></li><li><a href="#haskell">Haskell</a></li><li><a href="#ios">iOS</a></li><li><a href="#java">Java</a></li><li><a href="#javascript">JavaScript</a></li><li><a href="#latex">LaTeX</a></li><li><a href="#lisp">LISP</a></li><li><a href="#lua">Lua</a></li><li><a href="#perl">Perl</a></li><li><a href="#php">PHP</a></li><li><a href="#prolog">Prolog</a></li><li><a href="#python">Python</a></li><li><a href="#r">R</a></li><li><a href="#ruby">Ruby</a></li><li><a href="#scala">Scala</a></li><li><a href="#scheme">Scheme</a></li><li><a href="#shell">Shell</a></li><li><a href="#swift">Swift</a></li><li><a href="#webassembly">WebAssembly</a></li></ul></li><li><p><a href="#语言无关类">语言无关类</a></p><ul><li><a href="#操作系统">操作系统</a></li><li><a href="#版本控制">版本控制</a></li><li><a href="#分布式系统">分布式系统</a></li><li><a href="#编辑器">编辑器</a></li><li><a href="#nosql">NoSQL</a></li><li><a href="#mysql">MySQL</a></li><li><a href="#postgresql">PostgreSQL</a></li><li><a href="#项目相关">项目相关</a></li><li><a href="#设计模式">设计模式</a></li><li><a href="#web">Web</a></li><li><a href="#大数据">大数据</a></li><li><a href="#编程艺术">编程艺术</a></li><li><a href="#函数式编程">函数式编程</a></li><li><a href="#运维监控">运维监控</a></li><li><a href="#web服务器">WEB服务器</a></li></ul></li></ul><h2 id="语言无关类"><a href="#语言无关类" class="headerlink" title="语言无关类"></a>语言无关类</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><span class="exturl" data-url="aHR0cDovL2kubGludXh0b3kub3JnL2RvY3MvZ3VpZGUvaW5kZXguaHRtbA==" title="http://i.linuxtoy.org/docs/guide/index.html">开源世界旅行手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3ZiaXJkLmRpYy5rc3UuZWR1LnR3Lw==" title="http://vbird.dic.ksu.edu.tw/">鸟哥的Linux私房菜<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9hcHBzL3RyYWMvZWxwaS93aWtpL0FMUA==" title="http://sourceforge.net/apps/trac/elpi/wiki/ALP">Linux 系统高级编程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpZHlqaWFuZzgvemVwaHlyLWRvYw==" title="https://github.com/tidyjiang8/zephyr-doc">Zephyr OS 中文文档<i class="fa fa-external-link"></i></span>(v1.6.0)</li><li><span class="exturl" data-url="aHR0cDovL2JpbGxpZTY2LmdpdGh1Yi5pby9UTENML2luZGV4Lmh0bWw=" title="http://billie66.github.io/TLCL/index.html">The Linux Command Line<i class="fa fa-external-link"></i></span> (中英文版)</li><li><span class="exturl" data-url="aHR0cDovL29zcy5vcmcuY24va2VybmVsLWJvb2svbGRkMy9pbmRleC5odG1s" title="http://oss.org.cn/kernel-book/ldd3/index.html">Linux 设备驱动<i class="fa fa-external-link"></i></span> (第三版)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rZXJuZWx0cmF2ZWwubmV0L2tlcm5lbC1ib29rLyVFNiVCNyVCMSVFNSU4NSVBNSVFNSU4OCU4NiVFNiU5RSU5MExpbnV4JUU1JTg2JTg1JUU2JUEwJUI4JUU2JUJBJTkwJUU3JUEwJTgxLmh0bWw=" title="http://www.kerneltravel.net/kernel-book/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81.html">深入分析Linux内核源码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2NiLnZ1L3VuaXh0b29sYm94X3poX0NOLnhodG1s" title="http://cb.vu/unixtoolbox_zh_CN.xhtml">UNIX TOOLBOX<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpZHV1L2NoaW5lc2VfZG9ja2Vy" title="https://github.com/widuu/chinese_docker">Docker中文指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3llYXN5L2RvY2tlcl9wcmFjdGljZQ==" title="https://github.com/yeasy/docker_practice">Docker —— 从入门到实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3l1ZWR1LmJhaWR1LmNvbS9lYm9vay9kODE3OTY3NDE2ZmM3MDBhYmI2OGZjYTE=" title="http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1">Docker入门实战<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dzYXJnZW50L2RvY2tlci1jaGVhdC1zaGVldC90cmVlL21hc3Rlci96aC1jbiNkb2NrZXItY2hlYXQtc2hlZXQ=" title="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn#docker-cheat-sheet">Docker Cheat Sheet<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZyZWVyYWRpdXMuYWthZ2kyMDEub3Jn" title="http://freeradius.akagi201.org">FreeRADIUS新手入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hYWFhYWFzaHUuZ2l0Ym9va3MuaW8vbWFjLWRldi1zZXR1cC9jb250ZW50Lw==" title="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/">Mac 开发配置手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJzZC5vcmcvZG9jL3poX0NOL2Jvb2tzL2hhbmRib29rL2luZGV4Lmh0bWw=" title="https://www.freebsd.org/doc/zh_CN/books/handbook/index.html">FreeBSD 使用手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2JpbGxpZTY2LmdpdGh1Yi5pby9UTENML2Jvb2sv" title="http://billie66.github.io/TLCL/book/">Linux 命令行(中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dvcmtzLmppbmJ1Z3VvLmNvbS9sZnMvbGZzNjIvaW5kZXguaHRtbA==" title="http://works.jinbuguo.com/lfs/lfs62/index.html">Linux 构建指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lMTE1L2xpbnV4dG9vbHNfcnN0" title="https://github.com/me115/linuxtools_rst">Linux工具快速教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay90aW55bGFiL2xpbnV4LWRvYy9kZXRhaWxz" title="https://www.gitbook.com/book/tinylab/linux-doc/details">Linux Documentation (中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay90aW55bGFiL2VsaW51eC9kZXRhaWxz" title="https://www.gitbook.com/book/tinylab/elinux/details">嵌入式 Linux 知识库 (eLinux.org 中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvYmVnaXQzaHViL3VuZGVyc3RhbmRfbGludXhfcHJvY2Vzcw==" title="https://github.com/tobegit3hub/understand_linux_process">理解Linux进程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J5YW56ei9MRlMtc3lzdGVtZC16aF9DTg==" title="https://github.com/ryanzz/LFS-systemd-zh_CN">Linux From Scratch systemd 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjLzMwLW1pbnV0ZXMtdG8tbGVhcm4tcmVnZXgubWQ=" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/30-minutes-to-learn-regex.md">55分钟学会正则表达式<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3VzZS1saW51eC5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/use-linux.md">每个Linux用户都应该知道的命令行技巧<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL21lbW9yeS5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/memory.md">每个程序员都应该了解的内存知识<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2NwdS1jYWNoZS5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/cpu-cache.md">每个程序员都应该了解的CPU缓存知识<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3ZpcnR1YWwtbWVtb3J5Lm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/virtual-memory.md">每个程序员都应该了解的虚拟内存知识<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cDovL2JpbGxpZTY2LmdpdGJvb2tzLmlvL3RsY2wtY24vY29udGVudC8=" title="http://billie66.gitbooks.io/tlcl-cn/content/">shell脚本教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb21tYW5kbGluZWZ1LmNvbS9jb21tYW5kcy9tYXRjaGluZy9scy9iSE09L3NvcnQtYnktdm90ZXM=" title="http://www.commandlinefu.com/commands/matching/ls/bHM=/sort-by-votes">查找命令行的网站<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWJ1bGFyLmNvbS8=" title="http://www.rubular.com/">正则表达式在线测试<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lemxpcHBpLmNvbS9ibG9nLzIwMTcvMDIvc3MtcHJveHktZ3VpZGUuaHRtbA==" title="http://www.ezlippi.com/blog/2017/02/ss-proxy-guide.html">科学上网<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><ul><li><span class="exturl" data-url="aHR0cDovL2RjYW95dWFuLmdpdGh1Yi5pby9wYXBlcnMvcGRmcy9TY2FsYWJpbGl0eS5wZGY=" title="http://dcaoyuan.github.io/papers/pdfs/Scalability.pdf">走向分布式<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1c3RpbnlodWFuZy9GdW5jdGlvbmFsLVByb2dyYW1taW5nLUZvci1UaGUtUmVzdC1vZi1Vcy1Dbg==" title="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn">傻瓜函数编程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><ul><li><span class="exturl" data-url="aHR0cDovL3RlbmdpbmUudGFvYmFvLm9yZy9ib29rL2luZGV4Lmh0bWw=" title="http://tengine.taobao.org/book/index.html">Nginx开发从入门到精通<i class="fa fa-external-link"></i></span> (淘宝团队出品)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50dGxzYS5jb20vbmdpbngvbmdpbngtc3R1LXBkZi8=" title="http://www.ttlsa.com/nginx/nginx-stu-pdf/">Nginx教程从入门到精通<i class="fa fa-external-link"></i></span>(PDF版本，运维生存时间出品)</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9tb29uYmluZ2Jpbmcvb3BlbnJlc3R5LWJlc3QtcHJhY3RpY2VzL2RldGFpbHM=" title="https://www.gitbook.com/book/moonbingbing/openresty-best-practices/details">OpenResty最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dvcmtzLmppbmJ1Z3VvLmNvbS9hcGFjaGUvbWVudTIyL2luZGV4Lmh0bWw=" title="http://works.jinbuguo.com/apache/menu22/index.html">Apache 中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xvb2x5LmdpdGJvb2tzLmlvL2VsYXN0aWNzZWFyY2gtdGhlLWRlZmluaXRpdmUtZ3VpZGUtY24v" title="http://looly.gitbooks.io/elasticsearch-the-definitive-guide-cn/">Elasticsearch权威指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2hvdy1zdGFja292ZXJmbG93LXdvcmtzLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/how-stackoverflow-works.md">25 台服务器是怎样支撑 StackOverflow 的？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3BpY3R1cmUtc2VydmVyLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/picture-server.md">图片服务架构演进（孔凡勇）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2xvZ2dpbmcubWQ=" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/logging.md">最佳日志实践（王健）<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDEzNzM5NTE2MzA1OTI5NjA2ZGQxODM2MTI0ODU3OGM2N2I4MDY3YzhjMDE3YjAwMA==" title="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cDovL3JvZ2VyZHVkbGVyLmdpdGh1Yi5pby9naXQtZ3VpZGUvaW5kZXguemguaHRtbA==" title="http://rogerdudler.github.io/git-guide/index.zh.html">git简易指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2JhY2tsb2d0b29sLmNvbS9naXQtZ3VpZGUvY24v" title="http://backlogtool.com/git-guide/cn/">猴子都能懂的GIT入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpdHJlZi5qdXN0amF2YWMuY29t" title="http://gitref.justjavac.com">Git 参考手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpdC1zY20uY29tL2Jvb2svemgvdjI=" title="http://git-scm.com/book/zh/v2">Pro Git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay8wNTMyL3Byb2dpdC9kZXRhaWxz" title="https://www.gitbook.com/book/0532/progit/details">Pro Git 中文版<i class="fa fa-external-link"></i></span> (整理在gitbook上)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy1jcy1zdHVkZW50cy5zdGFuZm9yZC5lZHUvfmJseW5uL2dpdG1hZ2ljL2ludGwvemhfY24v" title="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Git Magic<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53b3JsZGhlbGxvLm5ldC9nb3RnaXRodWIvaW5kZXguaHRtbA==" title="http://www.worldhello.net/gotgithub/index.html">GotGitHub<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53b3JsZGhlbGxvLm5ldC9nb3RnaXQv" title="http://www.worldhello.net/gotgit/">Git权威指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpdGJvb2subGl1aHVpOTk4LmNvbS9pbmRleC5odG1s" title="http://gitbook.liuhui998.com/index.html">Git Community Book 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWVyY3VyaWFsLXNjbS5vcmcvd2lraS9DaGluZXNlVHV0b3JpYWw=" title="https://www.mercurial-scm.org/wiki/ChineseTutorial">Mercurial 使用教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2J1Y3VuemFpLm5ldC9oZ2luaXQv" title="http://bucunzai.net/hginit/">HgInit (中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lnaXQubGludXh0b3kub3JnLw==" title="http://igit.linuxtoy.org/">沉浸式学 Git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZseWhpZ2hlcjEzOS9HaXQtQ2hlYXQtU2hlZXQ=" title="https://github.com/flyhigher139/Git-Cheat-Sheet">Git-Cheat-Sheet<i class="fa fa-external-link"></i></span> （感谢 @flyhigher139 翻译了中文版）</li><li><span class="exturl" data-url="aHR0cDovL3Nub3dkcmVhbTg2LmdpdGJvb2tzLmlvL2dpdGh1Yi1jaGVhdC1zaGVldC9jb250ZW50L3poL2luZGV4Lmh0bWw=" title="http://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/index.html">GitHub秘籍<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9naXRodWItaGVscA==" title="https://github.com/waylau/github-help">Github帮助文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RhbmllbGt1bW1lci5naXRodWIuaW8vZ2l0LWZsb3ctY2hlYXRzaGVldC9pbmRleC56aF9DTi5odG1s" title="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git-flow 备忘清单<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3N2bmJvb2sucmVkLWJlYW4uY29tL25pZ2h0bHkvemgvaW5kZXguaHRtbA==" title="http://svnbook.red-bean.com/nightly/zh/index.html">svn 手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Bob2RhbC9naXRodWItcm9hbQ==" title="https://github.com/phodal/github-roam">GitHub漫游指南<i class="fa fa-external-link"></i></span></li></ul><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><span class="exturl" data-url="aHR0cDovL2V4dmltLmdpdGh1Yi5pby9kb2NzLXpoL2ludHJvLw==" title="http://exvim.github.io/docs-zh/intro/">exvim–vim 改良成IDE项目<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xlYXJudmltc2NyaXB0dGhlaGFyZHdheS5vbmVmbG93ZXJvbmV3b3JsZC5jb20v" title="http://learnvimscriptthehardway.onefloweroneworld.com/">笨方法学Vimscript 中译本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZpbWNuL3ZpbWNkb2M=" title="https://github.com/vimcn/vimcdoc">Vim中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhbmd5YW5nd2l0aGdudS91c2VfdmltX2FzX2lkZQ==" title="https://github.com/yangyangwithgnu/use_vim_as_ide">所需即所获：像 IDE 一样使用 vim<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja2VkaXQuaW8vIw==" title="https://stackedit.io/#">在线MarkDown编辑<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3ZpbS5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/vim.md">简明VIM练级攻略<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5waHAxMDAuY29tL21hbnVhbC9NeVNRTC8=" title="http://www.php100.com/manual/MySQL/">MySQL中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3NxbC5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/sql.md">十步完全理解SQL<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9sZW9vMnNrL2FyY2hpdmUvMjAxMS8wNy8xMC9teXNxbC1pbmRleC5odG1s" title="http://www.cnblogs.com/leoo2sk/archive/2011/07/10/mysql-index.html">MySQL索引背后的数据结构及算法原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9tci13aWQvYXJjaGl2ZS8yMDEzLzA1LzA5LzMwNjgyMjkuaHRtbA==" title="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html">21分钟MySQL入门教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><ul><li><span class="exturl" data-url="aHR0cDovL29sZC5zZWJ1Zy5uZXQvcGFwZXIvZGF0YWJhc2VzL25vc3FsL05vc3FsLmh0bWw=" title="http://old.sebug.net/paper/databases/nosql/Nosql.html">NoSQL数据库笔谈<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3JlZGlzYm9vay5jb20v" title="http://redisbook.com/">Redis 设计与实现<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3JlZGlzZG9jLmNvbS8=" title="http://redisdoc.com/">Redis 命令参考<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1YW5nejE5OTAvcmVkaXMtMy4wLWFubm90YXRlZA==" title="https://github.com/huangz1990/redis-3.0-annotated">带有详细注释的 Redis 3.0 代码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1YW5nejE5OTAvYW5ub3RhdGVkX3JlZGlzX3NvdXJjZQ==" title="https://github.com/huangz1990/annotated_redis_source">带有详细注释的 Redis 2.6 代码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1c3RpbnlodWFuZy90aGUtbGl0dGxlLW1vbmdvZGItYm9vay1jbi9ibG9iL21hc3Rlci9tb25nb2RiLm1k" title="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md">The Little MongoDB Book<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phc29uTGFpMjU2L3RoZS1saXR0bGUtcmVkaXMtYm9vay9ibG9iL21hc3Rlci9jbi9yZWRpcy5tZA==" title="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md">The Little Redis Book<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3MubmVvNGoub3JnLmNuLw==" title="http://docs.neo4j.org.cn/">Neo4j 简体中文手册 v1.8<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL25lbzRqLnR3Lw==" title="http://neo4j.tw/">Neo4j .rb 中文資源<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Rpc3F1ZWJvb2suY29t" title="http://disquebook.com">Disque 使用教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0plcnJ5TGVhZC9TcGFya0ludGVybmFscy90cmVlL21hc3Rlci9tYXJrZG93bg==" title="https://github.com/JerryLead/SparkInternals/tree/master/markdown">Apache Spark 设计与实现<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL25vc3FsLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/nosql.md">8种Nosql数据库系统对比<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3><ul><li><span class="exturl" data-url="aHR0cDovL3dvcmtzLmppbmJ1Z3VvLmNvbS9wb3N0Z3Jlc3FsL21lbnU4MjMvaW5kZXguaHRtbA==" title="http://works.jinbuguo.com/postgresql/menu823/index.html">PostgreSQL 8.2.3 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5wb3N0Z3Jlcy5jbi9kb2NzLzkuMy9pbmRleC5odG1s" title="http://www.postgres.cn/docs/9.3/index.html">PostgreSQL 9.3.1 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5wb3N0Z3Jlcy5jbi9kb2NzLzkuNS9pbmRleC5odG1s" title="http://www.postgres.cn/docs/9.5/index.html">PostgreSQL 9.5.3 中文文档<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="运维监控"><a href="#运维监控" class="headerlink" title="运维监控"></a>运维监控</h3><ul><li><span class="exturl" data-url="aHR0cDovL2tpYmFuYS5sb2dzdGFzaC5lcw==" title="http://kibana.logstash.es">ELKstack 中文指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Vkbi55eXVhcC5jb20vZG9jL21hc3RlcmluZy1lbGFzdGljc2VhcmNoLw==" title="http://udn.yyuap.com/doc/mastering-elasticsearch/">Mastering Elasticsearch(中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9mdXhpYW9wYW5nL2xlYXJuZWxhc3RpY3NlYXJjaC9kZXRhaWxz" title="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details">ElasticSearch 权威指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2VzLnhpYW9sZWlsdS5jb20=" title="http://es.xiaoleilu.com">Elasticsearch 权威指南（中文版）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZW5yeW4vbG9nc3Rhc2gtYmVzdC1wcmFjdGljZS1jbg==" title="https://github.com/chenryn/logstash-best-practice-cn">Logstash 最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jicy5rb25vdGVzLm9yZy93b3JrZG9jL3B1cHBldC0yNy8=" title="http://bbs.konotes.org/workdoc/puppet-27/">Puppet 2.7 Cookbook 中文版<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h3><ul><li><span class="exturl" data-url="aHR0cDovL2xpcHBpb3V5YW5nLmdpdGJvb2tzLmlvL2dyYWRsZS1pbi1hY3Rpb24tY24vY29udGVudC8=" title="http://lippiouyang.gitbooks.io/gradle-in-action-cn/content/">Gradle实战<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2FydGljbGUueWVleWFuLm9yZy92aWV3LzIyNTEvOTQ4ODI=" title="http://article.yeeyan.org/view/2251/94882">持续集成（第二版）<i class="fa fa-external-link"></i></span> (译言网)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2phdmEvai1hcC8=" title="http://www.ibm.com/developerworks/cn/java/j-ap/">让开发自动化系列专栏<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2phdmEvai1jcS8=" title="http://www.ibm.com/developerworks/cn/java/j-cq/">追求代码质量<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zvb2wyZmlzaC9zZWxlbml1bS1kb2M=" title="https://github.com/fool2fish/selenium-doc">selenium 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xvY2FsLmpvZWxvbnNvZnR3YXJlLmNvbS93aWtpL0NoaW5lc2VfKFNpbXBsaWZpZWQp" title="http://local.joelonsoftware.com/wiki/Chinese_(Simplified)">Joel谈软件<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xvY2FsLmpvZWxvbnNvZnR3YXJlLmNvbS93aWtpLyVFOSVBNiU5NiVFOSVBMCU4MQ==" title="http://local.joelonsoftware.com/wiki/%E9%A6%96%E9%A0%81">約耳談軟體(Joel on Software)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9HcmFkbGUtMi1Vc2VyLUd1aWRl" title="https://github.com/waylau/Gradle-2-User-Guide">Gradle 2 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS9zcGVj" title="https://github.com/ecomfe/spec">编码规范<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9ib29rLzExNDM=" title="http://www.ituring.com.cn/book/1143">开源软件架构<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3MuaHVpaG9vLmNvbS9nbnUvbGludXgvZ21ha2UuaHRtbA==" title="http://docs.huihoo.com/gnu/linux/gmake.html">GNU make 指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy55YXl1Lm9yZy9ib29rL2dudV9tYWtlLw==" title="http://www.yayu.org/book/gnu_make/">GNU make 中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovLzEyZmFjdG9yLm5ldC96aF9jbi8=" title="http://12factor.net/zh_cn/">The Twelve-Factor App<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lMTE1L2Rlc2lnbl9wYXR0ZXJucw==" title="https://github.com/me115/design_patterns">图说设计模式<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZWxpb24vYXJ0aWNsZS9kZXRhaWxzLzE3NTE3MjEz" title="http://blog.csdn.net/lovelion/article/details/17517213">史上最全设计模式导学目录<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsZnJlZFRoZUJlc3QvRGVzaWduLVBhdHRlcm4=" title="https://github.com/AlfredTheBest/Design-Pattern">design pattern 包教不包会<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9xdWFua2UuZ2l0Ym9va3MuaW8vZGVzaWduLXBhdHRlcm4tamF2YS9jb250ZW50Lw==" title="https://quanke.gitbooks.io/design-pattern-java/content/">设计模式 Java 版<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><ul><li><span class="exturl" data-url="aHR0cDovL2Nvb2xzaGVsbC5pbmZvL2Jsb2cvMjAxNS8wNC93ZWItdHJhbnNtaXNzaW9uLWJhc2lzLmh0bWw=" title="http://coolshell.info/blog/2015/04/web-transmission-basis.html">网络传输基础<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy4yMHRoaW5nc2lsZWFybmVkLmNvbS96aC1DTi9ob21l" title="http://www.20thingsilearned.com/zh-CN/home">关于浏览器和网络的 20 项须知<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2tub3dsZWRnZS5lY29tZmUuY29tLw==" title="http://knowledge.ecomfe.com/">前端知识体系<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ppbmxvbmcuZ2l0aHViLmlvLzIwMTMvMDgvMjkvZGV2dG9vbHNlY3JldHMv" title="http://jinlong.github.io/2013/08/29/devtoolsecrets/">浏览器开发工具的秘密<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NOLUNocm9tZS1EZXZUb29scy9DTi1DaHJvbWUtRGV2VG9vbHM=" title="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools">Chrome 开发者工具中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL29wZW4uY2hyb21lLjM2MC5jbi9leHRlbnNpb25fZGV2L292ZXJ2aWV3Lmh0bWw=" title="http://open.chrome.360.cn/extension_dev/overview.html">Chrome扩展开发文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ncnVudGpzLm9yZy8=" title="http://www.gruntjs.org/">Grunt中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3llb21hbmpzLm9yZy8=" title="http://yeomanjs.org/">Yeoman中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbG95VGVhbS9NYXJz" title="https://github.com/AlloyTeam/Mars">移动Web前端知识库<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RlZXJjaGFvLm5ldC90dXRvcmlhbHMvcmVnZXgvcmVnZXguaHRt" title="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvdWJlci9ibG9nL2lzc3Vlcy8y" title="https://github.com/fouber/blog/issues/2">前端开发体系建设日记<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvb3Npbi9tb2JpbGUtd2ViLWZhdm9yaXRlcw==" title="https://github.com/hoosin/mobile-web-favorites">移动前端开发收藏夹<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhcmN5bGl1L2dvb2dsZS1zdHlsZWd1aWRlL2Jsb2IvbWFzdGVyL0pTT05TdHlsZUd1aWRlLm1k" title="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md">JSON风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvbGFzYmxhY2svaHR0cC1hcGktZ3VpZGU=" title="https://github.com/bolasblack/http-api-guide">HTTP 接口设计指北<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhY2tlMi9oYWNrZTIuZ2l0aHViLmlvL2lzc3Vlcy8x" title="https://github.com/hacke2/hacke2.github.io/issues/1">前端资源分享（一）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhY2tlMi9oYWNrZTIuZ2l0aHViLmlvL2lzc3Vlcy8z" title="https://github.com/hacke2/hacke2.github.io/issues/3">前端资源分享（二）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2NvZGVybG1uLmdpdGh1Yi5pby9jb2RlLXN0YW5kYXJkcy8=" title="http://coderlmn.github.io/code-standards/">前端代码规范 及 最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9kd3FzL2Zyb250ZW5kZGV2aGFuZGJvb2svZGV0YWlscw==" title="https://www.gitbook.com/book/dwqs/frontenddevhandbook/details">前端开发者手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9sZW9oeGovZnJvbnQtZW5kLWRhdGFiYXNlL2RldGFpbHM=" title="https://www.gitbook.com/book/leohxj/front-end-database/details">前端工程师手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpemFyZGZvcmNlbC93M3NjaG9vbA==" title="https://github.com/wizardforcel/w3school">w3school教程整理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL21hbi5sdXBhd29ybGQuY29tL2NvbnRlbnQvbmV0d29yay93aXJlc2hhcmsvaW5kZXguaHRtbA==" title="http://man.lupaworld.com/content/network/wireshark/index.html">Wireshark用户手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkuZW1jLmNvbS90aHJlYWQvMTk0OTAx" title="https://community.emc.com/thread/194901">一站式学习Wireshark<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2hhcHB5cGV0ZXIuZ2l0aHViLmlvL3RlYWxlYWYtaHR0cC8=" title="http://happypeter.github.io/tealeaf-http/">HTTP 下午茶<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3l1ZWR1LmJhaWR1LmNvbS9lYm9vay80NzhkMWE2MjM3NmJhZjFmZmM0ZmFkOTk/cG49MQ==" title="http://yuedu.baidu.com/ebook/478d1a62376baf1ffc4fad99?pn=1">HTTP/2.0 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FiYnNoci9yZmM3NTQwLXRyYW5zbGF0aW9uLXpoX2Nu" title="https://github.com/abbshr/rfc7540-translation-zh_cn">RFC 7540 - HTTP/2 中文翻译版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay95ZTExb3cvaHR0cDItZXhwbGFpbmVkL2RldGFpbHM=" title="https://www.gitbook.com/book/ye11ow/http2-explained/details">http2讲解<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9qdW50YW8vMy13ZWItZGVzaWducy1pbi0zLXdlZWtzL2RldGFpbHM=" title="https://www.gitbook.com/book/juntao/3-web-designs-in-3-weeks/details">3 Web Designs in 3 Weeks<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvcm9ja3kvU2l0ZS1SZWxpYWJpbGl0eS1FbmdpbmVlcmluZw==" title="https://github.com/hellorocky/Site-Reliability-Engineering">站点可靠性工程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Zsb3dlcm93bC9CaWctRGF0YS1SZXNvdXJjZXM=" title="https://github.com/Flowerowl/Big-Data-Resources">大数据/数据挖掘/推荐系统/机器学习相关资源<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppemhhbmcvZ3VpZGV0b2RhdGFtaW5pbmc=" title="https://github.com/jizhang/guidetodatamining">面向程序员的数据挖掘指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmNzZG4ubmV0L0NPREVfVHJhbnNsYXRpb24vc3BhcmtfbWF0ZWlfcGhk" title="https://code.csdn.net/CODE_Translation/spark_matei_phd">大型集群上的快速和通用数据处理架构<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbnlpcXVuL0RhdGFNaW5pbmdBbGdvcml0aG0=" title="https://github.com/linyiqun/DataMiningAlgorithm">数据挖掘中经典的算法实现和详细的注释<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9haXlhbmJvLmdpdGJvb2tzLmlvL3NwYXJrLXByb2dyYW1taW5nLWd1aWRlLXpoLWNuL2NvbnRlbnQv" title="https://aiyanbo.gitbooks.io/spark-programming-guide-zh-cn/content/">Spark 编程指南简体中文版<i class="fa fa-external-link"></i></span></li></ul><hr><h2 id="编程艺术"><a href="#编程艺术" class="headerlink" title="编程艺术"></a>编程艺术</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1bHljb2RpbmcvVGhlLUFydC1PZi1Qcm9ncmFtbWluZy1ieS1KdWx5" title="https://github.com/julycoding/The-Art-Of-Programming-by-July">程序员编程艺术<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vc2NoaW5hLm5ldC90cmFuc2xhdGUvd2hhdC1ldmVyeS1wcm9ncmFtbWVyLXNob3VsZC1rbm93LWFib3V0LW1lbW9yeS1wYXJ0MT9wcmludA==" title="http://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1?print">每个程序员都应该了解的内存知识(译)<i class="fa fa-external-link"></i></span>【第一部分】</li><li><span class="exturl" data-url="aHR0cDovL3JlYWQuZG91YmFuLmNvbS9lYm9vay80OTcyODgzLw==" title="http://read.douban.com/ebook/4972883/">取悦的工序：如何理解游戏<i class="fa fa-external-link"></i></span> (豆瓣阅读，免费书籍)</li><li><span class="exturl" data-url="aHR0cDovL3hpYW9iZWljbi5naXRib29rcy5pby9wcm9ncmFtbWluZy1za2lsbHMtc3VtbWFyeS8=" title="http://xiaobeicn.gitbooks.io/programming-skills-summary/">编程技巧总汇<i class="fa fa-external-link"></i></span></li></ul><hr><h2 id="语言相关类"><a href="#语言相关类" class="headerlink" title="语言相关类"></a>语言相关类</h2><h3 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h3><ul><li><span class="exturl" data-url="aHR0cDovL2F3ay5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0Lw==" title="http://awk.readthedocs.org/en/latest/">awk程序设计语言<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2F3ay5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/awk.md">awk教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="SED"><a href="#SED" class="headerlink" title="SED"></a>SED</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3NlZC5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/sed.md">sed教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lemxpcHBpLmNvbS9ibG9nLzIwMTcvMDIvc2VkLWludHJvZHVjdGlvbi5odG1s" title="http://www.ezlippi.com/blog/2017/02/sed-introduction.html">SED简明教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9hcGFjaGUtc2hpcm8tMS4yLngtcmVmZXJlbmNl" title="https://github.com/waylau/apache-shiro-1.2.x-reference">Apache Shiro 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9KZXJzZXktMi54LVVzZXItR3VpZGU=" title="https://github.com/waylau/Jersey-2.x-User-Guide">Jersey 2.x 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9zcHJpbmctZnJhbWV3b3JrLTQtcmVmZXJlbmNl" title="https://github.com/waylau/spring-framework-4-reference">Spring Framework 4.x参考文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYmFvZ3VhbmcvU3ByaW5nLUJvb3QtUmVmZXJlbmNlLUd1aWRl" title="https://github.com/qibaoguang/Spring-Boot-Reference-Guide">Spring Boot参考指南<i class="fa fa-external-link"></i></span> (翻译中)</li><li><span class="exturl" data-url="aHR0cDovL215YmF0aXMuZ2l0aHViLmlvL215YmF0aXMtMy96aC9pbmRleC5odG1s" title="http://mybatis.github.io/mybatis-3/zh/index.html">MyBatis中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9SZXN0RGVtbw==" title="https://github.com/waylau/RestDemo">用jersey构建REST服务<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9hY3Rpdml0aS01LngtdXNlci1ndWlkZQ==" title="https://github.com/waylau/activiti-5.x-user-guide">Activiti 5.x 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5oYXdzdGVpbi5jb20vcG9zdHMvZ29vZ2xlLWphdmEtc3R5bGUuaHRtbA==" title="http://www.hawstein.com/posts/google-java-style.html">Google Java编程风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9uZXR0eS00LXVzZXItZ3VpZGU=" title="https://github.com/waylau/netty-4-user-guide">Netty 4.x 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9lc3NlbnRpYWwtbmV0dHktaW4tYWN0aW9u" title="https://github.com/waylau/essential-netty-in-action">Netty 实战(精髓)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9yZXN0LWluLWFjdGlvbg==" title="https://github.com/waylau/rest-in-action">REST 实战<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9qYXZhLWNvZGUtY29udmVudGlvbnM=" title="https://github.com/waylau/java-code-conventions">Java 编码规范<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9hcGFjaGUtbWluYS0yLngtdXNlci1ndWlkZQ==" title="https://github.com/waylau/apache-mina-2.x-user-guide">Apache MINA 2 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2p2bS5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/jvm.md">JVM必备指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2phdmEtc3RyaW5nLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/java-string.md">Java入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLw==" title="http://javarevisited.blogspot.com/">javarevisited博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5qb3VybmFsZGV2LmNvbS8=" title="http://www.journaldev.com/">journaldev教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5hbmRyb2lkZGV2dG9vbHMuY24v" title="http://www.androiddevtools.cn/">开发工具下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2d1aWRlcy5jb2RlcGF0aC5jb20vYW5kcm9pZC9Ib21l" title="http://guides.codepath.com/android/Home">CodePath Android教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5hcGtidXMuY29tL2Rlc2lnbi9pbmRleC5odG1s" title="http://www.apkbus.com/design/index.html">Android Design(中文版)<i class="fa fa-external-link"></i></span></li><li>Google Material Design 正體中文版 (<span class="exturl" data-url="aHR0cDovL3djYzcyMy5naXRib29rcy5pby9nb29nbGVfZGVzaWduX3RyYW5zbGF0ZS9jb250ZW50L3N0eWxlLWljb25zLmh0bWw=" title="http://wcc723.gitbooks.io/google_design_translate/content/style-icons.html">译本一<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzFzdGVycy9tYXRlcmlhbF9kZXNpZ25femg=" title="https://github.com/1sters/material_design_zh">译本二<i class="fa fa-external-link"></i></span>)</li><li><span class="exturl" data-url="aHR0cDovL2h1a2FpLm1lL2FuZHJvaWQtdHJhaW5pbmctY291cnNlLWluLWNoaW5lc2UvaW5kZXguaHRtbA==" title="http://hukai.me/android-training-course-in-chinese/index.html">Google Android官方培训课程中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3N0b3JtemhhbmcuZ2l0aHViLmlvL2FuZHJvaWQvMjAxNC8wNy8wNy9sZWFybi1hbmRyb2lkLWZyb20tcm9va2llLw==" title="http://stormzhang.github.io/android/2014/07/07/learn-android-from-rookie/">Android学习之路<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Rvb2xzLmFuZHJvaWQuY29tL3RlY2gtZG9jcy9uZXctYnVpbGQtc3lzdGVt" title="http://tools.android.com/tech-docs/new-build-system">Android构建工具<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jib3lmZWl5dS9hbmRyb2lkLXRlY2gtZnJvbnRpZXI=" title="https://github.com/bboyfeiyu/android-tech-frontier">Android开发技术前线(android-tech-frontier)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2FuZHJvaWQtbWVtb3J5LXByb2YxLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/android-memory-prof1.md">Android内存优化(上)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2FuZHJvaWQtbWVtb3J5LXByb2YyLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/android-memory-prof2.md">Android内存优化(中)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2FuZHJvaWQtbWVtb3J5LXByb2YzLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/android-memory-prof3.md">Android内存优化(全)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2RvdGEuY29tLw==" title="http://www.codota.com/">查找代码的一个网站<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWFyc2VuYWwuY29tL2ZyZWU=" title="https://android-arsenal.com/free">Android开源库汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2RvdGEuY29tLw==" title="http://www.codota.com/">查找示例代码的网站<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3R1dHNwbHVzLmNvbS8=" title="http://tutsplus.com/">Android SDK使用教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z1dHVyaWNlL2FuZHJvaWQtYmVzdC1wcmFjdGljZXM=" title="https://github.com/futurice/android-best-practices">Android最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dvb2dsZS5naXRodWIuaW8vbWF0ZXJpYWwtZGVzaWduLWljb25zLyNpY29ucy1mb3ItYW5kcm9pZA==" title="http://google.github.io/material-design-icons/#icons-for-android">Android Material icons<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><ul><li><span class="exturl" data-url="aHR0cDovL3poLmNwcHJlZmVyZW5jZS5jb20v" title="http://zh.cppreference.com/">C/C++ 中文参考手册<i class="fa fa-external-link"></i></span> (欢迎大家参与在线翻译和校对)</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay90aW55bGFiL2Nib29rL2RldGFpbHM=" title="https://www.gitbook.com/book/tinylab/cbook/details">C 语言编程透视<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvcmhhcHB5L0NwbHVzcGx1cy1Db25jdXJyZW5jeS1Jbi1QcmFjdGljZQ==" title="https://github.com/forhappy/Cplusplus-Concurrency-In-Practice">C++ 并发编程指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2FrYWVkdS5naXRodWIuaW8vYm9vay8=" title="http://akaedu.github.io/book/">Linux C编程一站式学习<i class="fa fa-external-link"></i></span> (宋劲杉, 北京亚嵌教育研究中心)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlZXlpdy9jZ2RiLW1hbnVhbC1pbi1jaGluZXNl" title="https://github.com/leeyiw/cgdb-manual-in-chinese">CGDB中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvZ2NjLzEwMC1nZGItdGlwcy9ibG9iL21hc3Rlci9zcmMvaW5kZXgubWQ=" title="https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md">100个gdb小技巧<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvZ2NjLzEwMC1nY2MtdGlwcy9ibG9iL21hc3Rlci9zcmMvaW5kZXgubWQ=" title="https://github.com/hellogcc/100-gcc-tips/blob/master/src/index.md">100个gcc小技巧<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvZ2NjLzEwMC1nZGItdGlwcw==" title="https://github.com/hellogcc/100-gdb-tips">学习gdb调试技巧<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuanVrZS96Z3VpZGUtY24=" title="https://github.com/anjuke/zguide-cn">ZMQ 指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9ib29rLzEyMDM=" title="http://www.ituring.com.cn/book/1203">How to Think Like a Computer Scientist<i class="fa fa-external-link"></i></span> (中英文版)</li><li><span class="exturl" data-url="aHR0cDovL3NjYy5xaWJlYnQuY2FzLmNuL2RvY3MvbGludXgvYmFzZS8lQjglRkElQ0UlRDIlRDIlQkIlQzYlRjAlRDAlQjRNYWtlZmlsZS0lQjMlQzIlRjAlQTkucGRm" title="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf">跟我一起写Makefile(PDF)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy55YXl1Lm9yZy9ib29rL2dudV9tYWtlLw==" title="http://www.yayu.org/book/gnu_make/">GNU make中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3MuaHVpaG9vLmNvbS9nbnUvbGludXgvZ21ha2UuaHRtbA==" title="http://docs.huihoo.com/gnu/linux/gmake.html">GNU make 指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLWdvb2dsZS1zdHlsZWd1aWRlLnJlYWR0aGVkb2NzLm9yZy9lbi9sYXRlc3QvZ29vZ2xlLWNwcC1zdHlsZWd1aWRlL2NvbnRlbnRzLw==" title="http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/contents/">Google C++ 风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuZHljYWkvY3ByaW1lcg==" title="https://github.com/andycai/cprimer">C/C++ Primer<i class="fa fa-external-link"></i></span> (by @andycai)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2xpYnJhcnlzL2Jvb2tzL2NvbnRlbnRzL2M=" title="http://www.nowamagic.net/librarys/books/contents/c">简单易懂的C魔法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Nld20ucGt1LmVkdS5jbi9zcmMvcGFyYWRpc2UvcmVmZXJlbmNlL0NNYWtlJTIwUHJhY3RpY2UucGRm" title="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf">Cmake 实践<i class="fa fa-external-link"></i></span> (PDF版)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdW5pc3R1ZGlvLmNvbS9jcHBmYXEv" title="http://www.sunistudio.com/cppfaq/">C++ FAQ LITE(中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vb29waHkvQ3BwLVByaW1lcg==" title="https://github.com/Mooophy/Cpp-Primer">C++ Primer 5th Answers<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9jaGVueGlhb3dlaS9jcHBfY29uY3VycmVuY3lfaW5fYWN0aW9uL2RldGFpbHM=" title="https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details">C++ 并发编程(基于C++11)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vcXRkb2N1bWVudC90dXRvcmlhbC5odG1s" title="http://www.kuqin.com/qtdocument/tutorial.html">QT 教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2MxLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/c1.md">C进阶指南（1)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1b2hhaGEvQ2hpbmVzZS11dmJvb2s=" title="https://github.com/luohaha/Chinese-uvbook">libuv中文教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLmhpZ2hzY29yZS5kZS9jcHAvYm9vc3Qv" title="http://zh.highscore.de/cpp/boost/">Boost 库中文教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpemFyZGZvcmNlbC9sY3Rody16aA==" title="https://github.com/wizardforcel/lcthw-zh">笨办法学C<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2MyLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/c2.md">C进阶指南（2)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2MzLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/c3.md">C进阶指南（3)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2MtZ2xvYmxlLXZhcmlhYmxlLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/c-globle-variable.md">C语言全局变量那些事儿<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL21hbGxvYy5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/malloc.md">如何实现一个malloc<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lkZW9uZS5jb20v" title="http://ideone.com/">在线编程和调试的网站<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li><span class="exturl" data-url="aHR0cDovL3poLmxlYXJubGF5b3V0LmNvbS8=" title="http://zh.learnlayout.com/">学习CSS布局<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYWRsdW8vQ1NTLUd1aWRlbGluZXMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1k" title="https://github.com/chadluo/CSS-Guidelines/blob/master/README.md">通用 CSS 笔记、建议与指导<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Nzcy5kb3lvZS5jb20v" title="http://css.doyoe.com/">CSS参考手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3lhbnh5ei5naXRodWIuaW8vZW1tZXQtZG9jcy8=" title="http://yanxyz.github.io/emmet-docs/">Emmet 文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2FsbG95dGVhbS5naXRodWIuaW8vY29kZS1ndWlkZS8=" title="http://alloyteam.github.io/code-guide/">前端代码规范<i class="fa fa-external-link"></i></span> (腾讯alloyteam团队)</li><li><span class="exturl" data-url="aHR0cDovL2NvZGVndWlkZS5ib290Y3NzLmNvbS8=" title="http://codeguide.bootcss.com/">HTML和CSS编码规范<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Nhc3MtZ3VpZGVsaW4uZXMvemgv" title="http://sass-guidelin.es/zh/">Sass Guidelines 中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9jc3MzLXR1dG9yaWFs" title="https://github.com/waylau/css3-tutorial">CSS3 Tutorial 《CSS3 教程》<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTA==" title="https://developer.mozilla.org/zh-CN/docs/Web/HTML">MDN HTML 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NT" title="https://developer.mozilla.org/zh-CN/docs/Web/CSS">MDN CSS 中文文档<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Vua253b24vZ28tZnVuZGFtZW50YWwtcHJvZ3JhbW1pbmc=" title="https://github.com/Unknwon/go-fundamental-programming">Go编程基础<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Vua253b24vdGhlLXdheS10by1nb19aSF9DTg==" title="https://github.com/Unknwon/the-way-to-go_ZH_CN">Go入门指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL21pa2VzcG9vay5jb20vbGVhcm5pbmctZ28v" title="http://mikespook.com/learning-go/">学习Go语言<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cDovL3h4aXl5LnFpbml1ZG4uY29tLyVFNSVBRCVBNiVFNCVCOSVBMCUyMEdvJTIwJUU4JUFGJUFEJUU4JUE4JTgwKEdvbGFuZykucGRmP2Rvd25sb2Fk" title="http://xxiyy.qiniudn.com/%E5%AD%A6%E4%B9%A0%20Go%20%E8%AF%AD%E8%A8%80(Golang).pdf?download">PDF<i class="fa fa-external-link"></i></span>)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FzdGF4aWUvYnVpbGQtd2ViLWFwcGxpY2F0aW9uLXdpdGgtZ29sYW5n" title="https://github.com/astaxie/build-web-application-with-golang">Go Web 编程<i class="fa fa-external-link"></i></span> (此书已经出版，希望开发者们去购买，支持作者的创作)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FzdGF4aWUvR28taW4tQWN0aW9u" title="https://github.com/astaxie/Go-in-Action">Go实战开发<i class="fa fa-external-link"></i></span> (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者<span class="exturl" data-url="aHR0cHM6Ly9tZS5hbGlwYXkuY29tL2FzdGF4aWU=" title="https://me.alipay.com/astaxie">捐赠<i class="fa fa-external-link"></i></span>，以鼓励作者的继续创作)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FzdGF4aWUvTlBXR196aA==" title="https://github.com/astaxie/NPWG_zh">Network programming with Go 中文翻译版本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5oZWxsb2djYy5vcmcvZWZmZWN0aXZlX2dvLmh0bWw=" title="http://www.hellogcc.org/effective_go.html">Effective Go<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L1RoZS1Hb2xhbmctU3RhbmRhcmQtTGlicmFyeS1ieS1FeGFtcGxl" title="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example">Go 语言标准库<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dvZG9jLm1sLw==" title="http://godoc.ml/">Golang标准库文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dvcmV2ZWwuY24vZG9jcy9tYW51YWwvaW5kZXguaHRtbA==" title="http://gorevel.cn/docs/manual/index.html">Revel 框架手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2L2FydGljbGUvZGV0YWlscy80NjU2NTI0MQ==" title="http://blog.csdn.net/dc_726/article/details/46565241">Java程序员的Golang入门指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h5cGVyLWNhcnJvdC9nb19jb21tYW5kX3R1dG9yaWFs" title="https://github.com/hyper-carrot/go_command_tutorial">Go命令教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FjaHVuL0dvLUJsb2ctSW4tQWN0aW9u" title="https://github.com/achun/Go-Blog-In-Action">Go语言博客实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy1jaGluYS9nb2xhbmdkb2MudHJhbnNsYXRpb25z" title="https://github.com/golang-china/golangdoc.translations">Go 官方文档翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpYW5jYWlhbWFvL2dvLWludGVybmFscw==" title="https://github.com/tiancaiamao/go-internals">深入解析Go<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL2dvbGFuZy1jaGluYS9nb3BsLXpoL3dpa2kvSG9tZQ==" title="https://bitbucket.org/golang-china/gopl-zh/wiki/Home">Go语言圣经(中文版)<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvZ29wbC16aC9kZXRhaWxz" title="https://www.gitbook.com/book/wizardforcel/gopl-zh/details">GitBook<i class="fa fa-external-link"></i></span>)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYWkyMDEwL2FkdmFuY2VkLWdvLXByb2dyYW1taW5nLWJvb2s=" title="https://github.com/chai2010/advanced-go-programming-book">Go语言高级编程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2phdmEvai1wZy8=" title="http://www.ibm.com/developerworks/cn/java/j-pg/">实战 Groovy 系列<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h3><ul><li><span class="exturl" data-url="aHR0cDovL3J3aC5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0Lw==" title="http://rwh.readthedocs.org/en/latest/">Real World Haskell 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZsZXVyZXItbGVlLmNvbS9seWFoLw==" title="http://fleurer-lee.com/lyah/">Haskell趣学指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xlYXJueW91YWhhc2tlbGwuY29tL2NoYXB0ZXJz" title="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!<i class="fa fa-external-link"></i></span>(质量不错的一个网书)</li></ul><hr><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Fpbmp4LzMwbWluX2d1aWRlcy9ibG9iL21hc3Rlci9pb3MubWQ=" title="https://github.com/qinjx/30min_guides/blob/master/ios.md">iOS开发60分钟入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lzdXgudGVuY2VudC5jb20vaW9zLWh1bWFuLWludGVyZmFjZS1ndWlkZWxpbmVzLXVpLWRlc2lnbi1iYXNpY3MtaW9zNy5odG1s" title="http://isux.tencent.com/ios-human-interface-guidelines-ui-design-basics-ios7.html">iOS7人机界面指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLWdvb2dsZS1zdHlsZWd1aWRlLnJlYWR0aGVkb2NzLm9yZy9lbi9sYXRlc3QvZ29vZ2xlLW9iamMtc3R5bGVndWlkZS8=" title="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/">Google Objective-C Style Guide 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dpbGVhbS5jb20vaXBob25lLTYtc2NyZWVuLWNuLw==" title="http://wileam.com/iphone-6-screen-cn/">iPhone 6 屏幕揭秘<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL25pbHN1bi5naXRodWIuaW8vYXBwbGUtd2F0Y2gv" title="http://nilsun.github.io/apple-watch/">Apple Watch开发初探<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvaW9zL3JlZmVyZW5jZWxpYnJhcnkvR2V0dGluZ1N0YXJ0ZWQvUm9hZE1hcGlPU0NoL2luZGV4Lmh0bWw=" title="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/index.html">马上着手开发 iOS 应用程序<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2preWluL1N1YnRpdGxl" title="https://github.com/jkyin/Subtitle">网易斯坦福大学公开课：iOS 7应用开发字幕文件<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul><li><p><span class="exturl" data-url="aHR0cDovL2JxNjkuY29tL2Jsb2cvYXJ0aWNsZXMvc2NyaXB0Lzg2OC9nb29nbGUtamF2YXNjcmlwdC1zdHlsZS1ndWlkZS5odG1s" title="http://bq69.com/blog/articles/script/868/google-javascript-style-guide.html">Google JavaScript 代码风格指南<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhcmN5bGl1L2dvb2dsZS1zdHlsZWd1aWRlL2Jsb2IvbWFzdGVyL0pTT05TdHlsZUd1aWRlLm1k" title="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md">Google JSON 风格指南<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkYW1sdS9qYXZhc2NyaXB0LXN0eWxlLWd1aWRl" title="https://github.com/adamlu/javascript-style-guide">Airbnb JavaScript 规范<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2phdmFzY3JpcHQucnVhbnlpZmVuZy5jb20v" title="http://javascript.ruanyifeng.com/">JavaScript 标准参考教程（alpha）<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL3Bpai5yb2JpbnF1Lm1lLw==" title="http://pij.robinqu.me/">Javascript编程指南<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JvYmluUXUvUHJvZ3JhbWluZy1Jbi1KYXZhc2NyaXB0" title="https://github.com/RobinQu/Programing-In-Javascript">源码<i class="fa fa-external-link"></i></span>)</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1c3RqYXZhYy8xMi1qYXZhc2NyaXB0LXF1aXJrcw==" title="https://github.com/justjavac/12-javascript-quirks">javascript 的 12 个怪癖<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2JvbnNhaWRlbi5naXRodWIuaW8vSmF2YVNjcmlwdC1HYXJkZW4vemgv" title="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2ljb2RlaXQub3JnL2pzY2NwLw==" title="http://icodeit.org/jsccp/">JavaScript核心概念及实践<i class="fa fa-external-link"></i></span> (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者)</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pheWxpL2phdmFzY3JpcHQtcGF0dGVybnM=" title="https://github.com/jayli/javascript-patterns">《JavaScript 模式》<i class="fa fa-external-link"></i></span> “JavaScript patterns”中译本</p></li><li><p><span class="exturl" data-url="aHR0cDovL2p1c3RqYXZhYy5jb20vbmFtZWQtZnVuY3Rpb24tZXhwcmVzc2lvbnMtZGVteXN0aWZpZWQuaHRtbA==" title="http://justjavac.com/named-function-expressions-demystified.html">命名函数表达式探秘<i class="fa fa-external-link"></i></span>  (注:原文由<span class="exturl" data-url="aHR0cDovL3d3dy5jbi1jdWNrb28uY29t" title="http://www.cn-cuckoo.com">为之漫笔<i class="fa fa-external-link"></i></span>翻译，原始地址无法打开，所以此处地址为我博客上的备份)</p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5vc2NoaW5hLm5ldC90cmFuc2xhdGUvbGVhcm5pbmctamF2YXNjcmlwdC1kZXNpZ24tcGF0dGVybnM=" title="http://www.oschina.net/translate/learning-javascript-design-patterns">学用 JavaScript 设计模式<i class="fa fa-external-link"></i></span> (开源中国)</p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9Ub21YdS9hcmNoaXZlLzIwMTEvMTIvMTUvMjI4ODQxMS5odG1s" title="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解JavaScript系列<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=" title="http://es6.ruanyifeng.com/">ECMAScript 6 入门<i class="fa fa-external-link"></i></span> (作者：阮一峰)</p></li><li><p><span class="exturl" data-url="aHR0cDovL2xpdWJpbi5naXRodWIuaW8vcHJvbWlzZXMtYm9vay8=" title="http://liubin.github.io/promises-book/">JavaScript Promise迷你书<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dldGlmeS9Zb3UtRG9udC1Lbm93LUpT" title="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS<i class="fa fa-external-link"></i></span> (深入JavaScript语言核心机制的系列图书)</p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDE0MzQ0NDY2ODk4NjdiMjcxNTdlODk2ZTc0ZDUxYTg5YzI1Y2M4YjQzYmRiMzAwMA==" title="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000">JavaScript 教程<i class="fa fa-external-link"></i></span> 廖雪峰</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdA==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN JavaScript 中文文档<i class="fa fa-external-link"></i></span></p></li><li><p>jQuery</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbi1jdWNrb28uY29tL2RlY29uc3RydWN0ZWQvanF1ZXJ5Lmh0bWw=" title="http://www.cn-cuckoo.com/deconstructed/jquery.html">jQuery 解构<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2xpYnJhcnlzL2Jvb2tzL2NvbnRlbnRzL2pxdWVyeQ==" title="http://www.nowamagic.net/librarys/books/contents/jquery">简单易懂的JQuery魔法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2k1dGluZy5naXRodWIuaW8vSG93LXRvLXdyaXRlLWpRdWVyeS1wbHVnaW4vYnVpbGQvanF1ZXJ5LnBsdWdpbi5odG1s" title="http://i5ting.github.io/How-to-write-jQuery-plugin/build/jquery.plugin.html">How to write jQuery plugin<i class="fa fa-external-link"></i></span></li></ul></li><li><p>Node.js</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub2RlYmVnaW5uZXIub3JnL2luZGV4LXpoLWNuLmh0bWw=" title="http://www.nodebeginner.org/index-zh-cn.html">Node入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL25xZGVuZy5naXRodWIuaW8vNy1kYXlzLW5vZGVqcy8=" title="http://nqdeng.github.io/7-days-nodejs/">七天学会NodeJS<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy10dy9ub2RlanMtd2lraS1ib29r" title="https://github.com/nodejs-tw/nodejs-wiki-book">Nodejs Wiki Book<i class="fa fa-external-link"></i></span> (繁体中文)</li><li><span class="exturl" data-url="aHR0cDovL2V4cHJlc3Nqcy5qc2VyLnVzLw==" title="http://expressjs.jser.us/">express.js 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1by15dS9rb2EtZ3VpZGU=" title="https://github.com/guo-yu/koa-guide">koa 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jhc2Utbi5naXRodWIuaW8va29hLWdlbmVyYXRvci1leGFtcGxlcy8=" title="http://base-n.github.io/koa-generator-examples/">一起学koa<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25zd2Jtdy9OLWJsb2c=" title="https://github.com/nswbmw/N-blog">使用 Express + MongoDB 搭建多人博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2phdmFzY3JpcHQucnVhbnlpZmVuZy5jb20vbm9kZWpzL2V4cHJlc3MuaHRtbA==" title="http://javascript.ruanyifeng.com/nodejs/express.html">Express框架<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fsc290YW5nL25vZGUtbGVzc29ucw==" title="https://github.com/alsotang/node-lessons">Node.js 包教不包会<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMub3JnL3BhY2thZ2UvbGVhcm55b3Vub2RlLXpoLWNu" title="https://www.npmjs.org/package/learnyounode-zh-cn">Learn You The Node.js For Much Win! (中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2k1dGluZy5naXRodWIuaW8vbm9kZS1kZWJ1Zy10dXRvcmlhbC8=" title="http://i5ting.github.io/node-debug-tutorial/">Node debug 三法三例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay8wNTMyL25vZGVqcy9kZXRhaWxz" title="https://www.gitbook.com/book/0532/nodejs/details">nodejs中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpemFyZGZvcmNlbC9vcm0yLWRvYy16aC1jbg==" title="https://github.com/wizardforcel/orm2-doc-zh-cn">orm2 中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li><p>underscore.js</p><ul><li><span class="exturl" data-url="aHR0cDovL2xlYXJuaW5nY24uY29tL3VuZGVyc2NvcmUv" title="http://learningcn.com/underscore/">Underscore.js中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li><p>backbone.js</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL2JhY2tib25lLw==" title="http://www.css88.com/doc/backbone/">backbone.js中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy50aGU1ZmlyZS5jb20vYmFja2JvbmUtanMtdHV0b3JpYWxzLXBkZi1kb3dubG9hZC5odG1s" title="http://www.the5fire.com/backbone-js-tutorials-pdf-download.html">backbone.js入门教程<i class="fa fa-external-link"></i></span> (PDF)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZTVmaXJlL2JhY2tib25lanMtbGVhcm5pbmctbm90ZQ==" title="https://github.com/the5fire/backbonejs-learning-note">Backbone.js入门教程第二版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZlbGl2aW5nLmdpdGh1Yi5pby9kZXZlbG9waW5nLWJhY2tib25lLWFwcGxpY2F0aW9ucw==" title="http://feliving.github.io/developing-backbone-applications">Developing Backbone.js Applications(中文版)<i class="fa fa-external-link"></i></span></li></ul></li><li><p>AngularJS</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21nZWNoZXYvYW5ndWxhcmpzLXN0eWxlLWd1aWRlL2Jsb2IvbWFzdGVyL1JFQURNRS16aC1jbi5tZA==" title="https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md">AngularJS最佳实践和风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BlaXJhbnN1bi9hbmd1bGFyanMtY24=" title="https://github.com/peiransun/angularjs-cn">AngularJS中译本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbnNoL0FuZ3VsYXJqc1R1dG9yaWFsX2Nu" title="https://github.com/zensh/AngularjsTutorial_cn">AngularJS入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1ZmVpL01ha2UtWW91ci1Pd24tQW5ndWxhckpTL2Jsb2IvbWFzdGVyLzAxLm1k" title="https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md">构建自己的AngularJS<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53YXlsYXUuY29tL2J1aWxkLWFuZ3VsYXJqcy1hcHAtd2l0aC15ZW9tYW4taW4td2luZG93cy8=" title="http://www.waylau.com/build-angularjs-app-with-yeoman-in-windows/">在Windows环境下用Yeoman构建AngularJS项目<i class="fa fa-external-link"></i></span></li></ul></li><li><p>Zepto.js</p><ul><li><span class="exturl" data-url="aHR0cDovL213ZWIuYmFpZHUuY29tL3plcHRvYXBpLw==" title="http://mweb.baidu.com/zeptoapi/">Zepto.js 中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li><p>Sea.js</p><ul><li><span class="exturl" data-url="aHR0cDovL2lzbGFuZDIwNS5naXRodWIuaW8vSGVsbG9TZWEuanMv" title="http://island205.github.io/HelloSea.js/">Hello Sea.js<i class="fa fa-external-link"></i></span></li></ul></li><li><p>React.js</p><ul><li><span class="exturl" data-url="aHR0cDovL3JlYWN0anMuY24v" title="http://reactjs.cn/">React.js 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zha2VmaXNoL3JlYWN0LXdlYnBhY2stY29va2Jvb2s=" title="https://github.com/fakefish/react-webpack-cookbook">React webpack-cookbook<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZyYXNlcnh1Lm1lL2ludHJvLXRvLXJlYWN0Lw==" title="http://fraserxu.me/intro-to-react/">React 入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dpa2kuamlrZXh1ZXl1YW4uY29tL3Byb2plY3QvcmVhY3QtbmF0aXZlLw==" title="http://wiki.jikexueyuan.com/project/react-native/">React Native 中文文档(含最新Android内容)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZUppYW4vYnVpbGQtYS1obi1mcm9udC1wYWdl" title="https://github.com/theJian/build-a-hn-front-page">Learn React &amp; Webpack by building the Hacker News front page<i class="fa fa-external-link"></i></span></li></ul></li><li><p>impress.js</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tva2RlbW8vaW1wcmVzcy5qcy10dXRvcmlhbC1pbi1DaGluZXNl" title="https://github.com/kokdemo/impress.js-tutorial-in-Chinese">impress.js的中文教程<i class="fa fa-external-link"></i></span></li></ul></li><li><p>CoffeeScript</p><ul><li><span class="exturl" data-url="aHR0cDovL2lzbGFuZDIwNS5naXRodWIuaW8vY29mZmVlc2NyaXB0LWNvb2tib29rLmdpdGh1Yi5jb20v" title="http://island205.github.io/coffeescript-cookbook.github.com/">CoffeeScript Cookbook<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lzbGFuZDIwNS5naXRodWIuaW8vdGxib2Mv" title="http://island205.github.io/tlboc/">The Little Book on CoffeeScript中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZWtwbHV4L2NvZmZlZXNjcmlwdC1zdHlsZS1ndWlkZQ==" title="https://github.com/geekplux/coffeescript-style-guide">CoffeeScript 编码风格指南<i class="fa fa-external-link"></i></span></li></ul></li><li><p>TypeScipt</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aG9uZ3NwLmdpdGJvb2tzLmlvL3R5cGVzY3JpcHQtaGFuZGJvb2svY29udGVudC8=" title="https://zhongsp.gitbooks.io/typescript-handbook/content/">TypeScript Handbook<i class="fa fa-external-link"></i></span></li></ul></li><li><p>ExtJS</p><ul><li><span class="exturl" data-url="aHR0cDovL2V4dGpzLWRvYy1jbi5naXRodWIuaW8vZXh0NGFwaS8=" title="http://extjs-doc-cn.github.io/ext4api/">Ext4.1.0 中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li><p>Meteor</p><ul><li><span class="exturl" data-url="aHR0cDovL3poLmRpc2NvdmVybWV0ZW9yLmNvbS8=" title="http://zh.discovermeteor.com/">Discover Meteor<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3MubWV0ZW9yaHViLm9yZy8jL2Jhc2ljLw==" title="http://docs.meteorhub.org/#/basic/">Meteor 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2FuZ3VsYXIubWV0ZW9yaHViLm9yZy8=" title="http://angular.meteorhub.org/">Angular-Meteor 中文教程<i class="fa fa-external-link"></i></span></li></ul></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9taW5pYm9vay85NTA=" title="http://www.ituring.com.cn/minibook/950">Chrome扩展及应用开发<i class="fa fa-external-link"></i></span></p></li></ul><hr><h3 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h3><ul><li><span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lLzIwMTQvMDkvMDgvbGF0ZXgtaW50cm9kdWN0aW9uLw==" title="http://liam0205.me/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tb2h1Lm9yZy9pbmZvL2xzaG9ydC1jbi5wZGY=" title="http://www.mohu.org/info/lshort-cn.pdf">一份不太简短的 LATEX 2ε 介绍<i class="fa fa-external-link"></i></span> （PDF版）</li></ul><hr><h3 id="LISP"><a href="#LISP" class="headerlink" title="LISP"></a>LISP</h3><ul><li>Common Lisp<ul><li><span class="exturl" data-url="aHR0cDovL2FjbC5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0Lw==" title="http://acl.readthedocs.org/en/latest/">ANSI Common Lisp 中文翻譯版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9taW5pYm9vay84NjI=" title="http://www.ituring.com.cn/minibook/862">On Lisp 中文翻译版本<i class="fa fa-external-link"></i></span></li></ul></li><li>Scheme<ul><li><span class="exturl" data-url="aHR0cDovL2RlYXRoa2luZy5naXRodWIuaW8veWFzdC1jbi8=" title="http://deathking.github.io/yast-cn/">Yet Another Scheme Tutorial Scheme入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvbmdqaW5naGUuZ2l0aHViLmlvL1RZUy16aC10cmFuc2xhdGlvbi8=" title="http://songjinghe.github.io/TYS-zh-translation/">Scheme语言简明教程<i class="fa fa-external-link"></i></span></li><li>Racket<ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cmNoZW4vcmFja2V0LWJvb2s=" title="https://github.com/tyrchen/racket-book">Racket book<i class="fa fa-external-link"></i></span></li></ul></li></ul></li></ul><hr><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuZHljYWkvbHVhcHJpbWVy" title="https://github.com/andycai/luaprimer">Lua编程入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2Rpbmdub3cuY29tLzIwMDAvZG93bmxvYWQvbHVhX21hbnVhbC5odG1s" title="http://www.codingnow.com/2000/download/lua_manual.html">Lua 5.1 参考手册 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Nsb3Vkd3UuZ2l0aHViLmlvL2x1YTUzZG9jLw==" title="http://cloudwu.github.io/lua53doc/">Lua 5.3 参考手册 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2Rpbmdub3cuY29tL3RlbXAvcmVhZGluZ2x1YS5wZGY=" title="http://www.codingnow.com/temp/readinglua.pdf">Lua源码欣赏<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvcnVzL21vZGVybl9wZXJsX2Jvb2s=" title="https://github.com/horus/modern_perl_book">Modern Perl 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3BlcmwubGludXh0b3kub3JnLw==" title="http://perl.linuxtoy.org/">Perl 程序员应该知道的事<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><ul><li><span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poLw==" title="http://php.net/manual/zh/">PHP 官方手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5sYXJ1ZW5jZS5jb20vMjAxMC8wNi8yMS8xNjA4Lmh0bWw=" title="http://www.laruence.com/2010/06/21/1608.html">PHP调试技术手册<i class="fa fa-external-link"></i></span>(PDF)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ibG9na3VuLmNvbS9wcm9qZWN0Lmh0bWw=" title="http://www.blogkun.com/project.html">XDebug 2中文手册(译)<i class="fa fa-external-link"></i></span> (CHM)</li><li><span class="exturl" data-url="aHR0cDovL3d1bGlqdW4uZ2l0aHViLmlvL3BocC10aGUtcmlnaHQtd2F5Lw==" title="http://wulijun.github.io/php-the-right-way/">PHP之道<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1c3RqYXZhYy9QSFAtQmVzdC1QcmFjdGljZXMtemhfQ04=" title="https://github.com/justjavac/PHP-Best-Practices-zh_CN">PHP 最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3J5YW5jYW8uZ2l0Ym9va3MuaW8vcGhwLWRldmVsb3Blci1wcmVwYXJlcy9jb250ZW50Lw==" title="http://ryancao.gitbooks.io/php-developer-prepares/content/">PHP 开发者实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZXplL3RpcGk=" title="https://github.com/reeze/tipi">深入理解PHP内核<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53YWx1LmNjL3BocGJvb2sv" title="http://www.walu.cc/phpbook/">PHP扩展开发及内核应用<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2NvZGVpZ25pdGVyLm9yZy5jbi91c2VyX2d1aWRlL2luZGV4Lmh0bWw=" title="http://codeigniter.org.cn/user_guide/index.html">CodeIgniter 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nb2xhcmF2ZWwuY29tL2RvY3Mv" title="http://www.golaravel.com/docs/">Laravel4 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1YW5naHVhNTgxL2xhcmF2ZWwtZ2V0dGluZy1zdGFydGVk" title="https://github.com/huanghua581/laravel-getting-started">Laravel 入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3N5bWZvbnktZG9jcy1jaHMucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC8=" title="http://symfony-docs-chs.readthedocs.org/en/latest/">Symfony2中文文档<i class="fa fa-external-link"></i></span> (未译完)</li><li><span class="exturl" data-url="aHR0cDovL3BoYWxjb24uNWl1bml4Lm5ldC8=" title="http://phalcon.5iunix.net/">Phalcon中文文档<i class="fa fa-external-link"></i></span>（翻译进行中）</li><li><span class="exturl" data-url="aHR0cDovL3lpaWJvb2suY29tLy9kb2M=" title="http://yiibook.com//doc">YiiBook几本Yii框架的在线教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5kaWdwYWdlLmNvbS8=" title="http://www.digpage.com/">深入理解 Yii 2.0<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy55aWljaGluYS5jb20v" title="http://www.yiichina.com/">Yii 框架中文文檔<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2xpYnJhcnlzL2Jvb2tzL2NvbnRlbnRzL3BocA==" title="http://www.nowamagic.net/librarys/books/contents/php">简单易懂的PHP魔法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpbmtlZERlc3Rpbnkvc3dvb2xlLWRvYw==" title="https://github.com/LinkedDestiny/swoole-doc">swoole文档及入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5waHBjb21wb3Nlci5jb20=" title="http://www.phpcomposer.com">Composer 中文网<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3MS5taW5pbWVlLm9yZy9waHAvc2xpbQ==" title="http://ww1.minimee.org/php/slim">Slim 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2x1bWVuLmxhcmF2ZWwtY2hpbmEub3JnLw==" title="http://lumen.laravel-china.org/">Lumen 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9waHB1bml0LmRlL21hbnVhbC9jdXJyZW50L3poX2NuL2luc3RhbGxhdGlvbi5odG1s" title="https://phpunit.de/manual/current/zh_cn/installation.html">PHPUnit 中文文档<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Prolog"><a href="#Prolog" class="headerlink" title="Prolog"></a>Prolog</h3><ul><li><span class="exturl" data-url="aHR0cDovL2ZlbmdkaWRpLmdpdGh1Yi5pby9ibG9nLzIwMTEvMTEvMTUvcWlhbi15YW4v" title="http://fengdidi.github.io/blog/2011/11/15/qian-yan/">笨办法学Prolog<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDEzNzQ3MzgxMjUwOTVjOTU1YzFlNmQ4YmI0OTMxODIxMDNmYWM5MjcwNzYyYTAwMA==" title="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000">廖雪峰 Python 2.7 中文教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDE0MzE2MDg5NTU3MjY0YTZiMzQ4OTU4ZjQ0OTk0OWRmNDJhNmQzYTJlNTQyYzAwMA==" title="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰 Python 3 中文教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vYWJ5dGVvZnB5dGhvbl9jbi8=" title="http://www.kuqin.com/abyteofpython_cn/">简明Python教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rYW5jbG91ZC5jbi9rYW5jbG91ZC9weXRob24tYmFzaWM=" title="http://www.kancloud.cn/kancloud/python-basic">零基础学 Python 第一版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rYW5jbG91ZC5jbi9rYW5jbG91ZC9zdGFydGVyLWxlYXJuaW5nLXB5dGhvbg==" title="http://www.kancloud.cn/kancloud/starter-learning-python">零基础学 Python 第二版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xvdmVseXB5dGhvbi5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0Lw==" title="http://lovelypython.readthedocs.org/en/latest/">可爱的 Python<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5weXRob25kb2MuY29tL3B5dGhvbnR1dG9yaWFsMjcvaW5kZXguaHRtbA==" title="http://www.pythondoc.com/pythontutorial27/index.html">Python 2.7 官方教程中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5weXRob25kb2MuY29tL3B5dGhvbnR1dG9yaWFsMy9pbmRleC5odG1s" title="http://www.pythondoc.com/pythontutorial3/index.html">Python 3.3 官方教程中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rYW5jbG91ZC5jbi90aGlua3BocC9weXRob24tY29va2Jvb2s=" title="http://www.kancloud.cn/thinkphp/python-cookbook">Python Cookbook 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lpZGFvNjIwYy9weXRob24zLWNvb2tib29r" title="https://github.com/yidao620c/python3-cookbook">Python3 Cookbook 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vZG9jcy9kaXZlaW50b3B5dGhvbnpoLWNuLTUuNGIvaHRtbC90b2Mv" title="http://www.kuqin.com/docs/diveintopythonzh-cn-5.4b/html/toc/">深入 Python<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL29sZC5zZWJ1Zy5uZXQvcGFwZXIvYm9va3MvZGl2ZS1pbnRvLXB5dGhvbjMv" title="http://old.sebug.net/paper/books/dive-into-python3/">深入 Python 3<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC96aG9uZy13aWtpL3dpa2kvUEVQOA==" title="https://code.google.com/p/zhong-wiki/wiki/PEP8">PEP8 Python代码风格规范<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLWdvb2dsZS1zdHlsZWd1aWRlLnJlYWR0aGVkb2NzLm9yZy9lbi9sYXRlc3QvZ29vZ2xlLXB5dGhvbi1zdHlsZWd1aWRlLw==" title="http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/">Google Python 风格指南 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lLzIwMTMvMTEvMDIvUHl0aG9uLXR1dG9yaWFsLXpoX2NuLw==" title="http://liam0205.me/2013/11/02/Python-tutorial-zh_cn/">Python入门教程<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lL2F0dGFjaG1lbnQvUHl0aG9uL1RoZV9QeXRob25fVHV0b3JpYWxfemgtY24ucGRm" title="http://liam0205.me/attachment/Python/The_Python_Tutorial_zh-cn.pdf">PDF<i class="fa fa-external-link"></i></span>)</li><li><span class="exturl" data-url="aHR0cDovL2FydGljbGUueWVleWFuLm9yZy92aWV3LzMxMTUyNy8yODc3MDY=" title="http://article.yeeyan.org/view/311527/287706">Python的神奇方法指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NlYnVnLm5ldC9wYXBlci9ib29rcy9MZWFyblB5dGhvblRoZUhhcmRXYXkv" title="http://sebug.net/paper/books/LearnPythonTheHardWay/">笨办法学 Python<i class="fa fa-external-link"></i></span> （<span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lL2F0dGFjaG1lbnQvUHl0aG9uL1B5SGFyZFdheS9MZWFybl9QeXRob25fVGhlX0hhcmRfV2F5X3poLWNuLnBkZg==" title="http://liam0205.me/attachment/Python/PyHardWay/Learn_Python_The_Hard_Way_zh-cn.pdf">PDF<i class="fa fa-external-link"></i></span>版下载）</li><li><span class="exturl" data-url="aHR0cDovL2RqYW5nb2Jvb2sucHkzay5jbi8yLjAv" title="http://djangobook.py3k.cn/2.0/">The Django Book 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlYnB5Lm9yZy90dXRvcmlhbDMuemgtY24=" title="http://webpy.org/tutorial3.zh-cn">web.py 0.3 新手指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlYnB5Lm9yZy9jb29rYm9vay9pbmRleC56aC1jbg==" title="http://webpy.org/cookbook/index.zh-cn">Web.py Cookbook 简体中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dvb2RwZWNrZXIub3JnLmNuL2RpdmVpbnRvcHl0aG9uLw==" title="http://woodpecker.org.cn/diveintopython/">Dive Into Python 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hc3NvY2lhdGVzLmFtYXpvbi5jbi9ncC9hc3NvY2lhdGVzL25ldHdvcmsvbWFpbi5odG1s" title="https://associates.amazon.cn/gp/associates/network/main.html">Bottle 文档中文版<i class="fa fa-external-link"></i></span> (需翻墙)</li><li><span class="exturl" data-url="aHR0cDovL2RvY3Muamlua2FuLm9yZy9kb2NzL2ZsYXNrLw==" title="http://docs.jinkan.org/docs/flask/">Flask 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3Muamlua2FuLm9yZy9kb2NzL2ppbmphMi8=" title="http://docs.jinkan.org/docs/jinja2/">Jinja2 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlcmt6ZXVnLWRvY3MtY24ucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://werkzeug-docs-cn.readthedocs.org/zh_CN/latest/">Werkzeug 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NwYWNld2FuZGVyLmdpdGh1Yi5pby9leHBsb3JlLWZsYXNrLXpo" title="http://spacewander.github.io/explore-flask-zh">Flask之旅<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RlbW8ucHl0aG9uZXIuY29tL2l0dDJ6aC9pbmRleC5odG1s" title="http://demo.pythoner.com/itt2zh/index.html">Introduction to Tornado 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Bhbi5iYWlkdS5jb20vcy8xcVc0cHZuWQ==" title="http://pan.baidu.com/s/1qW4pvnY">Python自然语言处理中文版<i class="fa fa-external-link"></i></span> （感谢陈涛同学的翻译，也谢谢 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nod2xleQ==" title="https://github.com/shwley">@shwley<i class="fa fa-external-link"></i></span> 联系了作者）</li><li><span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lLzIwMTQvMDkvMTEvbWF0cGxvdGxpYi10dXRvcmlhbC16aC1jbi8=" title="http://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/">Python 绘图库 matplotlib 官方指南中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NjcmFweS1jaHMucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://scrapy-chs.readthedocs.org/zh_CN/latest/">Scrapy 0.25 文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NhcmZseS90aGlua3B5dGhvbi1jbg==" title="https://github.com/carfly/thinkpython-cn">ThinkPython<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS92YW1laS9hcmNoaXZlLzIwMTIvMDkvMTMvMjY4Mjc3OC5odG1s" title="http://www.cnblogs.com/vamei/archive/2012/09/13/2682778.html">Python快速教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dpa2kudWJ1bnR1Lm9yZy5jbi9QeXRob27mraPliJnooajovr7lvI/mk43kvZzmjIfljZc=" title="http://wiki.ubuntu.org.cn/Python正则表达式操作指南">Python 正则表达式操作指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcmlmYW4uY29tL2ZpbGVzL2RvYy9kb2Nib29rL3B5dGhvbl9iZWdpbm5lcl90dXRvcmlhbC9yZWxlYXNlL2h0bWwvcHl0aG9uX2JlZ2lubmVyX3R1dG9yaWFsLmh0bWw=" title="http://www.crifan.com/files/doc/docbook/python_beginner_tutorial/release/html/python_beginner_tutorial.html">python初级教程：入门详解<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3B5dGhvbjMtY29va2Jvb2sucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://python3-cookbook.readthedocs.org/zh_CN/latest/">Python Cookbook 第3版 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xpa2ViZXRhLmdpdGJvb2tzLmlvL3R3aXN0ZWQtaW50cm8tY24v" title="http://likebeta.gitbooks.io/twisted-intro-cn/">Twisted 与异步编程入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3RleHRncm9jZXJ5LnJlYWR0aGVkb2NzLm9yZy96aC9sYXRlc3QvaW5kZXguaHRtbA==" title="http://textgrocery.readthedocs.org/zh/latest/index.html">TextGrocery 中文 API<i class="fa fa-external-link"></i></span> ( 基于svm算法的一个短文本分类 Python 库 )</li><li><span class="exturl" data-url="aHR0cDovL3JlcXVlc3RzLWRvY3MtY24ucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://requests-docs-cn.readthedocs.org/zh_CN/latest/">Requests: HTTP for Humans<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3BpbGxvdy1jbi5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0LyM=" title="http://pillow-cn.readthedocs.org/en/latest/#">Pillow 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3B5bW90d2NuLnJlYWR0aGVkb2NzLm9yZy9lbi9sYXRlc3QvaW5kZXguaHRtbA==" title="http://pymotwcn.readthedocs.org/en/latest/index.html">PyMOTW 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RhdGEuZGlnaXRzZXIubmV0L3poLUNOL3B5dGhvbl9pbmRleC5odG1s" title="http://data.digitser.net/zh-CN/python_index.html">Python 官方文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZhYnJpYy1jaHMucmVhZHRoZWRvY3Mub3Jn" title="http://fabric-chs.readthedocs.org">Fabric 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2JlYXV0aWZ1bHNvdXAucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://beautifulsoup.readthedocs.org/zh_CN/latest/">Beautiful Soup 4.2.0 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL29sZC5zZWJ1Zy5uZXQvcGFwZXIvYm9va3Mvc2NpcHlkb2M=" title="http://old.sebug.net/paper/books/scipydoc">用Python做科学计算<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5weXRob25kb2MuY29tL3NwaGlueC9pbmRleC5odG1s" title="http://www.pythondoc.com/sphinx/index.html">Sphinx 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1bmRpL01hc3RlcmluZy5QeXRob24uRGVzaWduLlBhdHRlcm5z" title="https://github.com/cundi/Mastering.Python.Design.Patterns">精通 Python 设计模式<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYXJ0Rmxhc2gvcHlTZWN1cml0eQ==" title="https://github.com/smartFlash/pySecurity">python 安全编程教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvc2p0dS1jczkwMi1jb3Vyc2V3YXJlL2RldGFpbHM=" title="https://www.gitbook.com/book/wizardforcel/sjtu-cs902-courseware/details">程序设计思想与方法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9yZWFkLmRvdWJhbi5jb20vZWJvb2svMTY2OTE4NDkv" title="https://read.douban.com/ebook/16691849/">知乎周刊·编程小白学Python<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb2dhL3NjaXB5LWxlY3R1cmUtbm90ZXNfY24=" title="https://github.com/cloga/scipy-lecture-notes_cn">Scipy 讲义<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vZG9jcy9weXRob25iYXNpYy5odG1s" title="http://www.kuqin.com/docs/pythonbasic.html">Python 学习笔记 基础篇<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vZG9jcy9weXRob25tb2R1bGUuaHRtbA==" title="http://www.kuqin.com/docs/pythonmodule.html">Python 学习笔记 模块篇<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL29sZC5zZWJ1Zy5uZXQvcGFwZXIvYm9va3MvcHl0aG9uLyVFMyU4MCU4QVB5dGhvbiVFNiVBMCU4NyVFNSU4NyU4NiVFNSVCQSU5MyVFMyU4MCU4QiVFNCVCOCVBRCVFNiU5NiU4NyVFNyU4OSU4OC5wZGY=" title="http://old.sebug.net/paper/books/python/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B%E4%B8%AD%E6%96%87%E7%89%88.pdf">Python 标准库 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9lYXN0bGFrZXNpZGUvaW50ZXJweS16aC9kZXRhaWxz" title="https://www.gitbook.com/book/eastlakeside/interpy-zh/details">Python进阶<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vY29yZS1weXRob24tMmUvY29udGVudC8=" title="https://wizardforcel.gitbooks.io/core-python-2e/content/">Python 核心编程 第二版<i class="fa fa-external-link"></i></span> CPyUG译</li><li><span class="exturl" data-url="aHR0cDovL3B5dGhvbmd1aWRlY24ucmVhZHRoZWRvY3MuaW8vemgvbGF0ZXN0Lw==" title="http://pythonguidecn.readthedocs.io/zh/latest/">Python最佳实践指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvcHl0aG9uLWVzc2VudGlhbC10dXRvcmlhbC9kZXRhaWxz" title="https://www.gitbook.com/book/wizardforcel/python-essential-tutorial/details">Python 精要教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvcHl0aG9uLXF1YW50LXVxZXIvZGV0YWlscw==" title="https://www.gitbook.com/book/wizardforcel/python-quant-uqer/details">Python 量化交易教程<i class="fa fa-external-link"></i></span></li><li>Django<ul><li><span class="exturl" data-url="aHR0cDovL2RqYW5nby1jaGluZXNlLWRvY3MucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC8=" title="http://django-chinese-docs.readthedocs.org/en/latest/">Django 1.5 文档中文版<i class="fa fa-external-link"></i></span> 正在翻译中</li><li><span class="exturl" data-url="aHR0cDovL2RqYW5nby0xLTctZG9jLmNvZGluZy5pby8=" title="http://django-1-7-doc.coding.io/">Diango 1.7 文档中文版<i class="fa fa-external-link"></i></span>  正在翻译中，目前只翻译了目录</li><li><span class="exturl" data-url="aHR0cDovL3B5dGhvbi51c3lpeWkuY24vZGphbmdvL2luZGV4Lmh0bWw=" title="http://python.usyiyi.cn/django/index.html">Django 1.8.2 文档中文版<i class="fa fa-external-link"></i></span><br>正在翻译中</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhbmd5dWJvL3poLWRqYW5nby1iZXN0LXByYWN0aWNlcw==" title="https://github.com/yangyubo/zh-django-best-practices">Django 最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9hbmRyZXctbGl1L2RqYW5nby1ibG9nL2RldGFpbHM=" title="https://www.gitbook.com/book/andrew-liu/django-blog/details">Django搭建简易博客教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RqYW5nb2Jvb2sucHkzay5jbi8yLjAv" title="http://djangobook.py3k.cn/2.0/">The Django Book 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1bmRpL0RqYW5nby1EZXNpZ24tUGF0dGVybnMtYW5kLUJlc3QtUHJhY3RpY2Vz" title="https://github.com/cundi/Django-Design-Patterns-and-Best-Practices">Django 设计模式与最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1bmRpL1dlYi5EZXZlbG9wbWVudC53aXRoLkRqYW5nby5Db29rYm9vaw==" title="https://github.com/cundi/Web.Development.with.Django.Cookbook">Django 网站开发 Cookbook<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9kamFuZ29naXJsc3RhaXBlaS9kamFuZ28tZ2lybHMtdGFpcGVpLXR1dG9yaWFsL2RldGFpbHM=" title="https://www.gitbook.com/book/djangogirlstaipei/django-girls-taipei-tutorial/details">Django Girls 學習指南<i class="fa fa-external-link"></i></span></li></ul></li><li>Flask<ul><li><span class="exturl" data-url="aHR0cDovL2RvY3Muamlua2FuLm9yZy9kb2NzL2ZsYXNrLw==" title="http://docs.jinkan.org/docs/flask/">Flask 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3Muamlua2FuLm9yZy9kb2NzL2ppbmphMi8=" title="http://docs.jinkan.org/docs/jinja2/">Jinja2 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlcmt6ZXVnLWRvY3MtY24ucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://werkzeug-docs-cn.readthedocs.org/zh_CN/latest/">Werkzeug 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NwYWNld2FuZGVyLmdpdGh1Yi5pby9leHBsb3JlLWZsYXNrLXpoLw==" title="http://spacewander.github.io/explore-flask-zh/">Flask之旅<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvZmxhc2stZXh0ZW5zaW9uLWRvY3MvZGV0YWlscw==" title="https://www.gitbook.com/book/wizardforcel/flask-extension-docs/details">Flask 扩展文档汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5weXRob25kb2MuY29tL2ZsYXNrLW1lZ2EtdHV0b3JpYWwvaW5kZXguaHRtbA==" title="http://www.pythondoc.com/flask-mega-tutorial/index.html">Flask 大型教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpeHUwNTIwMjAwNC9zcWxhbGNoZW15LWRvY3MtY24=" title="https://github.com/sixu05202004/sqlalchemy-docs-cn">SQLAlchemy 中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li>web.py<ul><li><span class="exturl" data-url="aHR0cDovL3dlYnB5Lm9yZy90dXRvcmlhbDMuemgtY24=" title="http://webpy.org/tutorial3.zh-cn">web.py 0.3 新手指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlYnB5Lm9yZy9jb29rYm9vay9pbmRleC56aC1jbg==" title="http://webpy.org/cookbook/index.zh-cn">Web.py Cookbook 简体中文版<i class="fa fa-external-link"></i></span></li></ul></li><li>Tornado<ul><li><span class="exturl" data-url="aHR0cDovL2RlbW8ucHl0aG9uZXIuY29tL2l0dDJ6aC9pbmRleC5odG1s" title="http://demo.pythoner.com/itt2zh/index.html">Introduction to Tornado 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2FjYWRlbXkvZGV0YWlsLzEzMzIxMDAy" title="http://www.nowamagic.net/academy/detail/13321002">Tornado源码解析<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90b3JuYWRvLXpoLnJlYWR0aGVkb2NzLm9yZy96aC9sYXRlc3Qv" title="https://tornado-zh.readthedocs.org/zh/latest/">Tornado 4.3 文档中文版<i class="fa fa-external-link"></i></span></li></ul></li></ul><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lpaHVpL3ItbmluamE=" title="https://github.com/yihui/r-ninja">R语言忍者秘笈<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0p1YW5pdG9GYXRhcy9ydWJ5LXN0eWxlLWd1aWRlL2Jsb2IvbWFzdGVyL1JFQURNRS16aENOLm1k" title="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md">Ruby 风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0p1YW5pdG9GYXRhcy9yYWlscy1zdHlsZS1ndWlkZS9ibG9iL21hc3Rlci9SRUFETUUtemhDTi5tZA==" title="https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md">Rails 风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xydGh3LmdpdGh1Yi5pby8=" title="http://lrthw.github.io/">笨方法學 Ruby<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2d1aWRlcy5ydWJ5LWNoaW5hLm9yZy8=" title="http://guides.ruby-china.org/">Ruby on Rails 指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lob3dlci50dy9yYWlsczQvaW5kZXguaHRtbA==" title="http://ihower.tw/rails4/index.html">Ruby on Rails 實戰聖經<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3JhaWxzdHV0b3JpYWwtY2hpbmEub3JnLw==" title="http://railstutorial-china.org/">Ruby on Rails Tutorial 原书第 3 版<i class="fa fa-external-link"></i></span> (本书网页版免费提供，电子版以 PDF、EPub 和 Mobi 格式提供购买，仅售 9.9 美元)</li><li><span class="exturl" data-url="aHR0cDovL3JhaWxzLXByYWN0aWNlLmNvbS9jb250ZW50L2luZGV4Lmh0bWw=" title="http://rails-practice.com/content/index.html">Rails 实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9rZWxieS9yYWlscy1iZWdpbm5lci1zLWd1aWRlL2RldGFpbHM=" title="https://www.gitbook.com/book/kelby/rails-beginner-s-guide/details">Rails 5 开发进阶(Beta)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9yb2NvZGV2L3JhaWxzLTEwMi9kZXRhaWxz" title="https://www.gitbook.com/book/rocodev/rails-102/details">Rails 102<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93dXN1b3B1LmdpdGJvb2tzLmlvL3dyaXRlLXJ1YnktZXh0ZW5zaW9uLXdpdGgtYy9jb250ZW50Lw==" title="https://wusuopu.gitbooks.io/write-ruby-extension-with-c/content/">编写Ruby的C拓展<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ydWJ5LWNoaW5hLm9yZy90b3BpY3MvMjIzODY=" title="https://ruby-china.org/topics/22386">Ruby 源码解读<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RlYXRoa2luZy5naXRodWIuaW8vbWV0YXByb2dyYW1taW5nLWluLXJ1Ynkv" title="http://deathking.github.io/metaprogramming-in-ruby/">Ruby中的元编程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><ul><li><span class="exturl" data-url="aHR0cDovL3R3aXR0ZXIuZ2l0aHViLmlvL3NjYWxhX3NjaG9vbC96aF9jbi9pbmRleC5odG1s" title="http://twitter.github.io/scala_school/zh_cn/index.html">Scala课堂<i class="fa fa-external-link"></i></span> (Twitter的Scala中文教程)</li><li><span class="exturl" data-url="aHR0cDovL3R3aXR0ZXIuZ2l0aHViLmlvL2VmZmVjdGl2ZXNjYWxhL2luZGV4LWNuLmh0bWw=" title="http://twitter.github.io/effectivescala/index-cn.html">Effective Scala<i class="fa fa-external-link"></i></span>(Twitter的Scala最佳实践的中文翻译)</li><li><span class="exturl" data-url="aHR0cDovL3poLnNjYWxhLXRvdXIuY29tLw==" title="http://zh.scala-tour.com/">Scala指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9TY2FsYS1JbXBhdGllbnQtMm5kLUNheS1Ib3JzdG1hbm4vZHAvMDEzNDU0MDU2NQ==" title="https://www.amazon.com/Scala-Impatient-2nd-Cay-Horstmann/dp/0134540565">Scala-for-the-impatient-2nd<i class="fa fa-external-link"></i></span>(自行购买或pdf)</li><li><span class="exturl" data-url="aHR0cDovL2hvbmdqaWFuZy5pbmZvL3NjYWxhLw==" title="http://hongjiang.info/scala/">Scala|写点什么<i class="fa fa-external-link"></i></span>(国人的一个很好的关于Scala的博客)</li></ul><hr><h3 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h3><ul><li><span class="exturl" data-url="aHR0cDovL2RlYXRoa2luZy5naXRodWIuaW8veWFzdC1jbi8=" title="http://deathking.github.io/yast-cn/">Yet Another Scheme Tutorial Scheme入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvbmdqaW5naGUuZ2l0aHViLmlvL1RZUy16aC10cmFuc2xhdGlvbi8=" title="http://songjinghe.github.io/TYS-zh-translation/">Scheme语言简明教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Fpbmp4LzMwbWluX2d1aWRlcy9ibG9iL21hc3Rlci9zaGVsbC5tZA==" title="https://github.com/qinjx/30min_guides/blob/master/shell.md">Shell脚本编程30分钟入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2FlLnNpbmEuY29tLmNuL2FyY2hpdmVzLzM2MDY=" title="http://blog.sae.sina.com.cn/archives/3606">Bash脚本15分钟进阶教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lMTE1L2xpbnV4dG9vbHNfcnN0" title="https://github.com/me115/linuxtools_rst">Linux工具快速教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d6YjU2LzEzX3F1ZXN0aW9uc19vZl9zaGVsbA==" title="https://github.com/wzb56/13_questions_of_shell">shell十三问<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><ul><li><span class="exturl" data-url="aHR0cDovL251bWJiYmJiLmdpdGh1Yi5pby90aGUtc3dpZnQtcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtaW4tY2hpbmVzZS8=" title="http://numbbbbb.github.io/the-swift-programming-language-in-chinese/">The Swift Programming Language 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Rldi5zd2lmdGd1aWRlLmNu" title="http://dev.swiftguide.cn">Swift 语言指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3gxNDB5dS9EZXZlbG9waW5nX2lPU184X0FwcHNfV2l0aF9Td2lmdA==" title="https://github.com/x140yu/Developing_iOS_8_Apps_With_Swift">Stanford 公开课，Developing iOS 8 Apps with Swift 字幕翻译文件<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzNkZ2VuL2NwcHdhc20tYm9vaw==" title="https://github.com/3dgen/cppwasm-book">C/C++面向WebAssembly编程<i class="fa fa-external-link"></i></span></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL0VaTGlwcGkvcHJhY3RpY2FsLXByb2dyYW1taW5nLWJvb2tz&quot; title=&quot;https://github.com/EZLippi/practical-programming-books&quot;&gt;文章来源&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里收录比较实用的计算机相关技术书籍，可以在短期之内入门的简单实用教程、一些技术网站以及一些写的比较好的博文，欢迎Fork，你也可以通过Pull Request参与编辑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5lemxpcHBpLmNvbS9ibG9nLzIwMTQvMDcvcXVhbGlmaWVkLXByb2dyYW1tZXItc2hvdWxkLXJlYWQtd2hhdC1ib29rcy5odG1s&quot; title=&quot;http://www.ezlippi.com/blog/2014/07/qualified-programmer-should-read-what-books.html&quot;&gt;程序员必读书籍&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机相关技术资料整理" scheme="http://miaopei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
    
      <category term="计算机相关技术资料整理" scheme="http://miaopei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vim 快捷键</title>
    <link href="http://miaopei.github.io/2018/03/20/vimHotKey/"/>
    <id>http://miaopei.github.io/2018/03/20/vimHotKey/</id>
    <published>2018-03-20T08:53:46.000Z</published>
    <updated>2019-06-13T06:43:59.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamlxaW5nd3UvYXJjaGl2ZS8yMDEyLzA2LzE0L3ZpbV9ub3Rlcy5odG1s" title="https://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html">Vim使用笔记<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-文档操作"><a href="#1-文档操作" class="headerlink" title="1. 文档操作"></a>1. 文档操作</h2><ul><li><code>:e</code> – 重新加载当前文档。</li><li><code>:e!</code> – 重新加载当前文档，并丢弃已做的改动。</li><li><code>:e file</code> – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。</li><li><code>:e! file</code> – 放弃对当前文件的修改，编辑新的文件。</li><li><code>:e# 或 ctrl+^</code> – 回到刚才编辑的文件，很实用。</li><li><code>gf</code> – 打开以光标所在字符串为文件名的文件。</li><li><code>:saveas newfilename</code> – 另存为</li></ul><a id="more"></a><h2 id="2-光标的移动"><a href="#2-光标的移动" class="headerlink" title="2. 光标的移动"></a>2. 光标的移动</h2><ul><li><code>gj</code> : 移动到一段内的下一行；</li><li><code>gk</code> : 移动到一段内的上一行；</li><li><code>w</code> : 前移一个单词，光标停在下一个单词开头；</li><li><code>b</code> : 后移一个单词，光标停在上一个单词开头；</li><li><code>(</code> : 前移1句。</li><li><code>)</code> : 后移1句。</li><li><code>{</code> : 前移1段。</li><li><code>}</code> : 后移1段。</li><li><code>fc</code> : 把光标移到同一行的下一个 c 字符处</li><li><code>Fc</code> : 把光标移到同一行的上一个 c 字符处</li><li><code>tc</code> : 把光标移到同一行的下一个 c 字符前</li><li><code>Tc</code> : 把光标移到同一行的上一个 c 字符后</li><li><code>;</code> : 配合 <code>f &amp; t</code> 使用，重复一次</li><li><code>,</code> : 配合 <code>f &amp; t</code> 使用，反向重复一次</li></ul><p>上面的操作都可以配合 n 使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动 3 个字符。</p><ul><li><code>0</code> : 移动到行首。</li><li><code>g0</code> : 移到光标所在屏幕行行首。</li><li><code>^</code> : 移动到本行第一个非空白字符。</li><li><code>g^</code>: 同 <code>^</code> ，但是移动到当前屏幕行第一个非空字符处。</li><li><code>$</code> : 移动到行尾。</li><li><code>g$</code> : 移动光标所在屏幕行行尾。</li><li><code>n|</code> : 把光标移到递 n 列上。</li><li><code>nG</code> : 到文件第 n 行。</li><li><code>:n&lt;cr&gt;</code> : 移动到第 n 行。</li><li><code>:$&lt;cr&gt;</code> : 移动到最后一行。</li><li><code>H</code> : 把光标移到屏幕最顶端一行。</li><li><code>M</code> : 把光标移到屏幕中间一行。</li><li><code>L</code> : 把光标移到屏幕最底端一行。</li><li><code>gg</code> : 到文件头部。</li><li><code>G</code> : 到文件尾部。</li></ul><h3 id="2-1-翻屏"><a href="#2-1-翻屏" class="headerlink" title="2.1 翻屏"></a>2.1 翻屏</h3><ul><li><code>ctrl+f</code> : 下翻一屏。</li><li><code>ctrl+b</code> : 上翻一屏。</li><li><code>ctrl+d</code> : 下翻半屏。</li><li><code>ctrl+u</code> : 上翻半屏。</li><li><code>ctrl+e</code> : 向下滚动一行。</li><li><code>ctrl+y</code> : 向上滚动一行。</li><li><code>n%</code> : 到文件 <code>n%</code> 的位置。</li><li><code>zz</code> : 将当前行移动到屏幕中央。</li><li><code>zt</code> : 将当前行移动到屏幕顶端。</li><li><code>zb</code> : 将当前行移动到屏幕底端。</li></ul><h3 id="2-2-标记"><a href="#2-2-标记" class="headerlink" title="2.2 标记"></a>2.2 标记</h3><p>使用标记可以快速移动。到达标记后，可以用 <code>Ctrl+o</code> 返回原来的位置。 <code>Ctrl+o</code> 和 <code>Ctrl+i</code> 很像浏览器上的 <em>后退</em> 和 <em>前进</em> 。</p><ul><li><code>m{a-z}</code> : 标记光标所在位置，局部标记，只用于当前文件。</li><li><code>m{A-Z}</code> : 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li><li>``{a-z}` : 移动到标记位置。</li><li><code>&#39;{a-z}</code> : 移动到标记行的行首。</li><li>``{0-9}` ：回到上[2-10]次关闭vim时最后离开的位置。</li><li>``: 移动到上次编辑的位置。’’ 也可以，不过``精确到列，而 ‘’ 精确到行 。如果想跳转到更老的位置，可以按 C-o，跳转到更新的位置用 C-i。</li><li>`” : 移动到上次离开的地方。</li><li>`. : 移动到最后改动的地方。</li><li><code>:marks</code> – 显示所有标记。</li><li><code>:delmarks a b</code> – 删除标记 a 和 b。</li><li><code>:delmarks a-c</code> – 删除标记 a、b 和 c。</li><li><code>:delmarks a c-f</code> – 删除标记 a、c、d、e、f。</li><li><code>:delmarks!</code> – 删除当前缓冲区的所有标记。</li><li><code>:help mark-motions</code>  – 查看更多关于 mark 的知识。</li></ul><h2 id="3-插入文本"><a href="#3-插入文本" class="headerlink" title="3. 插入文本"></a>3. 插入文本</h2><h3 id="3-1-基本插入"><a href="#3-1-基本插入" class="headerlink" title="3.1 基本插入"></a>3.1 基本插入</h3><ul><li><code>i</code> : 在光标前插入；一个小技巧：按 8，再按 <code>i</code>，进入插入模式，输入 <code>=</code>， 按 <code>esc</code> 进入命令模式，就会出现 8 个 <code>=</code> 。 这在插入分割线时非常有用，如<code>30i+&lt;esc&gt;</code> 就插入了 36 个 <code>+</code> 组成的分割线。</li><li><code>:r filename</code> : 在当前位置插入另一个文件的内容。</li><li><code>:r !date</code> :  在光标处插入当前日期与时间。同理，<code>:r !command</code> 可以将其它 shell 命令的输出插入当前文档。</li></ul><h3 id="3-2-改写插入"><a href="#3-2-改写插入" class="headerlink" title="3.2 改写插入"></a>3.2 改写插入</h3><ul><li><code>c[n]w</code> : 改写光标后 1(n) 个词。</li><li><code>c[n]l</code> : 改写光标后 n 个字母。</li><li><code>c[n]h</code> : 改写光标前 n 个字母。</li><li><code>[n]cc</code> : 修改当前 [n] 行。</li><li><code>[n]s</code> : 以输入的文本替代光标之后 1(n) 个字符，相当于 <code>c[n]l</code>。</li><li><code>[n]S</code> : 删除指定数目的行，并以所输入文本代替之。</li></ul><p>注意，类似 <code>cnw,dnw,ynw</code> 的形式同样可以写为 <code>ncw,ndw,nyw</code>。</p><h2 id="4-剪切复制和寄存器"><a href="#4-剪切复制和寄存器" class="headerlink" title="4. 剪切复制和寄存器"></a>4. 剪切复制和寄存器</h2><h3 id="4-1-剪切和复制、粘贴"><a href="#4-1-剪切和复制、粘贴" class="headerlink" title="4.1 剪切和复制、粘贴"></a>4.1 剪切和复制、粘贴</h3><ul><li><code>[n]x</code> : 剪切光标右边 n 个字符，相当于 <code>d[n]l</code>。</li><li><code>[n]X</code> : 剪切光标左边 n 个字符，相当于 <code>d[n]h</code>。</li><li><code>y</code> : 复制在可视模式下选中的文本。</li><li><code>yy or Y</code> : 复制整行文本。</li><li><code>y[n]w</code> : 复制一 (n) 个词。</li><li><code>y[n]l</code> : 复制光标右边 1(n) 个字符。</li><li><code>y[n]h</code> : 复制光标左边 1(n) 个字符。</li><li><code>y$</code> : 从光标当前位置复制到行尾。</li><li><code>y0</code> : 从光标当前位置复制到行首。</li><li><code>:m,ny&lt;cr&gt;</code> : 复制 m 行到 n 行的内容。</li><li><code>y1G 或 ygg</code> : 复制光标以上的所有行。</li><li><code>yG</code> : 复制光标以下的所有行。</li><li><code>yaw 和 yas</code>：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</li><li><code>d</code> : 删除（剪切）在可视模式下选中的文本。</li><li><code>d$ or D</code> : 删除（剪切）当前位置到行尾的内容。</li><li><code>d[n]w</code>: 删除（剪切）1(n)个单词</li><li><code>d[n]l</code>: 删除（剪切）光标右边 1(n) 个字符。</li><li><code>d[n]h</code>: 删除（剪切）光标左边 1(n) 个字符。</li><li><code>d0</code>: 删除（剪切）当前位置到行首的内容</li><li><code>[n] dd</code>: 删除（剪切）1(n) 行。</li><li><code>:m,nd&lt;cr&gt;</code> : 剪切 m 行到 n 行的内容。</li><li><code>d1G 或 dgg</code> : 剪切光标以上的所有行。</li><li><code>dG</code> : 剪切光标以下的所有行。</li><li><code>daw 和 das</code>：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li><li><code>d/f&lt;cr&gt;</code>：这是一个比较高级的组合命令，它将删除当前位置 到下一个 f 之间的内容。</li><li><code>p</code>: 在光标之后粘贴。</li><li><code>P</code> : 在光标之前粘贴。</li></ul><h3 id="4-2-文本对象"><a href="#4-2-文本对象" class="headerlink" title="4.2 文本对象"></a>4.2 文本对象</h3><ul><li><code>aw</code>：一个词</li><li><code>as</code>：一句。</li><li><code>ap</code>：一段。</li><li><code>ab</code>：一块（包含在圆括号中的）。</li></ul><p><code>y, d, c, v</code> 都可以跟文本对象。</p><h3 id="4-3-寄存器"><a href="#4-3-寄存器" class="headerlink" title="4.3 寄存器"></a>4.3 寄存器</h3><ul><li><code>a-z</code>：都可以用作寄存器名。<code>&quot;ayy</code> 把当前行的内容放入 a 寄存器。</li><li><code>A-Z</code>：用大写字母索引寄存器，可以在寄存器中追加内容。 如 <code>&quot;Ayy</code> 把当前行的内容追加到 a 寄存器中。</li><li><code>:reg</code> : 显示所有寄存器的内容。</li><li><code>&quot;&quot;</code>：不加寄存器索引时，默认使用的寄存器。</li><li><code>&quot;*</code>：当前选择缓冲区，<code>&quot;*yy</code> 把当前行的内容放入当前选择缓冲区。</li><li><code>&quot;+</code>：系统剪贴板。<code>&quot;+yy</code> 把当前行的内容放入系统剪贴板。</li></ul><h2 id="5-查找与替换"><a href="#5-查找与替换" class="headerlink" title="5. 查找与替换"></a>5. 查找与替换</h2><h3 id="5-1-查找"><a href="#5-1-查找" class="headerlink" title="5.1 查找"></a>5.1 查找</h3><ul><li><code>/something</code> : 在后面的文本中查找 something。</li><li><code>?something</code> : 在前面的文本中查找 something。</li><li><code>/pattern/+number</code> : 将光标停在包含 pattern 的行后面第 number 行上。</li><li><code>/pattern/-number</code> : 将光标停在包含 pattern 的行前面第 number 行上。</li><li><code>n</code> : 向后查找下一个。</li><li><code>N</code> : 向前查找下一个。</li></ul><p>可以用 grep 或 vimgrep 查找一个模式都在哪些地方出现过，其中 <code>:grep</code> 是调用外部的 grep 程序，而 <code>:vimgrep</code> 是 vim 自己的查找算法。</p><p>用法为： <code>:vim[grep]/pattern/[g] [j] files</code></p><ul><li><p><code>g</code> 的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p></li><li><p><code>j</code> 的含义是 grep 结束后，结果停在第 j 项，默认是停在第一项。</p></li></ul><p>vimgrep 前面可以加数字限定搜索结果的上限，如 <code>:1vim/pattern/ %</code> 只查找那个模式在本文件中的第一个出现。</p><p>其实 vimgrep 在读纯文本电子书时特别有用，可以生成导航的目录。</p><p>比如电子书中每一节的标题形式为：<code>n. xxxx</code>。你就可以这样：<code>:vim/^d{1,}./ %</code> 然后用 <code>:cw</code> 或 <code>:copen</code> 查看结果，可以用 <code>C-w H</code> 把 quickfix 窗口移到左侧，就更像个目录了。</p><h3 id="5-2-替换"><a href="#5-2-替换" class="headerlink" title="5.2 替换"></a>5.2 替换</h3><ul><li><code>:s/old/new</code> – 用 new 替换当前行第一个 old。</li><li><code>:s/old/new/g</code> – 用 new 替换当前行所有的 old。</li><li><code>:n1,n2s/old/new/g</code> – 用 new 替换文件 n1 行到 n2 行所有的 old。</li><li><code>:%s/old/new/g</code> – 用 new 替换文件中所有的 old。</li><li><code>:%s/^/xxx/g</code> – 在每一行的行首插入 xxx，<code>^</code> 表示行首。</li><li><code>:%s/$/xxx/g</code> – 在每一行的行尾插入 xxx，<code>$</code> 表示行尾。</li><li>所有替换命令末尾加上 c，每个替换都将需要用户确认。 如：<code>%s/old/new/gc</code>，加上i则忽略大小写(ignore)。</li></ul><p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p><p>语法为 <code>:[range]g/pattern/command</code></p><p>例如 <code>: %g/^ xyz/normal dd</code>。</p><p>表示对于以一个空格和 xyz 开头的行执行 normal 模式下的 dd 命令。</p><p>关于 range 的规定为：</p><ul><li>如果不指定 range，则表示当前行。</li><li><code>m,n</code> : 从 m 行到 n 行。</li><li><code>0</code> : 最开始一行（可能是这样）。</li><li><code>$</code> : 最后一行</li><li><code>.</code> : 当前行</li><li><code>%</code> : 所有行</li></ul><h3 id="5-3-正则表达式"><a href="#5-3-正则表达式" class="headerlink" title="5.3 正则表达式"></a>5.3 正则表达式</h3><p>高级的查找替换就要用到正则表达式。</p><ul><li><code>\d</code> : 表示十进制数（我猜的）</li><li><code>\s</code> : 表示空格</li><li><code>\S</code> : 非空字符</li><li><code>\a</code> : 英文字母</li><li><code>\|</code> : 表示 或</li><li><code>\.</code> : 表示.</li><li><code>{m,n}</code> : 表示 m 到 n 个字符。这要和 <code>\s</code> 与 <code>\a</code> 等连用，如 <code>\a\{m,n}</code> 表示 m 到 n 个英文字母。</li><li><code>{m,}</code>: 表示 m 到无限多个字符。</li><li><code>**</code>: 当前目录下的所有子目录。</li></ul><p><code>:help pattern</code> 得到更多帮助。</p><h2 id="6-编辑多个文件"><a href="#6-编辑多个文件" class="headerlink" title="6. 编辑多个文件"></a>6. 编辑多个文件</h2><h3 id="6-1-一次编辑多个文件"><a href="#6-1-一次编辑多个文件" class="headerlink" title="6.1 一次编辑多个文件"></a>6.1 一次编辑多个文件</h3><p>我们可以一次打开多个文件，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi a.txt b.txt c.txt</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>:next(:n)</code> 编辑下一个文件。</li><li><code>:2n</code> 编辑下 2 个文件。</li><li>使用 <code>:previous或:N</code> 编辑上一个文件。</li><li>使用 <code>:wnext</code>，保存当前文件，并编辑下一个文件。</li><li>使用 <code>:wprevious</code>，保存当前文件，并编辑上一个文件。</li><li>使用 <code>:args</code> 显示文件列表。</li><li><code>:n filenames 或 :args filenames</code> 指定新的文件列表。</li><li><code>vi -o filenames</code> 在水平分割的多个窗口中编辑多个文件。</li><li><code>vi -O filenames</code> 在垂直分割的多个窗口中编辑多个文件。</li></ul><h3 id="6-2-多标签编辑"><a href="#6-2-多标签编辑" class="headerlink" title="6.2 多标签编辑"></a>6.2 多标签编辑</h3><ul><li><code>vim -p files</code> : 打开多个文件，每个文件占用一个标签页。</li><li><code>:tabe, tabnew</code> – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li><li><code>^w gf</code> – 在新的标签页里打开光标下路径指定的文件。</li><li><code>:tabn</code> – 切换到下一个标签。<code>Control + PageDown</code>，也可以。</li><li><code>:tabp</code> – 切换到上一个标签。<code>Control + PageUp</code>，也可以。</li><li><code>[n] gt</code> – 切换到下一个标签。如果前面加了 n ， 就切换到第 n 个标签。第一个标签的序号就是 1。</li><li><code>:tab split</code> – 将当前缓冲区的内容在新页签中打开。</li><li><code>:tabc[lose]</code> – 关闭当前的标签页。</li><li><code>:tabo[nly]</code> – 关闭其它的标签页。</li><li><code>:tabs</code> – 列出所有的标签页和它们包含的窗口。</li><li><code>:tabm[ove] [N]</code> – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li></ul><h3 id="6-3-缓冲区"><a href="#6-3-缓冲区" class="headerlink" title="6.3 缓冲区"></a>6.3 缓冲区</h3><ul><li><code>:buffers 或 :ls 或 :files</code> 显示缓冲区列表。</li><li><code>ctrl+^</code>：在最近两个缓冲区间切换。</li><li><code>:bn</code> – 下一个缓冲区。</li><li><code>:bp</code> – 上一个缓冲区。</li><li><code>:bl</code> – 最后一个缓冲区。</li><li><code>:b[n] 或 :[n]b</code> – 切换到第 n 个缓冲区。</li><li><code>:nbw(ipeout)</code> – 彻底删除第 n 个缓冲区。</li><li><code>:nbd(elete)</code> – 删除第 n 个缓冲区，并未真正删除，还在 unlisted 列表中。</li><li><code>:ba[ll]</code> – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li></ul><h2 id="7-分屏编辑"><a href="#7-分屏编辑" class="headerlink" title="7. 分屏编辑"></a>7. 分屏编辑</h2><ul><li><code>vim -o file1 file2</code> : 水平分割窗口，同时打开 file1 和 file2</li><li><code>vim -O file1 file2</code> : 垂直分割窗口，同时打开 file1 和 file2</li></ul><h3 id="7-1-水平分割"><a href="#7-1-水平分割" class="headerlink" title="7.1 水平分割"></a>7.1 水平分割</h3><ul><li><code>:split(:sp)</code> – 把当前窗水平分割成两个窗口。(<code>CTRL-W s</code> 或 <code>CTRL-W CTRL-S</code>) 注意如果在终端下，<code>CTRL-S</code> 可能会冻结终端，请按 <code>CTRL-Q</code> 继续。</li><li><code>:split filename</code> – 水平分割窗口，并在新窗口中显示另一个文件。</li><li><code>:nsplit(:nsp)</code> – 水平分割出一个 n 行高的窗口。</li><li><code>:[N]new</code> – 水平分割出一个N行高的窗口，并编辑一个新文件。 ( <code>CTRL-W n</code> 或  <code>CTRL-W CTRL-N</code>)</li><li><code>ctrl+w f</code> –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li><li><code>C-w C-^</code> – 水平分割一个窗口，打开刚才编辑的文件。</li></ul><h3 id="7-2-垂直分割"><a href="#7-2-垂直分割" class="headerlink" title="7.2 垂直分割"></a>7.2 垂直分割</h3><ul><li><code>:vsplit(:vsp)</code> – 把当前窗口分割成水平分布的两个窗口。 (<code>CTRL-W v</code> 或 <code>CTRL CTRL-V</code>)</li><li><code>:[N]vne[w]</code> – 垂直分割出一个新窗口。</li><li><code>:vertical 水平分割的命令</code>： 相应的垂直分割。</li></ul><h3 id="7-3-关闭子窗口"><a href="#7-3-关闭子窗口" class="headerlink" title="7.3 关闭子窗口"></a>7.3 关闭子窗口</h3><ul><li><code>:qall</code> – 关闭所有窗口，退出 vim。</li><li><code>:wall</code> – 保存所有修改过的窗口。</li><li><code>:only</code> – 只保留当前窗口，关闭其它窗口。(<code>CTRL-W o</code>)</li><li><code>:close</code> – 关闭当前窗口，<code>CTRL-W c</code>能实现同样的功能。 (象 <code>:q :x</code> 同样工作 )</li></ul><h3 id="7-4-调整窗口大小"><a href="#7-4-调整窗口大小" class="headerlink" title="7.4 调整窗口大小"></a>7.4 调整窗口大小</h3><ul><li><code>ctrl+w +</code> –当前窗口增高一行。也可以用 n 增高 n 行。</li><li><code>ctrl+w -</code> –当前窗口减小一行。也可以用 n 减小 n 行。</li><li><code>ctrl+w _</code> –当前窗口扩展到尽可能的大。也可以用 n 设定行数。</li><li><code>:resize n</code> – 当前窗口 n 行高。</li><li><code>ctrl+w =</code> – 所有窗口同样高度。</li><li><code>n ctrl+w _</code> – 当前窗口的高度设定为 n 行。</li><li><code>ctrl+w &lt;</code> –当前窗口减少一列。也可以用 n 减少 n 列。</li><li><code>ctrl+w &gt;</code> –当前窗口增宽一列。也可以用 n 增宽 n 列。</li><li><code>ctrl+w |</code> –当前窗口尽可能的宽。也可以用 n 设定列数。</li></ul><h3 id="7-5-切换和移动窗口"><a href="#7-5-切换和移动窗口" class="headerlink" title="7.5 切换和移动窗口"></a>7.5 切换和移动窗口</h3><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p><ul><li><code>ctrl+w ctrl+w</code> : 切换到下一个窗口。或者是 <code>ctrl+w w</code>。</li><li><code>ctrl+w p</code> : 切换到前一个窗口。</li><li><code>ctrl+w h(l,j,k)</code> :切换到左（右，下，上）的窗口。</li><li><code>ctrl+w t(b)</code> :切换到最上（下）面的窗口。</li><li><code>ctrl+w H(L,K,J)</code> : 将当前窗口移动到最左（右、上、下）面。</li><li><code>ctrl+w r</code>：旋转窗口的位置。</li><li><code>ctrl+w T</code> : 将当前的窗口移动到新的标签页上。</li></ul><h2 id="8-快速编辑"><a href="#8-快速编辑" class="headerlink" title="8. 快速编辑"></a>8. 快速编辑</h2><h3 id="8-1-改变大小写"><a href="#8-1-改变大小写" class="headerlink" title="8.1 改变大小写"></a>8.1 改变大小写</h3><ul><li><code>~</code> : 反转光标所在字符的大小写。</li><li>可视模式下的 U 或 u：把选中的文本变为大写或小写。</li><li><code>gu(U)</code> 接范围（如<code>$</code>，或 <code>G</code>），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如<code>ggguG</code>，就是把开头到最后一行之间的字母全部变为小 写。再如 <code>gu5j</code>，把当前行和下面四行全部变成小写。</li></ul><h3 id="8-2-替换（normal模式）"><a href="#8-2-替换（normal模式）" class="headerlink" title="8.2 替换（normal模式）"></a>8.2 替换（normal模式）</h3><ul><li><code>r</code> : 替换光标处的字符，同样支持汉字。</li><li><code>R</code> : 进入替换模式，按 <code>esc</code> 回到正常模式。</li></ul><h3 id="8-3-撤消与重做（normal模式）"><a href="#8-3-撤消与重做（normal模式）" class="headerlink" title="8.3 撤消与重做（normal模式）"></a>8.3 撤消与重做（normal模式）</h3><ul><li><code>[n] u</code> : 取消一(n)个改动。</li><li><code>:undo 5</code> – 撤销 5 个改变。</li><li><code>:undolist</code> – 你的撤销历史。</li><li><code>ctrl + r</code> : 重做最后的改动。</li><li><code>U</code> : 取消当前行中所有的改动。</li><li><code>:earlier 4m</code> – 回到 4 分钟前</li><li><code>:later 55s</code> – 前进 55 秒</li></ul><h3 id="8-4-宏"><a href="#8-4-宏" class="headerlink" title="8.4 宏"></a>8.4 宏</h3><ul><li><code>.</code> –重复上一个编辑动作</li><li><code>qa</code>：开始录制宏 a（键盘操作记录）</li><li><code>q</code>：停止录制</li><li><code>@a</code>：播放宏 a</li></ul><h2 id="9-编辑特殊文件"><a href="#9-编辑特殊文件" class="headerlink" title="9. 编辑特殊文件"></a>9. 编辑特殊文件</h2><h3 id="9-1-文件加解密"><a href="#9-1-文件加解密" class="headerlink" title="9.1 文件加解密"></a>9.1 文件加解密</h3><ul><li><code>vim -x file</code> : 开始编辑一个加密的文件。</li><li><code>:X</code> – 为当前文件设置密码。</li><li><code>:set key=</code> – 去除文件的密码。</li></ul><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hZG1pbi92aW0tcXVpY2stZWRpdC5odG1s" title="http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html">这里是<i class="fa fa-external-link"></i></span> 滇狐总结的比较高级的 vi 技巧。</p><h3 id="9-2-文件的编码"><a href="#9-2-文件的编码" class="headerlink" title="9.2 文件的编码"></a>9.2 文件的编码</h3><ul><li><code>:e ++enc=utf8 filename</code>, 让 vim 用 utf-8 的编码打开这个文件。</li><li><code>:w ++enc=gbk</code>，不管当前文件什么编码，把它转存成 gbk 编码。</li><li><code>:set fenc 或 :set fileencoding</code>，查看当前文件的编码。</li><li>在 vimrc 中添加 <code>set fileencoding=ucs-bom,utf-8,cp936</code>，vim 会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936 对应于 gbk 编码。 ucs-bom 对应于 windows 下的文件格式。</li></ul><p>让 vim 正确处理文件格式和文件编码，有赖于 <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hZG1pbi92aW1yYy5odG1s" title="http://www.cnblogs.com/jiqingwu/admin/vimrc.html">~/.vimrc的正确配置<i class="fa fa-external-link"></i></span></p><h3 id="9-3-文件格式"><a href="#9-3-文件格式" class="headerlink" title="9.3 文件格式"></a>9.3 文件格式</h3><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p><ul><li><code>:e ++ff=dos filename</code>, 让 vim 用 dos 格式打开这个文件。</li><li><code>:w ++ff=mac filename</code>, 以 mac 格式存储这个文件。</li><li><code>:set ff</code>，显示当前文件的格式。</li><li>在 vimrc 中添加 <code>set fileformats=unix,dos,mac</code>，让 vim 自动识别文件格式。</li></ul><h2 id="10-编程辅助"><a href="#10-编程辅助" class="headerlink" title="10. 编程辅助"></a>10. 编程辅助</h2><h3 id="10-1-一些按键"><a href="#10-1-一些按键" class="headerlink" title="10.1 一些按键"></a>10.1 一些按键</h3><ul><li><code>gd</code> : 跳转到局部变量的定义处；</li><li><code>gD</code> : 跳转到全局变量的定义处，从当前文件开头开始搜索；</li><li><code>g;</code> : 上一个修改过的地方；</li><li><code>g,</code> : 下一个修改过的地方；</li><li><code>[[</code> : 跳转到上一个函数块开始，需要有单独一行的 {。</li><li><code>]]</code> : 跳转到下一个函数块开始，需要有单独一行的 {。</li><li><code>[]</code> : 跳转到上一个函数块结束，需要有单独一行的 }。</li><li><code>][</code> : 跳转到下一个函数块结束，需要有单独一行的 }。</li><li><code>[{</code> : 跳转到当前块开始处；</li><li><code>]}</code> : 跳转到当前块结束处；</li><li><code>[/</code> : 跳转到当前注释块开始处；</li><li><code>]/</code> : 跳转到当前注释块结束处；</li><li><code>%</code> : 不仅能移动到匹配的 <code>(),{} 或 []</code>上，而且能在 <code>#if，#else， #endif</code> 之间跳跃。</li></ul><p>下面的括号匹配对编程很实用的。</p><ul><li><code>ci&#39;, di&#39;, yi&#39;</code>：修改、剪切或复制 <code>&#39;</code> 之间的内容。</li><li><code>ca&#39;, da&#39;, ya&#39;</code>：修改、剪切或复制 <code>&#39;</code> 之间的内容，包含 <code>&#39;</code>。</li><li><code>ci&quot;, di&quot;, yi&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容。</li><li><code>ca&quot;, da&quot;, ya&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容，包含 <code>&quot;</code>。</li><li><code>ci(, di(, yi(</code>：修改、剪切或复制 <code>()</code>之间的内容。</li><li><code>ca(, da(, ya(</code>：修改、剪切或复制 <code>()</code> 之间的内容，包含 <code>()</code>。</li><li><code>ci[, di[, yi[</code>：修改、剪切或复制 <code>[]</code> 之间的内容。</li><li><code>ca[, da[, ya[</code>：修改、剪切或复制 <code>[]</code>之间的内容，包含 <code>[]</code>。</li><li><code>ci{, di{, yi{</code>：修改、剪切或复制 <code>{}</code> 之间的内容。</li><li><code>ca{, da{, ya{</code>：修改、剪切或复制 <code>{}</code> 之间的内容，包含 <code>{}</code>。</li><li><code>ci&lt;, di&lt;, yi&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容。</li><li><code>ca&lt;, da&lt;, ya&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容，包含<code>&lt;&gt;</code>。</li></ul><h3 id="10-2-ctags"><a href="#10-2-ctags" class="headerlink" title="10.2 ctags"></a>10.2 ctags</h3><table><thead><tr><th align="left"><code>Ctrl + ]</code></th><th>找到光标所在位置的标签定义的地方</th></tr></thead><tbody><tr><td align="left"><code>Ctrl + t</code></td><td>回到跳转之前的标签处</td></tr><tr><td align="left"><code>Ctrl + o</code></td><td>退回原来的地方</td></tr><tr><td align="left"><code>[I</code></td><td>查找全局标识符. Vim会列出它所找出的匹配行，<br>不仅在当前文件内查找，还会在所有的包含文件中查找</td></tr><tr><td align="left"><code>[i</code></td><td>从当前文件起始位置开始查找第一处包含光标所指关键字的位置</td></tr><tr><td align="left"><code>]i</code></td><td>类似上面的 <code>[i</code>，但这里是从光标当前位置开始往下搜索</td></tr><tr><td align="left"><code>[{</code></td><td>转到上一个位于第一列的”{“。（前提是 “{” 和 “}” 都在第一列。）</td></tr><tr><td align="left"><code>]}</code></td><td>转到下一个位于第一列的”}”</td></tr><tr><td align="left"><code>Ctrl+＼+ s</code></td><td>会出现所有调用、定义该函数的地方，输入索引号，回车即可</td></tr><tr><td align="left"><code>[ + ctrl + i</code></td><td>跳转到函数、变量和 <code>#define</code>   用 <code>ctrl+o</code> 返回</td></tr><tr><td align="left"><code>[ + ctrl + d</code></td><td>跳转到 <code>#define</code> 处用 <code>ctrl+o</code> 返回</td></tr></tbody></table><ul><li><code>ctags -R</code> : 生成 tag 文件，<code>-R</code> 表示也为子目录中的文件生成 tags</li><li><code>:set tags=path/tags</code> – 告诉 ctags 使用哪个 tag 文件</li><li><code>:tag xyz</code> – 跳到 xyz 的定义处，或者将光标放在 xyz 上按 <code>C-]</code>，返回用 <code>C-t</code></li><li><code>:stag xyz</code> – 用分割的窗口显示 xyz 的定义，或者 <code>C-w ]</code>， 如果用 <code>C-w n ]</code>，就会打开一个 n 行高的窗口</li><li><code>:ptag xyz</code> – 在预览窗口中打开 xyz 的定义，热键是 <code>C-w }</code>。</li><li><code>:pclose</code> – 关闭预览窗口。热键是 <code>C-w z</code>。</li><li><code>:pedit abc.h</code> – 在预览窗口中编辑 abc.h</li><li><code>:psearch abc</code> – 搜索当前文件和当前文件 include 的文件，显示包含 abc 的行。</li></ul><p>有时一个 tag 可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p><ul><li><code>:[n]tnext</code> – 下一 <code>[n]</code> 个匹配。</li><li><code>:[n]tprev</code> – 上一 <code>[n]</code>个匹配。</li><li><code>:tfirst</code> – 第一个匹配</li><li><code>:tlast</code> – 最后一个匹配</li><li><code>:tselect tagname</code> – 打开选择列表</li></ul><p>tab 键补齐</p><ul><li><code>:tag xyz&lt;tab&gt;</code> – 补齐以 xyz 开头的 tag 名，继续按 tab 键，会显示其他的。</li><li><code>:tag /xyz&lt;tab&gt;</code> – 会用名字中含有 xyz 的 tag 名补全。</li></ul><p><strong>ctags 对 c++ 生成 tags</strong> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q</span><br></pre></td></tr></table></figure><p>每个参数解释如下：</p><ul><li><p><code>-R</code> : ctags 循环生成子目录的 tags</p></li><li><p><code>--c++-kinds=+px</code> : ctags 记录 c++ 文件中的函数声明和各种外部和前向声明</p></li><li><p><code>--fields=+iaS</code> : ctags 要求描述的信息</p><ul><li>其中 <code>i</code> 表示如果有继承，则标识出父类；</li><li><code>a</code> 表示如果元素是类成员的话，要标明其调用权限（即是 public 还是 private）；</li><li><code>S</code> 表示如果是函数，则标识函数的 signature。</li></ul></li><li><p><code>--extra=+q</code> : 强制要求 ctags 做如下操作—如果某个语法元素是类的一个成员，ctags 默认会给其记录一行，可以要求 ctags 对同一个语法元斯屹记一行，这样可以保证在 VIM 中多个同名函数可以通过路径不同来区分。</p></li></ul><h3 id="10-3-cscope"><a href="#10-3-cscope" class="headerlink" title="10.3 cscope"></a>10.3 cscope</h3><p>查看阅读 c++ 代码</p><p>cscope 缺省只解析 C 文件 (<code>.c</code> 和 <code>.h</code>)、lex 文件( <code>.l</code> )和 yacc 文件( <code>.y</code> )，虽然它也可以支持 C++ 以及 Java，但它在扫描目录时会跳过 C++ 及  Java 后缀的文件。如果希望 <code>cscope</code> 解析 C++ 或 Java 文件，需要把这些文件的名字和路径保存在一个名为 cscope.files 的文件。当 cscope 发现在当前目录中存在 cscope.files 时，就会为 cscope.files 中列出的所有文件生成索引数据库。</p><p>下面的命令会查找当前目录及子目录中所有后缀名为 <code>&quot;.h&quot;, &quot;.c&quot;, &quot;cc&quot;</code> 和 <code>&quot;.cpp&quot;</code> 的文件，并把查找结果重定向到文件 cscope.files 中。然后 cscope 根据 cscope.files 中的所有文件，生成符号索引文件。最后一条命令使用 ctags 命令，生成一个 tags 文件，在 vim 中执行 <code>&quot;:help tags&quot;</code> 命令查询它的用法。它可以和 cscope 一起使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"*.h"</span> -o -name <span class="string">"*.c"</span> -o -name <span class="string">"*.cc"</span> -o <span class="string">"*.cpp"</span> &gt; cscope.files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cscope -bkq -i cscope.files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ctags -R</span></span><br></pre></td></tr></table></figure><p>​    </p><ul><li><code>cscope -Rbq</code> : 生成 cscope.out 文件</li><li><code>:cs add /path/to/cscope.out /your/work/dir</code></li><li><code>:cs find c func</code> – 查找 func 在哪些地方被调用<ul><li>s: 查找 C 语言符号，即查找函数名、宏、枚举值等出现的地方</li><li>g: 查找函数、宏、枚举等定义的位置，类似 ctags 所提供的功能</li><li>d: 查找本函数调用的函数</li><li>c: 查找调用本函数的函数</li><li>t: 查找指定的字符串</li><li>e: 查找 egrep 模式，相当于 egrep 功能，但查找速度快多了</li><li>f: 查找并打开文件，类似 vim 的 find 功能</li><li>i: 查找包含本文件的文件</li></ul></li><li><code>:cw</code> – 打开 quickfix 窗口查看结果</li></ul><h3 id="10-4-gtags"><a href="#10-4-gtags" class="headerlink" title="10.4 gtags"></a>10.4 gtags</h3><p>Gtags 综合了 ctags 和 cscope 的功能。 使用 Gtags 之前，你需要安装 GNU Gtags。 然后在工程目录运行 gtags 。</p><ul><li><code>:Gtags funcname</code> 定位到 funcname 的定义处。</li><li><code>:Gtags -r funcname</code> 查询 funcname被引用的地方。</li><li><code>:Gtags -s symbol</code> 定位 symbol 出现的地方。</li><li><code>:Gtags -g string</code> Goto string 出现的地方。 <code>:Gtags -gi string</code> 忽略大小写。</li><li><code>:Gtags -f filename</code> 显示 filename 中的函数列表。 你可以用 <code>:Gtags -f %</code> 显示当前文件。</li><li><code>:Gtags -P pattern</code> 显示路径中包含特定模式的文件。 如 <code>:Gtags -P .h$</code> 显示所有头文件， <code>:Gtags -P /vm/</code> 显示 vm 目录下的文件。</li></ul><h3 id="10-5-编译"><a href="#10-5-编译" class="headerlink" title="10.5 编译"></a>10.5 编译</h3><p>vim 提供了 <code>:make</code> 来编译程序，默认调用的是 make， 如果你当前目录下有 makefile，简单地 <code>:make</code> 即可。</p><p>如果你没有 make 程序，你可以通过配置 makeprg 选项来更改 make 调用的程序。 如果你只有一个 abc.java 文件，你可以这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set makeprg=javac\ abc.java</span><br></pre></td></tr></table></figure><p>然后 <code>:make</code> 即可。如果程序有错，可以通过 quickfix 窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让 vim 识别错误信息。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure><p><code>%f</code> 表示文件名，<code>%l</code> 表示行号， <code>%m</code> 表示错误信息，其它的还不能理解。 请参考 <code>:help errorformat</code>。</p><h3 id="10-6-快速修改窗口"><a href="#10-6-快速修改窗口" class="headerlink" title="10.6 快速修改窗口"></a>10.6 快速修改窗口</h3><p>其实是 quickfix 插件提供的功能， 对编译调试程序非常有用 </p><ul><li><code>:copen</code> – 打开快速修改窗口。</li><li><code>:cclose</code> – 关闭快速修改窗口。</li></ul><p>快速修改窗口在 make 程序时非常有用，当 make 之后：</p><ul><li><code>:cl</code> – 在快速修改窗口中列出错误。</li><li><code>:cn</code> – 定位到下一个错误。</li><li><code>:cp</code> – 定位到上一个错误。</li><li><code>:cr</code> – 定位到第一个错误。</li></ul><h3 id="10-7-自动补全"><a href="#10-7-自动补全" class="headerlink" title="10.7 自动补全"></a>10.7 自动补全</h3><ul><li><code>C-x C-s</code> – 拼写建议。</li><li><code>C-x C-v</code> – 补全 vim 选项和命令。</li><li><code>C-x C-l</code> – 整行补全。</li><li><code>C-x C-f</code> – 自动补全文件路径。弹出菜单后，按 <code>C-f</code> 循环选择，当然也可以按 <code>C-n 和 C-p</code>。</li><li><code>C-x C-p 和C-x C-n</code> – 用文档中出现过的单词补全当前的词。 直接按 <code>C-p 和 C-n</code>也可以。</li><li><code>C-x C-o</code> – 编程时可以补全关键字和函数名啊。</li><li><code>C-x C-i</code> – 根据头文件内关键字补全。</li><li><code>C-x C-d</code> – 补全宏定义。</li><li><code>C-x C-n</code> – 按缓冲区中出现过的关键字补全。 直接按 <code>C-n 或 C-p</code> 即可。</li></ul><p>当弹出补全菜单后：</p><ul><li><code>C-p</code> 向前切换成员；</li><li><code>C-n</code> 向后切换成员；</li><li><code>C-e</code> 退出下拉菜单，并退回到原来录入的文字；</li><li><code>C-y</code> 退出下拉菜单，并接受当前选项。</li></ul><h3 id="10-8-多行缩进缩出"><a href="#10-8-多行缩进缩出" class="headerlink" title="10.8 多行缩进缩出"></a>10.8 多行缩进缩出</h3><ul><li>正常模式下，按两下 <code>&gt;;</code> 光标所在行会缩进。</li><li>如果先按了 n，再按两下 <code>&gt;;</code>，光标以下的 n 行会缩进。</li><li>对应的，按两下 <code>&lt;;</code>，光标所在行会缩出。</li><li>如果在编辑代码文件，可以用 <code>=</code> 进行调整。</li><li>在可视模式下，选择要调整的代码块，按 <code>=</code>，代码会按书写规则缩排好。</li><li>或者 <code>n =</code>，调整 n 行代码的缩排。</li></ul><h3 id="10-9-折叠"><a href="#10-9-折叠" class="headerlink" title="10.9 折叠"></a>10.9 折叠</h3><ul><li><code>zf</code> – 创建折叠的命令，可以在一个可视区域上使用该命令；</li><li><code>zd</code> – 删除当前行的折叠；</li><li><code>zD</code> – 删除当前行的折叠；</li><li><code>zfap</code> – 折叠光标所在的段；</li><li><code>zo</code> – 打开折叠的文本；</li><li><code>zc</code> – 收起折叠；</li><li><code>za</code> – 打开/关闭当前折叠；</li><li><code>zr</code> – 打开嵌套的折行；</li><li><code>zm</code> – 收起嵌套的折行；</li><li><code>zR (zO)</code> – 打开所有折行；</li><li><code>zM (zC)</code> – 收起所有折行；</li><li><code>zj</code> – 跳到下一个折叠处；</li><li><code>zk</code> – 跳到上一个折叠处；</li><li><code>zi -- enable/disable fold</code>;</li></ul><h2 id="11-其它"><a href="#11-其它" class="headerlink" title="11. 其它"></a>11. 其它</h2><h3 id="11-1-工作目录"><a href="#11-1-工作目录" class="headerlink" title="11.1 工作目录"></a>11.1 工作目录</h3><ul><li><code>:pwd</code> 显示vim的工作目录。</li><li><code>:cd path</code> 改变 vim 的工作目录。</li><li><code>:set autochdir</code>  可以让 vim 根据编辑的文件自动切换工作目录。</li></ul><h3 id="11-2-一些快捷键（收集中）"><a href="#11-2-一些快捷键（收集中）" class="headerlink" title="11.2 一些快捷键（收集中）"></a>11.2 一些快捷键（收集中）</h3><ul><li><code>K</code> : 打开光标所在词的 manpage。</li><li><code>*</code> : 向下搜索光标所在词。</li><li><code>g*</code> : 同上，但部分符合即可。</li><li><code>\#</code> : 向上搜索光标所在词。</li><li><code>g#</code> : 同上，但部分符合即可。</li><li><code>g C-g</code> : 统计全文或统计部分的字数。</li></ul><h3 id="11-3-在线帮助"><a href="#11-3-在线帮助" class="headerlink" title="11.3 在线帮助"></a>11.3 在线帮助</h3><ul><li><code>:h(elp) 或 F1</code> 打开总的帮助。</li><li><code>:help user-manual</code> 打开用户手册。</li><li>命令帮助的格式为<code>：</code>第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li><li><code>:helptags somepath</code> 为 somepath 中的文档生成索引。</li><li><code>:helpgrep</code> 可以搜索整个帮助文档，匹配的列表显示在 quickfix 窗口中。</li><li><code>Ctrl+]</code> 跳转到 tag 主题，<code>Ctrl+t</code> 跳回。</li><li><code>:ver</code> 显示版本信息。</li></ul><p>高亮所有搜索模式匹配</p><ul><li><p><code>shift + *</code> 向后搜索光标所在位置的单词</p></li><li><p><code>shift + #</code> 向前搜索光标所在位置的单词</p></li><li><p>n 和 N 可以继续向后或者向前搜索匹配的字符串</p></li><li><p><code>:set hlsearch</code>  高亮所有匹配的字符串</p></li><li><p><code>:nohlsearch</code> 临时关闭</p></li><li><p><code>:set nohlsearch</code> 彻底关闭，只有重新 <code>:set hlsearch</code> 才可以高亮搜索</p></li><li><p>vim 高亮显示光标所在的单词，在单词的地方输入 <code>gd</code></p></li></ul><p>语法高亮</p><ul><li><p>syntax on</p></li><li><p>syntax off</p></li></ul><p>vim自动补全</p><ul><li><code>ctrl + n</code> 或者 <code>ctrl + p</code></li></ul><p>复制 vim 文件中所有内容</p><ul><li><p><code>gg</code> 回到文件首</p></li><li><p><code>shift + v</code> 进入 VISUAL LINE 模式</p></li><li><p><code>shift + g</code>  全选所有内容</p></li><li><p><code>ctrl + insert</code> 复制所选的内容</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamlxaW5nd3UvYXJjaGl2ZS8yMDEyLzA2LzE0L3ZpbV9ub3Rlcy5odG1s&quot; title=&quot;https://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html&quot;&gt;Vim使用笔记&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-文档操作&quot;&gt;&lt;a href=&quot;#1-文档操作&quot; class=&quot;headerlink&quot; title=&quot;1. 文档操作&quot;&gt;&lt;/a&gt;1. 文档操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:e&lt;/code&gt; – 重新加载当前文档。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e!&lt;/code&gt; – 重新加载当前文档，并丢弃已做的改动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e file&lt;/code&gt; – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e! file&lt;/code&gt; – 放弃对当前文件的修改，编辑新的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e# 或 ctrl+^&lt;/code&gt; – 回到刚才编辑的文件，很实用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gf&lt;/code&gt; – 打开以光标所在字符串为文件名的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:saveas newfilename&lt;/code&gt; – 另存为&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://miaopei.github.io/categories/Vim/"/>
    
    
      <category term="vim" scheme="http://miaopei.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>网络传输基础</title>
    <link href="http://miaopei.github.io/2018/03/16/web-transmission-basis/"/>
    <id>http://miaopei.github.io/2018/03/16/web-transmission-basis/</id>
    <published>2018-03-16T10:02:52.000Z</published>
    <updated>2019-06-14T09:24:46.793Z</updated>
    
    <content type="html"><![CDATA[<p>示例：Web服务器向Http客户端传送数据的过程:</p><p>在详细阐述网络传输过程之前，先来看一个最常见的例子，下图显示了一个网络服务器向客户端传送数据的完整过程：</p><a id="more"></a><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90202/image002.jpg" alt></p><ol><li>需要传送的数据是网络服务器的HTML页面。</li><li>应用协议HTTP报文首部添加到HTML数据之前。报文头信息包括：服务器所使用的HTTP版本（1.0/1.1），以及表明它包含发给网络客户端信息的状态编码（比如200表示Ok）。</li><li>HTTP应用层协议将HTML格式的网页数据发送给传输层，传输层添加TCP首部信息。TCP传输层用于管理网络服务器和客户端之间的会话，TCP是面向连接的，通过拥赛控制、滑动窗口、超时重传等机制保证数据有效的传输给客户端。</li><li>IP首部添加到TCP首部之前。IP层指定适当的源和目的IP地址。这些信息就构成了IP报文（IP Packet）。</li><li>以太网协议首部添加到IP报文的两端之后，就形成了数据链路帧(frame)。上述帧发送至通向网络客户端的路径上的最近一个路由器（默认网关）。每经过一个路由器会移除以太网信息，观察IP报文，判定最佳路径，将报文插入一个新的帧（下一个路由器的MAC地址），并发送至目标路径上下一个相邻路由器。每一个路由器在转发之前都移除并添加新的数据链路层信息。</li><li>数据通过互联网络传输，互联网络包含媒介和中间设备。</li><li>客户端接收到包含数据的数据链路帧，处理各层协议头，之后以与添加时相反的顺序移除协议头。首先处理并移除以太网信息，之后是IP协议信息，接下来TCP信息，最后是HTTP信息。</li><li>之后，将网页信息传递给客户端网页浏览器，浏览器把HTML网页渲染呈现给用户。</li></ol><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装:"></a>数据封装:</h3><p>消息要在网络中传输，必须对它进行编码，以特定的格式进行封装，同时需要适当地封装以足够的控制和地址信息，以使它能够从发送方移动到接收方。</p><p><strong>消息大小</strong></p><p>理论上，视频或邮件信息是能够以大块非中断型流从网络源地址传送到目的地址，但这也意味着同一时刻同一网络其他设备就无法收发消息。这种大型数据流会造成显著延时。并且，如果传输过程中连接断开，整个数据流都会丢失需要全部重传。因此更好的方法是将数据流分割（segmentation）为较小的，便于管理的片段，能够带来两点好处：</p><ul><li>发送较小片段，网络上同时可有多个会话交错进行。这种在网络上将不同会话片段交错进行的过程称为多路传输（multiplexing）。</li><li>分割可提高网络通讯的可靠性。各消息片段从源地址到目的地址无需经过相同路径，如果一条路径被堵塞或断开，其余消息可从替换路径到达目的地址。如果部分消息到不了目的地址，那只需重传丢失部分。</li></ul><p>通过对片段打上标签的方式来保证顺序以及在接收时重组。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90202/image003.jpg" alt></p><p><strong>协议数据单元（Protocol Data Unit, PDU）</strong></p><p>应用层数据在传输过程中沿着协议栈向下传递，每一层协议都会向其中添加首部信息，TCP首部和IP首部都是20字节的长度。这就是封装的过程。<br>数据片段在各层网络结构中采用的形式就称为协议数据单元（PDU）。封装过程中，下一层对从上一层收到的PDU进行封装。在处理的每一个阶段PDU都有不同的名字来反应它的功能。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90203/image004.jpg" alt></p><p>PDU按照TCP/IP协议的命名规范：</p><ul><li>数据（Data）：应用层PDU的常用术语</li><li>分段（Segment）：传输层PDU</li><li>数据报(Packet): 网络成PDU</li><li>以太网帧（Frame）：链路层PDU</li><li>比特（Bits）：在介质上物理传输数据所使用的PDU。</li></ul><p><strong>封装</strong></p><p>封装是指在传输之前为数据添加额外的协议头信息的过程。在绝大多数数据通信过程中，源数据在传输前都会封装以数层协议。在网络上发送消息时，主机上的协议栈从上至下进行操作。</p><p>以网络服务器为例，HTTP应用层协议发送HTML格式网页数据到传输层，应用层数据被分成TCP分段。各TCP分段被打上标签（主要是端口号，HTTP默认端口为80），称为首部（header），表明接收方哪一个进程应当接收此消息。同时也包含使得接收方能够按照原有的格式来重组数据的信息。</p><p>传输层将网页HTML数据封装成分段并发送至网络层，执行IP层协议。整个TCP分段封装成IP报文，也就是再添上IP首部。IP首部包括源和目的IP地址，以及发送报文到目的地址所必须的信息，包括一些控制字段。</p><p>之后，IP报文发送到链路层，封装以帧头和帧尾。每个帧头都包含源和目的物理地址。物理地址唯一指定了本地网络上的设备。帧尾包含差错校正信息。最后，由服务器网卡将比特编码传输给介质。  </p><p><strong>解封装</strong></p><p>接收主机以相反的方式（从下至上）进行操作称为解封装。解封装是接收设备移除一层或多层协议头的过程。数据在协议栈中向上移动直到终端应用层伴随着解封装。</p><h3 id="访问本地资源："><a href="#访问本地资源：" class="headerlink" title="访问本地资源："></a>访问本地资源：</h3><p>访问本地网络资源需要两种类型的地址：网络层地址和数据链路层地址。网络层和数据链路层负责将数据从发送设备传输至接收设备。两层协议都有源和目的地址，但两种地址的目的不同。</p><p>示例：客户端PC1与FTP在同一IP网络的通信</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90204/image005.jpg" alt></p><p><strong>网络地址</strong></p><p>网络层地址或IP地址包含两个部分：网络号和主机号。路由器使用网络前缀部分将报文转发给适当的网络。最后一个路由器使用主机部分将报文发送给目标设备。同一本地网络中，网络前缀部分是相同的，只有主机设备地址部分不同。</p><p>源IP地址：发送设备，即客户端PC1的IP地址：192.168.1.110</p><p>目的IP地址：接收设备，即FTP服务器：192.168.1.9</p><p><strong>数据链路地址</strong></p><p>数据链路地址（MAC）的目的是在<strong>同一网络中</strong>将数据链路帧从一个网络接口发送至另一个网络接口。以太网LAN和无线网LAN是两种不同物理介质的网络示例，分别有自己的数据链路协议。</p><p>当IP报文的发送方和接收方位于同一网络，数据链路帧直接发送到接收设备（通过ARP来获取目的IP的MAC地址）。以太网上数据链路地址就是以太网MAC地址。MAC地址是物理植入网卡的48比特地址。<br>源MAC地址：发送IP报文的PC1以太网卡MAC地址，AA-AA-AA-AA-AA-AA。</p><p>目的MAC地址：当发送设备与接收设备位于同一网络，即为接收设备的数据链路地址。本例中，FTP MAC地址：CC-CC-CC-CC-CC-CC。</p><p>源和目的MAC地址添加到以太网帧中。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90205/image006.jpg" alt></p><p><strong>MAC与IP地址</strong></p><p>发送方必须知道接收方的物理和逻辑地址。发送方主机能够以多种方式学习到接收方的IP地址：比如浏览器缓存、getHostByName系统调用、域名系统（Domain Name System, DNS），或通过应用手动输入，如用户指定FTP地址。</p><p>以太网MAC地址是怎么识别的呢？发送方主机使用地址解析协议（Address Resolution Protocol, ARP）以检测本地网络的所有MAC地址。如下图所示，发送主机在整个LAN发送ARP请求消息，这是一条广播消息。ARP请求包含目标设备的IP地址，LAN上的每一个设备都会检查该ARP请求，看看是否包含它自身的IP地址。只有符合该IP地址的设备才会发送ARP响应。ARP响应包含ARP请求中IP地址相对应的MAC地址。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90206/670-270/image007.jpg" alt></p><p><strong>访问远程资源：</strong></p><p><strong>默认网关</strong></p><p>当主机发送消息到远端网络，必须使用路由器，也称为默认网关。默认网关就是位于发送主机同一网络上的路由器的接口IP地址。有一点很重要：本地网络上的所有主机都能够配置自己的默认网关地址。如果该主机的TCP/IP设置中没有配置默认网关地址，或指定了错误的默认网关地址，则远端网络消息无法被送达。</p><p>如下图所示，LAN上的主机PC 1使用IP地址为192.168.1.1的R1作为默认网关，如果PDU的目的地址位于另一个网络，则主机将PDU发送至路由器上的默认网关。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90207/image008.jpg" alt></p><p><strong>与远端网络设备通讯</strong></p><p>下图显示了客户端主机PC 1与远端IP网络服务器进行通讯的网络层地址与数据链路层地址：</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90208/image009.jpg" alt></p><p><strong>网络地址</strong></p><p>当报文的发送方与接收方位于不同网络，源和目的IP地址将会代表不同网络上的主机。</p><p>源IP地址：发送设备即客户端主机PC 1的IP地址：192.168.1.110。</p><p>目的IP地址：接收设备即网络服务器的IP地址：172.16.1.99。</p><p><strong>数据链路地址</strong></p><p>当报文的发送方与接收方位于不同网络，以太网数据链路帧无法直接被发送到目的主机。以太网帧必须先发送给路由器或默认网关。本例中，默认网关是R1，R1的接口IP地址与PC 1属于同一网络，因此PC 1能够直接达到路由器。</p><p>源MAC地址：发送设备即PC 1的MAC地址，PC1的以太网接口MAC地址为：AA-AA-AA-AA-AA-AA。</p><p>目的MAC地址：当报文的发送方与接收方位于不同网络，这一值为路由器或默认网关的以太网MAC地址。本例中，即R1的以太网接口MAC地址，即：11-11-11-11-11-11。</p><p>IP报文封装成的以太网帧先被传输至R1，R1再转发给目的地址即网络服务器。R1可以转发给另一个路由器，如果目的服务器所在网路连接至R1，则直接发送给服务器。</p><p>发送设备如何确定路由器的MAC地址？每一个设备通过自己的TCP/IP设置中的默认网关地址得知路由器的IP地址。之后，它通过ARP来得知默认网关的MAC地址，该MAC地址随后添加到帧中。</p>]]></content>
    
    <summary type="html">
    
      理论上，视频或邮件信息是能够以大块非中断型流从网络源地址传送到目的地址，但这也意味着同一时刻同一网络其他设备就无法收发消息。这种大型数据流会造成显著延时。并且，如果传输过程中连接断开，整个数据流都会丢失需要全部重传。因此更好的方法是将数据流分割
    
    </summary>
    
      <category term="other" scheme="http://miaopei.github.io/categories/other/"/>
    
    
      <category term="other" scheme="http://miaopei.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法--图算法介绍</title>
    <link href="http://miaopei.github.io/2018/03/08/graph/"/>
    <id>http://miaopei.github.io/2018/03/08/graph/</id>
    <published>2018-03-08T10:02:52.000Z</published>
    <updated>2019-06-14T09:18:32.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的定义："><a href="#图的定义：" class="headerlink" title="图的定义："></a>图的定义：</h2><p>图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。</p><p>图的种类：地图，电路图，调度图，事物，网络，程序结构</p><p>图的属性：有V个顶点的图最多有V*（V-1）/2条边</p><a id="more"></a><p><img src="/images/imageGraph/graph1.jpg" alt></p><p><img src="/images/imageGraph/graph2.jpg" alt></p><h3 id="邻接矩阵："><a href="#邻接矩阵：" class="headerlink" title="邻接矩阵："></a>邻接矩阵：</h3><p>邻接矩阵是一个元素为bool值的V<em>V矩阵，若图中存在一条连接顶点V和W的边，折矩阵adj[v][w]=1,否则为0。占用的空间为V</em>V，当图是稠密时，邻接矩阵是比较合适的表达方法。</p><p><img src="/images/imageGraph/graph3.jpg" alt></p><h3 id="邻接表的表示"><a href="#邻接表的表示" class="headerlink" title="邻接表的表示"></a>邻接表的表示</h3><p>对于非稠密的图，使用邻接矩阵有点浪费存储空间，可以使用邻接表，我们维护一个链表向量，给定一个顶点时，可以立即访问其链表,占用的空间为O(V+E)。</p><p><img src="/images/imageGraph/graph4.jpg" alt></p><hr><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="深度优先搜索介绍"><a href="#深度优先搜索介绍" class="headerlink" title="深度优先搜索介绍"></a>深度优先搜索介绍</h3><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h3 id="深度优先搜索图解"><a href="#深度优先搜索图解" class="headerlink" title="深度优先搜索图解"></a>深度优先搜索图解</h3><h4 id="无向图的深度优先搜索"><a href="#无向图的深度优先搜索" class="headerlink" title="无向图的深度优先搜索"></a>无向图的深度优先搜索</h4><p>下面以”无向图”为例，来对深度优先搜索进行演示。</p><p><img src="/images/imageGraph/graph5.jpg" alt></p><p>对上面的图G1进行深度优先遍历，从顶点A开始。</p><p><img src="/images/imageGraph/graph6.jpg" alt></p><ul><li><p>第1步：访问A。</p></li><li><p>第2步：访问(A的邻接点)C。</p><p> 在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。 </p></li><li><p>第3步：访问(C的邻接点)B。</p><p> 在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 </p></li><li><p>第4步：访问(C的邻接点)D。</p><p> 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 </p></li><li><p>第5步：访问(A的邻接点)F。</p><p> 前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。 </p></li><li><p>第6步：访问(F的邻接点)G。</p></li><li><p>第7步：访问(G的邻接点)E。</p></li></ul><p>因此访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</p><h4 id="有向图的深度优先搜索"><a href="#有向图的深度优先搜索" class="headerlink" title="有向图的深度优先搜索"></a>有向图的深度优先搜索</h4><p>下面以”有向图”为例，来对深度优先搜索进行演示。</p><p><img src="/images/imageGraph/graph7.jpg" alt></p><p>对上面的图G2进行深度优先遍历，从顶点A开始。</p><p><img src="/images/imageGraph/graph8.jpg" alt></p><ul><li><p>第1步：访问A。</p></li><li><p>第2步：访问B。</p><p> 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 </p></li><li><p>第3步：访问C。</p><p> 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 </p></li><li><p>第4步：访问E。</p><p> 接下来访问C的出边的另一个顶点，即顶点E。 </p></li><li><p>第5步：访问D。</p><p> 接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 </p></li><li><p>第6步：访问F。</p><p> 接下应该回溯”访问A的出边的另一个顶点F”。 </p></li><li><p>第7步：访问G。</p></li></ul><p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</p><hr><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="广度优先搜索介绍"><a href="#广度优先搜索介绍" class="headerlink" title="广度优先搜索介绍"></a>广度优先搜索介绍</h3><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p><h3 id="广度优先搜索图解"><a href="#广度优先搜索图解" class="headerlink" title="广度优先搜索图解"></a>广度优先搜索图解</h3><h4 id="无向图的广度优先搜索"><a href="#无向图的广度优先搜索" class="headerlink" title="无向图的广度优先搜索"></a>无向图的广度优先搜索</h4><p>下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。</p><p><img src="/images/imageGraph/graph9.jpg" alt></p><ul><li><p>第1步：访问A。</p></li><li><p>第2步：依次访问C,D,F。</p><p> 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 </p></li><li><p>第3步：依次访问B,G。</p><p> 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 </p></li><li><p>第4步：访问E。</p><p> 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p></li></ul><p>因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</p><h4 id="有向图的广度优先搜索"><a href="#有向图的广度优先搜索" class="headerlink" title="有向图的广度优先搜索"></a>有向图的广度优先搜索</h4><p>下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。</p><p><img src="/images/imageGraph/graph10.jpg" alt></p><ul><li><p>第1步：访问A。</p></li><li><p>第2步：访问B。</p></li><li><p>第3步：依次访问C,E,F。</p><p>在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 </p></li><li><p>第4步：依次访问D,G。</p><p> 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p></li></ul><p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</p><h2 id="搜索算法的源码"><a href="#搜索算法的源码" class="headerlink" title="搜索算法的源码"></a>搜索算法的源码</h2><details><summary>1. 邻接矩阵表示的"无向图</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* C++: 邻接矩阵表示的"无向图(Matrix Undirected Graph)"</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @author LippiOuYang</span></span><br><span class="line"><span class="comment">* @date 2013/04/19</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MatrixUDG</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> mVexs[MAX];    <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="keyword">int</span> mVexNum;             <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">int</span> mEdgNum;             <span class="comment">// 边数</span></span><br><span class="line">    <span class="keyword">int</span> mMatrix[MAX][MAX];   <span class="comment">// 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建图(自己输入数据)</span></span><br><span class="line">    MatrixUDG();</span><br><span class="line">    <span class="comment">// 创建图(用已提供的矩阵)</span></span><br><span class="line">    MatrixUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen);</span><br><span class="line">    ~MatrixUDG();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索遍历图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 广度优先搜索（类似于树的层次遍历）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 打印矩阵队列图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 读取一个输入字符</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回ch在mMatrix矩阵中的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line">    <span class="comment">// 返回顶点v的第一个邻接顶点的索引，失败则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstVertex</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">    <span class="comment">// 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextVertex</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line">    <span class="comment">// 深度优先搜索遍历图的递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 创建图(自己输入数据)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MatrixUDG::MatrixUDG()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">int</span> i, p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入"顶点数"和"边数"</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input vertex number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mVexNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input edge number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mEdgNum;</span><br><span class="line">    <span class="keyword">if</span> ( mVexNum &lt; <span class="number">1</span> || mEdgNum &lt; <span class="number">1</span> || (mEdgNum &gt; (mVexNum * (mVexNum<span class="number">-1</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"input error: invalid parameters!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"顶点"</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"vertex("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        mVexs[i] = readChar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"边"</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mEdgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"edge("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        c1 = readChar();</span><br><span class="line">        c2 = readChar();</span><br><span class="line"></span><br><span class="line">        p1 = getPosition(c1);</span><br><span class="line">        p2 = getPosition(c2);</span><br><span class="line">        <span class="keyword">if</span> (p1==<span class="number">-1</span> || p2==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"input error: invalid edge!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mMatrix[p1][p2] = <span class="number">1</span>;</span><br><span class="line">        mMatrix[p2][p1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建图(用已提供的矩阵)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     vexs  -- 顶点数组</span></span><br><span class="line"><span class="comment"> *     vlen  -- 顶点数组的长度</span></span><br><span class="line"><span class="comment"> *     edges -- 边数组</span></span><br><span class="line"><span class="comment"> *     elen  -- 边数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MatrixUDG::MatrixUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"顶点数"和"边数"</span></span><br><span class="line">    mVexNum = vlen;</span><br><span class="line">    mEdgNum = elen;</span><br><span class="line">    <span class="comment">// 初始化"顶点"</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        mVexs[i] = vexs[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"边"</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mEdgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">        p1 = getPosition(edges[i][<span class="number">0</span>]);</span><br><span class="line">        p2 = getPosition(edges[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        mMatrix[p1][p2] = <span class="number">1</span>;</span><br><span class="line">        mMatrix[p2][p1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MatrixUDG::~MatrixUDG() </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回ch在mMatrix矩阵中的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> MatrixUDG::getPosition(<span class="keyword">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</span><br><span class="line">        <span class="keyword">if</span>(mVexs[i]==ch)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取一个输入字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> MatrixUDG::readChar()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!((ch&gt;=<span class="string">'a'</span>&amp;&amp;ch&lt;=<span class="string">'z'</span>) || (ch&gt;=<span class="string">'A'</span>&amp;&amp;ch&lt;=<span class="string">'Z'</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回顶点v的第一个邻接顶点的索引，失败则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> MatrixUDG::firstVertex(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (v&lt;<span class="number">0</span> || v&gt;(mVexNum<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        <span class="keyword">if</span> (mMatrix[v][i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> MatrixUDG::nextVertex(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (v&lt;<span class="number">0</span> || v&gt;(mVexNum<span class="number">-1</span>) || w&lt;<span class="number">0</span> || w&gt;(mVexNum<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = w + <span class="number">1</span>; i &lt; mVexNum; i++)</span><br><span class="line">        <span class="keyword">if</span> (mMatrix[v][i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度优先搜索遍历图的递归实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> MatrixUDG::DFS(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    visited[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mVexs[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走</span></span><br><span class="line">    <span class="keyword">for</span> (w = firstVertex(i); w &gt;= <span class="number">0</span>; w = nextVertex(i, w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            DFS(w, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度优先搜索遍历图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> MatrixUDG::DFS()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> visited[MAX];       <span class="comment">// 顶点访问标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有顶点都没有被访问</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++) &#123;</span><br><span class="line">        <span class="comment">//printf("\n== LOOP(%d)\n", i);</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[i])</span><br><span class="line">            DFS(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 广度优先搜索（类似于树的层次遍历）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> MatrixUDG::BFS()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[MAX];     <span class="comment">// 辅组队列</span></span><br><span class="line">    <span class="keyword">int</span> visited[MAX];   <span class="comment">// 顶点访问标记</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"BFS: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mVexs[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="built_in">queue</span>[rear++] = i;  <span class="comment">// 入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head != rear)  &#123;</span><br><span class="line">            j = <span class="built_in">queue</span>[head++];  <span class="comment">// 出队列</span></span><br><span class="line">            <span class="keyword">for</span> (k = firstVertex(j); k &gt;= <span class="number">0</span>; k = nextVertex(j, k)) &#123; <span class="comment">//k是为访问的邻接顶点</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[k]) &#123;</span><br><span class="line">                    visited[k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; mVexs[k] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                    <span class="built_in">queue</span>[rear++] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印矩阵队列图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> MatrixUDG::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Martix Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; mVexNum; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mMatrix[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> vexs[] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> edges[][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'D'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'F'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'C'</span>, <span class="string">'D'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'E'</span>, <span class="string">'G'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'F'</span>, <span class="string">'G'</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> vlen = <span class="keyword">sizeof</span>(vexs)/<span class="keyword">sizeof</span>(vexs[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> elen = <span class="keyword">sizeof</span>(edges)/<span class="keyword">sizeof</span>(edges[<span class="number">0</span>]);</span><br><span class="line">    MatrixUDG* pG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义"图"(输入矩阵队列)</span></span><br><span class="line">    <span class="comment">// pG = new MatrixUDG();</span></span><br><span class="line">    <span class="comment">// 采用已有的"图"</span></span><br><span class="line">    pG = <span class="keyword">new</span> MatrixUDG(vexs, vlen, edges, elen);</span><br><span class="line">    pG-&gt;print();   <span class="comment">// 打印图</span></span><br><span class="line">    pG-&gt;DFS();     <span class="comment">// 深度优先遍历</span></span><br><span class="line">    pG-&gt;BFS();     <span class="comment">// 广度优先遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </details><details><summary>2. 邻接表表示的"无向图</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++: 邻接表表示的"无向图(List Undirected Graph)"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author LippiOuYang</span></span><br><span class="line"><span class="comment"> * @date 2013/04/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListUDG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 内部类</span></span><br><span class="line">    <span class="comment">// 邻接表中表对应的链表的顶点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ENode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> ivex;           <span class="comment">// 该边所指向的顶点的位置</span></span><br><span class="line">        ENode *nextEdge;    <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邻接表中表的顶点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">char</span> data;          <span class="comment">// 顶点信息</span></span><br><span class="line">        ENode *firstEdge;   <span class="comment">// 指向第一条依附该顶点的弧</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有成员</span></span><br><span class="line">    <span class="keyword">int</span> mVexNum;             <span class="comment">// 图的顶点的数目</span></span><br><span class="line">    <span class="keyword">int</span> mEdgNum;             <span class="comment">// 图的边的数目</span></span><br><span class="line">    VNode mVexs[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建邻接表对应的图(自己输入)</span></span><br><span class="line">    ListUDG();</span><br><span class="line">    <span class="comment">// 创建邻接表对应的图(用已提供的数据)</span></span><br><span class="line">    ListUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen);</span><br><span class="line">    ~ListUDG();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索遍历图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 广度优先搜索（类似于树的层次遍历）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 打印邻接表图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 读取一个输入字符</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回ch的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line">    <span class="comment">// 深度优先搜索遍历图的递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span></span>;</span><br><span class="line">    <span class="comment">// 将node节点链接到list的最后</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(ENode *<span class="built_in">list</span>, ENode *node)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建邻接表对应的图(自己输入)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ListUDG::ListUDG()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">int</span> v, e;</span><br><span class="line">    <span class="keyword">int</span> i, p1, p2;</span><br><span class="line">    ENode *node1, *node2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入"顶点数"和"边数"</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input vertex number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mVexNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input edge number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mEdgNum;</span><br><span class="line">    <span class="keyword">if</span> ( mVexNum &lt; <span class="number">1</span> || mEdgNum &lt; <span class="number">1</span> || (mEdgNum &gt; (mVexNum * (mVexNum<span class="number">-1</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"input error: invalid parameters!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"邻接表"的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"vertex("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        mVexs[i].data = readChar();</span><br><span class="line">        mVexs[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"邻接表"的边</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mEdgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"edge("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        c1 = readChar();</span><br><span class="line">        c2 = readChar();</span><br><span class="line"></span><br><span class="line">        p1 = getPosition(c1);</span><br><span class="line">        p2 = getPosition(c2);</span><br><span class="line">        <span class="comment">// 初始化node1</span></span><br><span class="line">        node1 = <span class="keyword">new</span> ENode();</span><br><span class="line">        node1-&gt;ivex = p2;</span><br><span class="line">        <span class="comment">// 将node1链接到"p1所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span>(mVexs[p1].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            mVexs[p1].firstEdge = node1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkLast(mVexs[p1].firstEdge, node1);</span><br><span class="line">        <span class="comment">// 初始化node2</span></span><br><span class="line">        node2 = <span class="keyword">new</span> ENode();</span><br><span class="line">        node2-&gt;ivex = p1;</span><br><span class="line">        <span class="comment">// 将node2链接到"p2所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span>(mVexs[p2].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            mVexs[p2].firstEdge = node2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkLast(mVexs[p2].firstEdge, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建邻接表对应的图(用已提供的数据)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ListUDG::ListUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">int</span> i, p1, p2;</span><br><span class="line">    ENode *node1, *node2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"顶点数"和"边数"</span></span><br><span class="line">    mVexNum = vlen;</span><br><span class="line">    mEdgNum = elen;</span><br><span class="line">    <span class="comment">// 初始化"邻接表"的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mVexs[i].data = vexs[i];</span><br><span class="line">        mVexs[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"邻接表"的边</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mEdgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">        c1 = edges[i][<span class="number">0</span>];</span><br><span class="line">        c2 = edges[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        p1 = getPosition(c1);</span><br><span class="line">        p2 = getPosition(c2);</span><br><span class="line">        <span class="comment">// 初始化node1</span></span><br><span class="line">        node1 = <span class="keyword">new</span> ENode();</span><br><span class="line">        node1-&gt;ivex = p2;</span><br><span class="line">        <span class="comment">// 将node1链接到"p1所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span>(mVexs[p1].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            mVexs[p1].firstEdge = node1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkLast(mVexs[p1].firstEdge, node1);</span><br><span class="line">        <span class="comment">// 初始化node2</span></span><br><span class="line">        node2 = <span class="keyword">new</span> ENode();</span><br><span class="line">        node2-&gt;ivex = p1;</span><br><span class="line">        <span class="comment">// 将node2链接到"p2所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span>(mVexs[p2].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            mVexs[p2].firstEdge = node2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkLast(mVexs[p2].firstEdge, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ListUDG::~ListUDG() </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将node节点链接到list的最后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::linkLast(ENode *<span class="built_in">list</span>, ENode *node)</span><br><span class="line">&#123;</span><br><span class="line">    ENode *p = <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;nextEdge)</span><br><span class="line">        p = p-&gt;nextEdge;</span><br><span class="line">    p-&gt;nextEdge = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回ch的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ListUDG::getPosition(<span class="keyword">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</span><br><span class="line">        <span class="keyword">if</span>(mVexs[i].data==ch)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取一个输入字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> ListUDG::readChar()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!((ch&gt;=<span class="string">'a'</span>&amp;&amp;ch&lt;=<span class="string">'z'</span>) || (ch&gt;=<span class="string">'A'</span>&amp;&amp;ch&lt;=<span class="string">'Z'</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度优先搜索遍历图的递归实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::DFS(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span><br><span class="line">&#123;</span><br><span class="line">    ENode *node;</span><br><span class="line"></span><br><span class="line">    visited[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    node = mVexs[i].firstEdge;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[node-&gt;ivex])</span><br><span class="line">            DFS(node-&gt;ivex, visited);</span><br><span class="line">        node = node-&gt;nextEdge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度优先搜索遍历图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::DFS()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> visited[MAX];       <span class="comment">// 顶点访问标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有顶点都没有被访问</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i])</span><br><span class="line">            DFS(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 广度优先搜索（类似于树的层次遍历）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::BFS()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[MAX];     <span class="comment">// 辅组队列</span></span><br><span class="line">    <span class="keyword">int</span> visited[MAX];   <span class="comment">// 顶点访问标记</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    ENode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"BFS: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="built_in">queue</span>[rear++] = i;  <span class="comment">// 入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head != rear) </span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="built_in">queue</span>[head++];  <span class="comment">// 出队列</span></span><br><span class="line">            node = mVexs[j].firstEdge;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k = node-&gt;ivex;</span><br><span class="line">                <span class="keyword">if</span> (!visited[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; mVexs[k].data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                    <span class="built_in">queue</span>[rear++] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node-&gt;nextEdge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印邻接表图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    ENode *node;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"List Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"("</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        node = mVexs[i].firstEdge;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node-&gt;ivex &lt;&lt; <span class="string">"("</span> &lt;&lt; mVexs[node-&gt;ivex].data &lt;&lt; <span class="string">") "</span>;</span><br><span class="line">            node = node-&gt;nextEdge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> vexs[] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> edges[][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'D'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'F'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'C'</span>, <span class="string">'D'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'E'</span>, <span class="string">'G'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'F'</span>, <span class="string">'G'</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> vlen = <span class="keyword">sizeof</span>(vexs)/<span class="keyword">sizeof</span>(vexs[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> elen = <span class="keyword">sizeof</span>(edges)/<span class="keyword">sizeof</span>(edges[<span class="number">0</span>]);</span><br><span class="line">    ListUDG* pG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义"图"(输入矩阵队列)</span></span><br><span class="line">    <span class="comment">//pG = new ListUDG();</span></span><br><span class="line">    <span class="comment">// 采用已有的"图"</span></span><br><span class="line">    pG = <span class="keyword">new</span> ListUDG(vexs, vlen, edges, elen);</span><br><span class="line"></span><br><span class="line">    pG-&gt;print();   <span class="comment">// 打印图</span></span><br><span class="line">    pG-&gt;DFS();     <span class="comment">// 深度优先遍历</span></span><br><span class="line">    pG-&gt;BFS();     <span class="comment">// 广度优先遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><hr><h2 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h2><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p><p>此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p><p>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul><li><p>(1)</p><p>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</p></li><li><p>(2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</p></li><li><p>(3)</p><p>更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</p></li><li><p>(4) 重复步骤(2)和(3)，直到遍历完所有顶点。</p></li></ul><p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><p>5.3迪杰斯特拉算法图解</p><p><img src="/images/imageGraph/graph11.jpg" alt></p><p>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。</p><p><img src="/images/imageGraph/graph12.jpg" alt></p><ul><li><p>初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！</p></li><li><p>第1步：将顶点D加入到S中。</p><p> 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。     注:C(3)表示C到起点D的距离是3。</p></li><li><p>第2步：将顶点C加入到S中。</p><p> 上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。<br> 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。</p></li><li><p>第3步：将顶点E加入到S中。</p><p> 上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 </p><p> 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。</p></li><li><p>第4步：将顶点F加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</p></li><li><p>第5步：将顶点G加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p></li><li><p>第6步：将顶点B加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p></li><li><p>第7步：将顶点A加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p></li></ul><p>此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>本文以”邻接矩阵”为例对迪杰斯特拉算法进行说明，</p><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> vexs[MAX];       <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="keyword">int</span> vexnum;           <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">int</span> edgnum;           <span class="comment">// 边数</span></span><br><span class="line">    <span class="keyword">int</span> matrix[MAX][MAX]; <span class="comment">// 邻接矩阵</span></span><br><span class="line">&#125;Graph, *PGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EdgeData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> start; <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="keyword">char</span> end;   <span class="comment">// 边的终点</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">// 边的权重</span></span><br><span class="line">&#125;EData;</span><br></pre></td></tr></table></figure><p>Graph是邻接矩阵对应的结构体。 </p><p>vexs用于保存顶点，vexnum是顶点数，edgnum是边数；matrix则是用于保存矩阵信息的二维数组。例如，matrix[i][j]=1，则表示”顶点i(即vexs[i])”和”顶点j(即vexs[j])”是邻接点；matrix[i][j]=0，则表示它们不是邻接点。 </p><p>EData是邻接矩阵边对应的结构体。</p><h4 id="迪杰斯特拉算法-1"><a href="#迪杰斯特拉算法-1" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h4><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dijkstra最短路径。</span></span><br><span class="line"><span class="comment"> * 即，统计图(G)中"顶点vs"到其它各个顶点的最短路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     G -- 图</span></span><br><span class="line"><span class="comment"> *     vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。</span></span><br><span class="line"><span class="comment"> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。</span></span><br><span class="line"><span class="comment"> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Graph G, <span class="keyword">int</span> vs, <span class="keyword">int</span> prev[], <span class="keyword">int</span> dist[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> flag[MAX];      <span class="comment">// flag[i]=1表示"顶点vs"到"顶点i"的最短路径已成功获取。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[i] = <span class="number">0</span>;              <span class="comment">// 顶点i的最短路径还没获取到。</span></span><br><span class="line">        prev[i] = <span class="number">0</span>;              <span class="comment">// 顶点i的前驱顶点为0。</span></span><br><span class="line">        dist[i] = G.matrix[vs][i];<span class="comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对"顶点vs"自身进行</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    flag[vs] = <span class="number">1</span>;</span><br><span class="line">    dist[vs] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历G.vexnum-1次；每次找出一个顶点的最短路径。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 寻找当前最小的路径；</span></span><br><span class="line">        <span class="comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span></span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[j]==<span class="number">0</span> &amp;&amp; dist[j]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记"顶点k"为已经获取到最短路径</span></span><br><span class="line">        flag[k] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修正当前最短路径和前驱顶点</span></span><br><span class="line">        <span class="comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = (G.matrix[k][j]==INF ? INF : (min + G.matrix[k][j])); <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="number">0</span> &amp;&amp; (tmp  &lt; dist[j]) )</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = tmp;</span><br><span class="line">                prev[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印dijkstra最短路径的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dijkstra(%c): \n"</span>, G.vexs[vs]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  shortest(%c, %c)=%d\n"</span>, G.vexs[vs], G.vexs[i], dist[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的定义：&quot;&gt;&lt;a href=&quot;#图的定义：&quot; class=&quot;headerlink&quot; title=&quot;图的定义：&quot;&gt;&lt;/a&gt;图的定义：&lt;/h2&gt;&lt;p&gt;图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。&lt;/p&gt;
&lt;p&gt;图的种类：地图，电路图，调度图，事物，网络，程序结构&lt;/p&gt;
&lt;p&gt;图的属性：有V个顶点的图最多有V*（V-1）/2条边&lt;/p&gt;
    
    </summary>
    
      <category term="graph" scheme="http://miaopei.github.io/categories/graph/"/>
    
      <category term="algorithm" scheme="http://miaopei.github.io/categories/graph/algorithm/"/>
    
    
      <category term="graph" scheme="http://miaopei.github.io/tags/graph/"/>
    
      <category term="algorithm" scheme="http://miaopei.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Git操作手册|命令速查表</title>
    <link href="http://miaopei.github.io/2018/02/27/git-guide/"/>
    <id>http://miaopei.github.io/2018/02/27/git-guide/</id>
    <published>2018-02-27T10:02:52.000Z</published>
    <updated>2019-06-14T08:26:36.372Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。<br>本文分为以下几个部分：</p><ol><li>Git与SVN差异</li><li>Git常用命令</li><li>Git进阶指南</li></ol><a id="more"></a><h2 id="Git与SVN差异"><a href="#Git与SVN差异" class="headerlink" title="Git与SVN差异"></a>Git与SVN差异</h2><p>Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。</p><p>Git 和 SVN 思想最大的差别有四个：</p><ul><li>去中心化</li><li>直接记录快照，而非差异</li><li>不一样的分支概念</li><li>三个文件状态</li></ul><p><strong>去中心化</strong></p><p>Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西 ， 所有的数据都在本地，不存在谁是中心</p><p><img src="/images/images/git.gif" alt></p><p>图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。</p><p><strong>直接记录快照，而非差异</strong></p><p>Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉：</p><p>SVN：</p><p><img src="/images/images/svn.png" alt></p><p>Git:</p><p><img src="/images/images/gitgit.png" alt></p><p>Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。</p><p><strong>不一样的分支概念</strong></p><p>Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。</p><p><strong>三个文件状态</strong></p><p>在Git中文件有三种状态：</p><ul><li>已提交（committed）：该文件被安全地保存在了本地数据库</li><li>已修改（modified）：修改了某个文件，但还没有保存</li><li>已暂存（staged）：把已修改的文件放下下次保存的清单中</li></ul><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>复制一个已创建的仓库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span></span><br></pre></td></tr></table></figure><p>创建一个新的本地仓库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><h3 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h3><p>显示工作路径下已修改的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p>显示与上次提交版本文件的不同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><p>把当前所有修改添加到下次提交中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add</span></span><br></pre></td></tr></table></figure><p>把对某个文件的修改添加到下次提交中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>提交本地的所有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br></pre></td></tr></table></figure><p>提交之前已标记的变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit</span></span><br></pre></td></tr></table></figure><p>附加消息提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'message here'</span></span></span><br></pre></td></tr></table></figure><p>提交，并将提交时间设置为之前的某个日期:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --date=<span class="string">"`date --date='n day ago'`"</span> -am <span class="string">"Commit Message"</span></span></span><br></pre></td></tr></table></figure><h3 id="修改上次提交"><a href="#修改上次提交" class="headerlink" title="修改上次提交"></a>修改上次提交</h3><p>请勿修改已发布的提交记录!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><p>把当前分支中未提交的修改移动到其他分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout branch2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>从当前目录的所有文件中查找文本内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git grep <span class="string">"Hello"</span></span></span><br></pre></td></tr></table></figure><p>在某一版本中搜索文本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git grep <span class="string">"Hello"</span> v2.5</span></span><br></pre></td></tr></table></figure><h3 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h3><p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>显示所有提交（仅显示提交的hash和message）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --oneline</span></span><br></pre></td></tr></table></figure><p>显示某个用户的所有提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --author=<span class="string">"username"</span></span></span><br></pre></td></tr></table></figure><p>显示某个文件的所有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>谁，在什么时间，修改了文件的什么内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><p>列出所有的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure><p>切换分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>创建并切换到新分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>基于当前分支创建新分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;new-branch&gt;</span></span><br></pre></td></tr></table></figure><p>基于远程分支创建新的可追溯的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</span></span><br></pre></td></tr></table></figure><p>删除本地分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>给当前版本打标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h3><p>列出当前配置的远程端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><p>显示远程端的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><p>添加新的远程端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;remote&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><p>下载远程端版本，但不合并到HEAD中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><p>下载远程端版本，并自动与HEAD版本合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote pull &lt;remote&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><p>将远程端版本合并到本地版本中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master</span></span><br></pre></td></tr></table></figure><p>将本地版本发布到远程端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push remote &lt;remote&gt; &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>删除远程端分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</span></span><br><span class="line">或</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</span></span><br></pre></td></tr></table></figure><p>发布标签:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><h3 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h3><p>将分支合并到当前HEAD中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>将当前HEAD版本重置到分支中:<br>请勿重置已发布的提交!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>退出重置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --abort</span></span><br></pre></td></tr></table></figure><p>解决冲突后继续重置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure><p>使用配置好的merge tool 解决冲突：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mergetool</span></span><br></pre></td></tr></table></figure><p>在编辑器中手动解决冲突后，标记文件为已解决冲突</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;resolved-file&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;resolved-file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>放弃工作目录下的所有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD</span></span><br></pre></td></tr></table></figure><p>移除缓存区的所有文件（i.e. 撤销上次git add）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD</span></span><br></pre></td></tr></table></figure><p>放弃某个文件的所有本地修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>重置一个提交（通过创建一个截然不同的新提交）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><p>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Git进阶指南"><a href="#Git进阶指南" class="headerlink" title="Git进阶指南"></a>Git进阶指南</h2><h3 id="问：如何修改-origin-仓库信息？"><a href="#问：如何修改-origin-仓库信息？" class="headerlink" title="问：如何修改 origin 仓库信息？"></a>问：如何修改 origin 仓库信息？</h3><h4 id="1、添加-origin-仓库信息"><a href="#1、添加-origin-仓库信息" class="headerlink" title="1、添加 origin 仓库信息"></a>1、添加 origin 仓库信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin &lt;git仓库地址&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、查看-origin-仓库信息"><a href="#2、查看-origin-仓库信息" class="headerlink" title="2、查看 origin 仓库信息"></a>2、查看 origin 仓库信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下三种方式均可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config get --remote.origin.url</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br></pre></td></tr></table></figure><h4 id="3、删除-origin-仓库信息"><a href="#3、删除-origin-仓库信息" class="headerlink" title="3、删除 origin 仓库信息"></a>3、删除 origin 仓库信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm origin</span></span><br></pre></td></tr></table></figure><h3 id="问：如何配置-git-ssh-keys-？"><a href="#问：如何配置-git-ssh-keys-？" class="headerlink" title="问：如何配置 git ssh keys ？"></a>问：如何配置 git ssh keys ？</h3><p>在本地生成 ssh 私钥 / 公钥 文件</p><p>将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台</p><p>测试 git ssh 连接是否成功</p><p>接下来以添加 github ssh keys 为例，请注意替换 github 文件名。</p><p>注：如果对密钥机制不熟悉，建议不要指定 <code>-f</code> 参数，直接使用默认的 id_rsa 文件名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行以下命令，一直回车，文件名可随意指定</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -b 4096 -C <span class="string">"kaiye@macbook"</span> -f ~/.ssh/github</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychain</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add -K ~/.ssh/github</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 pub 公钥的内容粘贴到线上网站的后台</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/github.pub</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试 git ssh 是否连接成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br></pre></td></tr></table></figure><h3 id="问：如何撤销修改？"><a href="#问：如何撤销修改？" class="headerlink" title="问：如何撤销修改？"></a>问：如何撤销修改？</h3><p>修改包含四种情况，需单独区分。</p><h4 id="1、新建的文件和目录，且从未提交至版本库"><a href="#1、新建的文件和目录，且从未提交至版本库" class="headerlink" title="1、新建的文件和目录，且从未提交至版本库"></a>1、新建的文件和目录，且从未提交至版本库</h4><p>此类文件的状态为 Untracked files ，撤销方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git clean -fd .</span></span><br></pre></td></tr></table></figure><p>其中，. 表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。</p><h4 id="2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）"><a href="#2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）" class="headerlink" title="2、提交过版本库，但未提交至暂存区的文件（未执行 git add）"></a>2、提交过版本库，但未提交至暂存区的文件（未执行 git add）</h4><p>此类文件的状态为<code>Changes not staged for commit</code>，撤销方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br></pre></td></tr></table></figure><h4 id="3、已提交至暂存区的文件"><a href="#3、已提交至暂存区的文件" class="headerlink" title="3、已提交至暂存区的文件"></a>3、已提交至暂存区的文件</h4><p>此类文件的状态为 Changes to be committed，撤销方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset .</span></span><br></pre></td></tr></table></figure><p>执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。</p><h4 id="4、已提交至版本库（执行了-git-commit）"><a href="#4、已提交至版本库（执行了-git-commit）" class="headerlink" title="4、已提交至版本库（执行了 git commit）"></a>4、已提交至版本库（执行了 git commit）</h4><p>每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;版本号&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要「回滚至上一次提交」，可直接使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset head~1</span></span><br></pre></td></tr></table></figure><p>执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。</p><h4 id="5、如果回滚了之后又不想回滚了怎么办？"><a href="#5、如果回滚了之后又不想回滚了怎么办？" class="headerlink" title="5、如果回滚了之后又不想回滚了怎么办？"></a>5、如果回滚了之后又不想回滚了怎么办？</h4><p>如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。</p><p>如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &lt;版本号&gt; 。</p><h3 id="问：遇到冲突了怎么解决？"><a href="#问：遇到冲突了怎么解决？" class="headerlink" title="问：遇到冲突了怎么解决？"></a>问：遇到冲突了怎么解决？</h3><p>两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。</p><h4 id="1、最快的办法"><a href="#1、最快的办法" class="headerlink" title="1、最快的办法"></a>1、最快的办法</h4><p>大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用当前分支 HEAD 版本，通常是冲突源文件的 &lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记部分，======= 的上方</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout --ours &lt;文件名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用合并分支版本，通常是源冲突文件的 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记部分</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout --theirs &lt;文件名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 标记为解决状态加入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;文件名&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、最通用的办法"><a href="#2、最通用的办法" class="headerlink" title="2、最通用的办法"></a>2、最通用的办法</h4><p>用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。</p><p>在 Mac 系统下，运行 git mergetool &lt;文件名&gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。</p><h4 id="3、最好的习惯"><a href="#3、最好的习惯" class="headerlink" title="3、最好的习惯"></a>3、最好的习惯</h4><p>有三个好的习惯，可以减少代码的冲突：</p><p>在开始修改代码前先 git pull 一下；</p><p>将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件；</p><p>通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性。</p><h4 id="4、最复杂的情况"><a href="#4、最复杂的情况" class="headerlink" title="4、最复杂的情况"></a>4、最复杂的情况</h4><p>如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。</p><p>它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。</p><p>rebase 大概的操作步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将当前分支的版本追加到从远程 pull 回来的节点之后</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull --rebase</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若发生冲突，则按以上其他方法进行解决，解决后继续</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase --<span class="built_in">continue</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直到所有冲突得以解决，待项目最后上线前再执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase --skip</span></span><br></pre></td></tr></table></figure><h3 id="问：如何在不提交修改的前提下，执行-pull-merge-等操作？"><a href="#问：如何在不提交修改的前提下，执行-pull-merge-等操作？" class="headerlink" title="问：如何在不提交修改的前提下，执行 pull / merge 等操作？"></a>问：如何在不提交修改的前提下，执行 pull / merge 等操作？</h3><p>有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。</p><p>这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。</p><p>以下是 git stash 常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 stash 队列中已暂存了多少 WIP</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复上一次的 WIP 状态，并从队列中移除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复指定编号的 WIP，同时从队列中移除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop stash@&#123;num&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复指定编号的 WIP，但不从队列中移除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash apply stash@&#123;num&#125;</span></span><br></pre></td></tr></table></figure><h3 id="问：如何在-git-log-中查看修改的文件列表？"><a href="#问：如何在-git-log-中查看修改的文件列表？" class="headerlink" title="问：如何在 git log 中查看修改的文件列表？"></a>问：如何在 git log 中查看修改的文件列表？</h3><p>默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --name-status --oneline</span></span><br></pre></td></tr></table></figure><p>每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.ls <span class="string">'log --name-status --oneline --graph'</span></span></span><br></pre></td></tr></table></figure><p>运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.st <span class="string">'status --porcelain'</span></span></span><br></pre></td></tr></table></figure><p>更多 git log 参数，可通过 git help log 查看手册。</p><p>如果是看上一次提交的版本日志，直接运行 git show 即可。</p><p>此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。</p><h3 id="问：git-submodule-update-时出错怎么解决？"><a href="#问：git-submodule-update-时出错怎么解决？" class="headerlink" title="问：git submodule update 时出错怎么解决？"></a>问：git submodule update 时出错怎么解决？</h3><p>例如，在执行 git submodule update 时有以下错误信息：</p><blockquote><p>fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5<br>Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’</p></blockquote><p>在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit 了新的版本 「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。</p><p>解决方法，在电脑 A 上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 <code>-u</code> 参数即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master -u</span></span><br></pre></td></tr></table></figure><p>支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config core.quotepath off</span></span><br></pre></td></tr></table></figure><p>常用的打 tag 操作，更多请查看《Git 基础 - 打标签》</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地 tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地新增一个 tag，推送至 origin 服务器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.0.0 -m <span class="string">'tag description'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地与 origin tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.0.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete v1.0.0</span></span><br></pre></td></tr></table></figure><p>使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &lt;分支名&gt;，以下是常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建分支 branch1，并切换过去</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b branch1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有本地与远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改完成后，切换回 master 分支，将 branch1 分支合并进来</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge branch1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已完成合并的分支 branch1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d branch1</span></span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>Pro Git 简体中文版</li><li>Git权威指南</li><li>命令行man手册</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。&lt;br&gt;本文分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Git与SVN差异&lt;/li&gt;
&lt;li&gt;Git常用命令&lt;/li&gt;
&lt;li&gt;Git进阶指南&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Dogs vs Cats (猫狗大战)</title>
    <link href="http://miaopei.github.io/2018/01/03/DeepLearning/DogsVsCats/"/>
    <id>http://miaopei.github.io/2018/01/03/DeepLearning/DogsVsCats/</id>
    <published>2018-01-03T02:14:50.000Z</published>
    <updated>2019-06-13T07:58:02.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>GitHub 项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pYW9wZWkvY2F0X3ZzX2RvZw==" title="https://github.com/miaopei/cat_vs_dog">Dogs vs Cats (猫狗大战)<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><p>本项目是优达学城的一个毕业项目。项目要求使用深度学习方法识别一张图片是猫还是狗</p><ul><li>输入：一张彩色图片</li><li>输出：是猫还是狗</li></ul><a id="more"></a><h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><p>项目使用Anaconda搭建环境。可是使用environment目录下的yml进行环境安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda env create -f environment.yml</span></span><br></pre></td></tr></table></figure><h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>数据集来自 kaggle 上的一个竞赛：<span class="exturl" data-url="aHR0cHM6Ly93d3cua2FnZ2xlLmNvbS9jL2RvZ3MtdnMtY2F0cy1yZWR1eC1rZXJuZWxzLWVkaXRpb24vZGF0YQ==" title="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition/data">Dogs vs. Cats Redux: Kernels Edition<i class="fa fa-external-link"></i></span>。</p><p>下载kaggle猫狗数据集解压后分为 3 个文件 train.zip、 test.zip 和 sample_submission.csv。</p><p>train 训练集包含了 25000 张猫狗的图片， 每张图片包含图片本身和图片名。命名规则根据“type.num.jpg”方式命名。</p><p>test 测试集包含了 12500 张猫狗的图片， 每张图片命名规则根据“num.jpg”，需要注意的是测试集编号从 1 开始， 而训练集的编号从 0 开始。</p><p>sample_submission.csv 需要将最终测试集的测试结果写入.csv 文件中，上传至 kaggle 进行打分。</p><h2 id="基准模型"><a href="#基准模型" class="headerlink" title="基准模型"></a>基准模型</h2><p>项目使用ResNet50, Xception, Inception V3 这三个模型完成。本项目的最低要求是 kaggle Public Leaderboard 前10%。在kaggle上，总共有1314只队伍参加了比赛，所以需要最终的结果排在131位之前，131位的得分是0.06127，所以目标是模型预测结果要小于0.06127。</p><h2 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h2><p>kaggle 官方的评估标准是 LogLoss，下面的表达式就是二分类问题的 LogLoss 定义。</p><div align="center"><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PUxvZ0xvc3Mmc3BhY2U7PSZzcGFjZTstXGZyYWN7MX17bn1cc3VtX3tpPTF9Xm4mc3BhY2U7W3lfaWxvZyhcaGF0e3l9X2kpJnBsdXM7KDEteV9pKWxvZygxLSZzcGFjZTtcaGF0e3l9X2kpXQ==" title="https://www.codecogs.com/eqnedit.php?latex=LogLoss&space;=&space;-\frac{1}{n}\sum_{i=1}^n&space;[y_ilog(\hat{y}_i)&plus;(1-y_i)log(1-&space;\hat{y}_i)]"><img src="https://latex.codecogs.com/gif.latex?LogLoss&space;=&space;-\frac{1}{n}\sum_{i=1}^n&space;[y_ilog(\hat{y}_i)&plus;(1-y_i)log(1-&space;\hat{y}_i)]" title="LogLoss = -\frac{1}{n}\sum_{i=1}^n [y_ilog(\hat{y}_i)+(1-y_i)log(1- \hat{y}_i)]"><i class="fa fa-external-link"></i></span></div><p>其中：</p><ul><li><p>n 是测试集中图片数量</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PVxoYXR7eX1faQ==" title="https://www.codecogs.com/eqnedit.php?latex=\hat{y}_i"><img src="https://latex.codecogs.com/gif.latex?\hat{y}_i" title="\hat{y}_i"><i class="fa fa-external-link"></i></span> 是图片预测为狗的概率</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PXlfaQ==" title="https://www.codecogs.com/eqnedit.php?latex=y_i"><img src="https://latex.codecogs.com/gif.latex?y_i" title="y_i"><i class="fa fa-external-link"></i></span> 如果图像是狗，则为1，如果是猫，则为0</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PWxvZygp" title="https://www.codecogs.com/eqnedit.php?latex=log()"><img src="https://latex.codecogs.com/gif.latex?log()" title="log()"><i class="fa fa-external-link"></i></span> 是自然（基数 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PWU=" title="https://www.codecogs.com/eqnedit.php?latex=e"><img src="https://latex.codecogs.com/gif.latex?e" title="e"><i class="fa fa-external-link"></i></span>）对数</p></li></ul><p>对数损失越小，代表模型的性能越好。上述评估指标可用于评估该项目的解决方案以及基准模型。</p><h2 id="设计大纲"><a href="#设计大纲" class="headerlink" title="设计大纲"></a>设计大纲</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> model_graphviz/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><img src="/images/imageDeepLearning/model.png"><p>整个模型是在本地训练的，训练了三天才完成。建议使用云端 GPU 训练复现实验过程。</p><p><strong>1. 数据预处理</strong></p><ul><li>从kaggle下载好图片</li><li>将猫和狗的图片放在不同的文件夹以示分类，使用创建符号链接的方法</li><li>对图片进行resize，保持输入图片信息大小一致</li></ul><p><strong>2. 模型搭建</strong></p><p>Kera的应用模块Application提供了带有预训练权重的Keras模型，这些模型可以用来进行预测、特征提取和微调整和。</p><ul><li>Xception 默认输入图片大小是 <code>299*299*3</code></li><li>InceptionV3 默认输入图片大小是 <code>299*299*3</code></li><li>ResNet50 默认输入图片大小是 <code>224*224*3</code></li></ul><p>在Keras中载入模型并进行全局平均池化，只需要在载入模型的时候，设置<code>include_top=False</code>, <code>pooling=&#39;avg&#39;</code>. 每个模型都将图片处理成一个<code>1*2048</code>的行向量，将这三个行向量进行拼接，得到一个<code>1*6144</code>的行向量， 作为数据预处理的结果。</p><p><strong>3. 模型训练&amp;模型调参</strong></p><p>载入预处理的数据之后，先进行一次概率为0.5的dropout，然后直接连接输出层，激活函数为Sigmoid，优化器为Adam，输出一个零维张量，表示某张图片中有狗的概率。</p><p><strong>4. 模型评估</strong></p><ul><li>使用$Logloss$进行模型评估,上传Kaggle判断是否符合标准</li></ul><p><strong>5. 可视化</strong></p><ul><li>进行数据探索并且可视化原始数据</li><li>可视化模型训练过程的准确率曲线，损失函数曲线等</li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>项目使用 Keras 和 Flask 搭建部署一个简单易用的深度学习图像网页应用，可以通过网页导入一张彩色猫或者狗的图片预测是猫或者狗的概率。</p><p>项目目录结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── ResNet50_image_predict.ipynb</span><br><span class="line">├── app.py</span><br><span class="line">├── environmert.yml</span><br><span class="line">├── static</span><br><span class="line">│   ├── css</span><br><span class="line">│   │   └── main.css</span><br><span class="line">│   └── js</span><br><span class="line">│       └── main.js</span><br><span class="line">├── templates</span><br><span class="line">│   ├── base.html</span><br><span class="line">│   └── index.html</span><br><span class="line">├── models</span><br><span class="line">│   └── ResNet50_catdog_model.h5</span><br><span class="line">├── uploads</span><br><span class="line">│   ├── test01.jpg</span><br><span class="line">│   └── test02.jpg</span><br><span class="line">└── webapp_image_predict.ipynb</span><br></pre></td></tr></table></figure><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda env create -f environmert.yml</span></span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python app.py</span></span><br></pre></td></tr></table></figure><p>这时候用浏览器打开 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAwLw==" title="http://localhost:5000/">http://localhost:5000/<i class="fa fa-external-link"></i></span> 就可以进行网页导入图片预测图片是狗的概率了。</p><h3 id="快速复现webapp预测结果"><a href="#快速复现webapp预测结果" class="headerlink" title="快速复现webapp预测结果"></a>快速复现webapp预测结果</h3><p>如果不想搭建环境复现实验结果，可以按照以下操作分分钟复现实验结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull miaowmiaow/webapp:1.1.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 5000:5000 miaowmiaow/webapp:1.1.0</span></span><br></pre></td></tr></table></figure><p>到此就可以在浏览器中输入 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAw" title="http://localhost:5000">http://localhost:5000<i class="fa fa-external-link"></i></span> 就可以使用网页对导入的猫狗图片做预测了。</p><p>下图为预测的效果图：</p><img src="/images/imageDeepLearning/webapp.gif">]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;GitHub 项目地址：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL21pYW9wZWkvY2F0X3ZzX2RvZw==&quot; title=&quot;https://github.com/miaopei/cat_vs_dog&quot;&gt;Dogs vs Cats (猫狗大战)&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;项目说明&quot;&gt;&lt;a href=&quot;#项目说明&quot; class=&quot;headerlink&quot; title=&quot;项目说明&quot;&gt;&lt;/a&gt;项目说明&lt;/h2&gt;&lt;p&gt;本项目是优达学城的一个毕业项目。项目要求使用深度学习方法识别一张图片是猫还是狗&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：一张彩色图片&lt;/li&gt;
&lt;li&gt;输出：是猫还是狗&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="http://miaopei.github.io/categories/DeepLearning/"/>
    
    
      <category term="DeepLearning" scheme="http://miaopei.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket教程</title>
    <link href="http://miaopei.github.io/2017/05/16/WebSocket%E6%95%99%E7%A8%8B/"/>
    <id>http://miaopei.github.io/2017/05/16/WebSocket教程/</id>
    <published>2017-05-16T06:15:08.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<p>转自<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDUvd2Vic29ja2V0Lmh0bWw=" title="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰网络编程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3dlYnNvY2tldC5vcmcv" title="http://websocket.org/">WebSocket<i class="fa fa-external-link"></i></span> 是一种网络通信协议，很多高级功能都需要它。</p><h2 id="为什么需要-WebSocker"><a href="#为什么需要-WebSocker" class="headerlink" title="为什么需要 WebSocker"></a>为什么需要 WebSocker</h2><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><a id="more"></a><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p><img src="http://i.imgur.com/5mUfWtm.jpg" alt></p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<span class="exturl" data-url="aHR0cHM6Ly93d3cucHVibnViLmNvbS9ibG9nLzIwMTQtMTItMDEtaHR0cC1sb25nLXBvbGxpbmcv" title="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”<i class="fa fa-external-link"></i></span>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVzaF90ZWNobm9sb2d5" title="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术<i class="fa fa-external-link"></i></span>的一种。</p><p><img src="http://i.imgur.com/Qutxs2j.png" alt></p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是 <code>ws</code>（如果加密，则为 <code>wss</code> ），服务器网址就是 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/UWC2xr3.jpg" alt></p><h2 id="客户端的简单示例"><a href="#客户端的简单示例" class="headerlink" title="客户端的简单示例"></a>客户端的简单示例</h2><p>WebSocket 的用法相当简单。</p><p>下面是一个网页脚本的例子（点击<span class="exturl" data-url="aHR0cDovL2pzYmluLmNvbS9tdXFhbWlxaW11L2VkaXQ/anMsY29uc29sZQ==" title="http://jsbin.com/muqamiqimu/edit?js,console">这里<i class="fa fa-external-link"></i></span>看运行结果），基本上一眼就能明白。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>); </span><br><span class="line">  ws.send(<span class="string">"Hello WebSockets!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"Received Message: "</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="客户端的-API"><a href="#客户端的-API" class="headerlink" title="客户端的 API"></a>客户端的 API</h2><p>WebSocket 客户端的 API 如下。</p><h3 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。</p><p>实例对象的所有属性和方法清单，参见<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldA==" title="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">这里<i class="fa fa-external-link"></i></span>。</p><h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p><code>readyState</code> 属性返回实例对象的当前状态，共有四种。</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><p>下面是一个示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的 <code>onopen</code> 属性，用于指定连接成功后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要指定多个回调函数，可以使用addEventListener`方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h3><p>实例对象的 <code>onmessage</code> 属性，用于指定收到服务器数据后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，服务器数据可能是文本，也可能是二进制数据（ <code>blob</code> 对象或 <code>Arraybuffer</code> 对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received data string"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received arraybuffer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"blob"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send( )"></a>webSocket.send( )</h3><p>实例对象的 <code>send( )</code> 方法用于向服务器发送数据。</p><p>发送文本的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">'your message'</span>);</span><br></pre></td></tr></table></figure><p>发送 Blob 对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">'input[type="file"]'</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure><p>发送 ArrayBuffer 对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure><h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的 <code>bufferedAmount</code> 属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>WebSocket 服务器的实现，可以查看维基百科的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcGFyaXNvbl9vZl9XZWJTb2NrZXRfaW1wbGVtZW50YXRpb25z" title="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">列表<i class="fa fa-external-link"></i></span>。</p><p>常用的 Node 实现有以下三种。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VXZWJTb2NrZXRzL3VXZWJTb2NrZXRz" title="https://github.com/uWebSockets/uWebSockets">µWebSockets<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvY2tldC5pby8=" title="http://socket.io/">Socket.IO<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2Rl" title="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node<i class="fa fa-external-link"></i></span></li></ul><p>具体的用法请查看它们的文档，这里不详细介绍了。</p><h2 id="WebSocketd"><a href="#WebSocketd" class="headerlink" title="WebSocketd"></a>WebSocketd</h2><p>下面，我要推荐一款非常特别的 WebSocket 服务器：<span class="exturl" data-url="aHR0cDovL3dlYnNvY2tldGQuY29tLw==" title="http://websocketd.com/">Websocketd<i class="fa fa-external-link"></i></span>。</p><p>它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。</p><p><img src="http://i.imgur.com/a51CR69.png" alt></p><p>举例来说，下面是一个 Bash 脚本 <code>counter.sh</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 2</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 3</span><br></pre></td></tr></table></figure><p>命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bash ./counter.sh</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>现在，启动<code>websocketd</code>，指定这个脚本作为服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 bash ./counter.sh</span><br></pre></td></tr></table></figure><p>上面的命令会启动一个 WebSocket 服务器，端口是 <code>8080</code> 。每当客户端连接这个服务器，就会执行 <code>counter.sh</code> 脚本，并将它的输出推送给客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/'</span>);</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。</p><p>有了它，就可以很方便地将命令行的输出，发给浏览器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 ls</span><br></pre></td></tr></table></figure><p>上面的命令会执行<code>ls</code>命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWItdm1zdGF0cw==" title="https://github.com/joewalnes/web-vmstats">代码<i class="fa fa-external-link"></i></span>）。</p><p><img src="http://i.imgur.com/WMUStsh.jpg" alt></p><p>更多的用法可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL3RyZWUvbWFzdGVyL2V4YW1wbGVzL2Jhc2g=" title="https://github.com/joewalnes/websocketd/tree/master/examples/bash">官方示例<i class="fa fa-external-link"></i></span>。</p><ul><li>Bash 脚本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2Jhc2gvZ3JlZXRlci5zaA==" title="https://github.com/joewalnes/websocketd/blob/master/examples/bash/greeter.sh">读取客户端输入<i class="fa fa-external-link"></i></span>的例子</li><li>五行代码实现一个最简单的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2Jhc2gvY2hhdC5zaA==" title="https://github.com/joewalnes/websocketd/blob/master/examples/bash/chat.sh">聊天服务器<i class="fa fa-external-link"></i></span></li></ul><p><img src="http://i.imgur.com/KfZKSmD.png" alt></p><p>websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL25vZGVqcy9ncmVldGVyLmpz" title="https://github.com/joewalnes/websocketd/blob/master/examples/nodejs/greeter.js"><code>greeter.js</code><i class="fa fa-external-link"></i></span>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">'data: '</span> + chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动这个脚本的命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 node ./greeter.js</span><br></pre></td></tr></table></figure><p>官方仓库还有其他<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL3RyZWUvbWFzdGVyL2V4YW1wbGVz" title="https://github.com/joewalnes/websocketd/tree/master/examples">各种语言<i class="fa fa-external-link"></i></span>的例子。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><span class="exturl" data-url="aHR0cDovL2NqaWhyaWcuY29tL2Jsb2cvaG93LXRvLXVzZS13ZWJzb2NrZXRzLw==" title="http://cjihrig.com/blog/how-to-use-websockets/">How to Use WebSockets<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL3dlYnNvY2tldHMvd2Vic29ja2V0c19zZW5kX3JlY2VpdmVfbWVzc2FnZXMuaHRt" title="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">WebSockets - Send &amp; Receive Messages<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL3dlYnNvY2tldHMvYmFzaWNzLw==" title="https://www.html5rocks.com/en/tutorials/websockets/basics/">Introducing WebSockets: Bringing Sockets to the Web<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDUvd2Vic29ja2V0Lmh0bWw=&quot; title=&quot;http://www.ruanyifeng.com/blog/2017/05/websocket.html&quot;&gt;阮一峰网络编程&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3dlYnNvY2tldC5vcmcv&quot; title=&quot;http://websocket.org/&quot;&gt;WebSocket&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt; 是一种网络通信协议，很多高级功能都需要它。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要-WebSocker&quot;&gt;&lt;a href=&quot;#为什么需要-WebSocker&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 WebSocker&quot;&gt;&lt;/a&gt;为什么需要 WebSocker&lt;/h2&gt;&lt;p&gt;初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://miaopei.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="WebSocket" scheme="http://miaopei.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>定制支持串口安装的ubuntu系统镜像</title>
    <link href="http://miaopei.github.io/2017/05/15/%E5%AE%9A%E5%88%B6%E6%94%AF%E6%8C%81%E4%B8%B2%E5%8F%A3%E5%AE%89%E8%A3%85%E7%9A%84ubuntu%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/"/>
    <id>http://miaopei.github.io/2017/05/15/定制支持串口安装的ubuntu系统镜像/</id>
    <published>2017-05-15T07:48:06.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、所需环境："><a href="#1、所需环境：" class="headerlink" title="1、所需环境："></a>1、所需环境：</h2><p><strong>硬件环境：</strong></p><ul><li>笔记本</li><li>串口调试线缆</li><li>光盘</li><li>显示器</li><li>FWA产品的任一机型（此次使用的是FWA-4210）</li><li>SATA或者USB光驱×1</li></ul><a id="more"></a><p><strong>软件环境：</strong></p><ul><li>带有genisoimage(旧版是mkisofs)的linux发行版（此次使用的是Ubuntu 16.04 server版）</li><li>Ubuntu官网通用镜像ISO文件</li></ul><h2 id="2、操作过程："><a href="#2、操作过程：" class="headerlink" title="2、操作过程："></a>2、操作过程：</h2><h3 id="2-1-开机进入系统，将光盘挂载到Ubuntu系统"><a href="#2-1-开机进入系统，将光盘挂载到Ubuntu系统" class="headerlink" title="2.1 开机进入系统，将光盘挂载到Ubuntu系统"></a>2.1 开机进入系统，将光盘挂载到Ubuntu系统</h3><p>CLI命令如下；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -o loop ubuntu-16.04.2-server-amd64.iso /mnt/temp</span><br></pre></td></tr></table></figure><h3 id="2-2-更改配置"><a href="#2-2-更改配置" class="headerlink" title="2.2 更改配置"></a>2.2 更改配置</h3><p>相关配置文件（menu.cfg、txt.cfg、isolinux.cfg此文件不是必须要修改，具体见下边解释）。将光盘文件，拷贝到临时目录（家目录或者自己新建目录均可，但建议拷贝到/var或/temp目录下），具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -rf /mnt/temp/ /var/mycdrom</span><br></pre></td></tr></table></figure><p>因为 <code>/mnt</code> 目录的默认权限是 <code>333</code> ，所以在此使用 <code>-r</code> 和 <code>-f</code> 参数，<code>-r</code> 代表递归，即文件夹下所有文件都拷贝，<code>-f</code> 代表强制执行；</p><p>更改 <code>menu.cfg</code> 文件，如下图，主要是注释掉标准安装的配置文件，以便可以定制安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/mycdrom/temp/isolinux</span><br><span class="line"></span><br><span class="line">$ vi menu.cfg</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><blockquote><p>vi有三种模式，普通模式、编辑模式、命令行模式；</p><p>I o a进入编辑模式，</p><p>普通模式下数字+yy复制</p><p>P黏贴</p><p>命令行模式：w写入，q离开，！强制执行</p></blockquote><p>注释 <code>menu.cfg</code> 内容如下红框所示：</p><p><img src="http://i.imgur.com/JM99sFZ.png" alt></p><p>更改 <code>txt.cfg</code> 文件，主要用于定制串口安装（如下图）：</p><p><img src="http://i.imgur.com/pA7ruhP.png" alt></p><p>更改 <code>isolinux.cfg</code> 文件，主要修改grub菜单等待时间（如下图），也可不修改；</p><p><img src="http://i.imgur.com/jE4zoMG.png" alt></p><h3 id="2-3-重新打包ISO文件"><a href="#2-3-重新打包ISO文件" class="headerlink" title="2.3 重新打包ISO文件"></a>2.3 重新打包ISO文件</h3><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ genisoimage -o ubuntu-16.04.2-server-adm64-console_115200.iso -r -J -no-emul-boot -boot-load-size 4 -boot-info-table -b isolinux/isolinux.bin -c isolinux/boot.cat /var/mycdrom/temp</span><br></pre></td></tr></table></figure><p><code>genisoimage</code> 是linux各大发行版制作ISO镜像比较流行的工具，若要定制系统，最好在linux下更改相关配置，并使用此工具重新打包；若在Windows平台使用UltraISO等工具解压更改重新打包会出现不稳定的情况（无法找到镜像，无法找到安装源等）。</p><ul><li><code>-o</code> ：是output缩写，用来指定输出镜像名称</li><li><code>-r</code> ： 即rational-rock，用来开放ISO文件所有权限（r、w、x） </li><li><code>-J</code> ： 即Joliet，一种ISO9600扩展格式，用来增加兼容性，最好加上</li><li><code>-no-emul-boot</code>  <code>-boot-load-size 4</code>  <code>-boot-info-table</code> ：指定兼容模式下虚拟扇区的数量，若不指定，有些BISO会出现一些问题</li><li><code>-b</code> ：指定开机映像文件</li><li><code>-c</code> ：具体开机配置文件</li><li>最后加上输出目录</li></ul><p>Reboot系统U盘启动，即可安装系统。</p><h2 id="3、文本安装系统注意事项"><a href="#3、文本安装系统注意事项" class="headerlink" title="3、文本安装系统注意事项"></a>3、文本安装系统注意事项</h2><h3 id="3-1-进入安装模式"><a href="#3-1-进入安装模式" class="headerlink" title="3.1 进入安装模式"></a>3.1 进入安装模式</h3><p>关闭系统插入U盘，启动系统，看到如下提示按F12进入安装系统模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Press  F12  for  boot  menu..</span><br></pre></td></tr></table></figure><p>选择U盘所在的选项。</p><h3 id="3-2-分区"><a href="#3-2-分区" class="headerlink" title="3.2 分区"></a>3.2 分区</h3><p>若是硬盘已有linux发行版系统，那在如下界面，必须umount分区，才能将更改写入分区表</p><h3 id="3-3-自动更新"><a href="#3-3-自动更新" class="headerlink" title="3.3 自动更新"></a>3.3 自动更新</h3><p>如下界面，若有特许需求（需要安装一些特许软件apache、weblogic等）可以选择自动更新（需要联网），一般情况不选则自动更新</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、所需环境：&quot;&gt;&lt;a href=&quot;#1、所需环境：&quot; class=&quot;headerlink&quot; title=&quot;1、所需环境：&quot;&gt;&lt;/a&gt;1、所需环境：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;硬件环境：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;笔记本&lt;/li&gt;
&lt;li&gt;串口调试线缆&lt;/li&gt;
&lt;li&gt;光盘&lt;/li&gt;
&lt;li&gt;显示器&lt;/li&gt;
&lt;li&gt;FWA产品的任一机型（此次使用的是FWA-4210）&lt;/li&gt;
&lt;li&gt;SATA或者USB光驱×1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="http://miaopei.github.io/categories/Ubuntu/"/>
    
    
      <category term="ubuntu" scheme="http://miaopei.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本攻略笔记</title>
    <link href="http://miaopei.github.io/2017/05/15/Shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://miaopei.github.io/2017/05/15/Shell脚本攻略笔记/</id>
    <published>2017-05-15T07:40:41.000Z</published>
    <updated>2019-06-03T08:50:47.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><h3 id="1-1-shell-格式输出"><a href="#1-1-shell-格式输出" class="headerlink" title="1.1 shell 格式输出"></a>1.1 shell 格式输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'Hello world !'</span></span><br><span class="line">-n<span class="comment"># 忽略结尾的换行符</span></span><br><span class="line">-e<span class="comment"># 激活转义字符</span></span><br><span class="line">-E<span class="comment"># disable转义字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>打印彩色输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 彩色文本</span></span><br><span class="line"><span class="comment"># 重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;31m This is red text \e[0m"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 彩色背景</span></span><br><span class="line"><span class="comment"># 重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;42m Green Background \e[0m"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4s\n"</span> No Name Mark</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p><code>%-5s</code> 指明了一个格式为左对齐且宽度为5的字符串替换（ <code>-</code>表示左对齐）。如果不用 <code>-</code> 指定对齐方式，字符串就采用右对齐形式。</p><p><code>%s</code> 、 <code>%c</code> 、<code>%d</code> 和 <code>%f</code> 都是格式替换符（format substitution character），其所对应的参数可以置于带引号的格式字符串之后。 </p><h3 id="1-2-替换命令-tr"><a href="#1-2-替换命令-tr" class="headerlink" title="1.2 替换命令 tr"></a>1.2 替换命令 tr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tr 是 translate的简写</span></span><br><span class="line">$ tr <span class="string">'\0'</span> <span class="string">'\n'</span><span class="comment"># 将 \0 替换成 \n</span></span><br><span class="line">$ tr [选项]… 集合1 [集合2]</span><br><span class="line">选项说明：</span><br><span class="line">-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。</span><br><span class="line">-d, –delete 删除集合1中的字符而不是转换</span><br><span class="line">-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。</span><br><span class="line">-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符</span><br><span class="line"></span><br><span class="line">字符集合的范围：</span><br><span class="line">\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)</span><br><span class="line">\\ 反斜杠</span><br><span class="line">\a Ctrl-G 铃声</span><br><span class="line">\b Ctrl-H 退格符</span><br><span class="line">\f Ctrl-L 走行换页</span><br><span class="line">\n Ctrl-J 新行</span><br><span class="line">\r Ctrl-M 回车</span><br><span class="line">\t Ctrl-I tab键</span><br><span class="line">\v Ctrl-X 水平制表符</span><br><span class="line">CHAR1-CHAR2 从CHAR1 到 CHAR2的所有字符按照ASCII字符的顺序</span><br><span class="line">[CHAR*] <span class="keyword">in</span> SET2, copies of CHAR until length of SET1</span><br><span class="line">[CHAR*REPEAT] REPEAT copies of CHAR, REPEAT octal <span class="keyword">if</span> starting with 0</span><br><span class="line">[:alnum:] 所有的字母和数字</span><br><span class="line">[:alpha:] 所有字母</span><br><span class="line">[:blank:] 水平制表符，空白等</span><br><span class="line">[:cntrl:] 所有控制字符</span><br><span class="line">[:digit:] 所有的数字</span><br><span class="line">[:graph:] 所有可打印字符，不包括空格</span><br><span class="line">[:lower:] 所有的小写字符</span><br><span class="line">[:<span class="built_in">print</span>:] 所有可打印字符，包括空格</span><br><span class="line">[:punct:] 所有的标点字符</span><br><span class="line">[:space:] 所有的横向或纵向的空白</span><br><span class="line">[:upper:] 所有大写字母</span><br></pre></td></tr></table></figure><h3 id="1-3-打印变量"><a href="#1-3-打印变量" class="headerlink" title="1.3 打印变量"></a>1.3 打印变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ var=<span class="string">"value"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">或者</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-设置环境变量"><a href="#1-4-设置环境变量" class="headerlink" title="1.4 设置环境变量"></a>1.4 设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在PATH中添加一条新路径</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:/home/user/bin"</span></span><br><span class="line">也可以使用：</span><br><span class="line">$ PATH=<span class="string">"<span class="variable">$PATH</span>:/home/user/bin"</span></span><br><span class="line">$ <span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure><h3 id="1-5-Shell中三种引号的用法"><a href="#1-5-Shell中三种引号的用法" class="headerlink" title="1.5 Shell中三种引号的用法"></a>1.5 Shell中三种引号的用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="comment"># 使用单引号时，变量不会被扩展（expand），将依照原样显示。</span></span><br><span class="line">$ var=<span class="string">"123"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'$var'</span> will <span class="built_in">print</span> <span class="variable">$var</span></span><br><span class="line">结果为：<span class="string">'$var'</span> will <span class="built_in">print</span> 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="comment"># 输出引号中的内容，若存在命令、变量等，会先执行命令解析出结果再输出</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span> will <span class="built_in">print</span> <span class="variable">$var</span></span><br><span class="line">结果为：123 will <span class="built_in">print</span> 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反引号</span></span><br><span class="line"><span class="comment"># 命令替换</span></span><br><span class="line">$ var=`whoami`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">结果为：root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备注：反引号和$()作用相同</span></span><br></pre></td></tr></table></figure><h3 id="1-6-获得字符串的长度"><a href="#1-6-获得字符串的长度" class="headerlink" title="1.6 获得字符串的长度"></a>1.6 获得字符串的长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法</span></span><br><span class="line">$ length=<span class="variable">$&#123;#var&#125;</span></span><br><span class="line"></span><br><span class="line">$ var=12345678901234567890</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="1-7-识别当前shell"><a href="#1-7-识别当前shell" class="headerlink" title="1.7 识别当前shell"></a>1.7 识别当前shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">也可以使用：</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br></pre></td></tr></table></figure><h3 id="1-8-使用shell进行数学运算"><a href="#1-8-使用shell进行数学运算" class="headerlink" title="1.8 使用shell进行数学运算"></a>1.8 使用shell进行数学运算</h3><p>在Bash shell环境中，可以利用 <code>let</code>、<code>(( ))</code> 和<code>[]</code> 执行基本的算术操作。而在进行高级操作时，<code>expr</code> 和 <code>bc</code> 这两个工具也会非常有用。</p><p>使用 <code>let</code> 时，变量名之前不需要再添加 <code>$</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ no1=4</span><br><span class="line">$ <span class="built_in">let</span> no1++</span><br><span class="line">$ <span class="built_in">let</span> no1+=6<span class="comment"># 等同于let no=no+6</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 操作符[]的使用方法和let命令类似</span></span><br><span class="line">$ result=$[ no1 + no2 ]</span><br><span class="line"><span class="comment"># 在[]中也可以使用$前缀</span></span><br><span class="line">$ result=$[ <span class="variable">$no1</span> + 5 ]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用(())时，变量名之前需要加上$</span></span><br><span class="line">$ result=$(( no1 + 50 ))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># expr同样可以用于基本算术操作</span></span><br><span class="line">$ result=`expr 3 + 4`</span><br><span class="line">$ result=$(expr <span class="variable">$no1</span> + 5)</span><br></pre></td></tr></table></figure><p>bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项 。此处不多介绍。</p><h3 id="1-9-shell中各种括号的作用-、-、-、-、"><a href="#1-9-shell中各种括号的作用-、-、-、-、" class="headerlink" title="1.9 shell中各种括号的作用()、(())、[]、[[]]、{}"></a>1.9 shell中各种括号的作用()、(())、[]、[[]]、{}</h3><h4 id="1-9-1-小括号，圆括号（）"><a href="#1-9-1-小括号，圆括号（）" class="headerlink" title="1.9.1 小括号，圆括号（）"></a>1.9.1 小括号，圆括号（）</h4><p>1、单小括号 ( )</p><ul><li><strong>命令组。</strong>括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。</li><li><strong>命令替换。</strong>等同于<code>cmd</code>，shell扫描一遍命令行，发现了<code>$(cmd)结构</code> ，便将 <code>$(cmd)</code> 中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</li><li><strong>用于初始化数组。</strong>如：array=(a b c d)。</li></ul><p>2、双小括号 (( ))</p><ul><li><strong>整数扩展。</strong>这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。</li><li><strong>只要括号中的运算符、表达式符合C语言运算规则，都可用在 <code>$((exp))</code>中，甚至是三目运算符</strong>。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)。</li><li><strong>单纯用 (( )) 也可重定义变量值</strong>，比如 a=5; ((a++)) 可将 $a 重定义为6。</li><li><strong>常用于算术运算比较，双括号中的变量可以不使用<code>$</code> 符号前缀</strong>。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i&lt;5;i++)), 如果不使用双括号, 则为for i in <code>seq 0 4</code>或者for i in {0..4}。再如可以直接使用 <code>if (($i&lt;5))</code> , 如果不使用双括号, 则为 <code>if [ $i -lt 5 ]</code> 。</li></ul><h4 id="1-9-2-中括号，方括号"><a href="#1-9-2-中括号，方括号" class="headerlink" title="1.9.2 中括号，方括号[]"></a>1.9.2 中括号，方括号[]</h4><p>1、单中括号 []</p><ul><li>bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</li><li>Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</li><li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</li><li>在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</li></ul><p>2、双中括号 [[ ]]</p><ul><li>[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</li><li>支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</li><li>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用 <code>if [[ $a != 1 &amp;&amp; $a != 2 ]]</code> , 如果不适用双括号, 则为 <code>if [ $a -ne 1] &amp;&amp; [ $a != 2 ]</code>或者 <code>if [ $a -ne 1 -a $a != 2 ]</code> 。</li><li>bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</li></ul><h4 id="1-9-3-大括号、花括号"><a href="#1-9-3-大括号、花括号" class="headerlink" title="1.9.3 大括号、花括号 {}"></a>1.9.3 大括号、花括号 {}</h4><p>1）常规用法</p><ul><li>大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt</li><li>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</li></ul><p>2）几种特殊的替换结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var:-string&#125;</span>,<span class="variable">$&#123;var:+string&#125;</span>,<span class="variable">$&#123;var:=string&#125;</span>,<span class="variable">$&#123;var:?string&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>${var:-string}</code> 和 <code>${var:=string}:</code> 若变量var为空，则用在命令行中用string来替换 <code>${var:-string}</code>，否则变量var不为空时，则用变量var的值来替换 <code>${var:-string}</code> ；对于 <code>${var:=string}</code> 的替换规则和 <code>${var:-string}</code> 是一样的，所不同之处是 <code>${var:=string}</code> 若var为空时，用string替换 <code>${var:=string}</code> 的同时，把string赋给变量 <code>var： ${var:=string}</code> 很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</li><li><code>${var:+string}</code> 的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 。</li><li><code>${var:?string}</code> 替换规则为：若变量var不为空，则用变量var的值来替换 <code>${var:?string}</code> ；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。</li></ul><p>补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p><p>3）四种模式匹配替换结构</p><p>模式匹配记忆方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 是去掉左边(在键盘上#在$之左边)</span><br><span class="line">% 是去掉右边(在键盘上%在$之右边)</span><br><span class="line">#和%中的单一符号是最小匹配，两个相同符号是最大匹配。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var%pattern&#125;</span>,<span class="variable">$&#123;var%%pattern&#125;</span>,<span class="variable">$&#123;var#pattern&#125;</span>,<span class="variable">$&#123;var##pattern&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第一种模式：<code>${variable%pattern}</code> ，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式</li></ul><ul><li>第二种模式：<code>${variable%%pattern}</code>，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</li><li>第三种模式：<code>${variable#pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式</li><li>第四种模式：<code>${variable##pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</li></ul><p>这四种模式中都不会改变variable的值，其中，只有在pattern中使用了匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。</p><p>4）字符串提取和替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var:num&#125;</span>,<span class="variable">$&#123;var:num1:num2&#125;</span>,<span class="variable">$&#123;var/pattern/pattern&#125;</span>,<span class="variable">$&#123;var//pattern/pattern&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第一种模式：<code>${var:num}</code> ，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如 <code>${var: -2}</code> 、<code>${var:1-3}</code> 或 <code>${var:(-2)}</code>。         </li><li>第二种模式：<code>${var:num1:num2}</code>，num1是位置，num2是长度。表示从 <code>$var字符串的第$num1</code> 个位置开始提取长度为$num2的子串。不能为负数。</li><li>第三种模式：<code>${var/pattern/pattern}</code>表示将var字符串的第一个匹配的pattern替换为另一个pattern。。         </li><li>第四种模式：<code>${var//pattern/pattern}</code> 表示将var字符串中的所有能匹配的pattern替换为另一个pattern。</li></ul><h4 id="1-9-4-符号-后的括号"><a href="#1-9-4-符号-后的括号" class="headerlink" title="1.9.4 符号$后的括号"></a>1.9.4 符号$后的括号</h4><ul><li><code>${a}</code> 变量a的值, 在不引起歧义的情况下可以省略大括号。</li><li><code>$(cmd)</code>  命令替换，和<code>cmd</code>效果相同，结果为shell命令cmd的输，过某些Shell版本不支持 <code>$()</code> 形式的命令替换, 如tcsh。</li><li><code>$((expression))</code> 和<code>exprexpression</code>效果相同, 计算数学表达式exp的数值, 其中exp只要符合<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2M=" title="http://lib.csdn.net/base/c">C语言<i class="fa fa-external-link"></i></span>的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。</li></ul><h4 id="1-9-5-多条命令执行"><a href="#1-9-5-多条命令执行" class="headerlink" title="1.9.5 多条命令执行"></a>1.9.5 多条命令执行</h4><ul><li>单小括号，<code>(cmd1;cmd2;cmd3)</code>  新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。</li><li>单大括号，<code>{ cmd1;cmd2;cmd3;}</code>  在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。</li></ul><p>对 <code>{}</code> 和 <code>()</code> 而言, 括号中的重定向符只影响该条命令，而括号外的重定向符影响到括号中的所有命令。</p><h3 id="1-10-Shell特殊变量-0-和命令行参数"><a href="#1-10-Shell特殊变量-0-和命令行参数" class="headerlink" title="1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数"></a>1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数</h3><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名。</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n是一个数字，表示几个参数。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有采纳数。被双引号(“ “)包含是，与$* 稍有不同。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前shell进程ID。对于shell脚本，就是这个脚本所在的进程ID。</td></tr></tbody></table><h4 id="1-10-1-命令行参数"><a href="#1-10-1-命令行参数" class="headerlink" title="1.10.1 命令行参数"></a>1.10.1 命令行参数</h4><p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 <code>$n</code> 表示，例如，<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数，依次类推。</p><h4 id="1-10-2-和-的区别"><a href="#1-10-2-和-的区别" class="headerlink" title="1.10.2 $* 和 $@ 的区别"></a>1.10.2 <code>$*</code> 和 <code>$@</code> 的区别</h4><p><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</p><p>但是当它们被双引号(“ “)包含时，<code>&quot;$*&quot;</code> 会将所有的参数作为一个整体，以<code>&quot;$1 $2 … $n&quot;</code> 的形式输出所有参数；<code>&quot;$@&quot;</code> 会将各个参数分开，以 <code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code>的形式输出所有参数。</p><h4 id="1-10-3-退出状态"><a href="#1-10-3-退出状态" class="headerlink" title="1.10.3 退出状态"></a>1.10.3 退出状态</h4><p><code>$?</code> 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。</p><p>退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</p><p>不过，也有一些命令返回其他值，表示不同类型的错误。</p><p><code>$?</code> 也可以表示函数的返回值，此处不展开。</p><h3 id="1-11-Shell重定向"><a href="#1-11-Shell重定向" class="headerlink" title="1.11 Shell重定向"></a>1.11 Shell重定向</h3><p>1、重定向符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;               输出重定向到一个文件或设备 覆盖原来的文件</span><br><span class="line">&gt;!              输出重定向到一个文件或设备 强制覆盖原来的文件</span><br><span class="line">&gt;&gt;              输出重定向到一个文件或设备 追加原来的文件</span><br><span class="line">&lt;               输入重定向到一个程序</span><br></pre></td></tr></table></figure><p>2、标准输入刷出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 bash 命令执行的过程中，主要有三种输出入的状况，分别是：</span><br><span class="line">1. 标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt;</span><br><span class="line">2. 标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt;</span><br><span class="line">3. 错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt;</span><br></pre></td></tr></table></figure><p>3、使用实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。</span></span><br><span class="line"><span class="comment"># 1&gt;&amp;2 意思是把标准输出重定向到标准错误.</span></span><br><span class="line"><span class="comment"># 2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。</span></span><br><span class="line"><span class="comment"># &amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中</span></span><br><span class="line"></span><br><span class="line">$ cmd &lt;&gt; file<span class="comment"># 以读写方式打开文件 file</span></span><br><span class="line">$ cmd &gt;&amp;n<span class="comment"># 将 cmd 的输出发送到文件描述符 n</span></span><br><span class="line">$ cmd m&gt;&amp;n<span class="comment"># 将本该输出到文件描述符 m 的内容, 发送到文件描述符 n</span></span><br><span class="line">$ cmd m&lt;&amp;n <span class="comment"># 除了本该从文件描述符 m 处获取输入，改为从文件描述符 n 处获取</span></span><br><span class="line">$ cmd &gt;&amp;-<span class="comment"># 关闭标准输出</span></span><br><span class="line">$ cmd &lt;&amp;-<span class="comment"># 关闭标准输入</span></span><br><span class="line">$ cmd  &gt;&amp; file<span class="comment"># 将标准输出和标准错误都发送到文件 file </span></span><br><span class="line">$ cmd  &amp;&gt; file<span class="comment"># 作用同上, 更好的格式</span></span><br></pre></td></tr></table></figure><p>要在终端中打印stdout，同时将它重定向到一个文件中，那么可以这样使用tee 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法：command | tee FILE1 FILE2</span></span><br><span class="line">$ cat a* | tee out.txt | cat -n</span><br><span class="line"><span class="comment"># 默认情况下， tee命令会将文件覆盖，但它提供了一个-a选项，用于追加内容</span></span><br><span class="line">$ cat a* | tee -a out.txt | cat –n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以使用stdin作为命令参数。只需要将-作为命令的文件名参数即可</span></span><br><span class="line"><span class="comment"># 用法：$ cmd1 | cmd2 | cmd -</span></span><br><span class="line">$ <span class="built_in">echo</span> who is this | tee -</span><br></pre></td></tr></table></figure><h3 id="1-12-Shell数组和关联数组"><a href="#1-12-Shell数组和关联数组" class="headerlink" title="1.12 Shell数组和关联数组"></a>1.12 Shell数组和关联数组</h3><h4 id="1-12-1-简介"><a href="#1-12-1-简介" class="headerlink" title="1.12.1 简介"></a>1.12.1 简介</h4><p>数组是Shell脚本非常重要的组成部分，它借助索引将多个独立的独立的数据存储为一个集合。普通数组只能使用整数作为数组索引，关联数组不仅可以使用整数作为索引，也可以使用字符串作为索引。通常情况下，使用字符串做索引更容易被人们理解。Bash从4.0之后开始引入关联数组。</p><h4 id="1-12-2-定义打印普通数组"><a href="#1-12-2-定义打印普通数组" class="headerlink" title="1.12.2 定义打印普通数组"></a>1.12.2 定义打印普通数组</h4><p>数组的方法有如下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在一行上列出所有元素</span></span><br><span class="line">$ array_var=(1 2 3 4 5 6)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以“索引-值”的形式一一列出</span></span><br><span class="line">$ array_var[0]=<span class="string">"test1"</span></span><br><span class="line">$ array_var[1]=<span class="string">"test2"</span></span><br><span class="line">$ array_var[2]=<span class="string">"test3"</span></span><br></pre></td></tr></table></figure><p>注意：第一种方法要使用圆括号，否则后面会报错。</p><p>数组元素的方法有如下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[0]&#125;</span>         <span class="comment">#输出结果为 test1</span></span><br><span class="line">$ index=2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[$index]&#125;</span>    <span class="comment">#输出结果为 test3</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[*]&#125;</span>         <span class="comment">#输出所有数组元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[@]&#125;</span>         <span class="comment">#输出所有数组元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#array_var[*]&#125;</span>        <span class="comment">#输出值为 3</span></span><br></pre></td></tr></table></figure><p>注意：在ubuntu 14.04中，shell脚本要以#!/bin/bash开头，且执行脚本的方式为 bash test.sh。</p><h4 id="1-12-3-定义打印关联数组"><a href="#1-12-3-定义打印关联数组" class="headerlink" title="1.12.3 定义打印关联数组"></a>1.12.3 定义打印关联数组</h4><p>定义关联数组<br>在关联数组中，可以使用任何文本作为数组索引。定义关联数组时，首先需要使用声明语句将一个变量声明为关联数组，然后才可以在数组中添加元素，过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -A ass_array                           <span class="comment">#声明一个关联数组</span></span><br><span class="line">$ ass_array=([<span class="string">"index1"</span>]=index1 [<span class="string">"index2"</span>]=index2)<span class="comment">#内嵌“索引-值”列表法</span></span><br><span class="line">$ ass_array[<span class="string">"index3"</span>]=index3</span><br><span class="line">$ ass_array[<span class="string">"index4"</span>]=index4</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;ass_array["index1"]&#125;</span>                    <span class="comment">#输出为index1</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;ass_array["index4"]&#125;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[*]&#125;</span>                          <span class="comment">#输出索引列表</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[@]&#125;</span>                          <span class="comment">#输出索引列表</span></span><br></pre></td></tr></table></figure><p>注意：对于普通数组，使用上面的方法依然可以列出索引列表，在声明关联数组以及添加数组元素时，都不能在前面添加美元符$。</p><h3 id="1-13-使用别名"><a href="#1-13-使用别名" class="headerlink" title="1.13 使用别名"></a>1.13 使用别名</h3><p>alias命令的作用只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名设置一直保持作用，可以将它放入~/.bashrc文件中。因为每当一个新的shell进程生成时，都会执行 ~/.bashrc中的命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> install=<span class="string">'sudo apt-get install'</span></span><br></pre></td></tr></table></figure><h3 id="1-14-获取、设置日期和延时"><a href="#1-14-获取、设置日期和延时" class="headerlink" title="1.14 获取、设置日期和延时"></a>1.14 获取、设置日期和延时</h3><p>时间方面 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% : 印出</span><br><span class="line">% %n : 下一行</span><br><span class="line">%t : 跳格</span><br><span class="line">%H : 小时(00..23)</span><br><span class="line">%I : 小时(01..12)</span><br><span class="line">%k : 小时(0..23)</span><br><span class="line">%l : 小时(1..12)</span><br><span class="line">%M : 分钟(00..59)</span><br><span class="line">%p : 显示本地 AM 或 PM</span><br><span class="line">%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</span><br><span class="line">%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数 %S : 秒(00..61)</span><br><span class="line">%T : 直接显示时间 (24 小时制)</span><br><span class="line">%X : 相当于 %H:%M:%S</span><br><span class="line">%Z : 显示时区</span><br></pre></td></tr></table></figure><p>日期方面 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%a : 星期几 (Sun..Sat)</span><br><span class="line">%A : 星期几 (Sunday..Saturday)</span><br><span class="line"></span><br><span class="line">%b : 月份 (Jan..Dec)</span><br><span class="line">%B : 月份 (January..December)</span><br><span class="line"></span><br><span class="line">%y : 年份的最后两位数字 (00.99)</span><br><span class="line">%Y : 完整年份 (0000..9999)</span><br><span class="line"></span><br><span class="line">%c : 直接显示日期与时间</span><br><span class="line">%d : 日 (01..31)</span><br><span class="line">%D : 直接显示日期 (mm/dd/yy)</span><br><span class="line">%h : 同 %b</span><br><span class="line">%j : 一年中的第几天 (001..366)</span><br><span class="line">%m : 月份 (01..12)</span><br><span class="line">%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)</span><br><span class="line">%w : 一周中的第几天 (0..6)</span><br><span class="line">%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)</span><br><span class="line">%x : 直接显示日期 (mm/dd/yy)</span><br></pre></td></tr></table></figure><p>若是不以加号作为开头，则表示要设定时间，而时间格式为 <code>MMDDhhmm[[CC]YY][.ss]</code>，其中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MM 为月份，</span><br><span class="line">DD 为日，</span><br><span class="line">hh 为小时，</span><br><span class="line">mm 为分钟，</span><br><span class="line">CC 为年份前两位数字，</span><br><span class="line">YY 为年份后两位数字，</span><br><span class="line">ss 为秒数</span><br></pre></td></tr></table></figure><p>参数 :</p><p>-d datestr : 显示 datestr 中所设定的时间 (非系统时间)</p><p>–help : 显示辅助讯息</p><p>-s datestr : 将系统时间设为 datestr 中所设定的时间</p><p>-u : 显示目前的格林威治时间</p><p>–version : 显示版本编号</p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ date<span class="comment"># 获取日期</span></span><br><span class="line">$ date +%s<span class="comment"># 打印纪元时</span></span><br><span class="line">$ date <span class="string">"+%d %B %Y"</span><span class="comment"># 用格式串结合 + 作为date命令的参数，可以按照你的选择打印出对应格式的日期</span></span><br><span class="line">20 May 2010</span><br><span class="line">$ date -s <span class="string">"21 June 2009 11:01:22"</span> <span class="comment"># 设置日期和时间</span></span><br></pre></td></tr></table></figure><h3 id="1-15-脚本调试"><a href="#1-15-脚本调试" class="headerlink" title="1.15 脚本调试"></a>1.15 脚本调试</h3><h4 id="1-15-1使用选项–x，启用shell脚本的跟踪调试功能"><a href="#1-15-1使用选项–x，启用shell脚本的跟踪调试功能" class="headerlink" title="1.15.1使用选项–x，启用shell脚本的跟踪调试功能"></a>1.15.1使用选项–x，启用shell脚本的跟踪调试功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash -x script.sh</span><br></pre></td></tr></table></figure><h4 id="1-15-2-使用set-x和set-x对脚本进行部分调试"><a href="#1-15-2-使用set-x和set-x对脚本进行部分调试" class="headerlink" title="1.15.2 使用set -x和set +x对脚本进行部分调试"></a>1.15.2 使用set -x和set +x对脚本进行部分调试</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#文件名: debug.sh</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.6</span>&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">set</span> -x</span><br><span class="line">echo $i</span><br><span class="line"><span class="keyword">set</span> +x</span><br><span class="line">done</span><br><span class="line">echo <span class="string">"Script executed"</span></span><br></pre></td></tr></table></figure><ul><li>set –x：在执行时显示参数和命令。 </li><li>set +x：禁止调试。 </li><li>set –v：当命令进行读取时显示输入。 </li><li>set +v：禁止打印输入。 </li></ul><h4 id="1-15-3-通过传递-DEBUG环境变量调试"><a href="#1-15-3-通过传递-DEBUG环境变量调试" class="headerlink" title="1.15.3 通过传递 _DEBUG环境变量调试"></a>1.15.3 通过传递 _DEBUG环境变量调试</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DEBUG</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">[ <span class="string">"$_DEBUG"</span> == <span class="string">"on"</span> ] &amp;&amp; $@ || :</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.10</span>&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">DEBUG echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>可以将调试功能置为”on”来运行上面的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ _DEBUG=on ./script.sh</span><br></pre></td></tr></table></figure><p>我们在每一个需要打印调试信息的语句前加上DEBUG。如果没有把 _DEBUG=on传递给脚本，那么调试信息就不会打印出来。在Bash中，命令 <code>:</code> 告诉shell不要进行任何操作。 </p><h4 id="1-15-4-利用shebang来进行调试"><a href="#1-15-4-利用shebang来进行调试" class="headerlink" title="1.15.4 利用shebang来进行调试"></a>1.15.4 利用shebang来进行调试</h4><p>shebang的妙用<br>把shebang从 <code>#!/bin/bash</code> 改成 <code>#!/bin/bash -xv</code>，这样一来，不用任何其他选项就可以启用调试功能了。 </p><h3 id="1-16-函数参数"><a href="#1-16-函数参数" class="headerlink" title="1.16 函数参数"></a>1.16 函数参数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$<span class="number">0</span> # 脚本名</span><br><span class="line">$<span class="number">1</span># 第一个参数</span><br><span class="line">$<span class="number">2</span># 第二个参数</span><br><span class="line">$n# 第n个参数</span><br><span class="line"><span class="string">"$@"</span># 被扩展成 <span class="string">"$1"</span> <span class="string">"$2"</span> <span class="string">"$3"</span>等</span><br><span class="line"><span class="string">"$*"</span># 被扩展成 <span class="string">"$1c$2c$3"</span>，其中c是IFS的第一个字符</span><br><span class="line"><span class="string">"$@"</span> 要比<span class="string">"$*"</span>用得多。由于 <span class="string">"$*"</span>将所有的参数当做单个字符串，因此它很少被使用。</span><br></pre></td></tr></table></figure><p><strong>导出函数：</strong></p><p>函数也能像环境变量一样用export导出，如此一来，函数的作用域就可以扩展到子进程中，例如： </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> -f fname</span><br></pre></td></tr></table></figure><h3 id="1-17-read命令"><a href="#1-17-read命令" class="headerlink" title="1.17 read命令"></a>1.17 read命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从输入中读取n个字符并存入变量</span></span><br><span class="line">$ <span class="built_in">read</span> -n 2 var</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用无回显的方式读取密码</span></span><br><span class="line">$ <span class="built_in">read</span> -s var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示提示信息</span></span><br><span class="line">$ <span class="built_in">read</span> -p <span class="string">"Enter input:"</span> var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在特定时(秒)限内读取输入</span></span><br><span class="line">$ <span class="built_in">read</span> -t timeout var</span><br></pre></td></tr></table></figure><h3 id="1-18-条件比较与测试"><a href="#1-18-条件比较与测试" class="headerlink" title="1.18 条件比较与测试"></a>1.18 条件比较与测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if条件</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># else if和else</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> condition <span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>if的条件判断部分可能会变得很长，但可以用逻辑运算符将它变得简洁一些： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition ] &amp;&amp; action <span class="comment"># 如果condition为真，则执行action</span></span><br><span class="line">[ condition ] || action <span class="comment"># 如果condition为假，则执行action</span></span><br></pre></td></tr></table></figure><p><code>&amp;&amp;</code> 是逻辑与运算符， <code>||</code> 是逻辑或运算符。编写Bash脚本时，这是一个很有用的技巧。现在来了解一下条件和比较操作。 </p><p>算术比较：</p><ul><li><code>-gt</code> ：大于。 </li><li><code>-lt</code> ：小于。 </li><li><code>-ge</code> ：大于或等于。 </li><li><code>-le</code> ：小于或等于。 </li></ul><p>可以按照下面的方法结合多个条件进行测试： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="variable">$var1</span> -ne 0 -a <span class="variable">$var2</span> -gt 2 ] <span class="comment">#使用逻辑与-a</span></span><br><span class="line">[ <span class="variable">$var1</span> -ne 0 -o var2 -gt 2 ] <span class="comment">#逻辑或 -o</span></span><br></pre></td></tr></table></figure><p>文件系统相关测试：</p><p>我们可以使用不同的条件标志测试不同的文件系统相关的属性。 </p><ul><li><code>[ -f $file_var ]</code> ：如果给定的变量包含正常的文件路径或文件名，则返回真。 </li><li><code>[ -x $var ]</code> ：如果给定的变量包含的文件可执行，则返回真。 </li><li><code>[ -d $var ]</code> ：如果给定的变量包含的是目录，则返回真。 </li><li><code>[ -e $var ]</code> ：如果给定的变量包含的文件存在，则返回真。 </li><li><code>[ -c $var ]</code> ：如果给定的变量包含的是一个字符设备文件的路径，则返回真。 </li><li><code>[ -b $var ]</code> ：如果给定的变量包含的是一个块设备文件的路径，则返回真。 </li><li><code>[ -w $var ]</code> ：如果给定的变量包含的文件可写，则返回真。 </li><li><code>[ -r $var ]</code> ：如果给定的变量包含的文件可读，则返回真。 </li><li><code>[ -L $var ]</code> ：如果给定的变量包含的是一个符号链接，则返回真。 </li></ul><p>字符串比较：</p><p style="color: red;">使用字符串比较时，最好用双中括号，因为有时候采用单个中括号会产生错误，所以最好避开它们。 </p><p>可以用下面的方法检查两个字符串，看看它们是否相同。 </p><ul><li><code>[[ $str1 = $str2 ]]</code>：当str1等于str2时，返回真。也就是说， str1和str2包含<br>的文本是一模一样的。 </li><li><code>[[ $str1 == $str2 ]]</code> ：这是检查字符串是否相等的另一种写法。 </li></ul><p>也可以检查两个字符串是否不同。 </p><ul><li><code>[[ $str1 != $str2 ]]</code> ：如果str1和str2不相同，则返回真。 </li></ul><p>我们还可以检查字符串的字母序情况，具体如下所示。 </p><ul><li><code>[[ $str1 &gt; $str2 ]]</code> ：如果str1的字母序比str2大，则返回真。 </li><li><code>[[ $str1 &lt; $str2 ]]</code> ：如果str1的字母序比str2小，则返回真。 </li><li><code>[[ -z $str1 ]]</code> ：如果str1包含的是空字符串，则返回真。 </li><li><code>[[ -n $str1 ]]</code> ：如果str1包含的是非空字符串，则返回真。 </li></ul><p>使用逻辑运算符 &amp;&amp; 和 || 能够很容易地将多个条件组合起来： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$str1</span> ]] &amp;&amp; [[ -z <span class="variable">$str2</span> ]] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>test命令可以用来执行条件检测。用test可以避免使用过多的括号。之前讲过的[]中的测试条件同样可以用于test命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> -eq 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"True"</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 也可以写成：</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$var</span> -eq 0 ; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"True"</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><h4 id="1-利用子shell生成一个独立的进程"><a href="#1-利用子shell生成一个独立的进程" class="headerlink" title="1. 利用子shell生成一个独立的进程"></a>1. 利用子shell生成一个独立的进程</h4><p>子shell本身就是独立的进程。可以使用 <code>( )</code>操作符来定义一个子shell ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd;</span><br><span class="line">(cd /bin; ls);</span><br><span class="line">pwd;</span><br></pre></td></tr></table></figure><h4 id="2-无限循环的实例"><a href="#2-无限循环的实例" class="headerlink" title="2. 无限循环的实例"></a>2. 无限循环的实例</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> $@ &amp;&amp; <span class="keyword">return</span>; done &#125;</span><br></pre></td></tr></table></figure><p>工作原理：</p><p>函数repeat，它包含了一个无限while循环，该循环执行以参数形式（通过 <code>$@</code> 访问）传入函数的命令。如果命令执行成功，则返回，进而退出循环。 </p><p><strong>一种更快的做法 ：</strong></p><p>在大多数现代系统中， <code>true</code> 是作为 <code>/bin</code> 中的一个二进制文件来实现的。</p><p style="color: red;">这就意味着每执行一次while循环， shell就不得不生成一个进程。</p>如果不想这样，可以使用shell内建的 <code>:</code>命令，它总是会返回为0的退出码： <p></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; <span class="keyword">while</span> :; <span class="keyword">do</span> $@ &amp;&amp; <span class="keyword">return</span>; done &#125;</span><br></pre></td></tr></table></figure><p>尽管可读性不高，但是肯定比第一种方法快。 </p><h2 id="2-命令之乐"><a href="#2-命令之乐" class="headerlink" title="2. 命令之乐"></a>2. 命令之乐</h2><h3 id="2-1-cat命令"><a href="#2-1-cat命令" class="headerlink" title="2.1 cat命令"></a>2.1 cat命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摆脱多余的空白行</span></span><br><span class="line">$ cat -s file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示行号</span></span><br><span class="line">$ cat -n file</span><br><span class="line"><span class="comment"># -n甚至会为空白行加上行号。如果你想跳过空白行，那么可以使用选项-b。</span></span><br></pre></td></tr></table></figure><h3 id="2-2-find命令"><a href="#2-2-find命令" class="headerlink" title="2.2 find命令"></a>2.2 find命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录及子目录下所有的文件和文件夹</span></span><br><span class="line">$ find base_path</span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># -print指明打印出匹配文件的文件名（路径）。当使用 -print时， '\n'作为用于对输出的文件名进行分隔。就算你忽略-print， find命令仍会打印出文件名。</span></span><br><span class="line"><span class="comment"># -print0指明使用'\0'作为匹配的文件名之间的定界符。</span></span><br></pre></td></tr></table></figure><p>1、find命令有一个选项 <code>-iname</code>（忽略字母大小写） </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">example.txt EXAMPLE.txt file.txt</span><br><span class="line">$ find . -iname <span class="string">"example*"</span> -<span class="built_in">print</span></span><br><span class="line">./example.txt</span><br><span class="line">./EXAMPLE.txt</span><br></pre></td></tr></table></figure><p>2、如果想匹配多个条件中的一个，可以采用OR条件操作 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">new.txt some.jpg text.pdf</span><br><span class="line">$ find . \( -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span> \) -<span class="built_in">print</span></span><br><span class="line">./text.pdf</span><br><span class="line">./new.txt</span><br></pre></td></tr></table></figure><p>3、选项-path的参数可以使用通配符来匹配文件路径。 <code>-name</code> 总是用给定的文件名进行匹配。<code>-path</code> 则将文件路径作为一个整体进行匹配。例如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find /home/users -path <span class="string">"*/slynux/*"</span> -<span class="built_in">print</span></span><br><span class="line">/home/users/list/slynux.txt</span><br><span class="line">/home/users/slynux/eg.css</span><br></pre></td></tr></table></figure><p>4、选项 <code>-regex</code> 的参数和 <code>-path</code> 的类似，只不过 <code>-regex</code> 是基于正则表达式来匹配文件路径的。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">new.PY next.jpg test.py</span><br><span class="line">$ find . -regex <span class="string">".*\(\.py\|\.sh\)$"</span></span><br><span class="line">./test.py</span><br><span class="line"><span class="comment"># 类似地， -iregex可以让正则表达式忽略大小写。例如：</span></span><br><span class="line">$ find . -iregex <span class="string">".*\(\.py\|\.sh\)$"</span></span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure><p>5、find也可以用“!”否定参数的含义。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">list.txt new.PY new.txt next.jpg test.py</span><br><span class="line">$ find . ! -name <span class="string">"*.txt"</span> -<span class="built_in">print</span></span><br><span class="line">.</span><br><span class="line">./next.jpg</span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure><p>6、基于目录深度的搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 深度选项-maxdepth和 -mindepth来限制find命令遍历的目录深度</span></span><br><span class="line"><span class="comment"># 下列命令将find命令向下的最大深度限制为1:</span></span><br><span class="line">$ find . -maxdepth 1 -name <span class="string">"f*"</span> -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出深度距离当前目录至少两个子目录的所有文件:</span></span><br><span class="line">$ find . -mindepth 2 -name <span class="string">"f*"</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>-maxdepth和-mindepth应该作为find的第三个参数出现。如果作为第4个或之后的参数，就可能会影响到find的效率，因为它不得不进行一些不必要的检查。 </p><p>根据文件类型搜索</p><p>7、根据文件类型搜索</p><p><code>-type</code> 可以对文件搜索进行过滤 </p><table><thead><tr><th>文件类型</th><th>类型参数</th></tr></thead><tbody><tr><td>普通文件</td><td>f</td></tr><tr><td>符号链接</td><td>l</td></tr><tr><td>目录</td><td>d</td></tr><tr><td>字符设备</td><td>c</td></tr><tr><td>块设备</td><td>b</td></tr><tr><td>套接字</td><td>s</td></tr><tr><td>FIFO</td><td>p</td></tr></tbody></table><p>8、根据文件时间进行搜索</p><ul><li>访问时间（-atime）：用户最近一次访问文件的时间。</li><li>修改时间（-mtime）：文件内容最后一次被修改的时间。</li><li>变化时间（-ctime）：文件元数据（例如权限或所有权）最后一次改变的时间。</li></ul><blockquote><p>-atime、 -mtime、 -ctime可作为find的时间选项。它们可以用整数值指定，单位是天。这些整数值通常还带有 - 或 + ： - 表示小于， + 表示大于。 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出在最近7天内被访问过的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime -7 -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出恰好在7天前被访问过的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime 7 -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出访问时间超过7天的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime +7 -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>-atime、 -mtime以及-ctime都是基于时间的参数，其计量单位是“天”。还有其他一些基于时间的参数是以分钟作为计量单位的。这些参数包括： </p><ul><li>-amin（访问时间）</li><li>-mmin（修改时间）</li><li>-cmin（变化时间）</li></ul><p>使用 <code>-newer</code> ，我们可以指定一个用于比较时间戳的参考文件，然后找出比参考文件更新的（更近的修改时间）所有文件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出比file.txt修改时间更近的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -newer file.txt -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>9、基于文件大小的搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -size +2k</span><br><span class="line"><span class="comment"># 大于2KB的文件</span></span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -size -2k</span><br><span class="line"><span class="comment"># 小于2KB的文件</span></span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -size 2k</span><br><span class="line"><span class="comment"># 大小等于2KB的文件</span></span><br></pre></td></tr></table></figure><ul><li>b —— 块（512字节）</li><li>c —— 字节</li><li>w —— 字（2字节）</li><li>k —— 1024字节</li><li>M —— 1024k字节</li><li>G —— 1024M字节</li></ul><p>10、删除匹配的文件</p><p><code>-delete</code> 可以用来删除find查找到的匹配文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除当前目录下所有的 .swp文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.swp"</span> -delete</span><br></pre></td></tr></table></figure><p>11、基于文件权限和所有权的匹配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -perm 644 -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印出权限为644的文件</span></span><br></pre></td></tr></table></figure><p>-perm指明find应该只匹配具有特定权限值的文件。 </p><p>12、利用find执行命令或动作 </p><p>find命令可以借助选项-exec与其他命名进行结合。 -exec算得上是find最强大的特性之一。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> chown slynux &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#125;是一个与 -exec选项搭配使用的特殊字符串。对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名。</span></span><br></pre></td></tr></table></figure><p><code>-exec</code> 结合多个命令 :</p><p>我们无法在-exec参数中直接使用多个命令。它只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个shell脚本中（例如command.sh），然后在-exec中使用这个脚本：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec ./commands.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>13、让find跳过特定的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find devel/source_path \( -name <span class="string">".git"</span> -prune \) -o \( -<span class="built_in">type</span> f -<span class="built_in">print</span> \)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令打印出不包括在.git目录中的所有文件的名称（路径）。</span></span><br></pre></td></tr></table></figure><p><code>\( -name &quot;.git&quot; -prune \)</code> 的作用是用于进行排除，它指明了 .git目录应该被排除在外，而<code>\( -type f -print \)</code> 指明了需要执行的动作。这些动作需要被放置在第二个语句块中（打印出所有文件的名称和路径）。 </p><h3 id="2-3-玩转xargs"><a href="#2-3-玩转xargs" class="headerlink" title="2.3 玩转xargs"></a>2.3 玩转xargs</h3><p><code>xargs</code> 擅长将标准输入数据转换成命令行参数。</p><p><code>xargs</code> 命令把从 stdin接收到的数据重新格式化，再将其作为参数提供给其他命令。 </p><h4 id="2-3-1-将多行输入转换成单行输出"><a href="#2-3-1-将多行输入转换成单行输出" class="headerlink" title="2.3.1 将多行输入转换成单行输出"></a>2.3.1 将多行输入转换成单行输出</h4><p>只需要将换行符移除，再用” “（空格）进行代替，就可以实现多行输入的转换。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.txt <span class="comment"># 样例文件</span></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">7 8 9 10</span><br><span class="line">11 12</span><br><span class="line">$ cat example.txt | xargs</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12</span><br></pre></td></tr></table></figure><h4 id="2-3-2-将单行输入转换成多行输出"><a href="#2-3-2-将单行输入转换成多行输出" class="headerlink" title="2.3.2 将单行输入转换成多行输出"></a>2.3.2 将单行输入转换成多行输出</h4><p>指定每行最大的参数数量 <code>n</code>，我们可以将任何来自stdin的文本划分成多行，每行 <code>n</code> 个参数。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.txt | xargs -n 3</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">10 11 12</span><br></pre></td></tr></table></figure><h4 id="2-3-3-定制定界符"><a href="#2-3-3-定制定界符" class="headerlink" title="2.3.3 定制定界符"></a>2.3.3 定制定界符</h4><p>用 <code>-d</code> 选项为输入指定一个定制的定界符： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X</span><br><span class="line">split split split split</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X -n 2</span><br><span class="line">split split</span><br><span class="line">split split</span><br></pre></td></tr></table></figure><p>在这里，我们明确指定X作为输入定界符，而在默认情况下， xargs采用内部字段分隔符（空格）作为输入定界符。 </p><h4 id="2-3-4-读取stdin，将格式化参数传递给命令"><a href="#2-3-4-读取stdin，将格式化参数传递给命令" class="headerlink" title="2.3.4 读取stdin，将格式化参数传递给命令"></a>2.3.4 读取stdin，将格式化参数传递给命令</h4><p><code>-I</code> 指定替换字符串，这个字符串在xargs扩展时会被替换掉。如果将 <code>-I</code> 与 <code>xargs</code> 结合使用，对于每一个参数，命令都会被执行一次。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat args.txt</span><br><span class="line">arg1</span><br><span class="line">arg2</span><br><span class="line">arg3</span><br><span class="line">$ cat args.txt | xargs -I &#123;&#125; ./cecho.sh -p &#123;&#125; -l</span><br><span class="line">-p arg1 -l <span class="comment">#</span></span><br><span class="line">-p arg2 -l <span class="comment">#</span></span><br><span class="line">-p arg3 -l <span class="comment">#</span></span><br></pre></td></tr></table></figure><p><code>-I {}</code> 指定了替换字符串。对于每一个命令参数，字符串 <code>{}</code> 都会被从stdin读取到的参数替换掉。 </p><p>使用 <code>-I</code> 的时候，命令以循环的方式执行。 </p><p>xargs和find算是一对死党。两者结合使用可以让任务变得更轻松。 不过人们通常却是以一种错误的组合方式使用它们。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">print</span> | xargs rm -f</span><br></pre></td></tr></table></figure><p>这样做很危险。 有时可能会删除不必要删除的文件。 </p><p>只要我们把 <code>find</code> 的输出作为 <code>xargs</code> 的输入，就必须将 <code>-print0</code> 与 <code>find</code> 结合使用，以字符<code>null（&#39;\0&#39;）</code>来分隔输出。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -print0 | xargs -0 rm -f</span><br><span class="line"><span class="comment"># xargs -0将\0作为输入定界符。</span></span><br><span class="line"></span><br><span class="line">$ find source_code_dir_path -<span class="built_in">type</span> f -name <span class="string">"*.c"</span> -print0 | xargs -0 wc -l</span><br><span class="line"><span class="comment"># 统计源代码目录中所有C程序文件的行数</span></span><br></pre></td></tr></table></figure><h3 id="2-4-校验和与核实"><a href="#2-4-校验和与核实" class="headerlink" title="2.4 校验和与核实"></a>2.4 校验和与核实</h3><p>校验和（checksum）程序用来从文件中生成校验和密钥，然后利用这个校验和密钥核实文件的完整性。文件可以通过网络或任何存储介质分发到不同的地点。 </p><p>最知名且使用最为广泛的校验和技术是md5sum和SHA-1。它们对文件内容使用相应的算法来生成校验和。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum filename</span><br><span class="line">68b329da9893e34099c7d8ad5cb9c940 filename</span><br><span class="line"></span><br><span class="line">$ md5sum filename &gt; file_sum.md5</span><br><span class="line"></span><br><span class="line">$ md5sum file1 file2 file3 ..</span><br><span class="line"></span><br><span class="line">$ md5sum -c file_sum.md5</span><br><span class="line"><span class="comment"># 这个命令会输出校验和是否匹配的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要用所有的.md5信息来检查所有的文件，可以使用：</span></span><br><span class="line">$ md5sum -c *.md5</span><br></pre></td></tr></table></figure><p>计算SAH-1串的命令是sha1sum。其用法和md5sum的非常相似。只需要把先前讲过的那些命令中的md5sum替换成sha1sum就行了，记住将输入文件名从file_sum.md5改为file_sum.sha1。 </p><p>对目录进行校验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ md5deep -rl directory_path &gt; directory.md5</span><br><span class="line"><span class="comment"># -r使用递归的方式</span></span><br><span class="line"><span class="comment"># -l使用相对路径。默认情况下， md5deep会输出文件的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者也可以结合find来递归计算校验和：</span></span><br><span class="line">$ find directory_path -<span class="built_in">type</span> f -print0 | xargs -0 md5sum &gt;&gt; directory.md5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的命令进行核实：</span></span><br><span class="line">$ md5sum -c directory.md5</span><br></pre></td></tr></table></figure><h4 id="2-4-1-加密工具与散列"><a href="#2-4-1-加密工具与散列" class="headerlink" title="2.4.1 加密工具与散列"></a>2.4.1 加密工具与散列</h4><p><code>crypt</code>、 <code>gpg</code>、 <code>base64</code>、 <code>md5sum</code>、 <code>sha1sum</code> 以及 <code>openssl</code> 的用法。 </p><p>1）crypt是一个简单的加密工具，它从stdin接受一个文件以及口令作为输入，然后将加密数据输出到Stdout（因此要对输入、输出文件使用重定向）。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ crypt &lt;input_file &gt;output_file</span><br><span class="line">Enter passphrase:</span><br><span class="line"><span class="comment"># 它会要求输入一个口令。我们也可以通过命令行参数来提供口令。</span></span><br><span class="line"></span><br><span class="line">$ crypt PASSPHRASE &lt;input_file &gt;encrypted_file</span><br><span class="line"><span class="comment"># 如果需要解密文件，可以使用：</span></span><br><span class="line">$ crypt PASSPHRASE -d &lt;encrypted_file &gt;output_file</span><br></pre></td></tr></table></figure><p>2）gpg（GNU隐私保护）是一种应用广泛的工具，它使用加密技术来保护文件，以确保数据在送达目的地之前无法被读取。这里我们讨论如何加密、解密文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用gpg加密文件：</span></span><br><span class="line">$ gpg -c filename</span><br><span class="line"><span class="comment"># 该命令采用交互方式读取口令，并生成filename.gpg。使用以下命令解密gpg文件：</span></span><br><span class="line">$ gpg filename.gpg</span><br><span class="line"><span class="comment"># 该命令读取口令，然后对文件进行解密。</span></span><br></pre></td></tr></table></figure><p>3）Base64是一组相似的编码方案，它将ASCII字符转换成以64为基数的形式，以可读的ASCII字符串来描述二进制数据。 base64命令可以用来编码/解码Base64字符串。要将文件编码为Base64格式，可以使用： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ base64 filename &gt; outputfile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat file | base64 &gt; outputfile</span><br><span class="line"><span class="comment"># base64可以从stdin中进行读取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码Base64数据：</span></span><br><span class="line">$ base64 -d file &gt; outputfile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat base64_file | base64 -d &gt; outputfile</span><br></pre></td></tr></table></figure><p>4）md5sum与sha1sum都是单向散列算法，均无法逆推出原始数据。它们通常用于验证数据完整性或为特定数据生成唯一的密钥： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum file</span><br><span class="line">8503063d5488c3080d4800ff50850dc9 file</span><br><span class="line">$ sha1sum file</span><br><span class="line">1ba02b66e2e557fede8f61b7df282cd0a27b816b file</span><br></pre></td></tr></table></figure><p>这种类型的散列算法是存储密码的理想方案。密码使用其对应的散列值来存储。如果某个用户需要进行认证，读取该用户提供的密码并转换成散列值，然后将其与之前存储的散列值进行比对。如果相同，用户就通过认证，被允许访问；否则，就会被拒绝访问。 </p><p>5）openssl</p><p>用openssl生成shadow密码。 shadow密码通常都是salt密码。所谓SALT就是额外的一个字符串，用来起一个混淆的作用，使加密更加不易被破解。 salt由一些随机位组成，被用作密钥生成函数的输入之一，以生成密码的salt散列值。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ opensslpasswd -1 -salt SALT_STRING PASSWORD</span><br><span class="line"><span class="variable">$1</span><span class="variable">$SALT_STRING</span><span class="variable">$323VkWkSLHuhbt1zkSsUG</span>.</span><br><span class="line"><span class="comment"># 将SALT_STRING替换为随机字符串，并将PASSWORD替换成你想要使用的密码。</span></span><br></pre></td></tr></table></figure><h3 id="2-5-排序、唯一与重复"><a href="#2-5-排序、唯一与重复" class="headerlink" title="2.5 排序、唯一与重复"></a>2.5 排序、唯一与重复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对一组文件进行排序：</span></span><br><span class="line">$ sort file1.txt file2.txt &gt; sorted.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照数字顺序进行排序：</span></span><br><span class="line">$ sort -n file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照逆序进行排序：</span></span><br><span class="line">$ sort -r file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照月份进行排序（依照一月，二月，三月……）：</span></span><br><span class="line">$ sort -M months.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两个已排序过的文件：</span></span><br><span class="line">$ sort -m sorted1 sorted2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出已排序文件中不重复的行：</span></span><br><span class="line">$ sort file1.txt file2.txt | uniq</span><br></pre></td></tr></table></figure><p>检查文件是否已经排序过：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#功能描述：排序</span><br><span class="line">sort -C filename ;</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ]; then</span><br><span class="line">echo Sorted;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo Unsorted;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><code>-k</code> 指定了排序应该按照哪一个键（key）来进行。键指的是列号，而列号就是执行排序时的依据。 <code>-r</code> 告诉sort命令按照逆序进行排序。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依据第1列，以逆序形式排序</span></span><br><span class="line">$ sort -nrk 1 data.txt</span><br><span class="line">4 linux 1000</span><br><span class="line">3 bsd 1000</span><br><span class="line">2 winxp 4000</span><br><span class="line">1 mac 2000</span><br><span class="line"><span class="comment"># -nr表明按照数字，采用逆序形式排序</span></span><br><span class="line"><span class="comment"># 依据第2列进行排序</span></span><br><span class="line">$ sort -k 2 data.txt</span><br><span class="line">3 bsd 1000</span><br><span class="line">4 linux 1000</span><br><span class="line">1 mac 2000</span><br><span class="line">2 winxp 4000</span><br></pre></td></tr></table></figure><p>有时文本中可能会包含一些像空格之类的不必要的多余字符。如果需要忽略这些字符，并以字典序进行排序，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sort -bd unsorted.txt</span><br><span class="line"><span class="comment"># 选项-b用于忽略文件中的前导空白行，选项-d用于指明以字典序进行排序。</span></span><br></pre></td></tr></table></figure><p>sort选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-b：忽略每行前面开始出的空格字符；</span><br><span class="line"></span><br><span class="line">-c：检查文件是否已经按照顺序排序； </span><br><span class="line"></span><br><span class="line">-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符； </span><br><span class="line"></span><br><span class="line">-f：排序时，将小写字母视为大写字母； </span><br><span class="line"></span><br><span class="line">-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</span><br><span class="line"></span><br><span class="line">-m：将几个排序号的文件进行合并； </span><br><span class="line"></span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序； </span><br><span class="line"></span><br><span class="line">-n：依照数值的大小排序； </span><br><span class="line"></span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件； </span><br><span class="line"></span><br><span class="line">-r：以相反的顺序来排序； </span><br><span class="line"></span><br><span class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符； </span><br><span class="line"></span><br><span class="line">+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</span><br></pre></td></tr></table></figure><p>uniq选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：在每列旁边显示该行重复出现的次数； </span><br><span class="line"></span><br><span class="line">-d或--repeated：仅显示重复出现的行列； </span><br><span class="line"></span><br><span class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位； </span><br><span class="line"></span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符； </span><br><span class="line"></span><br><span class="line">-u或——unique：仅显示出一次的行列； </span><br><span class="line"></span><br><span class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。</span><br></pre></td></tr></table></figure><p>wc选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-c或--bytes或——chars：只显示Bytes数； <span class="comment"># 统计字符数</span></span><br><span class="line"></span><br><span class="line">-l或——lines：只显示列数； <span class="comment"># 统计行数</span></span><br><span class="line"></span><br><span class="line">-w或——words：只显示字数。<span class="comment"># 统计单词数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当不使用任何选项执行wc时，它会分别打印出文件的行数、单词数和字符数：</span></span><br><span class="line">$ wc file</span><br><span class="line">1435 15763 112200</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-L选项打印出文件中最长一行的长度：</span></span><br><span class="line">$ wc file -L</span><br><span class="line">205</span><br></pre></td></tr></table></figure><h3 id="2-6-临时文件命名与随机数"><a href="#2-6-临时文件命名与随机数" class="headerlink" title="2.6 临时文件命名与随机数"></a>2.6 临时文件命名与随机数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建临时文件：</span></span><br><span class="line">$ filename=`mktemp`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$filename</span></span><br><span class="line">/tmp/tmp.8xvhkjF5fH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时目录：</span></span><br><span class="line">$ dirname=`mktemp -d`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$dirname</span></span><br><span class="line">tmp.NI8xzW7VRX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果仅仅是想生成文件名，又不希望创建实际的文件或目录，方法如下：</span></span><br><span class="line">$ tmpfile=`mktemp -u`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$tmpfile</span></span><br><span class="line">/tmp/tmp.RsGmilRpcT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模板创建临时文件名：</span></span><br><span class="line"><span class="variable">$mktemp</span> test.XXX</span><br><span class="line">test.2tc</span><br></pre></td></tr></table></figure><p>如果提供了定制模板， X会被随机的字符（字母或数字）替换。注意， mktemp正常工作的前提是保证模板中只少要有3个X。 </p><h3 id="2-7-split-分割文件和数据"><a href="#2-7-split-分割文件和数据" class="headerlink" title="2.7 split 分割文件和数据"></a>2.7 split 分割文件和数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件分割成多个大小为10KB的文件</span></span><br><span class="line">$ split -b 10k data.file</span><br><span class="line">$ ls</span><br><span class="line">data.file xaa xab xac xad xae xaf xag xah xai xaj</span><br></pre></td></tr></table></figure><p>上面的命令将data.file分割成多个文件，每一个文件大小为10KB。这些文件以xab、 xac、 xad的形式命名。这表明它们都有一个字母后缀。如果想以数字为后缀，可以另外使用-d参数。此外，使用 -a length可以指定后缀长度： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 10k data.file -d -a 4</span><br><span class="line">$ ls</span><br><span class="line">data.file x0009 x0019 x0029 x0039 x0049 x0059 x0069 x0079</span><br></pre></td></tr></table></figure><p>除了k（KB）后缀，我们还可以使用M（MB）、 G（GB）、 c（byte）、 w（word）等后缀。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为分割后的文件指定文件名前缀 </span></span><br><span class="line">$ split -b 10k data.file -d -a 4 split_file</span><br><span class="line">$ ls</span><br><span class="line">data.file   split_file0002 split_file0005 split_file0008 strtok.c</span><br><span class="line">split_file0000 split_file0003 split_file0006 split_file0009</span><br><span class="line">split_file0001 split_file0004 split_file0007</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想按照数据块大小，而是需要根据行数来分割文件的话，可以使用 -l no_of_lines：</span></span><br><span class="line">$ split -l 10 data.file</span><br><span class="line"><span class="comment"># 分割成多个文件，每个文件包含10行</span></span><br></pre></td></tr></table></figure><p>csplit。它能够依据指定的条件和字符串匹配选项对日志文件进行分割。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat server.log</span><br><span class="line">SERVER-1</span><br><span class="line">[connection] 192.168.0.1 success</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 success</span><br><span class="line">SERVER-2</span><br><span class="line">[connection] 192.168.0.1 failed</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 success</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line">SERVER-3</span><br><span class="line">[connection] 192.168.0.1 pending</span><br><span class="line">[connection] 192.168.0.2 pending</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line">$ csplit server.log /SERVER/ -n 2 -s &#123;*&#125; -f server -b <span class="string">"%02d.log"</span> ; rm server00.log</span><br><span class="line">$ ls</span><br><span class="line">server01.log server02.log server03.log server.log</span><br></pre></td></tr></table></figure><p>有关这个命令的详细说明如下。 </p><ul><li>/SERVER/ 用来匹配某一行，分割过程即从此处开始。 </li><li>/[REGEX]/ 表示文本样式。包括从当前行（第一行）直到（但不包括）包含“SERVER”的匹配行。 </li><li>{*} 表示根据匹配重复执行分割，直到文件末尾为止。可以用{整数}的形式来指定分割执行的次数。 </li><li>-s 使命令进入静默模式，不打印其他信息。 </li><li>-n 指定分割后的文件名后缀的数字个数，例如01、 02、 03等。 </li><li>-f 指定分割后的文件名前缀（在上面的例子中， server就是前缀）。 </li><li>-b 指定后缀格式。例如%02d.log，类似于C语言中printf的参数格式。在这里文件名=前缀+后缀=server + %02d.log。 </li></ul><p>因为分割后的第一个文件没有任何内容（匹配的单词就位于文件的第一行中），所以我们删除了server00.log。 </p><h4 id="2-7-1-根据扩展名切分文件名-、"><a href="#2-7-1-根据扩展名切分文件名-、" class="headerlink" title="2.7.1 根据扩展名切分文件名$、"></a>2.7.1 根据扩展名切分文件名$、</h4><p>借助 <code>%</code> 操作符可以轻松将名称部分从 “名称.扩展名” 这种格式中提取出来。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">name=$&#123;file_jpg%.*&#125;</span><br><span class="line">echo File name is: $name</span><br><span class="line">输出结果：</span><br><span class="line">File name is: sample</span><br></pre></td></tr></table></figure><p>将文件名的扩展名部分提取出来，这可以借助 # 操作符实现。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension=$&#123;file_jpg#*.&#125;</span><br><span class="line">echo Extension is: jpg</span><br><span class="line">输出结果：</span><br><span class="line">Extension is: jpg</span><br></pre></td></tr></table></figure><p><code>${VAR%.*}</code>  的含义如下所述： </p><ul><li>从 $VAR中删除位于 % 右侧的通配符（在前例中是.*）所匹配的字符串。通配符从右向左进行匹配。 </li><li>给VAR赋值， VAR=sample.jpg。那么，通配符从右向左就会匹配到.jpg，因此，从 $VAR中删除匹配结果，就会得到输出sample。 </li></ul><p>%属于非贪婪（non-greedy）操作。它从右到左找出匹配通配符的最短结果。还有另一个操作符 %%，这个操作符与%相似，但行为模式却是贪婪的，这意味着它会匹配符合条件的最长的字符串。 </p><p>操作符%%则用.*从右向左执行贪婪匹配（.fun.book.txt）。 </p><p><code>${VAR#*.}</code> 的含义如下所述：<br>从$VAR中删除位于#右侧的通配符（即在前例中使用的*.）所匹配的字符串。通配<br>符从左向右进行匹配。<br>和 %% 类似， #也有一个相对应的贪婪操作符 ##。</p><p><code>##</code>从左向右进行贪婪匹配，并从指定变量中删除匹配结果。</p><p>这里有个能够提取域名不同部分的实用案例。假定 <code>URL=&quot;www.google.com&quot;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL%.*&#125;</span> <span class="comment"># 移除.*所匹配的最右边的内容</span></span><br><span class="line">www.google</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL%%.*&#125;</span> <span class="comment"># 将从右边开始一直匹配到最左边的*.移除（贪婪操作符）</span></span><br><span class="line">www</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL#*.&#125;</span> <span class="comment"># 移除*.所匹配的最左边的内容</span></span><br><span class="line">google.com</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL##*.&#125;</span> <span class="comment"># 将从左边开始一直匹配到最右边的*.移除（贪婪操作符）</span></span><br><span class="line">com</span><br></pre></td></tr></table></figure><h3 id="2-8-批量重命名和移动"><a href="#2-8-批量重命名和移动" class="headerlink" title="2.8 批量重命名和移动"></a>2.8 批量重命名和移动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 *.JPG更名为 *.jpg：</span></span><br><span class="line">$ rename *.JPG *.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件名中的空格替换成字符“_”：</span></span><br><span class="line">$ rename <span class="string">'s/ /_/g'</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换文件名的大小写：</span></span><br><span class="line">$ rename <span class="string">'y/A-Z/a-z/'</span> *</span><br><span class="line">$ rename <span class="string">'y/a-z/A-Z/'</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的 .mp3文件移入给定的目录：</span></span><br><span class="line">$ find path -<span class="built_in">type</span> f -name <span class="string">"*.mp3"</span> -<span class="built_in">exec</span> mv &#123;&#125; target_dir \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有文件名中的空格替换为字符“_”：</span></span><br><span class="line">$ find path -<span class="built_in">type</span> f -<span class="built_in">exec</span> rename <span class="string">'s/ /_/g'</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="3-以文件之名"><a href="#3-以文件之名" class="headerlink" title="3 以文件之名"></a>3 以文件之名</h2><h3 id="3-1-生成任意大小的文件"><a href="#3-1-生成任意大小的文件" class="headerlink" title="3.1 生成任意大小的文件"></a>3.1 生成任意大小的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=junk.data bs=1M count=1</span><br></pre></td></tr></table></figure><p>该命令会创建一个1MB大小的文件junk.data。来看一下命令参数： if代表输入文件（input file），of代表输出文件（output file）， bs代表以字节为单位的块大小（block size）， count代表需要被复制的块数。</p><p>使用dd命令时一定得留意，该命令运行在设备底层。要是你不小心出了岔子，搞不好会把磁盘清空或是损坏数据。所以一定要反复检查dd命令所用的语法是否正确，尤其是参数of=。 </p><table><thead><tr><th>单元大小</th><th>代码</th></tr></thead><tbody><tr><td>字节（1B）</td><td>c</td></tr><tr><td>字（2B）</td><td>w</td></tr><tr><td>块（512B）</td><td>b</td></tr><tr><td>千字节（1024B）</td><td>k</td></tr><tr><td>兆字节（1024KB）</td><td>M</td></tr><tr><td>吉字节（1024MB）</td><td>G</td></tr></tbody></table><p><code>ls -lS</code> 对当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息。  </p><h3 id="3-2-文件权限、所有权和粘滞位"><a href="#3-2-文件权限、所有权和粘滞位" class="headerlink" title="3.2 文件权限、所有权和粘滞位"></a>3.2 文件权限、所有权和粘滞位</h3><p>用命令ls -l可以列出文件的权限： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 slynux slynux 2497 2010-02-28 11:22 bot.py</span><br><span class="line">drwxr-xr-x 2 slynux slynux 4096 2010-05-27 14:31 a.py</span><br><span class="line">-rw-r--r-- 1 slynux slynux 539 2010-02-10 09:11 cl.pl</span><br></pre></td></tr></table></figure><ul><li><code>-</code>—— 普通文件。 </li><li>d —— 目录。 </li><li>c —— 字符设备。 </li><li>b —— 块设备。 </li><li>l —— 符号链接。 </li><li>s —— 套接字。 </li><li>p —— 管道。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改所有权</span></span><br><span class="line">$ chown user.group filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置粘滞位</span></span><br><span class="line"><span class="comment"># 要设置粘滞位，利用chmod将 +t应用于目录：</span></span><br><span class="line">$ chmod a+t directory_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以递归的方式设置权限</span></span><br><span class="line">$ chmod 777 . -R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以递归的方式设置所有权</span></span><br><span class="line">$ chown user.group . -R</span><br></pre></td></tr></table></figure><h3 id="3-3-创建不可修改的文件"><a href="#3-3-创建不可修改的文件" class="headerlink" title="3.3 创建不可修改的文件"></a>3.3 创建不可修改的文件</h3><p>chattr能够将文件设置为不可修改。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用下列命令将一个文件设置为不可修改：</span></span><br><span class="line">$ chattr +i file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要使文件恢复可写状态，移除不可修改属性即可：</span></span><br><span class="line">$ chattr -i file</span><br></pre></td></tr></table></figure><h3 id="3-4-查找符号链接及其指向目标"><a href="#3-4-查找符号链接及其指向目标" class="headerlink" title="3.4 查找符号链接及其指向目标"></a>3.4 查找符号链接及其指向目标</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符号链接：</span></span><br><span class="line">$ ln -s target symbolic_link_name</span><br><span class="line">例如：</span><br><span class="line">$ ln -l -s /var/www/ ~/web</span><br><span class="line"><span class="comment">#这个命令在已登录用户的home目录中创建了一个名为Web的符号链接。该链接指向/var/www。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的命令来验证是否创建链接：</span></span><br><span class="line">$ ls -l web</span><br><span class="line">lrwxrwxrwx 1 slynux slynux 8 2010-06-25 21:34 web -&gt; /var/www</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出当前目录下的符号链接：</span></span><br><span class="line">$ ls -l | grep <span class="string">"^l"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用find打印当前目录以及子目录下的符号链接：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> l -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用readlink打印出符号链接所指向的目标路径：</span></span><br><span class="line">$ readlink web</span><br><span class="line">/var/www</span><br></pre></td></tr></table></figure><h3 id="3-5-列举文件类型统计信息"><a href="#3-5-列举文件类型统计信息" class="headerlink" title="3.5 列举文件类型统计信息"></a>3.5 列举文件类型统计信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用下面的命令打印文件类型信息：</span></span><br><span class="line">$ file filename</span><br><span class="line">$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印不包括文件名在内的文件类型信息：</span></span><br><span class="line">$ file -b filename</span><br><span class="line">ASCII text</span><br></pre></td></tr></table></figure><h3 id="3-6-使用环回文件"><a href="#3-6-使用环回文件" class="headerlink" title="3.6 使用环回文件"></a>3.6 使用环回文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令可以创建一个1GB大小的文件：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=loobackfile.img bs=1G count=1</span><br><span class="line">1024+0 records <span class="keyword">in</span></span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 37.3155 s, 28.8 MB/s</span><br><span class="line"><span class="comment"># 你会发现创建好的文件大小超过了1GB。这是因为硬盘作为块设备，其分配存储空间时是按照块大小的整数倍来进行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用mkfs命令将1GB的文件格式化成ext4文件系统：</span></span><br><span class="line">$ mkfs.ext4 loopbackfile.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的命令检查文件系统：</span></span><br><span class="line">$ file loobackfile.img</span><br><span class="line">loobackfile.img: Linux rev 1.0 ext4 filesystem data,</span><br><span class="line">UUID=c9d56c42-f8e6-4cbd-aeab-369d5056660a (extents) (large files) (huge files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在就可以挂载环回文件了：</span></span><br><span class="line">$ mkdir /mnt/loopback</span><br><span class="line">$ mount -o loop loopbackfile.img /mnt/loopback</span><br><span class="line"><span class="comment"># -o loop用来挂载环回文件系统。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以手动来操作：</span></span><br><span class="line">$ losetup /dev/loop1 loopbackfile.img</span><br><span class="line">$ mount /dev/loop1 /mnt/loopback</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的方法进行卸载（umount）：</span></span><br><span class="line">$ umount mount_point</span><br></pre></td></tr></table></figure><h3 id="3-7-生成-ISO-文件及混合型-ISO"><a href="#3-7-生成-ISO-文件及混合型-ISO" class="headerlink" title="3.7 生成 ISO 文件及混合型 ISO"></a>3.7 生成 ISO 文件及混合型 ISO</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用下面的命令从/dev/cdrom创建一个ISO镜像：</span></span><br><span class="line">$ cat /dev/cdrom &gt; image.iso</span><br><span class="line"></span><br><span class="line"><span class="comment">#尽管可以奏效。但创建ISO镜像最好的方法还是使用dd工具：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/cdrom of=image.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># mkisofs命令用于创建ISO文件系统。</span></span><br><span class="line">$ mkisofs -V <span class="string">"Label"</span> -o image.iso source_dir/</span><br><span class="line"><span class="comment"># 选项 -o指定了ISO文件的路径。 source_dir是作为ISO文件内容来源的目录路径，选项 -V指定了ISO文件的卷标。</span></span><br></pre></td></tr></table></figure><h3 id="3-8-diff命令"><a href="#3-8-diff命令" class="headerlink" title="3.8 diff命令"></a>3.8 diff命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- 　<span class="comment"># 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。</span></span><br><span class="line">-a或--text 　<span class="comment"># diff预设只会逐行比较文本文件。</span></span><br><span class="line">-b或--ignore-space-change 　<span class="comment"># 不检查空格字符的不同。</span></span><br><span class="line">-B或--ignore-blank-lines 　 <span class="comment"># 不检查空白行。</span></span><br><span class="line">-c 　<span class="comment"># 显示全部内文，并标出不同之处。</span></span><br><span class="line">-C或--context <span class="comment"># 与执行"-c-"指令相同。</span></span><br><span class="line">-d或--minimal <span class="comment"># 使用不同的演算法，以较小的单位来做比较。</span></span><br><span class="line">-D或ifdef<span class="comment"># 此参数的输出格式可用于前置处理器巨集。</span></span><br><span class="line">-e或--ed<span class="comment"># 此参数的输出格式可用于ed的script文件。</span></span><br><span class="line">-f或-forward-ed<span class="comment"># 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span></span><br><span class="line">-H或--speed-large-files 　<span class="comment"># 比较大文件时，可加快速度。</span></span><br><span class="line">-l或--ignore-matching-lines 　<span class="comment"># 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</span></span><br><span class="line">-i或--ignore-case 　<span class="comment"># 不检查大小写的不同。</span></span><br><span class="line">-l或--paginate   <span class="comment"># 将结果交由pr程序来分页。</span></span><br><span class="line">-n或--rcs 　  <span class="comment"># 将比较结果以RCS的格式来显示。</span></span><br><span class="line">-N或--new-file 　  <span class="comment"># 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span></span><br><span class="line">-p 　  <span class="comment"># 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span></span><br><span class="line">-P或--unidirectional-new-file 　<span class="comment"># 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span></span><br><span class="line">-q或--brief 　<span class="comment"># 仅显示有无差异，不显示详细的信息。</span></span><br><span class="line">-r或--recursive 　<span class="comment"># 比较子目录中的文件。</span></span><br><span class="line">-s或--report-identical-files 　<span class="comment"># 若没有发现任何差异，仍然显示信息。</span></span><br><span class="line">-S或--starting-file 　<span class="comment"># 在比较目录时，从指定的文件开始比较。</span></span><br><span class="line">-t或--expand-tabs 　<span class="comment"># 在输出时，将tab字符展开。</span></span><br><span class="line">-T或--initial-tab 　<span class="comment"># 在每行前面加上tab字符以便对齐。</span></span><br><span class="line">-u,-U或--unified= 　<span class="comment"># 以合并的方式来显示文件内容的不同。</span></span><br><span class="line">-v或--version 　<span class="comment"># 显示版本信息。</span></span><br><span class="line">-w或--ignore-all-space 　<span class="comment"># 忽略全部的空格字符。</span></span><br><span class="line">-W或--width 　<span class="comment"># 在使用-y参数时，指定栏宽。</span></span><br><span class="line">-x或--exclude 　<span class="comment"># 不比较选项中所指定的文件或目录。</span></span><br><span class="line">-X或--exclude-from 　 <span class="comment"># 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件。</span></span><br><span class="line">-y或--side-by-side 　 <span class="comment"># 以并列的方式显示文件的异同之处。</span></span><br><span class="line">--<span class="built_in">help</span> 　 <span class="comment"># 显示帮助。</span></span><br><span class="line">--left-column 　<span class="comment"># 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</span></span><br><span class="line">--suppress-common-lines 　<span class="comment"># 在使用-y参数时，仅显示不同之处。</span></span><br></pre></td></tr></table></figure><p>生成目录的差异信息 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diff -Naur directory1 directory2</span><br></pre></td></tr></table></figure><ul><li>-N：将所有缺失的文件视为空文件。 </li><li>-a：将所有文件视为文本文件。 </li><li>-u：生成一体化输出。 </li><li>-r：遍历目录下的所有文件。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成patch文件</span></span><br><span class="line">$ diff -u version1.txt version2.txt &gt; version.patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下列命令来进行修补：</span></span><br><span class="line">$ patch -p1 version1.txt &lt; version.patch</span><br><span class="line">patching file version1.txt</span><br><span class="line"><span class="comment"># version1.txt的内容现在和verson2.txt的内容一模一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令可以撤销做出的修改：</span></span><br><span class="line">$ patch -p1 version1.txt &lt; version.patch</span><br><span class="line">patching file version1.txt</span><br><span class="line">Reversed (or previously applied) patch detected! Assume -R? [n] y</span><br><span class="line"><span class="comment"># 修改被撤销</span></span><br></pre></td></tr></table></figure><h3 id="3-9-more、less、head与tail命令"><a href="#3-9-more、less、head与tail命令" class="headerlink" title="3.9 more、less、head与tail命令"></a>3.9 more、less、head与tail命令</h3><h4 id="3-9-1-more文件内容输出查看工具"><a href="#3-9-1-more文件内容输出查看工具" class="headerlink" title="3.9.1 more文件内容输出查看工具"></a>3.9.1 more文件内容输出查看工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ more [参数选项] [文件] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数如下： </span></span><br><span class="line">+num   <span class="comment"># 从第num行开始显示； </span></span><br><span class="line">-num   <span class="comment"># 定义屏幕大小，为num行； </span></span><br><span class="line">+/pattern   <span class="comment"># 从pattern 前两行开始显示； </span></span><br><span class="line">-c   <span class="comment"># 从顶部清屏然后显示； </span></span><br><span class="line">-d   <span class="comment"># 提示Press space to continue, 'q' to quit.（按空格键继续，按q键退出），禁用响铃功能； </span></span><br><span class="line">-l    <span class="comment"># 忽略Ctrl+l （换页）字符； </span></span><br><span class="line">-p    <span class="comment"># 通过清除窗口而不是滚屏来对文件进行换页。和-c参数有点相似； </span></span><br><span class="line">-s    <span class="comment"># 把连续的多个空行显示为一行； </span></span><br><span class="line">-u    <span class="comment"># 把文件内容中的下划线去掉退出more的动作指令是q</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示提示，并从终端或控制台顶部显示；</span></span><br><span class="line">$ more -dc /etc/profile </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从profile的第4行开始显示；</span></span><br><span class="line">$ more +4 /etc/profile     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每屏显示4行；</span></span><br><span class="line">$ more -4 /etc/profile    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从profile中的第一个MAIL单词的前两行开始显示；</span></span><br><span class="line">$ more +/MAIL /etc/profile</span><br></pre></td></tr></table></figure><p>more 的动作指令：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter       # 向下n行，需要定义，默认为<span class="number">1</span>行； </span><br><span class="line">Ctrl+f    # 向下滚动一屏； </span><br><span class="line">空格键 # 向下滚动一屏； </span><br><span class="line">Ctrl+b  # 返回上一屏； </span><br><span class="line">=         # 输出当前行的行号； </span><br><span class="line">:f      # 输出文件名和当前行的行号； </span><br><span class="line">v      # 调用vi编辑器； </span><br><span class="line">! 命令          # 调用Shell，并执行命令； </span><br><span class="line">q     # 退出more当我们查看某一文件时，想调用vi来编辑它，不要忘记了v动作指令，这是比较方便的；</span><br></pre></td></tr></table></figure><p>其它命令通过管道和more结合的运用例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /etc |more</span><br></pre></td></tr></table></figure><h4 id="3-9-2-less查看文件内容工具"><a href="#3-9-2-less查看文件内容工具" class="headerlink" title="3.9.2 less查看文件内容工具"></a>3.9.2 less查看文件内容工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-c <span class="comment"># 从顶部（从上到下）刷新屏幕，并显示文件内容。而不是通过底部滚动完成刷新； </span></span><br><span class="line">-f <span class="comment"># 强制打开文件，二进制文件显示时，不提示警告； </span></span><br><span class="line">-i <span class="comment"># 搜索时忽略大小写；除非搜索串中包含大写字母； </span></span><br><span class="line">-I <span class="comment"># 搜索时忽略大小写，除非搜索串中包含小写字母； </span></span><br><span class="line">-m <span class="comment"># 显示读取文件的百分比； </span></span><br><span class="line">-M <span class="comment"># 显法读取文件的百分比、行号及总行数； </span></span><br><span class="line">-N <span class="comment"># 在每行前输出行号； </span></span><br><span class="line">-p <span class="comment"># pattern 搜索pattern；比如在/etc/profile搜索单词MAIL，就用 less -p MAIL /etc/profile </span></span><br><span class="line">-s <span class="comment"># 把连续多个空白行作为一个空白行显示； </span></span><br><span class="line">-Q <span class="comment"># 在终端下不响铃；</span></span><br></pre></td></tr></table></figure><p>less的动作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">回车键 <span class="comment"># 向下移动一行； </span></span><br><span class="line">y   <span class="comment"># 向上移动一行； </span></span><br><span class="line">空格键 <span class="comment"># 向下滚动一屏； </span></span><br><span class="line">b   <span class="comment"># 向上滚动一屏； </span></span><br><span class="line">d   <span class="comment"># 向下滚动半屏； </span></span><br><span class="line">h   <span class="comment"># less的帮助； </span></span><br><span class="line">u   <span class="comment"># 向上洋动半屏； </span></span><br><span class="line">w   <span class="comment"># 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示； </span></span><br><span class="line">g   <span class="comment"># 跳到第一行； </span></span><br><span class="line">G   <span class="comment"># 跳到最后一行； </span></span><br><span class="line">p   <span class="comment"># n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示； </span></span><br><span class="line">/pattern  <span class="comment"># 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词； </span></span><br><span class="line">v   <span class="comment"># 调用vi编辑器； </span></span><br><span class="line">q   <span class="comment"># 退出less </span></span><br><span class="line">!<span class="built_in">command</span>  <span class="comment"># 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件；</span></span><br></pre></td></tr></table></figure><h4 id="3-9-3-head"><a href="#3-9-3-head" class="headerlink" title="3.9.3 head"></a>3.9.3 head</h4><p>head 是显示一个文件的内容的前多少行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ head -n 10 /etc/profile</span><br></pre></td></tr></table></figure><h4 id="3-9-4-tail"><a href="#3-9-4-tail" class="headerlink" title="3.9.4 tail"></a>3.9.4 tail</h4><p>tail 是显示一个文件的内容的最后多少行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -n 5 /etc/profile</span><br></pre></td></tr></table></figure><h3 id="3-10-getopts-参数解析"><a href="#3-10-getopts-参数解析" class="headerlink" title="3.10 getopts 参数解析"></a>3.10 getopts 参数解析</h3><h4 id="3-10-1-getopts（shell内置命令）"><a href="#3-10-1-getopts（shell内置命令）" class="headerlink" title="3.10.1 getopts（shell内置命令）"></a>3.10.1 getopts（shell内置命令）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> getopt</span><br><span class="line">getopt 是 /usr/bin/getopt</span><br><span class="line">$ <span class="built_in">type</span> <span class="built_in">getopts</span> </span><br><span class="line"><span class="built_in">getopts</span> 是 shell 内建</span><br></pre></td></tr></table></figure><p>getopts不能直接处理长的选项（如：–prefix=/home等）</p><p>关于getopts的使用方法，可以man bash  搜索getopts。</p><p>getopts有两个参数，第一个参数是一个字符串，包括字符和“：”，每一个字符都是一个有效的选项，如果字符后面带有“：”，表示这个字符有自己的参数。getopts从命令中获取这些参数，并且删去了“-”，并将其赋值在第二个参数中，如果带有自己参数，这个参数赋值在 <code>$OPTARG</code>中。提供getopts的shell内置了 <code>$OPTARG</code> 这个变变，getopts修改了这个变量。</p><p>这里变量 <code>$OPTARG</code> 存储相应选项的参数，而 <code>$OPTIND</code> 总是存储原始 <code>$*</code> 中下一个要处理的元素位置。<code>while getopts &quot;:a:bc&quot; opt</code>   #第一个冒号表示忽略错误；字符后面的冒号表示该选项必须有自己的参数</p><p>getopts后面的字符串就是可以使用的选项列表，每个字母代表一个选项，后面带:的意味着选项除了定义本身之外，还会带上一个参数作为选项的值，比如d:在实际的使用中就会对应-d 30，选项的值就是30；getopts字符串中没有跟随:的是开关型选项，不需要再指定值，相当于true/false，只要带了这个参数就是true。如果命令行中包含了没有在getopts列表中的选项，会有警告信息，如果在整个getopts字符串前面也加上个:，就能消除警告信息了。</p><p>两个特殊变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$OPTIND</span>     <span class="comment"># 特殊变量，option index，会逐个递增, 初始值为1</span></span><br><span class="line"><span class="variable">$OPTARG</span>     <span class="comment"># 特殊变量，option argument，不同情况下有不同的值</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">echo $*</span><br><span class="line"><span class="keyword">while</span> getopts <span class="string">":a:bc"</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> $opt <span class="keyword">in</span></span><br><span class="line">                a ) echo $OPTARG</span><br><span class="line">                    echo $OPTIND;;</span><br><span class="line">                b ) echo <span class="string">"b $OPTIND"</span>;;</span><br><span class="line">                c ) echo <span class="string">"c $OPTIND"</span>;;</span><br><span class="line">                ? ) echo <span class="string">"error"</span></span><br><span class="line">                    exit <span class="number">1</span>;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo $OPTIND</span><br><span class="line">shift $(($OPTIND - <span class="number">1</span>))</span><br><span class="line">#通过shift $(($OPTIND - <span class="number">1</span>))的处理，$*中就只保留了除去选项内容的参数，可以在其后进行正常的shell编程处理了。</span><br><span class="line">echo $<span class="number">0</span></span><br><span class="line">echo $*</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./getopts.sh -a 11 -b -c</span><br><span class="line">-a 11 -b -c</span><br><span class="line">11</span><br><span class="line">3</span><br><span class="line">b 4</span><br><span class="line">c 5</span><br><span class="line">5</span><br><span class="line">./getopts.sh</span><br></pre></td></tr></table></figure><h4 id="3-10-2-getopt（一个外部工具）"><a href="#3-10-2-getopt（一个外部工具）" class="headerlink" title="3.10.2 getopt（一个外部工具）"></a>3.10.2 getopt（一个外部工具）</h4><p>具体用用法可以 man getopt</p><p><code>-o</code> 表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，如 <code>-carg</code> 而不能是 <code>-c arg</code>。</p><p><code>--long</code> 表示长选项</p><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"></span><br><span class="line"># A small example program <span class="keyword">for</span> using the <span class="keyword">new</span> getopt(<span class="number">1</span>) program.</span><br><span class="line"># This program will only work <span class="keyword">with</span> bash(<span class="number">1</span>)</span><br><span class="line"># An similar program using the tcsh(<span class="number">1</span>) script. language can be found</span><br><span class="line"># <span class="keyword">as</span> parse.tcsh</span><br><span class="line"></span><br><span class="line"># Example input and output (<span class="keyword">from</span> the bash prompt):</span><br><span class="line"># ./parse.bash -a par1 <span class="string">'another arg'</span> --c-long <span class="string">'wow!*\?'</span> -cmore -b <span class="string">" very long "</span></span><br><span class="line"># Option a</span><br><span class="line"># Option c, no argument</span><br><span class="line"># Option c, argument <span class="string">`more'</span></span><br><span class="line"><span class="string"># Option b, argument `</span> very long <span class="string">'</span></span><br><span class="line"><span class="string"># Remaining arguments:</span></span><br><span class="line"><span class="string"># --&gt; `par1'</span></span><br><span class="line"># --&gt; <span class="string">`another arg'</span></span><br><span class="line"><span class="string"># --&gt; `</span>wow!*\?<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note that we use `"$@"'</span> to <span class="keyword">let</span> each command-line parameter expand to a</span><br><span class="line"># separate word. The quotes around <span class="string">`$@' are essential!</span></span><br><span class="line"><span class="string"># We need TEMP as the `</span><span class="built_in">eval</span> <span class="keyword">set</span> --<span class="string">' would nuke the return value of getopt.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项</span></span><br><span class="line"><span class="string">#如-carg 而不能是-c arg</span></span><br><span class="line"><span class="string">#--long表示长选项</span></span><br><span class="line"><span class="string">#"$@"在上面解释过</span></span><br><span class="line"><span class="string"># -n:出错时的信息</span></span><br><span class="line"><span class="string"># -- ：举一个例子比较好理解：</span></span><br><span class="line"><span class="string">#我们要创建一个名字为 "-f"的目录你会怎么办？</span></span><br><span class="line"><span class="string"># mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用</span></span><br><span class="line"><span class="string"># mkdir -- -f 这样-f就不会被作为选项。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \</span></span><br><span class="line"><span class="string">     -n '</span>example.bash<span class="string">' -- "$@"`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if [ $? != 0 ] ; then echo "Terminating..." &gt;&amp;2 ; exit 1 ; fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note the quotes around `$TEMP'</span>: they are essential!</span><br><span class="line">#<span class="keyword">set</span> 会重新排列参数的顺序，也就是改变$<span class="number">1</span>,$<span class="number">2.</span>..$n的值，这些值在getopt中重新排列过了</span><br><span class="line"><span class="built_in">eval</span> <span class="keyword">set</span> -- <span class="string">"$TEMP"</span></span><br><span class="line"></span><br><span class="line">#经过getopt的处理，下面处理具体选项。</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"$1"</span> <span class="keyword">in</span></span><br><span class="line">                -a|--a-long) echo <span class="string">"Option a"</span> ; shift ;;</span><br><span class="line">                -b|--b-long) echo <span class="string">"Option b, argument \`$2'"</span> ; shift <span class="number">2</span> ;;</span><br><span class="line">                -c|--c-long)</span><br><span class="line">                        # c has an optional argument. As we are <span class="keyword">in</span> quoted mode,</span><br><span class="line">                        # an empty parameter will be generated <span class="keyword">if</span> its optional</span><br><span class="line">                        # argument is not found.</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"$2"</span> <span class="keyword">in</span></span><br><span class="line">                                <span class="string">""</span>) echo <span class="string">"Option c, no argument"</span>; shift <span class="number">2</span> ;;</span><br><span class="line">                                *)  echo <span class="string">"Option c, argument \`$2'"</span> ; shift <span class="number">2</span> ;;</span><br><span class="line">                        esac ;;</span><br><span class="line">                --) shift ; <span class="keyword">break</span> ;;</span><br><span class="line">                *) echo <span class="string">"Internal error!"</span> ; exit <span class="number">1</span> ;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo <span class="string">"Remaining arguments:"</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">do</span></span><br><span class="line">   echo <span class="string">'--&gt; '</span><span class="string">"\`$arg'"</span> ;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./getopt.sh --b-long abc -a -c33 remain</span><br><span class="line">Option b, argument `abc<span class="string">'</span></span><br><span class="line"><span class="string">Option a</span></span><br><span class="line"><span class="string">Option c, argument `33'</span></span><br><span class="line">Remaining arguments:</span><br><span class="line">--&gt; `remain<span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="3-11-只列出目录的各种方法"><a href="#3-11-只列出目录的各种方法" class="headerlink" title="3.11 只列出目录的各种方法"></a>3.11 只列出目录的各种方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ls –d：</span></span><br><span class="line">$ ls -d */</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用grep结合ls –F：</span></span><br><span class="line">$ ls -F | grep <span class="string">"/$"</span></span><br><span class="line"><span class="comment"># 当使用-F时，所有的输出项都会添加上一个代表文件类型的字符，如@、 *、 |等。目录对应的是 / 字符。我们用grep只过滤那些以 /$ 作为行尾标记的输出项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用grep结合ls –l：</span></span><br><span class="line">$ ls -l | grep <span class="string">"^d"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用find：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> d -maxdepth 1 -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><h3 id="3-12-使用pushd和popd进行快速定位"><a href="#3-12-使用pushd和popd进行快速定位" class="headerlink" title="3.12 使用pushd和popd进行快速定位"></a>3.12 使用pushd和popd进行快速定位</h3><p>使用pushd和popd时，可以无视cd命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压入并切换路径：</span></span><br><span class="line">$ <span class="built_in">pushd</span> /var/www</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再压入下一个目录路径：</span></span><br><span class="line">$ <span class="built_in">pushd</span> /usr/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的命令查看栈内容：</span></span><br><span class="line">$ <span class="built_in">dirs</span></span><br><span class="line">/usr/src /var/www ~ /usr/share /etc</span><br><span class="line">0 1   2 3 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当你想切换到列表中任意一个路径时，将每条路径从0到n进行编号，然后使用你希望切换到的路径编号，例如：</span></span><br><span class="line">$ <span class="built_in">pushd</span> +3</span><br><span class="line"><span class="comment"># 这条命令会将栈进行翻转并切换到目录 /use/share。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除最后添加的路径并把当前目录更改为上一级目录，可以使用以下命令：</span></span><br><span class="line">$ <span class="built_in">popd</span></span><br><span class="line"><span class="comment"># 用popd +num可以从列表中移除特定的路径。num是从左到右，从0到n开始计数的。</span></span><br></pre></td></tr></table></figure><h3 id="3-13-tree打印目录树"><a href="#3-13-tree打印目录树" class="headerlink" title="3.13 tree打印目录树"></a>3.13 tree打印目录树</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重点标记出匹配某种样式的文件：</span></span><br><span class="line">$ tree PATH -P <span class="string">"*.sh"</span> <span class="comment"># 用一个目录路径代替PATH</span></span><br><span class="line">|-- home</span><br><span class="line">| |-- packtpub</span><br><span class="line">| | `-- automate.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重点标记出除符合某种样式之外的那些文件：</span></span><br><span class="line">$ tree path -I PATTERN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -h选项同时打印出文件和目录的大小：</span></span><br><span class="line">$ tree -h</span><br></pre></td></tr></table></figure><h2 id="4-让文件飞"><a href="#4-让文件飞" class="headerlink" title="4 让文件飞"></a>4 让文件飞</h2><h3 id="4-1-正则表达式"><a href="#4-1-正则表达式" class="headerlink" title="4.1 正则表达式"></a>4.1 正则表达式</h3><table><thead><tr><th>正则表达式</th><th>描述</th><th align="left">示例</th></tr></thead><tbody><tr><td>^</td><td>行起始标记</td><td align="left">^tux 匹配以tux起始的行</td></tr><tr><td>$</td><td>行尾标记</td><td align="left">tux$ 匹配以tux结尾的行</td></tr><tr><td>.</td><td>匹配任意一个字符</td><td align="left">Hack.匹配Hackl和Hacki，它只能匹配单个字符</td></tr><tr><td>[ ]</td><td>匹配包含在 [字符] 之中的任意一个字符</td><td align="left">coo[kl] 匹配cook或cool</td></tr><tr><td>[ ^ ]</td><td>匹配除 <code>[^字符]</code> 之外的任意一个字符</td><td align="left"><code>9[^01]</code>匹配92、 93，但是不匹配91或90</td></tr><tr><td>[ - ]</td><td>匹配 [ ] 中指定范围内的任意一个字符</td><td align="left">[1-5] 匹配从1～5的任意一个数字</td></tr><tr><td>?</td><td>匹配之前的项1次或0次</td><td align="left">colou?r 匹配color或colour，但是不能匹配colouur</td></tr><tr><td>+</td><td>匹配之前的项1次或多次</td><td align="left">Rollno-9+ 匹配Rollno-99、Rollno-9，但是不能匹配Rollno-</td></tr><tr><td>*</td><td>匹配之前的项0次或多次</td><td align="left">co*l 匹配cl、 col、 coool等</td></tr><tr><td>( )</td><td>创建一个用于匹配的子串</td><td align="left">ma(tri)?x 匹配max或maxtrix</td></tr><tr><td>{n}</td><td>匹配之前的项n次</td><td align="left">[0-9]{3} 匹 配 任 意 一 个 三 位 数 ， [0-9]{3} 可 以 扩 展 为<code>[0-9][0-9][0-9]</code></td></tr><tr><td>{n, }</td><td>之前的项至少需要匹配n次</td><td align="left">[0-9]{2,} 匹配任意一个两位或更多位的数字</td></tr><tr><td>{n, m}</td><td>指定之前的项所必需匹配的最小次数和最大次数</td><td align="left">[0-9]{2,5} 匹配从两位数到五位数之间的任意一个数字</td></tr><tr><td>|</td><td>交替——匹配 | 两边的任意一项</td><td align="left">Oct  (1st | 2nd) 匹配Oct 1st或Oct 2nd</td></tr><tr><td>\</td><td>转义符可以将上面介绍的特殊字符进行转义</td><td align="left"><code>a\.b</code> 匹配a.b，但不能匹配ajb。通过在 . 之间加上前缀 \ ，从而忽略了 . 的特殊意义</td></tr></tbody></table><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>所有的字母和数字</td></tr><tr><td>[:alpha:]</td><td>所有字母</td></tr><tr><td>[:blank:]</td><td>水平制表符，空白等</td></tr><tr><td>[:cntrl:]</td><td>所有控制字符</td></tr><tr><td>[:digit:]</td><td>所有的数字</td></tr><tr><td><code>[:graph:]</code></td><td>所有可打印字符，不包括空格</td></tr><tr><td>[:lower:]</td><td>所有的小写字符</td></tr><tr><td>[:print:]</td><td>所有可打印字符，包括空格</td></tr><tr><td>[:punct:]</td><td>所有的标点字符</td></tr><tr><td>[:space:]</td><td>所有的横向或纵向的空白</td></tr><tr><td>[:upper:]</td><td>所有大写字母</td></tr></tbody></table><h3 id="4-2-grep命令"><a href="#4-2-grep命令" class="headerlink" title="4.2 grep命令"></a>4.2 grep命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-a<span class="comment"># 不要忽略二进制的数据。</span></span><br><span class="line">-A&lt;显示列数&gt;  <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之后的内容。</span></span><br><span class="line">-b<span class="comment"># 在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。</span></span><br><span class="line">-B&lt;显示列数&gt; <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前的内容。</span></span><br><span class="line">-c<span class="comment"># 计算符合范本样式的列数。</span></span><br><span class="line">-C&lt;显示列数&gt;或-&lt;显示列数&gt;<span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span></span><br><span class="line">-d&lt;进行动作&gt; <span class="comment"># 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</span></span><br><span class="line">-e&lt;范本样式&gt; <span class="comment"># 指定字符串做为查找文件内容的范本样式。</span></span><br><span class="line">-E<span class="comment"># 将范本样式为延伸的普通表示法来使用。</span></span><br><span class="line">-f&lt;范本文件&gt; <span class="comment"># 指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。</span></span><br><span class="line">-F<span class="comment"># 将范本样式视为固定字符串的列表。</span></span><br><span class="line">-G<span class="comment"># 将范本样式视为普通的表示法来使用。</span></span><br><span class="line">-h<span class="comment"># 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span></span><br><span class="line">-H<span class="comment"># 在显示符合范本样式的那一列之前，表示该列所属的文件名称。</span></span><br><span class="line">-i<span class="comment"># 忽略字符大小写的差别。</span></span><br><span class="line">-l<span class="comment"># 列出文件内容符合指定的范本样式的文件名称。</span></span><br><span class="line">-L<span class="comment"># 列出文件内容不符合指定的范本样式的文件名称。</span></span><br><span class="line">-n<span class="comment"># 在显示符合范本样式的那一列之前，标示出该列的列数编号。</span></span><br><span class="line">-q<span class="comment"># 不显示任何信息。</span></span><br><span class="line">-r<span class="comment"># 此参数的效果和指定“-d recurse”参数相同。</span></span><br><span class="line">-s<span class="comment"># 不显示错误信息。</span></span><br><span class="line">-v<span class="comment"># 反转查找。</span></span><br><span class="line">-V<span class="comment"># 显示版本信息。</span></span><br><span class="line">-w<span class="comment"># 只显示全字符合的列。</span></span><br><span class="line">-x<span class="comment"># 只显示全列符合的列。</span></span><br><span class="line">-o <span class="comment"># 只输出文件中匹配到的部分。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个grep命令也可以对多个文件进行搜索：</span></span><br><span class="line">$ grep <span class="string">"match_text"</span> file1 file2 file3 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># grep -E选项——这意味着使用扩展（extended）正则表达式：</span></span><br><span class="line">$ grep -E <span class="string">"[a-z]+"</span> filename</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ egrep <span class="string">"[a-z]+"</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只输出文件中匹配到的文本部分，可以使用选项 -o：</span></span><br><span class="line">$ <span class="built_in">echo</span> this is a line. | egrep -o <span class="string">"[a-z]+\."</span></span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印除包含match_pattern行之外的所有行，选项-v可以将匹配结果进行反转（invert）。可使用：</span></span><br><span class="line">$ grep -v match_pattern file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件或文本中包含匹配字符串的行数：</span></span><br><span class="line">$ grep -c <span class="string">"text"</span> filename</span><br><span class="line">10</span><br><span class="line"><span class="comment"># 需要注意的是-c只是统计匹配行的数量，并不是匹配的次数。。例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1 2 3 4\nhello\n5 6"</span> | egrep -c <span class="string">"[0-9]"</span></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要文件中统计匹配项的数量，可以使用下面的技巧：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1 2 3 4\nhello\n5 6"</span> | egrep -o <span class="string">"[0-9]"</span> | wc -l</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模式匹配所位于的字符或字节偏移：</span></span><br><span class="line">$ <span class="built_in">echo</span> gnu is not unix | grep -b -o <span class="string">"not"</span></span><br><span class="line">7:not</span><br><span class="line"><span class="comment"># 选项 -b总是和 -o配合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索多个文件并找出匹配文本位于哪一个文件中：</span></span><br><span class="line">$ grep -l linux sample1.txt sample2.txt</span><br><span class="line">sample1.txt</span><br><span class="line">sample2.txt</span><br><span class="line"><span class="comment"># 和-l相反的选项是-L，它会返回一个不匹配的文件列表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep的选项-R和-r功能一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略样式中的大小写</span></span><br><span class="line">$ <span class="built_in">echo</span> hello world | grep -i <span class="string">"HELLO"</span></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># grep匹配多个样式</span></span><br><span class="line">$ <span class="built_in">echo</span> this is a line of text | grep -e <span class="string">"this"</span> -e <span class="string">"line"</span> -o</span><br><span class="line">this</span><br><span class="line">line</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在grep搜索中指定或排除文件</span></span><br><span class="line">$ grep <span class="string">"main()"</span> . -r --include *.&#123;c,cpp&#125; <span class="comment"># 目录中递归搜索所有的 .c和 .cpp文件</span></span><br><span class="line"><span class="comment"># 如果需要排除目录，可以使用 --exclude-dir选项。</span></span><br><span class="line"><span class="comment"># 如果需要从文件中读取所需排除的文件列表，使用--exclude-from FILE。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用0值字节作为后缀的grep与xargs，为了指明输入的文件名是以0值字节（\0）作为终止符，需要在xargs中使用-0。</span></span><br><span class="line"><span class="comment"># grep使用-Z选项输出以0值字节作为终结符的文件名（\0）。</span></span><br><span class="line">$ grep <span class="string">"test"</span> file* -lZ | xargs -0 rm</span><br><span class="line"><span class="comment"># -Z通常和 -l结合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep的静默输出</span></span><br><span class="line"><span class="comment"># grep的静默选项（-q）来实现。在静默模式中， grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之后的3行，使用 -A选项：</span></span><br><span class="line">$ seq 10 | grep 5 -A 3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之前的3行，使用 -B选项：</span></span><br><span class="line">$ seq 10 | grep 5 -B 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之前以及之后的3行，使用-C选项：</span></span><br><span class="line">$ seq 10 | grep 5 -C 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有多个匹配，那么使用--作为各部分之间的定界符：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"a\nb\nc\na\nb\nc"</span> | grep a -A 1</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h3 id="4-3-cut-按列切分文件"><a href="#4-3-cut-按列切分文件" class="headerlink" title="4.3 cut 按列切分文件"></a>4.3 cut 按列切分文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示第2列和第3列：</span></span><br><span class="line">$ cut -f 2,3 filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>记法</th><th>范围</th></tr></thead><tbody><tr><td>N -</td><td>从第N个字节，字符或字段到行尾</td></tr><tr><td>N - M</td><td>从第N个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td></tr><tr><td>- M</td><td>第1个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td></tr></tbody></table><p>结合下列选项将字段指定为某个范围内的字节或字符 ：</p><ul><li>-b ：表示字节</li><li>-c ：表示字符</li><li>-f ：用于定义字段</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat range_fields.txt</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印第1个到第5个字符：</span></span><br><span class="line">$ cut -c1-5 range_fields.txt</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line"><span class="comment"># 打印前2个字符：</span></span><br><span class="line">$ cut range_fields.txt -c -2</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br></pre></td></tr></table></figure><h3 id="4-4-sed-进行文本替换"><a href="#4-4-sed-进行文本替换" class="headerlink" title="4.4 sed 进行文本替换"></a>4.4 sed 进行文本替换</h3><p>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-e &lt;script&gt;<span class="comment"># 以选项中指定的script来处理输入的文本文件</span></span><br><span class="line">-f &lt;script&gt;<span class="comment"># 以选项中指定的script文件来处理输入的文本文件</span></span><br><span class="line">-h<span class="comment"># 显示帮助</span></span><br><span class="line">-n<span class="comment"># 仅显示script处理后的结果</span></span><br><span class="line">-V<span class="comment"># 显示版本信息</span></span><br></pre></td></tr></table></figure><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a\ <span class="comment"># 在当前行下面插入文本。</span></span><br><span class="line">i\ <span class="comment"># 在当前行上面插入文本。</span></span><br><span class="line">c\ <span class="comment"># 把选定的行改为新的文本。 </span></span><br><span class="line">d <span class="comment"># 删除，删除选择的行。 </span></span><br><span class="line">D <span class="comment"># 删除模板块的第一行。</span></span><br><span class="line">s <span class="comment"># 替换指定字符 h 拷贝模板块的内容到内存中的缓冲区。 </span></span><br><span class="line">H <span class="comment"># 追加模板块的内容到内存中的缓冲区。 </span></span><br><span class="line">g <span class="comment"># 获得内存缓冲区的内容，并替代当前模板块中的文本。 </span></span><br><span class="line">G <span class="comment"># 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 </span></span><br><span class="line">l <span class="comment"># 列表不能打印字符的清单。 </span></span><br><span class="line">n <span class="comment"># 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 </span></span><br><span class="line">N <span class="comment"># 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 </span></span><br><span class="line">p <span class="comment"># 打印模板块的行。 P(大写) 打印模板块的第一行。 </span></span><br><span class="line">q <span class="comment"># 退出Sed。 </span></span><br><span class="line">b lable <span class="comment"># 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 </span></span><br><span class="line">r file <span class="comment"># 从file中读行。 </span></span><br><span class="line">t label <span class="comment"># if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 </span></span><br><span class="line">T label <span class="comment"># 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span></span><br><span class="line">w file <span class="comment"># 写并追加模板块到file末尾。 </span></span><br><span class="line">W file <span class="comment"># 写并追加模板块的第一行到file末尾。 </span></span><br><span class="line">! <span class="comment"># 表示后面的命令对所有没有被选定的行发生作用。 </span></span><br><span class="line">= <span class="comment"># 打印当前行号码。 </span></span><br><span class="line"><span class="comment"># 把注释扩展到下一个换行符以前。</span></span><br></pre></td></tr></table></figure><p>sed 替换标记：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g <span class="comment"># 表示行内全面替换。</span></span><br><span class="line">p <span class="comment"># 表示打印行。 </span></span><br><span class="line">w <span class="comment"># 表示把行写入一个文件。 </span></span><br><span class="line">x <span class="comment"># 表示互换模板块中的文本和缓冲区中的文本。 </span></span><br><span class="line">y <span class="comment"># 表示把一个字符翻译为另外的字符（但是不用于正则表达式） </span></span><br><span class="line">\1 <span class="comment"># 子串匹配标记 </span></span><br><span class="line">&amp; <span class="comment"># 已匹配字符串标记</span></span><br></pre></td></tr></table></figure><p>sed 元字符集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">^ <span class="comment"># 匹配行开始，如：/^sed/匹配所有以sed开头的行。</span></span><br><span class="line">$ <span class="comment"># 匹配行结束，如：/sed$/匹配所有以sed结尾的行。 </span></span><br><span class="line">. <span class="comment"># 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 </span></span><br><span class="line">* <span class="comment"># 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 </span></span><br><span class="line">[] <span class="comment"># 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 </span></span><br><span class="line">[^] <span class="comment"># 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/ 匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</span></span><br><span class="line">\(..\) <span class="comment"># 匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。 </span></span><br><span class="line">&amp; <span class="comment"># 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 </span></span><br><span class="line">\&lt;  <span class="comment"># 匹配单词的开始，如:/\&lt;love/匹配包含以开头的单词的行。</span></span><br><span class="line">\&gt;<span class="comment"># 匹配单词的结束，如:/love\&gt;/匹配包含以love结尾的单词的行。</span></span><br><span class="line">x\&#123;m\&#125; <span class="comment"># 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。 </span></span><br><span class="line">x\&#123;m,\&#125; <span class="comment"># 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。 </span></span><br><span class="line">x\&#123;m,n\&#125; <span class="comment"># 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed可以替换给定文本中的字符串。</span></span><br><span class="line">$ sed <span class="string">'s/pattern/replace_string/'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要在替换的同时保存更改，可以使用-i选项</span></span><br><span class="line">$ sed -i <span class="string">'s/text/replace/'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后缀/g意味着sed会替换每一处匹配。但是有时候我们只需要从第n处匹配开始替换。对此，可以使用/Ng选项。</span></span><br><span class="line">$ sed <span class="string">'s/pattern/replace_string/g'</span> file</span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/2g'</span></span><br><span class="line">thisTHISTHISTHIS</span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/3g'</span></span><br><span class="line">thisthisTHISTHIS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符/在sed中被作为定界符使用。我们可以像下面一样使用任意的定界符：</span></span><br><span class="line">$ sed <span class="string">'s:text:replace:g'</span></span><br><span class="line">$ sed <span class="string">'s|text|replace|g'</span></span><br><span class="line"><span class="comment"># 当定界符出现在样式内部时，我们必须用前缀\对它进行转义：</span></span><br><span class="line">$ sed <span class="string">'s|te\|xt|replace|g'</span></span><br><span class="line"><span class="comment"># \|是一个出现在样式内部并经过转义的定界符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除空白行</span></span><br><span class="line">$ sed <span class="string">'/^$/d'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已匹配字符串标记（&amp;）在sed中，我们可以用 &amp;标记匹配样式的字符串，这样就能够在替换字符串时使用已匹配的内容。</span></span><br><span class="line">$ <span class="built_in">echo</span> this is an example | sed <span class="string">'s/\w\+/[&amp;]/g'</span></span><br><span class="line">[this] [is] [an] [example]</span><br><span class="line"><span class="comment"># 正则表达式 \w\+ 匹配每一个单词，然后我们用[&amp;]替换它。 &amp; 对应于之前所匹配到的单词。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合多个表达式</span></span><br><span class="line">$ sed <span class="string">'expression'</span> | sed <span class="string">'expression'</span></span><br><span class="line"><span class="comment"># 它等价于</span></span><br><span class="line">$ sed <span class="string">'expression; expression'</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ sed -e <span class="string">'expression'</span> -e expression<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 引用。sed表达式通常用单引号来引用。双引号会通过对表达式求值来对其进行扩展。</span></span><br><span class="line"><span class="string">$ text=hello</span></span><br><span class="line"><span class="string">$ echo hello world | sed "s/$text/HELLO/"</span></span><br><span class="line"><span class="string">HELLO world</span></span><br></pre></td></tr></table></figure><h3 id="4-5-awk-进行高级文本处理"><a href="#4-5-awk-进行高级文本处理" class="headerlink" title="4.5 awk 进行高级文本处理"></a>4.5 awk 进行高级文本处理</h3><h4 id="4-5-1-awk-常用命令选项"><a href="#4-5-1-awk-常用命令选项" class="headerlink" title="4.5.1 awk 常用命令选项"></a>4.5.1 awk 常用命令选项</h4><ul><li><code>-F fs</code>        fs指定输入分隔符，fs可以是字符串或正则表达式，如<code>-F:</code><ul><li><code>-v var=value</code>   赋值一个用户定义变量，将外部变量传递给awk </li></ul></li><li><code>-f scripfile</code>      从脚本文件中读取awk命令 </li><li><code>-m[fr] val</code>          对val值设置内在限制，<code>-mf</code> 选项限制分配给val的最大块数目；<code>-mr</code> 选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li></ul><h4 id="4-5-2-awk-脚本基本结构"><a href="#4-5-2-awk-脚本基本结构" class="headerlink" title="4.5.2 awk 脚本基本结构"></a>4.5.2 awk 脚本基本结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; print "start" &#125; pattern&#123; commands &#125; END&#123; print "end" &#125;'</span> file</span><br><span class="line"><span class="comment"># 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;'</span> filename </span><br><span class="line">$ awk <span class="string">"BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;"</span> filename</span><br></pre></td></tr></table></figure><h4 id="4-5-3-awk-的工作原理"><a href="#4-5-3-awk-的工作原理" class="headerlink" title="4.5.3 awk 的工作原理"></a>4.5.3 awk 的工作原理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;'</span></span><br></pre></td></tr></table></figure><ul><li>第一步：执行 <code>BEGIN{ commands }</code> 语句块中的语句</li><li>第二步：从文件或标准输入(stdin)读取一行，然后执行 <code>pattern{ commands }</code> 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕</li><li>第三步：当读至输入流末尾时，执行 <code>END{ commands }</code> 语句块</li></ul><h4 id="4-5-4-awk-内置变量（预定义变量）"><a href="#4-5-4-awk-内置变量（预定义变量）" class="headerlink" title="4.5.4 awk 内置变量（预定义变量）"></a>4.5.4 awk 内置变量（预定义变量）</h4><p><strong>说明：</strong>  <code>[A][N][P][G]</code>表示第一个支持变量的工具，<code>[A]=awk</code>、<code>[N]=nawk</code>、<code>[P]=POSIXawk</code>、<code>[G]=gawk</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$n</span> <span class="comment"># 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 </span></span><br><span class="line"><span class="variable">$0</span> <span class="comment"># 这个变量包含执行过程中当前行的文本内容。 </span></span><br><span class="line">[N] ARGC <span class="comment"># 命令行参数的数目。 </span></span><br><span class="line">[G] ARGIND <span class="comment"># 命令行中当前文件的位置（从0开始算）。 </span></span><br><span class="line">[N] ARGV <span class="comment"># 包含命令行参数的数组。 </span></span><br><span class="line">[G] CONVFMT <span class="comment"># 数字转换格式（默认值为%.6g）。 </span></span><br><span class="line">[P] ENVIRON <span class="comment"># 环境变量关联数组。 </span></span><br><span class="line">[N] ERRNO <span class="comment"># 最后一个系统错误的描述。 </span></span><br><span class="line">[G] FIELDWIDTHS <span class="comment"># 字段宽度列表（用空格键分隔）。 </span></span><br><span class="line">[A] FILENAME <span class="comment"># 当前输入文件的名。 </span></span><br><span class="line">[P] FNR <span class="comment"># 同NR，但相对于当前文件。 </span></span><br><span class="line">[A] FS <span class="comment"># 字段分隔符（默认是任何空格）。 </span></span><br><span class="line">[G] IGNORECASE <span class="comment"># 如果为真，则进行忽略大小写的匹配。 </span></span><br><span class="line">[A] NF <span class="comment"># 表示字段数，在执行过程中对应于当前的字段数。 </span></span><br><span class="line">[A] NR <span class="comment"># 表示记录数，在执行过程中对应于当前的行号。 </span></span><br><span class="line">[A] OFMT <span class="comment"># 数字的输出格式（默认值是%.6g）。 </span></span><br><span class="line">[A] OFS <span class="comment"># 输出字段分隔符（默认值是一个空格）。 </span></span><br><span class="line">[A] ORS <span class="comment"># 输出记录分隔符（默认值是一个换行符）。 </span></span><br><span class="line">[A] RS <span class="comment"># 记录分隔符（默认是一个换行符）。 </span></span><br><span class="line">[N] RSTART <span class="comment"># 由match函数所匹配的字符串的第一个位置。 </span></span><br><span class="line">[N] RLENGTH <span class="comment"># 由match函数所匹配的字符串的长度。 </span></span><br><span class="line">[N] SUBSEP <span class="comment"># 数组下标分隔符（默认值是34）。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3nline2 f4 f5nline3 f6 f7"</span> | awk <span class="string">'&#123;print "Line No:"NR", No of fields:"NF, "$0="$0, "$1="$1, "$2="$2, "$3="$3&#125;'</span> </span><br><span class="line">Line No:1, No of fields:3 <span class="variable">$0</span>=line1 f2 f3 <span class="variable">$1</span>=line1 <span class="variable">$2</span>=f2 <span class="variable">$3</span>=f3 </span><br><span class="line">Line No:2, No of fields:3 <span class="variable">$0</span>=line2 f4 f5 <span class="variable">$1</span>=line2 <span class="variable">$2</span>=f4 <span class="variable">$3</span>=f5 </span><br><span class="line">Line No:3, No of fields:3 <span class="variable">$0</span>=line3 f6 f7 <span class="variable">$1</span>=line3 <span class="variable">$2</span>=f6 <span class="variable">$3</span>=f7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3n line2 f4 f5"</span> | awk <span class="string">'&#123;print $NF&#125;'</span> </span><br><span class="line">f3</span><br><span class="line">f5</span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3n line2 f4 f5"</span> | awk <span class="string">'&#123;print $(NF-1)&#125;'</span> </span><br><span class="line">f2 </span><br><span class="line">f4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每一行的第二和第三个字段：</span></span><br><span class="line">$ awk <span class="string">'&#123; print $2,$3 &#125;'</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件中的行数：</span></span><br><span class="line">$ awk <span class="string">'END&#123; print NR &#125;'</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个每一行中第一个字段值累加的例子：</span></span><br><span class="line">$ seq 5 | awk <span class="string">'BEGIN&#123; sum=0; print "总和：" &#125; &#123; print $1"+"; sum+=$1 &#125; END&#123; print "等于"; print sum &#125;'</span> </span><br><span class="line">总和： </span><br><span class="line">1+ </span><br><span class="line">2+ </span><br><span class="line">3+ </span><br><span class="line">4+ </span><br><span class="line">5+ </span><br><span class="line">等于 </span><br><span class="line">15</span><br></pre></td></tr></table></figure><h4 id="4-5-5-将外部变量值传递给awk"><a href="#4-5-5-将外部变量值传递给awk" class="headerlink" title="4.5.5 将外部变量值传递给awk"></a>4.5.5 将外部变量值传递给awk</h4><p>借助 <code>-v</code> 选项，可以将外部值（并非来自stdin）传递给awk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ VAR=10000 </span><br><span class="line">$ <span class="built_in">echo</span> | awk -v VARIABLE=<span class="variable">$VAR</span> <span class="string">'&#123; print VARIABLE &#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种传递外部变量方法：</span></span><br><span class="line">$ var1=<span class="string">"aaa"</span> </span><br><span class="line">$ var2=<span class="string">"bbb"</span> </span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当输入来自于文件时使用：</span></span><br><span class="line">$ awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span> filename</span><br></pre></td></tr></table></figure><h4 id="4-5-6-awk-运算与判断"><a href="#4-5-6-awk-运算与判断" class="headerlink" title="4.5.6 awk 运算与判断"></a>4.5.6 awk 运算与判断</h4><p><strong>算数运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+ -</td><td>加、减</td></tr><tr><td>* / &amp;</td><td>乘，除与求余</td></tr><tr><td>+ - !</td><td>一元加、减和逻辑非</td></tr><tr><td>^ ***</td><td>求幂</td></tr><tr><td>++ –</td><td>增加或减少，作为前缀或后缀</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";print a++,++a;&#125;'</span> </span><br><span class="line">0 2</span><br></pre></td></tr></table></figure><p style="color=red">**注意：**所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</p><p><strong>赋值运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>= += -= <em>= /= %= ^= *</em>=</td><td>赋值语句</td></tr></tbody></table><p><strong>逻辑运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>||</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);&#125;'</span></span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><p><strong>正则运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>~  ~!</td><td>匹配正则表达式和不匹配正则表达式</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="100testa";if(a ~ /^100*/)&#123;print "ok";&#125;&#125;'</span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><strong>关系运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&lt;  &lt;=  &gt;  &gt;=  !=  ==</td><td>关系运算符</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a=11;if(a &gt;= 9)&#123;print "ok";&#125;&#125;'</span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p style="color=red">**注意：**>  < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。</p><p><strong>其他运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>字段引用</td></tr><tr><td>空格</td><td>字符串连接符</td></tr><tr><td>? :</td><td>C条件表达式</td></tr><tr><td>in</td><td>数组中是否存在某键值</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";print a=="b"?"ok":"err";&#125;'</span> </span><br><span class="line">ok </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";arr[0]="b";arr[1]="c";print (a in arr);&#125;'</span> </span><br><span class="line">0 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";arr[0]="b";arr["b"]="c";print (a in arr);&#125;'</span> </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>运算级优先级表：</p><table><thead><tr><th>级别</th><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>=, +=, -=, *=, /=, %=, &amp;=, ^=, |=, &lt;&lt;=, &gt;&gt;=</td><td>赋值、运算</td></tr><tr><td>2</td><td>||</td><td>逻辑或</td></tr><tr><td>3</td><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>4</td><td>|</td><td>按位或</td></tr><tr><td>5</td><td>^</td><td>按位异或</td></tr><tr><td>6</td><td>&amp;</td><td>按位与</td></tr><tr><td>7</td><td>==, !=</td><td>等于、不等于</td></tr><tr><td>8</td><td>&lt;=, &gt;=, &lt;, &gt;</td><td>小于等于、大于等于、小于、大于</td></tr><tr><td>9</td><td>&lt;&lt;, &gt;&gt;</td><td>按位左移，按位右移</td></tr><tr><td>10</td><td>+, -</td><td>加、减</td></tr><tr><td>11</td><td>*, /, %</td><td>乘、除、取模</td></tr><tr><td>12</td><td>!, ~</td><td>逻辑非、按位取反或补码</td></tr><tr><td>13</td><td>-, +</td><td>正、负</td></tr></tbody></table><p>级别越高越优先</p><h4 id="4-5-7-awk-高级输入输出"><a href="#4-5-7-awk-高级输入输出" class="headerlink" title="4.5.7 awk 高级输入输出"></a>4.5.7 awk 高级输入输出</h4><p><strong>读取下一条记录：</strong></p><p>awk中 <code>next</code> 语句使用：在循环逐行匹配，如果遇到 <code>next</code>，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。net语句一般用于多行合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt </span><br><span class="line">a </span><br><span class="line">b </span><br><span class="line">c </span><br><span class="line">d </span><br><span class="line">e </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;'</span> text.txt </span><br><span class="line">2 b </span><br><span class="line">4 d</span><br></pre></td></tr></table></figure><p>当记录行号除以2余1，就跳过当前行。下面的 <code>print NR,$0</code> 也不会执行。下一行开始，程序有开始判断 <code>NR%2</code> 值。这个时候记录行号是 <code>：2</code>  ，就会执行下面语句块：<code>&#39;print NR,$0&#39;</code> </p><p>分析发现需要将包含有 “web” 行进行跳过，然后需要将内容与下面行合并为一行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt </span><br><span class="line">web01[192.168.2.100] </span><br><span class="line">httpd ok </span><br><span class="line">tomcat ok </span><br><span class="line">sendmail ok </span><br><span class="line">web02[192.168.2.101] </span><br><span class="line">httpd ok </span><br><span class="line">postfix ok </span><br><span class="line">web03[192.168.2.102] </span><br><span class="line">mysqld ok </span><br><span class="line">httpd ok </span><br><span class="line">0 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'/^web/&#123;T=$0;next;&#125;&#123;print T":t"$0;&#125;'</span> test.txt </span><br><span class="line">web01[192.168.2.100]: httpd ok </span><br><span class="line">web01[192.168.2.100]: tomcat ok </span><br><span class="line">web01[192.168.2.100]: sendmail ok </span><br><span class="line">web02[192.168.2.101]: httpd ok </span><br><span class="line">web02[192.168.2.101]: postfix ok </span><br><span class="line">web03[192.168.2.102]: mysqld ok </span><br><span class="line">web03[192.168.2.102]: httpd ok</span><br></pre></td></tr></table></figure><p><strong>简单地读取一条记录：</strong></p><p><code>awk getline</code> 用法：输出重定向需用到 <code>getline函数</code>。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。</p><p style="color=red">如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。 </p><p></p><blockquote><p>getline语法：getline var，变量var包含了特定行的内容。 </p></blockquote><p>awk getline从整体上来说，用法说明：</p><ul><li><strong>当其左右<p style="color=red">无</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline作用于当前文件，读入当前文件的第一行给其后跟的变量 <code>var</code> 或 <code>$0</code>（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。</li><li><strong>当其左右<p style="color=red">有</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; "date" | getline out; print out &#125;'</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，split函数把变量out转化成数组mon，然后打印数组mon的第二个元素：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; "date" | getline out; split(out,mon); print mon[2] &#125;'</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; while( "ls" | getline) print &#125;'</span></span><br></pre></td></tr></table></figure><p><strong>关闭文件：</strong></p><p>awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(<span class="string">"filename"</span>)</span><br></pre></td></tr></table></figure><p>filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。</p><p><strong>输出到一个文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt; "datafile"&#125;'</span></span><br><span class="line">或 </span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt;&gt; "datafile"&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="4-5-8-设置字段定界符"><a href="#4-5-8-设置字段定界符" class="headerlink" title="4.5.8 设置字段定界符"></a>4.5.8 设置字段定界符</h4><p style="color=red">默认的字段定界符是空格</p>，可以使用 `-F "定界符"` 明确指定一个定界符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F: <span class="string">'&#123; print $NF &#125;'</span> /etc/passwd </span><br><span class="line">或 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123; FS=":" &#125; &#123; print $NF &#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>在 <code>BEGIN语句块</code> 中则可以用 <code>OFS=“定界符”</code> 设置输出字段的定界符。</p><h4 id="4-5-9-流程控制语句"><a href="#4-5-9-流程控制语句" class="headerlink" title="4.5.9 流程控制语句"></a>4.5.9 流程控制语句</h4><p><strong>条件判断语句：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100; </span></span><br><span class="line"><span class="string">if(test&gt;90)&#123; </span></span><br><span class="line"><span class="string">print "very good"; </span></span><br><span class="line"><span class="string">&#125; else if(test&gt;60)&#123; </span></span><br><span class="line"><span class="string">print "good"; </span></span><br><span class="line"><span class="string">&#125; else&#123; </span></span><br><span class="line"><span class="string">print "no pass"; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">very good</span><br></pre></td></tr></table></figure><p>每条命令语句后面可以用 <code>;</code> </p><p style="color=red">分号</p>结尾。<p></p><p><strong>循环语句：</strong></p><p>while语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">while(i&lt;=test)&#123; </span></span><br><span class="line"><span class="string">total+=i; i++; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>for循环：</p><p>格式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(k in ENVIRON)&#123; </span></span><br><span class="line"><span class="string">print k"="ENVIRON[k]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line">TERM=linux </span><br><span class="line">G_BROKEN_FILENAMES=1 </span><br><span class="line">SHLVL=1 </span><br><span class="line"><span class="built_in">pwd</span>=/root/text </span><br><span class="line">... </span><br><span class="line">logname=root </span><br><span class="line">HOME=/root </span><br><span class="line">SSH_CLIENT=192.168.1.21 53087 22</span><br></pre></td></tr></table></figure><p><strong>注：</strong>ENVIRON是awk常量，是子典型数组。</p><p>格式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">for(i=0;i&lt;=100;i++)&#123; </span></span><br><span class="line"><span class="string">total+=i; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>do循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">i=0; </span></span><br><span class="line"><span class="string">do &#123;</span></span><br><span class="line"><span class="string">total+=i;i++;</span></span><br><span class="line"><span class="string">&#125; while(i&lt;=100) </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p><strong>其他语句：</strong></p><ul><li><strong>break</strong>          当 break 语句用于 while 或 for 语句时，导致退出程序循环</li><li><strong>continue</strong>       当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代</li><li><strong>next</strong>               能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程</li><li><strong>exit</strong>                 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行</li></ul><h4 id="4-5-10-数组应用"><a href="#4-5-10-数组应用" class="headerlink" title="4.5.10 数组应用"></a>4.5.10 数组应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到数组长度</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";lens=split(info,tA," ");print length(tA),lens;&#125;'</span> </span><br><span class="line">4 4</span><br><span class="line"><span class="comment"># length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># asort对数组进行排序，返回数组长度。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";split(info,tA," ");print asort(tA);&#125;'</span> </span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组内容（无序，有序输出）：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";split(info,tA," ");for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">4 <span class="built_in">test</span> </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line"></span><br><span class="line"><span class="comment"># for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";tlen=split(info,tA," ");for(k=1;k&lt;=tlen;k++)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line">4 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 注意：数组下标是从1开始，与C数组不一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断键值存在以及删除键值：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";if( "c" in tB)&#123;print "ok";&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;'</span> </span><br><span class="line">a a1 </span><br><span class="line">b b1</span><br><span class="line"><span class="comment"># 删除键值： </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";delete tB["a"];for(k in tB)&#123;print k,tB[k];&#125;&#125;'</span> </span><br><span class="line">b b1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维、多维数组使用</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(i=1;i&lt;=9;i++)&#123; </span></span><br><span class="line"><span class="string">for(j=1;j&lt;=9;j++)&#123; </span></span><br><span class="line"><span class="string">tarr[i,j]=i*j; </span></span><br><span class="line"><span class="string">print i,"*",j,"=",tarr[i,j]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line">1 * 1 = 1 </span><br><span class="line">1 * 2 = 2 </span><br><span class="line">1 * 3 = 3 </span><br><span class="line">1 * 4 = 4 </span><br><span class="line">1 * 5 = 5 </span><br><span class="line">1 * 6 = 6 </span><br><span class="line">... </span><br><span class="line">9 * 6 = 54 </span><br><span class="line">9 * 7 = 63 </span><br><span class="line">9 * 8 = 72 </span><br><span class="line">9 * 9 = 81</span><br><span class="line"><span class="comment"># 可以通过array[k,k2]引用获得数组内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方法：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(i=1;i&lt;=9;i++)&#123; </span></span><br><span class="line"><span class="string">for(j=1;j&lt;=9;j++)&#123; </span></span><br><span class="line"><span class="string">tarr[i,j]=i*j; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">for(m in tarr)&#123; </span></span><br><span class="line"><span class="string">split(m,tarr2,SUBSEP); print tarr2[1],"*",tarr2[2],"=",tarr[m]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="4-5-11-内置函数"><a href="#4-5-11-内置函数" class="headerlink" title="4.5.11 内置函数"></a>4.5.11 内置函数</h4><p>awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数。</p><p><strong>算数函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>atan2( y, x )</td><td>返回 y/x 的反正切</td></tr><tr><td>cos( x )</td><td>返回 x 的余弦；x 是弧度</td></tr><tr><td>sin( x )</td><td>返回 x 的正弦；x 是弧度</td></tr><tr><td>exp( x )</td><td>返回 x 幂函数</td></tr><tr><td>log( x )</td><td>返回 x 的自然对数</td></tr><tr><td>sqrt( x )</td><td>返回 x 平方根</td></tr><tr><td>int( x )</td><td>返回 x 的截断至整数的值</td></tr><tr><td>rand( )</td><td>返回任意数字 n，其中 0 &lt;= n &lt; 1</td></tr><tr><td>srand( [expr] )</td><td>将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;OFMT="%.3f";fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;&#125;'</span> </span><br><span class="line">0.841 22026.466 2.303 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得随机数：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">78 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">31 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">41</span><br></pre></td></tr></table></figure><p><strong>字符串函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>gsub( Ere, Repl, [ In ] )</td><td>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行</td></tr><tr><td>sub( Ere, Repl, [ In ] )</td><td>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）</td></tr><tr><td>index( String1, String2 )</td><td>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）</td></tr><tr><td>length [(String)]</td><td>返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td></tr><tr><td>blength [(String)]</td><td>返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td></tr><tr><td>substr( String, M, [ N ] )</td><td>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度</td></tr><tr><td>match( String, Ere )</td><td>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）</td></tr><tr><td>split( String, A, [Ere] )</td><td>将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建</td></tr><tr><td>tolower( String )</td><td>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td></tr><tr><td>toupper( String )</td><td>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td></tr><tr><td>sprintf(Format, Expr, Expr, . . . )</td><td>根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串</td></tr></tbody></table><p><strong>注：</strong>Ere都可以是正则表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gsub,sub使用 </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";gsub(/[0-9]+/,"!",info);print info&#125;'</span> </span><br><span class="line">this is a <span class="built_in">test</span>!<span class="built_in">test</span>!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找字符串（index使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print index(info,"test")?"ok":"no found";&#125;'</span> </span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式匹配查找(match使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print match(info,/[0-9]+/)?"ok":"no found";&#125;'</span> </span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取字符串(substr使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print substr(info,4,10);&#125;'</span> </span><br><span class="line">s is a tes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串分割（split使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test";split(info,tA," ");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">4 </span><br><span class="line">4 <span class="built_in">test</span> </span><br><span class="line">1 this </span><br><span class="line">2 is </span><br><span class="line">3 a</span><br></pre></td></tr></table></figure><p><strong>格式化字符串输出（sprintf使用）</strong> </p><p>格式化字符串格式：</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%d</td><td>十进制有符号整数</td></tr><tr><td>%u</td><td>十进制无符号整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%c</td><td>单个字符</td></tr><tr><td>%p</td><td>指针的值</td></tr><tr><td>%e</td><td>指数形式的浮点数</td></tr><tr><td>%x</td><td>%X 无符号以十六进制表示的整数</td></tr><tr><td>%o</td><td>无符号以八进制表示的整数</td></tr><tr><td>%g</td><td>自动选择合适的表示法</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;n1=124.113;n2=-1.224;n3=1.2345; printf("%.2f,%.2u,%.2g,%X,%on",n1,n2,n3,n1,n1);&#125;'</span> </span><br><span class="line">124.11,18446744073709551615,1.2,7C,174</span><br></pre></td></tr></table></figure><p><strong>一般函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>close( Expression )</td><td>用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的</td></tr><tr><td>system(command )</td><td>执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程</td></tr><tr><td>Expression | getline [ Variable ]</td><td>从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td></tr><tr><td>getline [ Variable ] &lt; Expression</td><td>从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td></tr><tr><td>getline [ Variable ]</td><td>将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开外部文件（close用法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;while("cat /etc/passwd"|getline)&#123;print $0;&#125;;close("/etc/passwd");&#125;'</span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐行读取外部文件(getline使用方法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;while(getline &lt; "/etc/passwd")&#123;print $0;&#125;;close("/etc/passwd");&#125;'</span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin </span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;print "Enter your name:";getline name;print name;&#125;'</span> </span><br><span class="line">Enter your name: </span><br><span class="line">chengmo </span><br><span class="line">chengmo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用外部应用程序(system使用方法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;b=system("ls -al");print b;&#125;'</span> </span><br><span class="line">total 42092 </span><br><span class="line">drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 . </span><br><span class="line">drwxr-xr-x 95 root root 4096 10-08 14:01 .. </span><br><span class="line"><span class="comment"># b返回值，是执行结果。</span></span><br></pre></td></tr></table></figure><p><strong>时间函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>函数名</td><td>说明</td></tr><tr><td>mktime( YYYY MM dd HH MM ss[ DST])</td><td>生成时间格式</td></tr><tr><td>strftime([format [, timestamp]])</td><td>格式化时间输出，将时间戳转为时间字符串 具体格式，见下表.</td></tr><tr><td>systime()</td><td>得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建指定时间(mktime使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp=mktime("2001 01 01 12 12 12");print strftime("%c",tstamp);&#125;'</span> </span><br><span class="line">2001年01月01日 星期一 12时12分12秒 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=mktime("2001 02 01 0 0 0");print tstamp2-tstamp1;&#125;'</span> </span><br><span class="line">2634468 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 求2个时间段中间时间差，介绍了strftime使用方法 </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=systime();print tstamp2-tstamp1;&#125;'</span> </span><br><span class="line">308201392</span><br></pre></td></tr></table></figure><p>strftime日期和时间格式说明符</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%a</td><td>星期几的缩写（Sun）</td></tr><tr><td>%A</td><td>星期几的完整写法（Sunday）</td></tr><tr><td>%b</td><td>月名的缩写（Oct）</td></tr><tr><td>%B</td><td>月名的完整写法（October）</td></tr><tr><td>%c</td><td>本地日期和时间</td></tr><tr><td>%d</td><td>十进制日期</td></tr><tr><td>%D</td><td>日期 08/20/99</td></tr><tr><td>%e</td><td>日期，如果只有一位会补上一个空格</td></tr><tr><td>%H</td><td>用十进制表示24小时格式的时间</td></tr><tr><td>%I</td><td>用十进制表示12小时格式的时间</td></tr><tr><td>%j</td><td>从1月1日期一年中的第几天</td></tr><tr><td>%m</td><td>十进制表示的月份</td></tr><tr><td>%M</td><td>十进制表示的分钟</td></tr><tr><td>%p</td><td>12小时表示法（AM/PM）</td></tr><tr><td>%S</td><td>十进制表示的秒</td></tr><tr><td>%U</td><td>十进制表示的一年中的第几个星期（星期天作为一个星期的开始）</td></tr><tr><td>%w</td><td>十进制表示的星期几（星期天是0）</td></tr><tr><td>%W</td><td>十进制表示的一年中的第几个星期（星期一作为一个星期的开始）</td></tr><tr><td>%x</td><td>重新设置本地日期（08/20/99）</td></tr><tr><td>%X</td><td>重新设置本地时间（12 : 00 : 00）</td></tr><tr><td>%y</td><td>两位数字表示的年（99）</td></tr><tr><td>%Y</td><td>当前月份</td></tr><tr><td>%Z</td><td>时区（PDT）</td></tr><tr><td>%%</td><td>百分号（%）</td></tr></tbody></table><h3 id="4-6-find-对目录中的所有文件进行文本替换"><a href="#4-6-find-对目录中的所有文件进行文本替换" class="headerlink" title="4.6 find 对目录中的所有文件进行文本替换"></a>4.6 find 对目录中的所有文件进行文本替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有.cpp文件中的Copyright替换成Copyleft：</span></span><br><span class="line">$ find . -name *.cpp -print0 | xargs -I&#123;&#125; -0 sed -i <span class="string">'s/Copyright/Copyleft/g'</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-exec实现同样的效果：</span></span><br><span class="line">$ find . -name *.cpp -<span class="built_in">exec</span> sed -i <span class="string">'s/Copyright/Copyleft/g'</span> \&#123;\&#125; \;</span><br></pre></td></tr></table></figure><h2 id="5-一团乱麻"><a href="#5-一团乱麻" class="headerlink" title="5 一团乱麻"></a>5 一团乱麻</h2><h3 id="5-1-wget命令"><a href="#5-1-wget命令" class="headerlink" title="5.1 wget命令"></a>5.1 wget命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-a&lt;日志文件&gt;：<span class="comment"># 在指定的日志文件中记录资料的执行过程； </span></span><br><span class="line">-A&lt;后缀名&gt;： <span class="comment"># 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔； </span></span><br><span class="line">-b：   <span class="comment"># 进行后台的方式运行wget； </span></span><br><span class="line">-B&lt;连接地址&gt;：<span class="comment"># 设置参考的连接地址的基地地址； </span></span><br><span class="line">-c：   <span class="comment"># 继续执行上次终端的任务； </span></span><br><span class="line">-C&lt;标志&gt;： <span class="comment"># 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； </span></span><br><span class="line">-d：   <span class="comment"># 调试模式运行指令； </span></span><br><span class="line">-D&lt;域名列表&gt;：    <span class="comment"># 设置顺着的域名列表，域名之间用“，”分隔； </span></span><br><span class="line">-e&lt;指令&gt;： <span class="comment"># 作为文件“.wgetrc”中的一部分执行指定的指令； </span></span><br><span class="line">-h：   <span class="comment"># 显示指令帮助信息； </span></span><br><span class="line">-i&lt;文件&gt;： <span class="comment"># 从指定文件获取要下载的URL地址； </span></span><br><span class="line">-l&lt;目录列表&gt;：<span class="comment"># 设置顺着的目录列表，多个目录用“，”分隔； </span></span><br><span class="line">-L：   <span class="comment"># 仅顺着关联的连接； </span></span><br><span class="line">-r：   <span class="comment"># 递归下载方式； </span></span><br><span class="line">-nc：   <span class="comment"># 文件存在时，下载文件不覆盖原有文件； </span></span><br><span class="line">-nv：   <span class="comment"># 下载时只显示更新和出错信息，不显示指令的详细执行过程； </span></span><br><span class="line">-q：   <span class="comment"># 不显示指令执行过程； </span></span><br><span class="line">-nh：   <span class="comment"># 不查询主机名称； </span></span><br><span class="line">-v：   <span class="comment"># 显示详细执行过程； </span></span><br><span class="line">-V：   <span class="comment"># 显示版本信息； </span></span><br><span class="line">--passive-ftp：   <span class="comment"># 使用被动模式PASV连接FTP服务器； </span></span><br><span class="line">--follow-ftp：   <span class="comment"># 从HTML文件中下载FTP连接文件。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget下载单个文件 </span></span><br><span class="line">$ wget http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并以不同的文件名保存 </span></span><br><span class="line">$ wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># wget限速下载 </span></span><br><span class="line">$ wget --<span class="built_in">limit</span>-rate=300k http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用wget断点续传 </span></span><br><span class="line">$ wget -c http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用wget后台下载 </span></span><br><span class="line">$ wget -b http://www.linuxde.net/testfile.zip </span><br><span class="line">Continuing <span class="keyword">in</span> background, pid 1840. </span><br><span class="line">Output will be written to `wget-log<span class="string">'.</span></span><br><span class="line"><span class="string"># 对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载，你可以使用以下命令来察看下载进度： </span></span><br><span class="line"><span class="string">$ tail -f wget-log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 伪装代理名称下载 </span></span><br><span class="line"><span class="string">$ wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.linuxde.net/testfile.zip</span></span><br><span class="line"><span class="string"># 有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装。</span></span><br></pre></td></tr></table></figure><p><strong>测试下载链接：</strong></p><p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --spider URL</span><br></pre></td></tr></table></figure><p>如果下载链接正确，将会显示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spider mode enabled. Check if remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 200 OK </span><br><span class="line">Length: unspecified [text/html] </span><br><span class="line">Remote file exists and could contain further links, </span><br><span class="line">but recursion is disabled -- not retrieving.</span><br></pre></td></tr></table></figure><p>这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget --spider url </span><br><span class="line">Spider mode enabled. Check <span class="keyword">if</span> remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 404 Not Found </span><br><span class="line">Remote file does not exist -- broken link!!!</span><br></pre></td></tr></table></figure><p>你可以在以下几种情况下使用–spider参数：</p><ul><li>定时下载之前进行检查</li><li>间隔检测网站是否可用</li><li>检查网站页面的死链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加重试次数 </span></span><br><span class="line">$ wget --tries=40 URL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载多个文件 </span></span><br><span class="line">$ wget -i filelist.txt </span><br><span class="line"><span class="comment"># 首先，保存一份下载链接文件： </span></span><br><span class="line">$ cat &gt; filelist.txt </span><br><span class="line">url1 </span><br><span class="line">url2 </span><br><span class="line">url3 </span><br><span class="line">url4 </span><br><span class="line"><span class="comment"># 接着使用这个文件和参数-i下载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤指定格式下载 </span></span><br><span class="line">$ wget --reject=gif ur </span><br><span class="line"><span class="comment"># 下载一个网站，但你不希望下载图片，可以使用这条命令。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把下载信息存入日志文件 </span></span><br><span class="line">$ wget -o download.log URL </span><br><span class="line"><span class="comment"># 不希望下载信息直接显示在终端而是在一个日志文件，可以使用。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制总下载文件大小 </span></span><br><span class="line">$ wget -Q5m -i filelist.txt </span><br><span class="line"><span class="comment"># 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</span></span><br></pre></td></tr></table></figure><p><strong>镜像网站：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --mirror -p --convert-links -P ./LOCAL URL</span><br></pre></td></tr></table></figure><p>下载整个网站到本地。</p><ul><li>–mirror 开户镜像下载</li><li>-p 下载所有为了html页面显示正常的文件</li><li>–convert-links 下载后，转换成本地的链接</li><li>-P ./LOCAL URL 保存所有文件和目录到本地指定目录</li></ul><p><strong>下载指定格式文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -A.pdf url</span><br></pre></td></tr></table></figure><p>可以在以下情况使用该功能：</p><ul><li>下载一个网站的所有图片</li><li>下载一个网站的所有视频</li><li>下载一个网站的所有PDF文件</li></ul><p><strong>FTP下载：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp-url </span><br><span class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><p>可以使用wget来完成ftp链接的下载。 </p><p>使用wget匿名ftp下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp-url</span><br></pre></td></tr></table></figure><p>使用wget用户名和密码认证的ftp下载： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><h3 id="5-2-curl-命令"><a href="#5-2-curl-命令" class="headerlink" title="5.2 curl 命令"></a>5.2 curl 命令</h3><p>常见参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-A/--user-agent &lt;string&gt;              <span class="comment"># 设置用户代理发送给服务器</span></span><br><span class="line">-b/--cookie &lt;name=string/file&gt;      <span class="comment"># cookie字符串或文件读取位置</span></span><br><span class="line">-c/--cookie-jar &lt;file&gt;                <span class="comment"># 操作结束后把cookie写入到这个文件中</span></span><br><span class="line">-C/--<span class="built_in">continue</span>-at &lt;offset&gt;             <span class="comment"># 断点续转</span></span><br><span class="line">-D/--dump-header &lt;file&gt;               <span class="comment"># 把header信息写入到该文件中</span></span><br><span class="line">-e/--referer                          <span class="comment"># 来源网址</span></span><br><span class="line">-f/--fail                             <span class="comment"># 连接失败时不显示http错误</span></span><br><span class="line">-o/--output                           <span class="comment"># 把输出写到该文件中</span></span><br><span class="line">-O/--remote-name                      <span class="comment"># 把输出写到该文件中，保留远程文件的文件名</span></span><br><span class="line">-r/--range &lt;range&gt;                    <span class="comment"># 检索来自HTTP/1.1或FTP服务器字节范围</span></span><br><span class="line">-s/--silent                           <span class="comment"># 静音模式。不输出任何东西</span></span><br><span class="line">-T/--upload-file &lt;file&gt;               <span class="comment"># 上传文件</span></span><br><span class="line">-u/--user &lt;user[:password]&gt;           <span class="comment"># 设置服务器的用户和密码</span></span><br><span class="line">-w/--write-out [format]               <span class="comment"># 什么输出完成后</span></span><br><span class="line">-x/--proxy &lt;host[:port]&gt;              <span class="comment"># 在给定的端口上使用HTTP代理</span></span><br><span class="line">-<span class="comment">#/--progress-bar                     # 进度条显示当前的传送状态</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不显示进度信息使用--silent选项。</span></span><br><span class="line">$ curl URL --silent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用选项 -O 将下载的数据写入到文件，必须使用文件的绝对地址：</span></span><br><span class="line">$ curl http://man.linuxde.net/text.iso --silent -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条：</span></span><br><span class="line">$ curl http://man.linuxde.net/test.iso -o filename.iso --progress</span><br><span class="line"><span class="comment">######################################### 100.0%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断点续传</span></span><br><span class="line">$ curl URL/File -C 偏移量 </span><br><span class="line"><span class="comment"># 偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -： </span></span><br><span class="line">$ curl -C -URL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--referer选项指定参照页字符串： </span></span><br><span class="line">$ curl --referer http://www.google.com http://man.linuxde.net </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl设置cookies 使用--cookie "COKKIES"选项来指定cookie，多个cookie使用分号分隔： </span></span><br><span class="line">$ curl http://man.linuxde.net --cookie <span class="string">"user=root;pass=123456"</span> </span><br><span class="line"><span class="comment"># 将cookie另存为一个文件，使用--cookie-jar选项： </span></span><br><span class="line">$ curl URL --cookie-jar cookie_file </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl设置用户代理字符串 有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用--user-agent或者-A选项：</span></span><br><span class="line">$ curl URL --user-agent <span class="string">"Mozilla/5.0"</span> curl URL -A <span class="string">"Mozilla/5.0"</span> </span><br><span class="line"><span class="comment"># 其他HTTP头部信息也可以使用curl来发送，使用-H"头部信息" 传递多个头部信息，例如： </span></span><br><span class="line">$ curl -H <span class="string">"Host:man.linuxde.net"</span> -H <span class="string">"accept-language:zh-cn"</span> URL </span><br><span class="line"></span><br><span class="line"><span class="comment"># curl的带宽控制和下载配额 使用--limit-rate限制curl的下载速度： </span></span><br><span class="line">$ curl URL --<span class="built_in">limit</span>-rate 50k </span><br><span class="line"><span class="comment"># 命令中用k（千字节）和m（兆字节）指定下载速度限制。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--max-filesize指定可下载的最大文件大小： </span></span><br><span class="line">$ curl URL --max-filesize bytes </span><br><span class="line"><span class="comment"># 如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl进行认证 使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码： </span></span><br><span class="line">$ curl -u user:<span class="built_in">pwd</span> http://man.linuxde.net </span><br><span class="line">$ curl -u user http://man.linuxde.net </span><br><span class="line"></span><br><span class="line"><span class="comment"># 只打印响应头部信息 通过-I或者-head可以只打印出HTTP头部信息： </span></span><br><span class="line">$ curl -I http://man.linuxde.net </span><br><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Server: nginx/1.2.5 </span><br><span class="line">date: Mon, 10 Dec 2012 09:24:34 GMT </span><br><span class="line">Content-Type: text/html; charset=UTF-8 </span><br><span class="line">Connection: keep-alive </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Pingback: http://man.linuxde.net/xmlrpc.php</span><br></pre></td></tr></table></figure><p>其他参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">-a/--append                    <span class="comment"># 上传文件时，附加到目标文件</span></span><br><span class="line">--anyauth                      <span class="comment"># 可以使用“任何”身份验证方法</span></span><br><span class="line">--basic                        <span class="comment"># 使用HTTP基本验证</span></span><br><span class="line">-B/--use-ascii                 <span class="comment"># 使用ASCII文本传输</span></span><br><span class="line">-d/--data &lt;data&gt;               <span class="comment"># HTTP POST方式传送数据</span></span><br><span class="line">--data-ascii &lt;data&gt;            <span class="comment"># 以ascii的方式post数据</span></span><br><span class="line">--data-binary &lt;data&gt;           <span class="comment"># 以二进制的方式post数据</span></span><br><span class="line">--negotiate                    <span class="comment"># 使用HTTP身份验证</span></span><br><span class="line">--digest                       <span class="comment"># 使用数字身份验证</span></span><br><span class="line">--<span class="built_in">disable</span>-eprt                 <span class="comment"># 禁止使用EPRT或LPRT</span></span><br><span class="line">--<span class="built_in">disable</span>-epsv                 <span class="comment"># 禁止使用EPSV</span></span><br><span class="line">--egd-file &lt;file&gt;              <span class="comment"># 为随机数据(SSL)设置EGD socket路径</span></span><br><span class="line">--tcp-nodelay                  <span class="comment"># 使用TCP_NODELAY选项</span></span><br><span class="line">-E/--cert &lt;cert[:passwd]&gt;      <span class="comment"># 客户端证书文件和密码 (SSL)</span></span><br><span class="line">--cert-type &lt;<span class="built_in">type</span>&gt;             <span class="comment"># 证书文件类型 (DER/PEM/ENG) (SSL)</span></span><br><span class="line">--key &lt;key&gt;                    <span class="comment"># 私钥文件名 (SSL)</span></span><br><span class="line">--key-type &lt;<span class="built_in">type</span>&gt;              <span class="comment"># 私钥文件类型 (DER/PEM/ENG) (SSL)</span></span><br><span class="line">--pass  &lt;pass&gt;                 <span class="comment"># 私钥密码 (SSL)</span></span><br><span class="line">--engine &lt;eng&gt;                 <span class="comment"># 加密引擎使用 (SSL). "--engine list" for list</span></span><br><span class="line">--cacert &lt;file&gt;                <span class="comment"># CA证书 (SSL)</span></span><br><span class="line">--capath &lt;directory&gt;           <span class="comment"># CA目   (made using c_rehash) to verify peer against (SSL)</span></span><br><span class="line">--ciphers &lt;list&gt;               <span class="comment"># SSL密码</span></span><br><span class="line">--compressed                   <span class="comment"># 要求返回是压缩的形势 (using deflate or gzip)</span></span><br><span class="line">--connect-timeout &lt;seconds&gt;    <span class="comment"># 设置最大请求时间</span></span><br><span class="line">--create-dirs                  <span class="comment"># 建立本地目录的目录层次结构</span></span><br><span class="line">--crlf                         <span class="comment"># 上传是把LF转变成CRLF</span></span><br><span class="line">--ftp-create-dirs              <span class="comment"># 如果远程目录不存在，创建远程目录</span></span><br><span class="line">--ftp-method [multicwd/nocwd/singlecwd]    <span class="comment"># 控制CWD的使用</span></span><br><span class="line">--ftp-pasv                     <span class="comment"># 使用 PASV/EPSV 代替端口</span></span><br><span class="line">--ftp-skip-pasv-ip             <span class="comment"># 使用PASV的时候,忽略该IP地址</span></span><br><span class="line">--ftp-ssl                      <span class="comment"># 尝试用 SSL/TLS 来进行ftp数据传输</span></span><br><span class="line">--ftp-ssl-reqd                 <span class="comment"># 要求用 SSL/TLS 来进行ftp数据传输</span></span><br><span class="line">-F/--form &lt;name=content&gt;       <span class="comment"># 模拟http表单提交数据</span></span><br><span class="line">-form-string &lt;name=string&gt;     <span class="comment"># 模拟http表单提交数据</span></span><br><span class="line">-g/--globoff                   <span class="comment"># 禁用网址序列和范围使用&#123;&#125;和[]</span></span><br><span class="line">-G/--get                       <span class="comment"># 以get的方式来发送数据</span></span><br><span class="line">-h/--<span class="built_in">help</span>                      <span class="comment"># 帮助</span></span><br><span class="line">-H/--header &lt;line&gt;             <span class="comment"># 自定义头信息传递给服务器</span></span><br><span class="line">--ignore-content-length        <span class="comment"># 忽略的HTTP头信息的长度</span></span><br><span class="line">-i/--include                   <span class="comment"># 输出时包括protocol头信息</span></span><br><span class="line">-I/--head                      <span class="comment"># 只显示文档信息</span></span><br><span class="line">-j/--junk-session-cookies      <span class="comment"># 读取文件时忽略session cookie</span></span><br><span class="line">--interface &lt;interface&gt;        <span class="comment"># 使用指定网络接口/地址</span></span><br><span class="line">--krb4 &lt;level&gt;                 <span class="comment"># 使用指定安全级别的krb4</span></span><br><span class="line">-k/--insecure                  <span class="comment"># 允许不使用证书到SSL站点</span></span><br><span class="line">-K/--config                    <span class="comment"># 指定的配置文件读取</span></span><br><span class="line">-l/--list-only                 <span class="comment"># 列出ftp目录下的文件名称</span></span><br><span class="line">--<span class="built_in">limit</span>-rate &lt;rate&gt;            <span class="comment"># 设置传输速度</span></span><br><span class="line">--<span class="built_in">local</span>-port&lt;NUM&gt;              <span class="comment"># 强制使用本地端口号</span></span><br><span class="line">-m/--max-time &lt;seconds&gt;        <span class="comment"># 设置最大传输时间</span></span><br><span class="line">--max-redirs &lt;num&gt;             <span class="comment"># 设置最大读取的目录数</span></span><br><span class="line">--max-filesize &lt;bytes&gt;         <span class="comment"># 设置最大下载的文件总量</span></span><br><span class="line">-M/--manual                    <span class="comment"># 显示全手动</span></span><br><span class="line">-n/--netrc                     <span class="comment"># 从netrc文件中读取用户名和密码</span></span><br><span class="line">--netrc-optional               <span class="comment"># 使用 .netrc 或者 URL来覆盖-n</span></span><br><span class="line">--ntlm                         <span class="comment"># 使用 HTTP NTLM 身份验证</span></span><br><span class="line">-N/--no-buffer                 <span class="comment"># 禁用缓冲输出</span></span><br><span class="line">-p/--proxytunnel               <span class="comment"># 使用HTTP代理</span></span><br><span class="line">--proxy-anyauth                <span class="comment"># 选择任一代理身份验证方法</span></span><br><span class="line">--proxy-basic                  <span class="comment"># 在代理上使用基本身份验证</span></span><br><span class="line">--proxy-digest                 <span class="comment"># 在代理上使用数字身份验证</span></span><br><span class="line">--proxy-ntlm                   <span class="comment"># 在代理上使用ntlm身份验证</span></span><br><span class="line">-P/--ftp-port &lt;address&gt;        <span class="comment"># 使用端口地址，而不是使用PASV</span></span><br><span class="line">-Q/--quote &lt;cmd&gt;               <span class="comment"># 文件传输前，发送命令到服务器</span></span><br><span class="line">--range-file                   <span class="comment"># 读取（SSL）的随机文件</span></span><br><span class="line">-R/--remote-time               <span class="comment"># 在本地生成文件时，保留远程文件时间</span></span><br><span class="line">--retry &lt;num&gt;                  <span class="comment"># 传输出现问题时，重试的次数</span></span><br><span class="line">--retry-delay &lt;seconds&gt;        <span class="comment"># 传输出现问题时，设置重试间隔时间</span></span><br><span class="line">--retry-max-time &lt;seconds&gt;     <span class="comment"># 传输出现问题时，设置最大重试时间</span></span><br><span class="line">-S/--show-error                <span class="comment"># 显示错误</span></span><br><span class="line">--socks4 &lt;host[:port]&gt;         <span class="comment"># 用socks4代理给定主机和端口</span></span><br><span class="line">--socks5 &lt;host[:port]&gt;         <span class="comment"># 用socks5代理给定主机和端口</span></span><br><span class="line">-t/--telnet-option &lt;OPT=val&gt;   <span class="comment"># Telnet选项设置</span></span><br><span class="line">--trace &lt;file&gt;                 <span class="comment"># 对指定文件进行debug</span></span><br><span class="line">--trace-ascii &lt;file&gt;           <span class="comment"># Like --跟踪但没有hex输出</span></span><br><span class="line">--trace-time                   <span class="comment"># 跟踪/详细输出时，添加时间戳</span></span><br><span class="line">--url &lt;URL&gt;                    <span class="comment"># Spet URL to work with</span></span><br><span class="line">-U/--proxy-user &lt;user[:password]&gt;  <span class="comment"># 设置代理用户名和密码</span></span><br><span class="line">-V/--version                   <span class="comment"># 显示版本信息</span></span><br><span class="line">-X/--request &lt;<span class="built_in">command</span>&gt;         <span class="comment"># 指定什么命令</span></span><br><span class="line">-y/--speed-time                <span class="comment"># 放弃限速所要的时间。默认为30</span></span><br><span class="line">-Y/--speed-limit               <span class="comment"># 停止传输速度的限制，速度时间'秒</span></span><br><span class="line">-z/--time-cond                 <span class="comment"># 传送时间设置</span></span><br><span class="line">-0/--http1.0                   <span class="comment"># 使用HTTP 1.0</span></span><br><span class="line">-1/--tlsv1                     <span class="comment"># 使用TLSv1（SSL）</span></span><br><span class="line">-2/--sslv2                     <span class="comment"># 使用SSLv2的（SSL）</span></span><br><span class="line">-3/--sslv3                     <span class="comment"># 使用的SSLv3（SSL）</span></span><br><span class="line">--3p-quote                     <span class="comment"># like -Q for the source URL for 3rd party transfer</span></span><br><span class="line">--3p-url                       <span class="comment"># 使用url，进行第三方传送</span></span><br><span class="line">--3p-user                      <span class="comment"># 使用用户名和密码，进行第三方传送</span></span><br><span class="line">-4/--ipv4                      <span class="comment"># 使用IP4</span></span><br><span class="line">-6/--ipv6                      <span class="comment"># 使用IP6</span></span><br></pre></td></tr></table></figure><h3 id="5-3-curl-wget两种方法模拟http的get-post请求"><a href="#5-3-curl-wget两种方法模拟http的get-post请求" class="headerlink" title="5.3 curl wget两种方法模拟http的get post请求"></a>5.3 curl wget两种方法模拟http的get post请求</h3><p><strong>get请求：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用curl命令：</span></span><br><span class="line">$ curl <span class="string">"http://www.baidu.com"</span>  <span class="comment"># 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span></span><br><span class="line">$ curl -i <span class="string">"http://www.baidu.com"</span>  <span class="comment"># 显示全部信息</span></span><br><span class="line">$ curl -l <span class="string">"http://www.baidu.com"</span> <span class="comment"># 只显示头部信息</span></span><br><span class="line">$ curl -v <span class="string">"http://www.baidu.com"</span> <span class="comment"># 显示get请求全过程解析</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget命令：</span></span><br><span class="line">$ wget <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure><p><strong>post请求：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用curl命令(通过-d参数，把访问参数放在里面)：</span></span><br><span class="line">$ curl -d <span class="string">"param1=value1&amp;param2=value2"</span> <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget命令：（--post-data参数来实现）</span></span><br><span class="line">$ wget --post-data <span class="string">'user=foo&amp;password=bar'</span>  http://server.com/auth.PHP</span><br></pre></td></tr></table></figure><h2 id="6-B计划"><a href="#6-B计划" class="headerlink" title="6 B计划"></a>6 B计划</h2><h3 id="6-1-用tar归档"><a href="#6-1-用tar归档" class="headerlink" title="6.1 用tar归档"></a>6.1 用tar归档</h3><p>tar支持的参数包括： <code>A</code>、 <code>c</code>、 <code>d</code>、 <code>r</code>、 <code>u</code>、 <code>x</code>、 <code>f</code> 和 <code>v</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用tar对文件进行归档：</span></span><br><span class="line">$ tar -cf output.tar file1 file2 file3 folder1 ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用选项-t列出归档文件中所包含的文件：</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要在归档或列出归档文件列表时获知更多的细节信息，可以使用-v或-vv参数</span></span><br><span class="line">$ $ tar -tvf archive.tar</span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file1</span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file2</span><br><span class="line"><span class="comment"># 文件名必须紧跟在-f之后，而且-f应该是选项中的最后一个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向归档文件中添加文件,追加选项-r</span></span><br><span class="line">$ tar -rvf original.tar new_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的方法列出归档文件中的内容：</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档文件中提取文件或文件夹, -x 表示提取</span></span><br><span class="line">$ tar -xf archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用选项-C来指定需要将文件提取到哪个目录：</span></span><br><span class="line">$ tar -xf archive.tar -C /path/to/extraction_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过将文件名指定为命令行参数来提取特定的文件：</span></span><br><span class="line">$ tar -xvf file.tar file1 file4</span><br><span class="line"><span class="comment"># 上面的命令只提取file1和file4，忽略其他文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在tar中使用stdin和stdout</span></span><br><span class="line">$ tar cvf - files/ | ssh user@example.com <span class="string">"tar xv -C Documents/"</span></span><br><span class="line"><span class="comment"># 在上面的例子中，对files目录中的内容进行了归档并输出到stdout（由'-'指明）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接两个归档文件, -A 选项轻松地合并多个tar文件</span></span><br><span class="line">$ tar -Af file1.tar file2.tar</span><br><span class="line"><span class="comment"># 查看内容，验证操作是否成功：</span></span><br><span class="line">$ tar -tvf file1.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过检查时间戳来更新归档文件中的内容</span></span><br><span class="line"><span class="comment"># 可以用更新选项-u指明：只有比归档文件中的同名文件更新时才会被添加。</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅当filea自上次被加入archive.tar后出现了变动才对其进行追加，可以使用：</span></span><br><span class="line">$ tar -uf archive.tar filea</span><br><span class="line"><span class="comment"># 如果两个filea的时间戳相同，则什么都不会发生。</span></span><br><span class="line"><span class="comment"># 可用touch命令修改文件的时间戳，然后再用tar命令：</span></span><br><span class="line">$ tar -uvvf archive.tar filea</span><br><span class="line">-rw-r--r-- slynux/slynux 0 2010-08-14 17:53 filea</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较归档文件与文件系统中的内容, 选项 -d 可以打印出两者之间的差别：</span></span><br><span class="line">$ tar -df archive.tar</span><br><span class="line">afile: Mod time differs</span><br><span class="line">afile: Size differs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档文件中删除文件, --delete选项从给定的归档文件中删除文件</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"><span class="comment"># 删除filea：</span></span><br><span class="line">$ tar --delete --file archive.tar filea</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">fileb</span><br><span class="line">filec</span><br></pre></td></tr></table></figure><p><strong>压缩tar归档文件：</strong></p><p>归档文件通常被压缩成下列格式之一： </p><ul><li>file.tar.gz </li><li>file.tar.bz2 </li><li>file.tar.lzma </li></ul><p>不同的tar选项可以用来指定不同的压缩格式： </p><ul><li>-j 指定bunzip2格式； </li><li>-z 指定gzip格式； </li><li>–lzma 指定lzma格式。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了让tar支持根据扩展名自动进行压缩，使用 -a或 --auto-compress选项：</span></span><br><span class="line">$ tar acvf archive.tar.gz filea fileb filec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档中排除部分文件,  --exclude [PATTERN]排除匹配通配符样式的文件</span></span><br><span class="line">$ tar -cf arch.tar * --exclude <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># 样式应该使用双引号来引用，避免shell对其进行扩展。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以将需要排除的文件列表放入文件中，同时配合选项 -X：</span></span><br><span class="line">$ cat list</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">$ tar -cf arch.tar * -X list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排除版本控制目录， 可以使用tar的 --exclude-vcs选项。例如：</span></span><br><span class="line">$ tar --exclude-vcs -czvvf source_code.tar.gz eye_of_gnome_svn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印总字节数，用–totals就可以在归档完成之后打印出总归档字节数：</span></span><br><span class="line">$ tar -cf arc.tar * --exclude <span class="string">"*.txt"</span> --totals</span><br><span class="line">Total bytes written: 20480 (20KiB, 12MiB/s)</span><br></pre></td></tr></table></figure><h3 id="6-2-用cpio归档"><a href="#6-2-用cpio归档" class="headerlink" title="6.2 用cpio归档"></a>6.2 用cpio归档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试文件：</span></span><br><span class="line">$ touch file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将测试文件按照下面的方法进行归档：</span></span><br><span class="line">$ <span class="built_in">echo</span> file1 file2 file3 | cpio -ov &gt; archive.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出cpio归档文件中的内容：</span></span><br><span class="line">$ cpio -it &lt; archive.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从cpio归档文件中提取文件：</span></span><br><span class="line">$ cpio -id &lt; archive.cpio</span><br></pre></td></tr></table></figure><p>对于归档命令： </p><ul><li>-o 指定了输出； </li><li>-v 用来打印归档文件列表。 </li></ul><p>在列出给定cpio归档文件所有内容的命令中： </p><ul><li>-i 用于指定输入； </li><li>-t 表示列出归档文件中的内容。 </li></ul><p>当使用命令进行提取时， -d用来表示提取。 cpio在覆盖文件时不会发出提示。 </p><h3 id="6-3-使用gzip压缩数据"><a href="#6-3-使用gzip压缩数据" class="headerlink" title="6.3 使用gzip压缩数据"></a>6.3 使用gzip压缩数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要使用gzip压缩文件，可以使用下面的命令：</span></span><br><span class="line">$ gzip filename</span><br><span class="line">$ ls</span><br><span class="line">filename.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将gzip文件解压缩的方法如下：</span></span><br><span class="line">$ gunzip filename.gz</span><br><span class="line">$ ls</span><br><span class="line">file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩文件的属性信息：</span></span><br><span class="line">$ gzip -l test.txt.gz</span><br><span class="line">compressed uncompressed ratio uncompressed_name</span><br><span class="line">35 6 -33.3% test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip命令可以从stdin中读入文件，也可以将压缩文件写出到stdout，选项 -c用来将输出指定到stdout。</span></span><br><span class="line">$ cat file | gzip -c &gt; file.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以指定gzip的压缩级别。用 --fast或 --best选项分别提供最低或最高的压缩比。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩归档文件</span></span><br><span class="line"><span class="comment"># 方法 1</span></span><br><span class="line">$ tar -czvvf archive.tar.gz [FILES]</span><br><span class="line">或者</span><br><span class="line">$ tar -cavvf archive.tar.gz [FILES]</span><br><span class="line"><span class="comment"># 选项 -a表明从文件扩展名自动推断压缩格式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 2</span></span><br><span class="line"><span class="comment"># 首先，创建一个tar归档文件：</span></span><br><span class="line">$ tar -cvvf archive.tar [FILES]</span><br><span class="line"><span class="comment"># 压缩tar归档文件：</span></span><br><span class="line">$ gzip archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># zcat——无需解压缩，直接读取gzip格式文件</span></span><br><span class="line">$ ls</span><br><span class="line">test.gz</span><br><span class="line">$ zcat test.gz</span><br><span class="line">A <span class="built_in">test</span> file</span><br><span class="line"><span class="comment"># 文件test包含了一行文本"A test file"</span></span><br><span class="line">$ ls</span><br><span class="line">test.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩率</span></span><br><span class="line"><span class="comment"># 我们可以指定压缩率，它共有9级，其中：</span></span><br><span class="line"><span class="comment"># 1级的压缩率最低，但是压缩速度最快；</span></span><br><span class="line"><span class="comment"># 9级的压缩率最高，但是压缩速度最慢。</span></span><br><span class="line">$ gzip -5 test.img</span><br><span class="line"><span class="comment"># 这应该能在压缩速度和压缩比之间获得一个不错的平衡。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bzip2，唯一的不同在于bzip2的压缩效率比gzip更高，但花费的时间比gzip更长</span></span><br><span class="line">$ bzip2 filename</span><br><span class="line"><span class="comment"># 解压缩bzip2格式的文件：</span></span><br><span class="line">$ bunzip2 filename.bz2</span><br><span class="line"><span class="comment"># 生成tar.bz2文件并从中提取内容的方法同之前介绍的tar.gz类似：</span></span><br><span class="line">$ tar -xjvf archive.tar.bz2</span><br><span class="line"><span class="comment"># 其中-j表明该归档文件是bzip2格式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用lzma</span></span><br><span class="line"><span class="comment"># lzma是另一种压缩工具，它的压缩率甚至比gzip和bzip2更好。</span></span><br><span class="line">$ lzma filename</span><br><span class="line"><span class="comment"># 解压缩lzma文件：</span></span><br><span class="line">$ unlzma filename.lzma</span><br><span class="line"><span class="comment"># 可以使用tar命令的--lzma选项对生成的tar归档文件进行压缩或提取：</span></span><br><span class="line">$ tar -cvvf --lzma archive.tar.lzma [FILES]</span><br><span class="line">或者</span><br><span class="line">$ tar -cavvf archive.tar.lzma [FILES]</span><br><span class="line"><span class="comment"># 如果要将经过lzma压缩过的tar归档文件中的内容提取到指定的目录中，可以使用：</span></span><br><span class="line">$ tar -xvvf --lzma archive.tar.lzma -C extract_directory</span><br><span class="line"><span class="comment"># 其中， -x用于提取内容， --lzma指定使用lzma对归档文件进行解压缩。</span></span><br><span class="line"><span class="comment"># 我们也可以用：</span></span><br><span class="line">$ tar -xavvf archive.tar.lzma -C extract_directory</span><br></pre></td></tr></table></figure><h3 id="6-4-用-zip-归档和压缩"><a href="#6-4-用-zip-归档和压缩" class="headerlink" title="6.4 用 zip 归档和压缩"></a>6.4 用 zip 归档和压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对归档文件采用ZIP格式进行压缩：</span></span><br><span class="line">$ zip file.zip file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对目录和文件进行递归操作, -r 用于指定递归操作：</span></span><br><span class="line">$ zip -r archive.zip folder1 folder2</span><br><span class="line"></span><br><span class="line"><span class="comment">#  要从ZIP文件中提取内容，可以使用：</span></span><br><span class="line">$ unzip file.zip</span><br><span class="line"><span class="comment"># 在完成提取操作之后， unzip并不会删除file.zip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要更新压缩文件中的内容，使用选项 -u：</span></span><br><span class="line">$ zip file.zip -u newfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从压缩文件中删除内容，则使用-d：</span></span><br><span class="line">$ zip -d arc.zip file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩文件中的内容：</span></span><br><span class="line">$ unzip -l archive.zip</span><br></pre></td></tr></table></figure><h3 id="6-5-更快的归档工具-pbzip2"><a href="#6-5-更快的归档工具-pbzip2" class="headerlink" title="6.5 更快的归档工具 pbzip2"></a>6.5 更快的归档工具 pbzip2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩单个文件：</span></span><br><span class="line">$ pbzip2 myfile.tar</span><br><span class="line"><span class="comment"># pbzip2会自动检测系统中处理器核心的数量，然后将myfile.tar压缩成myfile.tar.bz2。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将多个文件或目录进行归档及压缩，可以使用tar配合pbzip2来实现：</span></span><br><span class="line">$ tar cf myfile.tar.bz2 --use-compress-prog=pbzip2 dir_to_compress/</span><br><span class="line">或者</span><br><span class="line">$ tar -c directory_to_compress/ | pbzip2 -c &gt; myfile.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从pbzip2格式的文件中进行提取。</span></span><br><span class="line"><span class="comment"># 如果是tar.bz2文件，我们可以一次性完成解压缩和提取工作：</span></span><br><span class="line">$ pbzip2 -dc myfile.tar.bz2 | tar x</span><br><span class="line"><span class="comment"># 如果是经过pbzip2压缩过的归档文件，可以使用：</span></span><br><span class="line">$ pbzip2 -d myfile.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动指定处理器数量, 使用pbzip2的-p选项来手动指定处理器核心的数量</span></span><br><span class="line">$ pbzip2 -p4 myfile.tar</span><br><span class="line"><span class="comment"># 上面的命令告诉pbzip2使用4个处理器核心。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定压缩比</span></span><br><span class="line"><span class="comment"># 像其他压缩工具一样，我们可以使用从1到9的选项来分别指定最快和最优的压缩比。</span></span><br></pre></td></tr></table></figure><h3 id="6-6-创建压缩文件系统"><a href="#6-6-创建压缩文件系统" class="headerlink" title="6.6 创建压缩文件系统"></a>6.6 创建压缩文件系统</h3><p>squashfs是一种具有超高压缩率的只读型文件系统，这种文件系统能够将2GB~3GB的数据压缩成一个700MB的文件。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加源目录和文件，创建一个squashfs文件：</span></span><br><span class="line">$ sudo mksquashfs /etc test.squashfs</span><br><span class="line">Parallel mksquashfs: Using 2 processors</span><br><span class="line">Creating 4.0 filesystem on test.squashfs, block size 131072.</span><br><span class="line">[=======================================] 1867/1867 100%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用环回形式挂载squashfs文件：</span></span><br><span class="line">$ mkdir /mnt/squash</span><br><span class="line">$ mount -o loop compressedfs.squashfs /mnt/squash</span><br><span class="line"><span class="comment"># 你可以访问/mnt/squashfs访问其中的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在创建squashfs文件时排除部分文件, 选项-e，将需要排除的文件列表以命令行参数的方式来指定。例如：</span></span><br><span class="line">$ sudo mksquashfs /etc test.squashfs -e /etc/passwd /etc/shadow</span><br><span class="line"><span class="comment"># 也可以将需要排除的文件名列表写入文件，然后用 -ef指定该文件：</span></span><br><span class="line">$ cat excludelist</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line">$ sudo mksquashfs /etc test.squashfs -ef excludelist</span><br></pre></td></tr></table></figure><h3 id="6-7-使用-rsync-备份系统快照"><a href="#6-7-使用-rsync-备份系统快照" class="headerlink" title="6.7 使用 rsync 备份系统快照"></a>6.7 使用 rsync 备份系统快照</h3><p>rsync可以对位于不同位置的文件和目录进行同步，它利用差异计算以及压缩技术来最小化数据传输量。 </p><p>rsync也支持压缩、加密等多种特性。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将源目录复制到目的端：</span></span><br><span class="line">$ rsync -av /home/slynux/data slynux@192.168.0.6:/home/backups/data</span><br><span class="line"><span class="comment"># 其中：</span></span><br><span class="line"> -a表示要进行归档；</span><br><span class="line"> -v表示在stdout上打印出细节信息或进度。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据备份到远程服务器或主机：</span></span><br><span class="line">$ rsync -av source_dir username@host:PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的方法将远程主机上的数据恢复到本地主机：</span></span><br><span class="line">$ rsync -av username@host:PATH destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过网络进行传输时，压缩数据能够明显改善传输效率。我们可以用rsync的选项 -z 指定在网络传输时压缩数据。例如：</span></span><br><span class="line">$ rsync -avz <span class="built_in">source</span> destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个目录中的内容同步到另一个目录：</span></span><br><span class="line">$ rsync -av /home/<span class="built_in">test</span>/ /home/backups</span><br><span class="line"><span class="comment"># 这条命令将源目录（/home/test）中的内容（不包括目录本身）复制到现有的backups目录中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在使用rsync进行归档的过程中排除部分文件</span></span><br><span class="line">$ rsync -avz /home/code/some_code /mnt/disk/backup/code --exclude <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># 或者我们可以通过一个列表文件指定需要排除的文件。</span></span><br><span class="line"><span class="comment"># 这可以利用--exclude-from FILEPATH。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在更新rsync备份时，删除不存在的文件, rsync并不会在目的端删除那些在源端已不存在的文件</span></span><br><span class="line">$ rsync -avz SOURCE DESTINATION --delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定期进行备份</span></span><br><span class="line">$ crontab -ev</span><br><span class="line"><span class="comment"># 添加上这么一行：</span></span><br><span class="line">0 */10 * * * rsync -avz /home/code user@IP_ADDRESS:/home/backups</span><br><span class="line"><span class="comment"># 上面的crontab条目将rsync调度为每10个小时运行一次。</span></span><br></pre></td></tr></table></figure><h3 id="6-8-用-fsarchiver-创建全盘镜像"><a href="#6-8-用-fsarchiver-创建全盘镜像" class="headerlink" title="6.8 用 fsarchiver 创建全盘镜像"></a>6.8 用 fsarchiver 创建全盘镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件系统/分区备份。</span></span><br><span class="line"><span class="comment"># 使用fsarchiver的savefs选项：</span></span><br><span class="line">$ fsarchiver savefs backup.fsa /dev/sda1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时备份多个分区。</span></span><br><span class="line">$ fsarchiver savefs backup.fsa /dev/sda1 /dev/sda2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份归档中恢复分区。</span></span><br><span class="line">$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1</span><br><span class="line"><span class="comment"># id=0 表 明 我 们 希 望 从 备 份 归 档 中 提 取 第 一 个 分 区 的 内 容 ， 将 其 恢 复 到 由 dest=/dev/sda1所指定的分区中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份归档中恢复多个分区。</span></span><br><span class="line"><span class="comment"># 像之前一样，使用restfs选项：</span></span><br><span class="line">$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1 id=1,dest=/dev/sdb1</span><br></pre></td></tr></table></figure><h2 id="7-无网不利"><a href="#7-无网不利" class="headerlink" title="7 无网不利"></a>7 无网不利</h2><h3 id="7-1-设置网络"><a href="#7-1-设置网络" class="headerlink" title="7.1 设置网络"></a>7.1 设置网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动设置网络接口的IP地址：</span></span><br><span class="line">$ ifconfig wlan0 192.168.0.80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用以下命令设置比IP地址的子网掩码：</span></span><br><span class="line">$ ifconfig wlan0 192.168.0.80 netmask 255.255.252.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动配置网络接口</span></span><br><span class="line">$ dhclient eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印网络接口列表</span></span><br><span class="line">$ ifconfig | cut -c-10 | tr -d <span class="string">' '</span> | tr -s <span class="string">'\n'</span></span><br><span class="line">lo</span><br><span class="line">wlan0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示IP地址</span></span><br><span class="line">$ ifconfig wlan0 | egrep -o <span class="string">"inet addr:[^ ]*"</span> | grep -o <span class="string">"[0-9.]*"</span></span><br><span class="line">192.168.0.82</span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬件地址（MAC地址）欺骗</span></span><br><span class="line">$ ifconfig eth0 hw ether 00:1c:bf:87:25:d5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 名字服务器与DNS（域名服务）</span></span><br><span class="line">$ cat /etc/resolv.conf</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line"><span class="comment"># 我们可以像下面这样手动添加名字服务器：</span></span><br><span class="line">$ <span class="built_in">echo</span> nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS查找</span></span><br><span class="line">$ host google.com</span><br><span class="line">google.com has address 64.233.181.105</span><br><span class="line">google.com has address 64.233.181.99</span><br><span class="line">google.com has address 64.233.181.147</span><br><span class="line">google.com has address 64.233.181.106</span><br><span class="line">google.com has address 64.233.181.103</span><br><span class="line">google.com has address 64.233.181.104</span><br><span class="line"></span><br><span class="line">$ nslookup google.com</span><br><span class="line">Server: 8.8.8.8</span><br><span class="line">Address: 8.8.8.8<span class="comment">#53</span></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.105</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.99</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.147</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.106</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.103</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.104</span><br><span class="line">Server: 8.8.8.8</span><br><span class="line"><span class="comment"># 上面最后一行对应着用于DNS解析的默认名字服务器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用DNS服务器，也可以为IP地址解析添加符号名，这只需要向文件 /etc/hosts中加入条目即可。</span></span><br><span class="line"><span class="comment"># 用下面的方法进行添加：</span></span><br><span class="line">$ <span class="built_in">echo</span> IP_ADDRESS symbolic_name &gt;&gt; /etc/hosts</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> 192.168.0.9 backupserver &gt;&gt; /etc/hosts</span><br><span class="line"><span class="comment"># 添加了条目之后，任何时候解析backupserver，都会返回192.168.0.9。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示路由表信息</span></span><br><span class="line">$ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref UseIface</span><br><span class="line">192.168.0.0 * 255.255.252.0 U 2 0 0wlan0</span><br><span class="line">link-local * 255.255.0.0 U 1000 0 0wlan0</span><br><span class="line">default p4.local 0.0.0.0 UG 0 0 0wlan0</span><br><span class="line"><span class="comment"># 也可以使用：</span></span><br><span class="line">$ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref Use Iface</span><br><span class="line">192.168.0.0 0.0.0.0 255.255.252.0 U 2 0 0 wlan0</span><br><span class="line">169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 wlan0</span><br><span class="line">0.0.0.0 192.168.0.4 0.0.0.0 UG 0 0 0 wlan0</span><br><span class="line"><span class="comment"># -n指定以数字形式显示地址。如果使用-n， route会以数字形式的IP地址显示每一个条目；否则，如果IP地址具有对应的DNS条目，就会显示符号形式的主机名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认网关：</span></span><br><span class="line">$ route add default gw 192.168.0.1 wlan0</span><br></pre></td></tr></table></figure><h3 id="7-2-traceroute-命令"><a href="#7-2-traceroute-命令" class="headerlink" title="7.2 traceroute 命令"></a>7.2 traceroute 命令</h3><p>traceroute，它可以显示分组途径的所有网关的地址。 traceroute信息可以帮助我们搞明白分组到达目的地需要经过多少跳（hop）。中途的网关或路由器的数量给出了一个测量网络上两个节点之间距离的度量<br>（metric）。 traceroute的输出如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ traceroute google.com</span><br><span class="line">traceroute to google.com (74.125.77.104), 30 hops max, 60 byte packets</span><br><span class="line">1 gw-c6509.lxb.as5577.net (195.26.4.1) 0.313 ms 0.371 ms 0.457 ms</span><br><span class="line">2 40g.lxb-fra.as5577.net (83.243.12.2) 4.684 ms 4.754 ms 4.823 ms</span><br><span class="line">3 de-cix10.net.google.com (80.81.192.108) 5.312 ms 5.348 ms 5.327 ms</span><br><span class="line">4 209.85.255.170 (209.85.255.170) 5.816 ms 5.791 ms 209.85.255.172</span><br><span class="line">(209.85.255.172) 5.678 ms</span><br><span class="line">5 209.85.250.140 (209.85.250.140) 10.126 ms 9.867 ms 10.754 ms</span><br><span class="line">6 64.233.175.246 (64.233.175.246) 12.940 ms 72.14.233.114</span><br><span class="line">(72.14.233.114) 13.736 ms 13.803 ms</span><br><span class="line">7 72.14.239.199 (72.14.239.199) 14.618 ms 209.85.255.166</span><br><span class="line">(209.85.255.166) 12.755 ms 209.85.255.143 (209.85.255.143) 13.803 ms</span><br><span class="line">8 209.85.255.98 (209.85.255.98) 22.625 ms 209.85.255.110</span><br><span class="line">(209.85.255.110) 14.122 ms</span><br><span class="line">*</span><br><span class="line">9 ew-in-f104.1e100.net (74.125.77.104) 13.061 ms 13.256 ms 13.484 ms</span><br></pre></td></tr></table></figure><h3 id="7-3-列出网络上所有的活动主机-fping"><a href="#7-3-列出网络上所有的活动主机-fping" class="headerlink" title="7.3 列出网络上所有的活动主机 (fping)"></a>7.3 列出网络上所有的活动主机 (fping)</h3><p>fping的选项如下： </p><ul><li>选项 -a指定打印出所有活动主机的IP地址； </li><li>选项 -u指定打印出所有无法到达的主机； </li><li>选项 -g指定从 “IP地址/子网掩码”记法或者”IP地址范围”记法中生成一组IP地址； </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ fping -a 192.160.1/24 -g</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ fping -a 192.160.1 192.168.0.255 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以用已有的命令行工具来查询网络上的主机状态：</span></span><br><span class="line">$ fping -a 192.160.1/24 -g 2&gt; /dev/null</span><br><span class="line">192.168.0.1</span><br><span class="line">192.168.0.90</span><br><span class="line"><span class="comment"># 或者，使用：</span></span><br><span class="line">$ fping -a 192.168.0.1 192.168.0.255 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;/dev/null将由于主机无法到达所产生的错误信息打印到null设备。</span></span><br><span class="line">$ fping -a 192.168.0.1 192.168.0.5 192.168.0.6</span><br><span class="line"><span class="comment"># 将IP地址作为参数传递</span></span><br><span class="line">$ fping -a &lt; ip.list</span><br><span class="line"><span class="comment"># 从文件中传递一组IP地址</span></span><br></pre></td></tr></table></figure><h3 id="7-4-ssh-命令"><a href="#7-4-ssh-命令" class="headerlink" title="7.4 ssh 命令"></a>7.4 ssh 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SSH的压缩功能,选项-C启用这一功能：</span></span><br><span class="line">$ ssh -C user@hostname COMMANDS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据重定向至远程shell命令的stdin</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'text'</span> | ssh user@remote_host <span class="string">'echo'</span></span><br><span class="line">text</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 将文件中的数据进行重定向</span></span><br><span class="line">$ ssh user@remote_host <span class="string">'echo'</span> &lt; file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在远程主机中执行图形化命令</span></span><br><span class="line"><span class="comment"># 对此，你需要像这样设置变量$DISPLAY：</span></span><br><span class="line">$ ssh user@host <span class="string">"export DISPLAY=:0 ; command1; command2"</span><span class="string">""</span></span><br><span class="line"><span class="comment"># 这将启用远程主机上的图形化输出。如果你想在本地主机上也显示图形化输出，使用SSH的X11转发选项（forwarding option）：</span></span><br><span class="line">$ ssh -X user@host <span class="string">"command1; command2</span></span><br></pre></td></tr></table></figure><h3 id="7-5-通过网络传输文件"><a href="#7-5-通过网络传输文件" class="headerlink" title="7.5 通过网络传输文件"></a>7.5 通过网络传输文件</h3><p>计算机联网的主要目的就是资源共享。在资源共享方面，使用最多的是文件共享。有多种方法可以用来在网络中传输文件。这则攻略就讨论了如何用常见的协议FTP、 SFTP、 RSYNC和SCP传输文件。 </p><p>通过FTP传输文件可以使用lftp命令，通过SSH连接传输文件可以使用sftp， RSYNC使用SSH与rsync命令， scp通过SSH进行传输。 </p><p><strong>文件传输协议（File Transfer Protocol， FTP） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要连接FTP服务器传输文件，可以使用：</span></span><br><span class="line">$ lftp username@ftphost</span><br><span class="line"><span class="comment"># 它会提示你输入密码，然后显示一个像下面那样的登录提示符：</span></span><br><span class="line">lftp username@ftphost:~&gt;</span><br></pre></td></tr></table></figure><p>你可以在提示符后输入命令，如下所示。 </p><ul><li>用cd directory改变目录。 </li><li>用lcd改变本地主机的目录。 </li><li>用mkdir创建目录。 </li><li>列出远程机器当前目录下的文件使用Is。 </li><li>用get filename下载文件：<br><code>lftp username@ftphost:~&gt; get filename</code></li><li>用put filename从当前目录上传文件：<br><code>lftp username@ftphost:~&gt; put filename</code></li><li>用quit退出lftp会话。 </li></ul><p><strong>FTP自动传输 ：</strong></p><p>ftp是另一个可用于FTP文件传输的命令。相比较而言， lftp的用法更灵活。 lftp和ftp为用户启动一个交互式会话（通过显示消息来提示用户输入）。 </p><p><strong>SFTP（Secure FTP，安全FTP） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/slynux</span><br><span class="line">$ put testfile.jpg</span><br><span class="line">$ get serverfile.jpg</span><br><span class="line"><span class="comment"># 运行sftp：</span></span><br><span class="line">$ sftp user@domainname</span><br></pre></td></tr></table></figure><p><strong>rsync命令 ：</strong></p><p>rsync广泛用于网络文件复制及系统备份。 </p><p><strong>SCP（Secure Copy Program，安全复制程序） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp filename user@remotehost:/home/path</span><br><span class="line"></span><br><span class="line">$ scp user@remotehost:/home/path/filename filename</span><br></pre></td></tr></table></figure><p>用SCP进行递归复制 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r /home/slynux user@remotehost:/home/backups</span><br><span class="line"><span class="comment"># 将目录/home/slynux递归复制到远程主机中</span></span><br><span class="line"><span class="comment"># scp的 -p 选项能够在复制文件的同时保留文件的权限和模式。</span></span><br></pre></td></tr></table></figure><h3 id="7-6-连接网线网络"><a href="#7-6-连接网线网络" class="headerlink" title="7.6 连接网线网络"></a>7.6 连接网线网络</h3><p>我们需要用ifconfig分配IP地址和子网掩码才能连接上有线网络。对于无线网络来说，还需要其他工具（如iwconfig和iwlist）来配置更多的参数。 </p><p>iwlist工具扫描并列出可用的无线网络。用下面的命令进行扫描： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ iwlist scan</span><br><span class="line">wlan0 Scan completed :</span><br><span class="line">Cell 01 - Address: 00:12:17:7B:1C:65</span><br><span class="line">Channel:11</span><br><span class="line">Frequency:2.462 GHz (Channel 11)</span><br><span class="line">Quality=33/70 Signal level=-77 dBm</span><br><span class="line">                    Encryption key:on</span><br><span class="line">ESSID:<span class="string">"model-2"</span></span><br></pre></td></tr></table></figure><h3 id="7-7-在本地挂载点上挂载远程驱动器"><a href="#7-7-在本地挂载点上挂载远程驱动器" class="headerlink" title="7.7 在本地挂载点上挂载远程驱动器"></a>7.7 在本地挂载点上挂载远程驱动器</h3><p>sshfs允许你将远程文件系统挂载到本地挂载点上。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将位于远程主机上的文件系统挂载到本地挂载点上：</span></span><br><span class="line">$ sshfs -o allow_other user@remotehost:/home/path /mnt/mountpoint</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成任务后，可用下面的方法卸载：</span></span><br><span class="line">$ umount /mnt/mountpoint</span><br></pre></td></tr></table></figure><h3 id="7-8-网络流量与端口分析"><a href="#7-8-网络流量与端口分析" class="headerlink" title="7.8 网络流量与端口分析"></a>7.8 网络流量与端口分析</h3><p>列出系统中的开放端口以及运行在端口上的服务的详细信息，可以使用以下命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要列出本地主机当前的开放端口，可以使用：</span></span><br><span class="line">$ lsof -i | grep <span class="string">":[0-9]\+-&gt;"</span> -o | grep <span class="string">"[0-9]\+"</span> -o | sort | uniq</span><br></pre></td></tr></table></figure><p>用netstat查看开放端口与服务 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -tnp列出开放端口与服务：</span></span><br><span class="line">$ netstat -tnp</span><br></pre></td></tr></table></figure><h3 id="7-9-创建套接字"><a href="#7-9-创建套接字" class="headerlink" title="7.9 创建套接字"></a>7.9 创建套接字</h3><p>最简单的方法就是使用netcat命令（或nc）。我们需要两个套接字：一个用来侦听，一个用来连接。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置侦听套接字：</span></span><br><span class="line">$ nc -l 1234</span><br><span class="line"><span class="comment"># 这会在本地主机的端口1234上创建一个侦听套接字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到该套接字：</span></span><br><span class="line">$ nc HOST 1234</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想发送消息，只需要在执行第2步操作的主机终端中输入信息并按回车键就行了。消息会出现在执行第1步操作的主机终端中。</span></span><br></pre></td></tr></table></figure><p>在网络上进行快速文件复制 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在接收端执行下列命令：</span></span><br><span class="line">$ nc -l 1234 &gt; destination_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在发送端执行下列命令：</span></span><br><span class="line">$ nc HOST 1234 &lt; source_filename</span><br></pre></td></tr></table></figure><h3 id="7-10-iptables防火墙设置"><a href="#7-10-iptables防火墙设置" class="headerlink" title="7.10 iptables防火墙设置"></a>7.10 iptables防火墙设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阻塞发送到特定IP地址的流量：</span></span><br><span class="line">$ iptables -A OUTPUT -d 8.8.8.8 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞发送到特定端口的流量：</span></span><br><span class="line">$ iptables -A OUTPUT -p tcp -dport 21 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment">#  iptables中的第一个选项-A表明向链（chain）中添加一条新的规则，该规则由后续参数给出。OUTPUT链，它可以对所有出站（outgoing）的流量进行控制。-d指定了所要匹配的分组目的地址。-j来使iptables丢弃（DROP）符合条件的分组。-p指定该规则是适用于TCP， -dport指定了对应的端口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除对iptables链所做出的所有改动。</span></span><br><span class="line">$ iptables --flush</span><br></pre></td></tr></table></figure><h2 id="8-当个好管家"><a href="#8-当个好管家" class="headerlink" title="8 当个好管家"></a>8 当个好管家</h2><h3 id="8-1-监视磁盘使用情况"><a href="#8-1-监视磁盘使用情况" class="headerlink" title="8.1 监视磁盘使用情况"></a>8.1 监视磁盘使用情况</h3><p><code>df</code> 是disk free的缩写， <code>du</code> 是disk usage的缩写。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出某个文件（或多个文件）占用的磁盘空间：</span></span><br><span class="line">$ du file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要获得某个目录中所有文件的磁盘使用情况，并在每一行中显示各个文件的磁盘占用详情，可以使用：</span></span><br><span class="line">$ du -a DIRECTORY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以KB、 MB或块（block）为单位显示磁盘使用情况</span></span><br><span class="line">$ du -h FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示磁盘使用总计, -c 可以输出作为命令参数的所有文件和目录的磁盘使用情况</span></span><br><span class="line">$ du -c process_log.shpcpu.sh</span><br><span class="line">4 process_log.sh</span><br><span class="line">4 pcpu.sh</span><br><span class="line">8 total</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s（summarize，合计）则只输出合计数据。它可以配合 -h打印出人们易读的格式。</span></span><br><span class="line">$ du -sh slynux</span><br><span class="line">680K slynux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以字节（默认输出）为单位的文件大小：</span></span><br><span class="line">$ du -b FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以KB为单位的文件大小：</span></span><br><span class="line">$ du -k FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以MB为单位的文件大小：</span></span><br><span class="line">$ du -m FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以指定块为单位的文件大小：</span></span><br><span class="line">$ du -B BLOCK_SIZE FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从磁盘使用统计中排除部分文件</span></span><br><span class="line">$ du --exclude <span class="string">"*.txt"</span> FILES(s)</span><br><span class="line"><span class="comment"># 排除所有的.txt文件</span></span><br><span class="line">$ du --exclude-from EXCLUDE.txt DIRECTORY</span><br><span class="line"><span class="comment"># EXCLUDE.txt包含了需要排除的文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --max-depth指定du应该遍历的目录层次的最大深度。</span></span><br><span class="line">$ du --max-depth 2 DIRECTORY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出指定目录中最大的10个文件</span></span><br><span class="line">$ du -ak /home/slynux | sort -nrk 1 | head -n 4</span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> du -k &#123;&#125; \; | sort -nrk 1 | head</span><br></pre></td></tr></table></figure><p>du提供磁盘使用情况信息，而df提供磁盘可用空间信息。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem Size Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1 9.2G 2.2G 6.6G 25% /</span><br><span class="line">none 497M 240K 497M 1% /dev</span><br><span class="line">none 502M 168K 501M 1% /dev/shm</span><br><span class="line">none 502M 88K 501M 1% /var/run</span><br><span class="line">none 502M 0 502M 0% /var/lock</span><br><span class="line">none 502M 0 502M 0% /lib/init/rw</span><br><span class="line">none 9.2G 2.2G 6.6G 25% /var/lib/ureadahead/debugfs</span><br></pre></td></tr></table></figure><h3 id="8-2-计算命令执行时间"><a href="#8-2-计算命令执行时间" class="headerlink" title="8.2 计算命令执行时间"></a>8.2 计算命令执行时间</h3><ul><li>real: %e </li><li>user: %U </li><li>sys: %S </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ time COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用选项-o filename将相关的时间统计信息写入文件：</span></span><br><span class="line">$ /usr/bin/time -o output.txt COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将命令执行时间添加到文件而不影响其原有内容，使用选项-a以及-o：</span></span><br><span class="line">$ /usr/bin/time -a -o output.txt COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建格式化输出：</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Time: %U"</span> -a -o timing.log uname</span><br><span class="line">Linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用错误重定向操作符（2&gt;）对时间信息重定向。</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Time: %U"</span> uname&gt; command_output.txt 2&gt;time.log</span><br><span class="line">$ cat time.log</span><br><span class="line">Time: 0.00</span><br><span class="line">$ cat command_output.txt</span><br><span class="line">Linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用参数%Z显示系统页面大小：</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Page size: %Z bytes"</span> ls&gt; /dev/null</span><br><span class="line">Page size: 4096 bytes</span><br></pre></td></tr></table></figure><p>三种不同类型的时：</p><ul><li>Real时间指的是挂钟时间（wall clock time），也就是命令从开始执行到结束的时间。这段时间包括其他进程所占用的时间片（time slice）以及进程被阻塞时所花费的时间（例如，为等待I/O操作完成所用的时间）。 </li><li>User时间是指进程花费在用户模式（内核之外）中的CPU时间。这是唯一真正用于执行进程所花费的时间。执行其他进程以及花费在阻塞状态中的时间并没有计算在内。 </li><li>Sys时间是指进程花费在内核中的CPU时间。它代表在内核中执行系统调用所使用的时间，这和库代码（library code）不同，后者仍旧运行在用户空间。与“user时间”类似，这也是真正由进程使用的CPU时间。 </li></ul><p>time命令 一些可以使用的参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>%C</td><td>进行计时的命令名称以及命令行参数</td></tr><tr><td>%D</td><td>进程非共享数据区域的大小，以KB为单位</td></tr><tr><td>%E</td><td>进程使用的real时间（挂钟时间），显示格式为[小时:]分钟:秒</td></tr><tr><td>%x</td><td>命令的退出状态</td></tr><tr><td>%k</td><td>进程接收到的信号数量</td></tr><tr><td>%W</td><td>进程被交换出主存的次数</td></tr><tr><td>%Z</td><td>系统的页面大小。这是一个系统常量，但在不同的系统中，这个常量值也不同</td></tr><tr><td>%P</td><td>进程所获得的CPU时间百分比。这个值等于user+system时间除以总运行时间。结果以百分比形式显示</td></tr><tr><td>%K</td><td>进程的平均总（data+stack+text）内存使用量，以KB为单位</td></tr><tr><td>%w</td><td>进程主动进行上下文切换的次数，例如等待I/O操作完成</td></tr><tr><td>%c</td><td>进程被迫进行上下文切换的次数（由于时间片到期）</td></tr></tbody></table><h3 id="8-3-收集与当前登录用户、启动日志及启动故障的相关信息"><a href="#8-3-收集与当前登录用户、启动日志及启动故障的相关信息" class="headerlink" title="8.3 收集与当前登录用户、启动日志及启动故障的相关信息"></a>8.3 收集与当前登录用户、启动日志及启动故障的相关信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前登录用户的相关信息：</span></span><br><span class="line">$ who</span><br><span class="line">slynux pts/0 2010-09-29 05:24 (slynuxs-macbook-pro.local)</span><br><span class="line">slynux tty7 2010-09-29 07:08 (:0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得有关登录用户更详细的信息：</span></span><br><span class="line">$ w</span><br><span class="line">  07:09:05 up 1:45, 2 users, load average: 0.12, 0.06, 0.02</span><br><span class="line">USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</span><br><span class="line">slynux pts/0 slynuxs 05:24 0.00s 0.65s 0.11s sshd: slynux</span><br><span class="line">slynux tty7 :007:08 1:45m 3.28s 0.26s gnome-session</span><br><span class="line"><span class="comment"># 第一行列出了当前时间，系统运行时间，当前登录的用户数量以及过去的1分钟、 5分钟、 15分钟内的系统平均负载。接下来的每一行显示了每一个登录用户的详细信息，其中包括登录名、 TTY、远程主机、登录时间、空闲时间、自该用户登录后所使用的总CPU时间、当前运行进程所使用的CPU时间以及进程所对应的命令行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录主机的用户列表：</span></span><br><span class="line">$ users</span><br><span class="line">slynux slynux slynux hacker</span><br><span class="line">$ users | tr <span class="string">' '</span> <span class="string">'\n'</span> | sort | uniq</span><br><span class="line">slynux</span><br><span class="line">hacker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统已经加电运行了多长时间：</span></span><br><span class="line">$ uptime</span><br><span class="line">21:44:33 up 3:17, 8 users, load average: 0.09, 0.14, 0.09</span><br><span class="line">$ uptime | grep -Po <span class="string">'\d&#123;2&#125;\:\d&#123;2&#125;\:\d&#123;2&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取上一次启动以及用户登录会话的信息：</span></span><br><span class="line">$ last</span><br><span class="line">slynux tty7 :0 Tue Sep 28 18:27 still logged <span class="keyword">in</span></span><br><span class="line">reboot system boot 2.6.32-21-generic Tue Sep 28 18:10 - 21:46 (03:35)</span><br><span class="line">slynux pts/0 :0.0 Tue Sep 28 05:31 - crash (12:39)</span><br><span class="line"><span class="comment"># last命令可以提供登录会话信息。它实际上是一个系统登录日志，包括了登录tty、登录时间、状态等信息。</span></span><br><span class="line"><span class="comment"># last命令以日志文件/var/log/wtmp作为输入日志数据。它也可以用选项-f明确地指定日志文件。例如：</span></span><br><span class="line">$ last -f /var/<span class="built_in">log</span>/wtmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个用户登录会话的信息：</span></span><br><span class="line">$ last USER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取重启会话（reboot session）信息：</span></span><br><span class="line">$ last reboot</span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 18:10 - 21:48 (03:37)</span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 05:14 - 21:48 (16:33)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取失败的用户登录会话信息：</span></span><br><span class="line">$ lastb</span><br><span class="line"><span class="built_in">test</span> tty8 :0 Wed Dec 15 03:56 - 03:56 (00:00)</span><br><span class="line">slynux tty8 :0 Wed Dec 15 03:55 - 03:55 (00:00)</span><br></pre></td></tr></table></figure><h3 id="8-4-使用-watch-监视命令输出"><a href="#8-4-使用-watch-监视命令输出" class="headerlink" title="8.4 使用 watch 监视命令输出"></a>8.4 使用 watch 监视命令输出</h3><p>watch命令可以用来在终端中以固定的间隔监视命令输出。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ watch ls</span><br><span class="line"></span><br><span class="line">$ watch <span class="string">'ls -l | grep "^d"'</span></span><br><span class="line"><span class="comment"># 只列出目录</span></span><br><span class="line"><span class="comment"># 命令默认每2秒更新一次输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -n SECOND指定更新输出的时间间隔。例如：</span></span><br><span class="line">$ watch -n 5 <span class="string">'ls -l'</span></span><br><span class="line"><span class="comment"># 以5秒为间隔，监视ls -l的输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 突出标示watch输出中的差异, -d 可以启用这一功能：</span></span><br><span class="line">$ watch -d <span class="string">'COMMANDS'</span></span><br></pre></td></tr></table></figure><h3 id="8-5-用-logrotate-管理日志文件"><a href="#8-5-用-logrotate-管理日志文件" class="headerlink" title="8.5 用 logrotate 管理日志文件"></a>8.5 用 logrotate 管理日志文件</h3><p>用一种被称为轮替（rotation）的技术来限制日志文件的体积，一旦它超过了限定的大小，就对其内容进行抽取（strip），同时将 日志文件中的旧条目存储到日志目录中的归档文件内。旧的日志文件就会得以保存以便随后参阅。 </p><p><code>logrotate</code> 的配置目录位于/etc/logrotate.d。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/logrotate.d/program</span><br><span class="line">/var/<span class="built_in">log</span>/program.log &#123;</span><br><span class="line">missingok</span><br><span class="line">notifempty</span><br><span class="line">size 30k</span><br><span class="line">compress</span><br><span class="line">weekly</span><br><span class="line">rotate 5</span><br><span class="line">create 0600 root root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中各个参数的含义：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>missingok</td><td>如果日志文件丢失，则忽略；然后返回（不对日志文件进行轮替）</td></tr><tr><td>notifempty</td><td>仅当源日志文件非空时才对其进行轮替</td></tr><tr><td>size 30k</td><td>限制实施轮替的日志文件的大小。可以用1M表示1MB</td></tr><tr><td>compress</td><td>允许用gzip压缩较旧的日志</td></tr><tr><td>weekly</td><td>指定进行轮替的时间间隔。可以是weekly、 yearly或daily</td></tr><tr><td>rotate 5</td><td>这是需要保留的旧日志文件的归档数量。在这里指定的是5，所以这些文件名将会是program.log.1.gz、 program.log.2.gz等直到program.log.5.gz</td></tr><tr><td>create 0600 root root</td><td>指定所要创建的归档文件的模式、用户以及用户组</td></tr></tbody></table><h3 id="8-6-用-syslog-记录日志"><a href="#8-6-用-syslog-记录日志" class="headerlink" title="8.6 用 syslog 记录日志"></a>8.6 用 syslog 记录日志</h3><p>每一个标准应用进程都可以利用syslog记录日志信息。 </p><p>使用命令logger通过syslogd记录日志。 </p><p>Linux中一些重要的日志文件 ：</p><table><thead><tr><th>日志文件</th><th>描述</th></tr></thead><tbody><tr><td>/var/log/boot.log</td><td>系统启动信息</td></tr><tr><td>/var/log/httpd</td><td>Apache Web服务器日志</td></tr><tr><td>/var/log/messages</td><td>发布内核启动信息</td></tr><tr><td>/var/log/auth.log</td><td>用户认证日志</td></tr><tr><td>/var/log/dmesg</td><td>系统启动信息</td></tr><tr><td>/var/log/mail.log</td><td>邮件服务器日志</td></tr><tr><td>/var/log/Xorg.0.log</td><td>X服务器日志</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向系统日志文件/var/log/message中写入日志信息：</span></span><br><span class="line">$ logger This is a <span class="built_in">test</span> <span class="built_in">log</span> line</span><br><span class="line">$ tail -n 1 /var/<span class="built_in">log</span>/messages</span><br><span class="line">Sep 29 07:47:44 slynux-laptop slynux: This is a <span class="built_in">test</span> <span class="built_in">log</span> line</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果要记录特定的标记（tag），可以使用：</span></span><br><span class="line">$ logger -t TAG This is a message</span><br><span class="line">$ tail -n 1 /var/<span class="built_in">log</span>/messages</span><br><span class="line">Sep 29 07:48:42 slynux-laptop TAG: This is a message</span><br><span class="line"><span class="comment"># 但是当logger发送消息时，它用标记字符串来确定应该记录到哪一个日志文件中。 syslogd使用与日志相关联的TAG来决定应该将其记录到哪一个文件中。你可以从/etc/rsyslog.d/目录下的配置文件中看到标记字符串以及与其相关联的日志文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将另一个日志文件的最后一行记录到系统日志中，可以使用：</span></span><br><span class="line">$ logger -f /var/<span class="built_in">log</span>/source.log</span><br></pre></td></tr></table></figure><h3 id="8-7-通过监视用户登录找出入侵者"><a href="#8-7-通过监视用户登录找出入侵者" class="headerlink" title="8.7 通过监视用户登录找出入侵者"></a>8.7 通过监视用户登录找出入侵者</h3><p>入侵者定义为：屡次试图登入系统达两分钟以上，并且期间的登录过程全部失败。凡是这类用户都应该被检测出来并生成包含以下细节信息的报告： </p><ul><li>试图登录的账户 </li><li>试图登录的次数 </li><li>攻击者的IP地址 </li><li>IP地址所对应的主机 </li><li>进行登录的时间段 </li></ul><p>为了处理SSH登录失败的情况，还得知道用户认证会话日志会被记录在日志文件/var/log/auth.log中。脚本需要扫描这个日志文件来检测出失败的登录信息，执行各种检查来获取所需要的数据。我们可以用host命令找出IP地址所对应的主机。 </p><h3 id="8-8-监视磁盘活动"><a href="#8-8-监视磁盘活动" class="headerlink" title="8.8 监视磁盘活动"></a>8.8 监视磁盘活动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互式监视, iotop的-o选项只显示出那些正在进行I/O活动的进程：</span></span><br><span class="line">$ iotop -o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于shell脚本的非交互式用法：</span></span><br><span class="line">$ iotop -b -n 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视特定进程</span></span><br><span class="line">$ iotop -p PID</span><br></pre></td></tr></table></figure><h3 id="8-9-检查磁盘及文件系统错误"><a href="#8-9-检查磁盘及文件系统错误" class="headerlink" title="8.9 检查磁盘及文件系统错误"></a>8.9 检查磁盘及文件系统错误</h3><p>使用fsck的各种选项对文件系统错误进行检查和修复。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要检查分区或文件系统的错误，只需要将路径作为fsck的参数：</span></span><br><span class="line">$ fsck /dev/sdb3</span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">e2fsck 1.42.5 (29-Jul-2012)</span><br><span class="line">HDD2 has been mounted 26 <span class="built_in">times</span> without being checked, check forced.</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">HDD2: 75540/16138240 files (0.7% non-contiguous), 48756390/64529088 blocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查/etc/fstab中所配置的所有文件系统：</span></span><br><span class="line">$ fsck -A</span><br><span class="line"><span class="comment"># 该命令会依次检查/etc/fstab中列出的文件系统。 fstab文件对磁盘及其挂载点之间的映射关系进行了配置，以便于更便捷地挂载文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定fsck自动修复错误，无需询问是否进行修复：</span></span><br><span class="line">$ fsck -a /dev/sda2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟fsck要执行的操作：</span></span><br><span class="line">$ fsck -AN</span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /] fsck.ext4 /dev/sda8</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /home] fsck.ext4 /dev/sda7</span><br><span class="line">[/sbin/fsck.ext3 (1) -- /media/Data] fsck.ext3 /dev/sda6</span><br></pre></td></tr></table></figure><h2 id="9-管理重任"><a href="#9-管理重任" class="headerlink" title="9 管理重任"></a>9 管理重任</h2><h3 id="9-1-收集进程信息"><a href="#9-1-收集进程信息" class="headerlink" title="9.1 收集进程信息"></a>9.1 收集进程信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了包含更多的信息，可以使用-f（表示full）来显示多列，如下所示：</span></span><br><span class="line">$ ps -f</span><br><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">slynux 1220 1219 0 18:18 pts/0 00:00:00 -bash</span><br><span class="line">slynux 1587 1220 0 18:59 pts/0 00:00:00 ps -f</span><br><span class="line"><span class="comment"># 使用选项 -e（every）。选项-ax（all）也可以生成同样的输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行如下命令之一： ps –e， ps –ef， ps -ax或ps –axf。</span></span><br><span class="line">$ ps -e | head</span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1 ? 00:00:00 init</span><br><span class="line">2 ? 00:00:00 kthreadd</span><br><span class="line">3 ? 00:00:00 migration/0</span><br><span class="line">4 ? 00:00:00 ksoftirqd/0</span><br><span class="line">5 ? 00:00:00 watchdog/0</span><br><span class="line">6 ? 00:00:00 events/0</span><br><span class="line">7 ? 00:00:00 cpuset</span><br><span class="line">8 ? 00:00:00 khelper</span><br><span class="line">9 ? 00:00:00 netns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 -o 来指定想要显示的列，以便只打印出我们需要的内容。</span></span><br><span class="line"><span class="comment"># -o 的参数以逗号操作符（,）作为定界符。值得注意的是，逗号操作符与它分隔的参数之间是没有空格的。</span></span><br><span class="line"><span class="comment"># -e和过滤器结合使用没有任何实际效果，依旧会显示所有的进程。</span></span><br><span class="line"><span class="comment"># 示例如下，其中comm表示COMMAND， pcpu表示CPU占用率：</span></span><br><span class="line">$ ps -eo comm,pcpu | head</span><br><span class="line">COMMAND %CPU</span><br><span class="line">init 0.0</span><br><span class="line">kthreadd 0.0</span><br><span class="line">migration/0 0.0</span><br><span class="line">ksoftirqd/0 0.0</span><br><span class="line">watchdog/0 0.0</span><br><span class="line">events/0 0.0</span><br><span class="line">cpuset 0.0</span><br><span class="line">khelper 0.0</span><br><span class="line">netns 0.0</span><br></pre></td></tr></table></figure><p>选项-o可以使用不同的参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pcpu</td><td>CPU占用率</td></tr><tr><td>pid</td><td>进程ID</td></tr><tr><td>ppid</td><td>父进程ID</td></tr><tr><td>pmem</td><td>内存使用率</td></tr><tr><td>comm</td><td>可执行文件名</td></tr><tr><td>cmd</td><td>简单命令</td></tr><tr><td>user</td><td>启动进程的用户</td></tr><tr><td>nice</td><td>优先级</td></tr><tr><td>time</td><td>累计的CPU时间</td></tr><tr><td>etime</td><td>进程启动后流逝的时间</td></tr><tr><td>tty</td><td>所关联的TTY设备</td></tr><tr><td>euid</td><td>有效用户ID</td></tr><tr><td>stat</td><td>进程状态</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top, 默认会输出一个占用CPU最多的进程列表。输出结果每隔几秒就会更新。</span></span><br><span class="line">$ top</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据参数对ps输出进行排序</span></span><br><span class="line">$ ps -eo comm,pcpu --sort -pcpu | head</span><br><span class="line">COMMAND %CPU</span><br><span class="line">Xorg 0.1</span><br><span class="line">hald-addon-stor 0.0</span><br><span class="line">ata/0 0.0</span><br><span class="line">scsi_eh_0 0.0</span><br><span class="line">gnome-settings- 0.0</span><br><span class="line">init 0.0</span><br><span class="line">hald 0.0</span><br><span class="line">pulseaudio 0.0</span><br><span class="line">gdm-simple-gree 0.0</span><br><span class="line">$ ps -eo comm,pid,pcpu,pmem | grep bash</span><br><span class="line">bash 1255 0.0 0.3</span><br><span class="line">bash 1680 5.5 0.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出给定命令名所对应的进程ID，在参数后加上=就可以移除列名。</span></span><br><span class="line">$ ps -C bash -o pid=</span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line">$ pgrep bash</span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用换行符作为定界符，而是要自行指定可以像下面这样：</span></span><br><span class="line">$ pgrep bash -d <span class="string">":"</span></span><br><span class="line">1255:1680</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定进程的用户（拥有者）列表：</span></span><br><span class="line">$ pgrep -u root,slynux COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据真实用户或ID以及有效用户或ID过滤ps输出</span></span><br><span class="line"> 用 -u EUSER1,EUSER2 …，指定有效用户列表；</span><br><span class="line"> 用 -U RUSER1,RUSER2 …，指定真实用户列表</span><br><span class="line">$ ps -u root -U root -o user,pcpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用TTY过滤ps输出, 可以通过指定进程所属的TTY选择ps的输出。用选项 -t指定TTY列表：</span></span><br><span class="line">$ ps -t pts/0,pts/1</span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1238 pts/0 00:00:00 bash</span><br><span class="line">1835 pts/1 00:00:00 bash</span><br><span class="line">1864 pts/0 00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程线程的相关信息</span></span><br><span class="line"><span class="comment"># 通常与进程线程相关的信息在ps输出中是看不到的。我们可以用选项 –L 在ps输出中显示线程的相关信息。这会显示出两列： NLWP和NLP。 NLWP是进程的线程数量， NLP是ps输出中每个条目的线程ID。例如：</span></span><br><span class="line">$ ps -eLf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出宽度以及所要显示的列</span></span><br><span class="line"><span class="comment"># 可以按照你自己的使用方式来进行应用。尝试以下选项:</span></span><br><span class="line"> -f ps –ef</span><br><span class="line"> u ps -e u</span><br><span class="line"> ps ps -e w（w表示宽松输出）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示进程的环境变量</span></span><br><span class="line"><span class="comment"># 了解某个进程依赖哪些环境变量，这类信息我们通常都用得着。进程的运行方式可能极其依赖某组环境变量。我们可以利用环境变量调试并修复与进程相关的问题。</span></span><br><span class="line">$ ps -eo pid,cmd e | tail -n 3</span><br><span class="line">1162 hald-addon-acpi: listening on acpid socket /var/run/acpid.socket</span><br><span class="line">1172 sshd: slynux [priv]</span><br><span class="line">1237 sshd: slynux@pts/0</span><br><span class="line">1238 -bash USER=slynux LOGNAME=slynux HOME=/home/slynux</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</span><br><span class="line">MAIL=/var/mail/slynux SHELL=/bin/bash SSH_CLIENT=10.211.55.2 49277 22</span><br><span class="line">SSH_CONNECTION=10.211.55.2 49277 10.211.55.4 22 SSH_TTY=/dev/pts/0 TERM=xterm-color</span><br><span class="line">LANG=en_IN XDG_SESSION_COOKIE=d1e96f5cc8a7a3bc3a0a73e44c95121a-1286499339.</span><br><span class="line">592429-1573657095</span><br></pre></td></tr></table></figure><h3 id="9-2-which、-whereis、-file、-whatis与平均负载"><a href="#9-2-which、-whereis、-file、-whatis与平均负载" class="headerlink" title="9.2 which、 whereis、 file、 whatis与平均负载"></a>9.2 which、 whereis、 file、 whatis与平均负载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># which, which命令用来找出某个命令的位置。</span></span><br><span class="line">$ <span class="built_in">which</span> ls</span><br><span class="line">/bin/ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis</span></span><br><span class="line"><span class="comment"># whereis与which命令类似，但它不仅返回命令的路径，还能够打印出其对应的命令手册的位置以及命令源代码的路径（如果有的话）</span></span><br><span class="line">$ whereis ls</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># file</span></span><br><span class="line">$ file FILENAME</span><br><span class="line"><span class="comment"># 该命令会打印出与该文件类型相关的细节信息。</span></span><br><span class="line">$ file /bin/ls</span><br><span class="line">/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked</span><br><span class="line">(uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.15, stripped</span><br><span class="line"></span><br><span class="line"><span class="comment"># whatis, whatis命令会输出作为参数的命令的简短描述信息。</span></span><br><span class="line">$ whatis ls</span><br><span class="line">ls (1) - list directory contents</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平均负载</span></span><br><span class="line">$ uptime</span><br><span class="line">12:40:53 up 6:16, 2 users, load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure><h3 id="9-3-杀死进程以及发送或响应信号"><a href="#9-3-杀死进程以及发送或响应信号" class="headerlink" title="9.3 杀死进程以及发送或响应信号"></a>9.3 杀死进程以及发送或响应信号</h3><p>信号是Linux中的一种进程间通信机制。 当进程接收到一个信号时，它会通过执行对应的信号处理程序（signal handler）来进行响应。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有可用的信号：</span></span><br><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止进程：</span></span><br><span class="line">$ <span class="built_in">kill</span> PROCESS_ID_LIST</span><br><span class="line"><span class="comment"># kill命令默认发出一个TERM信号。进程ID列表使用空格作为进程ID之间的定界符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要通过kill命令向进程发送指定的信号，可以使用：</span></span><br><span class="line">$ <span class="built_in">kill</span> -s SIGNAL PID</span><br><span class="line"><span class="comment"># 参数SIGNAL要么是信号名称，要么是信号编号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们经常要强行杀死进程，可以使用：</span></span><br><span class="line">$ <span class="built_in">kill</span> -s SIGKILL PROCESS_ID</span><br><span class="line">或者</span><br><span class="line">$ <span class="built_in">kill</span> -9 PROCESS_ID</span><br></pre></td></tr></table></figure><p>常用到的信号量：</p><ul><li>SIGHUP 1——对控制进程或终端的终结进行挂起检测（hangup detection）</li><li>SIGINT 2——当按下Ctrl + C时发送该信号 </li><li>SIGKILL 9——用于强行杀死进程 </li><li>SIGTERM 15——默认用于终止进程 </li><li>SIGTSTP 20——当按下Ctrl + Z时发送该信号 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># killall命令通过命令名终止进程：</span></span><br><span class="line">$ killall process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称向进程发送信号：</span></span><br><span class="line">$ killall -s SIGNAL process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称强行杀死进程：</span></span><br><span class="line">$ killall -9 process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># pkill命令和kill命令类似，不过默认情况下pkill接受的是进程名，而非进程ID。例如：</span></span><br><span class="line">$ pkill process_name</span><br><span class="line">$ pkill -s SIGNAL process_name</span><br><span class="line"><span class="comment"># pkill不支持信号名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕捉并响应信号</span></span><br><span class="line"><span class="comment"># trap命令在脚本中用来为信号分配信号处理程序。</span></span><br><span class="line">$ <span class="built_in">trap</span> <span class="string">'signal_handler_function_name'</span> SIGNAL LIST</span><br></pre></td></tr></table></figure><h3 id="9-4-向用户终端发送消息"><a href="#9-4-向用户终端发送消息" class="headerlink" title="9.4 向用户终端发送消息"></a>9.4 向用户终端发送消息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wall命令用来向当前所有登录用户的终端写入消息。</span></span><br><span class="line">$ cat message | wall</span><br><span class="line">或者</span><br><span class="line">$ wall&lt; message</span><br><span class="line">Broadcast Message from slynux@slynux-laptop</span><br><span class="line">(/dev/pts/1) at 12:54 ...</span><br><span class="line">This is a messag</span><br></pre></td></tr></table></figure><h3 id="9-5-采集系统信息"><a href="#9-5-采集系统信息" class="headerlink" title="9.5 采集系统信息"></a>9.5 采集系统信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印当前系统的主机名：</span></span><br><span class="line">$ hostname</span><br><span class="line">或者</span><br><span class="line">$ uname -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印Linux内核版本、硬件架构等详细信息：</span></span><br><span class="line">$ uname -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内核发行版本：</span></span><br><span class="line">$ uname -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印主机类型：</span></span><br><span class="line">$ uname -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印CPU相关信息：</span></span><br><span class="line">$ cat /proc/cpuinfo</span><br><span class="line"><span class="comment"># 获取处理器名称：</span></span><br><span class="line">$ cat /proc/cpuinfo | sed -n 5p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内存的详细信息：</span></span><br><span class="line">$ cat /proc/meminfo</span><br><span class="line"><span class="comment"># 打印系统可用内存总量：</span></span><br><span class="line">$ cat /proc/meminfo | head -1</span><br><span class="line">MemTotal: 1026096 kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出系统的分区信息：</span></span><br><span class="line">$ cat /proc/partitions</span><br><span class="line">或者</span><br><span class="line">$ fdisk -l <span class="comment">#如果没有输出，切换到root用户执行该命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取系统的详细信息：</span></span><br><span class="line">$ lshw <span class="comment">#建议以root用户来执行</span></span><br></pre></td></tr></table></figure><h3 id="9-6-使用-proc-采集信息"><a href="#9-6-使用-proc-采集信息" class="headerlink" title="9.6 使用 proc 采集信息"></a>9.6 使用 proc 采集信息</h3><p>以Bash为例，它的进程ID是4295（pgrep bash），那么就会有一个对应的目录/proc/4295。进程对应的目录中包含了大量有关进程的信息。 /proc/PID中一些重要的文件如下所示。 </p><ul><li><p>environ：包含与进程相关的环境变量。使用cat /proc/4295/environ，可以显示所有传递给该进程的环境变量 </p></li><li><p>cwd： 是一个到进程工作目录（working directory）的符号链接 </p></li><li><p>exe：是一个到当前进程所对应的可执行文件的符号链接 </p><p>$ readlink /proc/4295/exe<br>/bin/bash</p></li><li><p>fd：包含了进程所使用的文件描述符 </p></li></ul><h3 id="9-7-用-cron-进行调度"><a href="#9-7-用-cron-进行调度" class="headerlink" title="9.7 用 cron 进行调度"></a>9.7 用 cron 进行调度</h3><p><strong>crontab任务配置基本格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  *　 *　 *　   *　　command</span><br><span class="line">分钟(0-59)　小时(0-23)　日期(1-31)　 月份(1-12)　星期(0-6,0代表星期天)　  命令</span><br></pre></td></tr></table></figure><p>cron表中的每一个条目都由6部分组成，并按照下列顺序排列： </p><ul><li>分钟（0～59） </li><li>小时（0～23） </li><li>天（1～31） </li><li>月份（1～12） </li><li>工作日（0～6） </li><li>命令（在指定时间执行的脚本或命令） </li></ul><p>星号（*）指定命令应该在每个时间段执行。 </p><p>除了数字还有几个个特殊的符号就是 <code>&quot;*&quot;</code> 、<code>&quot;/&quot;</code> 和 <code>&quot;-&quot;</code> 、<code>&quot;,&quot;</code> ，<code>*</code> 代表所有的取值范围内的数字，<code>&quot;/&quot;</code> 代表每的意思, <code>&quot;*/5&quot;</code> 表示每5个单位，<code>&quot;-&quot;</code> 代表从某个数字到某个数字, <code>&quot;,&quot;</code> 分开几个离散的数字。以下举几个例子说明问题： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定每小时的第5分钟执行一次ls命令</span></span><br><span class="line">5 * * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每天的 5:30 执行ls命令</span></span><br><span class="line">30 5 * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每月8号的7：30分执行ls命令</span></span><br><span class="line">30 7 8 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每年的6月8日5：30执行ls命令</span></span><br><span class="line">30 5 8 6 * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每星期日的6:30执行ls命令 [ 注：0表示星期天，1表示星期1，以此类推，也可以用英文来表示，sun表示星期天，mon表示星期一等。 ]</span></span><br><span class="line">30 6 * * 0 ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月10号及20号的3：30执行ls命令 [注：“，”用来连接多个不连续的时段 ]</span></span><br><span class="line">30 3 10,20 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天8-11点的第25分钟执行ls命令 [注：“-”用来连接连续的时段 ]</span></span><br><span class="line">25 8-11 * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每15分钟执行一次ls命令 [即每个小时的第0 15 30 45 60分钟执行ls命令 ]</span></span><br><span class="line">*/15 * * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个月中，每隔10天6:30执行一次ls命令[即每月的1、11、21、31日是的6：30执行一次ls命令。 ]</span></span><br><span class="line">30 6 */10 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天7：50以root 身份执行/etc/cron.daily目录中的所有可执行文件</span></span><br><span class="line">50 7 * * * root run-parts /etc/cron.daily   <span class="comment"># [ 注：run-parts参数表示，执行后面目录中的所有可执行文件。 ]</span></span><br></pre></td></tr></table></figure><p><strong>配置用户定时任务的语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ crontab [-u user]file</span><br><span class="line"></span><br><span class="line">$ crontab -u user[-i]</span><br></pre></td></tr></table></figure><p>参数与说明：</p><ul><li>crontab -u        //设定某个用户的cron服务</li><li>crontab -l        //列出某个用户cron服务的详细内容</li><li>crontab -r              //删除没个用户的cron服务</li><li>crontab -e             //编辑某个用户的cron服务</li></ul><h3 id="9-8-从终端截图"><a href="#9-8-从终端截图" class="headerlink" title="9.8 从终端截图"></a>9.8 从终端截图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取整个屏幕：</span></span><br><span class="line">$ import -window root screenshot.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动选择部分区域进行抓取：</span></span><br><span class="line">$ import screenshot.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取特定窗口：</span></span><br><span class="line">$ import -window window_id screenshot.png</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本命令&quot;&gt;&lt;a href=&quot;#1-基本命令&quot; class=&quot;headerlink&quot; title=&quot;1. 基本命令&quot;&gt;&lt;/a&gt;1. 基本命令&lt;/h2&gt;&lt;h3 id=&quot;1-1-shell-格式输出&quot;&gt;&lt;a href=&quot;#1-1-shell-格式输出&quot; class=&quot;headerlink&quot; title=&quot;1.1 shell 格式输出&quot;&gt;&lt;/a&gt;1.1 shell 格式输出&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Hello world !&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n	&lt;span class=&quot;comment&quot;&gt;# 忽略结尾的换行符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-e	&lt;span class=&quot;comment&quot;&gt;# 激活转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-E	&lt;span class=&quot;comment&quot;&gt;# disable转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; -e &lt;span class=&quot;string&quot;&gt;&quot;1\t2\t3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://miaopei.github.io/categories/Shell/"/>
    
    
      <category term="shell" scheme="http://miaopei.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令eval的用法</title>
    <link href="http://miaopei.github.io/2017/04/13/Linux%E5%91%BD%E4%BB%A4eval%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://miaopei.github.io/2017/04/13/Linux命令eval的用法/</id>
    <published>2017-04-13T11:50:19.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eval-command-line"><a href="#eval-command-line" class="headerlink" title="eval command-line"></a>eval command-line</h2><p>其中command－line是在终端上键入的一条普通命令行。<strong>然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次</strong>。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pipe=<span class="string">"|"</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> ls <span class="variable">$pipe</span> wc -l</span><br></pre></td></tr></table></figure><p>shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。</p><a id="more"></a><p><strong>如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（；｜ &amp;），I／o重定向符（&lt; &gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。</strong></p><h2 id="eval-echo-取得最后一个参数"><a href="#eval-echo-取得最后一个参数" class="headerlink" title="eval echo $# 取得最后一个参数"></a>eval echo $# 取得最后一个参数</h2><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat last</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $<span class="variable">$#</span></span><br><span class="line"></span><br><span class="line">$ ./last one two three four</span><br><span class="line">four</span><br></pre></td></tr></table></figure><p>第一遍扫描后，shell把反斜杠去掉了。当shell再次扫描该行时，它替换了$4的值，并执行echo命令</p><h2 id="以下示意如何用eval命令创建指向变量的“指针”："><a href="#以下示意如何用eval命令创建指向变量的“指针”：" class="headerlink" title="以下示意如何用eval命令创建指向变量的“指针”："></a>以下示意如何用eval命令创建指向变量的“指针”：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ x=100</span><br><span class="line"></span><br><span class="line">$ ptrx=x</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> <span class="built_in">echo</span> $<span class="variable">$ptrx</span>  <span class="comment">#指向ptrx，用这里的方法可以理解b中的例子</span></span><br><span class="line">100 打印100</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> <span class="variable">$ptrx</span>=50  <span class="comment">#将50存到ptrx指向的变量中。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">50 打印50</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;eval-command-line&quot;&gt;&lt;a href=&quot;#eval-command-line&quot; class=&quot;headerlink&quot; title=&quot;eval command-line&quot;&gt;&lt;/a&gt;eval command-line&lt;/h2&gt;&lt;p&gt;其中command－line是在终端上键入的一条普通命令行。&lt;strong&gt;然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次&lt;/strong&gt;。如：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pipe=&lt;span class=&quot;string&quot;&gt;&quot;|&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;eval&lt;/span&gt; ls &lt;span class=&quot;variable&quot;&gt;$pipe&lt;/span&gt; wc -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。&lt;/p&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://miaopei.github.io/categories/Shell/"/>
    
    
      <category term="Linux Shell" scheme="http://miaopei.github.io/tags/Linux-Shell/"/>
    
  </entry>
  
  <entry>
    <title>HTTP思维导图</title>
    <link href="http://miaopei.github.io/2017/04/12/HTTP%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://miaopei.github.io/2017/04/12/HTTP思维导图/</id>
    <published>2017-04-12T07:41:58.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自<span class="exturl" data-url="aHR0cDovL3lycTExMC5tZS8yMDE3LzAzLzA0LzIwMTcwMzA0LWh0dHAtbWluZG1hcC8=" title="http://yrq110.me/2017/03/04/20170304-http-mindmap/">HTTP思维导图<i class="fa fa-external-link"></i></span>。</p><p>HTTP mindmap整理</p><p>source from 《HTTP权威指南》</p><a id="more"></a><h3 id="概述-Summary"><a href="#概述-Summary" class="headerlink" title="概述-Summary"></a>概述-Summary</h3><img src="/images/imageHttp/HTTP-1.svg"><h3 id="报文-Message"><a href="#报文-Message" class="headerlink" title="报文-Message"></a>报文-Message</h3><img src="/images/imageHttp/HTTP-2.svg"><h3 id="连接-Connection"><a href="#连接-Connection" class="headerlink" title="连接-Connection"></a>连接-Connection</h3><img src="/images/imageHttp/HTTP-3.svg"><h3 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理-Proxy"></a>代理-Proxy</h3><img src="/images/imageHttp/HTTP-4.svg"><h3 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存-Cache"></a>缓存-Cache</h3><img src="/images/imageHttp/HTTP-5.svg"><h3 id="网关、隧道与中继-Gateway、Tunnel-and-Relay"><a href="#网关、隧道与中继-Gateway、Tunnel-and-Relay" class="headerlink" title="网关、隧道与中继-Gateway、Tunnel and Relay"></a>网关、隧道与中继-Gateway、Tunnel and Relay</h3><img src="/images/imageHttp/HTTP-6.svg"><h3 id="识别-Identification"><a href="#识别-Identification" class="headerlink" title="识别-Identification"></a>识别-Identification</h3><img src="/images/imageHttp/HTTP-7.svg"><h3 id="认证-Authentication"><a href="#认证-Authentication" class="headerlink" title="认证-Authentication"></a>认证-Authentication</h3><img src="/images/imageHttp/HTTP-8.svg"><h3 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全-Security"></a>安全-Security</h3><img src="/images/imageHttp/HTTP-9.svg"><h3 id="实体与编码-Entity-and-Encoding"><a href="#实体与编码-Entity-and-Encoding" class="headerlink" title="实体与编码-Entity and Encoding"></a>实体与编码-Entity and Encoding</h3><img src="/images/imageHttp/HTTP-10.svg">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章来自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3lycTExMC5tZS8yMDE3LzAzLzA0LzIwMTcwMzA0LWh0dHAtbWluZG1hcC8=&quot; title=&quot;http://yrq110.me/2017/03/04/20170304-http-mindmap/&quot;&gt;HTTP思维导图&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;HTTP mindmap整理&lt;/p&gt;
&lt;p&gt;source from 《HTTP权威指南》&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://miaopei.github.io/categories/http/"/>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Webpack创建、运行vue.js项目及其目录结构详解</title>
    <link href="http://miaopei.github.io/2017/04/10/Webpack%E5%88%9B%E5%BB%BA%E3%80%81%E8%BF%90%E8%A1%8Cvue-js%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://miaopei.github.io/2017/04/10/Webpack创建、运行vue-js项目及其目录结构详解/</id>
    <published>2017-04-10T10:18:27.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目环境搭建："><a href="#项目环境搭建：" class="headerlink" title="项目环境搭建："></a>项目环境搭建：</h3><p>1.安装node</p><p>进入<a href="[https://nodejs.org/en/](https://nodejs.org/en/">node官网</a>进行下载。</p><p>版本查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v6.10.1</span><br></pre></td></tr></table></figure><p style="color:red;">**注意：**node版本最好新一点，推介6.0以上。 </p><a id="more"></a><p>2.全局安装vue-cli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g vue-cli</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果安装失败可能需要root权限重新安装。</p><p>3.创建一个基于 <code>webpack</code> 模板的新项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vue init webpack project-name <span class="comment">#(默认安装2.0版本)</span></span><br><span class="line">$ vue init webpack<span class="comment">#1.0 project-name #(安装1.0版本)</span></span><br></pre></td></tr></table></figure><h3 id="项目目录结构："><a href="#项目目录结构：" class="headerlink" title="项目目录结构："></a>项目目录结构：</h3><p><img src="http://i.imgur.com/P64Q8uK.png" alt></p><p><img src="http://i.imgur.com/beLRmUA.png" alt></p><ul><li><p>main.js是入口文件，主要作用是初始化vue实例并使用需要的插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。其实你也可以理解为所有的路由也是App.vue的子组件。所以我将router标示为App.vue的子组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;hello&gt;&lt;/hello&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Hello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>index.html文件入口</p></li><li><p>src放置组件和入口文件</p></li><li><p>node_modules为依赖的模块</p></li><li><p>config中配置了路径端口值等</p></li><li><p>build中配置了webpack的基本配置、开发环境配置、生产环境配置等</p></li></ul><h3 id="运行项目："><a href="#运行项目：" class="headerlink" title="运行项目："></a>运行项目：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> project-name</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br><span class="line"><span class="comment"># 上述步骤都完成后在浏览器输入：localhost:8080</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;项目环境搭建：&quot;&gt;&lt;a href=&quot;#项目环境搭建：&quot; class=&quot;headerlink&quot; title=&quot;项目环境搭建：&quot;&gt;&lt;/a&gt;项目环境搭建：&lt;/h3&gt;&lt;p&gt;1.安装node&lt;/p&gt;
&lt;p&gt;进入&lt;a href=&quot;[https://nodejs.org/en/](https://nodejs.org/en/&quot;&gt;node官网&lt;/a&gt;进行下载。&lt;/p&gt;
&lt;p&gt;版本查看：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ node -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v6.10.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p style=&quot;color:red;&quot;&gt;**注意：**node版本最好新一点，推介6.0以上。 &lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://miaopei.github.io/categories/Docker/"/>
    
    
      <category term="webpack" scheme="http://miaopei.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>lighttpd 配置https</title>
    <link href="http://miaopei.github.io/2017/03/31/lighttpd-%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://miaopei.github.io/2017/03/31/lighttpd-配置https/</id>
    <published>2017-03-31T04:34:28.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="确定安装的lighttpd支持ssl"><a href="#确定安装的lighttpd支持ssl" class="headerlink" title="确定安装的lighttpd支持ssl"></a>确定安装的lighttpd支持ssl</h3><p>版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lighttpd -v</span><br><span class="line">lighttpd/1.4.35 (ssl) - a light and fast webserver</span><br><span class="line">Build-Date: Apr 25 2017 10:25:18</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h3><p>完整的ssl证书分为四个部分：</p><ul><li>CA根证书（root CA）</li><li>中级证书（Intermediate Certificate）</li><li>域名证书</li><li>证书秘钥（仅由开发者提供）</li></ul><p>证书相当于公钥，pem相当于私钥。</p><p>Self-Signed Certificates：包含公钥和私钥的结合体，证书（公钥）会在连接请求的时候发给浏览器，以便浏览器解密和加密。</p><p>创建Self-Signed Certificates：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><p>上边的命令生成一个server.pem文件。</p><h3 id="lighttpd-conf-配置"><a href="#lighttpd-conf-配置" class="headerlink" title="lighttpd.conf 配置"></a>lighttpd.conf 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SERVER</span>[<span class="string">"socket"</span>] == <span class="string">"[::]:443"</span> &#123;  </span><br><span class="line">     ssl.engine      = <span class="string">"enable"</span></span><br><span class="line">     ssl.pemfile     = <span class="string">"/mnt/flash/server.pem"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制定向到HTTPS"><a href="#强制定向到HTTPS" class="headerlink" title="强制定向到HTTPS"></a>强制定向到HTTPS</h3><p>下面是 <code>lighttpd.conf</code> 文件中关于强制 HTTP 定向到 HTTPS 的部分配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HTTP</span>[<span class="string">"scheme"</span>] == <span class="string">"http"</span> &#123;</span><br><span class="line">    <span class="comment"># capture vhost name with regex conditiona -&gt; %0 in redirect pattern</span></span><br><span class="line">    <span class="comment"># must be the most inner block to the redirect rule</span></span><br><span class="line">    <span class="variable">$HTTP</span>[<span class="string">"host"</span>] =~ <span class="string">".*"</span> &#123;</span><br><span class="line">        url.redirect = (<span class="string">".*"</span> =&gt; <span class="string">"https://%0<span class="variable">$0</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此功能需要lighttpd <code>mod_redirect</code> 模块支持。使用此功能前确保模块已经安装。</p><h3 id="lighttpd安全配置"><a href="#lighttpd安全配置" class="headerlink" title="lighttpd安全配置"></a>lighttpd安全配置</h3><p><strong>禁用 SSL Compression (抵御 CRIME 攻击)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.use-compression = <span class="string">"disable"</span></span><br></pre></td></tr></table></figure><p><strong>禁用 SSLv2 及 SSLv3</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl.use-sslv2 = <span class="string">"disable"</span></span><br><span class="line">ssl.use-sslv3 = <span class="string">"disable"</span></span><br></pre></td></tr></table></figure><p><strong>抵御 Poodle 和 SSL downgrade 攻击</strong></p><p>需要支持 <code>TLS-FALLBACK-SCSV</code> 以自动开启此功能。下列 openSSL 版本包含对 <code>TLS-FALLBACK-SCSV</code> 的支持，lighttpd 会自动启用此特性。</p><ul><li>OpenSSL <strong>1.0.1</strong> 在 <code>1.0.1j</code> 及之后的版本中支持</li><li>OpenSSL <strong>1.0.0</strong> 在 <code>1.0.0o</code> 及之后的版本中支持</li><li>OpenSSL <strong>0.9.8</strong> 在 <code>0.9.8zc</code> 及之后的版本中支持</li></ul><p><strong>加密及交换算法</strong></p><p>一份推介的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.cipher-list = <span class="string">"EECDH+AESGCM:EDH+AESGCM:AES128+EECDH:AES128+EDH"</span></span><br></pre></td></tr></table></figure><p>如果您需要兼容一些老式系统和浏览器 (例如 Windows XP 和 IE6)，请使用下面的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.cipher-list = <span class="string">"EECDH+AESGCM:EDH+AESGCM:ECDHE-RSA-AES128-GCM-SHA256:AES256+EECDH:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4"</span></span><br></pre></td></tr></table></figure><p><strong>配置 Forward Secrecy 和 DHE 参数</strong></p><p>生成强 DHE 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/ssl/certs</span><br><span class="line">$ openssl dhparam -out dhparam.pem 4096</span><br></pre></td></tr></table></figure><p><strong>建议您使用性能强劲的平台生成此文件</strong>，例如最新版的至强物理机。如果您只有一台小型 VPS，请使用 <code>openssl dhparam -out dhparam.pem 2048</code> 命令生成 2048bit 的参数文件。</p><p>添加到 SSL 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl.dh-file = <span class="string">"/etc/ssl/certs/dhparam.pem"</span></span><br><span class="line">ssl.ec-curve = <span class="string">"secp384r1"</span></span><br></pre></td></tr></table></figure><p><strong>启用 HSTS</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.modules += ( <span class="string">"mod_setenv"</span> )</span><br><span class="line"><span class="variable">$HTTP</span>[<span class="string">"scheme"</span>] == <span class="string">"https"</span> &#123;</span><br><span class="line">    setenv.add-response-header  = ( <span class="string">"Strict-Transport-Security"</span> =&gt; <span class="string">"max-age=63072000; includeSubdomains; preload"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0xpZ2h0dHBk" title="https://wiki.archlinux.org/index.php/Lighttpd">Lighttpd<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;确定安装的lighttpd支持ssl&quot;&gt;&lt;a href=&quot;#确定安装的lighttpd支持ssl&quot; class=&quot;headerlink&quot; title=&quot;确定安装的lighttpd支持ssl&quot;&gt;&lt;/a&gt;确定安装的lighttpd支持ssl&lt;/h3&gt;&lt;p&gt;版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ lighttpd -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lighttpd/1.4.35 (ssl) - a light and fast webserver&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Build-Date: Apr 25 2017 10:25:18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
      <category term="lighttpd" scheme="http://miaopei.github.io/tags/lighttpd/"/>
    
  </entry>
  
  <entry>
    <title>lighttpd+fastcgi</title>
    <link href="http://miaopei.github.io/2017/03/31/lighttpd-fastcgi/"/>
    <id>http://miaopei.github.io/2017/03/31/lighttpd-fastcgi/</id>
    <published>2017-03-31T04:34:28.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>lighttpd</code> 提供了一种外部程序调用的接口，即 <code>FastCGI</code> 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。</p><p>这就意味着能够在 <code>Apache</code> 服务器上运行的 <code>FastCGI</code> 程序，也一定可以无缝的在 <code>lighttpd</code> 上使用。</p><a id="more"></a><h3 id="FastCGI介绍"><a href="#FastCGI介绍" class="headerlink" title="FastCGI介绍"></a>FastCGI介绍</h3><p>1）就像 <code>CGI</code> 一样，<code>FastCGI</code> 也是独立于编程语言的。<br>2）就像 <code>CGI</code> 一样，<code>FastCGI</code> 程序运行在完全独立于核心 <code>Web Server</code> 之外的进程中，和 <code>API</code> 方式相比，提供了很大的安全性。（API会将程序代码与核心Web Server挂接在一起，这就意味着基于问题API的应用程序可能会使整个Web Server或另一个应用程序崩溃；一个恶意API还可以从核心Web Server或另一个应用程序中盗取安全密钥）</p><p>3) 虽然 <code>FastCGI</code> 不能一夜之间复制CGI的所有功能，但是 <code>FastCGI</code> 一直宣扬开放，这也使得我们拥有很多免费的 <code>FastCGI</code> 应用程序库（C/C++、Java、Perl、TCL）和免费的Server模块（Apache、ISS、Lighttpd）。</p><p>4) 就像 <code>CGI</code> 一样，<code>FastCGI</code> 并不依附于任何 <code>Web Server</code> 的内部架构，因此即使 <code>Server</code> 的技术实现变动，<code>FastCGI</code> 仍然非常稳定；而 <code>API</code> 设计是反映 <code>Web Server</code> 内部架构的，因此，一旦架构改变，API要随之变动。</p><p>5) <code>FastCGI</code> 程序可以运行在任何机器上，完全可以和 <code>Web Server</code> 不在一台机器上。这种分布式计算的思想可以确保可扩展性、提高系统可用性和安全性。</p><p>6) <code>CGI</code> 程序主要是对 <code>HTTP</code> 请求做计算处理，而 <code>FastCGI</code> 却还可以做得更多，例如模块化认证、授权检查、数据类型转换等等。在未来，<code>FastCGI</code> 还会有能力扮演更多角色。</p><p>7) <code>FastCGI</code> 移除了 <code>CGI</code> 程序的许多弊端。例如，针对每一个新请求，<code>WebServer</code> 都必须重启 <code>CGI</code> 程序来处理新请求，这导致 <code>WebServer</code> 的性能会大受影响。而 <code>FastCGI</code> 通过保持进程处理运行状态并持续处理请求的方式解决了该问题，这就将进程创建和销毁的时间节省了出来。</p><p>8) <code>CGI</code> 程序需要通过管道（pipe）方式与 <code>Web Server</code> 通信，而 <code>FastCGI</code> 则是通过 <code>Unix-Domain-Sockets</code> 或 <code>TCP/IP</code> 方式来实现与 <code>Web Server</code> 的通信。这确保了 <code>FastCGI</code> 可以运行在 <code>Web Server</code> 之外的服务器上。<code>FastCGI</code> 提供了 <code>FastCGI</code> 负载均衡器，它可以有效控制多个独立的 <code>FastCGI Server</code> 的负载，这种方式比 <code>load-balancer+apache+mod_php</code> 方式能够承担更多的流量。</p><h3 id="FastCGI-模块"><a href="#FastCGI-模块" class="headerlink" title="FastCGI 模块"></a>FastCGI 模块</h3><p>若要 <code>lighttpd</code> 支持 <code>fastcgi</code>，则需要配置如下内容：</p><p>在 <code>fastcgi.conf</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.modules += ( &quot;mod_fastcgi&quot; )</span><br></pre></td></tr></table></figure><p>及在 <code>module.conf</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;conf.d/fastcgi.conf&quot;</span><br></pre></td></tr></table></figure><h3 id="FastCGI-配置选项"><a href="#FastCGI-配置选项" class="headerlink" title="FastCGI 配置选项"></a>FastCGI 配置选项</h3><p><code>lighttpd</code> 通过 <code>fastcgi</code> 模块的方式实现了对 <code>fastcgi</code> 的支持，并且在配置文件中提供了三个相关的选项：</p><p>1） fastcgi.debug</p><p>可以设置一个从0到65535的值，用于设定 <code>FastCGI</code> 模块的调试等级。当前仅有0和1可用。<strong>1表示开启调试（会输出调试信息），0表示禁用</strong>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.debug = 1</span><br></pre></td></tr></table></figure><p>2） fastcgi.map-extentsions</p><p>同一个 <code>fastcgi server</code> 能够映射多个扩展名，如 <code>.php3</code> 和 <code>.php4</code> 都对应 <code>.php</code>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot; )</span><br></pre></td></tr></table></figure><p>or for multiple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot;, &quot;.php4&quot; =&gt; &quot;.php&quot; )</span><br></pre></td></tr></table></figure><p>3） fastcgi.server</p><p>这个配置是告诉 <code>Web Server</code> 将 <code>FastCGI</code> 请求发送到哪里，其中每一个文件扩展名可以处理一个类型的请求。负载均衡器可以实现对同一扩展名的多个对象的负载均衡。</p><p><code>fastcgi.server</code> 的结构语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">( &lt;extension&gt; =&gt;</span><br><span class="line">  ( [ &lt;name&gt; =&gt; ]</span><br><span class="line">    ( <span class="comment"># Be careful: lighty does *not* warn you if it doesn't know a specified option here (make sure you have no typos)</span></span><br><span class="line">      <span class="string">"host"</span> =&gt; &lt;string&gt; ,</span><br><span class="line">      <span class="string">"port"</span> =&gt; &lt;<span class="built_in">integer</span>&gt; ,</span><br><span class="line">      <span class="string">"socket"</span> =&gt; &lt;string&gt;,                 <span class="comment"># either socket or host+port</span></span><br><span class="line">      <span class="string">"bin-path"</span> =&gt; &lt;string&gt;,               <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"bin-environment"</span> =&gt; &lt;array&gt;,         <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"bin-copy-environment"</span> =&gt; &lt;array&gt;,    <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"mode"</span> =&gt; &lt;string&gt;,                   <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"docroot"</span> =&gt; &lt;string&gt; ,               <span class="comment"># optional if "mode" is not "authorizer"</span></span><br><span class="line">      <span class="string">"check-local"</span> =&gt; &lt;string&gt;,            <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"max-procs"</span> =&gt; &lt;<span class="built_in">integer</span>&gt;,             <span class="comment"># optional - when omitted, default is 4</span></span><br><span class="line">      <span class="string">"broken-scriptfilename"</span> =&gt; &lt;boolean&gt;, <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"kill-signal"</span> =&gt; &lt;<span class="built_in">integer</span>&gt;,           <span class="comment"># optional, default is SIGTERM(15) (v1.4.14+)</span></span><br><span class="line">    ),</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; ...</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中：</p><blockquote><p><strong>extentsion</strong> ：文件名后缀或以”/”开头的前缀（也可为文件名）<br><strong>name</strong> ：这是一个可选项，表示handler的名称，在mod_status中用于统计功能，可以清晰的分辨出是哪一个handler处理了<extension>。<strong>host</strong> ：FastCGI进程监听的IP地址。此处不支持hostname形式。<br><strong>port</strong> ：FastCGI进程所监听的TCP端口号<br><strong>bin-path</strong> ：本地FastCGI二进制程序的路径，当本地没有FastCGI正在运行时，会启动这个FastCGI程序。<br><strong>socket</strong> ：unix-domain-socket所在路径。<br><strong>mode</strong> ：可以选择FastCGI协议的模式，默认是“responder”，还可以选择authorizer。<br><strong>docroot</strong> ：这是一个可选项，对于responder模式来讲，表示远程主机docroot；对于authorizer模式来说，它表示MANDATORY，并且指向授权请求的docroot。<br><strong>check_local</strong> ：这是一个可选项，默认是enable。如果是enable，那么server会首先在本地（server.document-root）目录中检查被请求的文件是否存在，如果不存在，则给用户返回404（Not Found），而不会把这个请求传递给FastCGI。如果是disable，那么server不会检查本地文件，而是直接将请求转发给FastCGI。（disable的话，server从某种意义上说就变为了一个转发器）<br><strong>broken-scriptfilename</strong> ：以类似PHP抽取PATH_INFO的方式，抽取URL中的SCRIPT_FILENAME。</extension></p></blockquote><p>如果 <code>bin-path</code> 被设置了，那么：</p><blockquote><p><strong>max-procs</strong> ：设置多少个FastCGI进程被启动<br><strong>bin-environment</strong> ：在FastCGI进程启动时设置一个环境变量<br><strong>bin-copy-environment</strong> ：清除环境，并拷贝指定的变量到全新的环境中。<br><strong>kill-signal</strong> ：默认的话，在停止FastCGI进程时，lighttpd会发送SIGTERM(-15)信号给子进程。此处可以设置发送的信号。</p></blockquote><p><strong>举例</strong> ：</p><p>使用前缀来对应主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = (</span><br><span class="line">  <span class="string">"/remote_scripts/"</span> =&gt;</span><br><span class="line">  (( <span class="string">"host"</span> =&gt; <span class="string">"192.168.0.3"</span>,</span><br><span class="line">     <span class="string">"port"</span> =&gt; 9000,</span><br><span class="line">     <span class="string">"check-local"</span> =&gt; <span class="string">"disable"</span>,</span><br><span class="line">     <span class="string">"docroot"</span> =&gt; <span class="string">"/"</span> <span class="comment"># remote server may use</span></span><br><span class="line">                      <span class="comment"># it's own docroot</span></span><br><span class="line">  ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果有一个请求 “<span class="exturl" data-url="aHR0cDovL215LmV4YW1wbGUub3JnL3JlbW90ZV9zY3JpcHRzL3Rlc3QuY2dpJnF1b3Q777yM6YKj5LmIc2VydmVy5Lya5bCG5YW26L2s5Y+R57uZMTkyLjE2OC4wLjPnmoQ5MDAw56uv5Y+j77yM5bm25LiU" title="http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且">http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且<i class="fa fa-external-link"></i></span> <code>SCRIPT_NAME</code> 会被赋值为 <code>“/remote_scripts/test.cgi”</code>。如果所设置的 <code>handler</code> 的末尾不是 <code>“/”</code> ，那么会被认为是一个文件。</p><p><strong>负载均衡</strong> ：</p><p><code>FastCGI</code> 模块提供了一种在多台 <code>FastCGI</code> 服务器间负载均衡的方法。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = ( <span class="string">".php"</span> =&gt;</span><br><span class="line">  (</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; <span class="string">"10.0.0.2"</span>,</span><br><span class="line">      <span class="string">"port"</span> =&gt; 1030</span><br><span class="line">    ),</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; <span class="string">"10.0.0.3"</span>,</span><br><span class="line">      <span class="string">"port"</span> =&gt; 1030 )</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>为了更好的理解负载均衡实现的原理，建议你置 <code>fastcgi.debug</code> 为 <code>1</code> 。即使对于本机的多个 <code>FastCGI</code> ，你也会获得如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proc: 127.0.0.1 1031  1 1 1 31454</span><br><span class="line">proc: 127.0.0.1 1028  1 1 1 31442</span><br><span class="line">proc: 127.0.0.1 1030  1 1 1 31449</span><br><span class="line">proc: 127.0.0.1 1029  1 1 2 31447</span><br><span class="line">proc: 127.0.0.1 1026  1 1 2 31438</span><br><span class="line">got proc: 34 31454</span><br><span class="line">release proc: 40 31438</span><br><span class="line">proc: 127.0.0.1 1026  1 1 1 31438</span><br><span class="line">proc: 127.0.0.1 1028  1 1 1 31442</span><br><span class="line">proc: 127.0.0.1 1030  1 1 1 31449</span><br><span class="line">proc: 127.0.0.1 1031  1 1 2 31454</span><br><span class="line">proc: 127.0.0.1 1029  1 1 2 31447</span><br></pre></td></tr></table></figure><p>上述信息显示出了IP地址，端口号、当前链接数（也就是负载）（倒数第二列）、进程ID（倒数第一列）等等。整个输出信息总是以负载域来从小到大排序的。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><span class="exturl" data-url="aHR0cDovL3JlZG1pbmUubGlnaHR0cGQubmV0L3Byb2plY3RzLzEvd2lraS9Eb2NzOk1vZEZhc3RDR0k=" title="http://redmine.lighttpd.net/projects/1/wiki/Docs:ModFastCGI"><i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5mYXN0Y2dpLmNvbQ==" title="http://www.fastcgi.com"><i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3JvY2xpbnV4LmNuLz9wPTIzNDc=" title="http://roclinux.cn/?p=2347">说说lighttpd的fastcgi<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3luZXQvcC80MTczNDUwLmh0bWw=" title="http://www.cnblogs.com/skynet/p/4173450.html">Nginx + CGI/FastCGI + C/Cpp<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDAwNjU5Ng==" title="https://segmentfault.com/a/1190000004006596">FastCGI+lighttpd开发之介绍和环境搭建<i class="fa fa-external-link"></i></span></p><h3 id="附：QC-V3-PP-版本-lighttpd-conf"><a href="#附：QC-V3-PP-版本-lighttpd-conf" class="headerlink" title="附：QC V3 PP 版本 lighttpd.conf"></a>附：QC V3 PP 版本 lighttpd.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/qtilighttpd.conf </span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Copyright (c) 2016 Qualcomm Technologies, Inc.</span></span><br><span class="line"><span class="comment"># All Rights Reserved.</span></span><br><span class="line"><span class="comment"># Confidential and Proprietary - Qualcomm Technologies, Inc.</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">server.document-root = <span class="string">"/opt/qcom/www"</span></span><br><span class="line"></span><br><span class="line">server.port    = 80</span><br><span class="line">server.username    = <span class="string">"apps"</span></span><br><span class="line">server.groupname  = <span class="string">"apps"</span></span><br><span class="line">server.bind    = <span class="string">"0.0.0.0"</span></span><br><span class="line">server.tag    = <span class="string">"lighttpd"</span></span><br><span class="line"><span class="variable">$SERVER</span>[<span class="string">"socket"</span>] == <span class="string">"[::]:80"</span> &#123;  &#125;</span><br><span class="line"></span><br><span class="line">server.errorlog-use-syslog  = <span class="string">"enable"</span></span><br><span class="line">accesslog.use-syslog    = <span class="string">"enable"</span></span><br><span class="line"></span><br><span class="line">server.modules    = (</span><br><span class="line">  <span class="string">"mod_access"</span>,<span class="string">"mod_accesslog"</span>, <span class="string">"mod_cgi"</span>, <span class="string">"mod_fastcgi"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fastcgi.debug = 1</span><br><span class="line">fastcgi.server = (</span><br><span class="line">    <span class="string">"/fsmoam"</span> =&gt; (</span><br><span class="line">    <span class="string">"fsmoam.fcgi.handler"</span> =&gt; (</span><br><span class="line">        <span class="string">"socket"</span> =&gt; <span class="string">"/tmp/fsmoam.fcgi.socket"</span>,</span><br><span class="line">        <span class="string">"check-local"</span> =&gt; <span class="string">"disable"</span>,</span><br><span class="line">        <span class="string">"bin-path"</span> =&gt; <span class="string">"/opt/qcom/bin/tests/fsmWebServer --default-log-level=DEBUG"</span>,</span><br><span class="line">        <span class="string">"max-procs"</span> =&gt; 1)</span><br><span class="line">     )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mimetype mapping</span></span><br><span class="line">mimetype.assign    = (</span><br><span class="line">  <span class="string">".pdf"</span>    =&gt;  <span class="string">"application/pdf"</span>,</span><br><span class="line">  <span class="string">".sig"</span>    =&gt;  <span class="string">"application/pgp-signature"</span>,</span><br><span class="line">  <span class="string">".spl"</span>    =&gt;  <span class="string">"application/futuresplash"</span>,</span><br><span class="line">  <span class="string">".class"</span>  =&gt;  <span class="string">"application/octet-stream"</span>,</span><br><span class="line">  <span class="string">".ps"</span>    =&gt;  <span class="string">"application/postscript"</span>,</span><br><span class="line">  <span class="string">".torrent"</span>  =&gt;  <span class="string">"application/x-bittorrent"</span>,</span><br><span class="line">  <span class="string">".dvi"</span>    =&gt;  <span class="string">"application/x-dvi"</span>,</span><br><span class="line">  <span class="string">".gz"</span>    =&gt;  <span class="string">"application/x-gzip"</span>,</span><br><span class="line">  <span class="string">".pac"</span>    =&gt;  <span class="string">"application/x-ns-proxy-autoconfig"</span>,</span><br><span class="line">  <span class="string">".swf"</span>    =&gt;  <span class="string">"application/x-shockwave-flash"</span>,</span><br><span class="line">  <span class="string">".tar.gz"</span>  =&gt;  <span class="string">"application/x-tgz"</span>,</span><br><span class="line">  <span class="string">".tgz"</span>    =&gt;  <span class="string">"application/x-tgz"</span>,</span><br><span class="line">  <span class="string">".tar"</span>    =&gt;  <span class="string">"application/x-tar"</span>,</span><br><span class="line">  <span class="string">".zip"</span>    =&gt;  <span class="string">"application/zip"</span>,</span><br><span class="line">  <span class="string">".mp3"</span>    =&gt;  <span class="string">"audio/mpeg"</span>,</span><br><span class="line">  <span class="string">".m3u"</span>    =&gt;  <span class="string">"audio/x-mpegurl"</span>,</span><br><span class="line">  <span class="string">".wma"</span>    =&gt;  <span class="string">"audio/x-ms-wma"</span>,</span><br><span class="line">  <span class="string">".wax"</span>    =&gt;  <span class="string">"audio/x-ms-wax"</span>,</span><br><span class="line">  <span class="string">".ogg"</span>    =&gt;  <span class="string">"audio/x-wav"</span>,</span><br><span class="line">  <span class="string">".wav"</span>    =&gt;  <span class="string">"audio/x-wav"</span>,</span><br><span class="line">  <span class="string">".gif"</span>    =&gt;  <span class="string">"image/gif"</span>,</span><br><span class="line">  <span class="string">".jpg"</span>    =&gt;  <span class="string">"image/jpeg"</span>,</span><br><span class="line">  <span class="string">".jpeg"</span>    =&gt;  <span class="string">"image/jpeg"</span>,</span><br><span class="line">  <span class="string">".png"</span>    =&gt;  <span class="string">"image/png"</span>,</span><br><span class="line">  <span class="string">".xbm"</span>    =&gt;  <span class="string">"image/x-xbitmap"</span>,</span><br><span class="line">  <span class="string">".xpm"</span>    =&gt;  <span class="string">"image/x-xpixmap"</span>,</span><br><span class="line">  <span class="string">".xwd"</span>    =&gt;  <span class="string">"image/x-xwindowdump"</span>,</span><br><span class="line">  <span class="string">".css"</span>    =&gt;  <span class="string">"text/css"</span>,</span><br><span class="line">  <span class="string">".html"</span>    =&gt;  <span class="string">"text/html"</span>,</span><br><span class="line">  <span class="string">".htm"</span>    =&gt;  <span class="string">"text/html"</span>,</span><br><span class="line">  <span class="string">".js"</span>    =&gt;  <span class="string">"text/javascript"</span>,</span><br><span class="line">  <span class="string">".asc"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".c"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".conf"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".text"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".txt"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".dtd"</span>    =&gt;  <span class="string">"text/xml"</span>,</span><br><span class="line">  <span class="string">".xml"</span>    =&gt;  <span class="string">"text/xml"</span>,</span><br><span class="line">  <span class="string">".mpeg"</span>    =&gt;  <span class="string">"video/mpeg"</span>,</span><br><span class="line">  <span class="string">".mpg"</span>    =&gt;  <span class="string">"video/mpeg"</span>,</span><br><span class="line">  <span class="string">".mov"</span>    =&gt;  <span class="string">"video/quicktime"</span>,</span><br><span class="line">  <span class="string">".qt"</span>    =&gt;  <span class="string">"video/quicktime"</span>,</span><br><span class="line">  <span class="string">".avi"</span>    =&gt;  <span class="string">"video/x-msvideo"</span>,</span><br><span class="line">  <span class="string">".asf"</span>    =&gt;  <span class="string">"video/x-ms-asf"</span>,</span><br><span class="line">  <span class="string">".asx"</span>    =&gt;  <span class="string">"video/x-ms-asf"</span>,</span><br><span class="line">  <span class="string">".wmv"</span>    =&gt;  <span class="string">"video/x-ms-wmv"</span>,</span><br><span class="line">  <span class="string">".bz2"</span>    =&gt;  <span class="string">"application/x-bzip"</span>,</span><br><span class="line">  <span class="string">".tbz"</span>    =&gt;  <span class="string">"application/x-bzip-compressed-tar"</span>,</span><br><span class="line">  <span class="string">".tar.bz2"</span>  =&gt;  <span class="string">"application/x-bzip-compressed-tar"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">index-file.names = ( <span class="string">"index.html"</span> )</span><br><span class="line"></span><br><span class="line">cgi.assign = ( <span class="string">".sh"</span> =&gt; <span class="string">"/bin/sh"</span> )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;lighttpd&lt;/code&gt; 提供了一种外部程序调用的接口，即 &lt;code&gt;FastCGI&lt;/code&gt; 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。&lt;/p&gt;
&lt;p&gt;这就意味着能够在 &lt;code&gt;Apache&lt;/code&gt; 服务器上运行的 &lt;code&gt;FastCGI&lt;/code&gt; 程序，也一定可以无缝的在 &lt;code&gt;lighttpd&lt;/code&gt; 上使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="lighttpd" scheme="http://miaopei.github.io/tags/lighttpd/"/>
    
      <category term="FastCGI" scheme="http://miaopei.github.io/tags/FastCGI/"/>
    
  </entry>
  
  <entry>
    <title>svn 常用操作命令</title>
    <link href="http://miaopei.github.io/2017/03/29/svn-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://miaopei.github.io/2017/03/29/svn-常用操作命令/</id>
    <published>2017-03-29T08:23:27.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span><br><span class="line">$ svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名</span><br><span class="line"><span class="comment"># 也可以使用缩写</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">$ svn co http://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>注</strong> ：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。 不指定本地目录全路径，则检出到当前目录下。</p><h2 id="导出（导出一个干净的不带-svn文件夹的目录树）"><a href="#导出（导出一个干净的不带-svn文件夹的目录树）" class="headerlink" title="导出（导出一个干净的不带.svn文件夹的目录树）"></a>导出（导出一个干净的不带.svn文件夹的目录树）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn  <span class="built_in">export</span>  [-r 版本号]  http://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">$ svn  <span class="built_in">export</span>  [-r 版本号]  svn://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">$ svn  <span class="built_in">export</span>  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn <span class="built_in">export</span> svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">$ svn <span class="built_in">export</span> svn://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br><span class="line">$ svn <span class="built_in">export</span> /home/testapp /home/testtools</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：第一种从版本库导出干净工作目录树的形式是指定URL，</p><p>​     如果指定了修订版本号，会导出相应的版本，</p><p>​     如果没有指定修订版本，则会导出最新的，导出到指定位置。</p><p>​     如果省略 本地目录全路径，URL的最后一部分会作为本地目录的名字。</p><p>​     第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留，</p><p>​     但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。</p><h2 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn　add　文件名</span><br><span class="line"><span class="comment"># 注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn add test.php  <span class="comment"># 添加test.php </span></span><br><span class="line">$ svn commit -m <span class="string">"添加我的测试用test.php"</span> test.php</span><br><span class="line">$ svn add *.php  <span class="comment"># 添加当前目录下所有的php文件</span></span><br><span class="line">$ svn commit -m <span class="string">"添加我的测试用全部php文件"</span> *.php</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ svn　commit　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line">$ svn　ci　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line"><span class="comment"># 必须带上-m参数，参数可以为空，但是必须写上-m</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn commit -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> *   <span class="comment"># 注意这个*表示全部文件</span></span><br><span class="line">$ svn commit -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">$ svn commit -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php   <span class="comment"># 保持锁就用–no-unlock开关</span></span><br><span class="line">$ svn ci -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> *   <span class="comment"># 注意这个*表示全部文件</span></span><br><span class="line">$ svn ci -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">$ svn ci -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php   <span class="comment"># 保持锁就用–no-unlock开关</span></span><br></pre></td></tr></table></figure><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ svn　update</span><br><span class="line">$ svn　update　-r　修正版本　文件名</span><br><span class="line">$ svn　update　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span></span><br><span class="line">$ svn update </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将版本库中的文件 test.cpp 还原到修正版本（revision）200</span></span><br><span class="line">$ svn update -r 200 test.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新与版本库同步。提交的时候提示过期冲突，需要先 update 修改文件，然后清除svn resolved，最后再提交commit。</span></span><br><span class="line">$ svn update test.php</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ svn　delete　svn://路径(目录或文件的全路径) -m <span class="string">"删除备注信息文本"</span></span><br><span class="line"><span class="comment"># 推荐如下操作：</span></span><br><span class="line">$ svn　delete　文件名 </span><br><span class="line">$ svn　ci　-m　<span class="string">"删除备注信息文本"</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn delete svn://localhost/testapp/test.php -m <span class="string">"删除测试文件test.php"</span></span><br><span class="line"><span class="comment"># 推荐如下操作：</span></span><br><span class="line">$ svn delete test.php </span><br><span class="line">$ svn ci -m <span class="string">"删除测试文件test.php"</span></span><br></pre></td></tr></table></figure><h2 id="加锁-解锁"><a href="#加锁-解锁" class="headerlink" title="加锁 / 解锁"></a>加锁 / 解锁</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svn　lock　-m　<span class="string">"加锁备注信息文本"</span>　[--force]　文件名 </span><br><span class="line">$ svn　unlock　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn lock -m <span class="string">"锁信测试用test.php文件"</span> test.php </span><br><span class="line">$ svn unlock test.php</span><br></pre></td></tr></table></figure><h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ svn　diff　文件名 </span><br><span class="line">$ svn　diff　-r　修正版本号m:修正版本号n　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 将修改的文件与基础版本比较</span></span><br><span class="line">$ svn diff test.php </span><br><span class="line"></span><br><span class="line"><span class="comment"># 对修正版本号200 和 修正版本号201 比较差异</span></span><br><span class="line">$ svn diff -r 200:201 test.php</span><br></pre></td></tr></table></figure><h2 id="查看文件或者目录状态"><a href="#查看文件或者目录状态" class="headerlink" title="查看文件或者目录状态"></a>查看文件或者目录状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ svn st 目录路径/名</span><br><span class="line"><span class="comment"># 目录下的文件和子目录的状态，正常状态不显示.</span></span><br><span class="line"><span class="comment"># 【?：不在svn的控制中；  M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 </span></span><br><span class="line">$ svn status 目录路径/名　　　　　</span><br><span class="line">$ svn -v 目录路径/名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件和子目录状态</span></span><br><span class="line"><span class="comment"># 【第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人】</span></span><br><span class="line">$ svn status -v 目录路径/名</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。</p><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ svn　<span class="built_in">log</span>　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 显示这个文件的所有修改记录，及其版本号的变化</span></span><br><span class="line">$ svn <span class="built_in">log</span> test.php</span><br></pre></td></tr></table></figure><h2 id="查看文件详细信息"><a href="#查看文件详细信息" class="headerlink" title="查看文件详细信息"></a>查看文件详细信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ svn　info　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn info test.php</span><br></pre></td></tr></table></figure><h2 id="SVN-帮助"><a href="#SVN-帮助" class="headerlink" title="SVN 帮助"></a>SVN 帮助</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全部功能选项</span></span><br><span class="line">$ svn　<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 具体功能的说明</span></span><br><span class="line">$ svn　<span class="built_in">help</span>　ci</span><br></pre></td></tr></table></figure><h2 id="查看版本库下的文件和目录列表"><a href="#查看版本库下的文件和目录列表" class="headerlink" title="查看版本库下的文件和目录列表"></a>查看版本库下的文件和目录列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn　list　svn://路径(目录或文件的全路径)</span><br><span class="line">$ svn　ls　svn://路径(目录或文件的全路径)</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn list svn://localhost/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示svn://localhost/test目录下的所有属于版本库的文件和目录</span></span><br><span class="line">$ svn ls svn://localhost/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="创建纳入版本控制下的新目录"><a href="#创建纳入版本控制下的新目录" class="headerlink" title="创建纳入版本控制下的新目录"></a>创建纳入版本控制下的新目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svn　mkdir　目录名</span><br><span class="line">$ svn　mkdir　-m　<span class="string">"新增目录备注文本"</span>　http://目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn mkdir newdir</span><br><span class="line">$ svn mkdir -m <span class="string">"Making a new dir."</span> svn://localhost/<span class="built_in">test</span>/newdir</span><br></pre></td></tr></table></figure><p><strong>注</strong> ： 添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn update</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：如果手工在checkout出来的目录里创建了一个新文件夹newsubdir，</p><p>​     再用svn mkdir newsubdir命令后，SVN会提示：</p><p>​     svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？</p><p>​     svn: 无法创建目录“hello”: 文件已经存在</p><pre><code> 此时，用如下命令解决：svn add --non-recursive newsubdir</code></pre><p>​     在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录</p><p>​     再用 svn mkdir -m “添hello功能模块文件” <span class="exturl" data-url="c3ZuOi8vbG9jYWxob3N0L3Rlc3QvbmV3ZGlyL25ld3N1YmRpcg==" title="svn://localhost/test/newdir/newsubdir">svn://localhost/test/newdir/newsubdir<i class="fa fa-external-link"></i></span> 命令，</p><p>​     SVN提示：</p><p>​     svn: File already exists: filesystem ‘/data/svnroot/test/db’, transaction ‘4541-1’,</p><p>​     path ‘/newdir/newsubdir ‘</p><h2 id="恢复本地修改"><a href="#恢复本地修改" class="headerlink" title="恢复本地修改"></a>恢复本地修改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ svn　revert　[--recursive]　文件名</span><br><span class="line"><span class="comment"># 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 丢弃对一个文件的修改</span></span><br><span class="line">$ svn revert foo.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复一整个目录的文件，. 为当前目录</span></span><br><span class="line">$ svn revert --recursive .</span><br></pre></td></tr></table></figure><h2 id="把工作拷贝更新到别的URL"><a href="#把工作拷贝更新到别的URL" class="headerlink" title="把工作拷贝更新到别的URL"></a>把工作拷贝更新到别的URL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ svn　switch　http://目录全路径　本地目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># (原为123的分支)当前所在目录分支到localhost/test/456</span></span><br><span class="line">$ svn switch http://localhost/<span class="built_in">test</span>/456 .</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ svn　resolved　[本地目录全路径]</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn update</span><br><span class="line">C foo.c</span><br><span class="line">Updated to revision 31.</span><br><span class="line"><span class="comment"># 如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span></span><br><span class="line">$ ls</span><br><span class="line">foo.c</span><br><span class="line">foo.c.mine</span><br><span class="line">foo.c.r30</span><br><span class="line">foo.c.r31</span><br><span class="line"><span class="comment"># 当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span></span><br><span class="line"><span class="comment"># 你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</span></span><br></pre></td></tr></table></figure><h2 id="不checkout而查看输出特定文件或URL的内容"><a href="#不checkout而查看输出特定文件或URL的内容" class="headerlink" title="不checkout而查看输出特定文件或URL的内容"></a>不checkout而查看输出特定文件或URL的内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ svn　cat　http://文件全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn cat http://localhost/<span class="built_in">test</span>/readme.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支copy</span></span><br><span class="line"><span class="comment"># 从branchA拷贝出一个新分支branchB</span></span><br><span class="line">$ svn copy branchA branchB  -m <span class="string">"make B branch"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并内容到分支merge</span></span><br><span class="line"><span class="comment"># 把对branchA的修改合并到分支branchB</span></span><br><span class="line">$ svn merge branchA branchB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;检出&quot;&gt;&lt;a href=&quot;#检出&quot; class=&quot;headerlink&quot; title=&quot;检出&quot;&gt;&lt;/a&gt;检出&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 也可以使用缩写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 例子：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn co http://localhost/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;/testapp --username wzhnsc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="svn" scheme="http://miaopei.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>hexo 使用指南</title>
    <link href="http://miaopei.github.io/2017/03/28/hexo-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://miaopei.github.io/2017/03/28/hexo-使用指南/</id>
    <published>2017-03-28T08:53:46.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装、初始化和配置"><a href="#安装、初始化和配置" class="headerlink" title="安装、初始化和配置"></a>安装、初始化和配置</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>git</li><li>node.js</li><li>github</li></ul><a id="more"></a><h3 id="安装和初始化"><a href="#安装和初始化" class="headerlink" title="安装和初始化"></a>安装和初始化</h3><p>首先确定已经安装好了 <code>nodejs</code> 和 <code>npm</code> 以及 <code>git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAw" title="http://localhost:4000">http://localhost:4000<i class="fa fa-external-link"></i></span>，会看到生成好的博客。</p><h3 id="主目录结构"><a href="#主目录结构" class="headerlink" title="主目录结构"></a>主目录结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-- _config.yml</span><br><span class="line">|-- package.json</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source</span><br><span class="line">   |-- _posts</span><br><span class="line">|-- themes</span><br><span class="line">|-- .gitignore</span><br><span class="line">|-- package.json</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。</p><p><strong>package.json</strong></p><p>hexo框架的参数和所依赖插件，如下：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"3.2.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.10"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>scaffold</strong></p><p>scaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。</p><p><strong>_config.yml文件</strong></p><p>_config.yml 采用YAML语法格式，<span class="exturl" data-url="aHR0cDovL215Lm9zY2hpbmEubmV0L3UvMTg2MTgzNy9ibG9nLzUyNjE0Mj9wPSU3QiU3QnRvdGFsUGFnZSU3RCU3RA==" title="http://my.oschina.net/u/1861837/blog/526142?p=%7B%7BtotalPage%7D%7D">具体语法自行学习<i class="fa fa-external-link"></i></span> 。<br>具体配置可以参考<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbi5odG1s" title="https://hexo.io/zh-cn/docs/configuration.html">官方文档<i class="fa fa-external-link"></i></span>，_config.yml 文件中的内容，并对主要参数做简单的介绍</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span>   <span class="comment">#网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span>     <span class="comment">#网站副标题</span></span><br><span class="line"><span class="attr">description:</span>  <span class="comment">#网站描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span>  <span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span>    <span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span>    <span class="comment">#网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://yoursite.com</span>   <span class="comment">#你的站点Url</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                    <span class="comment">#站点的根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>   <span class="comment">#文章的 永久链接 格式   </span></span><br><span class="line"><span class="attr">permalink_defaults:</span>    <span class="comment">#永久链接中各部分的默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory   </span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span>         <span class="comment">#资源文件夹，这个文件夹用来存放内容</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span>         <span class="comment">#公共文件夹，这个文件夹用于存放生成的站点文件。</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span>              <span class="comment">#标签文件夹     </span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span>      <span class="comment">#归档文件夹</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span>   <span class="comment">#分类文件夹</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span>   <span class="comment">#Include code 文件夹</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span>            <span class="comment">#国际化（i18n）文件夹</span></span><br><span class="line"><span class="attr">skip_render:</span>               <span class="comment">#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>   <span class="comment">#新文章的文件名称</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>       <span class="comment">#预设布局</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span>           <span class="comment">#把标题转换为 title case</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span>        <span class="comment">#在新标签中打开链接</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span>           <span class="comment">#把文件名称转换为 (1) 小写或 (2) 大写</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span>       <span class="comment">#是否显示草稿</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span>   <span class="comment">#是否启动 Asset 文件夹</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span>       <span class="comment">#把链接改为与根目录的相对位址    </span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span>               <span class="comment">#显示未来的文章</span></span><br><span class="line"><span class="attr">highlight:</span>                 <span class="comment">#内容中代码块的设置    </span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span>          <span class="comment">#分类别名</span></span><br><span class="line"><span class="attr">tag_map:</span>               <span class="comment">#标签别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span>         <span class="comment">#日期格式</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span>           <span class="comment">#时间格式    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span>    <span class="comment">#分页数量</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span>   <span class="comment">#主题名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="comment">#  部署部分的设置</span></span><br><span class="line"><span class="attr">deploy:</span>     </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span>  <span class="comment">#类型，常用的git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/nanshanyi/nanshanyi.github.io.git</span> <span class="comment">#github仓库的地址</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>如果页面中出现中文，应以UTF-8无BOM编码格式，所以不要用win自带的记事本，而是用notepad++这种支持编码转换的编辑器。</strong></p><p>由于google在天朝大陆被墙，进入 <code>themes\landscape\layout\_partial</code> ，打开 <code>head.ejs</code> ，删掉第31行 <code>fonts.googleapis.com</code> 的链接。</p><p>下载下来 <code>jQuery-2.0.3.min.js</code> ，放到 <code>themes\landscape\source\js</code> 文件夹中。之后进入 <code>themes\landscape\layout\_partial</code> ，打开 <code>after-footer.ejs</code> ，将第17行的路径替换为 <code>/js/jquery-2.0.3.min.js</code> 。</p><p>至此大功告成。</p><h2 id="写文章-amp-草稿"><a href="#写文章-amp-草稿" class="headerlink" title="写文章&amp;草稿"></a>写文章&amp;草稿</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p>命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post <span class="string">"new article"</span></span><br></pre></td></tr></table></figure><p>之后在 <code>soource/_posts</code> 目录下面多了一个 <code>new-article.md</code> 的文件。</p><h3 id="文章属性"><a href="#文章属性" class="headerlink" title="文章属性"></a>文章属性</h3><table><thead><tr><th>Setting</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>layout</td><td>Layout</td><td>post或page</td></tr><tr><td>title</td><td>文章的标题</td><td></td></tr><tr><td>date</td><td>穿件日期</td><td>文件的创建日期</td></tr><tr><td>updated</td><td>修改日期</td><td>文件的修改日期</td></tr><tr><td>comments</td><td>是否开启评论</td><td>true</td></tr><tr><td>tags</td><td>标签</td><td></td></tr><tr><td>categories</td><td>分类</td><td></td></tr><tr><td>permalink</td><td>url中的名字</td><td>文件名</td></tr><tr><td>toc</td><td>是否开启目录</td><td>true</td></tr><tr><td>reward</td><td>是否开启打赏</td><td>true</td></tr></tbody></table><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - 日记</span><br><span class="line">tags:</span><br><span class="line">  - Hexo</span><br><span class="line">  - node.js</span><br></pre></td></tr></table></figure><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><code>&lt;!--more--&gt;</code> 之上的内容为摘要。</p><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>草稿相当于很多博客都有的“私密文章”功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"new draft"</span></span><br></pre></td></tr></table></figure><p>会在 <code>source/_drafts</code> 目录下生成一个 <code>new-draft.md</code> 文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到 <code>_drafts</code> 目录之中。</p><p>如果你希望强行预览草稿，更改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render_drafts: true</span><br></pre></td></tr></table></figure><p>或者，如下方式启动server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server --drafts</span><br></pre></td></tr></table></figure><p>下面这条命令可以把草稿变成文章，或者页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">$ hexo publish drafts hexo-使用指南</span><br></pre></td></tr></table></figure><h2 id="Blog中出入图片和音乐"><a href="#Blog中出入图片和音乐" class="headerlink" title="Blog中出入图片和音乐"></a>Blog中出入图片和音乐</h2><p>文章推介：<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzUzZTBkMmE2MTdkYQ==" title="http://www.jianshu.com/p/53e0d2a617da">Hexo 博客中插入音乐/视频<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cDovL2Jsb2cuc2hpcWljaGFuLmNvbS91c2UtcWluaXUtc3RvcmUtaW1hZ2UtZm9yLWhleG8v" title="http://blog.shiqichan.com/use-qiniu-store-image-for-hexo/">使用七牛为Hexo存储图片<i class="fa fa-external-link"></i></span></p><pre><code>[hexo主题中添加相册功能](http://www.cnblogs.com/xljzlw/p/5137622.html)</code></pre><p>​           <span class="exturl" data-url="aHR0cDovL3d1Y2hvbmcubWUvYmxvZy8yMDE0LzEyLzEzL2hleG8tdGhlbWUtY3JlYXRpbmctaW1hZ2Utc3R5bGVzLz91dG1fc291cmNlPXR1aWNvb2wmdXRtX21lZGl1bT1yZWZlcnJhbCM=" title="http://wuchong.me/blog/2014/12/13/hexo-theme-creating-image-styles/?utm_source=tuicool&utm_medium=referral#">为 Hexo 主题添加多种图片样式(主题不错考虑移植)<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzg2MDc=" title="https://yq.aliyun.com/articles/8607">Hexo折腾记——基本配置篇<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qYXJzb24tNzQyNi9wLzU1MTU4NzAuaHRtbA==" title="http://www.cnblogs.com/jarson-7426/p/5515870.html">hexo博客进阶－相册和独立域名<i class="fa fa-external-link"></i></span></p><p>插入图片基本分为两种办法** ：</p><p>（1） 放在本地文件</p><p>首先在根目录下确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。<br>在 hexo 目录，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>之后再使用 <code>hexo new &#39;new&#39;</code>创建新博客的时候，会在 <code>source/_posts</code> 里面创建 <code>.md</code> 文件的同时生成一个相同的名字的文件夹。把该文章中需要使用的图片放在该文件夹下即可。<br>使用的时候</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">“图片描述”（可以不写）</span>](<span class="link">/文件夹名/你的图片名字.JPG</span>)</span><br><span class="line">例如：</span><br><span class="line">！[ ] (new/text.jpg)</span><br></pre></td></tr></table></figure><p>（2）放在<span class="exturl" data-url="aHR0cHM6Ly9wb3J0YWwucWluaXUuY29tL3NpZ251cD9jb2RlPTNsZ2xhczZwZ2kycWE=" title="https://portal.qiniu.com/signup?code=3lglas6pgi2qa">七牛<i class="fa fa-external-link"></i></span>上，需要先注册，上传图片生成链接，直接在文章中使用链接即可。</p><p><strong>插入音乐</strong> ：</p><p>可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器；复制代码，直接粘贴到博文中即可。这样会显示一个网易的播放器，可以把</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">298</span> <span class="attr">height</span>=<span class="string">52</span> <span class="attr">src</span>=<span class="string">"http://music.163.com/outchain/player?type=2&amp;id=32192436&amp;auto=1&amp;height=32"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">//其中的width=298 height=52 均改为0就看不到了，依然可以播放音乐</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/Y60twn8.png" alt></p><p><img src="http://i.imgur.com/i42cvBI.png" alt></p><h2 id="代码高亮highlight-js支持"><a href="#代码高亮highlight-js支持" class="headerlink" title="代码高亮highlight.js支持"></a>代码高亮highlight.js支持</h2><p><span class="exturl" data-url="aHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcv" title="https://highlightjs.org/">highlightjs官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvc3RhdGljL2RlbW8v" title="https://highlightjs.org/static/demo/">highlightjs主题风格<i class="fa fa-external-link"></i></span></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy55ZWhiZWF0cy5jb20vMjAxNS8wNC8wOC9oZXhvLXNlYXJjaC8=" title="http://www.yehbeats.com/2015/04/08/hexo-search/">Hexo，Yilia主题添加站内搜索功能<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2t1YW5ncWkubWUvdHJpY2tzL2VuYWJsZS10YWJsZS1vZi1jb250ZW50cy1vbi1oZXhvLw==" title="http://kuangqi.me/tricks/enable-table-of-contents-on-hexo/">为Hexo博客添加目录<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9hcnRpY2xlLzE5OTYyNA==" title="http://www.ituring.com.cn/article/199624">Hexo站点中添加文章目录以及归档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2NyZXNjZW50bW9vbi5pbmZvLzIwMTQvMTIvMTEvcG9wdWxhci13aWRnZXQv" title="http://crescentmoon.info/2014/12/11/popular-widget/">使用LeanCloud平台为Hexo博客添加文章浏览量统计组件<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy50dWljb29sLmNvbS9hcnRpY2xlcy9BQkZuMnFV" title="http://www.tuicool.com/articles/ABFn2qU">使用hexo搭建静态博客<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9hcnRpY2xlLzE5OTAzNT91dG1fc291cmNlPXR1aWNvb2wmdXRtX21lZGl1bT1yZWZlcnJhbA==" title="http://www.ituring.com.cn/article/199035?utm_source=tuicool&utm_medium=referral">Hexo Docs中文 ： （二）基本用法<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装、初始化和配置&quot;&gt;&lt;a href=&quot;#安装、初始化和配置&quot; class=&quot;headerlink&quot; title=&quot;安装、初始化和配置&quot;&gt;&lt;/a&gt;安装、初始化和配置&lt;/h2&gt;&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;node.js&lt;/li&gt;
&lt;li&gt;github&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://miaopei.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>nodejs+webpack+vuejs 搭建开发环境学习套路</title>
    <link href="http://miaopei.github.io/2017/03/27/nodejs-webpack-vuejs-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AD%A6%E4%B9%A0%E5%A5%97%E8%B7%AF/"/>
    <id>http://miaopei.github.io/2017/03/27/nodejs-webpack-vuejs-搭建开发环境学习套路/</id>
    <published>2017-03-27T10:02:52.000Z</published>
    <updated>2017-03-28T10:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><span class="exturl" data-url="aHR0cDovL3Z1ZWpzLm9yZy92Mi9ndWlkZS8=" title="http://vuejs.org/v2/guide/">官方手册<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv" title="https://cn.vuejs.org/">中文官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly92dWVmZS5jbi92Mi9ndWlkZS8=" title="https://vuefe.cn/v2/guide/">vuejs 2.0 中文文档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=" title="http://es6.ruanyifeng.com/">ECMAScript 6 入门<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Nub2RlanMub3JnL3RvcGljLzUyOGM5YTM4ZDJiMzg5M2YyYWJiNmVlYg==" title="http://cnodejs.org/topic/528c9a38d2b3893f2abb6eeb">node.js相关的中文文档及教程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkv" title="http://nodejs.cn/api/">Node.js中文网API<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3dlYnBhY2tkb2MuY29tLw==" title="http://webpackdoc.com/">Webpack 中文指南<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3dlYnBhY2syLw==" title="http://www.css88.com/doc/webpack2/">webpack2.2中文文档<i class="fa fa-external-link"></i></span></p><p>以上是提供的一些官方资料，下面开始我们的套路吧：</p><a id="more"></a><h3 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建"></a>环境构建</h3><p>1.新建一个目录<code>vuepro</code><br>2.初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vuepro</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化的时候可以一路回车，在最后输入"yes"后会生成package.json文件</span></span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>3.安装模块，先装这么多，有需要再安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install vue webpack babel-loader babel-core babel-preset-env babel-cli babel-preset-es2015 html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>4.创建良好的目录层级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir src</span><br><span class="line">$ <span class="built_in">cd</span> src &amp;&amp; mkdir -p html jssrc webapp</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/qkj7kJd.png" alt>    </p><p><code>html</code>放置模板文件，<code>jssrc</code>放置js文件，最终编译好的文件放置在<code>webapp</code>目录里，这个目录也就是我们网站的目录。</p><p>5.在项目根目录下创建webpack配置文件：<code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack=<span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports =</span><br><span class="line">&#123;</span><br><span class="line">    entry:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//入口文件</span></span><br><span class="line">        <span class="string">"index"</span>:__dirname+<span class="string">'/src/jssrc/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname+<span class="string">'/src/webapp/js'</span>,  <span class="comment">//输出文件夹</span></span><br><span class="line">        filename:<span class="string">'[name].js'</span>   <span class="comment">//最终打包生成的文件名(只是文件名，不带路径的哦)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*resolve: &#123;</span></span><br><span class="line"><span class="comment">        alias: &#123;</span></span><br><span class="line"><span class="comment">            vue: 'vue/dist/vue.js'</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;,*/</span></span><br><span class="line">    externals: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,<span class="attr">loader</span>:<span class="string">"babel-loader"</span>,<span class="attr">query</span>:&#123;<span class="attr">compact</span>:<span class="literal">true</span>&#125;&#125;,</span><br><span class="line">            <span class="comment">//这里肯定要加入n个loader 譬如vue-loader、babel-loader、css-loader等等</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            filename: __dirname+<span class="string">'/src/webapp/index.html'</span>,   <span class="comment">//目标文件</span></span><br><span class="line">            template: __dirname+<span class="string">'/src/html/index.html'</span>, <span class="comment">//模板文件</span></span><br><span class="line">            inject:<span class="string">'body'</span>,</span><br><span class="line">            hash:<span class="literal">true</span>,  <span class="comment">//代表js文件后面会跟一个随机字符串,解决缓存问题</span></span><br><span class="line">            chunks:[<span class="string">"index"</span>]</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.同样在根目录下创建babel配置文件：<code>.babelrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot; : [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在webpack里面配置loader，我们上面webpack配置中已经写了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loaders:[</span><br><span class="line">           &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,<span class="attr">loader</span>:<span class="string">"babel-loader"</span>,<span class="attr">query</span>:&#123;<span class="attr">compact</span>:<span class="literal">true</span>&#125;&#125;,</span><br><span class="line">  <span class="comment">// 经过测试旧版用的是loader:"babel",在新版中用的是loader:"babel-loader"</span></span><br><span class="line">       ]</span><br></pre></td></tr></table></figure><p>这句话意思就是：凡是 <code>.js</code> 文件都使用 <code>babel-loader</code> , 并且压缩。</p><h3 id="学习vue最简单的一个套路"><a href="#学习vue最简单的一个套路" class="headerlink" title="学习vue最简单的一个套路"></a>学习vue最简单的一个套路</h3><p>思考：数据如何渲染？</p><p>套路如下：</p><p>首先要有个数据块标记</p><p>vue里面可以像模板引擎一样写上 <code>{\{name\}}</code></p><p>其中 <code>name</code> 就是变量名</p><h3 id="接下来进行实战练习"><a href="#接下来进行实战练习" class="headerlink" title="接下来进行实战练习"></a>接下来进行实战练习</h3><p><img src="http://i.imgur.com/UhW18FI.png" alt>    </p><p>index.htm l如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"me"</span>&gt;</span></span><br><span class="line">        我的年龄是&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index.js 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>; <span class="comment">//会去node_modules\vue\package.json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#me"</span>,</span><br><span class="line">    data:&#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此，我们需要用 <code>webpack</code> 打包，打包到 <code>webapp</code> 目录下。 </p><p>需要修改2个地方： </p><p>(1)因为我们的 <code>webpack</code> 不是全局安装的，所以不能直接执行 <code>webpack</code> 命令，我们这里借助 <code>npm</code> 来执行。所以需要修改项目根目录下的 <code>package.json</code> 文件，加入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">  "build": "webpack"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>表示：执行build，就会去node_modules.bin\下去寻找webpack命令。<code>build</code> 这个名字是自定义的。</p><p>(2)还需要修改 webpack 配置文件：<code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            vue: <span class="string">'vue/dist/vue.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>我们之前把这个注释掉了，现在打开。此处的意义是找到 <code>node_modules/vue/dist/vue.js</code></p><p>最后，我们就来打包，看看结果是怎样的？ </p><p>终端里还是cd到项目根目录下，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/wmjrYdu.png" alt>    </p><p><code>index.html</code>  就是打包之后的模板文件，<code>js/index.js</code> 就是打包之后的js文件，在 <code>index.html</code> 被引用了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"me"</span>&gt;</span></span><br><span class="line">        我的年龄是&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/index.js?43c73980e35f1569ef72"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预览一下index.html: </p><p><img src="http://i.imgur.com/6kHwB4L.png" alt></p><p>这样就完成了 <code>vueJS</code> 的一个简单案列</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3Z1ZWpzLm9yZy92Mi9ndWlkZS8=&quot; title=&quot;http://vuejs.org/v2/guide/&quot;&gt;官方手册&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jbi52dWVqcy5vcmcv&quot; title=&quot;https://cn.vuejs.org/&quot;&gt;中文官网&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly92dWVmZS5jbi92Mi9ndWlkZS8=&quot; title=&quot;https://vuefe.cn/v2/guide/&quot;&gt;vuejs 2.0 中文文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=&quot; title=&quot;http://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Nub2RlanMub3JnL3RvcGljLzUyOGM5YTM4ZDJiMzg5M2YyYWJiNmVlYg==&quot; title=&quot;http://cnodejs.org/topic/528c9a38d2b3893f2abb6eeb&quot;&gt;node.js相关的中文文档及教程&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL25vZGVqcy5jbi9hcGkv&quot; title=&quot;http://nodejs.cn/api/&quot;&gt;Node.js中文网API&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3dlYnBhY2tkb2MuY29tLw==&quot; title=&quot;http://webpackdoc.com/&quot;&gt;Webpack 中文指南&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3dlYnBhY2syLw==&quot; title=&quot;http://www.css88.com/doc/webpack2/&quot;&gt;webpack2.2中文文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上是提供的一些官方资料，下面开始我们的套路吧：&lt;/p&gt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://miaopei.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github 博客多终端同步</title>
    <link href="http://miaopei.github.io/2017/03/20/Hexo-Github-%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/"/>
    <id>http://miaopei.github.io/2017/03/20/Hexo-Github-博客多终端同步/</id>
    <published>2017-03-19T20:20:57.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9ua2V5X0xaTC9hcnRpY2xlL2RldGFpbHMvNjA4NzA4OTE=" title="http://blog.csdn.net/Monkey_LZL/article/details/60870891">原文链接<i class="fa fa-external-link"></i></span></p><p>主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解：</p><a id="more"></a><h2 id="1-准备条件"><a href="#1-准备条件" class="headerlink" title="1. 准备条件"></a>1. 准备条件</h2><p>安装了Node.js,Git,Hexo环境<br>完成Github与本地Hexo的对接<br>这部分大家可以参考<span class="exturl" data-url="aHR0cHM6Ly94dWFud28ub3JnLzIwMTUvMDMvMjYvaGV4by1pbnRvci8=" title="https://xuanwo.org/2015/03/26/hexo-intor/">史上最详细的Hexo博客搭建图文教程<i class="fa fa-external-link"></i></span></p><p>配置好这些，就可以捋起袖子大干一场了！</p><h2 id="2-在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上"><a href="#2-在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上" class="headerlink" title="2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上"></a>2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上</h2><p>在利用Github+Hexo搭建自己的博客时，新建了一个Hexo的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到Github项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件</span></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line">$ git commit -m <span class="string">"Blog Source Hexo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建hexo分支</span></span><br><span class="line">$ git branch hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到hexo分支上</span></span><br><span class="line">$ git checkout hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地与Github项目对接</span></span><br><span class="line">$ git remote add origin https://github.com/yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># push到Github项目的hexo分支上</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure><p>这样你的github项目中就会多出一个Hexo分支，这个就是用于多终端同步关键的部分。</p><h2 id="3-另一终端完成clone和push更新"><a href="#3-另一终端完成clone和push更新" class="headerlink" title="3. 另一终端完成clone和push更新"></a>3. 另一终端完成clone和push更新</h2><p>此时在另一终端更新博客，只需要将Github的hexo分支clone下来，进行初次的相关配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将Github中hexo分支clone到本地</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b hexo https://github.com/yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到刚刚clone的文件夹内</span></span><br><span class="line">$ <span class="built_in">cd</span> yourname.github.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># cheackout 远程代码到本地hexo分支</span></span><br><span class="line">$ git checkout -b hexo origin/hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init</span></span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个.md文件，并编辑完成自己的博客内容</span></span><br><span class="line">$ hexo new post <span class="string">"new blog name"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客</span></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line">$ git commit -m <span class="string">"XX"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新分支</span></span><br><span class="line">$ git push origin hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master</span></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><h2 id="4-不同终端间愉快地玩耍"><a href="#4-不同终端间愉快地玩耍" class="headerlink" title="4. 不同终端间愉快地玩耍"></a>4. 不同终端间愉快地玩耍</h2><p>在不同的终端已经做完配置，就可以愉快的分享自己更新的博客<br>进入自己相应的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先pull完成本地与远端的融合</span></span><br><span class="line">$ git pull origin hexo</span><br><span class="line"></span><br><span class="line">$ hexo new post <span class="string">" new blog name"</span></span><br><span class="line"></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"XX"</span></span><br><span class="line"></span><br><span class="line">$ git push origin hexo</span><br><span class="line"></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9ua2V5X0xaTC9hcnRpY2xlL2RldGFpbHMvNjA4NzA4OTE=&quot; title=&quot;http://blog.csdn.net/Monkey_LZL/article/details/60870891&quot;&gt;原文链接&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解：&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://miaopei.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>常用Git命令清单</title>
    <link href="http://miaopei.github.io/2017/01/27/git-common-list/"/>
    <id>http://miaopei.github.io/2017/01/27/git-common-list/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>我每天使用 Git ，但是很多命令记不住。</p><p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p><a id="more"></a><p><img src="http://i.imgur.com/zYeQxr4.png" alt></p><p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><pre><code># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><pre><code># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><pre><code># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><pre><code># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><pre><code># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><pre><code># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]</code></pre><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><pre><code># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><pre><code># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><pre><code># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop</code></pre><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><pre><code># 生成一个可供发布的压缩包$ git archive</code></pre>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git使用规范流程</title>
    <link href="http://miaopei.github.io/2017/01/27/git-using-standard-process/"/>
    <id>http://miaopei.github.io/2017/01/27/git-using-standard-process/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。</p><p>否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。</p><p>下面是ThoughtBot 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。</p><a id="more"></a><p><img src="http://i.imgur.com/WjTakfD.png" alt></p><h2 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h2><p>首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考《Git分支管理策略》）。</p><pre><code># 获取主干最新代码$ git checkout master$ git pull# 新建一个开发分支myfeature$ git checkout -b myfeature</code></pre><h2 id="第二步：提交分支commit"><a href="#第二步：提交分支commit" class="headerlink" title="第二步：提交分支commit"></a>第二步：提交分支commit</h2><p>分支修改后，就可以提交commit了。</p><pre><code>$ git add --all$ git status$ git commit --verbose</code></pre><p><code>git add</code> 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。</p><p><code>git status</code> 命令，用来查看发生变动的文件。</p><p><code>git commit</code> 命令的 <code>verbose</code> 参数，会列出 diff 的结果。</p><h2 id="第三步：撰写提交信息"><a href="#第三步：撰写提交信息" class="headerlink" title="第三步：撰写提交信息"></a>第三步：撰写提交信息</h2><p>提交commit时，必须给出完整扼要的提交信息，下面是一个范本。</p><pre><code>Present-tense summary under 50 characters* More information about commit (under 72 characters).* More information about commit (under 72 characters).http://project.management-system.com/ticket/123</code></pre><p>第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。</p><h2 id="第四步：与主干同步"><a href="#第四步：与主干同步" class="headerlink" title="第四步：与主干同步"></a>第四步：与主干同步</h2><p>分支的开发过程中，要经常与主干保持同步。</p><pre><code>$ git fetch origin$ git rebase origin/master</code></pre><h2 id="第五步：合并commit"><a href="#第五步：合并commit" class="headerlink" title="第五步：合并commit"></a>第五步：合并commit</h2><p>分支开发完成后，很可能有一堆 <code>commit</code>，但是合并到主干的时候，往往希望只有一个（或最多两三个）<code>commit</code>，这样不仅清晰，也容易管理。</p><p>那么，怎样才能将多个 <code>commit</code> 合并呢？这就要用到 <code>git rebase</code> 命令。</p><pre><code>$ git rebase -i origin/master</code></pre><p><code>git rebase</code> 命令的 <code>i</code> 参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usagepick de9b1eb Fix PostChecker::Post#urlspick 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend# Rebase 8db7e8b..fa20af3 onto 8db7e8b## Commands:#  p, pick = use commit#  r, reword = use commit, but edit the commit message#  e, edit = use commit, but stop for amending#  s, squash = use commit, but meld into previous commit#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message#  x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out</code></pre><p>上面的互动界面，先列出当前分支最新的4个 <code>commit</code>（越下面越新）。每个 <code>commit</code> 前面有一个操作命令，默认是 <code>pick</code>，表示该行 <code>commit</code> 被选中，要进行 <code>rebase</code> 操作。</p><p>4个commit的下面是一大堆注释，列出可以使用的命令。</p><ul><li>pick：正常选中</li><li>reword：选中，并且修改提交信息；</li><li>edit：选中，rebase时会暂停，允许你修改这个commit（参考这里）</li><li>squash：选中，会将当前commit与上一个commit合并</li><li>fixup：与squash相同，但不会保存当前commit的提交信息</li><li>exec：执行其他shell命令</li></ul><p>上面这6个命令当中，<code>squash</code> 和 <code>fixup</code> 可以用来合并 <code>commit</code>。先把需要合并的 <code>commit</code> 前面的动词，改成 <code>squash</code>（或者s）。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlss 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend</code></pre><p>这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。</p><pre><code># This is a combination of 3 commits.# The first commit&apos;s message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:Hey kids, stop all the highlighting</code></pre><p>如果将第三行的 <code>squash</code> 命令改成 <code>fixup</code> 命令。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlsf 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend</code></pre><p>运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。</p><pre><code># This is a combination of 3 commits.# The first commit&apos;s message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:# Hey kids, stop all the highlighting</code></pre><p>Pony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。</p><pre><code>$ git reset HEAD~5$ git add .$ git commit -am &quot;Here&apos;s the bug fix that closes #28&quot;$ git push --force</code></pre><p><code>squash</code> 和 <code>fixup</code> 命令，还可以当作命令行参数使用，自动合并commit。</p><pre><code>$ git commit --fixup  $ git rebase -i --autosquash </code></pre><p>这个用法请参考<span class="exturl" data-url="aHR0cDovL2ZsZS5naXRodWIuaW8vZ2l0LXRpcC1rZWVwLXlvdXItYnJhbmNoLWNsZWFuLXdpdGgtZml4dXAtYW5kLWF1dG9zcXVhc2guaHRtbA==" title="http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html">http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html<i class="fa fa-external-link"></i></span>，这里就不解释了。</p><h2 id="第六步：推送到远程仓库"><a href="#第六步：推送到远程仓库" class="headerlink" title="第六步：推送到远程仓库"></a>第六步：推送到远程仓库</h2><p>合并commit后，就可以推送当前分支到远程仓库了。</p><pre><code>$ git push --force origin myfeature</code></pre><p><code>git push</code> 命令要加上 <code>force</code> 参数，因为 <code>rebase</code> 以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送。</p><h2 id="第七步：发出Pull-Request"><a href="#第七步：发出Pull-Request" class="headerlink" title="第七步：发出Pull Request"></a>第七步：发出Pull Request</h2><p>提交到远程仓库以后，就可以发出 <code>Pull Request</code> 到 <code>master</code> 分支，然后请求别人进行代码 <code>review</code>，确认可以合并到 <code>master</code>。</p>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="http://miaopei.github.io/2016/12/23/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://miaopei.github.io/2016/12/23/Docker-学习笔记/</id>
    <published>2016-12-23T02:14:50.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h1><h3 id="常用Docker命令"><a href="#常用Docker命令" class="headerlink" title="常用Docker命令"></a>常用Docker命令</h3><hr><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启Docker守护进程调试模式</span></span><br><span class="line">$ sudo docker daemon -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Docker信息</span></span><br><span class="line">$ sudo docker info </span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止或者启动Docker</span></span><br><span class="line">$ sudo service docker stop/start </span><br><span class="line"></span><br><span class="line"><span class="comment"># 以命令行模式运行一个容器</span></span><br><span class="line">$ sudo docker run -i -t ubuntu /bin/bash </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给容器命名</span></span><br><span class="line">$ sudo docker run --name Micheal_container -i -t ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动或者停止运行的容器</span></span><br><span class="line">$ sudo docker start/stop Micheal_container </span><br><span class="line"></span><br><span class="line"><span class="comment"># 附着到正在运行的容器</span></span><br><span class="line">$ sudo docker attach Micheal_container</span><br></pre></td></tr></table></figure><p><strong>创建守护式容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的docker run 使用了<code>-d</code>参数，因此Docker会将容器放到后台运行。</p></blockquote><p><strong>Docker日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取守护式容器的日志</span></span><br><span class="line">$ sudo docker logs daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪守护式容器的日志</span></span><br><span class="line">$ sudo docker logs -f daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取日志的最后10行</span></span><br><span class="line">$ sudo docker logs --tail 10 daemon_dave </span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪某个容器的最新日志</span></span><br><span class="line">$ sudo docker logs --tail 0 -f daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># -t 标志为每条日志项加上时间戳</span></span><br><span class="line">$ sudo docker logs -ft daemon_dave</span><br></pre></td></tr></table></figure><p><strong>Docker日志驱动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --<span class="built_in">log</span>-driver=<span class="string">"syslog"</span> --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p>使用syslog将会禁用docker logs命令，并且将所有容器的日志输出都重定向到Syslog。</p></blockquote><p><strong>查看容器内的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker top daemon_dave</span><br></pre></td></tr></table></figure><p><strong>Docker统计信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker stats daemon_dave daemon_kate daemon_clear daemon_sarah</span><br></pre></td></tr></table></figure><blockquote><p>以上命令可以看到一个守护容器的列表，以及他们的CPU、内存、网络I/O以及存储I/O的性能和指标。这对快速监控一台主机上的一组容器非常有用。</p></blockquote><p><strong>在容器内部运行进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -d daemon_dave touch /etc/new_config_file</span><br></pre></td></tr></table></figure><blockquote><p><code>-d</code>表示需要运行一个后台进程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内运行交互命令</span></span><br><span class="line">$ sudo docker <span class="built_in">exec</span> -t -i daemon_dave /bin/bash</span><br></pre></td></tr></table></figure><p><strong>自动重启容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --restart=always --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p><code>--restart</code>标志被设置为always。无论容器的退出代码是什么，Docker都会自动重启改容器。除了always，还可以将这个标志设为<code>on-failure</code>，这样，只有当容器的退出代码为非0值的时候，才会自动重启。另外，on-failure还接受一个可选的重启次数参数，<code>--restart=on-failure:5</code>,Docker会尝试自动重启改容器，最多重启5次。</p></blockquote><p><strong>深入容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect daemon_dave</span><br></pre></td></tr></table></figure><blockquote><p>docker inspect命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置以及很多有用的数据。可以使用<code>-f</code>或者<code>--format</code>标志来选定查看结果。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format=<span class="string">'&#123;.State.Running&#125;'</span> daemon_dave</span><br></pre></td></tr></table></figure><blockquote><p>查看多个容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format <span class="string">'&#123;.Name&#125; &#123;.State.Running&#125;'</span> daemon_dave Micheal_container</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong><br>​    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker rm daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line">$ sudo docker rm `sudo docker ps -a -q`</span><br></pre></td></tr></table></figure><p><strong>列出所有镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br></pre></td></tr></table></figure><p><strong>拉去镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure><p><strong>运行一个带标签的Docker镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t --name new_container ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure><p><strong>查找镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker search puppet</span><br></pre></td></tr></table></figure><p><strong>构建镜像</strong></p><ul><li>使用<code>docker commit</code>命令</li><li>使用<code>docker build</code>命令和<code>Dockerfile</code>文件</li></ul><p><strong>用Docker的commit命令创建镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来安装需要安装的工具，安装完成后exit退出容器, eg：</span></span><br><span class="line">$ apt-get -yqq update</span><br><span class="line">$ apt-get -y install apache2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定提交修改过的容器的ID（可以通过docker ps -l -q命令得到刚创建的容器的ID）</span></span><br><span class="line">$ sudo docker commit 4aab3cecb76 micheal/apache2  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查新创建的镜像</span></span><br><span class="line">sudo docker images micheal/apache2  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交另一个新定制容器</span></span><br><span class="line"><span class="comment"># -m 选项用来指定新创建的镜像的提交信息，-a 用来列出该镜像的作者信息。</span></span><br><span class="line">$ sudo docker commit -m<span class="string">"A new custom image"</span> -a<span class="string">"Micheal"</span> 4aab3cecb76 micheal/apache2:webserver</span><br></pre></td></tr></table></figure><p><strong>用Dockerfile构建镜像</strong></p><p>Dockerfile文件示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Vsersion: 0.0.1</span></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER Micheal "miaopei@baicells.com"</span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get -y install nginx</span><br><span class="line">RUN echo 'Hi, I an in your container' &gt; /usr/share/nginx/html/index.html</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><blockquote><p>Dockerfile中的指令会按照顺序从上到下执行，所以根据需要合理安排指令的顺序。</p><p>如果Dockerfile由于某些原因没有正常结束，那么用户得到了一个可以使用的镜像。这对调试非常有帮助：可以基于改镜像运行一个具备交互功能的容器，使用最后创建的镜像对为什么用户指令会失败进行调试。</p><p><strong>每个Dockerfile的第一条指令必须是FROM</strong>,FROM指令指定一个已经存在的镜像，后续指令都将基于该镜像进行，这个镜像被称为基础镜像。</p><p>MAINTAINER指令告诉Docker镜像的作者是谁，以及作者的电子邮件。有助于标识镜像的所有者和联系方式。</p></blockquote><blockquote><p>默认情况下，RUN指令会在shell里使用命令包装器<code>/bin/sh -c</code>来执行，如果是在一个不支持shell的平台上运行或者不希望在shell中运行（比如避免shell字符串篡改），也可以使用<code>exec</code>格式的RUN指令，如下所示：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ "apt-get", " install", "-y", "nginx" ]</span><br></pre></td></tr></table></figure><blockquote><p>EXPOSE指令告诉Docker该容器内的应用程序将会使用该容器的指定端口。</p></blockquote><p><strong>基于Dockerfile构建新镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web"</span> .</span><br><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web:v1"</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里Docker假设在这个Git仓库的根目录下存在Dockerfile文件</span></span><br><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web:v1"</span> git@github.com:micheal/docker_static_web  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略Dockerfile的构建缓存</span></span><br><span class="line">$ sudo docker build --no-cache -t=<span class="string">"micheal/static_web"</span> .</span><br></pre></td></tr></table></figure><p><strong>查看镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出Docker镜像</span></span><br><span class="line">$ sudo docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像每一层，以及创建这些层的Dockerfile指令</span></span><br><span class="line">$ sudo docker <span class="built_in">history</span> micheal/static_web </span><br><span class="line"></span><br><span class="line">$ sudo docker run -d -p 80 --name statix_web micheal/static_web nginx -g <span class="string">"daemon off;"</span></span><br></pre></td></tr></table></figure><blockquote><p>nginx -g “daemon off;”,这将以前台的方式启动Nginx。</p><p><code>-p</code>标志用来控制Docker在运行时应该公开那些网络端口给外部（宿主机）。运行一个容器时，Docker可以通过两种方式来在宿主机上分配端口。</p><ul><li>Docker可以在宿主机上随机选择一个位于32768 ~ 61000的一个比较大的端口号来映射到容器中的80端口上。</li><li>可以在Docker宿主机只指定一个具体的端口号来映射到容器中的80端口上。</li></ul></blockquote><p><strong>查看Docker端口映射情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回宿主机中映射的端口</span></span><br><span class="line">$ sudo socker port static_web 80 </span><br><span class="line"></span><br><span class="line"><span class="comment"># -p会将容器内的80端口绑定到宿主机的8080端口上</span></span><br><span class="line">$ sudo docker run -d -p 8080:80 --name statix_web micheal/static_web nginx -g <span class="string">"daemon off;"</span></span><br></pre></td></tr></table></figure><p><strong>Dockerfile指令</strong></p><ol><li>CMD</li></ol><blockquote><p>CMD指令用于指定一个容器启动时要运行的命令。这有点儿类似于RUN指令，只是RUN指令是指定容器镜像被构建时要运行的命令，而CMD是指定容器被启动时要运行的命令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash/"</span>, <span class="string">"-l"</span>]</span><br></pre></td></tr></table></figure><ol><li>ENTRYPOINT</li></ol><blockquote><p>ENTRYPOINT和CMD指令非常类似，我们可在docker run命令行中覆盖CMD指令，而ENTRYPOINT指令提供的命令则不容易在启动容器的时候被覆盖。</p><p>可以组合使用ENTRYPOINT和CMD指令来完成一些巧妙的工作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">"/usr/sbin/nginx"</span>]</span><br><span class="line">CMD [<span class="string">"-h"</span>]</span><br></pre></td></tr></table></figure><ol><li>WORKDIR</li></ol><blockquote><p>WORKDIR指令用来在从镜像创建一个新容器时，在容器内部设置一个工作目录，ENTRYPOINT和/或CMD指定的程序会在这个目录下执行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /opt/webapp/db</span><br><span class="line">RUN bundle install</span><br><span class="line">WORKDIR /opt/webapp</span><br><span class="line">ENTRYPOINT [<span class="string">"rackup"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>-w</code>标志在运行时覆盖工作目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -ti -w /var/<span class="built_in">log</span> ubuntu <span class="built_in">pwd</span>/var/<span class="built_in">log</span></span><br></pre></td></tr></table></figure><ol><li>ENV</li></ol><blockquote><p>ENV指令用来在镜像构建过程中设置环境变量。这些变量会持久保存到从我们镜像创建的任何容器中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV RVM_PATH /home/rvm</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用docker run命令行的<code>-e</code>标志来传递环境变量。这些环境变量只会在运行时有效。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -ti -e <span class="string">"WEB_PORT=8080"</span> ubuntu env</span><br></pre></td></tr></table></figure><ol><li>USER</li></ol><blockquote><p>USER指令用来指定该镜像会以什么样的用户身份来运行。我们可以指定用户名或者UID以及组或GID，甚至是两者的组合。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure><blockquote><p>也可以在docker run命令行中通过<code>-u</code>标志覆盖该指令指定的值。</p></blockquote><ol><li>VOLUME</li></ol><blockquote><p>VOLUME指令用来向基于镜像创建的容器添加卷。一个卷可以存在于一个或者多个容器内特定的目录，这个目录可以绕过联合文件系统，并提供如下共享数据或者对数据进行持久化的功能。</p><ul><li>卷可以在容器间共享和重用</li><li>一个容器可以不是必须和其他容器共享卷</li><li>对卷的修改是立即生效的</li><li>对卷的修改不会对更新镜像产生影响</li><li>卷会一直存在直到没有任何容器再使用它</li></ul><p>卷功能让我们可以将数据（如源代码）、数据库或者其他内容添加到镜像中而不是将这些内容提交到镜像中，并且允许我们在多个容器间共享这些内容，我们可以利用此功能来测试容器和内部应用程序代码，管理日志，或者处理容器内部的数据库。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/opt/project"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>这条指令将会基于此镜像的任何容器创建一个名为/opt/project的挂载点。</p><p>也可以通过指定数组的方式指定多个卷</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/opt/project"</span>, <span class="string">"/data"</span>]</span><br></pre></td></tr></table></figure><ol><li>ADD</li></ol><blockquote><p>ADD指令用来将构建环境下的文件和目录复制到镜像中。不能对构建目录或者上下文之外的文件进行ADD操作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD software.lic /opt/application/software.lic</span><br><span class="line">ADD latest.tar.gz /var/www/wordpress/   //这条指令会将归档文件解开到指定的目录下</span><br></pre></td></tr></table></figure><ol><li>COPY</li></ol><blockquote><p>COPY指令非常类似ADD，它们根本不同是COPY只关心构建上下文中复制本地文件，而不会去做文件提取（extraction）和解压（decompression）的工作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY conf.d/ /etc/apache2/</span><br></pre></td></tr></table></figure><ol><li>LABEL</li></ol><blockquote><p>LABEL指令用于为Docker镜像添加元数据。元数据以键值对的形式展现</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=<span class="string">"1.0"</span></span><br><span class="line">LABEL location=<span class="string">"New York"</span> <span class="built_in">type</span>=<span class="string">"Data Center"</span> role=<span class="string">"Web Server"</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用docker inspect命令查看容器标签</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect micheal/apache2</span><br></pre></td></tr></table></figure><ol><li>STOPSIGNAL</li></ol><blockquote><p>STOPSIGNAL指令用来设置停止容器时发送什么系统调用信号给容器。</p></blockquote><ol><li>ARG</li></ol><blockquote><p>ARG指令用来定义可以在docker build命令运行时传递给构建运行时的变量，我们只需要在构建时使用–build-arg标志即可。用户只能在构建时指定在Dockerfile文件汇总定义过的参数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG build</span><br><span class="line">ARG webapp_user=user</span><br><span class="line"></span><br><span class="line">$ docker build --build-arg build=1234 -t micheal/webapp .</span><br></pre></td></tr></table></figure><ol><li>ONBUILD</li></ol><blockquote><p>ONBUILD指令能为镜像添加触发器（trigger）。当一个镜像被用做其他镜像的基础镜像时（比如用户的镜像需要从某未准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本），该镜像中的触发器将会被执行。</p><p>触发器会在构建过程中插入新指令，我们可以认为这些指令是紧跟在FROM之后指定的。触发器可以是任何构建指令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN <span class="built_in">cd</span> /app/src/ &amp;&amp; make</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码将会在创建的镜像中加入ONBUILD触发器，ONBUILD指令可以在镜像上运行docker inspect命令查看。</p></blockquote><p><strong>Docker Networking</strong></p><blockquote><p>容器之间的连接用网络创建，这被称为Docker Networking。Docker Networking允许用户创建自己的网络，容器可以通过这个网上互相通信。更重要的是，现在容器可以跨越不同的宿主机来通信，并且网络配置可以更灵活的定制。Docker Networking也和Docker Compose以及Swarm进行了集成。</p><p>要想使用Docker网络，需要先创建一个网络，然后在这个网络下启动容器。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network create app</span><br></pre></td></tr></table></figure><blockquote><p>这里使用docker network命令创建了一个桥接网络，命名为app。可以使用docker network inspect命令查看新创建的这个网络。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect app</span><br></pre></td></tr></table></figure><blockquote><p>我们可以看到这个新网络是一个本地的桥接网络（这非常像docker0网络），而且现在没有容器再这个网络中运行。</p><p>可以使用<code>docker network ls</code>命令列出当前系统中所有的网络。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network ls</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用 <code>docker network rm</code>命令删除一个Docker网络。</p><p>在Docker网络中创建Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --net=app --name db micheal/redis</span><br></pre></td></tr></table></figure><blockquote><p><code>--net</code>标志指定了新容器将会在那个网络中运行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect app</span><br></pre></td></tr></table></figure><blockquote><p>将已有容器连接到Docker网络</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network connect app db2</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>docker network disconnect</code> 命令断开一个容器与指定网络的连接</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network disconnect app db2</span><br></pre></td></tr></table></figure><p><strong>通过Docker链接连接容器</strong></p><blockquote><p>启动一个Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name redis micheal/redis</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里没有公开容器的任何端口。一会就能看到这么做的原因。</p></blockquote><blockquote><p>链接Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -p 4567 --name webapp --link redis:db -t -i -v <span class="variable">$PWD</span>/webapp_redis:/opt/webapp micheal/sinatra /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>这个命令做了不少事情，我们逐一解释。首先，我们使用<code>-p</code>标志公开4567端口，这样就能从外面访问web应用程序。</p><p>我们还使用<code>--name</code>标志给容器命名为webapp，并且使用了<code>-v</code>标志把web应用程序目录作为卷挂载到了容器里。</p><p>然而，这次我们使用了一个新标志<code>--link</code>。<code>--link</code>标志创建了两个容器间的客户-服务链接。这个标志需要两个参数：一个是要链接的容器的名字，另一个是链接的别名。这个例子中我们创建了客户联系，webapp容器是客户，redis容器是“服务”，并且为这个服务增加了db作为别名。这个别名让我们可以一致地访问容器公开信息，而无须关注底层容器的名字。链接让服务容器有能力与客户容器通信，并且能分享一些连接细节，这些细节有助于在应用程序中配置并使用这个链接。</p></blockquote><blockquote><p>连接也能得到一些安全上的好处。注意，启动 Redis 容器时，并没有使用<code>-p</code>标志公开Redis的端口。因为不需要这么做。通过把容器链接在一起，可以让客户直接访问任意服务容器的公开端口（即客户webapp容器可以连接到服务redis容器的6379端口）。更妙的是，只有使用<code>--link</code>标志链接到这个容器的容器才能连接到这个端口。容器的端口不需要对本地宿主机公开，现在我们已经拥有一个非常安全的模型。通过这个安全模型，就可以限制容器化应用程序被攻击面，减少应用暴露的网络。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker基本命令&quot;&gt;&lt;a href=&quot;#Docker基本命令&quot; class=&quot;headerlink&quot; title=&quot;Docker基本命令&quot;&gt;&lt;/a&gt;Docker基本命令&lt;/h1&gt;&lt;h3 id=&quot;常用Docker命令&quot;&gt;&lt;a href=&quot;#常用Docker命令&quot; class=&quot;headerlink&quot; title=&quot;常用Docker命令&quot;&gt;&lt;/a&gt;常用Docker命令&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://miaopei.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://miaopei.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>leveldb原理剖析</title>
    <link href="http://miaopei.github.io/2016/07/15/Program-C/2014-11-18-leveldb/"/>
    <id>http://miaopei.github.io/2016/07/15/Program-C/2014-11-18-leveldb/</id>
    <published>2016-07-15T02:14:50.000Z</published>
    <updated>2019-06-14T08:23:23.219Z</updated>
    
    <content type="html"><![CDATA[<p>在说LevelDb之前，先认识两位大牛，Jeff Dean和Sanjay Ghemawat，这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。</p><p>Jeff Dean其人：<span class="exturl" data-url="aHR0cDovL3Jlc2VhcmNoLmdvb2dsZS5jb20vcGVvcGxlL2plZmYvaW5kZXguaHRtbA==" title="http://research.google.com/people/jeff/index.html">http://research.google.com/people/jeff/index.html<i class="fa fa-external-link"></i></span>，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。</p><a id="more"></a><p>Sanjay Ghemawat其人：<span class="exturl" data-url="aHR0cDovL3Jlc2VhcmNoLmdvb2dsZS5jb20vcGVvcGxlL3NhbmpheS9pbmRleC5odG1s" title="http://research.google.com/people/sanjay/index.html">http://research.google.com/people/sanjay/index.html<i class="fa fa-external-link"></i></span>，Google大规模分布式平台GFS，Bigtable和MapReduce主要设计和实现工程师。</p><p>LevelDb就是这两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C++ 程序库。正像上面介绍的，这二位是Bigtable的设计和实现者，如果了解Bigtable的话，应该知道在这个影响深远的分布式存储系统中有两个核心的部分：Master Server和Tablet Server。其中Master Server做一些管理数据的存储以及分布式调度工作，实际的分布式数据存储以及读写操作是由Tablet Server完成的，而LevelDb则可以理解为一个简化版的Tablet Server。</p><hr><h2 id="LevelDb-剖析之一：介绍"><a href="#LevelDb-剖析之一：介绍" class="headerlink" title="LevelDb 剖析之一：介绍"></a>LevelDb 剖析之一：介绍</h2><p>LevelDb有如下一些特点：</p><p>首先，LevelDb是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。</p><p>其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。</p><p>再次，像大多数KV系统一样，LevelDb的操作接口很简单，基本操作包括写记录，读记录以及删除记录。也支持针对多条操作的原子批量操作。</p><p>另外，LevelDb支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。</p><p>除此外，LevelDb还支持数据压缩等操作，这对于减小存储空间以及增快IO效率都有直接的帮助。</p><p>LevelDb性能非常突出，官方网站报道其随机写性能达到40万条记录每秒，而随机读性能达到6万条记录每秒。总体来说，LevelDb的写操作要大大快于读操作，而顺序读写操作则大大快于随机读写操作。</p><hr><h2 id="LevelDb剖析之二：整体架构"><a href="#LevelDb剖析之二：整体架构" class="headerlink" title="LevelDb剖析之二：整体架构"></a>LevelDb剖析之二：整体架构</h2><p>LevelDb本质上是一套存储系统以及在这套存储系统上提供的一些操作接口。为了便于理解整个系统及其处理流程，我们可以从两个不同的角度来看待LevleDb：静态角度和动态角度。从静态角度，可以假想整个系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等；从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。</p><p>本节所讲的整体架构主要从静态角度来描述，之后接下来的几节内容会详述静态结构涉及到的文件或者内存数据结构，LevelDb剖析后半部分主要介绍动态视角下的LevelDb，就是说整个系统是怎么运转起来的。</p><p>LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么您会看到如下一番景象：</p><p><img src="/images/imageLeveldb/level1.png" alt="LevelDb结构"></p><p>从图中可以看出，构成LevelDb静态结构的包括六个主要部分：内存中的MemTable和Immutable MemTable以及磁盘上的几种主要文件：Current文件，Manifest文件，log文件以及SSTable文件。当然，LevelDb除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是LevelDb的主体构成元素。</p><p>LevelDb的Log文件和Memtable与Bigtable论文中介绍的是一致的，当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p><p>Log文件在系统中的作用主要是用于系统崩溃恢复而不丢失数据，假如没有Log文件，因为写入的记录刚开始是保存在内存中的，此时如果系统崩溃，内存中的数据还没有来得及Dump到磁盘，所以会丢失数据（Redis就存在这个问题）。为了避免这种情况，LevelDb在写入内存前先将操作记录到Log文件中，然后再记入内存中，这样即使系统崩溃，也可以从Log文件中恢复内存中的Memtable，不会造成数据的丢失。</p><p>当Memtable插入的数据占用内存到了一个界限后，需要将内存的记录导出到外存文件中，LevleDb会生成新的Log文件和Memtable，原先的Memtable就成为Immutable Memtable，顾名思义，就是说这个Memtable的内容是不可更改的，只能读不能写入或者删除。新到来的数据被记入新的Log文件和Memtable，LevelDb后台调度会将Immutable Memtable的数据导出到磁盘，形成一个新的SSTable文件。SSTable就是由内存中的数据不断导出并进行Compaction操作后形成的，而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。</p><p>SSTable中的文件是Key有序的，就是说在文件中小key记录排在大Key记录之前，各个Level的SSTable都是如此，但是这里需要注意的一点是：Level 0的SSTable文件（后缀为.sst）和其它Level的文件相比有特殊性：这个层级内的.sst文件，两个文件可能存在key重叠，比如有两个level 0的sst文件，文件A和文件B，文件A的key范围是：{bar, car}，文件B的Key范围是{blue,samecity}，那么很可能两个文件都存在key=”blood”的记录。对于其它Level的SSTable文件来说，则不会出现同一层级内.sst文件的key重叠现象，就是说Level L中任意两个.sst文件，那么可以保证它们的key值是不会重叠的。这点需要特别注意，后面您会看到很多操作的差异都是由于这个原因造成的。</p><p>SSTable中的某个文件属于特定层级，而且其存储的记录是key有序的，那么必然有文件中的最小key和最大key，这是非常重要的信息，LevelDb应该记下这些信息。Manifest就是干这个的，它记载了SSTable各个文件的管理信息，比如属于哪个Level，文件名称叫啥，最小key和最大key各自是多少。下图是Manifest所存储内容的示意：</p><p><img src="/images/imageLeveldb/level2.png" alt="Manifest存储示意图"></p><p>图中只显示了两个文件（manifest会记载所有SSTable文件的这些信息），即Level 0的test.sst1和test.sst2文件，同时记载了这些文件各自对应的key范围，比如test.sstt1</p><p>的key范围是“an”到 “banana”，而文件test.sst2的key范围是“baby”到“samecity”，可以看出两者的key范围是有重叠的。</p><p>Current文件是干什么的呢？这个文件的内容只有一个信息，就是记载当前的manifest文件名。因为在LevleDb的运行过程中，随着Compaction的进行，SSTable文件会发生变化，会有新的文件产生，老的文件被废弃，Manifest也会跟着反映这种变化，此时往往会新生成Manifest文件来记载这种变化，而Current则用来指出哪个Manifest文件才是我们关心的那个Manifest文件。</p><p>以上介绍的内容就构成了LevelDb的整体静态结构，在LevelDb剖析接下来的内容中，我们会首先介绍重要文件或者内存数据的具体数据布局与结构。</p><hr><h2 id="LevelDb剖析之三：log文件"><a href="#LevelDb剖析之三：log文件" class="headerlink" title="LevelDb剖析之三：log文件"></a>LevelDb剖析之三：log文件</h2><p>上节内容讲到log文件在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。</p><p>下面我们带大家看看log文件的具体物理和逻辑布局是怎样的，LevelDb对于一个log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位，下图展示的log文件由3个Block构成，所以从物理布局来讲，一个log文件就是由连续的32K大小Block构成的。</p><p><img src="/images/imageLeveldb/level3.png" alt="log文件布局"></p><p>在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在LevelDb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理</p><p>记录头包含三个字段，ChechSum是对“类型”和“数据”字段的校验码，为了避免处理不完整或者是被破坏的数据，当LevelDb读取记录数据时候会对数据进行校验，如果发现和存储的CheckSum相同，说明数据完整无破坏，可以继续后续流程。“记录长度”记载了数据的大小，“数据”则是上面讲的Key:Value数值对，“类型”字段则指出了每条记录的逻辑结构和log文件物理分块结构之间的关系，具体而言，主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。</p><p> 如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。</p><p>假设目前存在三条记录，Record A，Record B和Record C，其中Record A大小为10K，Record B 大小为80K，Record C大小为12K，那么其在log文件中的逻辑布局会如图3.1所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。</p><p>从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDb一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p><hr><h2 id="LevelDb剖析之四：SSTable文件"><a href="#LevelDb剖析之四：SSTable文件" class="headerlink" title="LevelDb剖析之四：SSTable文件"></a>LevelDb剖析之四：SSTable文件</h2><p>SSTable是Bigtable中至关重要的一块，对于LevelDb来说也是如此，对LevelDb的SSTable实现细节的了解也有助于了解Bigtable中一些实现细节。</p><p>本节内容主要讲述SSTable的静态布局结构，我们曾在“LevelDb剖析之二：整体架构”中说过，SSTable文件形成了不同Level的层级结构，至于这个层级结构是如何形成的我们放在后面Compaction一节细说。本节主要介绍SSTable某个文件的物理布局和逻辑布局结构，这对了解LevelDb的运行过程很有帮助。</p><p>LevelDb不同层级有很多SSTable文件（以后缀.sst为特征），所有.sst文件内部布局都是一样的。上节介绍Log文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：Log文件中的记录是Key无序的，即先后记录的key大小没有明确大小关系，而.sst文件内部则是根据记录的Key由小到大排列的，从下面介绍的SSTable布局可以体会到Key有序是为何如此设计.sst文件结构的关键。</p><p><img src="/images/imageLeveldb/level4.png" alt="4.1 sst文件的分块结构"></p><p>上图展示了一个 <code>.sst</code> 文件的物理划分结构，同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。</p><p>以上是 <code>.sst</code> 的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。图4.2展示了 <code>.sst</code> 文件的内部逻辑解释。</p><p><img src="/images/imageLeveldb/level5.png" alt="4.2 逻辑布局"></p><p>从上图可以看出，从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。</p><p>LevelDb 1.2版对于Meta Block尚无实际使用，只是保留了一个接口，估计会在后续版本中加入内容，下面我们看看数据索引区和文件尾部Footer的内部结构。</p><p><img src="/images/imageLeveldb/level6.png" alt="4.3 数据索引"></p><p>图4.3是数据索引的内部结构示意图。再次强调一下，Data Block内的KV记录是按照Key由小到大排列的，数据索引区的每条记录是对某个Data Block建立的索引信息，每条索引信息包含三个内容，以图4.3所示的数据块i的索引Index i来说：红色部分的第一个字段记载大于等于数据块i中最大的Key值的那个Key，第二个字段指出数据块i在.sst文件中的起始位置，第三个字段指出Data Block i的大小（有时候是有数据压缩的）。后面两个字段好理解，是用于定位数据块在文件中的位置的，第一个字段需要详细解释一下，在索引里保存的这个Key值未必一定是某条记录的Key,以图4.3的例子来说，假设数据块i 的最小Key=“samecity”，最大Key=“the best”;数据块i+1的最小Key=“the fox”,最大Key=“zoo”,那么对于数据块i的索引Index i来说，其第一个字段记载大于等于数据块i的最大Key(“the best”)同时要小于数据块i+1的最小Key(“the fox”)，所以例子中Index i的第一个字段是：“the c”，这个是满足要求的；而Index i+1的第一个字段则是“zoo”，即数据块i+1的最大Key。</p><p>文件末尾Footer块的内部结构见图4.4，metaindex_handle指出了metaindex block的起始位置和大小；inex_handle指出了index Block的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的，后面跟着一个填充区和魔数。</p><p>上面主要介绍的是数据管理区的内部结构，下面我们看看数据区的一个Block的数据部分内部是如何布局的（图4.1中的红色部分），图4.5是其内部布局示意图。</p><p><img src="/images/imageLeveldb/level7.png" alt="4.5 数据Block内部结构"></p><p>从图中可以看出，其内部也分为两个部分，前面是一个个KV记录，其顺序是根据Key值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point）,其实是一些指针，指出Block内容中的一些记录位置。</p><p>“重启点”是干什么的呢？我们一再强调，Block内容里的KV记录是按照Key大小有序的，这样的话，相邻的两条记录很可能Key部分存在重叠，比如key i=“the Car”，Key i+1=“the color”,那么两者存在重叠部分“the c”，为了减少Key的存储量，Key i+1可以只存储和上一条Key不同的部分“olor”，两者的共同部分从Key i中可以获得。记录的Key在Block内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的Key部分，而是重新记录所有的Key值，假设Key i+1是一个重启点，那么Key里面会完整存储“the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。</p><p><img src="/images/imageLeveldb/level8.png" alt="4.6 记录格式"></p><p>在Block内容区，每个KV记录的内部结构是怎样的？图4.6给出了其详细结构，每个记录包含5个字段：key共享长度，比如上面的“olor”记录， 其key和上一条记录共享的Key部分长度是“the c”的长度，即5；key非共享长度，对于“olor”来说，是4；value长度指出Key:Value中Value的长度，在后面的Value内容字段中存储实际的Value值；而key非共享内容则实际存储“olor”这个Key字符串。</p><p>上面讲的这些就是.sst文件的全部内部奥秘。</p><hr><h2 id="LevelDb剖析之五：MemTable详解"><a href="#LevelDb剖析之五：MemTable详解" class="headerlink" title="LevelDb剖析之五：MemTable详解"></a>LevelDb剖析之五：MemTable详解</h2><p>LevelDb剖析前述小节大致讲述了磁盘文件相关的重要静态结构，本小节讲述内存中的数据结构Memtable，Memtable在整个体系中的重要地位也不言而喻。总体而言，所有KV数据都是存储在Memtable，Immutable Memtable和SSTable中的，Immutable Memtable从结构上讲和Memtable是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而Memtable则是允许写入和读取的。当Memtable写入的数据占用内存到达指定数量，则自动转换为Immutable Memtable，等待Dump到磁盘中，系统会自动生成新的Memtable供写操作写入新数据，理解了Memtable，那么Immutable Memtable自然不在话下。</p><p>LevelDb的MemTable提供了将KV数据写入，删除以及读取KV记录的操作接口，但是事实上Memtable并不存在真正的删除操作,删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，真正的删除操作是Lazy的，会在以后的Compaction过程中去掉这个KV。</p><p>需要注意的是，LevelDb的Memtable中KV对是根据Key大小有序存储的，在系统插入新的KV时，LevelDb要把这个KV插到合适的位置上以保持这种Key有序性。其实，LevelDb的Memtable类只是一个接口类，真正的操作是通过背后的SkipList来做的，包括插入操作和读取操作等，所以Memtable的核心数据结构是一个SkipList。</p><p>SkipList是由William Pugh发明。他在Communications of the ACM June 1990, 33(6) 668-676 发表了Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。</p><p>SkipList是平衡树的一种替代数据结构，但是和红黑树不相同的是，SkipList对于树的平衡的实现是基于一种随机化的算法的，这样也就是说SkipList的插入和删除的工作是比较简单的。</p><p>关于SkipList的详细介绍可以参考这篇文章，<span class="exturl" data-url="aHR0cDovL2xpcHBpb3V5YW5nb25saW5lLmluZm8vc2tpcC1saXN0Lw==" title="http://lippiouyangonline.info/skip-list/">skip-list原理解析<i class="fa fa-external-link"></i></span>讲述的很清楚，LevelDb的SkipList基本上是一个具体实现，并无特殊之处。</p><p>SkipList不仅是维护有序数据的一个简单实现，而且相比较平衡树来说，在插入数据的时候可以避免频繁的树节点调整操作，所以写入效率是很高的，LevelDb整体而言是个高写入系统，SkipList在其中应该也起到了很重要的作用。Redis为了加快插入操作，也使用了SkipList来作为内部实现数据结构。</p><hr><h2 id="LevelDb剖析之六-写入与删除记录"><a href="#LevelDb剖析之六-写入与删除记录" class="headerlink" title="LevelDb剖析之六 写入与删除记录"></a>LevelDb剖析之六 写入与删除记录</h2><p>在之前的五节LevelDb剖析中，我们介绍了LevelDb的一些静态文件及其详细布局，从本节开始，我们看看LevelDb的一些动态操作，比如读写记录，Compaction，错误恢复等操作。</p><p>本节介绍levelDb的记录更新操作，即插入一条KV记录或者删除一条KV记录。levelDb的更新操作速度是非常快的，源于其内部机制决定了这种更新操作的简单性。</p><p><img src="/images/imageLeveldb/level9.png" alt="6.1 LevelDb写入记录"></p><p>图6.1是levelDb如何更新KV数据的示意图，从图中可以看出，对于一个插入操作Put(Key,Value)来说，完成插入操作包含两个具体步骤：首先是将这条KV记录以顺序写的方式追加到之前介绍过的log文件末尾，因为尽管这是一个磁盘读写操作，但是文件的顺序追加写入效率是很高的，所以并不会导致写入速度的降低；第二个步骤是:如果写入log文件成功，那么将这条KV记录插入内存中的Memtable中，前面介绍过，Memtable只是一层封装，其内部其实是一个Key有序的SkipList列表，插入一条新记录的过程也很简单，即先查找合适的插入位置，然后修改相应的链接指针将新记录插入即可。完成这一步，写入记录就算完成了，所以一个插入记录操作涉及一次磁盘文件追加写和内存SkipList插入操作，这是为何levelDb写入速度如此高效的根本原因。</p><p>从上面的介绍过程中也可以看出：log文件内是key无序的，而Memtable中是key有序的。那么如果是删除一条KV记录呢？对于levelDb来说，并不存在立即删除的操作，而是与插入操作相同的，区别是，插入操作插入的是Key:Value 值，而删除操作插入的是“Key:删除标记”，并不真正去删除记录，而是后台Compaction的时候才去做真正的删除操作。</p><p>levelDb的写入操作就是如此简单。真正的麻烦在后面将要介绍的读取操作中。</p><hr><h2 id="LevelDb剖析之七：读取记录"><a href="#LevelDb剖析之七：读取记录" class="headerlink" title="LevelDb剖析之七：读取记录"></a>LevelDb剖析之七：读取记录</h2><p>LevelDb是针对大规模Key/Value数据的单机存储库，从应用的角度来看，LevelDb就是一个存储工具。而作为称职的存储工具，常见的调用接口无非是新增KV，删除KV，读取KV，更新Key对应的Value值这么几种操作。LevelDb的接口没有直接支持更新操作的接口，如果需要更新某个Key的Value,你可以选择直接生猛地插入新的KV，保持Key相同，这样系统内的key对应的value就会被更新；或者你可以先删除旧的KV， 之后再插入新的KV，这样比较委婉地完成KV的更新操作。</p><p>假设应用提交一个Key值，下面我们看看LevelDb是如何从存储的数据中读出其对应的Value值的。图7-1是LevelDb读取过程的整体示意图。</p><p><img src="/images/imageLeveldb/level10.png" alt="7-1 LevelDb读取记录流程"></p><p>LevelDb首先会去查看内存中的Memtable，如果Memtable中包含key及其对应的value，则返回value值即可；如果在Memtable没有读到key，则接下来到同样处于内存中的Immutable Memtable中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。因为SSTable数量较多，而且分成多个Level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于level 0的文件中查找，如果找到则返回对应的value值，如果没有找到那么到level 1中的文件中去找，如此循环往复，直到在某层SSTable文件中找到这个key对应的value为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p><p>那么为什么是从Memtable到Immutable Memtable，再从Immutable Memtable到文件，而文件中为何是从低level到高level这么一个查询路径呢？道理何在？之所以选择这么个查询路径，是因为从信息的更新时间来说，很明显Memtable存储的是最新鲜的KV对；Immutable Memtable中存储的KV数据对的新鲜程度次之；而所有SSTable文件中的KV数据新鲜程度一定不如内存中的Memtable和Immutable Memtable的。对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。也就是说，上面列出的查找路径就是按照数据新鲜程度排列出来的，越新鲜的越先查找。</p><p>为啥要优先查找新鲜的数据呢？这个道理不言而喻，举个例子。比如我们先往levelDb里面插入一条数据 {key=”<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20mcXVvdDs=" title="http://www.samecity.com&quot;">www.samecity.com&quot;<i class="fa fa-external-link"></i></span>  value=”我们”},过了几天，samecity网站改名为：69同城，此时我们插入数据{key=”<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20mcXVvdDs=" title="http://www.samecity.com&quot;">www.samecity.com&quot;<i class="fa fa-external-link"></i></span>  value=”69同城”}，同样的key,不同的value；逻辑上理解好像levelDb中只有一个存储记录，即第二个记录，但是在levelDb中很可能存在两条记录，即上面的两个记录都在levelDb中存储了，此时如果用户查询key=”<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20mcXVvdDss5oiR5Lus5b2T54S25biM5pyb5om+5Yiw5pyA5paw55qE5pu05paw6K6w5b2V77yM5Lmf5bCx5piv56ys5LqM5Liq6K6w5b2V6L+U5Zue77yM6L+Z5bCx5piv5Li65L2V6KaB5LyY5YWI5p+l5om+5paw6bKc5pWw5o2u55qE5Y6f5Zug44CC" title="http://www.samecity.com&quot;,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。">www.samecity.com&quot;,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。<i class="fa fa-external-link"></i></span></p><p>前文有讲：对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。这是一个结论，理论上需要一个证明过程，否则会招致如下的问题：为神马呢？从道理上讲呢，很明白：因为Level L+1的数据不是从石头缝里蹦出来的，也不是做梦梦到的，那它是从哪里来的？Level L+1的数据是从Level L 经过Compaction后得到的（如果您不知道什么是Compaction，那么……..也许以后会知道的），也就是说，您看到的现在的Level L+1层的SSTable数据是从原来的Level L中来的，现在的Level L比原来的Level L数据要新鲜，所以可证，现在的Level L比现在的Level L+1的数据要新鲜。</p><p>SSTable文件很多，如何快速地找到key对应的value值？在LevelDb中，level 0一直都爱搞特殊化，在level 0和其它level中查找某个key的过程是不一样的。因为level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含，这样的话LevelDb的策略是先找出level 0中哪些文件包含这个key（manifest文件中记载了level和对应的文件及文件里key的范围信息，LevelDb在内存中保留这种映射表）， 之后按照文件的新鲜程度排序，新的文件排在前面，之后依次查找，读出key对应的value。而如果是非level 0的话，因为这个level的文件之间key是不重叠的，所以只从一个文件就可以找到key对应的value。</p><p>最后一个问题,如果给定一个要查询的key和某个key range包含这个key的SSTable文件，那么levelDb是如何进行具体查找过程的呢？levelDb一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后levelDb根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的SSTable文件并不包含这个key，所以到下一级别的SSTable中去查找。</p><p>从之前介绍的LevelDb的写操作和这里介绍的读操作可以看出，相对写操作，读操作处理起来要复杂很多，所以写的速度必然要远远高于读数据的速度，也就是说，LevelDb比较适合写操作多于读操作的应用场合。而如果应用是很多读操作类型的，那么顺序读取效率会比较高，因为这样大部分内容都会在缓存中找到，尽可能避免大量的随机读取操作。</p><hr><h2 id="LevelDb剖析之八：Compaction操作"><a href="#LevelDb剖析之八：Compaction操作" class="headerlink" title="LevelDb剖析之八：Compaction操作"></a>LevelDb剖析之八：Compaction操作</h2><p>前文有述，对于LevelDb来说，写入记录操作很简单，删除记录仅仅写入一个删除标记就算完事，但是读取记录比较复杂，需要在内存以及各个层级文件中依照新鲜程度依次查找，代价很高。为了加快读取速度，levelDb采取了compaction的方式来对已有的记录进行整理压缩，通过这种方式，来删除掉一些不再有效的KV数据，减小数据规模，减少文件数量等。</p><p>levelDb的compaction机制和过程与Bigtable所讲述的是基本一致的，Bigtable中讲到三种类型的compaction: minor ，major和full。所谓minor Compaction，就是把memtable中的数据导出到SSTable文件中；major compaction就是合并不同层级的SSTable文件，而full compaction就是将所有SSTable进行合并。</p><p>LevelDb包含其中两种，minor和major。</p><p>我将为大家详细叙述其机理。</p><p>先来看看minor Compaction的过程。Minor compaction 的目的是当内存中的memtable大小到了一定值时，将内容保存到磁盘文件中，图8.1是其机理示意图。 </p><p><img src="/images/imageLeveldb/level11.png" alt="8.1 minor compaction"></p><p>从8.1可以看出，当memtable数量到了一定程度会转换为immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable其实是一个多层级队列SkipList，其中的记录是根据key有序排列的。所以这个minor compaction实现起来也很简单，就是按照immutable memtable中记录由小到大遍历，并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 数据，这样就完成了一次minor compaction。从图中也可以看出，对于被删除的记录，在minor compaction过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉key记录，但是这个KV数据在哪里?那需要复杂的查找，所以在minor compaction的时候并不做删除，只是将这个key作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的compaction中会去做。</p><p>当某个level下的SSTable文件数目超过一定设置值后，levelDb会从这个level的SSTable中选择一个文件（level&gt;0），将其和高一层级的level+1的SSTable文件合并，这就是major compaction。</p><p>我们知道在大于0的层级中，每个SSTable文件内的Key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。Level 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。</p><p>levelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，levelDb在这里有个小技巧， 就是说轮流来，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。</p><p>如果选好了level L的文件A和level L+1层的文件进行合并，那么问题又来了，应该选择level L+1哪些文件进行合并？levelDb选择L+1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。</p><p>也就是说，选定了level L的文件A,之后在level L+1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。</p><p>图8.2说明了这一过程。</p><p><img src="/images/imageLeveldb/level12.png" alt="8.2 SSTable Compaction"></p><p>Major compaction的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的Key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个Key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入level L+1层中新生成的一个SSTable文件中。就这样对KV数据一一处理，形成了一系列新的L+1层数据文件，之前的L层文件和L+1层参与compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了L层和L+1层文件记录的合并过程。</p><p>那么在major compaction过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于L层中存在这个Key，那么这个KV在major compaction过程中可以抛掉。因为我们前面分析过，对于层级低于L的文件中如果存在同一Key的记录，那么说明对于Key来说，有更新鲜的Value存在，那么过去的Value就等于没有意义了，所以可以删除。</p><hr><h2 id="LevelDb剖析之九-levelDb中的Cache"><a href="#LevelDb剖析之九-levelDb中的Cache" class="headerlink" title="LevelDb剖析之九 levelDb中的Cache"></a>LevelDb剖析之九 levelDb中的Cache</h2><p>书接前文，前面讲过对于levelDb来说，读取操作如果没有在内存的memtable中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在level 0中最新的文件中找到了这个key，那么也需要读取2次磁盘，一次是将SSTable的文件中的index部分读入内存，这样根据这个index可以确定key是在哪个block中存储；第二次是读入这个block的内容，然后在内存中查找key对应的value。</p><p>levelDb中引入了两个不同的Cache:Table Cache和Block Cache。其中Block Cache是配置可选的，即在配置文件中指定是否打开这个功能。</p><p><img src="/images/imageLeveldb/level3.png" alt="9.1 table cache"></p><p>图9.1是table cache的结构。在Cache中，key值是SSTable的文件名称，Value部分包含两部分，一个是指向磁盘打开的SSTable文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个SSTable文件对应的Table结构指针，table结构在内存中，保存了SSTable的index内容以及用来指示block cache用的cache_id ,当然除此外还有其它一些内容。</p><p>比如在get(key)读取操作中，如果levelDb确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，levelDb会首先查找Table Cache，看这个文件是否在缓存里，如果找到了，那么根据index部分就可以查找是哪个block包含这个key。如果没有在缓存中找到文件，那么打开SSTable文件，将其index部分读入内存，然后插入Cache里面，去index里面定位哪个block包含这个Key 。如果确定了文件哪个block包含这个key，那么需要读入block内容，这是第二次读取。</p><p>Block Cache是为了加快这个过程的，图9.2是其结构示意图。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p><p>如果levelDb发现这个block在block cache中，那么可以避免读取数据，直接在cache里的block内容里面查找key的value就行，如果没找到呢？那么读入block内容并把它插入block cache中。levelDb就是这样通过两个cache来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p><hr><h2 id="LevelDb剖析之十-Version、VersionEdit、VersionSet"><a href="#LevelDb剖析之十-Version、VersionEdit、VersionSet" class="headerlink" title="LevelDb剖析之十 Version、VersionEdit、VersionSet"></a>LevelDb剖析之十 Version、VersionEdit、VersionSet</h2><p>Version 保存了当前磁盘以及内存中所有的文件信息，一般只有一个Version叫做”current” version（当前版本）。Leveldb还保存了一系列的历史版本，这些历史版本有什么作用呢？</p><p>当一个Iterator创建后，Iterator就引用到了current version(当前版本)，只要这个Iterator不被delete那么被Iterator引用的版本就会一直存活。这就意味着当你用完一个Iterator后，需要及时删除它。</p><p>当一次Compaction结束后（会生成新的文件，合并前的文件需要删除），Leveldb会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p><p>VersionSet 是所有Version的集合，管理着所有存活的Version。</p><p>VersionEdit 表示Version之间的变化，相当于delta 增量，表示有增加了多少文件，删除了文件。下图表示他们之间的关系。</p><p>Version0 +VersionEdit–&gt;Version1</p><p>VersionEdit会保存到MANIFEST文件中，当做数据恢复时就会从MANIFEST文件中读出来重建数据。</p><p>leveldb的这种版本的控制，让我想到了双buffer切换，双buffer切换来自于图形学中，用于解决屏幕绘制时的闪屏问题，在服务器编程中也有用处。</p><p>比如我们的服务器上有一个字典库，每天我们需要更新这个字典库，我们可以新开一个buffer，将新的字典库加载到这个新buffer中，等到加载完毕，将字典的指针指向新的字典库。</p><p>leveldb的version管理和双buffer切换类似，但是如果原version被某个iterator引用，那么这个version会一直保持，直到没有被任何一个iterator引用，此时就可以删除这个version。</p><p>注：本文参考了这篇文章：<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20vYmxvZy9JbmRleC5hc3A/U29ydElEPTEy" title="http://www.samecity.com/blog/Index.asp?SortID=12">http://www.samecity.com/blog/Index.asp?SortID=12<i class="fa fa-external-link"></i></span><br>参考资料：1.<span class="exturl" data-url="aHR0cDovL3poLndpa2lwZWRpYS5vcmcvd2lraS9MZXZlbERC" title="http://zh.wikipedia.org/wiki/LevelDB">维基百科<i class="fa fa-external-link"></i></span><br>　　　　　2.<span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2xldmVsZGIv" title="http://code.google.com/p/leveldb/">google code<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在说LevelDb之前，先认识两位大牛，Jeff Dean和Sanjay Ghemawat，这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。&lt;/p&gt;
&lt;p&gt;Jeff Dean其人：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3Jlc2VhcmNoLmdvb2dsZS5jb20vcGVvcGxlL2plZmYvaW5kZXguaHRtbA==&quot; title=&quot;http://research.google.com/people/jeff/index.html&quot;&gt;http://research.google.com/people/jeff/index.html&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。&lt;/p&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>leveldb原理剖析</title>
    <link href="http://miaopei.github.io/2016/07/15/Program-C/leveldb/"/>
    <id>http://miaopei.github.io/2016/07/15/Program-C/leveldb/</id>
    <published>2016-07-15T02:14:50.000Z</published>
    <updated>2019-06-14T08:02:10.592Z</updated>
    
    <content type="html"><![CDATA[<p>在说LevelDb之前，先认识两位大牛，Jeff Dean和Sanjay Ghemawat，这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。</p><p>Jeff Dean其人：<span class="exturl" data-url="aHR0cDovL3Jlc2VhcmNoLmdvb2dsZS5jb20vcGVvcGxlL2plZmYvaW5kZXguaHRtbA==" title="http://research.google.com/people/jeff/index.html">http://research.google.com/people/jeff/index.html<i class="fa fa-external-link"></i></span>，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。</p><a id="more"></a><p>Sanjay Ghemawat其人：<span class="exturl" data-url="aHR0cDovL3Jlc2VhcmNoLmdvb2dsZS5jb20vcGVvcGxlL3NhbmpheS9pbmRleC5odG1s" title="http://research.google.com/people/sanjay/index.html">http://research.google.com/people/sanjay/index.html<i class="fa fa-external-link"></i></span>，Google大规模分布式平台GFS，Bigtable和MapReduce主要设计和实现工程师。</p><p>LevelDb就是这两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C++ 程序库。正像上面介绍的，这二位是Bigtable的设计和实现者，如果了解Bigtable的话，应该知道在这个影响深远的分布式存储系统中有两个核心的部分：Master Server和Tablet Server。其中Master Server做一些管理数据的存储以及分布式调度工作，实际的分布式数据存储以及读写操作是由Tablet Server完成的，而LevelDb则可以理解为一个简化版的Tablet Server。</p><hr><h2 id="LevelDb-剖析之一：介绍"><a href="#LevelDb-剖析之一：介绍" class="headerlink" title="LevelDb 剖析之一：介绍"></a>LevelDb 剖析之一：介绍</h2><p>LevelDb有如下一些特点：</p><p>首先，LevelDb是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。</p><p>其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。</p><p>再次，像大多数KV系统一样，LevelDb的操作接口很简单，基本操作包括写记录，读记录以及删除记录。也支持针对多条操作的原子批量操作。</p><p>另外，LevelDb支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。</p><p>除此外，LevelDb还支持数据压缩等操作，这对于减小存储空间以及增快IO效率都有直接的帮助。</p><p>LevelDb性能非常突出，官方网站报道其随机写性能达到40万条记录每秒，而随机读性能达到6万条记录每秒。总体来说，LevelDb的写操作要大大快于读操作，而顺序读写操作则大大快于随机读写操作。</p><hr><h2 id="LevelDb剖析之二：整体架构"><a href="#LevelDb剖析之二：整体架构" class="headerlink" title="LevelDb剖析之二：整体架构"></a>LevelDb剖析之二：整体架构</h2><p>LevelDb本质上是一套存储系统以及在这套存储系统上提供的一些操作接口。为了便于理解整个系统及其处理流程，我们可以从两个不同的角度来看待LevleDb：静态角度和动态角度。从静态角度，可以假想整个系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等；从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。</p><p>本节所讲的整体架构主要从静态角度来描述，之后接下来的几节内容会详述静态结构涉及到的文件或者内存数据结构，LevelDb剖析后半部分主要介绍动态视角下的LevelDb，就是说整个系统是怎么运转起来的。</p><p>LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么您会看到如下一番景象：</p><p><img src="/images/imageLeveldb/level1.png" alt="LevelDb结构"></p><p>从图中可以看出，构成LevelDb静态结构的包括六个主要部分：内存中的MemTable和Immutable MemTable以及磁盘上的几种主要文件：Current文件，Manifest文件，log文件以及SSTable文件。当然，LevelDb除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是LevelDb的主体构成元素。</p><p>LevelDb的Log文件和Memtable与Bigtable论文中介绍的是一致的，当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p><p>Log文件在系统中的作用主要是用于系统崩溃恢复而不丢失数据，假如没有Log文件，因为写入的记录刚开始是保存在内存中的，此时如果系统崩溃，内存中的数据还没有来得及Dump到磁盘，所以会丢失数据（Redis就存在这个问题）。为了避免这种情况，LevelDb在写入内存前先将操作记录到Log文件中，然后再记入内存中，这样即使系统崩溃，也可以从Log文件中恢复内存中的Memtable，不会造成数据的丢失。</p><p>当Memtable插入的数据占用内存到了一个界限后，需要将内存的记录导出到外存文件中，LevleDb会生成新的Log文件和Memtable，原先的Memtable就成为Immutable Memtable，顾名思义，就是说这个Memtable的内容是不可更改的，只能读不能写入或者删除。新到来的数据被记入新的Log文件和Memtable，LevelDb后台调度会将Immutable Memtable的数据导出到磁盘，形成一个新的SSTable文件。SSTable就是由内存中的数据不断导出并进行Compaction操作后形成的，而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。</p><p>SSTable中的文件是Key有序的，就是说在文件中小key记录排在大Key记录之前，各个Level的SSTable都是如此，但是这里需要注意的一点是：Level 0的SSTable文件（后缀为.sst）和其它Level的文件相比有特殊性：这个层级内的.sst文件，两个文件可能存在key重叠，比如有两个level 0的sst文件，文件A和文件B，文件A的key范围是：{bar, car}，文件B的Key范围是{blue,samecity}，那么很可能两个文件都存在key=”blood”的记录。对于其它Level的SSTable文件来说，则不会出现同一层级内.sst文件的key重叠现象，就是说Level L中任意两个.sst文件，那么可以保证它们的key值是不会重叠的。这点需要特别注意，后面您会看到很多操作的差异都是由于这个原因造成的。</p><p>SSTable中的某个文件属于特定层级，而且其存储的记录是key有序的，那么必然有文件中的最小key和最大key，这是非常重要的信息，LevelDb应该记下这些信息。Manifest就是干这个的，它记载了SSTable各个文件的管理信息，比如属于哪个Level，文件名称叫啥，最小key和最大key各自是多少。下图是Manifest所存储内容的示意：</p><p><img src="/images/imageLeveldb/level2.png" alt="Manifest存储示意图"></p><p>图中只显示了两个文件（manifest会记载所有SSTable文件的这些信息），即Level 0的test.sst1和test.sst2文件，同时记载了这些文件各自对应的key范围，比如test.sstt1</p><p>的key范围是“an”到 “banana”，而文件test.sst2的key范围是“baby”到“samecity”，可以看出两者的key范围是有重叠的。</p><p>Current文件是干什么的呢？这个文件的内容只有一个信息，就是记载当前的manifest文件名。因为在LevleDb的运行过程中，随着Compaction的进行，SSTable文件会发生变化，会有新的文件产生，老的文件被废弃，Manifest也会跟着反映这种变化，此时往往会新生成Manifest文件来记载这种变化，而Current则用来指出哪个Manifest文件才是我们关心的那个Manifest文件。</p><p>以上介绍的内容就构成了LevelDb的整体静态结构，在LevelDb剖析接下来的内容中，我们会首先介绍重要文件或者内存数据的具体数据布局与结构。</p><hr><h2 id="LevelDb剖析之三：log文件"><a href="#LevelDb剖析之三：log文件" class="headerlink" title="LevelDb剖析之三：log文件"></a>LevelDb剖析之三：log文件</h2><p>上节内容讲到log文件在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。</p><p>下面我们带大家看看log文件的具体物理和逻辑布局是怎样的，LevelDb对于一个log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位，下图展示的log文件由3个Block构成，所以从物理布局来讲，一个log文件就是由连续的32K大小Block构成的。</p><p><img src="/images/imageLeveldb/level3.png" alt="log文件布局"></p><p>在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在LevelDb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理</p><p>记录头包含三个字段，ChechSum是对“类型”和“数据”字段的校验码，为了避免处理不完整或者是被破坏的数据，当LevelDb读取记录数据时候会对数据进行校验，如果发现和存储的CheckSum相同，说明数据完整无破坏，可以继续后续流程。“记录长度”记载了数据的大小，“数据”则是上面讲的Key:Value数值对，“类型”字段则指出了每条记录的逻辑结构和log文件物理分块结构之间的关系，具体而言，主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。</p><p> 如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。</p><p>假设目前存在三条记录，Record A，Record B和Record C，其中Record A大小为10K，Record B 大小为80K，Record C大小为12K，那么其在log文件中的逻辑布局会如图3.1所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。</p><p>从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDb一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p><hr><h2 id="LevelDb剖析之四：SSTable文件"><a href="#LevelDb剖析之四：SSTable文件" class="headerlink" title="LevelDb剖析之四：SSTable文件"></a>LevelDb剖析之四：SSTable文件</h2><p>SSTable是Bigtable中至关重要的一块，对于LevelDb来说也是如此，对LevelDb的SSTable实现细节的了解也有助于了解Bigtable中一些实现细节。</p><p>本节内容主要讲述SSTable的静态布局结构，我们曾在“LevelDb剖析之二：整体架构”中说过，SSTable文件形成了不同Level的层级结构，至于这个层级结构是如何形成的我们放在后面Compaction一节细说。本节主要介绍SSTable某个文件的物理布局和逻辑布局结构，这对了解LevelDb的运行过程很有帮助。</p><p>LevelDb不同层级有很多SSTable文件（以后缀.sst为特征），所有.sst文件内部布局都是一样的。上节介绍Log文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：Log文件中的记录是Key无序的，即先后记录的key大小没有明确大小关系，而.sst文件内部则是根据记录的Key由小到大排列的，从下面介绍的SSTable布局可以体会到Key有序是为何如此设计.sst文件结构的关键。</p><p><img src="/images/imageLeveldb/level4.png" alt="4.1 sst文件的分块结构"></p><p>上图展示了一个 <code>.sst</code> 文件的物理划分结构，同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。</p><p>以上是 <code>.sst</code> 的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。图4.2展示了 <code>.sst</code> 文件的内部逻辑解释。</p><p><img src="/images/imageLeveldb/level5.png" alt="4.2 逻辑布局"></p><p>从上图可以看出，从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。</p><p>LevelDb 1.2版对于Meta Block尚无实际使用，只是保留了一个接口，估计会在后续版本中加入内容，下面我们看看数据索引区和文件尾部Footer的内部结构。</p><p><img src="/images/imageLeveldb/level6.png" alt="4.3 数据索引"></p><p>图4.3是数据索引的内部结构示意图。再次强调一下，Data Block内的KV记录是按照Key由小到大排列的，数据索引区的每条记录是对某个Data Block建立的索引信息，每条索引信息包含三个内容，以图4.3所示的数据块i的索引Index i来说：红色部分的第一个字段记载大于等于数据块i中最大的Key值的那个Key，第二个字段指出数据块i在.sst文件中的起始位置，第三个字段指出Data Block i的大小（有时候是有数据压缩的）。后面两个字段好理解，是用于定位数据块在文件中的位置的，第一个字段需要详细解释一下，在索引里保存的这个Key值未必一定是某条记录的Key,以图4.3的例子来说，假设数据块i 的最小Key=“samecity”，最大Key=“the best”;数据块i+1的最小Key=“the fox”,最大Key=“zoo”,那么对于数据块i的索引Index i来说，其第一个字段记载大于等于数据块i的最大Key(“the best”)同时要小于数据块i+1的最小Key(“the fox”)，所以例子中Index i的第一个字段是：“the c”，这个是满足要求的；而Index i+1的第一个字段则是“zoo”，即数据块i+1的最大Key。</p><p>文件末尾Footer块的内部结构见图4.4，metaindex_handle指出了metaindex block的起始位置和大小；inex_handle指出了index Block的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的，后面跟着一个填充区和魔数。</p><p>上面主要介绍的是数据管理区的内部结构，下面我们看看数据区的一个Block的数据部分内部是如何布局的（图4.1中的红色部分），图4.5是其内部布局示意图。</p><p><img src="/images/imageLeveldb/level7.png" alt="4.5 数据Block内部结构"></p><p>从图中可以看出，其内部也分为两个部分，前面是一个个KV记录，其顺序是根据Key值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point）,其实是一些指针，指出Block内容中的一些记录位置。</p><p>“重启点”是干什么的呢？我们一再强调，Block内容里的KV记录是按照Key大小有序的，这样的话，相邻的两条记录很可能Key部分存在重叠，比如key i=“the Car”，Key i+1=“the color”,那么两者存在重叠部分“the c”，为了减少Key的存储量，Key i+1可以只存储和上一条Key不同的部分“olor”，两者的共同部分从Key i中可以获得。记录的Key在Block内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的Key部分，而是重新记录所有的Key值，假设Key i+1是一个重启点，那么Key里面会完整存储“the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。</p><p><img src="/images/imageLeveldb/level8.png" alt="4.6 记录格式"></p><p>在Block内容区，每个KV记录的内部结构是怎样的？图4.6给出了其详细结构，每个记录包含5个字段：key共享长度，比如上面的“olor”记录， 其key和上一条记录共享的Key部分长度是“the c”的长度，即5；key非共享长度，对于“olor”来说，是4；value长度指出Key:Value中Value的长度，在后面的Value内容字段中存储实际的Value值；而key非共享内容则实际存储“olor”这个Key字符串。</p><p>上面讲的这些就是.sst文件的全部内部奥秘。</p><hr><h2 id="LevelDb剖析之五：MemTable详解"><a href="#LevelDb剖析之五：MemTable详解" class="headerlink" title="LevelDb剖析之五：MemTable详解"></a>LevelDb剖析之五：MemTable详解</h2><p>LevelDb剖析前述小节大致讲述了磁盘文件相关的重要静态结构，本小节讲述内存中的数据结构Memtable，Memtable在整个体系中的重要地位也不言而喻。总体而言，所有KV数据都是存储在Memtable，Immutable Memtable和SSTable中的，Immutable Memtable从结构上讲和Memtable是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而Memtable则是允许写入和读取的。当Memtable写入的数据占用内存到达指定数量，则自动转换为Immutable Memtable，等待Dump到磁盘中，系统会自动生成新的Memtable供写操作写入新数据，理解了Memtable，那么Immutable Memtable自然不在话下。</p><p>LevelDb的MemTable提供了将KV数据写入，删除以及读取KV记录的操作接口，但是事实上Memtable并不存在真正的删除操作,删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，真正的删除操作是Lazy的，会在以后的Compaction过程中去掉这个KV。</p><p>需要注意的是，LevelDb的Memtable中KV对是根据Key大小有序存储的，在系统插入新的KV时，LevelDb要把这个KV插到合适的位置上以保持这种Key有序性。其实，LevelDb的Memtable类只是一个接口类，真正的操作是通过背后的SkipList来做的，包括插入操作和读取操作等，所以Memtable的核心数据结构是一个SkipList。</p><p>SkipList是由William Pugh发明。他在Communications of the ACM June 1990, 33(6) 668-676 发表了Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。</p><p>SkipList是平衡树的一种替代数据结构，但是和红黑树不相同的是，SkipList对于树的平衡的实现是基于一种随机化的算法的，这样也就是说SkipList的插入和删除的工作是比较简单的。</p><p>关于SkipList的详细介绍可以参考这篇文章，<span class="exturl" data-url="aHR0cDovL2xpcHBpb3V5YW5nb25saW5lLmluZm8vc2tpcC1saXN0Lw==" title="http://lippiouyangonline.info/skip-list/">skip-list原理解析<i class="fa fa-external-link"></i></span>讲述的很清楚，LevelDb的SkipList基本上是一个具体实现，并无特殊之处。</p><p>SkipList不仅是维护有序数据的一个简单实现，而且相比较平衡树来说，在插入数据的时候可以避免频繁的树节点调整操作，所以写入效率是很高的，LevelDb整体而言是个高写入系统，SkipList在其中应该也起到了很重要的作用。Redis为了加快插入操作，也使用了SkipList来作为内部实现数据结构。</p><hr><h2 id="LevelDb剖析之六-写入与删除记录"><a href="#LevelDb剖析之六-写入与删除记录" class="headerlink" title="LevelDb剖析之六 写入与删除记录"></a>LevelDb剖析之六 写入与删除记录</h2><p>在之前的五节LevelDb剖析中，我们介绍了LevelDb的一些静态文件及其详细布局，从本节开始，我们看看LevelDb的一些动态操作，比如读写记录，Compaction，错误恢复等操作。</p><p>本节介绍levelDb的记录更新操作，即插入一条KV记录或者删除一条KV记录。levelDb的更新操作速度是非常快的，源于其内部机制决定了这种更新操作的简单性。</p><p><img src="/images/imageLeveldb/level9.png" alt="6.1 LevelDb写入记录"></p><p>图6.1是levelDb如何更新KV数据的示意图，从图中可以看出，对于一个插入操作Put(Key,Value)来说，完成插入操作包含两个具体步骤：首先是将这条KV记录以顺序写的方式追加到之前介绍过的log文件末尾，因为尽管这是一个磁盘读写操作，但是文件的顺序追加写入效率是很高的，所以并不会导致写入速度的降低；第二个步骤是:如果写入log文件成功，那么将这条KV记录插入内存中的Memtable中，前面介绍过，Memtable只是一层封装，其内部其实是一个Key有序的SkipList列表，插入一条新记录的过程也很简单，即先查找合适的插入位置，然后修改相应的链接指针将新记录插入即可。完成这一步，写入记录就算完成了，所以一个插入记录操作涉及一次磁盘文件追加写和内存SkipList插入操作，这是为何levelDb写入速度如此高效的根本原因。</p><p>从上面的介绍过程中也可以看出：log文件内是key无序的，而Memtable中是key有序的。那么如果是删除一条KV记录呢？对于levelDb来说，并不存在立即删除的操作，而是与插入操作相同的，区别是，插入操作插入的是Key:Value 值，而删除操作插入的是“Key:删除标记”，并不真正去删除记录，而是后台Compaction的时候才去做真正的删除操作。</p><p>levelDb的写入操作就是如此简单。真正的麻烦在后面将要介绍的读取操作中。</p><hr><h2 id="LevelDb剖析之七：读取记录"><a href="#LevelDb剖析之七：读取记录" class="headerlink" title="LevelDb剖析之七：读取记录"></a>LevelDb剖析之七：读取记录</h2><p>LevelDb是针对大规模Key/Value数据的单机存储库，从应用的角度来看，LevelDb就是一个存储工具。而作为称职的存储工具，常见的调用接口无非是新增KV，删除KV，读取KV，更新Key对应的Value值这么几种操作。LevelDb的接口没有直接支持更新操作的接口，如果需要更新某个Key的Value,你可以选择直接生猛地插入新的KV，保持Key相同，这样系统内的key对应的value就会被更新；或者你可以先删除旧的KV， 之后再插入新的KV，这样比较委婉地完成KV的更新操作。</p><p>假设应用提交一个Key值，下面我们看看LevelDb是如何从存储的数据中读出其对应的Value值的。图7-1是LevelDb读取过程的整体示意图。</p><p><img src="/images/imageLeveldb/level10.png" alt="7-1 LevelDb读取记录流程"></p><p>LevelDb首先会去查看内存中的Memtable，如果Memtable中包含key及其对应的value，则返回value值即可；如果在Memtable没有读到key，则接下来到同样处于内存中的Immutable Memtable中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。因为SSTable数量较多，而且分成多个Level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于level 0的文件中查找，如果找到则返回对应的value值，如果没有找到那么到level 1中的文件中去找，如此循环往复，直到在某层SSTable文件中找到这个key对应的value为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p><p>那么为什么是从Memtable到Immutable Memtable，再从Immutable Memtable到文件，而文件中为何是从低level到高level这么一个查询路径呢？道理何在？之所以选择这么个查询路径，是因为从信息的更新时间来说，很明显Memtable存储的是最新鲜的KV对；Immutable Memtable中存储的KV数据对的新鲜程度次之；而所有SSTable文件中的KV数据新鲜程度一定不如内存中的Memtable和Immutable Memtable的。对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。也就是说，上面列出的查找路径就是按照数据新鲜程度排列出来的，越新鲜的越先查找。</p><p>为啥要优先查找新鲜的数据呢？这个道理不言而喻，举个例子。比如我们先往levelDb里面插入一条数据 {key=”<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20mcXVvdDs=" title="http://www.samecity.com&quot;">www.samecity.com&quot;<i class="fa fa-external-link"></i></span>  value=”我们”},过了几天，samecity网站改名为：69同城，此时我们插入数据{key=”<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20mcXVvdDs=" title="http://www.samecity.com&quot;">www.samecity.com&quot;<i class="fa fa-external-link"></i></span>  value=”69同城”}，同样的key,不同的value；逻辑上理解好像levelDb中只有一个存储记录，即第二个记录，但是在levelDb中很可能存在两条记录，即上面的两个记录都在levelDb中存储了，此时如果用户查询key=”<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20mcXVvdDss5oiR5Lus5b2T54S25biM5pyb5om+5Yiw5pyA5paw55qE5pu05paw6K6w5b2V77yM5Lmf5bCx5piv56ys5LqM5Liq6K6w5b2V6L+U5Zue77yM6L+Z5bCx5piv5Li65L2V6KaB5LyY5YWI5p+l5om+5paw6bKc5pWw5o2u55qE5Y6f5Zug44CC" title="http://www.samecity.com&quot;,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。">www.samecity.com&quot;,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。<i class="fa fa-external-link"></i></span></p><p>前文有讲：对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。这是一个结论，理论上需要一个证明过程，否则会招致如下的问题：为神马呢？从道理上讲呢，很明白：因为Level L+1的数据不是从石头缝里蹦出来的，也不是做梦梦到的，那它是从哪里来的？Level L+1的数据是从Level L 经过Compaction后得到的（如果您不知道什么是Compaction，那么……..也许以后会知道的），也就是说，您看到的现在的Level L+1层的SSTable数据是从原来的Level L中来的，现在的Level L比原来的Level L数据要新鲜，所以可证，现在的Level L比现在的Level L+1的数据要新鲜。</p><p>SSTable文件很多，如何快速地找到key对应的value值？在LevelDb中，level 0一直都爱搞特殊化，在level 0和其它level中查找某个key的过程是不一样的。因为level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含，这样的话LevelDb的策略是先找出level 0中哪些文件包含这个key（manifest文件中记载了level和对应的文件及文件里key的范围信息，LevelDb在内存中保留这种映射表）， 之后按照文件的新鲜程度排序，新的文件排在前面，之后依次查找，读出key对应的value。而如果是非level 0的话，因为这个level的文件之间key是不重叠的，所以只从一个文件就可以找到key对应的value。</p><p>最后一个问题,如果给定一个要查询的key和某个key range包含这个key的SSTable文件，那么levelDb是如何进行具体查找过程的呢？levelDb一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后levelDb根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的SSTable文件并不包含这个key，所以到下一级别的SSTable中去查找。</p><p>从之前介绍的LevelDb的写操作和这里介绍的读操作可以看出，相对写操作，读操作处理起来要复杂很多，所以写的速度必然要远远高于读数据的速度，也就是说，LevelDb比较适合写操作多于读操作的应用场合。而如果应用是很多读操作类型的，那么顺序读取效率会比较高，因为这样大部分内容都会在缓存中找到，尽可能避免大量的随机读取操作。</p><hr><h2 id="LevelDb剖析之八：Compaction操作"><a href="#LevelDb剖析之八：Compaction操作" class="headerlink" title="LevelDb剖析之八：Compaction操作"></a>LevelDb剖析之八：Compaction操作</h2><p>前文有述，对于LevelDb来说，写入记录操作很简单，删除记录仅仅写入一个删除标记就算完事，但是读取记录比较复杂，需要在内存以及各个层级文件中依照新鲜程度依次查找，代价很高。为了加快读取速度，levelDb采取了compaction的方式来对已有的记录进行整理压缩，通过这种方式，来删除掉一些不再有效的KV数据，减小数据规模，减少文件数量等。</p><p>levelDb的compaction机制和过程与Bigtable所讲述的是基本一致的，Bigtable中讲到三种类型的compaction: minor ，major和full。所谓minor Compaction，就是把memtable中的数据导出到SSTable文件中；major compaction就是合并不同层级的SSTable文件，而full compaction就是将所有SSTable进行合并。</p><p>LevelDb包含其中两种，minor和major。</p><p>我将为大家详细叙述其机理。</p><p>先来看看minor Compaction的过程。Minor compaction 的目的是当内存中的memtable大小到了一定值时，将内容保存到磁盘文件中，图8.1是其机理示意图。 </p><p><img src="/images/imageLeveldb/level11.png" alt="8.1 minor compaction"></p><p>从8.1可以看出，当memtable数量到了一定程度会转换为immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable其实是一个多层级队列SkipList，其中的记录是根据key有序排列的。所以这个minor compaction实现起来也很简单，就是按照immutable memtable中记录由小到大遍历，并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 数据，这样就完成了一次minor compaction。从图中也可以看出，对于被删除的记录，在minor compaction过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉key记录，但是这个KV数据在哪里?那需要复杂的查找，所以在minor compaction的时候并不做删除，只是将这个key作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的compaction中会去做。</p><p>当某个level下的SSTable文件数目超过一定设置值后，levelDb会从这个level的SSTable中选择一个文件（level&gt;0），将其和高一层级的level+1的SSTable文件合并，这就是major compaction。</p><p>我们知道在大于0的层级中，每个SSTable文件内的Key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。Level 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。</p><p>levelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，levelDb在这里有个小技巧， 就是说轮流来，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。</p><p>如果选好了level L的文件A和level L+1层的文件进行合并，那么问题又来了，应该选择level L+1哪些文件进行合并？levelDb选择L+1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。</p><p>也就是说，选定了level L的文件A,之后在level L+1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。</p><p>图8.2说明了这一过程。</p><p><img src="/images/imageLeveldb/level12.png" alt="8.2 SSTable Compaction"></p><p>Major compaction的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的Key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个Key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入level L+1层中新生成的一个SSTable文件中。就这样对KV数据一一处理，形成了一系列新的L+1层数据文件，之前的L层文件和L+1层参与compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了L层和L+1层文件记录的合并过程。</p><p>那么在major compaction过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于L层中存在这个Key，那么这个KV在major compaction过程中可以抛掉。因为我们前面分析过，对于层级低于L的文件中如果存在同一Key的记录，那么说明对于Key来说，有更新鲜的Value存在，那么过去的Value就等于没有意义了，所以可以删除。</p><hr><h2 id="LevelDb剖析之九-levelDb中的Cache"><a href="#LevelDb剖析之九-levelDb中的Cache" class="headerlink" title="LevelDb剖析之九 levelDb中的Cache"></a>LevelDb剖析之九 levelDb中的Cache</h2><p>书接前文，前面讲过对于levelDb来说，读取操作如果没有在内存的memtable中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在level 0中最新的文件中找到了这个key，那么也需要读取2次磁盘，一次是将SSTable的文件中的index部分读入内存，这样根据这个index可以确定key是在哪个block中存储；第二次是读入这个block的内容，然后在内存中查找key对应的value。</p><p>levelDb中引入了两个不同的Cache:Table Cache和Block Cache。其中Block Cache是配置可选的，即在配置文件中指定是否打开这个功能。</p><p><img src="/images/imageLeveldb/level3.png" alt="9.1 table cache"></p><p>图9.1是table cache的结构。在Cache中，key值是SSTable的文件名称，Value部分包含两部分，一个是指向磁盘打开的SSTable文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个SSTable文件对应的Table结构指针，table结构在内存中，保存了SSTable的index内容以及用来指示block cache用的cache_id ,当然除此外还有其它一些内容。</p><p>比如在get(key)读取操作中，如果levelDb确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，levelDb会首先查找Table Cache，看这个文件是否在缓存里，如果找到了，那么根据index部分就可以查找是哪个block包含这个key。如果没有在缓存中找到文件，那么打开SSTable文件，将其index部分读入内存，然后插入Cache里面，去index里面定位哪个block包含这个Key 。如果确定了文件哪个block包含这个key，那么需要读入block内容，这是第二次读取。</p><p>Block Cache是为了加快这个过程的，图9.2是其结构示意图。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p><p>如果levelDb发现这个block在block cache中，那么可以避免读取数据，直接在cache里的block内容里面查找key的value就行，如果没找到呢？那么读入block内容并把它插入block cache中。levelDb就是这样通过两个cache来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p><hr><h2 id="LevelDb剖析之十-Version、VersionEdit、VersionSet"><a href="#LevelDb剖析之十-Version、VersionEdit、VersionSet" class="headerlink" title="LevelDb剖析之十 Version、VersionEdit、VersionSet"></a>LevelDb剖析之十 Version、VersionEdit、VersionSet</h2><p>Version 保存了当前磁盘以及内存中所有的文件信息，一般只有一个Version叫做”current” version（当前版本）。Leveldb还保存了一系列的历史版本，这些历史版本有什么作用呢？</p><p>当一个Iterator创建后，Iterator就引用到了current version(当前版本)，只要这个Iterator不被delete那么被Iterator引用的版本就会一直存活。这就意味着当你用完一个Iterator后，需要及时删除它。</p><p>当一次Compaction结束后（会生成新的文件，合并前的文件需要删除），Leveldb会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p><p>VersionSet 是所有Version的集合，管理着所有存活的Version。</p><p>VersionEdit 表示Version之间的变化，相当于delta 增量，表示有增加了多少文件，删除了文件。下图表示他们之间的关系。</p><p>Version0 +VersionEdit–&gt;Version1</p><p>VersionEdit会保存到MANIFEST文件中，当做数据恢复时就会从MANIFEST文件中读出来重建数据。</p><p>leveldb的这种版本的控制，让我想到了双buffer切换，双buffer切换来自于图形学中，用于解决屏幕绘制时的闪屏问题，在服务器编程中也有用处。</p><p>比如我们的服务器上有一个字典库，每天我们需要更新这个字典库，我们可以新开一个buffer，将新的字典库加载到这个新buffer中，等到加载完毕，将字典的指针指向新的字典库。</p><p>leveldb的version管理和双buffer切换类似，但是如果原version被某个iterator引用，那么这个version会一直保持，直到没有被任何一个iterator引用，此时就可以删除这个version。</p><p>注：本文参考了这篇文章：<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20vYmxvZy9JbmRleC5hc3A/U29ydElEPTEy" title="http://www.samecity.com/blog/Index.asp?SortID=12">http://www.samecity.com/blog/Index.asp?SortID=12<i class="fa fa-external-link"></i></span><br>参考资料：1.<span class="exturl" data-url="aHR0cDovL3poLndpa2lwZWRpYS5vcmcvd2lraS9MZXZlbERC" title="http://zh.wikipedia.org/wiki/LevelDB">维基百科<i class="fa fa-external-link"></i></span><br>　　　　　2.<span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2xldmVsZGIv" title="http://code.google.com/p/leveldb/">google code<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在说LevelDb之前，先认识两位大牛，Jeff Dean和Sanjay Ghemawat，这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。&lt;/p&gt;
&lt;p&gt;Jeff Dean其人：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3Jlc2VhcmNoLmdvb2dsZS5jb20vcGVvcGxlL2plZmYvaW5kZXguaHRtbA==&quot; title=&quot;http://research.google.com/people/jeff/index.html&quot;&gt;http://research.google.com/people/jeff/index.html&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。&lt;/p&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>处理并发之二：libevent的eventbuffer</title>
    <link href="http://miaopei.github.io/2016/07/12/Program-C/libevent/"/>
    <id>http://miaopei.github.io/2016/07/12/Program-C/libevent/</id>
    <published>2016-07-12T02:14:50.000Z</published>
    <updated>2019-06-14T07:46:43.817Z</updated>
    
    <content type="html"><![CDATA[<p>bufferevent这个结构体</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">ev_base</span>;</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent_ops</span> *<span class="title">be_ops</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev_read</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev_write</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">input</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span>;</span> </span><br><span class="line">    bufferevent_data_cb readcb;</span><br><span class="line">    bufferevent_data_cb writecb;</span><br><span class="line">    bufferevent_event_cb errorcb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 struct bufferevent 内置了两个 event（读/写）和对应的缓冲区。当有数据被读入(input)的时候，readcb 被调用，当 output 被输出完成的时候，writecb 被调用，当网络 I/O 出现错误，如链接中断，超时或其他错误时，errorcb 被调用。<br>使用 bufferevent 的过程：</p><p><strong>1. 设置sock为非阻塞的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:  evutil_make_socket_nonblocking(fd);</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用bufferevent_socket_new创建一个structbufferevent *bev，关联该sockfd，托管给event_base</strong></p><p>函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent * <span class="title">bufferevent_socket_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">int</span> options)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// eg:  struct bufferevent *bev;  </span></span></span><br><span class="line"><span class="function"><span class="comment">// bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span></span></span><br></pre></td></tr></table></figure><p><strong>3. 设置读写对应的回调函数</strong></p><p>函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,   </span></span></span><br><span class="line"><span class="function"><span class="params">bufferevent_data_cb readcb, bufferevent_data_cb writecb,  </span></span></span><br><span class="line"><span class="function"><span class="params">bufferevent_event_cb eventcb, <span class="keyword">void</span> *cbarg)</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// eg. bufferevent_setcb(bev, readcb, NULL, errorcb, NULL);</span></span></span><br></pre></td></tr></table></figure><p><strong>4. 启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的</strong></p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> event)</span>   </span></span><br><span class="line"><span class="function"><span class="comment">// eg. bufferevent_enable(bev, EV_READ|EV_WRITE);</span></span></span><br></pre></td></tr></table></figure><p><strong>5. 进入bufferevent_setcb回调函数：</strong></p><p>在readcb里面从input中读取数据，处理完毕后填充到output中； writecb对于服务端程序，只需要readcb就可以了，可以置为NULL； errorcb 用于处理一些错误信息。</p><p>针对这些使用过程进入源码进行分析：</p><p><strong>1. bufferevent_socket_new</strong>     </p><ul><li>在bufferevent_init_common中调用evbuffer_new()初始化input和output</li><li>在event_assign中初始化bufferevent中的ev_read和ev_write事件。</li><li>在evbuffer_add_cb中给output添加了一个callback bufferevent_socket_outbuf_cb</li></ul><p><strong>2. bufferevent_setcb</strong></p><p>该函数的作用主要是赋值，把该函数后面的参数，赋值给第一个参数 <code>struct bufferevent *bufev</code> 定义的变量</p><p><strong>3. bufferevent_enable</strong></p><p>调用event_add将读写事件加入到事件监听队列中。</p><p>对bufferevent常用的几个函数进行分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">evbuffer_readln</span><span class="params">(struct evbuffer*buffer, <span class="keyword">size_t</span> *n_read_out,<span class="keyword">enum</span></span></span></span><br><span class="line"><span class="function"><span class="params">evbuffer_eol_style eol_style)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//含义：Read a single line from an evbuffer.</span></span><br><span class="line"><span class="comment">//返回值：读到的一行内容</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add</span><span class="params">(struct evbuffer *buf,<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含义：将数据添加到evbuffer的结尾</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove</span><span class="params">(struct evbuffer*buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含义：从evbuffer读取数据到data</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> evbuffer_get_length(<span class="keyword">const</span> structevbuffer *buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含义：返回evbuffer中存储的字节长度</span></span><br></pre></td></tr></table></figure><p>暂时先分析到这里，下面是代码，客户端发送消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0, Client 0 send Message:</span><br><span class="line">Request: Hello Server! over</span><br></pre></td></tr></table></figure><p>服务端一条消息收完成后，会回复：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response ok! Hello Client!</span><br></pre></td></tr></table></figure><p>服务端从bufferevent中取出消息是按行取的。代码可能有不完善的地方，由于才疏学浅，研究时间短（3天），希望高手提出宝贵意见。</p><details><summary>buffer_server.c</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;     </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;        </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span></span>;  </span><br><span class="line"><span class="comment">//struct bufferevent内建了两个event(read/write)和对应的缓冲区(struct evbuffer *input, *output)，并提供相应的函数用来操作缓冲区(或者直接操作bufferevent)   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收到数据后，判断是不一样一条消息的结束，结束标志为"over"字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readcb</span><span class="params">(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"called readcb!\n"</span>);   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">input</span>, *<span class="title">output</span>;</span>  </span><br><span class="line">    <span class="keyword">char</span> *request_line;  </span><br><span class="line">    <span class="keyword">size_t</span> len;  </span><br><span class="line">    <span class="comment">//其实就是取出bufferevent中的input  </span></span><br><span class="line">    input = bufferevent_get_input(bev);</span><br><span class="line">    <span class="comment">//其实就是取出bufferevent中的output </span></span><br><span class="line">    output = bufferevent_get_output(bev);  </span><br><span class="line">    <span class="keyword">size_t</span> input_len = evbuffer_get_length(input);      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input_len: %d\n"</span>, input_len);  </span><br><span class="line">    <span class="keyword">size_t</span> output_len = evbuffer_get_length(output);     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"output_len: %d\n"</span>, output_len);    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;        </span><br><span class="line">        <span class="comment">//从evbuffer前面取出一行，用一个新分配的空字符结束</span></span><br><span class="line">        <span class="comment">//的字符串返回这一行,EVBUFFER_EOL_CRLF表示行尾是一个可选的回车，后随一个换行符</span></span><br><span class="line">        request_line = evbuffer_readln(input, &amp;len, EVBUFFER_EOL_CRLF);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == request_line)&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The first line has not arrived yet.\n"</span>);            </span><br><span class="line">            <span class="built_in">free</span>(request_line);<span class="comment">//之所以要进行free是因为 line = mm_malloc(n_to_copy+1))，在这里进行了malloc </span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Get one line date: %s\n"</span>, request_line); </span><br><span class="line">            <span class="comment">//用于判断是不是一条消息的结束  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strstr</span>(request_line, <span class="string">"over"</span>) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> *response = <span class="string">"Response ok! Hello Client!\r\n"</span>;  </span><br><span class="line">                <span class="comment">//Adds data to an event buffer  </span></span><br><span class="line">                evbuffer_add(output, response, <span class="built_in">strlen</span>(response));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"服务端接收一条数据完成，回复客户端一条消息: %s\n"</span>, response);                 </span><br><span class="line">                <span class="built_in">free</span>(request_line);  </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">free</span>(request_line);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">size_t</span> input_len1 = evbuffer_get_length(input);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input_len1: %d\n"</span>, input_len1); </span><br><span class="line">    <span class="keyword">size_t</span> output_len1 = evbuffer_get_length(output);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"output_len1: %d\n\n"</span>, output_len1);  </span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errorcb</span><span class="params">(struct bufferevent *bev, <span class="keyword">short</span> error, <span class="keyword">void</span> *ctx)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (error &amp; BEV_EVENT_EOF) &#123; </span><br><span class="line">        <span class="comment">/* connection has been closed, do any clean up here */</span>    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connection closed\n"</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (error &amp; BEV_EVENT_ERROR)&#123;    </span><br><span class="line">        <span class="comment">/* check errno to see what error occurred */</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"some other error\n"</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error &amp; BEV_EVENT_TIMEOUT) </span><br><span class="line">        <span class="comment">/* must be a timeout event handle, handle it */</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Timed out\n"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">bufferevent_free(bev);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_accept</span><span class="params">(<span class="keyword">evutil_socket_t</span> listener, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">arg</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span>  </span><br><span class="line"><span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);  </span><br><span class="line"><span class="keyword">int</span> fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);  </span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"accept"</span>);  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (fd &gt; FD_SETSIZE)&#123;  </span><br><span class="line">close(fd);  </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">struct bufferevent *bev;</span><br><span class="line">evutil_make_socket_nonblocking(fd);           </span><br><span class="line"><span class="comment">//使用bufferevent_socket_new创建一个struct bufferevent*bev，</span></span><br><span class="line"><span class="comment">//关联该sockfd，托管给event_base           </span></span><br><span class="line"><span class="comment">//BEV_OPT_CLOSE_ON_FREE表示释放bufferevent时关闭底层传输端口。</span></span><br><span class="line">    <span class="comment">//这将关闭底层套接字，释放底层bufferevent等</span></span><br><span class="line">bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);           </span><br><span class="line"><span class="comment">//设置读写对应的回调函数  </span></span><br><span class="line">bufferevent_setcb(bev, readcb, <span class="literal">NULL</span>, errorcb, <span class="literal">NULL</span>);  </span><br><span class="line">bufferevent_setwatermark(bev, EV_READ, <span class="number">0</span>, MAX_LINE);          </span><br><span class="line"><span class="comment">//启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。</span></span><br><span class="line"><span class="comment">//正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的  </span></span><br><span class="line">bufferevent_enable(bev, EV_READ|EV_WRITE); </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line"><span class="keyword">evutil_socket_t</span> listener;   </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">listener_event</span>;</span>    </span><br><span class="line">base = event_base_new();  </span><br><span class="line"><span class="keyword">if</span> (!base)  </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;  </span><br><span class="line"><span class="built_in">sin</span>.sin_addr.s_addr = <span class="number">0</span>;  </span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(<span class="number">8000</span>);   </span><br><span class="line">listener = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">evutil_make_socket_nonblocking(listener);  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> WIN32&#123;    </span></span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">1</span>;        </span><br><span class="line">    setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, </span><br><span class="line">                   &amp;one, <span class="keyword">sizeof</span>(one));  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">    <span class="keyword">if</span>(bind(listener, (struct sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);          </span><br><span class="line">        <span class="keyword">return</span>;     </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listen(listener, <span class="number">16</span>)&lt;<span class="number">0</span>)&#123;perror(<span class="string">"listen"</span>);  </span><br><span class="line">        <span class="keyword">return</span>;     </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (<span class="keyword">void</span>*)base);</span><br><span class="line">    event_add(listener_event, <span class="literal">NULL</span>);  event_base_dispatch(base);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);   </span><br><span class="line">    run();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bufferevent这个结构体&lt;/p&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://miaopei.github.io/2016/07/11/Program-C/multi-thread/"/>
    <id>http://miaopei.github.io/2016/07/11/Program-C/multi-thread/</id>
    <published>2016-07-11T02:14:50.000Z</published>
    <updated>2019-06-14T06:12:33.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyMzc1NTA5" title="https://www.zhihu.com/question/22375509">怎么样才算得上熟悉多线程编程？<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC91LzE4NjQ1NjcvYmxvZy8zNDA0NzE=" title="https://my.oschina.net/u/1864567/blog/340471">C++多线程模型与锁<i class="fa fa-external-link"></i></span></p></blockquote><ol><li>了解进程线程的基本概念，能用一种语言在一个平台上实现一个多线程的例子。（这些不会还写熟悉多线程就太大无畏了）</li><li>了解为什么要用Mutex之类的工具做锁来同步和保护资源。弄懂诸如racing condition，死锁之类的概念。50%公司的见面题，用来砍死大无畏。</li><li>了解编译器优化带来的影响，了解cache的影响，了解volatile，memory barrier之类的概念。如果是主Java的话，去了解一下JVM的内存模型。以上这些偏硬偏系统端的公司喜欢问，不过由于太基础，稍稍好奇一点的多线程领域程序员都应该会了解，否则略显大无畏。</li><li>了解一下你主攻平台＋语言所提供的工具库，知道常用的工具的用法和使用场景：Mutex，Semaphore，原子操作集，Condition Variable，spin lock。这几个算是比较常用的，在各个平台＋语言也都有对应实现。老实说，spinlock，condition variable是我工作里从没用过的，但是也被问过，其他几个都太常用了，如果是java的话再多看一组Executor相关的，以及Java多线程相关的keywords，和object本身提供的同步函数，wait notify之类的，在主Java的公司问过。</li><li>了解常用的多线程设计范式，比如读写锁（Reader/Writer Lock，非常经典的范式，有偏向读和写的不同变形，至少被要求写过3次），生产消费范式（写过2次），一些常用容器的实现，比如BlockingQueue（写过3次）或者concurrentHashmap（写过2次）。如果是主Java的话可以看看JDK的实现。熟悉一下一些算不上多线程设计模式的小技巧，比如传递只读对象可以避免加锁，或者Copy传递以防外部修改之类的（讨论环节被问过）。另外值得特别一提的一个小细节是，Singleton的线程安全是个很有意思而且容易出错的话题，值得一看（只被问过一次，不过我答挂了，所以印象及其深）。还有可能会问的是一些有趣的小场景让你实现一些功能需要线程安全，无法特别准备，但是你能了解上面说的这些范式，不傻的话大多数都能想出来。<br>如果和我一样多线程方面是主Java的话，记得Doug Lea的书写的很明白，不过不记得当时读完的是哪本，70%可能是下面这个<br><span class="exturl" data-url="aHR0cDovL3d3dy5hbWF6b24uY29tL0phdmEtQ29uY3VycmVuY3ktUHJhY3RpY2UtQnJpYW4tR29ldHovZHAvMDMyMTM0OTYwMQ==" title="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601<i class="fa fa-external-link"></i></span><br>否则就是<br>Concurrent Programming in Java: Design Principles and Pattern (2nd Edition): Doug Lea: 0785342310092: Amazon.com: Books</li></ol><p>这个大致是一些公司对多线程部分的要求，如果应聘者声称熟悉这个部分。上面所有点都是本人面试被问到的，基本上能看完上面这些，可以做到不用很心虚在简历上写自己熟悉多线程而不会被揭穿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyMzc1NTA5&quot; title=&quot;https://www.zhihu.com/question/2
      
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>处理并发之一：LINUX Epoll 机制介绍</title>
    <link href="http://miaopei.github.io/2016/07/08/Program-C/linux-epoll/"/>
    <id>http://miaopei.github.io/2016/07/08/Program-C/linux-epoll/</id>
    <published>2016-07-08T02:14:50.000Z</published>
    <updated>2019-06-14T07:19:50.504Z</updated>
    
    <content type="html"><![CDATA[<p>Epoll 可是当前在 Linux 下开发大规模并发网络程序的热门人选，Epoll 在 Linux2.6 内核中正式引入，和 select 相似，其实都 I/O 多路复用技术而已，并没有什么神秘的。</p><p>其实在 Linux 下设计并发网络程序，向来不缺少方法，比如典型的 Apache 模型（Process Per Connection，简称 PPC），TPC（Thread Per Connection）模型，以及 select 模型和 poll 模型，那为何还要再引入 Epoll 这个东东呢？那还是有得说说的…</p><a id="more"></a><h2 id="常用模型的缺点"><a href="#常用模型的缺点" class="headerlink" title="常用模型的缺点"></a>常用模型的缺点</h2><p>如果不摆出来其他模型的缺点，怎么能对比出 Epoll 的优点呢。</p><h3 id="PPC-TPC-模型"><a href="#PPC-TPC-模型" class="headerlink" title="PPC/TPC 模型"></a>PPC/TPC 模型</h3><p>这两种模型思想类似，就是让每一个到来的连接一边自己做事去，别再来烦我。只是 PPC 是为它开了一个进程，而 TPC 开了一个线程。可是别烦我是有代价的，它要时间和空间啊，连接多了之后，那么多的进程 / 线程切换，这开销就上来了；因此这类模型能接受的最大连接数都不会高，一般在几百个左右。</p><h3 id="select模型"><a href="#select模型" class="headerlink" title="select模型"></a>select模型</h3><ol><li><p>最大并发数限制，因为一个进程所打开的 FD（文件描述符）是有限制的，由 FD_SETSIZE 设置，默认值是 1024/2048，因此 Select 模型的最大并发数就被相应限制了。自己改改这个FD_SETSIZE？想法虽好，可是先看看下面吧…</p></li><li><p>效率问题，select 每次调用都会线性扫描全部的 FD 集合，这样效率就会呈现线性下降，把FD_SETSIZE 改大的后果就是，大家都慢慢来，什么？都超时了？？！！</p></li><li><p>内核 / 用户空间 内存拷贝问题，如何让内核把 FD 消息通知给用户空间呢？在这个问题上 select 采取了内存拷贝方法。</p></li></ol><h3 id="poll-模型"><a href="#poll-模型" class="headerlink" title="poll 模型"></a>poll 模型</h3><p>基本上效率和 select 是相同的，select 缺点的 2 和 3 它都没有改掉。</p><h2 id="Epoll-的提升"><a href="#Epoll-的提升" class="headerlink" title="Epoll 的提升"></a>Epoll 的提升</h2><p>把其他模型逐个批判了一下，再来看看 Epoll 的改进之处吧，其实把 select 的缺点反过来那就是 Epoll 的优点了。</p><ol><li><p>Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048,  一般来说这个数目和系统内存关系很大，具体数目可以 <code>cat /proc/sys/fs/file-max</code> 察看。</p></li><li><p>效率提升，Epoll 最大的优点就在于它只管你 “活跃” 的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll 的效率就会远远高于 select 和 poll。</p></li><li><p>内存拷贝，Epoll 在这点上使用了 “共享内存”，这个内存拷贝也省略了。</p></li></ol><h2 id="Epoll为什么高效"><a href="#Epoll为什么高效" class="headerlink" title="Epoll为什么高效"></a>Epoll为什么高效</h2><p>Epoll 的高效和其数据结构的设计是密不可分的，这个下面就会提到。</p><p>首先回忆一下 select 模型，当有 I/O 事件到来时，select 通知应用程序有事件到了快去处理，而应用程序必须轮询所有的 FD 集合，测试每个 FD 是否有事件发生，并处理事件；</p><details><summary>代码像下面这样：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = select(maxfd+<span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">120</span>);</span><br><span class="line"><span class="keyword">if</span>(res &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_CONNECTION; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(allConnection[i],&amp;readfds))</span><br><span class="line">        &#123;</span><br><span class="line">            handleEvent(allConnection[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if(res == 0) handle timeout, res &lt; 0 handle error</span></span><br></pre></td></tr></table></figure></details><p>Epoll 不仅会告诉应用程序有 I/0 事件到来，还会告诉应用程序相关的信息，这些信息是应用程序填充的，因此根据这些信息应用程序就能直接定位到事件，而不必遍历整个 FD 集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">intres = epoll_wait(epfd, events, <span class="number">20</span>, <span class="number">120</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res;i++)</span><br><span class="line">&#123;</span><br><span class="line">    handleEvent(events[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Epoll-关键数据结构"><a href="#Epoll-关键数据结构" class="headerlink" title="Epoll 关键数据结构"></a>Epoll 关键数据结构</h2><p>前面提到 Epoll 速度快和其数据结构密不可分，其关键数据结构就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;      <span class="comment">// Epoll events</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;      <span class="comment">// User datavariable</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">   <span class="keyword">void</span> *ptr;</span><br><span class="line">   <span class="keyword">int</span> fd;</span><br><span class="line">   <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">   <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>结构体 <code>epoll_event</code> 被用于注册所感兴趣的事件和回传所发生待处理的事件. </p><p>其中 <code>epoll_data</code> 联合体用来保存触发事件的某个文件描述符相关的数据. </p><p>例如一个 client 连接到服务器，服务器通过调用 accept 函数可以得到于这个 client 对应的 socket 文件描述符，可以把这文件描述符赋给 epoll_data 的 fd 字段以便后面的读写操作在这个文件描述符上进行。epoll_event 结构体的 events 字段是表示感兴趣的事件和被触发的事件可能的取值为： </p><ul><li>EPOLLIN ：表示对应的文件描述符可以读；</li><li>EPOLLOUT：表示对应的文件描述符可以写；</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读</li><li>EPOLLERR：表示对应的文件描述符发生错误；</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET：表示对应的文件描述符有事件发生；</li></ul><p><strong>ET 和 LT 模式</strong></p><p>LT(level triggered) 是缺省的工作方式，并且同时支持 block 和 no-block socket. 在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的 select/poll 都是这种模型的代表。</p><p>ET (edge-triggered) 是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 EWOULDBLOCK 错误）。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知(only once)，不过在 TCP 协议中，ET 模式的加速效用仍需要更多的 benchmark 确认。</p><p>ET 和 LT 的区别在于 LT 事件不会丢弃，而是只要读 buffer 里面有数据可以让用户读，则不断的通知你。而 ET 则只在事件发生之时通知。可以简单理解为 LT 是水平触发，而 ET 则为边缘触发。</p><p>ET 模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用 ET 模式,需要一直 <code>read/write</code> 直到出错为止, 很多人反映为什么采用 ET 模式只接收了一部分数据就再也得不到通知了, 大多因为这样; 而 LT 模式是只要有数据没有处理就会一直通知下去的.</p><h2 id="使用-Epoll"><a href="#使用-Epoll" class="headerlink" title="使用 Epoll"></a>使用 Epoll</h2><p>既然 Epoll 相比 select 这么好，那么用起来如何呢？会不会很繁琐啊…先看看下面的三个函数吧，就知道 Epoll 的易用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>生成一个 Epoll 专用的文件描述符，其实是申请一个内核空间，用来存放你想关注的 socket fd 上是否发生以及发生了什么事件。size 就是你在这个 Epoll fd 上能关注的最大 socket fd 数，大小自定，只要内存足够。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</p><ul><li>EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；</li><li>EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件；</li><li>EPOLL_CTL_DEL：从 epfd 中删除一个 fd；</li></ul><p>第三个参数是需要监听的 fd，第四个参数是告诉内核需要监听什么事</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_event * events,<span class="keyword">int</span> maxevents,<span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>等待 I/O 事件的发生；参数说明：</p><ul><li>epfd: 由 <code>epoll_create()</code> 生成的 Epoll 专用的文件描述符；</li><li>epoll_event: 用于回传代处理事件的数组；</li><li>maxevents: 每次能处理的事件数；</li><li>timeout: 等待 I/O 事件发生的超时值；</li><li>返回发生事件数。</li></ul><hr><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>首先对服务端和客户端做下说明：</p><ul><li><p>我想实现的是客户端和服务端并发的程序，客户端通过配置并发数，说明有多少个用户去连接服务端。</p></li><li><p>客户端会发送消息：”Client: i send message Hello Server!”，其中 <code>i</code> 表示哪一个客户端；收到消息：”Recv Server Msg Content:%s\n”。</p></li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发送：Client: 1 send message "Hello Server!"</span><br><span class="line">接收：Recv Derver Msg Content:Hello, client fd: 6</span><br><span class="line">服务端收到后给客户端回复消息："Hello, client fd: i"，其中 i 表示服务端接收的 fd, 用户区别是哪一个客户端。接收客户端消息："Terminal Received Msg Content:%s\n"</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送：Hello, client fd: 6</span><br><span class="line">接收：Terminal Received Msg Content:Client: 1 send message "Hello Server!"</span><br></pre></td></tr></table></figure><p>备注：这里在接收到消息后，直接打印出消息，如果需要对消息进行处理（如果消息处理比较占用时间，不能立即返回，可以将该消息放入一个队列中，然后开启一个线程从队列中取消息进行处理，这样的话不会因为消息处理而阻塞 epoll）。libenent 好像对这种有 2 中处理方式，一个就是回调，要求回调函数，不占用太多的时间，基本能立即返回，另一种好像也是一个队列实现的，这个还需要研究。</p><p>服务端代码说明：</p><p>服务端在绑定监听后，开启了一个线程，用于负责接收客户端连接，加入到 epoll 中，这样只要 accept 到客户端的连接，就将其 add EPOLLIN 到 epoll 中，然后进入循环调用 epoll_wait，监听到读事件，接收数据，并将事件修改为 EPOLLOUT；反之监听到写事件，发送数据，并将事件修改为EPOLLIN。</p><details><summary>服务器代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cepollserver.h  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  C_EPOLL_SERVER_H  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  C_EPOLL_SERVER_H  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MAX_SOCKFD_COUNT 65535  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEpollServer</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    CEpollServer();  </span><br><span class="line">    ~CEpollServer();  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* chIp, <span class="keyword">int</span> iPort)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Listen</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListenThread</span><span class="params">( <span class="keyword">void</span>* lpVoid )</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span>        m_iEpollFd;  </span><br><span class="line">    <span class="keyword">int</span>        m_isock;  </span><br><span class="line">    <span class="keyword">pthread_t</span>       m_ListenThreadId;<span class="comment">// 监听线程句柄  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cepollserver.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line">CEpollServer::CEpollServer()  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">CEpollServer::~CEpollServer()  </span><br><span class="line">&#123;  </span><br><span class="line">    close(m_isock);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">bool</span> CEpollServer::InitServer(<span class="keyword">const</span> <span class="keyword">char</span>* pIp, <span class="keyword">int</span> iPort)  </span><br><span class="line">&#123;  </span><br><span class="line">    m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置非阻塞模式  </span></span><br><span class="line">    <span class="keyword">int</span> opts = O_NONBLOCK;  </span><br><span class="line">    <span class="keyword">if</span>(fcntl(m_iEpollFd,F_SETFL,opts)&lt;<span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"设置非阻塞模式失败!\n"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    m_isock = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">0</span> &gt; m_isock ) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket error!\n"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">　　  </span><br><span class="line">    sockaddr_in listen_addr;  </span><br><span class="line">    listen_addr.sin_family=AF_INET;  </span><br><span class="line">    listen_addr.sin_port=htons ( iPort );  </span><br><span class="line">    listen_addr.sin_addr.s_addr=htonl(INADDR_ANY);  </span><br><span class="line">    listen_addr.sin_addr.s_addr=inet_addr(pIp);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ireuseadd_on = <span class="number">1</span>;<span class="comment">//支持端口复用  </span></span><br><span class="line">    setsockopt(m_isock, SOL_SOCKET, SO_REUSEADDR, &amp;ireuseadd_on, <span class="keyword">sizeof</span>(ireuseadd_on) );  </span><br><span class="line">　　  </span><br><span class="line">    <span class="keyword">if</span> ( bind ( m_isock, ( sockaddr * ) &amp;listen_addr,<span class="keyword">sizeof</span> ( listen_addr ) ) !=<span class="number">0</span> ) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bind error\n"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( listen ( m_isock, <span class="number">20</span>) &lt;<span class="number">0</span> ) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"listen error!\n"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"服务端监听中...\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听线程，此线程负责接收客户端连接，加入到epoll中  </span></span><br><span class="line">    <span class="keyword">if</span> ( pthread_create( &amp;m_ListenThreadId, <span class="number">0</span>, ( <span class="keyword">void</span> * ( * ) ( <span class="keyword">void</span> * ) ) ListenThread, <span class="keyword">this</span> ) != <span class="number">0</span> ) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server 监听线程创建失败!!!"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听线程  </span></span><br><span class="line"><span class="keyword">void</span> CEpollServer::ListenThread( <span class="keyword">void</span>* lpVoid )  </span><br><span class="line">&#123;  </span><br><span class="line">    CEpollServer *pTerminalServer = (CEpollServer*)lpVoid;  </span><br><span class="line">    sockaddr_in remote_addr;  </span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span> (remote_addr);  </span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;  </span><br><span class="line">        <span class="keyword">int</span> client_socket = accept (pTerminalServer-&gt;m_isock, ( sockaddr * ) &amp;remote_addr,(<span class="keyword">socklen_t</span>*)&amp;len );  </span><br><span class="line">        <span class="keyword">if</span> ( client_socket &lt; <span class="number">0</span> ) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Server Accept失败!, client_socket: %d\n"</span>, client_socket);  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            struct epoll_event    ev;  </span><br><span class="line">            ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;  </span><br><span class="line">            ev.data.fd = client_socket;     <span class="comment">//记录socket句柄  </span></span><br><span class="line">            epoll_ctl(pTerminalServer-&gt;m_iEpollFd, EPOLL_CTL_ADD, client_socket, &amp;ev);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">　　  </span><br><span class="line"><span class="keyword">void</span> CEpollServer::Run()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>    <span class="title">events</span>[_<span class="title">MAX_SOCKFD_COUNT</span>];</span>  </span><br><span class="line">        <span class="keyword">int</span> nfds = epoll_wait( m_iEpollFd, events,  _MAX_SOCKFD_COUNT, <span class="number">-1</span> );  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> client_socket = events[i].data.fd;  </span><br><span class="line">            <span class="keyword">char</span> buffer[<span class="number">1024</span>];<span class="comment">//每次收发的字节数小于1024字节  </span></span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1024</span>);  </span><br><span class="line">            <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)<span class="comment">//监听到读事件，接收数据  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">int</span> rev_size = recv(events[i].data.fd,buffer, <span class="number">1024</span>,<span class="number">0</span>);  </span><br><span class="line">                <span class="keyword">if</span>( rev_size &lt;= <span class="number">0</span> )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"recv error: recv size: "</span> &lt;&lt; rev_size &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_del</span>;</span>  </span><br><span class="line">                    event_del.data.fd = events[i].data.fd;  </span><br><span class="line">                    event_del.events = <span class="number">0</span>;  </span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Terminal Received Msg Content:%s\n"</span>,buffer);  </span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>    <span class="title">ev</span>;</span>  </span><br><span class="line">                    ev.events = EPOLLOUT | EPOLLERR | EPOLLHUP;  </span><br><span class="line">                    ev.data.fd = client_socket;     <span class="comment">//记录socket句柄  </span></span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;ev);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLOUT)<span class="comment">//监听到写事件，发送数据  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">char</span> sendbuff[<span class="number">1024</span>];  </span><br><span class="line">                <span class="built_in">sprintf</span>(sendbuff, <span class="string">"Hello, client fd: %d\n"</span>, client_socket);  </span><br><span class="line">                <span class="keyword">int</span> sendsize = send(client_socket, sendbuff, <span class="built_in">strlen</span>(sendbuff)+<span class="number">1</span>, MSG_NOSIGNAL);  </span><br><span class="line">                <span class="keyword">if</span>(sendsize &lt;= <span class="number">0</span>)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_del</span>;</span>  </span><br><span class="line">                    event_del.data.fd = events[i].data.fd;  </span><br><span class="line">                    event_del.events = <span class="number">0</span>;  </span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Server reply msg ok! buffer: %s\n"</span>, sendbuff);  </span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>    <span class="title">ev</span>;</span>  </span><br><span class="line">                    ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;  </span><br><span class="line">                    ev.data.fd = client_socket;     <span class="comment">//记录socket句柄  </span></span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;ev);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"EPOLL ERROR\n"</span> &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, events[i].data.fd, &amp;events[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>客户端代码：</summary><p>说明：测试是两个并发进行测试，每一个客户端都是一个长连接。代码中在连接服务器（ConnectToServer）时将用户 ID 和 socketid 关联起来。用户 ID 和 socketid 是一一对应的关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DEFINE_EPOLLCLIENT_H_  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DEFINE_EPOLLCLIENT_H_  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MAX_SOCKFD_COUNT 65535  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* @brief 用户状态 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _EPOLL_USER_STATUS_EM  </span><br><span class="line">&#123;  </span><br><span class="line">    FREE = <span class="number">0</span>,  </span><br><span class="line">    CONNECT_OK = <span class="number">1</span>,<span class="comment">//连接成功  </span></span><br><span class="line">    SEND_OK = <span class="number">2</span>,<span class="comment">//发送成功  </span></span><br><span class="line">    RECV_OK = <span class="number">3</span>,<span class="comment">//接收成功  </span></span><br><span class="line">&#125;EPOLL_USER_STATUS_EM;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*@brief </span></span><br><span class="line"><span class="comment">*@CEpollClient class 用户状态结构体 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserStatus</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    EPOLL_USER_STATUS_EM iUserStatus;<span class="comment">//用户状态  </span></span><br><span class="line">    <span class="keyword">int</span> iSockFd;<span class="comment">//用户状态关联的socketfd  </span></span><br><span class="line">    <span class="keyword">char</span> cSendbuff[<span class="number">1024</span>];<span class="comment">//发送的数据内容  </span></span><br><span class="line">    <span class="keyword">int</span> iBuffLen;<span class="comment">//发送数据内容的长度  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uEpollEvents;<span class="comment">//Epoll events  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEpollClient</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:CEpollClient </span></span><br><span class="line"><span class="comment">    * 描述:构造函数 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserCount  </span></span><br><span class="line"><span class="comment">    * @param [in] pIP IP地址 </span></span><br><span class="line"><span class="comment">    * @param [in] iPort 端口号 </span></span><br><span class="line"><span class="comment">    * @return 无返回 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    CEpollClient(<span class="keyword">int</span> iUserCount, <span class="keyword">const</span> <span class="keyword">char</span>* pIP, <span class="keyword">int</span> iPort);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:CEpollClient </span></span><br><span class="line"><span class="comment">    * 描述:析构函数 </span></span><br><span class="line"><span class="comment">    * @return 无返回 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    ~CEpollClient();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:RunFun </span></span><br><span class="line"><span class="comment">    * 描述:对外提供的接口，运行epoll类 </span></span><br><span class="line"><span class="comment">    * @return 无返回值 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">RunFun</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:ConnectToServer </span></span><br><span class="line"><span class="comment">    * 描述:连接到服务器 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserId 用户ID </span></span><br><span class="line"><span class="comment">    * @param [in] pServerIp 连接的服务器IP </span></span><br><span class="line"><span class="comment">    * @param [in] uServerPort 连接的服务器端口号 </span></span><br><span class="line"><span class="comment">    * @return 成功返回socketfd,失败返回的socketfd为-1 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ConnectToServer</span><span class="params">(<span class="keyword">int</span> iUserId,<span class="keyword">const</span> <span class="keyword">char</span> *pServerIp,<span class="keyword">unsigned</span> <span class="keyword">short</span> uServerPort)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:SendToServerData </span></span><br><span class="line"><span class="comment">    * 描述:给服务器发送用户(iUserId)的数据 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserId 用户ID </span></span><br><span class="line"><span class="comment">    * @return 成功返回发送数据长度 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SendToServerData</span><span class="params">(<span class="keyword">int</span> iUserId)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:RecvFromServer </span></span><br><span class="line"><span class="comment">    * 描述:接收用户回复消息 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserId 用户ID </span></span><br><span class="line"><span class="comment">    * @param [in] pRecvBuff 接收的数据内容 </span></span><br><span class="line"><span class="comment">    * @param [in] iBuffLen 接收的数据长度 </span></span><br><span class="line"><span class="comment">    * @return 成功返回接收的数据长度，失败返回长度为-1 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">RecvFromServer</span><span class="params">(<span class="keyword">int</span> iUserid,<span class="keyword">char</span> *pRecvBuff,<span class="keyword">int</span> iBuffLen)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:CloseUser </span></span><br><span class="line"><span class="comment">    * 描述:关闭用户 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserId 用户ID </span></span><br><span class="line"><span class="comment">    * @return 成功返回true </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CloseUser</span><span class="params">(<span class="keyword">int</span> iUserId)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:DelEpoll </span></span><br><span class="line"><span class="comment">    * 描述:删除epoll事件 </span></span><br><span class="line"><span class="comment">    * @param [in] iSockFd socket FD </span></span><br><span class="line"><span class="comment">    * @return 成功返回true </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DelEpoll</span><span class="params">(<span class="keyword">int</span> iSockFd)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span>    m_iUserCount;<span class="comment">//用户数量；  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UserStatus</span> *<span class="title">m_pAllUserStatus</span>;</span><span class="comment">//用户状态数组  </span></span><br><span class="line">    <span class="keyword">int</span>    m_iEpollFd;<span class="comment">//需要创建epollfd  </span></span><br><span class="line">    <span class="keyword">int</span>    m_iSockFd_UserId[_MAX_SOCKFD_COUNT];<span class="comment">//将用户ID和socketid关联起来  </span></span><br><span class="line">    <span class="keyword">int</span>    m_iPort;<span class="comment">//端口号  </span></span><br><span class="line">    <span class="keyword">char</span>   m_ip[<span class="number">100</span>];<span class="comment">//IP地址  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cepollclient.h"</span>  </span></span><br><span class="line"></span><br><span class="line">CEpollClient::CEpollClient(<span class="keyword">int</span> iUserCount, <span class="keyword">const</span> <span class="keyword">char</span>* pIP, <span class="keyword">int</span> iPort)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">strcpy</span>(m_ip, pIP);  </span><br><span class="line">    m_iPort = iPort;  </span><br><span class="line">    m_iUserCount = iUserCount;  </span><br><span class="line">    m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT);  </span><br><span class="line">    m_pAllUserStatus = (struct UserStatus*)<span class="built_in">malloc</span>(iUserCount*<span class="keyword">sizeof</span>(struct UserStatus));  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iuserid=<span class="number">0</span>; iuserid&lt;iUserCount ; iuserid++) &#123;  </span><br><span class="line">        m_pAllUserStatus[iuserid].iUserStatus = FREE;  </span><br><span class="line">        <span class="built_in">sprintf</span>(m_pAllUserStatus[iuserid].cSendbuff, <span class="string">"Client: %d send message \"Hello Server!\"\r\n"</span>, iuserid);  </span><br><span class="line">        m_pAllUserStatus[iuserid].iBuffLen = <span class="built_in">strlen</span>(m_pAllUserStatus[iuserid].cSendbuff) + <span class="number">1</span>;  </span><br><span class="line">        m_pAllUserStatus[iuserid].iSockFd = <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">memset</span>(m_iSockFd_UserId, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(m_iSockFd_UserId));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">CEpollClient::~CEpollClient()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">free</span>(m_pAllUserStatus);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CEpollClient::ConnectToServer(<span class="keyword">int</span> iUserId,<span class="keyword">const</span> <span class="keyword">char</span> *pServerIp,<span class="keyword">unsigned</span> <span class="keyword">short</span> uServerPort)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>( (m_pAllUserStatus[iUserId].iSockFd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>) ) &lt; <span class="number">0</span> ) &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: init socket fail, reason is:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="string">",errno is:"</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        m_pAllUserStatus[iUserId].iSockFd = <span class="number">-1</span>;  </span><br><span class="line">        <span class="keyword">return</span>  m_pAllUserStatus[iUserId].iSockFd;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span>  </span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));  </span><br><span class="line">    addr.sin_family = AF_INET;  </span><br><span class="line">    addr.sin_port = htons(uServerPort);  </span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(pServerIp);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> ireuseadd_on = <span class="number">1</span>;<span class="comment">//支持端口复用  </span></span><br><span class="line">    setsockopt(m_pAllUserStatus[iUserId].iSockFd, SOL_SOCKET, SO_REUSEADDR, &amp;ireuseadd_on, <span class="keyword">sizeof</span>(ireuseadd_on));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ul = <span class="number">1</span>;  </span><br><span class="line">    ioctl(m_pAllUserStatus[iUserId].iSockFd, FIONBIO, &amp;ul); <span class="comment">//设置为非阻塞模式   </span></span><br><span class="line">    connect(m_pAllUserStatus[iUserId].iSockFd, (<span class="keyword">const</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));  </span><br><span class="line">    m_pAllUserStatus[iUserId].iUserStatus = CONNECT_OK;  </span><br><span class="line">    m_pAllUserStatus[iUserId].iSockFd = m_pAllUserStatus[iUserId].iSockFd;  </span><br><span class="line">    <span class="keyword">return</span> m_pAllUserStatus[iUserId].iSockFd;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CEpollClient::SendToServerData(<span class="keyword">int</span> iUserId)  </span><br><span class="line">&#123;  </span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//此处控制发送频率，避免狂打日志，正常使用中需要去掉  </span></span><br><span class="line">    <span class="keyword">int</span> isendsize = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">if</span>( CONNECT_OK == m_pAllUserStatus[iUserId].iUserStatus || RECV_OK == m_pAllUserStatus[iUserId].iUserStatus) &#123;  </span><br><span class="line">        isendsize = send(m_pAllUserStatus[iUserId].iSockFd, m_pAllUserStatus[iUserId].cSendbuff, m_pAllUserStatus[iUserId  </span><br><span class="line">].iBuffLen, MSG_NOSIGNAL);  </span><br><span class="line">        <span class="keyword">if</span>(isendsize &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: SendToServerData, send fail, reason is:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="string">",errno is:"</span>&lt;&lt;errno&lt;  </span><br><span class="line">&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[CEpollClient info]: iUserId: %d Send Msg Content:%s\n"</span>, iUserId, m_pAllUserStatus[iUserId].cSendbuff  </span><br><span class="line">);  </span><br><span class="line">            m_pAllUserStatus[iUserId].iUserStatus = SEND_OK;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> isendsize;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CEpollClient::RecvFromServer(<span class="keyword">int</span> iUserId,<span class="keyword">char</span> *pRecvBuff,<span class="keyword">int</span> iBuffLen) </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> irecvsize = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(SEND_OK == m_pAllUserStatus[iUserId].iUserStatus) &#123;  </span><br><span class="line">        irecvsize = recv(m_pAllUserStatus[iUserId].iSockFd, pRecvBuff, iBuffLen, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &gt; irecvsize) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: iUserId: "</span> &lt;&lt; iUserId &lt;&lt; <span class="string">"RecvFromServer, recv fail, reason is:"</span>&lt;&lt;strerror(errn  </span><br><span class="line">o)&lt;&lt;<span class="string">",errno is:"</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == irecvsize) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[warning:] iUserId: "</span>&lt;&lt; iUserId &lt;&lt; <span class="string">"RecvFromServer, STB收到数据为0，表示对方断开连接,irecvsize:"</span>&lt;&lt;ire  </span><br><span class="line">cvsize&lt;&lt;<span class="string">",iSockFd:"</span>&lt;&lt; m_pAllUserStatus[iUserId].iSockFd &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Recv Server Msg Content:%s\n"</span>, pRecvBuff);  </span><br><span class="line">            m_pAllUserStatus[iUserId].iUserStatus = RECV_OK;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> irecvsize;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">bool</span> CEpollClient::CloseUser(<span class="keyword">int</span> iUserId)  </span><br><span class="line">&#123;  </span><br><span class="line">    close(m_pAllUserStatus[iUserId].iSockFd);  </span><br><span class="line">    m_pAllUserStatus[iUserId].iUserStatus = FREE;  </span><br><span class="line">    m_pAllUserStatus[iUserId].iSockFd = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">      </span><br><span class="line"><span class="keyword">int</span> CEpollClient::RunFun()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> isocketfd = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iuserid=<span class="number">0</span>; iuserid&lt;m_iUserCount; iuserid++) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span>  </span><br><span class="line">        isocketfd = ConnectToServer(iuserid, m_ip, m_iPort);  </span><br><span class="line">        <span class="keyword">if</span>(isocketfd &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: RunFun, connect fail"</span> &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        m_iSockFd_UserId[isocketfd] = iuserid;<span class="comment">//将用户ID和socketid关联起来  </span></span><br><span class="line">  </span><br><span class="line">        event.data.fd = isocketfd;  </span><br><span class="line">        event.events = EPOLLIN|EPOLLOUT|EPOLLERR|EPOLLHUP;  </span><br><span class="line">  </span><br><span class="line">        m_pAllUserStatus[iuserid].uEpollEvents = event.events;  </span><br><span class="line">        epoll_ctl(m_iEpollFd, EPOLL_CTL_ADD, event.data.fd, &amp;event);  </span><br><span class="line">　　&#125;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[_<span class="title">MAX_SOCKFD_COUNT</span>];</span>  </span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>];  </span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="number">1024</span>);  </span><br><span class="line">        <span class="keyword">int</span> nfds = epoll_wait(m_iEpollFd, events, _MAX_SOCKFD_COUNT, <span class="number">100</span> );<span class="comment">//等待epoll事件的产生  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ifd=<span class="number">0</span>; ifd&lt;nfds; ifd++)<span class="comment">//处理所发生的所有事件  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_nfds</span>;</span>  </span><br><span class="line">            <span class="keyword">int</span> iclientsockfd = events[ifd].data.fd;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"events[ifd].data.fd: "</span> &lt;&lt; events[ifd].data.fd &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">            <span class="keyword">int</span> iuserid = m_iSockFd_UserId[iclientsockfd];<span class="comment">//根据socketfd得到用户ID  </span></span><br><span class="line">            <span class="keyword">if</span>( events[ifd].events &amp; EPOLLOUT )  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">int</span> iret = SendToServerData(iuserid);  </span><br><span class="line">                <span class="keyword">if</span>( <span class="number">0</span> &lt; iret )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    event_nfds.events = EPOLLIN|EPOLLERR|EPOLLHUP;  </span><br><span class="line">                    event_nfds.data.fd = iclientsockfd;  </span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;event_nfds);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error:] EpollWait, SendToServerData fail, send iret:"</span>&lt;&lt;iret&lt;&lt;<span class="string">",iuserid:"</span>&lt;&lt;iuser  </span><br><span class="line">                        id&lt;&lt;<span class="string">",fd:"</span>&lt;&lt;events[ifd].data.fd&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                    DelEpoll(events[ifd].data.fd);  </span><br><span class="line">                    CloseUser(iuserid);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( events[ifd].events &amp; EPOLLIN )<span class="comment">//监听到读事件，接收数据  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">int</span> ilen = RecvFromServer(iuserid, buffer, <span class="number">1024</span>);  </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> &gt; ilen)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: RunFun, recv fail, reason is:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="string">",errno is:"</span>&lt;&lt;errno&lt;&lt;e  </span><br><span class="line">                        ndl;  </span><br><span class="line">                    DelEpoll(events[ifd].data.fd);  </span><br><span class="line">                    CloseUser(iuserid);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == ilen)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient warning:] server disconnect,ilen:"</span>&lt;&lt;ilen&lt;&lt;<span class="string">",iuserid:"</span>&lt;&lt;iuserid&lt;&lt;<span class="string">",fd:"</span>&lt;&lt;events[  </span><br><span class="line">                        ifd].data.fd&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                    DelEpoll(events[ifd].data.fd);  </span><br><span class="line">                    CloseUser(iuserid);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    m_iSockFd_UserId[iclientsockfd] = iuserid;<span class="comment">//将socketfd和用户ID关联起来  </span></span><br><span class="line">                    event_nfds.data.fd = iclientsockfd;  </span><br><span class="line">                    event_nfds.events = EPOLLOUT|EPOLLERR|EPOLLHUP;  </span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;event_nfds);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error:] other epoll error"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                DelEpoll(events[ifd].data.fd);  </span><br><span class="line">                CloseUser(iuserid);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">　　  </span><br><span class="line"><span class="keyword">bool</span> CEpollClient::DelEpoll(<span class="keyword">int</span> iSockFd)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">bool</span> bret = <span class="literal">false</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_del</span>;</span>  </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &lt; iSockFd)  </span><br><span class="line">    &#123;  </span><br><span class="line">        event_del.data.fd = iSockFd;  </span><br><span class="line">        event_del.events = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">if</span>( <span class="number">0</span> == epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del) )  </span><br><span class="line">        &#123;  </span><br><span class="line">            bret = <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[SimulateStb error:] DelEpoll,epoll_ctl error,iSockFd:"</span>&lt;&lt;iSockFd&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        m_iSockFd_UserId[iSockFd] = <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        bret = <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> bret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>服务器主程序：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cepollserver.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    CEpollServer  theApp;  </span><br><span class="line">    theApp.InitServer(<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>);  </span><br><span class="line">    theApp.Run();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>客户端主程序：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cepollclient.h"</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    CEpollClient *pCEpollClient = <span class="keyword">new</span> CEpollClient(<span class="number">2</span>, <span class="string">"127.0.0.1"</span>, <span class="number">8000</span>);  </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pCEpollClient)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[epollclient error]:main init"</span>&lt;&lt;<span class="string">"Init CEpollClient fail"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    pCEpollClient-&gt;RunFun();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != pCEpollClient)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">delete</span> pCEpollClient;  </span><br><span class="line">        pCEpollClient = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Epoll 可是当前在 Linux 下开发大规模并发网络程序的热门人选，Epoll 在 Linux2.6 内核中正式引入，和 select 相似，其实都 I/O 多路复用技术而已，并没有什么神秘的。&lt;/p&gt;
&lt;p&gt;其实在 Linux 下设计并发网络程序，向来不缺少方法，比如典型的 Apache 模型（Process Per Connection，简称 PPC），TPC（Thread Per Connection）模型，以及 select 模型和 poll 模型，那为何还要再引入 Epoll 这个东东呢？那还是有得说说的…&lt;/p&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>C 代码优化小贴士</title>
    <link href="http://miaopei.github.io/2016/07/06/Program-C/c-code-opt/"/>
    <id>http://miaopei.github.io/2016/07/06/Program-C/c-code-opt/</id>
    <published>2016-07-06T02:14:50.000Z</published>
    <updated>2019-06-14T06:47:57.606Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><span style="color: #000000">虽然对于优化C代码有很多有效的指导方针，但是对于彻底地了解编译器和你工作的机器依然无法取代，通常，加快程序的速度也会加大代码量。这些增加的代码也会影响一个程序的复杂度和可读性，这是不可接受的，比如你在一些小型的设备上编程，例如：移动设备、PDA……，这些有着严格的内存限制，于是，在优化的座右铭是:写代码在内存和速度都应该优化。</span></p><h2>整型数 / Integers</h2><p>在我们知道使用的数不可能是负数的时候，应该使用unsigned int取代int，一些处理器处理整数算数运算的时候unsigned int比int快，于是，在一个紧致的循环里面定义一个整型变量，最好这样写代码：</p><pre class="brush: c; gutter: true">register unsigned int variable_name;</pre><p>然而，我们不能保证编译器会注意到那个register关键字，也有可能，对某种处理器来说，有没有unsigned是一样的。这两个关键字并不是可以在所有的编译器中应用。</p>**记住，整形数运算要比浮点数运算快得多，因为处理器可以直接进行整型数运算，浮点数运算需要依赖于外部的浮点数处理器或者浮点数数学库。**<p>我们处理小数的时候要精确点些（比如我们在做一个简单的统计程序时），要限制结果不能超过100，要尽可能晚的把它转化成浮点数。</p><p>还有一个整形提升的问题，比如下面这个例子：<pre class="brush: c; gutter: true">size_t n = 10;int i ;for(i = -1; i < n; ++i){printf("%d\n",i);}</pre>这段代码实际上什么也不会输出，因为size_t是unsigned int类型，i会自动转换成unsigned int就变成了一个很大的正数，所以和n比较自然什么都不会输出。</p><p>在算术运算中，char和short会自动转换成int，转换的原则就是如果int类型能过包括操作数类型的所有范围，则操作数（比如unsigned short）转换成int，否则转换成unsigned int，int和long类型运算以此类推，**总是向着精度更高、位更长的类型转换。**</p><h2>除法和余数 / Division and Remainder</h2><p>在标准的处理器中，根据分子和分母的不同，一个32位的除法需要20-140个时钟周期来执行完成，等于一个固定的时间加上每个位被除的时间。</p><p>Time (分子/ 分母) = C0 + C1* log<sub>2</sub> (分子/分母)</p><p>= C0 + C1 * (log<sub>2</sub> (分子) &#8211; log<sub>2</sub> (分母)).<br>现在的ARM处理器需要消耗20+4.3N个时钟周期，这是一个非常费时的操作，要尽可能的避免。在有些情况下，除法表达式可以用乘法表达是来重写。比方说，(a/b)&gt;c可以写成a&gt;(c*b),条件是我们已经知道b为非负数而且b*c不会超过整型数的取值范围。如果我们能够确定其中的一个操作数为unsigned，那么使用无符号除法将会更好，因为它要比有符号除法快得多。</p><h2>合并除法运算和取余运算 / Combining division and remainder</h2><p>在一些情况下，除法运算和取余运算都需要用到，在这种情况下，编译器会将除法运算和取余运算合并，因为除法运算总是同时返回商和余数。如果两个运算都要用到，我们可以将他们写到一起。</p><pre class="brush: c; gutter: true">typedef unsigned int uint;uint div32u (uint a) {     return a / 32;}int div32s (int a) {     return a / 32;}</pre><p>这两种除法都会避免调用除法函数（进行移位操作），另外，无符号的除法要比有符号的除法使用更少的指令。有符号的除法要耗费更多的时间，因为这种除法是使最终结果趋向于零的，而移位则是趋向于负无穷。</p><h2>取模运算的替换 / An alternative for modulo arithmetic</h2><p>我们一般使用取余运算进行取模，不过，有时候使用 if 语句来重写也是可行的。考虑下面的两个例子：</p><pre class="brush: c; gutter: true">uint modulo_func1 (uint count){    return (++count % 60);}uint modulo_func2 (uint count){    if (++count &gt;= 60)        count = 0;    return (count);}</pre><p>第二个例子要比第一个更可取，因为由它产生的代码会更快，注意：这只是在count取值范围在0 – 59之间的时候才行。</p><p>但是我们可以使用如下的代码（笔者补充）实现等价的功能：</p><pre class="brush: c; gutter: true">uint modulo_func3 (uint count){    if (++count &gt;= 60)        count %= 60;    return (count);}</pre><h2>使用数组索引 / Using array indices</h2><p>假设你要依据某个变量的值，设置另一个变量的取值为特定的字符，你可能会这样做：</p><pre class="brush: c; gutter: true">switch(queue) {    case 0 :   letter = &#039;W&#039;;        break;    case 1 :   letter = &#039;S&#039;;        break;    case 2 :   letter = &#039;U&#039;;        break;}</pre><p>或者这样：</p><pre class="brush: c; gutter: true">if(queue == 0)    letter = &#039;W&#039;;else if ( queue == 1 )    letter = &#039;S&#039;;else    letter = &#039;U&#039;;</pre><p>有一个简洁且快速的方式是简单的将变量的取值做成一个字符串索引，例如：</p><pre class="brush: c; gutter: true">static char *classes = &quot;WSU&quot;;letter = classes[queue];</pre><h2> 全局变量 / Global variables</h2><p>全局变量不会被分配在寄存器上，修改全局变量需要通过指针或者调用函数的方式间接进行。所以编译器不会将全局变量存储在寄存器中，那样会带来额外的、不必要的负担和存储空间。所以在比较关键的循环中，我们要不使用全局变量。<br></p>******如果一个函数要频繁的使用全局变量，我们可以使用局部变量，作为全局变量的拷贝，这样就可以使用寄存器了。条件是本函数调用的任何子函数不使用这些全局变量。**<p>举个例子：</p><pre class="brush: c; gutter: true">int f(void);int g(void);int errs;void test1(void){    errs += f();    errs += g();}void test2(void){    int localerrs = errs;    localerrs += f();    localerrs += g();    errs = localerrs;}</pre><p>可以看到test1()中每次加法都需要读取和存储全局变量errs，而在test2()中，localerrs分配在寄存器上，只需要一条指令。</p><h2>使用别名 / Using Aliases</h2><p>考虑下面的例子：</p><pre class="brush: c; gutter: true">void func1( int *data ){    int i;    for(i = 0; i &lt; 10; i++)        anyfunc(*data, i);}</pre><p>即使*data从来没有变化，编译器却不知道anyfunc()没有修改它，于是程序每次用到它的时候，都要把它从内存中读出来，可能它只是某些变量的别名，这些变量在程序的其他部分被修改。如果能够确定它不会被改变，我们可以这样写：</p><pre class="brush: c; gutter: true">void func1( int *data ){int i;int localdata;localdata = *data;for(i=0; i&lt;10; i++)anyfunc(localdata, i);}</pre><p>这样会给编译器优化工作更多的选择余地。</p><h2>活跃变量和泄漏 / Live variables and spilling</h2><p>寄存器的数量在每个处理器当中都是固定的，所以在程序的某个特定的位置，可以保存在寄存器中的变量的数量是有限制的。有些编译器支持“生命周期分割”（live-range splitting），也就是说在函数的不同部分，变量可以被分配到不同的寄存器或者内存中。变量的生存范围被定义成：起点是对该变量的一次空间分配，终点是在下次空间分配之前的最后一次使用之间。在这个范围内，变量的值是合法的，是活的。在生存范围之外，变量不再被使用，是死的，它的寄存器可以供其他变量使用，这样，编译器就可以安排更多的变量到寄存器当中。<br>可分配到寄存器的变量需要的寄存器数量等于经过生命范围重叠的变量的数目，如果这个数目超过可用的寄存器的数量，有些变量就必须被暂时的存储到内存中。这种处理叫做“泄漏(spilling)”。<br>编译器优先释放最不频繁使用的变量，将释放的代价降到最低。可以通过以下方式避免变量的“释放”：</p><ul><li>限制活跃变量的最大数目：通常可以使用简单小巧的表达式，在函数内部不使用太多的变量。把大的函数分割成更加简单的、更加小巧的多个函数，也可能会有所帮助。</li><li>使用关键字register修饰最经常使用的变量：告诉编译器这个变量将会被经常用到，要求编译器使用非常高的优先级将此变量分配到寄存器中。尽管如此，在某些情况下，变量还是可能被泄漏。</li></ul><h2>变量类型 / Variable Types</h2><p>C编译器支持基本的变量类型：char、short、int、long(signed、unsigned)、float、double。为变量定义最恰当的类型，非常重要，因为这样可以减少代码和数据的长度，可以非常显著的提高效率。</p><h2>局部变量 / Local variables</h2><p>如果可能，局部变量要避免使用char和short。对于char和short类型，编译器在每次分配空间以后，都要将这种局部变量的尺寸减少到8位或16位。这对于符号变量来说称为符号扩展，对无符号变量称为无符号扩展。这种操作是通过将寄存器左移24或16位，然后再有符号（或无符号的）右移同样的位数来实现的，需要两条指令（无符号字节变量的无符号扩展需要一条指令）。<br>这些移位操作可以通过使用int和unsigned int的局部变量来避免。这对于那些首先将数据调到局部变量然后利用局部变量进行运算的情况尤其重要。即使数据以8位或16位的形式输入或输出，把他们当作32位来处理仍是有意义的。<br>我们来考虑下面的三个例子函数：</p><pre class="brush: c; gutter: true">int wordinc (int a){     return a + 1;}short shortinc (short a){     return a + 1;}char charinc (char a){     return a + 1;}</pre><p>他们的运算结果是相同的，但是第一个代码片断要比其他片断运行的要快。</p><h2>指针 / Pointers</h2><p>如果可能，我们应该使用结构体的引用作为参数，也就是结构体的指针，否则，整个结构体就会被压入堆栈，然后传递，这会降低速度。程序适用值传递可能需要几K字节，而一个简单的指针也可以达到同样的目的，只需要几个字节就可以了。<br>如果在函数内部不会改变结构体的内容，那么就应该将参数声明为const型的指针。举个例子：</p><pre class="brush: c; gutter: true">void print_data_of_a_structure (const Thestruct  *data_pointer){     ...printf contents of the structure...}</pre><p>这个例子代码告知编译器在函数内部不会改变外部结构体的内容，访问他们的时候，不需要重读。还可以确保编译器捕捉任何修改这个只读结构体的代码，给结构体以额外的保护。</p><h2>指针链 / Pointer chains</h2><p>指针链经常被用来访问结构体的信息，比如，下面的这段常见的代码：</p><pre class="brush: c; gutter: true">typedef struct { int x, y, z; } Point3;typedef struct { Point3 *pos, *direction; } Object;void InitPos1(Object *p){    p-&gt;pos-&gt;x = 0;    p-&gt;pos-&gt;y = 0;    p-&gt;pos-&gt;z = 0;}</pre><p>代码中，处理器在每次赋值操作的时候都要重新装载p-&gt;pos，因为编译器不知道p-&gt;pos-&gt;x不是p-&gt;pos的别名。更好的办法是将p-&gt;pos缓存成一个局部变量，如下：</p><pre class="brush: c; gutter: true">void InitPos2(Object *p){     Point3 *pos = p-&gt;pos;    pos-&gt;x = 0;     pos-&gt;y = 0;    pos-&gt;z = 0;}</pre><p>另一个可能的方法是将Point3结构体包含在Object结构体中，完全避免指针的使用。</p><h2>条件的执行 / Conditional Execution</h2><p>条件执行主要用在if语句中，同时也会用到由关系运算(&lt;,==,&gt;等)或bool运算(&amp;&amp;, !等)组成的复杂的表达式。尽可能的保持if和else语句的简单是有好处的，这样才能很好的条件化。关系表达式应该被分成包含相似条件的若干块。<br>下面的例子演示了编译器如何使用条件执行：</p><pre class="brush: c; gutter: true">int g(int a, int b, int c, int d){    if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &lt; 0 &amp;&amp; d &lt; 0)  //分组化的条件被捆绑在一起        return a + b + c + d;    return -1;}</pre><p>条件被分组，便以其能够条件化他们。</p><h2>Boolean表达式和范围检查 / Boolean Expressions &amp; Range checking</h2><p>有一种常见的boolean表达式被用来检查是否一个变量取值在某个特定的范围内，比方说，检查一个点是否在一个窗口内。</p><pre class="brush: c; gutter: true">bool PointInRectangelArea (Point p, Rectangle *r){    return (p.x &gt;= r-&gt;xmin &amp;&amp; p.x &lt; r-&gt;xmax &amp;&amp; p.y &gt;= r-&gt;ymin &amp;&amp; p.y &lt; r-&gt;ymax);}</pre><p>这里还有一个更快的方法：把(x &gt;= min &amp;&amp; x &lt; max) 转换成 (unsigned)(x-min) &lt; (max-min). 尤其是min为0时，更为有效。下面是优化后的代码：</p><pre class="brush: c; gutter: true">bool PointInRectangelArea (Point p, Rectangle *r){    return ((unsigned) (p.x - r-&gt;xmin) &lt; r-&gt;xmax &amp;&amp; (unsigned) (p.y - r-&gt;ymin) &lt; r-&gt;ymax);}</pre><h2>Boolean表达式&amp;与零的比较 / Boolean Expressions &amp; Compares with zero</h2><p>在比较(CMP)指令后，相应的处理器标志位就会被设置。这些标志位也可以被其他的指令设置，诸如MOV, ADD, AND, MUL, 也就是基本的数学和逻辑运算指令（数据处理指令）。假如一条数据处理指令要设置这些标志位，那么N和Z标志位的设置方法跟把数字和零比较的设置方法是一样的。N标志位表示结果是不是负数，Z标志位表示结果是不是零。<br>在C语言中，处理器中的N和Z标志位对应的有符号数的关系运算符是x &lt; 0, x &gt;= 0, x == 0, x != 0，无符号数对应的是x == 0, x != 0 (or x &gt; 0)。<br>C语言中，每用到一个关系运算符，编译器就会产生一个比较指令。如果关系运算符是上面的其中一个，在数据处理指令紧跟比较指令的情况下，编译器就会将比较指令优化掉。比如：</p><pre class="brush: c; gutter: true">int aFunction(int x, int y){    if (x + y &lt; 0)        return 1;    else        return 0;}</pre><p>这样做，会在关键循环中节省比较指令，使代码长度减少，效率增加。C语言中没有借位(carry)标志位和溢出(overflow)标志位的概念，所以如果不使用内嵌汇编语言，要访问C和V标志位是不可能的。尽管如此，编译器支持借位标志位（无符号数溢出），比方说：</p><pre class="brush: c; gutter: true">int sum(int x, int y){     int res;     res = x + y;     if ((unsigned) res &lt; (unsigned) x) // carry set?  //        res++;     return res;}</pre><h2>惰性评估计算 / Lazy Evaluation Exploitation</h2><p>在类似与这样的 if(a&gt;10 &amp;&amp; b=4) 语句中, 确保AND表达式的第一部分最有可能为false, 结果第二部分极有可能不被执行.</p><p>用switch() 代替if&#8230;else&#8230;，在条件选择比较多的情况下，可以用if…else…else…，像这样：</p><pre class="brush: c; gutter: true">if( val == 1)    dostuff1();else if (val == 2)    dostuff2();else if (val == 3)    dostuff3();</pre><p>使用switch可以更快：</p><pre class="brush: c; gutter: true">switch( val ){    case 1: dostuff1(); break;    case 2: dostuff2(); break;    case 3: dostuff3(); break;}</pre><p>在if语句中，即使是最后一个条件成立，也要先判断所有前面的条件是否成立。Switch语句能够去除这些额外的工作。如果你不得不使用if…else，那就把最可能的成立的条件放在前面。</p><h2>二分分解 / Binary Breakdown</h2><p>把判断条件做成二进制的风格，比如，不要使用下面的列表：</p><pre class="brush: c; gutter: true">if(a == 1) {     } else if(a == 2) {     } else if(a == 3) {     } else if(a == 4) {     } else if(a == 5) {     } else if(a == 6) {     } else if(a == 7) {     } else if(a == 8) {     }}</pre><p>而采用：</p><pre class="brush: c; gutter: true">if(a &lt;= 4) {     if(a == 1) {     } else if(a == 2) {     } else if(a == 3) {     } else if(a == 4) {     } } else {     if(a == 5) {     } else if(a == 6) {     } else if(a == 7) {     } else if(a == 8) {     } }</pre><p>甚至：</p><pre class="brush: c; gutter: true">if(a &lt;= 4) {     if(a &lt;= 2) {         if(a == 1) {                 /* a is 1 */         } else {                 /* a must be 2 */         }     } else {         if(a == 3) {                 /* a is 3 */         } else {                 /* a must be 4 */         }     } } else {     if(a &lt;= 6) {         if(a == 5) {                 /* a is 5 */         } else {                 /* a must be 6 */         }     } else {         if(a == 7) {                 /* a is 7 */         } else {                 /* a must be 8 */         }     } }</pre><p>慢速、低效：</p><pre class="brush: c; gutter: true">c = getch();switch(c){    case &#039;A&#039;: {        do something;          break;      }     case &#039;H&#039;: {        do something;        break;    }      case &#039;Z&#039;: {         do something;         break;     }}</pre><p>快速、高效：</p><pre class="brush: c; gutter: true">c = getch();switch(c) {    case 0: {        do something;        break;    }      case 1: {        do something;         break;    }     case 2: {        do something;         break;     }}</pre><p>以上是两个case语句之间的比较</p><h2>switch语句和查找表 / Switch statement vs. lookup tables</h2><p>switch语句通常用于以下情况：</p><ul><li>调用几个函数中的一个</li><li>设置一个变量或返回值</li><li>执行几个代码片断中的一个</li></ul><p>如果case表示是密集的，在使用switch语句的前两种情况中，可以使用效率更高的查找表。比如下面的两个实现汇编代码转换成字符串的例程：</p><pre class="brush: c; gutter: true">char * Condition_String1(int condition) {    switch(condition) {         case 0: return &quot;EQ&quot;;         case 1: return &quot;NE&quot;;         case 2: return &quot;CS&quot;;         case 3: return &quot;CC&quot;;         case 4: return &quot;MI&quot;;         case 5: return &quot;PL&quot;;         case 6: return &quot;VS&quot;;         case 7: return &quot;VC&quot;;         case 8: return &quot;HI&quot;;         case 9: return &quot;LS&quot;;         case 10: return &quot;GE&quot;;         case 11: return &quot;LT&quot;;         case 12: return &quot;GT&quot;;         case 13: return &quot;LE&quot;;         case 14: return &quot;&quot;;         default: return 0;    }}char * Condition_String2(int condition) {    if((unsigned) condition &gt;= 15) return 0;    return          &quot;EQNECSCCMIPLVSVCHILSGELTGTLE&quot; +           3 * condition;}</pre><p>第一个例程需要240个字节，第二个只需要72个。</p><h2>循环终止 / Loop termination</h2><p>如果不加留意地编写循环终止条件，就可能会给程序带来明显的负担。我们应该尽量使用“倒数到零”的循环，使用简单的循环终止条件。循环终止条件相对简单，程序在执行的时候也会消耗相对少的时间。拿下面两个计算n!的例子来说，第一个例子使用递增循环，第二个使用递减循环。</p><pre class="brush: c; gutter: true">int fact1_func (int n){    int i, fact = 1;    for (i = 1; i &lt;= n; i++)        fact *= i;    return (fact);}<p>int fact2_func(int n)<br>{    int i, fact = 1;<br>    for (i = n; i != 0; i–)<br>        fact *= i;<br>    return (fact);<br>}</p></pre><p></p><p>结果是，第二个例子要比第一个快得多。</p><h2>更快的for()循环 / Faster for() loops</h2><p>这是一个简单而有效的概念，通常情况下，我们习惯把for循环写成这样：</p><pre class="brush: c; gutter: true">for( i = 0;  i &lt; 10;  i++){ ... }</pre><p>i 值依次为：0,1,2,3,4,5,6,7,8,9</p><p>在不在乎循环计数器顺序的情况下，我们可以这样：</p><pre class="brush: c; gutter: true">for( i = 10;  i--; ) { ... }</pre><p>i 值依次为: 9,8,7,6,5,4,3,2,1,0,而且循环要更快</p><p>这种方法是可行的，因为它是用更快的i&#8211;作为测试条件的，也就是说“i是否为非零数，如果是减一，然后继续”。相对于原先的代码，处理器不得不“把i减去10，结果是否为非零数，如果是，增加i，然后继续”，在紧密循环(tight loop)中，这会产生显著的区别。<br>这种语法看起来有一点陌生，却完全合法。循环中的第三条语句是可选的（无限循环可以写成这样for(;;)）,下面的写法也可以取得同样的效果：</p><pre class="brush: c; gutter: true">for(i = 10;  i;  i--){}</pre><p>或者:</p><pre class="brush: c; gutter: true">for(i = 10;  i != 0;  i--){}</pre><p>我们唯一要小心的地方是要记住循环需要停止在0（如果循环是从50-80，这样做就不行了），而且循环的计数器为倒计数方式。</p><p>另外，我们还可以把计数器分配到寄存器上，可以产生更为有效的代码。这种将循环计数器初始化成循环次数，然后递减到零的方法，同样适用于while和do语句。</p><h2>混合循环/ Loop jamming</h2><p>在可以使用一个循环的场合，决不要使用两个。但是如果你要在循环中进行大量的工作，超过处理器的指令缓冲区，在这种情况下，使用两个分开的循环可能会更快，因为有可能这两个循环都被完整的保存在指令缓冲区里了。</p><pre class="brush: c; gutter: true">//原先的代码for(i = 0; i &lt; 100; i++){    stuff();}for(i = 0; i &lt; 100; i++){    morestuff();}        //更好的做法for(i = 0; i &lt; 100; i++){    stuff();    morestuff();}</pre><h2>函数循环 / Function Looping</h2><p>调用函数的时候，在性能上就会付出一定的代价。不光要改变程序指针，还要将那些正在使用的变量压入堆栈，分配新的变量空间。为了提高程序的效率，在程序的函数结构上，有很多工作可以做。保证程序的可读性的同时，还要尽量控制程序的大小。<br>如果一个函数在一个循环中被频繁调用，就可以考虑将这个循环放在函数的里面，这样可以免去重复调用函数的负担，比如：</p><pre class="brush: c; gutter: true">for(i = 0 ; i &lt; 100 ; i++) {     func(t,i); }void func(int w, d) {     lots of stuff. }</pre><p>可以写成：</p><pre class="brush: c; gutter: true">func(t);void func(w) {     for(i = 0; i &lt; 100; i++) {         //lots of stuff.     } }</pre><h2>展开循环 / Loop unrolling</h2><p>为了提高效率，可以将小的循环解开，不过这样会增加代码的尺寸。循环被拆开后，会降低循环计数器更新的次数，减少所执行的循环的分支数目。如果循环只重复几次，那它完全可以被拆解开，这样，由循环所带来的额外开销就会消失。</p><p>比如:</p><pre class="brush: c; gutter: true">for(i = 0; i &lt; 3; i++){     something(i);}//更高效的方式：something(0);something(1);something(2);</pre><p>因为在每次的循环中，i 的值都会增加，然后检查是否有效。编译器经常会把这种简单的循环解开，前提是这些循环的次数是固定的。对于这样的循环：</p><pre class="brush: c; gutter: true">for(i = 0; i &lt;  limit; i++) { ... }</pre><p>就不可能被拆解，因为我们不知道它循环的次数到底是多少。不过，将这种类型的循环拆解开并不是不可能的。</p><p>与简单循环相比，下面的代码的长度要长很多，然而具有高得多的效率。选择8作为分块大小，只是用来演示，任何合适的长度都是可行的。例子中，循环的成立条件每八次才被检验一次，而不是每次都要检验。如果需要处理的数组的大小是确定的，我们就可以使用数组的大小作为分块的大小（或者是能够整除数组长度的数值）。不过，分块的大小跟系统的缓存大小有关。</p><pre class="brush: c; gutter: true">#include&lt;stdio.H&gt; #define BLOCKSIZE (8) <p>int main(void)<br>{     int i = 0;<br>    int limit = 33;  /* could be anything */<br>    int blocklimit;</p><pre><code>/* The limit may not be divisible by BLOCKSIZE,   go as near as we can first, then tidy up. */ blocklimit = (limit / BLOCKSIZE) * BLOCKSIZE;/* unroll the loop in blocks of 8 */ while(i &amp;lt; blocklimit) {     printf(&amp;quot;process(%d)\n&amp;quot;, i);     printf(&amp;quot;process(%d)\n&amp;quot;, i+1);     printf(&amp;quot;process(%d)\n&amp;quot;, i+2);     printf(&amp;quot;process(%d)\n&amp;quot;, i+3);     printf(&amp;quot;process(%d)\n&amp;quot;, i+4);     printf(&amp;quot;process(%d)\n&amp;quot;, i+5);     printf(&amp;quot;process(%d)\n&amp;quot;, i+6);     printf(&amp;quot;process(%d)\n&amp;quot;, i+7);     /* update the counter */     i += 8; } /*  * There may be some left to do. * This could be done as a simple for() loop,  * but a switch is faster (and more interesting)  */ if( i &amp;lt; limit ) {     /* Jump into the case at the place that will allow     * us to finish off the appropriate number of items.      */     switch( limit - i )     {         case 7 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 6 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 5 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 4 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 3 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 2 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 1 : printf(&amp;quot;process(%d)\n&amp;quot;, i);     }} return 0;</code></pre><p>}</p></pre><p></p><p>&nbsp;</p><h2>计算非零位的个数 / counting the number of bits set</h2><p>例1：测试单个的最低位，计数，然后移位。</p><pre class="brush: c; gutter: true">//example1int countbit1(uint n){    int bits = 0;    while (n != 0) {        if(n &amp; 1) bits++;            n &gt;&gt;= 1;    }      return bits;}</pre><p>例2：先除4，然后计算被4处的每个部分。循环拆解经常会给程序优化带来新的机会。</p><pre class="brush: c; gutter: true">//example - 2int countbit2(uint n){    int bits = 0;    while (n != 0) {        if (n &amp; 1) bits++;        if (n &amp; 2) bits++;        if (n &amp; 4) bits++;        if (n &amp; 8) bits++;            n &gt;&gt;= 4;    }    return bits;}</pre><h2>尽早地退出循环 / Early loop breaking</h2><p>通常没有必要遍历整个循环。举例来说，在数组中搜索一个特定的值，我们可以在找到我们需要值之后立刻退出循环。下面的例子在10000个数字中搜索-99。</p><pre class="brush: c; gutter: true">found = FALSE; for(i=0;i&lt;10000;i++) {     if(list[i] == -99) {          found = TRUE;     } } if(found) printf(&quot;Yes, there is a -99. Hooray!\n&quot;);</pre><p>这样做是可行的，但是不管这个被搜索到的项目出现在什么位置，都会搜索整个数组。跟好的方法是，再找到我们需要的数字以后，立刻退出循环。</p><pre class="brush: c; gutter: true">found = FALSE; for(i = 0; i &lt; 10000; i++) {     if( list[i] == -99 ) {         found = TRUE;         break;     } } if( found ) printf(&quot;Yes, there is a -99. Hooray!\n&quot;);</pre><p>如果数字出现在位置23上，循环就会终止，忽略剩下的9977个。</p><h2>函数设计 / Function Design</h2><p>保持函数短小精悍，是对的。这可以使编译器能够跟高效地进行其他的优化，比如寄存器分配。</p><h2>调用函数的开销 / Function call overhead</h2><p>对处理器而言，调用函数的开销是很小的，通常，在被调用函数所进行的工作中，所占的比例也很小。能够使用寄存器传递的函数参数个数是有限制的。这些参数可以是整型兼容的（char,short,int以及float都占用一个字），或者是4个字以内的结构体（包括2个字的double和long long）。假如参数的限制是4，那么第5个及后面的字都会被保存到堆栈中。这会增加在调用函数是存储这些参数的，以及在被调用函数中恢复这些参数的代价。</p><pre class="brush: c; gutter: true">int f1(int a, int b, int c, int d) {     return a + b + c + d;}int g1(void) {    return f1(1, 2, 3, 4);}int f2(int a, int b, int c, int d, int e, int f) {    return a + b + c + d + e + f;}ing g2(void) {    return f2(1, 2, 3, 4, 5, 6);}</pre><p>g2函数中，第5、6个参数被保存在堆栈中，在f2中被恢复，每个参数带来2次内存访问。</p><h2>最小化参数传递的开销 / Minimizing parameter passing overhead</h2><p>为了将传递参数给函数的代价降至最低，我们可以：<br>尽可能确保函数的形参不多于四个，甚至更少，这样就不会使用堆栈来传递参数。<br>如果一个函数形参多于四个，那就确保在这个函数能够做大量的工作，这样就可以抵消由传递堆栈参数所付出的代价。<br>用指向结构体的指针作形参，而不是结构体本身。<br>把相关的参数放到一个结构里里面，然后把它的指针传给函数，可以减少参数的个数，增加程序的可读性。<br>将long类型的参数的个数降到最小，因为它使用两个参数的空间。对于double也同样适用。<br>避免出现参数的一部分使用寄存器传输，另一部分使用堆栈传输的情况。这种情况下参数将被全部压到堆栈里。<br>避免出现函数的参数个数不定的情况。这种情况下，所有参数都使用堆栈。</p><h2>叶子函数 / Leaf functions</h2><p>如果一个函数不再调用其他函数，这样的函数被称为叶子函数。在许多应用程序中，大约一半的函数调用是对叶子函数的调用。叶子函数在所有平台上都可以得到非常高效的编译，因为他们不需要进行参数的保存和恢复。在入口压栈和在出口退栈的代价，跟一个足够复杂的需要4个或者5个参数的叶子函数所完成的工作相比，是非常小的。如果可能的话，我们就要尽量安排经常被调用的函数成为叶子函数。函数被调用的次数可以通过模型工具（profiling facility）来确定。这里有几种方法可以确保函数被编译成叶子函数：</p><ul><li>不调用其他函数：包括那些被转换成调用C语言库函数的运算，比如除法、浮点运算。</li><li>使用关键字__inline修饰小的函数。</li></ul><h2>内联函数 / Inline functions</h2><p>对于所有调试选项，内嵌函数是被禁止的。使用inline关键字修饰函数后，跟普通的函数调用不同，代码中对该函数的调用将会被函数体本身代替。这会使代码更快，另一方面它会影响代码的长度，尤其是内嵌函数比较大而且经常被调用的情况下。</p><pre class="brush: c; gutter: true">__inline int square(int x) {    return x * x;}double length(int x, int y){    return sqrt(square(x) + square(y));}</pre><p>使用内嵌函数有几个优点：</p><ul><li>没有调用函数的开销。</li></ul><p>因为函数被直接代替，没有任何额外的开销，比如存储和恢复寄存器。</p><ul><li>更低的参数赋值开销。</li></ul><p>参数传递的开销通常会更低，因为它不需要复制变量。如果其中一些参数是常量，编译器还可以作进一步的优化。</p><p>内嵌函数的缺点是如果函数在许多地方被调用，将会增加代码的长度。长度差别的大小非常依赖于内嵌函数的大小和调用的次数。</p><p>仅将少数关键函数设置成内嵌函数是明智的。如果设置得当，内嵌函数可以减少代码的长度，一次函数调用需要一定数量的指令，但是，使用优化过的内嵌函数可以编译成更少的指令。</p><h2>使用查找表 / Using Lookup Tables</h2><p>有些函数可以近似成查找表，这样可以显著的提高效率。查找表的精度一般比计算公式的精度低，不过在大多数程序中，这种精度就足够了。<br>许多信号处理软件（比如MODEM调制软件）会大量的使用sin和cos函数，这些函数会带来大量的数学运算。对于实时系统来说，精度不是很重要，sin/cos查找表显得更加实用。使用查找表的时候，尽量将相近的运算合并成一个查找表，这样要比使用多个查找表要更快和使用更少的空间。</p><h2>浮点运算 / Floating-Point Arithmetic</h2><p>尽管浮点运算对于任何处理器来讲都是很费时间的，有的时候，我们还是不得不用到浮点运算，比方说实现信号处理。尽管如此，编写浮点运算代码的时候，我们要牢记：</p><ul><li>浮点除法是慢的</li></ul><p>除法要比加法或者乘法慢两倍，我们可以把被一个常数除的运算写成被这个数的倒数乘（比如，x=x/3.0写成x=x*(1.0/3.0)）。倒数的计算在编译阶段就被完成。</p><ul><li>使用float代替double</li></ul><p>Float型变量消耗更少的内存和寄存器，而且因为它的低精度所以具有更高的效率。在精度足够的情况下，就要使用float。</p><ul><li>不要使用先验函数（transcendental functions），</li></ul><p>先验函数（比如sin，cos，log）是通过使用一系列的乘法和加法实现的，所以这些运算会比普通的乘法慢10倍以上。</p><ul><li>简化浮点表达式</li></ul><p>编译器在整型跟浮点型混合的运算中不会进行太多的优化。比如3 * (x / 3) 不会被优化成x，因为浮点运算通常会导致精度的降低，甚至表达式的顺序都是重要的： (a + b) 　　  + c 不等于 a + (b + c)。因此，进行手动的优化是有好处的。</p><p>不过，在特定的场合下，浮点运算的效率达不到指定的水平，这种情况下，最好的办法可能是放弃浮点运算，转而使用定点运算。当变量的变化范围足够的小，定点运算要比浮点运算精度更高、速度更快。</p><h2>其他的技巧 / Misc tips</h2><ul><li>一般情况下，可以用存储空间换取时间。你可以缓存那些经常用到的数据，而不是每次都重新计算、或者重新装载。比如sin/cos表，或者伪随机数的表（如果你不是真的需要随机数，你可以在开始的时候计算1000个，在随后的代码中重复利用就是了）</li><li>尽量少的使用全局变量。</li><li>将一个文件内部的变量声明成静态的，除非它有必要成为全局的。</li><li>不要使用递归。递归可以使代码非常整齐和美观，但会产生大量的函数调用和开销。</li><li>访问单维数组要比多维数组快</li><li>使用#defined宏代替经常用到的小函数。</li></ul><hr><h2>引用/References</h2><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5hcm0uY29tL3BkZnMvREFJMDAzNEFfZWZmaWNpZW50X2MucGRm" title="http://www.arm.com/pdfs/DAI0034A_efficient_c.pdf">Writing Efficient C for ARM<i class="fa fa-external-link"></i></span><ul><li>Document number: ARM DAI 0034A</li><li>Issued: January 1998</li><li>Copyright Advanced RISC Machines Ltd. (ARM) 1998</li></ul></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5yZGR2cy5jb20vRmFzdGVyQy8=" title="http://www.rddvs.com/FasterC/">Richard&#8217;s C Optimization page<i class="fa fa-external-link"></i></span> OR: How to make your C, C++ or Java program run faster with little effort.</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50bGRwLm9yZy9MRFAvTEcvaXNzdWU3MS9qb3NoaS5odG1s" title="http://www.tldp.org/LDP/LG/issue71/joshi.html">Code Optimization Using the GNU C Compiler<i class="fa fa-external-link"></i></span> By Rahul U Joshi.</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcy5wcmluY2V0b24uZWR1L3NvZnR3YXJlL2xjYy9kb2MvbGludXguaHRtbA==" title="http://www.cs.princeton.edu/software/lcc/doc/linux.html">Compile C Faster on Linux<i class="fa fa-external-link"></i></span> [Christopher W. Fraser (Microsoft Research), David R. Hanson (Princeton University)]</li><li>CODE OPTIMIZATION &#8211; COMPILER [<span class="exturl" data-url="aHR0cDovL3d3dy5pYmlibGlvLm9yZy9wdWIvbGFuZ3VhZ2VzL2ZvcnRyYW4vY2gxLTEwLmh0bWw=" title="http://www.ibiblio.org/pub/languages/fortran/ch1-10.html">1<i class="fa fa-external-link"></i></span>] [<span class="exturl" data-url="aHR0cDovL3d3dy5pYmlibGlvLm9yZy9wdWIvbGFuZ3VhZ2VzL2ZvcnRyYW4vY2gxLTkuaHRtbA==" title="http://www.ibiblio.org/pub/languages/fortran/ch1-9.html">2<i class="fa fa-external-link"></i></span>][Thanks to Craig Burley for the excellent comments. Thanks to Timothy Prince for the note on architectures with Instruction Level Parallelism].</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb3lvdGVndWxjaC5jb20vYWNvdmVhLw==" title="http://www.coyotegulch.com/acovea/">An Evolutionary Analysis of GNU C Optimizations<i class="fa fa-external-link"></i></span> [Using Natural Selection to Investigate Software Complexities by Scott Robert Ladd. Updated: 16 December 2003]</li></ul><h2>其他网络资源 / Other URLs</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy54czRhbGwubmwvfmVrb25pam4vbG9vcHkuaHRtbA==" title="http://www.xs4all.nl/~ekonijn/loopy.html">http://www.xs4all.nl/~ekonijn/loopy.html<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5wdWJsaWMuYXN1LmVkdS9+c3NoZXR0eS9PcHRpbWl6aW5nX0NvZGVfTWFudWFsLmRvYw==" title="http://www.public.asu.edu/~sshetty/Optimizing_Code_Manual.doc">http://www.public.asu.edu/~sshetty/Optimizing_Code_Manual.doc<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5hYmFybmV0dC5kZW1vbi5jby51ay90dXRvcmlhbC5odG1s" title="http://www.abarnett.demon.co.uk/tutorial.html">http://www.abarnett.demon.co.uk/tutorial.html<i class="fa fa-external-link"></i></span></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>本文翻译自： <span class="exturl" data-url="aHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vQXJ0aWNsZXMvNjE1NC9Xcml0aW5nLUVmZmljaWVudC1DLWFuZC1DLUNvZGUtT3B0aW1pemF0aW9u" title="http://www.codeproject.com/Articles/6154/Writing-Efficient-C-and-C-Code-Optimization">codeproject<i class="fa fa-external-link"></i></span>，感谢codingwu的整理，转载请注明<span class="exturl" data-url="aHR0cDovL2Nvb2xzaGVsbC5pbmZvLzIwMTQvMTIvYy1jb2RlLW9wdC5odG1s" title="http://coolshell.info/2014/12/c-code-opt.html">出处<i class="fa fa-external-link"></i></span>。</p>]]></content>
    
    <summary type="html">
    
      虽然对于优化 C 代码有很多有效的指导方针，但是对于彻底地了解编译器和你工作的机器依然无法取代，通常，加快程序的速度也会加大代码量。这些增加的代码也会影响一个程序的复杂度和可读性，这是不可接受的，比如你在一些小型的设备上编程，例如：移动设备、PDA……，这些有着严格的内存限制，于是，在优化的座右铭是:写代码在内存和速度都应该优化。
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>C 语言高级编程指南</title>
    <link href="http://miaopei.github.io/2016/07/03/Program-C/c-advaced-programming/"/>
    <id>http://miaopei.github.io/2016/07/03/Program-C/c-advaced-programming/</id>
    <published>2016-07-03T02:14:50.000Z</published>
    <updated>2019-06-14T06:43:47.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整形溢出和提升"><a href="#整形溢出和提升" class="headerlink" title="整形溢出和提升"></a>整形溢出和提升</h2><p>大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,</p><a id="more"></a><p>你觉得输出结果是什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(i)) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个变量转换成无符号整形时,i的值不再是-1,而是 size_t的最大值,因为sizeof操作返回的是一个 size_t类型的无符号数。</p><p>在C99/C11标准里写道:</p><blockquote><p>“If the operand that has unsigned integer type has rank greater or<br>equal to the rank of the type of the other operand, then the operand<br>with signed integer type is converted to the type of the operand with<br>unsigned integer type.”</p></blockquote><p>在 C 标准里面 size_t 至少是一个 16 位的无符号整数, 对于给定的架构 size_t 一般对应 long, 所以sizeof（int）和 size_t 至少相等, 这就带来了可移植性的问题, C 标准没有定义 short, int, long, longlong 的大小, 只是说明了他们的最小长度, 对于 x86_64 架构, long 在Linux下是 64 位, 而在 64 位 Windows 下是 32 位。一般的方法是采用固定长度的类型比如定义在 C99 头文件stdint.h中的uint16_t, int32_t, uint_least16_t, uint_fast16_t 等。</p><p>如果 int 可以表示原始类型的所有值,那么这个操作数会转换成 int, 否则他会转换成 unsigned int。下面这个函数在 32 位平台返回 65536, 但是在 16 位系统返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> sum()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> a = <span class="number">65535</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于char 类型到底是 signed 还是 unsigned 取决于硬件架构和操作系统,通常<br>由特定平台的 ABI(Application Binary Interface) 指定,如果是 signed char,下面的代码输出-128 和-127,否则输出 128,129(x86 架构)。</p><pre><code>char c = 128;char d = 129;printf(&quot;%d,%d\n&quot;,c,d);</code></pre><hr><h2 id="内存管理和分配"><a href="#内存管理和分配" class="headerlink" title="内存管理和分配"></a>内存管理和分配</h2><p>malloc 函数分配制定字节大小的内存,对象未被初始化,如果 size 是 0 取<br>决与系统实现。malloc(0) 返回一个空指针或者 unique pointer, 如果 size 是表达式的运算结果, 确保没有整形溢出。</p><blockquote><p>“If the size of the space requested is 0, the behavior is<br>implementation- defined: the value returned shall be either a null<br>pointer or a unique pointer.”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> computed_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elem_size &amp;&amp; num &gt; SIZE_MAX / elem_size) &#123;</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"overflow"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">computed_size = elem_size*num;</span><br></pre></td></tr></table></figure><p>malloc 不会给分配的内存初始化，如果要对新分配的内存初始化，可以用 calloc 代替 malloc, 一般情况下给序列分配相等大小的元素时, 用 calloc 来代替用表达式计算大小, calloc 会把内存初始化为 0。</p><p>realloc 用来对已经分配内存的对象改变大小,如果新的 size 更大,额外的空间<br>没 有 被 初 始 化 , 如 果 提 供 给 realloc 的 指 针 是 空 指 针 , realloc 就 等 效 于malloc,如果原指针非空而 new size是0,结果依赖于操作系统的具体实现。</p><blockquote><p>“In case of failure realloc shall return NULL and leave provided memory<br>object intact. Thus it is important not only to check for integer<br>overflow of size argument, but also to correctly handle object size if<br>realloc fails.”</p></blockquote><details><summary>下面这段代码可以带你领会 malloc, calloc，realloc, free 的用法：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_OK            0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_NULL_ERROR    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_SIZE_ERROR    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_ALLOC_ERROR   3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_vector</span><span class="params">(struct <span class="built_in">vector</span> *vc, <span class="keyword">size_t</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_NULL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vc-&gt;data = <span class="number">0</span>;</span><br><span class="line">    vc-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for integer and SIZE_MAX overflow */</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || SIZE_MAX / num &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_SIZE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vc-&gt;data = <span class="built_in">calloc</span>(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calloc faild */</span></span><br><span class="line">    <span class="keyword">if</span> (vc-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_ALLOC_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vc-&gt;size = num * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">return</span> VECTOR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">grow_vector</span><span class="params">(struct <span class="built_in">vector</span> *vc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *newptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> newsize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_NULL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* check for integer and SIZE_MAX overflow */</span></span><br><span class="line">    <span class="keyword">if</span> (vc-&gt;size == <span class="number">0</span> || SIZE_MAX / <span class="number">2</span> &lt; vc-&gt;size) &#123;</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">   <span class="keyword">return</span> VECTOR_SIZE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    newsize = vc-&gt;size * <span class="number">2</span>;</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(vc-&gt;data, newsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* realloc faild; vector stays intact size was not changed */</span></span><br><span class="line">    <span class="keyword">if</span> (newptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_ALLOC_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* upon success; update new address and size */</span></span><br><span class="line">    vc-&gt;data = newptr;</span><br><span class="line">    vc-&gt;size = newsize;</span><br><span class="line">    <span class="keyword">return</span> VECTOR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><hr><h2 id="避免重大错误"><a href="#避免重大错误" class="headerlink" title="避免重大错误"></a>避免重大错误</h2><ol><li><p>使用未初始化的变量</p><p>C 语言要求所有变量在使用之前要初始化，使用未初始化的变量会造成为定义的行为，这和 C++ 不同，C++ 保证所有变量在使用之前都得到初始化，Java <strong>尽量保证</strong> 变量使用前的得到初始化，如类基本数据成员会被初始化为默认值。</p></li><li><p>free 错误</p><p>对空指针调用 free, 对不是由 malloc family 函数分配的指针调用 free,或者对已经调用 free 的指针再次调用 free。</p><p>一开始初始化指针为 NULL 可以减少错误, GCC 和 Clang 编译器有 -Wuninitialized 选项来对未初始化的变量显示警告信息, 另外不要将同一个指针用于静态变量和动态变量。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nullfree</span><span class="params">(<span class="keyword">void</span> **pptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = *pptr;</span><br><span class="line">    assert(ptr != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    *pptr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>对空指针解引用，数组越界访问</p><p>对 NULL 指针或者 free’d 内存解引用，数组越界访问，是很明显的错误，为了消除这种错误，一般的做法就是增加数组越界检查的功能，比如 Java 里的 array 就有下标检查的功能，但是这样会带来严重的性能代价，我们要修改 ABI（application binary interface），让每个指针都跟随着它的范围信息，在数值计算中 cost is terrible。</p></li><li><p>违反类型规则</p><p>把 <code>int*</code> 指针 cast 成 <code>float*</code>，然后对它解引用，在 C 里面会引发 undefined behavior，C 规定这种类型的转换需要使用 memset，C++ 里面有个 reinterpret_cast 函数用于无关类型之间的转换，<code>reinterpret_cast &lt;new_type&gt; (expression)</code></p></li></ol><hr><h2 id="防止内存泄漏"><a href="#防止内存泄漏" class="headerlink" title="防止内存泄漏"></a>防止内存泄漏</h2><p>内存泄漏发生在程序不再使用的动态内存没有得到释放，这需要我们掌握动态分配对象的作用域，尤其是什么时候该调用 free 来释放内存，常用的几种方法如下：</p><ol><li>在程序启动的时候分配</li></ol><p>在程序启动的时候分配需要的 heap memory，程序退出时把释放的任务交给操作系统，这种方法一般适用于程序运行后马上退出的那种。</p><ol start="2"><li><p>使用变长数组（VLA）</p><p> 如果你需要一块变长大小的空间并且作用域在函数中，变长数组可以帮到你，但是也有一个限制，一个函数中的变长数组内存大小一般不超过几百字节，这个数字 C 标准没有明确的定义，最好是把内存分配到栈上，在栈上允许分配的最大 VLA 内存是 SIZE_MAX，掌握目标平台的栈大小可以有效的防止栈溢出。</p></li><li><p>使用引用计数</p><p> 引用计数是一个很好的管理内存的方法，特别是当你不希望自己定义的对象被复制时，每一次赋值把引用计数加 1, 每次失去引用就把引用计数减1,当引用计数等于0时，以为的对象已经不再需要了，我们需要释放对象占用的内存，由于C不提供自动的析构函数，我们必须手动释放内存，看一个例子：</p></li></ol><details><summary>例子：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REF_OBJ 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_obj_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">uint16_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_obj_t</span> <span class="title">references</span>[<span class="title">MAX_REF_OBJ</span>];</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> reference_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create memory object and return handle */</span></span><br><span class="line"><span class="keyword">uint16_t</span> create(<span class="keyword">size_t</span> size)&#123;</span><br><span class="line"><span class="keyword">if</span> (reference_count &gt;= MAX_REF_OBJ)</span><br><span class="line">        <span class="keyword">return</span> RC_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size)&#123;</span><br><span class="line">      <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            references[reference_count].ptr = ptr;</span><br><span class="line">            references[reference_count].count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> reference_count++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> RC_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get memory object and increment reference counter */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">retain</span><span class="params">(<span class="keyword">uint16_t</span> handle)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(handle &lt; reference_count &amp;&amp; handle &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        references[handle].count++;</span><br><span class="line">        <span class="keyword">return</span> references[handle].ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* decrement reference counter */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">uint16_t</span> handle)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"release\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(handle &lt; reference_count &amp;&amp; handle &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mem_obj_t</span> *<span class="title">object</span> = &amp;<span class="title">references</span>[<span class="title">handle</span>];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object-&gt;count &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"released\n"</span>);</span><br><span class="line">            <span class="built_in">free</span>(object-&gt;ptr);</span><br><span class="line">            reference_count--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"decremented\n"</span>);</span><br><span class="line">            object-&gt;count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>C++ 标准库有个 <code>auto_ptr</code> 智能指针，能够自动释放指针所指对象的内存，C++ boost 库有个<code>boost::shared_ptr</code> 智能指针，内置引用计数，支持拷贝和赋值，看下面这个例子：</p><blockquote><p> “Objects of shared_ptr types have the ability of taking ownership of a pointer and share that ownership: once they take ownership, the group of owners of a pointer become responsible for its deletion when the last one of them releases that ownership.”</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Basic useage</span></span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count of p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(p1); <span class="comment">// or p2 = p1;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count of p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    *p1 = <span class="number">999</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p2: "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p2.reset();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count of p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>内存池，有利于减少内存碎片，看下面这个例子：</li></ol><details><summary>例子：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_pool_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* ptr;<span class="comment">//指向内存池起始地址</span></span><br><span class="line">    <span class="keyword">size_t</span> size;<span class="comment">//内存池大小</span></span><br><span class="line">    <span class="keyword">size_t</span> used;<span class="comment">//已用内存大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//create memory pool</span></span><br><span class="line"><span class="function">struct mem_pool_t* <span class="title">create_pool</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">mem_pool_t</span>* pool=<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(struct <span class="keyword">men_pool_t</span>));</span><br><span class="line">    <span class="keyword">if</span>(pool!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">void</span>* mem=<span class="built_in">calloc</span>(<span class="number">1</span>,size);</span><br><span class="line">        <span class="keyword">if</span>(mem!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pool-&gt;ptr=mem;</span><br><span class="line">            pool-&gt;size=size;</span><br><span class="line">            pool-&gt;used=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> pool;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate memory from pool</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">pool_alloc</span><span class="params">(<span class="keyword">mem_pool_t</span>* pool,<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pool=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> bytes_left=pool-&gt;size-pool-&gt;used;</span><br><span class="line">    <span class="keyword">if</span>(size&amp;&amp;size&lt;=bytes_left)&#123;</span><br><span class="line">        <span class="keyword">void</span>* mem=pool-&gt;ptr+pool-&gt;used;</span><br><span class="line">        pool-&gt;used+=size;</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">／／release memory of the pool</span><br><span class="line"><span class="keyword">void</span> pool_free(<span class="keyword">mem_pool_t</span>* pool)&#123;</span><br><span class="line"><span class="keyword">if</span>(pool!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(pool-&gt;ptr);</span><br><span class="line"><span class="built_in">free</span>(pool);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ol start="5"><li><p>垃圾回收机制</p><p>引用计数采用的方法是当内存不再需要时得到手动释放，垃圾回收发生在内存分配失败或者内存到达一定的水位（watermarks），实现垃圾回收最简单的一个算法是 MARK AND SWEEP 算法，该算法的思路是遍历所有动态分配对象的内存，标记那些还能继续使用的，回收那些没有被标记的内存。</p><p>Java 采用的垃圾回收机制就更复杂了，思路也是回收那些不再使用的内存，JAVA 的垃圾回收和C++ 的析构函数又不一样，C++ 保证对象在使用之前得到初始化，对象超出作用域之后内存得到释放，而 JAVA 不能保证对象一定被析构。 </p></li></ol><hr><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>我们一般的概念里指针和数组名是可互换的，但是在编译器里他们被不同的对待，当我们说一个对象或者表达式具有某种类型的时候我们一般是说这个对象是个左值（lvalue），当对象不是 const 的时候，左值是可以修改的，比如对象是复制操作符的左参数，而数组名是一个 const 左值，指向地一个元素的 const 指针，所以你不能给数组名赋值或者意图改变数组名，如果表达式是数组类型，数组名通常转换成指向地一个元素的指针。</p><p>但是也有例外，什么情况下数组名不是一个指针呢？</p><ol><li>当它是 sizeof 操作符的操作数时，返回数组占的内存字节数</li><li>当它是取地址操作 <code>&amp;</code> 的操作数时，返回一个数组的地址</li></ol><p>看下面这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">short</span> *pa;</span><br><span class="line"><span class="keyword">short</span> (*px)[];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pa = a;</span><br><span class="line">    px = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%p; pa:%p; px:%p\n"</span>, a, pa, px);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[1]:%i; pa[1]:%i (*px)[1]:%i\n"</span>, a[<span class="number">1</span>], pa[<span class="number">1</span>],(*px)[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a 是一个 short 类型数组，pa 是一个指向 short 类型的指针，px 呢？</p><ul><li><p>px 是一个指向数组类型的指针，在 a 被赋值给 pa 之前，他的值被转换成一个指向数组第一个元素的指针，下面那个 a 却没有转换，因为遇到的是 <code>&amp;</code> 操作符。</p></li><li><p>数组下标 <code>a[1]</code> 等价于 <code>(a+1)</code>, 和 <code>p[1]</code> 一样，也指向 <code>*(p+1)</code>，但是两者还是有区别的，a 是一个数组，它实际上存储的是第一个元素的地址，所以数组 a 是用来定位第一个元素的，而 pa 不一样，它就是一个指针，不是用来定位的。</p></li></ul><p>再比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">c=&amp;a[<span class="number">0</span>];<span class="comment">//c是指向数组a地一个元素的指针</span></span><br><span class="line">c=a;<span class="comment">//a自动转换成指向第一个元素的指针，实际上是指针拷贝</span></span><br><span class="line">b=a;<span class="comment">//非法的，你不能用赋值符把一个数组的所有元素赋给另一个数组</span></span><br><span class="line">a=c;<span class="comment">//非法的，你不能修改const指针的值</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整形溢出和提升&quot;&gt;&lt;a href=&quot;#整形溢出和提升&quot; class=&quot;headerlink&quot; title=&quot;整形溢出和提升&quot;&gt;&lt;/a&gt;整形溢出和提升&lt;/h2&gt;&lt;p&gt;大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,&lt;/p&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>CPlusPlus 设计模式</title>
    <link href="http://miaopei.github.io/2016/06/28/Program-C/cplus-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://miaopei.github.io/2016/06/28/Program-C/cplus-设计模式/</id>
    <published>2016-06-28T02:14:50.000Z</published>
    <updated>2019-06-14T06:11:54.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p>定义一个单例类：</p><ol><li>私有化它的构造函数，以防止外界创建单例类的对象；</li><li>使用类的私有静态指针变量指向类的唯一实例；</li><li>使用一个公有的静态方法获取该实例。</li></ol></blockquote><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><blockquote><p>即第一次调用该类实例的时候才产生一个新的该类实例，并在以后仅返回此实例。</p><p>需要用锁，来保证其线程安全性：原因：多个线程可能进入判断是否已经存在实例的 if 语句，从而non thread safety.</p><p>使用double-check来保证thread safety.但是如果处理大量数据时，该锁才成为严重的性能瓶颈。</p></blockquote><details><summary>1. 静态成员实例的懒汉模式：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)</span><br><span class="line">    &#123;</span><br><span class="line">        Lock();<span class="comment">//借用其它类来实现，如boost</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        UnLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>2. 内部静态实例的懒汉模式：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonInside</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SingletonInside* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Lock(); <span class="comment">// not needed after C++0x</span></span><br><span class="line">        <span class="keyword">static</span> SingletonInside instance;</span><br><span class="line">        UnLock(); <span class="comment">// not needed after C++0x</span></span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SingletonInside()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><blockquote><p>即无论是否调用该类的实例，在程序开始时就会产生一个该类的实例，并在以后仅返回此实例。</p><p>由静态初始化实例保证其线程安全性，WHY？因为静态实例初始化在程序开始时<strong>进入主函数之前就由主线程以单线程方式完成了初始化</strong>，不必担心多线程问题。</p><p>故在性能需求较高时，应使用这种模式，避免频繁的锁争夺。</p></blockquote><details><summary>饿汉模式：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonStatic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> SingletonStatic* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SingletonStatic* m_instance;</span><br><span class="line">    SingletonStatic()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部初始化 before invoke main</span></span><br><span class="line"><span class="keyword">const</span> SingletonStatic* SingletonStatic::m_instance = <span class="keyword">new</span> SingletonStatic;</span><br></pre></td></tr></table></figure></details><p><strong>m_pInstance 指向的空间什么时候释放呢？更严重的问题是，该实例的析构函数什么时候执行？</strong></p><details><summary>单例模式 - 线程安全</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Singleton() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton ctor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singleton() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton dtor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Garbo</span></span></span><br><span class="line"><span class="class">    &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        ~Garbo()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::m_pInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Garbo dtor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> Garbo garbo; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Singleton::Garbo Singleton::garbo;  <span class="comment">// 一定要初始化，不然程序结束时不会析构garbo</span></span><br><span class="line">Singleton *Singleton::m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">Singleton *Singleton::GetInstance()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (m_pInstance == <span class="literal">NULL</span>) </span><br><span class="line">        m_pInstance = <span class="keyword">new</span> Singleton;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *p1 = Singleton::GetInstance();</span><br><span class="line">    Singleton *p2 = Singleton::GetInstance();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 == p2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出结果如下：</span></span><br><span class="line">Singleton ctor</span><br><span class="line">p1 == p2</span><br><span class="line">Garbo dtor</span><br><span class="line">Singleton dtor</span><br></pre></td></tr></table></figure></details><p>类 CGarbo 被定义为 CSingleton 的私有内嵌类，以防该类被在其他地方滥用。</p><p>程序运行结束时，系统会调用 CSingleton的 静态成员 Garbo 的析构函数，该析构函数会删除单例的唯一实例。</p><p>使用这种方法释放单例对象有以下特征：</p><ul><li><p>在单例类内部定义专有的嵌套类；</p></li><li><p>在单例类内定义私有的专门用于释放的静态成员；</p></li><li><p>利用程序在结束时析构全局变量的特性，选择最终的释放时机；</p></li><li><p>使用单例的代码不需要任何操作，不必关心对象的释放。</p></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuZmF0ZWRpZXIuY29tLzIwMTUvMDMvMDQvZGVjb3VwbGluZy1ieS11c2luZy1yZWZsZWN0LWFuZC1zaW1wbGUtZmFjdG9yeS1wYXR0ZXJuLWluLWNwcC8=" title="http://blog.fatedier.com/2015/03/04/decoupling-by-using-reflect-and-simple-factory-pattern-in-cpp/">在C++中利用反射和简单工厂模式实现业务模块解耦<i class="fa fa-external-link"></i></span></p></blockquote><p>用一个单独的类来做创造实例的过程，就是工厂。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><details><summary>简单工厂模式基本代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProduct() &#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> :</span> <span class="keyword">public</span> AbstractProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> :</span> <span class="keyword">public</span> AbstractProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProduct* <span class="title">createProduct</span><span class="params">(<span class="keyword">char</span> product)</span> </span>&#123;</span><br><span class="line">        AbstractProduct* ap = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">switch</span>(product) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>: ap = <span class="keyword">new</span> ProductA(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'B'</span>: ap = <span class="keyword">new</span> ProductB(); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Factory* f = <span class="keyword">new</span> Factory();</span><br><span class="line">    AbstractProduct* apa = f-&gt;createProduct(<span class="string">'A'</span>);</span><br><span class="line">    apa-&gt;Operation();  <span class="comment">// ProductA</span></span><br><span class="line"></span><br><span class="line">    AbstractProduct* apb = f-&gt;createProduct(<span class="string">'B'</span>);</span><br><span class="line">    apb-&gt;Operation();  <span class="comment">// ProductB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> apa;</span><br><span class="line">    <span class="keyword">delete</span> apb;</span><br><span class="line">    <span class="keyword">delete</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><img src="/images/imageProgramC/%E7%AE%80%E5%8D%95%E8%BF%90%E7%AE%97%E5%B7%A5%E5%8E%82.png" alt="简单运算工厂"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation <span class="title">createOperate</span><span class="params">(<span class="built_in">string</span> operate)</span> </span>&#123;</span><br><span class="line">        Operation oper = null;</span><br><span class="line">        <span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"+"</span>: oper = <span class="keyword">new</span> OperationAdd(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"-"</span>: oper = <span class="keyword">new</span> OperationSub(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"*"</span>: oper = <span class="keyword">new</span> OperationMul(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"/"</span>: oper = <span class="keyword">new</span> OperationDiv(); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。</p></blockquote><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。</p><p><img src="/images/imageProgramC/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="工厂方法模式结构图"></p><details><summary>工厂方法模式基本代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Product()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteProductA"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteProductB"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">FactoryMethod</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Creator()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreatorA</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreatorB</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Creator* ca = <span class="keyword">new</span> ConcreteCreatorA();</span><br><span class="line">    Product* pa = ca-&gt;FactoryMethod();</span><br><span class="line">    pa-&gt;Operation(); <span class="comment">// ConcreteProductA</span></span><br><span class="line"></span><br><span class="line">    Creator* cb = <span class="keyword">new</span> ConcreteCreatorB();</span><br><span class="line">    Product* pb = cb-&gt;FactoryMethod();</span><br><span class="line">    pb-&gt;Operation(); <span class="comment">// ConcreteProductB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ca;</span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line">    <span class="keyword">delete</span> cb;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>把简单工厂模式中的工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，就变成了一个工厂抽象接口和多个具体生成对象的工厂。</p><p><img src="/images/imageProgramC/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE-01.png" alt="工厂方法模式结构图"></p><p>这样整个工厂和产品体系就没有修改，而只是扩展，符合开放 - 封闭原则。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><img src="/images/imageProgramC/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="抽象工厂模式结构图"></p><details><summary>抽象工厂模式基本代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProductA()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> :</span> <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> :</span> <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProductB()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> :</span> <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> :</span> <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductA* <span class="title">CreateProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductB* <span class="title">CreateProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractFactory()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA1* <span class="title">CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB1* <span class="title">CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA2* <span class="title">CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB2* <span class="title">CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractFactory* af1 = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">    <span class="comment">// 具体工厂创建对应的具体产品</span></span><br><span class="line">    AbstractProductA* apa1 = af1-&gt;CreateProductA();  <span class="comment">// 工厂1创建产品A</span></span><br><span class="line">    apa1-&gt;Operation();  <span class="comment">// ProductA1</span></span><br><span class="line"></span><br><span class="line">    AbstractProductB* apb1 = af1-&gt;CreateProductB();  <span class="comment">// 工厂1创建产品B</span></span><br><span class="line">    apb1-&gt;Operation();  <span class="comment">// ProductB1</span></span><br><span class="line"></span><br><span class="line">    AbstractFactory* af2 = <span class="keyword">new</span> ConcreteFactory2();</span><br><span class="line">    AbstractProductA* apa2 = af2-&gt;CreateProductA();  <span class="comment">// 工厂2创建产品A</span></span><br><span class="line">    apa2-&gt;Operation();  <span class="comment">// ProductA2</span></span><br><span class="line"></span><br><span class="line">    AbstractProductB* apb2 = af2-&gt;CreateProductB();  <span class="comment">// 工厂2创建产品B</span></span><br><span class="line">    apb2-&gt;Operation();  <span class="comment">// ProductB2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> apa1;</span><br><span class="line">    <span class="keyword">delete</span> apa2;</span><br><span class="line">    <span class="keyword">delete</span> af1;</span><br><span class="line">    <span class="keyword">delete</span> apb1;</span><br><span class="line">    <span class="keyword">delete</span> apb2;</span><br><span class="line">    <span class="keyword">delete</span> af2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>抽象工厂函数的优缺点</strong></p><p>优点：</p><ul><li>易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这样就使得改变一个应用的具体工厂变得非常容易，只需要改变具体工厂即可使用不同的产品配置。</li><li>让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂实现分离，不会出现在客户代码中。</li></ul><p>缺点：增加新的产品时需要改动多处代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是
      
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Interview STL</title>
    <link href="http://miaopei.github.io/2016/06/18/Program-C/STL/"/>
    <id>http://miaopei.github.io/2016/06/18/Program-C/STL/</id>
    <published>2016-06-18T02:14:50.000Z</published>
    <updated>2019-06-14T06:13:21.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9ub3RlL2Jsb2IvbWFzdGVyL1NUTC5tZA==" title="https://github.com/huihut/note/blob/master/STL.md">github . huihut/note/STL.md<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdGwv" title="http://www.cplusplus.com/reference/stl/">cplusplus . stl<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLmNwcHJlZmVyZW5jZS5jb20vdy8lRTklQTYlOTYlRTklQTElQjU=" title="http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference . C++ 参考手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sdW1uL2RldGFpbHMvZ2Vlay1zdGwuaHRtbA==" title="http://blog.csdn.net/column/details/geek-stl.html">CSDN专栏：STL学习笔记<i class="fa fa-external-link"></i></span></li></ul><a id="more"></a><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li>容器（containers）</li><li>算法（algorithms）</li><li>迭代器（iterators）</li><li>仿函数（functors）</li><li>配接器（adapters）</li><li>空间配置器（allocator）</li></ul><h2 id="容器（containers）"><a href="#容器（containers）" class="headerlink" title="容器（containers）"></a>容器（containers）</h2><ul><li>序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted）</li><li>关联式容器（associattive containers）</li></ul><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>array是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。</p><p>在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。</p><p>与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。</p><p>零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。</p><p>与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。</p><p>数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">size_t</span> <span class="title">N</span> &gt; <span class="title">class</span> <span class="title">array</span>;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160405225541788" alt></p><h4 id="array-begin"><a href="#array-begin" class="headerlink" title="array::begin"></a>array::begin</h4><p>返回指向数组容器中第一个元素的迭代器。</p><p><img src="https://i.stack.imgur.com/oa3EQ.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; myarray = &#123;<span class="number">2</span>, <span class="number">16</span>, <span class="number">77</span>,<span class="number">34</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myarray.begin(); it != myarray.end(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 2 16 77 34 50</span><br></pre></td></tr></table></figure><h4 id="array-end"><a href="#array-end" class="headerlink" title="array::end"></a>array::end</h4><p>返回指向数组容器中最后一个元素之后的理论元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123; <span class="number">5</span>, <span class="number">19</span>, <span class="number">77</span>, <span class="number">34</span>, <span class="number">99</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> it = myarray.begin(); it != myarray.end(); ++it )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 5 19 77 34 99</span><br></pre></td></tr></table></figure><h4 id="array-rbegin"><a href="#array-rbegin" class="headerlink" title="array::rbegin"></a>array::rbegin</h4><p>返回指向数组容器中最后一个元素的反向迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      reverse_iterator rbegin（）<span class="keyword">noexcept</span>;</span><br><span class="line">const_reverse_iterator rbegin（）<span class="keyword">const</span> <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,4&gt; myarray = &#123;<span class="number">4</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">14</span>&#125; ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 14 80 26 4</span><br></pre></td></tr></table></figure><h4 id="array-rend"><a href="#array-rend" class="headerlink" title="array::rend"></a>array::rend</h4><p>返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,4&gt; myarray = &#123;<span class="number">4</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">14</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 14 80 26 4</span><br></pre></td></tr></table></figure><h4 id="array-cbegin"><a href="#array-cbegin" class="headerlink" title="array::cbegin"></a>array::cbegin</h4><p>返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const_iterator cbegin（）<span class="keyword">const</span> <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123;<span class="number">2</span>, <span class="number">16</span>, <span class="number">77</span>, <span class="number">34</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> it = myarray.cbegin(); it != myarray.cend(); ++it )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;   <span class="comment">// cannot modify *it</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 2 16 77 34 50</span><br></pre></td></tr></table></figure><h4 id="array-cend"><a href="#array-cend" class="headerlink" title="array::cend"></a>array::cend</h4><p>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123; <span class="number">15</span>, <span class="number">720</span>, <span class="number">801</span>, <span class="number">1002</span>, <span class="number">3502</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> it = myarray.cbegin(); it != myarray.cend(); ++it )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;   <span class="comment">// cannot modify *it</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 2 16 77 34 50</span><br></pre></td></tr></table></figure><h4 id="array-crbegin"><a href="#array-crbegin" class="headerlink" title="array::crbegin"></a>array::crbegin</h4><p>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const_reverse_iterator crbegin（）<span class="keyword">const</span> <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,6&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125; ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray backwards:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;   <span class="comment">// cannot modify *rit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray backwards: 60 50 40 30 20 10</span><br></pre></td></tr></table></figure><h4 id="array-crend"><a href="#array-crend" class="headerlink" title="array::crend"></a>array::crend</h4><p>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_reverse_iterator <span class="title">crend</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,6&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125; ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray backwards:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;   <span class="comment">// cannot modify *rit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray backwards: 60 50 40 30 20 10</span><br></pre></td></tr></table></figure><h4 id="array-size"><a href="#array-size" class="headerlink" title="array::size"></a>array::size</h4><p>返回数组容器中元素的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> size_type size（）<span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myints;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of myints:"</span> &lt;&lt; myints.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(myints):"</span> &lt;&lt; <span class="keyword">sizeof</span>(myints) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size of myints: 5</span><br><span class="line">sizeof(myints): 20</span><br></pre></td></tr></table></figure><h4 id="array-max-size"><a href="#array-max-size" class="headerlink" title="array::max_size"></a>array::max_size</h4><p>返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myints;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of myints: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size of myints: "</span> &lt;&lt; myints.max_size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size of myints: 10</span><br><span class="line">max_size of myints: 10</span><br></pre></td></tr></table></figure><h4 id="array-empty"><a href="#array-empty" class="headerlink" title="array::empty"></a>array::empty</h4><p>返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,0&gt; first;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; second;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first "</span> &lt;&lt; (first.empty() ? <span class="string">"is empty"</span> : <span class="string">"is not empty"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second "</span> &lt;&lt; (second.empty() ? <span class="string">"is empty"</span> : <span class="string">"is not empty"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first is empty</span><br><span class="line">second is not empt</span><br></pre></td></tr></table></figure><h4 id="array-operator"><a href="#array-operator" class="headerlink" title="array::operator[]"></a>array::operator[]</h4><p>返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      reference <span class="keyword">operator</span>[] (size_type n);</span><br><span class="line">const_reference <span class="keyword">operator</span>[] (size_type n) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myarray;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign some values:</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        myarray[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print content</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myarray[i];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h4 id="array-at"><a href="#array-at" class="headerlink" title="array::at"></a>array::at</h4><p>返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reference <span class="title">at</span> <span class="params">( size_type n )</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">at</span> <span class="params">( size_type n )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myarray;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign some values:</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        myarray[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print content</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myarray[i];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h4 id="array-front"><a href="#array-front" class="headerlink" title="array::front"></a>array::front</h4><p>返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。<br>在空容器上调用此函数会导致未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reference <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">2</span>, <span class="number">16</span>, <span class="number">77</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"front is: "</span> &lt;&lt; myarray.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"back is: "</span> &lt;&lt; myarray.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 77</span></span><br><span class="line"></span><br><span class="line">  myarray.front() = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray now contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x : myarray ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">front is: 2</span><br><span class="line">back is: 77</span><br><span class="line">myarray now contains: 100 16 77</span><br></pre></td></tr></table></figure><h4 id="array-back"><a href="#array-back" class="headerlink" title="array::back"></a>array::back</h4><p>返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。<br>在空容器上调用此函数会导致未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reference <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">5</span>, <span class="number">19</span>, <span class="number">77</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"front is: "</span> &lt;&lt; myarray.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"back is: "</span> &lt;&lt; myarray.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 77</span></span><br><span class="line"></span><br><span class="line">  myarray.back() = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray now contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x : myarray ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">front is: 5</span><br><span class="line">back is: 77</span><br><span class="line">myarray now contains: 5 19 50</span><br></pre></td></tr></table></figure><h4 id="array-data"><a href="#array-data" class="headerlink" title="array::data"></a>array::data</h4><p>返回指向数组对象中第一个元素的指针。</p><p>由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">value_type* <span class="title">data</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> value_type* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="string">"Test string"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">char</span>,12&gt; charray;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span> (charray.data(),cstr,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; charray.data() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test string</span><br></pre></td></tr></table></figure><h4 id="array-fill"><a href="#array-fill" class="headerlink" title="array::fill"></a>array::fill</h4><p>用val填充数组所有元素，将val设置为数组对象中所有元素的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,6&gt; myarray;</span><br><span class="line"></span><br><span class="line">  myarray.fill(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x : myarray) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 5 5 5 5 5 5</span><br></pre></td></tr></table></figure><h4 id="array-swap"><a href="#array-swap" class="headerlink" title="array::swap"></a>array::swap</h4><p>通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。</p><p>与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="built_in">array</span>&amp; x)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;())))</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; first = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; second = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">  first.swap (second);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x : first) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x : second) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first: 11 22 33 44 55</span><br><span class="line">second: 10 20 30 40 50</span><br></pre></td></tr></table></figure><h4 id="get（array）"><a href="#get（array）" class="headerlink" title="get（array）"></a>get（array）</h4><p>形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> I，<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt; <span class="title">T</span>＆<span class="title">get</span>（<span class="title">array</span> &lt;T，N&gt;＆<span class="title">arr</span>）<span class="title">noexcept</span>;</span> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> I，<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt; <span class="title">T</span> &amp;&amp; <span class="title">get</span>（<span class="title">array</span> &lt;T，N&gt; &amp;&amp; <span class="title">arr</span>）<span class="title">noexcept</span>;</span> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> I，<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt; <span class="title">const</span> <span class="title">T</span>＆<span class="title">get</span>（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">arr</span>）<span class="title">noexcept</span>;</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mytuple (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tuple_element&lt;<span class="number">0</span>,<span class="keyword">decltype</span>(myarray)&gt;::type myelement;  <span class="comment">// int myelement</span></span><br><span class="line"></span><br><span class="line">  myelement = <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(myarray);</span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(myarray) = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(myarray);</span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(myarray) = myelement;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element in myarray: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(myarray) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element in mytuple: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first element in myarray: 30</span><br><span class="line">first element in mytuple: 10</span><br></pre></td></tr></table></figure><h4 id="relational-operators-array"><a href="#relational-operators-array" class="headerlink" title="relational operators (array)"></a>relational operators (array)</h4><p>形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_T</span> <span class="title">N</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span> ==（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">lhs</span>，<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">rhs</span>）;</span></span><br><span class="line">（<span class="number">2</span>）</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_T</span> <span class="title">N</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span>！=（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">lhs</span>，<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">rhs</span>）;</span></span><br><span class="line">（<span class="number">3</span>）</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_T</span> <span class="title">N</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span> &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;</span></span><br><span class="line"><span class="class">（4）</span></span><br><span class="line"><span class="class">template &lt;class T，size_T N&gt; </span></span><br><span class="line"><span class="class">  bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;</span></span><br><span class="line"><span class="class">（5）</span></span><br><span class="line"><span class="class">template &lt;class T，size_T N&gt; </span></span><br><span class="line"><span class="class">  bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;</span></span><br><span class="line"><span class="class">（6）</span></span><br><span class="line"><span class="class">template &lt;class T，size_T N&gt; </span></span><br><span class="line"><span class="class">  bool operator&gt; =（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">lhs</span>，<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">rhs</span>）;</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; a = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; b = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; c = &#123;<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a==b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a and b are equal\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (b!=c) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b and c are not equal\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (b&lt;c) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b is less than c\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (c&gt;b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c is greater than b\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (a&lt;=b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a is less than or equal to b\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (a&gt;=b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a is greater than or equal to b\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a and b are equal</span><br><span class="line">b and c are not equal</span><br><span class="line">b is less than c</span><br><span class="line">c is greater than b</span><br><span class="line">a is less than or equal to b</span><br><span class="line">a is greater than or equal to b</span><br></pre></td></tr></table></figure><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector是表示可以改变大小的数组的序列容器。</p><p>就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。</p><p>在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。</p><p>相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。</p><p>因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。</p><p>与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。</p><p>针对 vector 的各种常见操作的复杂度（效率）如下： </p><ul><li>随机访问 - 常数 O(1) </li><li>在尾部增删元素 - 平摊（amortized）常数 O(1)}} </li><li>增删元素 - 至 vector 尾部的线性距离 O(n)}}</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt; &gt; <span class="title">class</span> <span class="title">vector</span>;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160406151211233" alt></p><h4 id="vector-vector"><a href="#vector-vector" class="headerlink" title="vector::vector"></a>vector::vector</h4><p>（1）empty容器构造函数（默认构造函数）<br>构造一个空的容器，没有元素。<br>（2）fill构造函数<br>用n个元素构造一个容器。每个元素都是val的副本（如果提供）。<br>（3）范围（range）构造器<br>使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。<br>（4）复制（copy）构造函数（并用分配器复制）<br>按照相同的顺序构造一个包含x中每个元素的副本的容器。<br>（5）移动（move）构造函数（和分配器移动）<br>构造一个获取x元素的容器。<br>如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。<br>x保持未指定但有效的状态。<br>（6）初始化列表构造函数<br>构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line">         <span class="built_in">vector</span> (size_type n, <span class="keyword">const</span> value_type&amp; val,</span><br><span class="line">                 <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type());</span><br><span class="line">range (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">vector</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">          <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br><span class="line">copy (<span class="number">4</span>)</span><br><span class="line"><span class="built_in">vector</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&amp; x);</span><br><span class="line"><span class="built_in">vector</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line">move (<span class="number">5</span>)</span><br><span class="line"><span class="built_in">vector</span> (<span class="built_in">vector</span>&amp;&amp; x);</span><br><span class="line"><span class="built_in">vector</span> (<span class="built_in">vector</span>&amp;&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">vector</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first;             <span class="comment">// empty vector of ints</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; second(<span class="number">4</span>, <span class="number">100</span>);    <span class="comment">// four ints with value 100</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; third(second.begin(), second.end());<span class="comment">// iterating through second</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fourth(third);     <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the iterator constructor can also be used to construct from arrays:</span></span><br><span class="line">    <span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fifth(myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of fifth are:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The contents of fifth are: 16 2 77 29</span><br></pre></td></tr></table></figure><h4 id="vector-vector-1"><a href="#vector-vector-1" class="headerlink" title="vector::~vector"></a>vector::~vector</h4><p>销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">vector</span>();</span><br></pre></td></tr></table></figure><h4 id="vector-operator"><a href="#vector-operator" class="headerlink" title="vector::operator="></a>vector::operator=</h4><p>将新内容分配给容器，替换其当前内容，并相应地修改其大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copy (<span class="number">1</span>)</span><br><span class="line"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> <span class="built_in">vector</span>&amp; x);</span><br><span class="line">move (<span class="number">2</span>)</span><br><span class="line"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span>= (<span class="built_in">vector</span>&amp;&amp; x);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span></span>= (<span class="built_in">initializer_list</span>&lt;value_type&gt; il);</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;int&gt; foo (3,0);</span><br><span class="line">  std::vector&lt;int&gt; bar (5,0);</span><br><span class="line"></span><br><span class="line">  bar = foo;</span><br><span class="line">  foo = std::vector&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Size of foo: 0</span><br><span class="line">Size of bar: 3</span><br></pre></td></tr></table></figure><h4 id="vector-begin"><a href="#vector-begin" class="headerlink" title="vector::begin"></a>vector::begin</h4><h4 id="vector-end"><a href="#vector-end" class="headerlink" title="vector::end"></a>vector::end</h4><h4 id="vector-rbegin"><a href="#vector-rbegin" class="headerlink" title="vector::rbegin"></a>vector::rbegin</h4><h4 id="vector-rend"><a href="#vector-rend" class="headerlink" title="vector::rend"></a>vector::rend</h4><h4 id="vector-cbegin"><a href="#vector-cbegin" class="headerlink" title="vector::cbegin"></a>vector::cbegin</h4><h4 id="vector-cend"><a href="#vector-cend" class="headerlink" title="vector::cend"></a>vector::cend</h4><h4 id="vector-rcbegin"><a href="#vector-rcbegin" class="headerlink" title="vector::rcbegin"></a>vector::rcbegin</h4><h4 id="vector-rcend"><a href="#vector-rcend" class="headerlink" title="vector::rcend"></a>vector::rcend</h4><h4 id="vector-size"><a href="#vector-size" class="headerlink" title="vector::size"></a>vector::size</h4><p>返回vector中元素的数量。</p><p>这是vector中保存的实际对象的数量，不一定等于其存储容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myints;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"0. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) myints.push_back(i);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myints.insert (myints.end(),<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myints.pop_back();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0. size: 0</span><br><span class="line">1. size: 10</span><br><span class="line">2. size: 20</span><br><span class="line">3. size: 19</span><br></pre></td></tr></table></figure><h4 id="vector-max-size"><a href="#vector-max-size" class="headerlink" title="vector::max_size"></a>vector::max_size</h4><p>返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制，</p><p>这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some content in the vector:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; myvector.size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size: "</span> &lt;&lt; myvector.max_size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A possible output for this program could be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size: 100</span><br><span class="line">capacity: 128</span><br><span class="line">max_size: 1073741823</span><br></pre></td></tr></table></figure><h4 id="vector-resize"><a href="#vector-resize" class="headerlink" title="vector::resize"></a>vector::resize</h4><p>调整容器的大小，使其包含n个元素。</p><p>如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。</p><p>如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。</p><p>如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。</p><p>注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some initial content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  myvector.resize(<span class="number">5</span>);</span><br><span class="line">  myvector.resize(<span class="number">8</span>,<span class="number">100</span>);</span><br><span class="line">  myvector.resize(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;myvector.size();i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myvector[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0</span><br></pre></td></tr></table></figure><h4 id="vector-capacity"><a href="#vector-capacity" class="headerlink" title="vector::capacity"></a>vector::capacity</h4><p>返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some content in the vector:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; (<span class="keyword">int</span>) myvector.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; (<span class="keyword">int</span>) myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size: "</span> &lt;&lt; (<span class="keyword">int</span>) myvector.max_size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A possible output for this program could be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size: 100</span><br><span class="line">capacity: 128</span><br><span class="line">max_size: 1073741823</span><br></pre></td></tr></table></figure><h4 id="vector-empty"><a href="#vector-empty" class="headerlink" title="vector::empty"></a>vector::empty</h4><p>返回vector是否为空（即，它的size是否为0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!myvector.empty())</span><br><span class="line">  &#123;</span><br><span class="line">     sum += myvector.back();</span><br><span class="line">     myvector.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total: 55</span><br></pre></td></tr></table></figure><h4 id="vector-reserve"><a href="#vector-reserve" class="headerlink" title="vector::reserve"></a>vector::reserve</h4><p>请求vector容量至少足以包含n个元素。</p><p>如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。</p><p>在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。</p><p>这个函数对vector大小没有影响，也不能改变它的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span> <span class="params">(size_type n)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type sz;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo;</span><br><span class="line">  sz = foo.capacity();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"making foo grow:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">    foo.push_back(i);</span><br><span class="line">    <span class="keyword">if</span> (sz!=foo.capacity()) &#123;</span><br><span class="line">      sz = foo.capacity();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity changed: "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar;</span><br><span class="line">  sz = bar.capacity();</span><br><span class="line">  bar.reserve(<span class="number">100</span>);   <span class="comment">// this is the only difference with foo above</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"making bar grow:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">    bar.push_back(i);</span><br><span class="line">    <span class="keyword">if</span> (sz!=bar.capacity()) &#123;</span><br><span class="line">      sz = bar.capacity();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity changed: "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">making foo grow:</span><br><span class="line">capacity changed: 1</span><br><span class="line">capacity changed: 2</span><br><span class="line">capacity changed: 4</span><br><span class="line">capacity changed: 8</span><br><span class="line">capacity changed: 16</span><br><span class="line">capacity changed: 32</span><br><span class="line">capacity changed: 64</span><br><span class="line">capacity changed: 128</span><br><span class="line">making bar grow:</span><br><span class="line">capacity changed: 100</span><br></pre></td></tr></table></figure><h4 id="vector-shrink-to-fit"><a href="#vector-shrink-to-fit" class="headerlink" title="vector::shrink_to_fit"></a>vector::shrink_to_fit</h4><p>要求容器减小其capacity(容量)以适应其尺寸。</p><p>该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1. capacity of myvector: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myvector.resize(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2. capacity of myvector: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myvector.shrink_to_fit();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3. capacity of myvector: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. capacity of myvector: 100</span><br><span class="line">2. capacity of myvector: 100</span><br><span class="line">3. capacity of myvector: 10</span><br></pre></td></tr></table></figure><h4 id="vector-operator-1"><a href="#vector-operator-1" class="headerlink" title="vector::operator[]"></a>vector::operator[]</h4><h4 id="vector-at"><a href="#vector-at" class="headerlink" title="vector::at"></a>vector::at</h4><h4 id="vector-front"><a href="#vector-front" class="headerlink" title="vector::front"></a>vector::front</h4><h4 id="vector-back"><a href="#vector-back" class="headerlink" title="vector::back"></a>vector::back</h4><h4 id="vector-data"><a href="#vector-data" class="headerlink" title="vector::data"></a>vector::data</h4><h4 id="vector-assign"><a href="#vector-assign" class="headerlink" title="vector::assign"></a>vector::assign</h4><p>将新内容分配给vector，替换其当前内容，并相应地修改其大小。</p><p>在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。</p><p>在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。</p><p>在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。</p><p>所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">range (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">assign</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; second;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; third;</span><br><span class="line"></span><br><span class="line">  first.assign (<span class="number">7</span>,<span class="number">100</span>);             <span class="comment">// 7 ints with a value of 100</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  it=first.begin()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  second.assign (it,first.end()<span class="number">-1</span>); <span class="comment">// the 5 central values of first</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">1776</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  third.assign (myints,myints+<span class="number">3</span>);   <span class="comment">// assigning from array.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of first: "</span> &lt;&lt; <span class="keyword">int</span> (first.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of second: "</span> &lt;&lt; <span class="keyword">int</span> (second.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of third: "</span> &lt;&lt; <span class="keyword">int</span> (third.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Size of first: 7</span><br><span class="line">Size of second: 5</span><br><span class="line">Size of third: 3</span><br></pre></td></tr></table></figure><p>补充：vector::assign 与 vector::operator= 的区别：</p><ol><li>vector::assign 实现源码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(size_type __n, <span class="keyword">const</span> _Tp&amp; __val)</span> </span>&#123; _M_fill_assign(__n, __val); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;_Tp, _Alloc&gt;:</span>:_M_fill_assign(<span class="keyword">size_t</span> __n, <span class="keyword">const</span> value_type&amp; __val) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__n &gt; capacity()) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator());</span><br><span class="line">    __tmp.swap(*<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__n &gt; size()) &#123;</span><br><span class="line">    fill(begin(), end(), __val);</span><br><span class="line">    _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    erase(fill_n(begin(), __n, __val), end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>vector::operator= 实现源码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;_Tp,_Alloc&gt;&amp; </span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;_Tp,_Alloc&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;__x != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __xlen = __x.size();</span><br><span class="line">    <span class="keyword">if</span> (__xlen &gt; capacity()) &#123;</span><br><span class="line">      iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());</span><br><span class="line">      destroy(_M_start, _M_finish);</span><br><span class="line">      _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">      _M_start = __tmp;</span><br><span class="line">      _M_end_of_storage = _M_start + __xlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size() &gt;= __xlen) &#123;</span><br><span class="line">      iterator __i = copy(__x.begin(), __x.end(), begin());</span><br><span class="line">      destroy(__i, _M_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      copy(__x.begin(), __x.begin() + size(), _M_start);</span><br><span class="line">      uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    _M_finish = _M_start + __xlen;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-push-back"><a href="#vector-push-back" class="headerlink" title="vector::push_back"></a>vector::push_back</h4><p>在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。</p><p>这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="keyword">int</span> myint;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter some integers (enter 0 to end):\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; myint;</span><br><span class="line">    myvector.push_back (myint);</span><br><span class="line">  &#125; <span class="keyword">while</span> (myint);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector stores "</span> &lt;&lt; <span class="keyword">int</span>(myvector.size()) &lt;&lt; <span class="string">" numbers.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-pop-back"><a href="#vector-pop-back" class="headerlink" title="vector::pop_back"></a>vector::pop_back</h4><p>删除vector中的最后一个元素，有效地将容器size减少一个。</p><p>这破坏了被删除的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  myvector.push_back (<span class="number">100</span>);</span><br><span class="line">  myvector.push_back (<span class="number">200</span>);</span><br><span class="line">  myvector.push_back (<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!myvector.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    sum+=myvector.back();</span><br><span class="line">    myvector.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The elements of myvector add up to "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The elements of myvector add up to 600</span><br></pre></td></tr></table></figure><h4 id="vector-insert"><a href="#vector-insert" class="headerlink" title="vector::insert"></a>vector::insert</h4><p>通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。 </p><p>由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">single <span class="title">element</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line">range (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">insert</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br><span class="line">move (<span class="number">4</span>)</span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, value_type&amp;&amp; val)</span></span>;</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="built_in">initializer_list</span>&lt;value_type&gt; il)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  it = myvector.begin();</span><br><span class="line">  it = myvector.insert ( it , <span class="number">200</span> );</span><br><span class="line"></span><br><span class="line">  myvector.insert (it,<span class="number">2</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "it" no longer valid, get a new one:</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anothervector (<span class="number">2</span>,<span class="number">400</span>);</span><br><span class="line">  myvector.insert (it+<span class="number">2</span>,anothervector.begin(),anothervector.end());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myarray [] = &#123; <span class="number">501</span>,<span class="number">502</span>,<span class="number">503</span> &#125;;</span><br><span class="line">  myvector.insert (myvector.begin(), myarray, myarray+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (it=myvector.begin(); it&lt;myvector.end(); it++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 501 502 503 300 300 400 400 200 100 100 100</span><br></pre></td></tr></table></figure><p>补充：insert 迭代器野指针错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vi;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取vector第一个元素的迭代器</span></span><br><span class="line">vi = v.begin();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错</span></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">v.insert(vi, <span class="number">2</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正：应该把<code>vi = v.begin();</code>放到<code>v.push_back(10);</code>后面</p><h4 id="vector-erase"><a href="#vector-erase" class="headerlink" title="vector::erase"></a>vector::erase</h4><p>从vector中删除单个元素（position）或一系列元素（[first，last））。</p><p>这有效地减少了被去除的元素的数量，从而破坏了容器的大小。</p><p>由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some values (from 1 to 10)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// erase the 6th element</span></span><br><span class="line">  myvector.erase (myvector.begin()+<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// erase the first 3 elements:</span></span><br><span class="line">  myvector.erase (myvector.begin(),myvector.begin()+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;myvector.size(); ++i)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myvector[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 4 5 7 8 9 10</span><br></pre></td></tr></table></figure><h4 id="vector-swap"><a href="#vector-swap" class="headerlink" title="vector::swap"></a>vector::swap</h4><p>通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。</p><p>在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。</p><p>请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="built_in">vector</span>&amp; x)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"></span><br><span class="line">  foo.swap(bar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;foo.size(); i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; foo[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;bar.size(); i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; bar[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo contains: 200 200 200 200 200 </span><br><span class="line">bar contains: 100 100 100</span><br></pre></td></tr></table></figure><h4 id="vector-clear"><a href="#vector-clear" class="headerlink" title="vector::clear"></a>vector::clear</h4><p>从vector中删除所有的元素（被销毁），留下size为0的容器。</p><p>不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：<code>vector&lt;T&gt;().swap(x);   // clear x reallocating</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.begin(); it != v.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 size  = "</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 capacity  = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v1.clear();</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 size  = "</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 capacity  = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v1.push_back(<span class="number">11</span>);</span><br><span class="line">v1.push_back(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 size  = "</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 capacity  = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">50 50 50 50 50</span><br><span class="line">v1 size  = 5</span><br><span class="line">v1 capacity  = 5</span><br><span class="line"></span><br><span class="line">v1 size  = 0</span><br><span class="line">v1 capacity  = 5</span><br><span class="line">11 22</span><br><span class="line">v1 size  = 2</span><br><span class="line">v1 capacity  = 5</span><br></pre></td></tr></table></figure><h4 id="vector-emplace"><a href="#vector-emplace" class="headerlink" title="vector::emplace"></a>vector::emplace</h4><p>通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。</p><p>这有效地增加了一个容器的大小。</p><p>分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。</p><p>由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。</p><p>该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">emplace</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = myvector.emplace ( myvector.begin()+<span class="number">1</span>, <span class="number">100</span> );</span><br><span class="line">  myvector.emplace ( it, <span class="number">200</span> );</span><br><span class="line">  myvector.emplace ( myvector.end(), <span class="number">300</span> );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: myvector)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 10 200 100 20 30 300</span><br></pre></td></tr></table></figure><h4 id="vector-emplace-back"><a href="#vector-emplace-back" class="headerlink" title="vector::emplace_back"></a>vector::emplace_back</h4><p>在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。</p><p>这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。</p><p>该元素是通过调用allocator_traits :: construct来转换args来创建的。</p><p>与push_back相比，emplace_back可以避免额外的复制和移动操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_back</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">President</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> country;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line"> </span><br><span class="line">    President(<span class="built_in">std</span>::<span class="built_in">string</span> p_name, <span class="built_in">std</span>::<span class="built_in">string</span> p_country, <span class="keyword">int</span> p_year)</span><br><span class="line">        : name(<span class="built_in">std</span>::move(p_name)), country(<span class="built_in">std</span>::move(p_country)), year(p_year)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being constructed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President(President&amp;&amp; other)</span><br><span class="line">        : name(<span class="built_in">std</span>::move(other.name)), country(<span class="built_in">std</span>::move(other.country)), year(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being moved.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> President&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; elections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:\n"</span>;</span><br><span class="line">    elections.emplace_back(<span class="string">"Nelson Mandela"</span>, <span class="string">"South Africa"</span>, <span class="number">1994</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; reElections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\npush_back:\n"</span>;</span><br><span class="line">    reElections.push_back(President(<span class="string">"Franklin Delano Roosevelt"</span>, <span class="string">"the USA"</span>, <span class="number">1936</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nContents:\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: elections) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was elected president of "</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: reElections) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was re-elected president of "</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">I am being constructed.</span><br><span class="line"> </span><br><span class="line">push_back:</span><br><span class="line">I am being constructed.</span><br><span class="line">I am being moved.</span><br><span class="line"> </span><br><span class="line">Contents:</span><br><span class="line">Nelson Mandela was elected president of South Africa in 1994.</span><br><span class="line">Franklin Delano Roosevelt was re-elected president of the USA in 1936.</span><br></pre></td></tr></table></figure><h4 id="vector-get-allocator"><a href="#vector-get-allocator" class="headerlink" title="vector::get_allocator"></a>vector::get_allocator</h4><p>返回与vector关联的构造器对象的副本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="keyword">int</span> * p;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate an array with space for 5 elements using vector's allocator:</span></span><br><span class="line">  p = myvector.get_allocator().allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// construct values in-place on the array:</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) myvector.get_allocator().construct(&amp;p[i],i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The allocated array contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; p[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// destroy and deallocate:</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) myvector.get_allocator().destroy(&amp;p[i]);</span><br><span class="line">  myvector.get_allocator().deallocate(p,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The allocated array contains: 0 1 2 3 4</span><br></pre></td></tr></table></figure><h4 id="relational-operators-vector"><a href="#relational-operators-vector" class="headerlink" title="relational operators (vector)"></a>relational operators (vector)</h4><h4 id="swap-vector"><a href="#swap-vector" class="headerlink" title="swap (vector)"></a>swap (vector)</h4><h4 id="vector-1"><a href="#vector-1" class="headerlink" title="vector "></a>vector <bool></bool></h4><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。</p><p>特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。</p><p>因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。</p><p>两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。</p><p>对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。</p><p>deque上常见操作的复杂性（效率）如下： </p><ul><li>随机访问 - 常数O(1) </li><li>在结尾或开头插入或移除元素 - 摊销不变O(1) </li><li>插入或移除元素 - 线性O(n)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt; &gt; <span class="title">class</span> <span class="title">deque</span>;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="http://img.blog.csdn.net/20170727225856144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlg2Nzc1ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br><img src="https://images0.cnblogs.com/blog/559453/201401/092150340824.png" alt></p><h4 id="deque-deque"><a href="#deque-deque" class="headerlink" title="deque::deque"></a>deque::deque</h4><p>构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容：</p><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; first;                                <span class="comment">// empty deque of ints</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; second (<span class="number">4</span>,<span class="number">100</span>);                       <span class="comment">// four ints with value 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; third (second.begin(),second.end());  <span class="comment">// iterating through second</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; fourth (third);                       <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// the iterator constructor can be used to copy arrays:</span></span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; fifth (myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of fifth are:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The contents of fifth are: 16 2 77 29</span><br></pre></td></tr></table></figure><h4 id="deque-push-back"><a href="#deque-push-back" class="headerlink" title="deque::push_back"></a>deque::push_back</h4><p>在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。</p><p>这有效地增加了一个容器的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line">  <span class="keyword">int</span> myint;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter some integers (enter 0 to end):\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; myint;</span><br><span class="line">    mydeque.push_back (myint);</span><br><span class="line">  &#125; <span class="keyword">while</span> (myint);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque stores "</span> &lt;&lt; (<span class="keyword">int</span>) mydeque.size() &lt;&lt; <span class="string">" numbers.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-push-front"><a href="#deque-push-front" class="headerlink" title="deque::push_front"></a>deque::push_front</h4><p>在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。</p><p>这有效地增加了一个容器的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque (<span class="number">2</span>,<span class="number">100</span>);     <span class="comment">// two ints with a value of 100</span></span><br><span class="line">  mydeque.push_front (<span class="number">200</span>);</span><br><span class="line">  mydeque.push_front (<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">300 200 100 100</span><br></pre></td></tr></table></figure><h4 id="deque-pop-back"><a href="#deque-pop-back" class="headerlink" title="deque::pop_back"></a>deque::pop_back</h4><p>删除deque容器中的最后一个元素，有效地将容器大小减少一个。</p><p>这破坏了被删除的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  mydeque.push_back (<span class="number">10</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">20</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!mydeque.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    sum+=mydeque.back();</span><br><span class="line">    mydeque.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The elements of mydeque add up to "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The elements of mydeque add up to 60</span><br></pre></td></tr></table></figure><h4 id="deque-pop-front"><a href="#deque-pop-front" class="headerlink" title="deque::pop_front"></a>deque::pop_front</h4><p>删除deque容器中的第一个元素，有效地减小其大小。</p><p>这破坏了被删除的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">  mydeque.push_back (<span class="number">100</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">200</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Popping out the elements in mydeque:"</span>;</span><br><span class="line">  <span class="keyword">while</span> (!mydeque.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; mydeque.front();</span><br><span class="line">    mydeque.pop_front();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe final size of mydeque is "</span> &lt;&lt; <span class="keyword">int</span>(mydeque.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Popping out the elements in mydeque: 100 200 300</span><br><span class="line">The final size of mydeque is 0</span><br></pre></td></tr></table></figure><h4 id="deque-emplace-front"><a href="#deque-emplace-front" class="headerlink" title="deque::emplace_front"></a>deque::emplace_front</h4><p>在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。</p><p>这有效地增加了一个容器的大小。</p><p>该元素是通过调用allocator_traits::construct来转换args来创建的。</p><p>存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_front</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mydeque.emplace_front (<span class="number">111</span>);</span><br><span class="line">  mydeque.emplace_front (<span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: mydeque)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydeque contains: 222 111 10 20 30</span><br></pre></td></tr></table></figure><h4 id="deque-emplace-back"><a href="#deque-emplace-back" class="headerlink" title="deque::emplace_back"></a>deque::emplace_back</h4><p>在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。</p><p>这有效地增加了一个容器的大小。</p><p>该元素是通过调用allocator_traits::construct来转换args来创建的。</p><p>存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_back</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mydeque.emplace_back (<span class="number">100</span>);</span><br><span class="line">  mydeque.emplace_back (<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: mydeque)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydeque contains: 10 20 30 100 200</span><br></pre></td></tr></table></figure><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。</p><p>forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表</p><p>之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。</p><p>与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。</p><p>的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。</p><p>该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。</p><p><img src="http://img.blog.csdn.net/20160407212133266" alt></p><h4 id="forward-list-forward-list"><a href="#forward-list-forward-list" class="headerlink" title="forward_list::forward_list"></a>forward_list::forward_list</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line">range (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">forward_list</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br><span class="line">copy (<span class="number">4</span>)</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst);</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line">move (<span class="number">5</span>)</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst);</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">forward_list</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; first;                      <span class="comment">// default: empty</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; second (<span class="number">3</span>,<span class="number">77</span>);              <span class="comment">// fill: 3 seventy-sevens</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; third (second.begin(), second.end()); <span class="comment">// range initialization</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; fourth (third);            <span class="comment">// copy constructor</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; fifth (<span class="built_in">std</span>::move(fourth));  <span class="comment">// move ctor. (fourth wasted)</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; sixth = &#123;<span class="number">3</span>, <span class="number">52</span>, <span class="number">25</span>, <span class="number">90</span>&#125;;    <span class="comment">// initializer_list constructor</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first:"</span> ; <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: first)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second:"</span>; <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: second) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"third:"</span>;  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: third)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fourth:"</span>; <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: fourth) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fifth:"</span>;  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: fifth)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sixth:"</span>;  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: sixth)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">forward_list constructor examples:</span><br><span class="line">first:</span><br><span class="line">second: 77 77 77</span><br><span class="line">third: 77 77 77</span><br><span class="line">fourth:</span><br><span class="line">fifth: 77 77 77</span><br><span class="line">sixth: 3 52 25 90</span><br></pre></td></tr></table></figure><h4 id="forward-list-forward-list-1"><a href="#forward-list-forward-list-1" class="headerlink" title="forward_list::~forward_list"></a>forward_list::~forward_list</h4><h4 id="forward-list-before-begin"><a href="#forward-list-before-begin" class="headerlink" title="forward_list::before_begin"></a>forward_list::before_begin</h4><p>返回指向容器中第一个元素之前的位置的迭代器。</p><p>返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; mylist = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mylist.insert_after ( mylist.before_begin(), <span class="number">11</span> );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x: mylist ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist contains: 11 20 30 40 50</span><br></pre></td></tr></table></figure><h4 id="forward-list-cbefore-begin"><a href="#forward-list-cbefore-begin" class="headerlink" title="forward_list::cbefore_begin"></a>forward_list::cbefore_begin</h4><p>返回指向容器中第一个元素之前的位置的const_iterator。</p><p>一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。</p><p>返回的价值不得解除引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">cbefore_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; mylist = &#123;<span class="number">77</span>, <span class="number">2</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mylist.insert_after ( mylist.cbefore_begin(), <span class="number">19</span> );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x: mylist ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist contains: 19 77 2 16</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。</p><p>在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;</span><br></pre></td></tr></table></figure><p>在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // <span class="title">map</span>:</span>:key_type</span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                                       // <span class="title">map</span>:</span>:mapped_type</span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,                     // <span class="title">map</span>:</span>:key_compare</span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;pair&lt;const Key,T&gt; &gt;    // <span class="title">map</span>:</span>:allocator_type</span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure><h4 id="map-map"><a href="#map-map" class="headerlink" title="map::map"></a>map::map</h4><p>构造一个映射容器对象，根据所使用的构造器版本初始化其内容：</p><p>（1）空容器构造函数（默认构造函数）</p><p>构造一个空的容器，没有元素。</p><p>（2）范围构造函数</p><p>构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。</p><p>（3）复制构造函数（并用分配器复制）</p><p>使用x中的每个元素的副本构造一个容器。</p><p>（4）移动构造函数（并与分配器一起移动）</p><p>构造一个获取x元素的容器。<br>如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。<br>x保持未指定但有效的状态。</p><p>（5）初始化列表构造函数</p><p>用il中的每个元素的副本构造一个容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">empty (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">map</span> <span class="params">(<span class="keyword">const</span> key_compare&amp; comp = key_compare(),</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">map</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc)</span></span>;</span><br><span class="line">range (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">map</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">key_compare</span>&amp; <span class="title">comp</span> = <span class="title">key_compare</span>(),</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">allocator_type</span>&amp; = <span class="title">allocator_type</span>());</span></span><br><span class="line">copy (<span class="number">3</span>)</span><br><span class="line"><span class="built_in">map</span> (<span class="keyword">const</span> <span class="built_in">map</span>&amp; x);</span><br><span class="line"><span class="built_in">map</span> (<span class="keyword">const</span> <span class="built_in">map</span>&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line">move (<span class="number">4</span>)</span><br><span class="line"><span class="built_in">map</span> (<span class="built_in">map</span>&amp;&amp; x);</span><br><span class="line"><span class="built_in">map</span> (<span class="built_in">map</span>&amp;&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">map</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> key_compare&amp; comp = key_compare(),</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fncomp</span> <span class="params">(<span class="keyword">char</span> lhs, <span class="keyword">char</span> rhs)</span> </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classcomp</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>&amp; lhs, <span class="keyword">const</span> <span class="keyword">char</span>&amp; rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; first;</span><br><span class="line"></span><br><span class="line">  first[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">  first[<span class="string">'b'</span>]=<span class="number">30</span>;</span><br><span class="line">  first[<span class="string">'c'</span>]=<span class="number">50</span>;</span><br><span class="line">  first[<span class="string">'d'</span>]=<span class="number">70</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; second (first.begin(),first.end());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; third (second);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>,classcomp&gt; fourth;                 <span class="comment">// class as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span>(*fn_pt)(<span class="keyword">char</span>,<span class="keyword">char</span>) = fncomp;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>,<span class="keyword">bool</span>(*)(<span class="keyword">char</span>,<span class="keyword">char</span>)&gt; fifth (fn_pt); <span class="comment">// function pointer as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-begin"><a href="#map-begin" class="headerlink" title="map::begin"></a>map::begin</h4><p>返回引用map容器中第一个元素的迭代器。</p><p>由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。</p><p>如果容器是空的，则返回的迭代器值不应被解除引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'b'</span>] = <span class="number">100</span>;</span><br><span class="line">  mymap[<span class="string">'a'</span>] = <span class="number">200</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>] = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// show content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; 200</span><br><span class="line">b =&gt; 100</span><br><span class="line">c =&gt; 300</span><br></pre></td></tr></table></figure><h4 id="map-key-comp"><a href="#map-key-comp" class="headerlink" title="map::key_comp"></a>map::key_comp</h4><p>返回容器用于比较键的比较对象的副本。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::key_compare mycomp = mymap.key_comp();</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">100</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">200</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap contains:\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> highest = mymap.rbegin()-&gt;first;     <span class="comment">// key value of last element</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( mycomp((*it++).first, highest) );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mymap contains:</span><br><span class="line">a =&gt; 100</span><br><span class="line">b =&gt; 200</span><br><span class="line">c =&gt; 300</span><br></pre></td></tr></table></figure><h4 id="map-value-comp"><a href="#map-value-comp" class="headerlink" title="map::value_comp"></a>map::value_comp</h4><p>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'x'</span>]=<span class="number">1001</span>;</span><br><span class="line">  mymap[<span class="string">'y'</span>]=<span class="number">2002</span>;</span><br><span class="line">  mymap[<span class="string">'z'</span>]=<span class="number">3003</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap contains:\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; highest = *mymap.rbegin();          <span class="comment">// last element</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( mymap.value_comp()(*it++, highest) );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mymap contains:</span><br><span class="line">x =&gt; 1001</span><br><span class="line">y =&gt; 2002</span><br><span class="line">z =&gt; 3003</span><br></pre></td></tr></table></figure><h4 id="map-find"><a href="#map-find" class="headerlink" title="map::find"></a>map::find</h4><p>在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。</p><p>如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。 </p><p>另一个成员函数map::count可以用来检查一个特定的键是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">50</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">100</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">150</span>;</span><br><span class="line">  mymap[<span class="string">'d'</span>]=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  it = mymap.find(<span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != mymap.end())</span><br><span class="line">    mymap.erase (it);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// print content:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"elements in mymap:"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a =&gt; "</span> &lt;&lt; mymap.find(<span class="string">'a'</span>)-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c =&gt; "</span> &lt;&lt; mymap.find(<span class="string">'c'</span>)-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d =&gt; "</span> &lt;&lt; mymap.find(<span class="string">'d'</span>)-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elements in mymap:</span><br><span class="line">a =&gt; 50</span><br><span class="line">c =&gt; 150</span><br><span class="line">d =&gt; 200</span><br></pre></td></tr></table></figure><h4 id="map-count"><a href="#map-count" class="headerlink" title="map::count"></a>map::count</h4><p>在容器中搜索具有等于k的键的元素，并返回匹配的数量。</p><p>由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。</p><p>如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">  mymap [<span class="string">'a'</span>]=<span class="number">101</span>;</span><br><span class="line">  mymap [<span class="string">'c'</span>]=<span class="number">202</span>;</span><br><span class="line">  mymap [<span class="string">'f'</span>]=<span class="number">303</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (c=<span class="string">'a'</span>; c&lt;<span class="string">'h'</span>; c++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    <span class="keyword">if</span> (mymap.count(c)&gt;<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" is an element of mymap.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" is not an element of mymap.\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a is an element of mymap.</span><br><span class="line">b is not an element of mymap.</span><br><span class="line">c is an element of mymap.</span><br><span class="line">d is not an element of mymap.</span><br><span class="line">e is not an element of mymap.</span><br><span class="line">f is an element of mymap.</span><br><span class="line">g is not an element of mymap.</span><br></pre></td></tr></table></figure><h4 id="map-lower-bound"><a href="#map-lower-bound" class="headerlink" title="map::lower_bound"></a>map::lower_bound</h4><p>将迭代器返回到下限</p><p>返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。</p><p>该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。</p><p>如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。</p><p>一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">lower_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator itlow,itup;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">20</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">40</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">60</span>;</span><br><span class="line">  mymap[<span class="string">'d'</span>]=<span class="number">80</span>;</span><br><span class="line">  mymap[<span class="string">'e'</span>]=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  itlow=mymap.lower_bound (<span class="string">'b'</span>);  <span class="comment">// itlow points to b</span></span><br><span class="line">  itup=mymap.upper_bound (<span class="string">'d'</span>);   <span class="comment">// itup points to e (not d!)</span></span><br><span class="line"></span><br><span class="line">  mymap.erase(itlow,itup);        <span class="comment">// erases [itlow,itup)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// print content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; 20</span><br><span class="line">e =&gt; 100</span><br></pre></td></tr></table></figure><h4 id="map-upper-bound"><a href="#map-upper-bound" class="headerlink" title="map::upper_bound"></a>map::upper_bound</h4><p>将迭代器返回到上限</p><p>返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。</p><p>该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。</p><p>如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。</p><p>类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">upper_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator itlow,itup;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">20</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">40</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">60</span>;</span><br><span class="line">  mymap[<span class="string">'d'</span>]=<span class="number">80</span>;</span><br><span class="line">  mymap[<span class="string">'e'</span>]=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  itlow=mymap.lower_bound (<span class="string">'b'</span>);  <span class="comment">// itlow points to b</span></span><br><span class="line">  itup=mymap.upper_bound (<span class="string">'d'</span>);   <span class="comment">// itup points to e (not d!)</span></span><br><span class="line"></span><br><span class="line">  mymap.erase(itlow,itup);        <span class="comment">// erases [itlow,itup)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// print content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; 20</span><br><span class="line">e =&gt; 100</span><br></pre></td></tr></table></figure><h4 id="map-equal-range"><a href="#map-equal-range" class="headerlink" title="map::equal_range"></a>map::equal_range</h4><p>获取相同元素的范围</p><p>返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。 </p><p>如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;const_iterator,const_iterator&gt; equal_range (<span class="keyword">const</span> key_type&amp; k) <span class="keyword">const</span>;</span><br><span class="line">pair&lt;iterator,iterator&gt;             equal_range (<span class="keyword">const</span> key_type&amp; k);</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">20</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator,<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator&gt; ret;</span><br><span class="line">  ret = mymap.equal_range(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lower bound points to: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"upper bound points to: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ret.second-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; ret.second-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lower bound points to: &apos;b&apos; =&gt; 20</span><br><span class="line">upper bound points to: &apos;c&apos; =&gt; 30</span><br></pre></td></tr></table></figure><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><h3 id="无序容器（Unordered-Container）：unordered-set、unordered-multiset、unordered-map、unordered-multimap"><a href="#无序容器（Unordered-Container）：unordered-set、unordered-multiset、unordered-map、unordered-multimap" class="headerlink" title="无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap"></a>无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap</h3><p>包括：</p><ul><li>unordered_set</li><li>unordered_multiset</li><li>unordered_map</li><li>unordered_multimap</li></ul><p>都是以哈希表实现的。</p><p><img src="http://img.blog.csdn.net/20160410123436394" alt></p><p>unordered_set、unodered_multiset结构：</p><p><img src="http://img.blog.csdn.net/20160410123518692" alt></p><p>unordered_map、unodered_multimap结构：</p><p><img src="http://img.blog.csdn.net/20160410123525739" alt></p><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h3 id="unordered-multiset"><a href="#unordered-multiset" class="headerlink" title="unordered_multiset"></a>unordered_multiset</h3><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><h3 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h3><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Types</span>&gt; <span class="title">class</span> <span class="title">tuple</span>;</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple, std::get, std::tie, std::ignore</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; foo (<span class="number">10</span>,<span class="string">'x'</span>);</span><br><span class="line">  <span class="keyword">auto</span> bar = <span class="built_in">std</span>::make_tuple (<span class="string">"test"</span>, <span class="number">3.1</span>, <span class="number">14</span>, <span class="string">'y'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(bar) = <span class="number">100</span>;                                    <span class="comment">// access element</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myint; <span class="keyword">char</span> mychar;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tie (myint, mychar) = foo;                            <span class="comment">// unpack elements</span></span><br><span class="line">  <span class="built_in">std</span>::tie (<span class="built_in">std</span>::ignore, <span class="built_in">std</span>::ignore, myint, mychar) = bar;  <span class="comment">// unpack (with ignore)</span></span><br><span class="line"></span><br><span class="line">  mychar = <span class="built_in">std</span>::get&lt;<span class="number">3</span>&gt;(bar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(foo) = <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(bar);</span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(foo) = mychar;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(foo) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(foo) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo contains: 100 y</span><br></pre></td></tr></table></figure><h4 id="tuple-tuple"><a href="#tuple-tuple" class="headerlink" title="tuple::tuple"></a>tuple::tuple</h4><p>构建一个 tuple（元组）对象。</p><p>这涉及单独构建其元素，初始化取决于调用的构造函数形式：</p><p>（1）默认的构造函数</p><p>构建一个 元组对象的元素值初始化。</p><p>（2）复制/移动构造函数</p><p>该对象使用tpl的内容进行初始化 元组目的。tpl<br>的相应元素被传递给每个元素的构造函数。</p><p>（3）隐式转换构造函数</p><p>同上。tpl中的<br>所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。</p><p>（4）初始化构造函数<br>用elems中的相应元素初始化每个元素。elems<br>的相应元素被传递给每个元素的构造函数。</p><p>（5）对转换构造函数</p><p>该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。</p><p>（6）分配器版本</p><p>和上面的版本一样，除了每个元素都是使用allocator alloc构造的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line">copy / move (<span class="number">2</span>)</span><br><span class="line">tuple (<span class="keyword">const</span> tuple&amp; tpl) = <span class="keyword">default</span>;</span><br><span class="line">tuple (tuple&amp;&amp; tpl) = <span class="keyword">default</span>;</span><br><span class="line"><span class="function">implicit <span class="title">conversion</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">template &lt;class... UTypes&gt;</span><br><span class="line">  tuple (<span class="keyword">const</span> tuple&lt;UTypes...&gt;&amp; tpl);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span></span><br><span class="line">initialization (<span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="keyword">const</span> Types&amp;... elems)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">explicit</span> <span class="title">tuple</span> (<span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span></span><br><span class="line"><span class="function">conversion from <span class="title">pair</span> <span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line">template &lt;class U1, class U2&gt;</span><br><span class="line">  tuple (<span class="keyword">const</span> pair&lt;U1,U2&gt;&amp; pr);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span></span><br><span class="line">allocator (<span class="number">6</span>)</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">tuple</span>&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">tuple</span>&amp;&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>,<span class="title">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">tuple</span>&lt;UTypes...&gt;&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">Types</span>&amp;... <span class="title">elems</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">pair</span>&lt;U1,U2&gt;&amp; <span class="title">pr</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // std::make_pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple, std::make_tuple, std::get</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; first;                             <span class="comment">// default</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; second (first);                    <span class="comment">// copy</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; third (<span class="built_in">std</span>::make_tuple(<span class="number">20</span>,<span class="string">'b'</span>));   <span class="comment">// move</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">long</span>,<span class="keyword">char</span>&gt; fourth (third);                   <span class="comment">// implicit conversion</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; fifth (<span class="number">10</span>,<span class="string">'a'</span>);                    <span class="comment">// initialization</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; sixth (<span class="built_in">std</span>::make_pair(<span class="number">30</span>,<span class="string">'c'</span>));    <span class="comment">// from pair / move</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sixth contains: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(sixth);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" and "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(sixth) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sixth contains: 30 and c</span><br></pre></td></tr></table></figure><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。</p><p>pair是tuple（元组）的一个特例。</p><p>pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p><p>应用：</p><ul><li>可以将两个类型数据组合成一个如map&lt;key, value&gt;</li><li>当某个函数需要两个返回值时</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">struct</span> <span class="title">pair</span>;</span></span><br></pre></td></tr></table></figure><h4 id="pair-pair"><a href="#pair-pair" class="headerlink" title="pair::pair"></a>pair::pair</h4><p>构建一个pair对象。</p><p>这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式：</p><p>（1）默认的构造函数</p><p>构建一个 对对象的元素值初始化。</p><p>（2）复制/移动构造函数（和隐式转换）</p><p>该对象被初始化为pr的内容 对目的。pr<br>的相应成员被传递给每个成员的构造函数。</p><p>（3）初始化构造函数</p><p>会员 第一是由一个和成员构建的第二与b。</p><p>（4）分段构造</p><p>构造成员 first  和 second  到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">pair</span><span class="params">()</span></span>;</span><br><span class="line">copy / move (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">V</span>&gt; <span class="title">pair</span> (<span class="title">const</span> <span class="title">pair</span>&lt;U,V&gt;&amp; <span class="title">pr</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">V</span>&gt; <span class="title">pair</span> (<span class="title">pair</span>&lt;U,V&gt;&amp;&amp; <span class="title">pr</span>);</span></span><br><span class="line">pair (<span class="keyword">const</span> pair&amp; pr) = <span class="keyword">default</span>;</span><br><span class="line">pair (pair&amp;&amp; pr) = <span class="keyword">default</span>;</span><br><span class="line">initialization (<span class="number">3</span>)</span><br><span class="line">pair (<span class="keyword">const</span> first_type&amp; a, <span class="keyword">const</span> second_type&amp; b);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">V</span>&gt; <span class="title">pair</span> (<span class="title">U</span>&amp;&amp; <span class="title">a</span>, <span class="title">V</span>&amp;&amp; <span class="title">b</span>);</span></span><br><span class="line">piecewise (<span class="number">4</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args1</span>, <span class="title">class</span>... <span class="title">Args2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">pair</span> (<span class="title">piecewise_construct_t</span> <span class="title">pwc</span>, <span class="title">tuple</span>&lt;Args1...&gt; <span class="title">first_args</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">tuple</span>&lt;Args2...&gt; <span class="title">second_args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // std::pair, std::make_pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product1;                     <span class="comment">// default constructor</span></span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product2 (<span class="string">"tomatoes"</span>,<span class="number">2.30</span>);   <span class="comment">// value init</span></span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product3 (product2);          <span class="comment">// copy constructor</span></span><br><span class="line"></span><br><span class="line">  product1 = <span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"lightbulbs"</span>),<span class="number">0.99</span>);   <span class="comment">// using make_pair (move)</span></span><br><span class="line"></span><br><span class="line">  product2.first = <span class="string">"shoes"</span>;                  <span class="comment">// the type of first is string</span></span><br><span class="line">  product2.second = <span class="number">39.90</span>;                   <span class="comment">// the type of second is double</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product1.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product1.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product2.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product2.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product3.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product3.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The price of lightbulbs is $0.99</span><br><span class="line">The price of shoes is $39.9</span><br><span class="line">The price of tomatoes is $2.3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;STL&quot;&gt;&lt;a href=&quot;#STL&quot; class=&quot;headerlink&quot; title=&quot;STL&quot;&gt;&lt;/a&gt;STL&lt;/h1&gt;&lt;h2 id=&quot;网站&quot;&gt;&lt;a href=&quot;#网站&quot; class=&quot;headerlink&quot; title=&quot;网站&quot;&gt;&lt;/a&gt;网站&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9ub3RlL2Jsb2IvbWFzdGVyL1NUTC5tZA==&quot; title=&quot;https://github.com/huihut/note/blob/master/STL.md&quot;&gt;github . huihut/note/STL.md&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdGwv&quot; title=&quot;http://www.cplusplus.com/reference/stl/&quot;&gt;cplusplus . stl&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3poLmNwcHJlZmVyZW5jZS5jb20vdy8lRTklQTYlOTYlRTklQTElQjU=&quot; title=&quot;http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5&quot;&gt;cppreference . C++ 参考手册&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sdW1uL2RldGFpbHMvZ2Vlay1zdGwuaHRtbA==&quot; title=&quot;http://blog.csdn.net/column/details/geek-stl.html&quot;&gt;CSDN专栏：STL学习笔记&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Interview C C++</title>
    <link href="http://miaopei.github.io/2016/06/08/Program-C/interview/"/>
    <id>http://miaopei.github.io/2016/06/08/Program-C/interview/</id>
    <published>2016-06-08T02:14:50.000Z</published>
    <updated>2019-06-14T06:12:15.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-C-面试知识总结"><a href="#C-C-面试知识总结" class="headerlink" title="C/C++ 面试知识总结"></a>C/C++ 面试知识总结</h1><p>C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。</p><p>勘误新增请 Issue、PR，建议、讨论请 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvaXNzdWVzLzEy" title="https://github.com/huihut/interview/issues/12">#issues/12<i class="fa fa-external-link"></i></span>，排版使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL216bG9naW4vY2hpbmVzZS1jb3B5d3JpdGluZy1ndWlkZWxpbmVz" title="https://github.com/mzlogin/chinese-copywriting-guidelines">中文文案排版指北<i class="fa fa-external-link"></i></span></p><p>使用建议：</p><ul><li><code>Ctrl + F</code>：快速查找定位知识点</li><li><code>TOC 导航</code>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phd2lsL0dheUh1Yg==" title="https://github.com/jawil/GayHub">jawil/GayHub<i class="fa fa-external-link"></i></span> 插件快速目录跳转</li></ul><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#cc">C/C++</a></li><li><a href="#stl">STL</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li><li><a href="#%E7%AE%97%E6%B3%95">算法</a></li><li><a href="#problems">Problems</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E5%BA%93">链接装载库</a></li><li><a href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">海量数据处理</a></li><li><a href="#%E9%9F%B3%E8%A7%86%E9%A2%91">音视频</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li><li><a href="#%E4%B9%A6%E7%B1%8D">书籍</a></li><li><a href="#%E5%A4%8D%E4%B9%A0%E5%88%B7%E9%A2%98%E7%BD%91%E7%AB%99">复习刷题网站</a></li><li><a href="#%E6%8B%9B%E8%81%98%E6%97%B6%E9%97%B4%E5%B2%97%E4%BD%8D">招聘时间岗位</a></li><li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E7%BB%8F%E9%AA%8C">面试题目经验</a></li></ul><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针和指针常量；</li><li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><details><summary>const 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="comment">// 还有其中区别方法，沿着 * 号划一条线：</span></span><br><span class="line"><span class="comment">// 如果const位于 * 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；</span></span><br><span class="line"><span class="comment">// 如果const位于 * 的右侧，const就是修饰指针本身，即指针本身是常量。</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure></details><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。</li><li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ol><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81YzM1Y2MyMThiYjQ=" title="https://www.jianshu.com/p/5c35cc218bb4">C++ static 和const 的作用<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 <code>this</code> 指针：<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol><h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>不能包含循环、递归、switch 等复杂操作；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><details><summary>inline 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure></details><h4 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h4><ol><li>将 inline 函数体复制到 inline 函数调用点处； </li><li>为所用 inline 函数中的局部变量分配内存空间； </li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h4 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h4><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcy50ZWNobmlvbi5hYy5pbC91c2Vycy95ZWNoaWVsL2MrKy1mYXEvaW5saW5lLXZpcnR1YWxzLmh0bWw=" title="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html">Are “inline virtual” member functions ever actually “inlined”?<i class="fa fa-external-link"></i></span></p><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><details><summary>虚函数内联使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">Base b;</span><br><span class="line">b.who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">ptr-&gt;who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p><details><summary>assert() 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure></details><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h3><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul><h3 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h3><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p><details><summary>#pragma pack(n) 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure></details><h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bit mode: <span class="number">2</span>;    <span class="comment">// mode 占 2 位</span></span><br></pre></td></tr></table></figure><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和连接的</li></ul><p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><details><summary>extern "C" 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></details><h3 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h3><h4 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p><p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p><h4 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h4><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p><p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p><p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student(); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h3><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>最本质的一个区别就是默认的访问控制<ol><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ol></li></ul><h3 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><details><summary>union 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h3><p><span class="exturl" data-url="aHR0cDovL2Rvbmd4aWNoZW5nLm9yZy9jcHAvb29jLw==" title="http://dongxicheng.org/cpp/ooc/">C 语言实现封装、继承和多态<i class="fa fa-external-link"></i></span></p><h3 id="explicit（显式）构造函数"><a href="#explicit（显式）构造函数" class="headerlink" title="explicit（显式）构造函数"></a>explicit（显式）构造函数</h3><p>explicit 修饰的构造函数可用来防止隐式转换</p><details><summary>explicit 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test1(<span class="keyword">int</span> n)            <span class="comment">// 普通构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> n)</span>   <span class="comment">// explicit（显式）构造函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test1 t1=<span class="number">12</span>;            <span class="comment">// 隐式调用其构造函数，成功</span></span><br><span class="line">    Test2 t2=<span class="number">12</span>;            <span class="comment">// 编译错误，不能隐式调用其构造函数</span></span><br><span class="line">    <span class="function">Test2 <span class="title">t2</span><span class="params">(<span class="number">12</span>)</span></span>;           <span class="comment">// 显式调用成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h3><ul><li>能访问私有成员  </li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><h4 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h4><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure><h4 id="构造函数的-using-声明【C-11】"><a href="#构造函数的-using-声明【C-11】" class="headerlink" title="构造函数的 using 声明【C++11】"></a>构造函数的 using 声明【C++11】</h4><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">derived(parms) : base(args) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h4><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure><h4 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 <code>using 指示</code> 污染命名空间</h4><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了制定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><details><summary>using 使用</summary> <p>尽量少使用 <code>using 指示</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>应该多使用 <code>using 声明</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></details><h3 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ol><details><summary>:: 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    count = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h3><h4 id="限定作用域的枚举类型"><a href="#限定作用域的枚举类型" class="headerlink" title="限定作用域的枚举类型"></a>限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span> input, output, append &#125;;</span><br></pre></td></tr></table></figure><h4 id="不限定作用域的枚举类型"><a href="#不限定作用域的枚举类型" class="headerlink" title="不限定作用域的枚举类型"></a>不限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy53ZWl4dWV5dWFuLm5ldC92aWV3LzU4MjQuaHRtbA==" title="http://www.weixueyuan.net/view/5824.html">C++ 枚举类型详解<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure><details><summary>decltype 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>常规引用，一般表示对象的身份。</p><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p><p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p><ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li></ul><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aWFvbHUxMTc1L2FydGljbGUvZGV0YWlscy80Njg4OTUyMw==" title="https://blog.csdn.net/tianxiaolu1175/article/details/46889523">详解c++ 引用（reference）与 指针（pointer）的区别与联系<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul><li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li></ul><h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><p>好处</p><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li></ol></li></ul><h3 id="initializer-list-列表初始化【C-11】"><a href="#initializer-list-列表初始化【C-11】" class="headerlink" title="initializer_list 列表初始化【C++11】"></a>initializer_list 列表初始化【C++11】</h3><p>用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p><details><summary>initializer_list 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.size() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.end(), l.begin(), l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> T*, <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; c_arr() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.size()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p><img src="http://img.my.csdn.net/uploads/201211/22/1353564524_6375.png" alt="面向对象特征"></p><p>面向对象三大特征 —— 封装、继承、多态</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li><li>关键字：public, protected, friendly, private。不写默认为 friendly。</li></ul><table><thead><tr><th>关键字</th><th>当前类</th><th>包内</th><th>子孙类</th><th>包外</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>friendly</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>基类（父类）——&gt; 派生类（子类）</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。</li><li>C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。</li><li>多态是以封装和继承为基础的。</li></ul><h4 id="静态多态（早绑定）"><a href="#静态多态（早绑定）" class="headerlink" title="静态多态（早绑定）"></a>静态多态（早绑定）</h4><p>函数重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态多态（晚绑定）"><a href="#动态多态（晚绑定）" class="headerlink" title="动态多态（晚绑定）"></a>动态多态（晚绑定）</h4><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li></ul><p><strong>注意：</strong></p><ul><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数，解释见：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcjJUU4JTk5JTlBJUU1JTg3JUJEJUU2JTk1JUIwdmlydHVhbCVFNSU4RiVBRiVFNCVCQiVBNSVFNiU5OCVBRiVFNSU4NiU4NSVFOCU4MSU5NCVFNSU4NyVCRCVFNiU5NSVCMGlubGluZSVFNSU5MCU5Nw==" title="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97">虚函数（virtual）可以是内联函数（inline）吗？<i class="fa fa-external-link"></i></span></li></ul><details><summary>动态多态使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                     // 形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p><details><summary>虚析构函数使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();    </span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIyNjAyMzgvYXJ0aWNsZS9kZXRhaWxzLzUzNjEwNDYy" title="https://blog.csdn.net/u012260238/article/details/53610462">CSDN . C++ 中的虚函数、纯虚函数区别和联系<i class="fa fa-external-link"></i></span></p><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 </li><li>虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 </li><li>带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。</li></ul><h3 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h3><ul><li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li></ul><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p><p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><h3 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h3><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h3 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h3><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h3 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h3><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有有定于任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数</li></ul></li></ul><h3 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a>内存分配和管理</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9jaGVucXguZ2l0aHViLmlvLzIwMTQvMDkvMjUvQ3BwLU1lbW9yeS1NYW5hZ2VtZW50Lw==" title="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">C/C++内存管理详解<i class="fa fa-external-link"></i></span> - ShinChan’s Blog</p></blockquote><h4 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h4><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ol><h4 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h4><p>用于分配、释放内存</p><details><summary>malloc、free 使用</summary> <p>申请内存，确认是否申请成功</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">assert(str != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>释放内存后指针置空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></details><h4 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h4><ol><li>new / new[]：完成两件事，先底层调用 malloc 分了配内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><details><summary>new、delete 使用</summary> <p>申请内存，确认是否申请成功</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t = <span class="keyword">new</span> T();     <span class="comment">// 先内存分配 ，再构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t;           <span class="comment">// 先析构函数，再内存释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="定位-new"><a href="#定位-new" class="headerlink" title="定位 new"></a>定位 new</h4><p>定位 new（placement new）允许我们向 new 传递额外的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (palce_address) type</span><br><span class="line"><span class="keyword">new</span> (palce_address) type (initializers)</span><br><span class="line"><span class="keyword">new</span> (palce_address) type [size]</span><br><span class="line"><span class="keyword">new</span> (palce_address) type [size] &#123; braced initializer <span class="built_in">list</span> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>palce_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h3 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h3><p><span class="exturl" data-url="aHR0cHM6Ly9pc29jcHAub3JnL3dpa2kvZmFxL2ZyZWVzdG9yZS1tZ210I2RlbGV0ZS10aGlz" title="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this">Is it legal (and moral) for a member function to say delete this?<i class="fa fa-external-link"></i></span></p><p>合法，但：</p><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol><h3 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvMGE1ODRhYTEzZjgwNGYzZWE3MmI0NDJhMDY1YTc2MTg=" title="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618">如何定义一个只能在堆上（栈上）生成对象的类?<i class="fa fa-external-link"></i></span></p><h4 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h4><p>方法：将析构函数设置为私有</p><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p><h4 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h4><p>方法：将 new 和 delete 重载为私有</p><p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2xleGlhby9hcnRpY2xlL2RldGFpbHMvNTY3NzMwMzk=" title="https://blog.csdn.net/haolexiao/article/details/56773039">C++11及C++14标准的智能指针<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4MTk4MjUyOTQvYXJ0aWNsZS9kZXRhaWxzLzUyMTM5MzI4" title="https://blog.csdn.net/a819825294/article/details/52139328">C++ 智能指针<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMTA0NjY2Lw==" title="http://blog.jobbole.com/104666/">使用 C++11 智能指针时要避开的 10 大错误<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h4><p>头文件：<code>#include &lt;memory&gt;</code></p><h4 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps (<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))；</span><br></pre></td></tr></table></figure><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h4><ol><li>shared_ptr</li><li>unique_ptr</li><li>weak_ptr</li><li>auto_ptr（被 C++11 弃用）</li></ol><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li><li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li></ul><h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p><ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li></ul><h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p><ul><li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li></ul><h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p><ul><li>unique_ptr 用于取代 auto_ptr</li></ul><h5 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h5><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p><h5 id="auto-ptr-与-unique-ptr-比较"><a href="#auto-ptr-与-unique-ptr-比较" class="headerlink" title="auto_ptr 与 unique_ptr 比较"></a>auto_ptr 与 unique_ptr 比较</h5><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li><li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li></ul><h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vemgtQ04vbGlicmFyeS81ZjZjOWY4aC5hc3B4" title="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx">MSDN . 强制转换运算符<i class="fa fa-external-link"></i></span></p><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ29vZGhhY2tlci9hcmNoaXZlLzIwMTEvMDcvMjAvMjExMTk5Ni5odG1s" title="https://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html">C++类型转换总结<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><ul><li>用于非多态类型的转换</li><li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li><li>通常用于转换数值数据类型（如 float -&gt; int）</li><li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li></ul><blockquote><p>向上转换是一种隐式转换。</p></blockquote><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li><li>执行行运行时类型检查</li><li>只适用于指针或引用</li><li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><ul><li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li></ul><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><ul><li>用于位的简单重新解释</li><li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li><li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li><li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li><li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li></ul><h4 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h4><ul><li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li></ul><details><summary>bad_cast 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Circle&amp; ref_circle = <span class="keyword">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> (bad_cast b) &#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught: "</span> &lt;&lt; b.what();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><h4 id="dynamic-cast-1"><a href="#dynamic-cast-1" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li></ul><h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><h4 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h4><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：<code>typeinfo</code></li></ul><details><summary>typeid、type_info 使用</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>                       // 能飞的</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>= <span class="number">0</span>;     <span class="comment">// 起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>= <span class="number">0</span>;        <span class="comment">// 降落</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> :</span> <span class="keyword">public</span> Flyable         <span class="comment">// 鸟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foraging</span><span class="params">()</span> </span>&#123;...&#125;           <span class="comment">// 觅食</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> :</span> <span class="keyword">public</span> Flyable        <span class="comment">// 飞机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">carry</span><span class="params">()</span> </span>&#123;...&#125;              <span class="comment">// 运输</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> take <span class="title">off</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info &amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">doSomething</span><span class="params">(Flyable *obj)</span>                 <span class="comment">// 做些事情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;takeoff();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*obj).name() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 输出传入对象类型（"class Bird" or "class Plane"）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(*obj) == <span class="keyword">typeid</span>(Bird))            <span class="comment">// 判断对象类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bird *bird = <span class="keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="comment">// 对象转化</span></span><br><span class="line">        bird-&gt;foraging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj-&gt;land();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h3 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h3><ol><li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li><li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li><li>尽可能使用 const</li><li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li><li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li><li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li><li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li><li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li><li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li><li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li><li>在 <code>operator=</code> 中处理 “自我赋值”</li><li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li><li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li><li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li><li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li><li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li><li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li><li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li><li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li><li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li><li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li><li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li><li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li><li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li><li>考虑写一个不抛异常的 swap 函数</li><li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li><li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li><li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li><li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li><li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li><li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能过够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li><li>确定你的 public 继承塑模出 is-a 关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li><li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li><li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li><li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li><li>绝不重新定义继承而来的 non-virtual 函数</li><li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li></ol><h3 id="Google-C-Style-Guide"><a href="#Google-C-Style-Guide" class="headerlink" title="Google C++ Style Guide"></a>Google C++ Style Guide</h3><blockquote><p>英文：<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL3N0eWxlZ3VpZGUvY3BwZ3VpZGUuaHRtbA==" title="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide<i class="fa fa-external-link"></i></span><br>中文：<span class="exturl" data-url="aHR0cHM6Ly96aC1nb29nbGUtc3R5bGVndWlkZS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvZ29vZ2xlLWNwcC1zdHlsZWd1aWRlL2NvbnRlbnRzLw==" title="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">C++ 风格指南<i class="fa fa-external-link"></i></span></p></blockquote><details><summary>Google C++ Style Guide 图</summary><p><img src="/images/imageProgramC/interview/GoogleCppStyleGuide.png" alt="Google C++ Style Guide"></p><blockquote><p>图片来源于：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZvaWRjY2MvYXJ0aWNsZS9kZXRhaWxzLzM3NTk5MjAz" title="https://blog.csdn.net/voidccc/article/details/37599203">CSDN . 一张图总结Google C++编程规范(Google C++ Style Guide)<i class="fa fa-external-link"></i></span></p></blockquote></details><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="STL-索引"><a href="#STL-索引" class="headerlink" title="STL 索引"></a>STL 索引</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RM" title="https://github.com/huihut/interview/tree/master/STL">STL 方法含义索引<i class="fa fa-external-link"></i></span></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTU2MDcxNjZmYjlhMDFjYjI1NmQ1MDE=" title="https://juejin.im/post/5a5607166fb9a01cb256d501">C++ STL容器总结<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h3><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI2FycmF5" title="https://github.com/huihut/interview/tree/master/STL#array">array<i class="fa fa-external-link"></i></span></td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持快速随机访问</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3ZlY3Rvcg==" title="https://github.com/huihut/interview/tree/master/STL#vector">vector<i class="fa fa-external-link"></i></span></td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1)<br>头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持快速随机访问</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI2xpc3Q=" title="https://github.com/huihut/interview/tree/master/STL#list">list<i class="fa fa-external-link"></i></span></td><td>双向链表</td><td>插入、删除 O(1)<br>随机读改 O(n)</td><td>无序</td><td>可重复</td><td>支持快速增删</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI2RlcXVl" title="https://github.com/huihut/interview/tree/master/STL#deque">deque<i class="fa fa-external-link"></i></span></td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3N0YWNr" title="https://github.com/huihut/interview/tree/master/STL#stack">stack<i class="fa fa-external-link"></i></span></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3F1ZXVl" title="https://github.com/huihut/interview/tree/master/STL#queue">queue<i class="fa fa-external-link"></i></span></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3ByaW9yaXR5X3F1ZXVl" title="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue<i class="fa fa-external-link"></i></span></td><td>vector + max-heap</td><td>插入、删除 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3NldA==" title="https://github.com/huihut/interview/tree/master/STL#set">set<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI211bHRpc2V0" title="https://github.com/huihut/interview/tree/master/STL#multiset">multiset<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI21hcA==" title="https://github.com/huihut/interview/tree/master/STL#map">map<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI211bHRpbWFw" title="https://github.com/huihut/interview/tree/master/STL#multimap">multimap<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td>hash_set</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>hash_multiset</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td>hash_map</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>hash_multimap</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><h3 id="STL-算法"><a href="#STL-算法" class="headerlink" title="STL 算法"></a>STL 算法</h3><table><thead><tr><th>算法</th><th>底层算法</th><th>时间复杂度</th><th>可不可重复</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9hbGdvcml0aG0vZmluZC8=" title="http://www.cplusplus.com/reference/algorithm/find/">find<i class="fa fa-external-link"></i></span></td><td>顺序查找</td><td>O(n)</td><td>可重复</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2djYy1taXJyb3IvZ2NjL2Jsb2IvbWFzdGVyL2xpYnN0ZGMrKy12My9pbmNsdWRlL2JpdHMvc3RsX2FsZ28uaCNMNDgwOA==" title="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808">sort<i class="fa fa-external-link"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50cm9zb3J0" title="https://en.wikipedia.org/wiki/Introsort">内省排序<i class="fa fa-external-link"></i></span></td><td>O(n*log<sub>2</sub>n)</td><td>可重复</td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h4 id="顺序栈（Sequence-Stack）"><a href="#顺序栈（Sequence-Stack）" class="headerlink" title="顺序栈（Sequence Stack）"></a>顺序栈（Sequence Stack）</h4><p><a href="DataStructure/SqStack.cpp">SqStack.cpp</a></p><details><summary>顺序栈数据结构和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqSrack;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/SqStack.png" alt></p></details><h4 id="队列（Sequence-Queue）"><a href="#队列（Sequence-Queue）" class="headerlink" title="队列（Sequence Queue）"></a>队列（Sequence Queue）</h4><details><summary>队列数据结构</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType * elem;</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> maxSize;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></details><h5 id="非循环队列"><a href="#非循环队列" class="headerlink" title="非循环队列"></a>非循环队列</h5><details><summary>非循环队列图片</summary><p><img src="/images/imageProgramC/interview/SqQueue.png" alt></p><p><code>SqQueue.rear++</code></p></details><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><details><summary>循环队列图片</summary><p><img src="/images/imageProgramC/interview/SqLoopStack.png" alt></p><p><code>SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize</code></p></details><h4 id="顺序表（Sequence-List）"><a href="#顺序表（Sequence-List）" class="headerlink" title="顺序表（Sequence List）"></a>顺序表（Sequence List）</h4><p><a href="DataStructure/SqList.cpp">SqList.cpp</a></p><details><summary>顺序表数据结构和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/SqList.png" alt></p></details><h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><p><a href="DataStructure/LinkList.cpp">LinkList.cpp</a></p><p><a href="DataStructure/LinkList_with_head.cpp">LinkList_with_head.cpp</a></p><details><summary>链式数据结构</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure></details><h4 id="链队列（Link-Queue）"><a href="#链队列（Link-Queue）" class="headerlink" title="链队列（Link Queue）"></a>链队列（Link Queue）</h4><details><summary>链队列图片</summary><p><img src="/images/imageProgramC/interview/LinkQueue.png" alt></p></details><h4 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h4><h5 id="单链表（Link-List）"><a href="#单链表（Link-List）" class="headerlink" title="单链表（Link List）"></a>单链表（Link List）</h5><details><summary>单链表图片</summary><p><img src="/images/imageProgramC/interview/LinkList.png" alt></p></details><h5 id="双向链表（Du-Link-List）"><a href="#双向链表（Du-Link-List）" class="headerlink" title="双向链表（Du-Link-List）"></a>双向链表（Du-Link-List）</h5><details><summary>双向链表图片</summary><p><img src="/images/imageProgramC/interview/DuLinkList.png" alt></p></details><h5 id="循环链表（Cir-Link-List）"><a href="#循环链表（Cir-Link-List）" class="headerlink" title="循环链表（Cir-Link-List）"></a>循环链表（Cir-Link-List）</h5><details><summary>循环链表图片</summary><p><img src="/images/imageProgramC/interview/CirLinkList.png" alt></p></details><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="DataStructure/HashTable.cpp">HashTable.cpp</a></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>哈希函数：<code>H(key): K -&gt; D , key ∈ K</code></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>直接定址法</li><li>除留余数法</li><li>数字分析法</li><li>折叠法</li><li>平方取中法</li></ul><h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><ul><li>链地址法：key 相同的用单链表链接</li><li>开放定址法<ul><li>线性探测法：key 相同 -&gt; 放到 key 的下一个位置，<code>Hi = (H(key) + i) % m</code></li><li>二次探测法：key 相同 -&gt; 放到 <code>Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2）</code></li><li>随机探测法：<code>H = (H(key) + 伪随机数) % m</code></li></ul></li></ul><h4 id="线性探测的哈希表数据结构"><a href="#线性探测的哈希表数据结构" class="headerlink" title="线性探测的哈希表数据结构"></a>线性探测的哈希表数据结构</h4><details><summary>线性探测的哈希表数据结构和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">KeyType key;</span><br><span class="line">&#125;RcdType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">RcdType *rcd;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">bool</span> *tag;</span><br><span class="line">&#125;HashTable;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/HashTable.png" alt></p></details><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>函数直接或间接地调用自身</p><h4 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h4><ul><li>分治法<ul><li>问题的分解</li><li>问题规模的分解</li></ul></li><li>折半查找（递归）</li><li>归并查找（递归）</li><li>快速排序（递归）</li></ul><h4 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h4><ul><li>迭代：反复利用变量旧值推出新值</li><li>折半查找（迭代）</li><li>归并查找（迭代）</li></ul><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><h5 id="头尾链表存储表示"><a href="#头尾链表存储表示" class="headerlink" title="头尾链表存储表示"></a>头尾链表存储表示</h5><details><summary>广义表的头尾链表存储表示和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的头尾链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom;</span><br><span class="line">        <span class="comment">// atom 是原子结点的值域，AtomType 由用户定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="comment">// ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾</span></span><br><span class="line">    &#125; a;</span><br><span class="line">&#125; *GList, GLNode;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/GeneralizedList1.png" alt></p></details><h5 id="扩展线性链表存储表示"><a href="#扩展线性链表存储表示" class="headerlink" title="扩展线性链表存储表示"></a>扩展线性链表存储表示</h5><details><summary>扩展线性链表存储表示和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的扩展线性链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom; <span class="comment">// 原子结点的值域</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">hp</span>;</span> <span class="comment">// 表结点的表头指针</span></span><br><span class="line">    &#125; a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">tp</span>;</span></span><br><span class="line">    <span class="comment">// 相当于线性链表的 next，指向下一个元素结点</span></span><br><span class="line">&#125; *GList1, GLNode1;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/GeneralizedList2.png" alt></p></details><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><a href="DataStructure/BinaryTree.cpp">BinaryTree.cpp</a></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i &gt;= 1）</li><li>深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k &gt;= 1）</li><li>度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1</li><li>有 n 个结点的完全二叉树深度 k = ⌊ log<sub>2</sub>(n) ⌋ + 1 </li><li>对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点<ol><li>若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋</li><li>若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i</li><li>若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1</li></ol></li></ol><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><details><summary>二叉树数据结构</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure></details><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><details><summary>二叉树顺序存储图片</summary><p><img src="/images/imageProgramC/interview/SqBinaryTree.png" alt></p></details><h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><details><summary>二叉树链式存储图片</summary><p><img src="/images/imageProgramC/interview/LinkBinaryTree.png" alt></p></details><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul><li>先序遍历</li><li>中序遍历</li><li>后续遍历</li><li>层次遍历</li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>满二叉树</li><li>完全二叉树（堆）<ul><li>大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右</li><li>小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右</li></ul></li><li>二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右</li><li>平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1</li><li>最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：<ul><li>LL型：根的左孩子右旋</li><li>RR型：根的右孩子左旋</li><li>LR型：根的左孩子左旋，再右旋</li><li>RL型：右孩子的左子树，先右旋，再左旋</li></ul></li></ul><h3 id="其他树及森林"><a href="#其他树及森林" class="headerlink" title="其他树及森林"></a>其他树及森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul><li>双亲表示法</li><li>双亲孩子表示法</li><li>孩子兄弟表示法</li></ul><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>一种不相交的子集所构成的集合 S = {S1, S2, …, Sn}</p><h4 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h4><h5 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h5><ul><li>| 左子树树高 - 右子树树高 | &lt;= 1</li><li>平衡二叉树必定是二叉搜索树，反之则不一定</li><li>最小二叉平衡树的节点的公式：<code>F(n)=F(n-1)+F(n-2)+1</code> （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）</li></ul><details><summary>平衡二叉树图片</summary><p><img src="/images/imageProgramC/interview/Self-balancingBinarySearchTree.png" alt></p></details><h5 id="最小失衡树"><a href="#最小失衡树" class="headerlink" title="最小失衡树"></a>最小失衡树</h5><p>平衡二叉树插入新结点导致失衡的子树</p><p>调整：</p><ul><li>LL 型：根的左孩子右旋</li><li>RR 型：根的右孩子左旋</li><li>LR 型：根的左孩子左旋，再右旋</li><li>RL 型：右孩子的左子树，先右旋，再左旋</li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h5 id="红黑树的特征是什么？"><a href="#红黑树的特征是什么？" class="headerlink" title="红黑树的特征是什么？"></a>红黑树的特征是什么？</h5><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是 NIL 节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）</li></ol><h5 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h5><ol><li>变色</li><li>左旋</li><li>右旋</li></ol><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul><li>关联数组：如 STL 中的 map、set</li></ul><h5 id="红黑树、B-树、B-树的区别？"><a href="#红黑树、B-树、B-树的区别？" class="headerlink" title="红黑树、B 树、B+ 树的区别？"></a>红黑树、B 树、B+ 树的区别？</h5><ul><li>红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些</li><li>B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。</li></ul><h4 id="B-树（B-tree）、B-树（B-tree）"><a href="#B-树（B-tree）、B-树（B-tree）" class="headerlink" title="B 树（B-tree）、B+ 树（B+-tree）"></a>B 树（B-tree）、B+ 树（B+-tree）</h4><details><summary>B 树、B+ 树图片</summary><p><img src="https://i.stack.imgur.com/l6UyF.png" alt="B 树（B-tree）、B+ 树（B+-tree）"></p></details><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>一般化的二叉查找树（binary search tree）</li><li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li></ul><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ul><li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li></ul><h5 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h5><ul><li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li><li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li></ul><h5 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h5><p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p><h5 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h5><ul><li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li><li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li></ul><blockquote><p>B 树、B+ 树区别来自：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODcwMjE4L2RpZmZlcmVuY2VzLWJldHdlZW4tYi10cmVlcy1hbmQtYi10cmVlcw==" title="https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees">differences-between-b-trees-and-b-trees<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaXZpY3Rvci9wLzU4NDkwNjEuaHRtbA==" title="https://www.cnblogs.com/ivictor/p/5849061.html">B树和B+树的区别<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h4><details><summary>八叉树图片</summary><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png" alt></p></details><p>八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><ul><li>三维计算机图形</li><li>最邻近搜索</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最差时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td><a href="Algorithm/BubbleSort.h">冒泡排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td><a href="Algorithm/SelectionSort.h">选择排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>数组不稳定、链表稳定</td></tr><tr><td><a href="Algorithm/InsertSort.h">插入排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td><a href="Algorithm/QuickSort.h">快速排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n<sup>2</sup>)</td><td>O(log<sub>2</sub>n)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/HeapSort.cpp">堆排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n*log<sub>2</sub>n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/MergeSort.h">归并排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n*log<sub>2</sub>n)</td><td>O(n)</td><td>稳定</td></tr><tr><td><a href="Algorithm/ShellSort.h">希尔排序</a></td><td>O(n*log<sup>2</sup>n)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/CountSort.cpp">计数排序</a></td><td>O(n+m)</td><td>O(n+m)</td><td>O(n+m)</td><td>稳定</td></tr><tr><td><a href="Algorithm/BucketSort.cpp">桶排序</a></td><td>O(n)</td><td>O(n)</td><td>O(m)</td><td>稳定</td></tr><tr><td><a href="Algorithm/RadixSort.h">基数排序</a></td><td>O(k*n)</td><td>O(n<sup>2</sup>)</td><td></td><td>稳定</td></tr></tbody></table><blockquote><ul><li>均按从小到大排列</li><li>k：代表数值中的 “数位” 个数</li><li>n：代表数据规模</li><li>m：代表数据的最大值减最小值</li><li>来自：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JThFJTkyJUU1JUJBJThGJUU3JUFFJTk3JUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">wikipedia . 排序算法<i class="fa fa-external-link"></i></span></li></ul></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><table><thead><tr><th>查找算法</th><th>平均时间复杂度</th><th>空间复杂度</th><th>查找条件</th></tr></thead><tbody><tr><td><a href="Algorithm/SequentialSearch.h">顺序查找</a></td><td>O(n)</td><td>O(1)</td><td>无序或有序</td></tr><tr><td><a href="Algorithm/BinarySearch.h">二分查找（折半查找）</a></td><td>O(log<sub>2</sub>n)</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="Algorithm/InsertionSearch.h">插值查找</a></td><td>O(log<sub>2</sub>(log<sub>2</sub>n))</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="Algorithm/FibonacciSearch.cpp">斐波那契查找</a></td><td>O(log<sub>2</sub>n)</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="DataStructure/HashTable.cpp">哈希查找</a></td><td>O(1)</td><td>O(n)</td><td>无序或有序</td></tr><tr><td><a href="Algorithm/BSTSearch.h">二叉查找树（二叉搜索树查找）</a></td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr><tr><td><a href="DataStructure/RedBlackTree.cpp">红黑树</a></td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr><tr><td>2-3树</td><td>O(log<sub>2</sub>n - log<sub>3</sub>n)</td><td></td><td></td></tr><tr><td>B树/B+树</td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr></tbody></table><h3 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h3><table><thead><tr><th>图搜索算法</th><th>数据结构</th><th>遍历时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUI5JUJGJUU1JUJBJUE2JUU0JUJDJTk4JUU1JTg1JTg4JUU2JTkwJTlDJUU3JUI0JUEy" title="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS广度优先搜索<i class="fa fa-external-link"></i></span></td><td>邻接矩阵<br>邻接链表</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUI3JUIxJUU1JUJBJUE2JUU0JUJDJTk4JUU1JTg1JTg4JUU2JTkwJTlDJUU3JUI0JUEy" title="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">DFS深度优先搜索<i class="fa fa-external-link"></i></span></td><td>邻接矩阵<br>邻接链表</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td></tr></tbody></table><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><table><thead><tr><th>算法</th><th>思想</th><th>应用</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg4JTg2JUU2JUIyJUJCJUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法<i class="fa fa-external-link"></i></span></td><td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvUHJvYmxlbXMvUm91bmRSb2JpblByb2JsZW0=" title="https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem">循环赛日程安排问题<i class="fa fa-external-link"></i></span>、排序算法（快速排序、归并排序）</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThBJUE4JUU2JTgwJTgxJUU4JUE3JTg0JUU1JTg4JTky" title="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划<i class="fa fa-external-link"></i></span></td><td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvUHJvYmxlbXMvS25hcHNhY2tQcm9ibGVt" title="https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem">背包问题<i class="fa fa-external-link"></i></span>、斐波那契数列</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI0JUFBJUU1JUJGJTgzJUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">贪心法<i class="fa fa-external-link"></i></span></td><td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</td><td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</td></tr></tbody></table><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><h3 id="Single-Problem"><a href="#Single-Problem" class="headerlink" title="Single Problem"></a>Single Problem</h3><ul><li><a href="Problems/ChessboardCoverageProblem">Chessboard Coverage Problem（棋盘覆盖问题）</a></li><li><a href="Problems/KnapsackProblem">Knapsack Problem（背包问题）</a></li><li><a href="Problems/NeumannNeighborProblem">Neumann Neighbor Problem（冯诺依曼邻居问题）</a></li><li><a href="Problems/RoundRobinProblem">Round Robin Problem（循环赛日程安排问题）</a></li><li><a href="Problems/TubingProblem">Tubing Problem（输油管道问题）</a></li></ul><h3 id="Leetcode-Problems"><a href="#Leetcode-Problems" class="headerlink" title="Leetcode Problems"></a>Leetcode Problems</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhb2VsL2xlZXRjb2Rl" title="https://github.com/haoel/leetcode">Github . haoel/leetcode<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BlenkvTGVldENvZGU=" title="https://github.com/pezy/LeetCode">Github . pezy/LeetCode<i class="fa fa-external-link"></i></span></li></ul><h3 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a>剑指 Offer</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poZWRhaGh0L0NvZGluZ0ludGVydmlld0NoaW5lc2Uy" title="https://github.com/zhedahht/CodingInterviewChinese2">Github . zhedahht/CodingInterviewChinese2<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dhdGllbWUvQ29kaW5nSW50ZXJ2aWV3cw==" title="https://github.com/gatieme/CodingInterviews">Github . gatieme/CodingInterviews<i class="fa fa-external-link"></i></span></li></ul><h3 id="Cracking-the-Coding-Interview-程序员面试金典"><a href="#Cracking-the-Coding-Interview-程序员面试金典" class="headerlink" title="Cracking the Coding Interview 程序员面试金典"></a>Cracking the Coding Interview 程序员面试金典</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NhcmVlcmN1cC9jdGNp" title="https://github.com/careercup/ctci">Github . careercup/ctci<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3RhL2NyYWNraW5nLXRoZS1jb2RpbmctaW50ZXJ2aWV3" title="https://www.nowcoder.com/ta/cracking-the-coding-interview">牛客网 . 程序员面试金典<i class="fa fa-external-link"></i></span></li></ul><h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2FjdGl2aXR5L29q" title="https://www.nowcoder.com/activity/oj">牛客网 . 在线编程专题<i class="fa fa-external-link"></i></span></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjA1NDkyNQ==" title="https://zhuanlan.zhihu.com/p/26054925">【构建操作系统】进程间通信<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd6aGVuMjA5L2FydGljbGUvZGV0YWlscy83ODI0OTI4OA==" title="https://blog.csdn.net/wangzhen209/article/details/78249288">C++ 高性能服务器网络框架设计细节<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxNTE2ODI3L2Fuc3dlci81MzU3Njc1NA==" title="https://www.zhihu.com/question/21516827/answer/53576754">epoll编程，如何实现高并发服务器开发？<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODU1MjU5MA==" title="https://zhuanlan.zhihu.com/p/38552590">如何实现高并发服务器开发<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3dlaWZ1L2FydGljbGUvZGV0YWlscy80NjgzNTQzNw==" title="https://blog.csdn.net/luoweifu/article/details/46835437">编程思想之多线程与多进程(4)——C++中的多线程<i class="fa fa-external-link"></i></span></p></blockquote><p>对于有线程系统：</p><ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul><p>对于无线程系统：</p><ul><li>进程是资源调度、分配的独立单位</li></ul><h4 id="进程之间的通信方式以及优缺点"><a href="#进程之间的通信方式以及优缺点" class="headerlink" title="进程之间的通信方式以及优缺点"></a>进程之间的通信方式以及优缺点</h4><ul><li>管道（PIPE）<ul><li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信<ul><li>优点：可以实现任意关系的进程间的通信</li><li>缺点：<ol><li>长期存于系统中，使用不当容易出错</li><li>缓冲区有限</li></ol></li></ul></li><li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul><li>优点：简单方便</li><li>缺点：<ol><li>局限于单向通信 </li><li>只能创建在它的进程以及其有亲缘关系的进程之间</li><li>缓冲区有限</li></ol></li></ul></li></ul></li><li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问<ul><li>优点：可以同步进程</li><li>缺点：信号量有限</li></ul></li><li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识<ul><li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li><li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul></li><li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul><li>优点：无须复制，快捷，信息量大</li><li>缺点：<ol><li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li><li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ol></li></ul></li><li>套接字（Socket）：可用于不同及其间的进程通信<ul><li>优点：<ol><li>传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>传输数据时间短，性能高</li><li>适合于客户端和服务器端之间信息实时交互</li><li>可以加密,数据安全性强</li></ol></li><li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li></ul></li></ul><h4 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h4><ul><li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul><li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持着是否已经释放锁。</li><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)<ul><li>无名线程信号量</li><li>命名线程信号量</li></ul></li><li>信号机制(Signal)：类似进程间的信号处理</li><li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li></ul><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  </p><blockquote><p>进程之间的通信方式以及优缺点来源于：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VqaWFmZWlfbmpnY3h5L2FydGljbGUvZGV0YWlscy83NzA5ODk3Nw==" title="http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977">进程线程面试题总结<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="进程之间私有和共享的资源"><a href="#进程之间私有和共享的资源" class="headerlink" title="进程之间私有和共享的资源"></a>进程之间私有和共享的资源</h4><ul><li>私有：地址空间、堆、全局变量、栈、寄存器</li><li>共享：代码段，公共数据，进程目录，进程 ID</li></ul><h4 id="线程之间私有和共享的资源"><a href="#线程之间私有和共享的资源" class="headerlink" title="线程之间私有和共享的资源"></a>线程之间私有和共享的资源</h4><ul><li>私有：线程栈，寄存器，程序寄存器</li><li>共享：堆，地址空间，全局变量，静态变量</li></ul><h4 id="多进程与多线程间的对比、优劣与选择"><a href="#多进程与多线程间的对比、优劣与选择" class="headerlink" title="多进程与多线程间的对比、优劣与选择"></a>多进程与多线程间的对比、优劣与选择</h4><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table><thead><tr><th>对比维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td><td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU 利用率低</td><td>占用内存少，切换简单，CPU 利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度很快</td><td>线程占优</td></tr><tr><td>编程、调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会互相影响</td><td>一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布式</td><td>进程占优</td></tr></tbody></table><h5 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h5><table><thead><tr><th>优劣</th><th>多进程</th><th>多线程</th></tr></thead><tbody><tr><td>优点</td><td>编程、调试简单，可靠性较高</td><td>创建、销毁、切换速度快，内存、资源占用小</td></tr><tr><td>缺点</td><td>创建、销毁、切换速度慢，内存、资源占用大</td><td>编程、调试复杂，可靠性较差</td></tr></tbody></table><h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><ul><li>需要频繁创建销毁的优先用线程</li><li>需要进行大量计算的优先使用线程</li><li>强相关的处理用线程，弱相关的处理用进程</li><li>可能要扩展到多机分布的用进程，多核分布的用线程</li><li>都满足需求的情况下，用你最熟悉、最拿手的方式</li></ul><blockquote><p>多进程与多线程间的对比、优劣与选择来自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2hlbmdsb25nNjY2L2FydGljbGUvZGV0YWlscy84NTU3MjE1" title="https://blog.csdn.net/lishenglong666/article/details/8557215">多线程还是多进程的选择及区别<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>将应用程序分为多个、独立的、单纯和的进程，它们运行在同一时刻，就像你可以同时进行网页浏览和文字处理，这些独立的进程可以通过所有常规的进程间通信渠道互相传递信息（信号、套接字、文件、管道等）。</li><li>操作系统在进程间提供的附加保护操作和更高级别的通信机制，意味着可以比线程更容易地编写安全的并发代码。</li><li>使用独立的进程实现并发，可以在网络连接的不同的机器上运行独立的进程，虽然这增加了通信成本，但在一个精心设计的系统上，这可能是一个提高并行可用行和提高性能的低成本方法。</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>这种进程之间的通信通常设置复杂，或是速度较慢，或两者兼备，因为操作系统通常在进程间提供了大量的保护，以避免一个进程不小心修改了属于另一个进程的数据。</li><li>运行多个进和所需的固有开销：启动进程需要时间，操作系统必须投入内部资源来管理进程。</li></ul><h4 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul><li>每个线程相互独立运行，且每个线程可以运行不同的指令序列。但进程中的所有的线程都共享相同的地址空间，并且从所有线程中访问大部分数据——全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。</li><li>共享的地址空间，以及缺少线程间的数据保护，使得使用多线程相关的开销远小于使用多进程，因为操作系统有更少的簿记要做。</li></ul><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul><li><p>虽然通常可以在进程之间共享内存，但这难以建立并且通常难以管理，因为同一数据的内存地址在不同的进程中也不尽相同。</p></li><li><p>共享内存的灵活性是有代价的：如果数据要被多个线程访问，那么必须确保当每个线程访问时所看到的数据是一致的。</p></li></ul><h3 id="Linux-内核的同步方式"><a href="#Linux-内核的同步方式" class="headerlink" title="Linux 内核的同步方式"></a>Linux 内核的同步方式</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</p><h4 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4><ul><li>原子操作</li><li>信号量（semaphore）</li><li>读写信号量（rw_semaphore）</li><li>自旋锁（spinlock）</li><li>大内核锁（BKL，Big Kernel Lock）</li><li>读写锁（rwlock）</li><li>大读者锁（brlock-Big Reader Lock）</li><li>读-拷贝修改(RCU，Read-Copy Update)</li><li>顺序锁（seqlock）</li></ul><blockquote><p>来自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLXN5bmNoL3BhcnQxLw==" title="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/">Linux 内核的同步机制，第 1 部分<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLXN5bmNoL3BhcnQyLw==" title="https://www.ibm.com/developerworks/cn/linux/l-synch/part2/">Linux 内核的同步机制，第 2 部分<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><ul><li>系统资源不足</li><li>资源分配不当</li><li>进程运行推进顺序不合适</li></ul><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ul><li>互斥</li><li>请求和保持</li><li>不剥夺</li><li>环路</li></ul><h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ul><li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li><li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li><li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li><li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li><li>有序资源分配法</li><li>银行家算法</li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li>Windows：FCB 表 + FAT + 位图</li><li>Unix：inode + 混合索引 + 成组链接</li></ul><h3 id="主机字节序与网络字节序"><a href="#主机字节序与网络字节序" class="headerlink" title="主机字节序与网络字节序"></a>主机字节序与网络字节序</h3><h4 id="主机字节序（CPU-字节序）"><a href="#主机字节序（CPU-字节序）" class="headerlink" title="主机字节序（CPU 字节序）"></a>主机字节序（CPU 字节序）</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：</p><ul><li>大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址</li><li>小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址</li></ul><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p>32 位整数 <code>0x12345678</code> 是从起始位置为 <code>0x00</code> 的地址开始存放，则：</p><table><thead><tr><th>内存地址</th><th>0x00</th><th>0x01</th><th>0x02</th><th>0x03</th></tr></thead><tbody><tr><td>大端</td><td>12</td><td>34</td><td>56</td><td>78</td></tr><tr><td>小端</td><td>78</td><td>56</td><td>34</td><td>12</td></tr></tbody></table><details><summary>大端小端图片</summary><p><img src="/images/imageProgramC/interview/CPU-Big-Endian.svg.png" alt="大端序"><br><img src="/images/imageProgramC/interview/CPU-Little-Endian.svg.png" alt="小端序"></p></details><h5 id="判断大端小端"><a href="#判断大端小端" class="headerlink" title="判断大端小端"></a>判断大端小端</h5><details><summary>判断大端小端</summary><p>可以这样判断自己 CPU 字节序是大端还是小端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*((<span class="keyword">char</span>*)&amp;i) == <span class="number">0x12</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"小端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h5 id="各架构处理器的字节序"><a href="#各架构处理器的字节序" class="headerlink" title="各架构处理器的字节序"></a>各架构处理器的字节序</h5><ul><li>x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；</li><li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；</li><li>ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。</li></ul><h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保重数据在不同主机之间传输时能够被正确解释。</p><p>网络字节顺序采用：大端（Big Endian）排列方式。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li>全局置换：在整个内存空间置换</li><li>局部置换：在本进程中进行置换</li></ul><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>全局：</p><ul><li>工作集算法</li><li>缺页率置换算法</li></ul><p>局部：</p><ul><li>最佳置换算法（OPT）</li><li>先进先出置换算法（FIFO）</li><li>最近最久未使用（LRU）算法</li><li>时钟（Clock）置换算法</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机经网络体系结构：</p><p><img src="/images/imageProgramC/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机经网络体系结构"></p><h3 id="各层作用及协议"><a href="#各层作用及协议" class="headerlink" title="各层作用及协议"></a>各层作用及协议</h3><table><thead><tr><th>分层</th><th>作用</th><th>协议</th></tr></thead><tbody><tr><td>物理层</td><td>通过媒介传输比特，确定机械及电气规范（比特 Bit）</td><td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td></tr><tr><td>数据链路层</td><td>将比特组装成帧和点到点的传递（帧 Frame）</td><td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td></tr><tr><td>网络层</td><td>负责数据包从源到宿的传递和网际互连（包 Packet）</td><td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td></tr><tr><td>运输层</td><td>提供端到端的可靠报文传递和错误恢复（ 段Segment）</td><td>TCP、UDP、SPX</td></tr><tr><td>会话层</td><td>建立、管理和终止会话（会话协议数据单元 SPDU）</td><td>NFS、SQL、NETBIOS、RPC</td></tr><tr><td>表示层</td><td>对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）</td><td>JPEG、MPEG、ASII</td></tr><tr><td>应用层</td><td>允许访问OSI环境的手段（应用协议数据单元 APDU）</td><td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td></tr></tbody></table><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul><li>传输数据的单位 ———— 比特</li><li>数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点）</li></ul><p>通道：</p><ul><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li><li>双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul><p>通道复用技术：</p><ul><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>主要信道：</p><ul><li>点对点信道</li><li>广播信道</li></ul><h4 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h4><ul><li>数据单元 ———— 帧</li></ul><p>三个基本问题：</p><ul><li>封装成帧：把网络层的 IP 数据报封装成帧，<code>SOH - 数据部分 - EOT</code></li><li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li><li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li></ul><p>点对点协议（Point-to-Point Protocol）：</p><ul><li>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</li></ul><h4 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h4><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li><li>ARP（Address Resolution Protocol，地址解析协议）</li><li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li></ul><h4 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP 网际协议"></a>IP 网际协议</h4><p>IP 地址分类：</p><ul><li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li></ul><table><thead><tr><th>IP 地址类别</th><th>网络号</th><th>网络范围</th><th>主机号</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A 类</td><td>8bit，第一位固定为 0</td><td>0 —— 127</td><td>24bit</td><td>1.0.0.0 —— 127.255.255.255</td></tr><tr><td>B 类</td><td>16bit，前两位固定为  10</td><td>128.0 —— 191.255</td><td>16bit</td><td>128.0.0.0 —— 191.255.255.255</td></tr><tr><td>C  类</td><td>24bit，前三位固定为  110</td><td>192.0.0 —— 223.255.255</td><td>8bit</td><td>192.0.0.0 —— 223.255.255.255</td></tr><tr><td>D  类</td><td>前四位固定为 1110，后面为多播地址</td><td></td><td></td><td></td></tr><tr><td>E  类</td><td>前五位固定为 11110，后面保留为今后所用</td><td></td><td></td><td></td></tr></tbody></table><p>IP 数据报格式：</p><p><img src="/images/imageProgramC/interview/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IP 数据报格式"></p><h4 id="ICMP-网际控制报文协议"><a href="#ICMP-网际控制报文协议" class="headerlink" title="ICMP 网际控制报文协议"></a>ICMP 网际控制报文协议</h4><p>ICMP 报文格式：</p><p><img src="/images/imageProgramC/interview/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="ICMP 报文格式"></p><p>应用：</p><ul><li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性<ul><li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li></ul></li></ul><h4 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h4><ul><li>RIP（Routing Information Protocol，路由信息协议）</li><li>OSPF（Open Sortest Path First，开放最短路径优先）</li></ul><h4 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h4><ul><li>BGP（Border Gateway Protocol，边界网关协议）</li></ul><h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><ul><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li><li>多播路由选择协议</li></ul><h4 id="VPN-和-NAT"><a href="#VPN-和-NAT" class="headerlink" title="VPN 和 NAT"></a>VPN 和 NAT</h4><ul><li>VPN（Virtual Private Network，虚拟专用网）</li><li>NAT（Network Address Translation，网络地址转换）</li></ul><h4 id="路由表包含什么？"><a href="#路由表包含什么？" class="headerlink" title="路由表包含什么？"></a>路由表包含什么？</h4><ol><li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li><li>子网掩码（subnet mask）：用来判断 IP 所属网络</li><li>下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: <code>0.0.0.0</code>, Netmask: <code>0.0.0.0</code>）指向自治系统的出口。</li></ol><p>根据应用和执行的不同，路由表可能含有如下附加信息：</p><ol><li>花费（Cost）：就是数据发送过程中通过路径所需要的花费。</li><li>路由的服务质量</li><li>路由中需要过滤的出/入连接列表</li></ol><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>协议：</p><ul><li>TCP（Transmission Control Protocol，传输控制协议）</li><li>UDP（User Datagram Protocol，用户数据报协议）</li></ul><p>端口：</p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>HTTPS</th><th>SNMP</th></tr></thead><tbody><tr><td>端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>443</td><td>161</td></tr></tbody></table><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li></ul><p>特征：</p><ul><li>面向连接</li><li>只能点对点（一对一）通信</li><li>可靠交互</li><li>全双工通信</li><li>面向字节流</li></ul><p>TCP 如何保证可靠传输：</p><ul><li>确认和超时重传</li><li>数据合理分片和排序</li><li>流量控制</li><li>拥塞控制</li><li>数据校验</li></ul><p>TCP 报文结构</p><p><img src="/images/imageProgramC/interview/TCP%E6%8A%A5%E6%96%87.png" alt="TCP 报文"></p><p>TCP 首部</p><p><img src="/images/imageProgramC/interview/TCP%E9%A6%96%E9%83%A8.png" alt="TCP 首部"></p><p>TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：</p><ul><li>URG：紧急比特（urgent），当 <code>URG＝1</code> 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li><li>ACK：确认比特（Acknowledge）。只有当 <code>ACK＝1</code> 时确认号字段才有效，代表这个封包为确认封包。当 <code>ACK＝0</code> 时，确认号无效。</li><li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li><li>RST：复位比特(Reset)，当 <code>RST＝1</code> 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li><li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li><li>FIN：终止比特(Final)，用来释放一个连接。当 <code>FIN＝1</code> 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li></ul><p>特征：</p><ul><li>无连接</li><li>尽最大努力交付</li><li>面向报文</li><li>没有拥塞控制</li><li>支持一对一、一对多、多对一、多对多的交互通信</li><li>首部开销小</li></ul><p>UDP 报文结构</p><p><img src="/images/imageProgramC/interview/UDP%E6%8A%A5%E6%96%87.png" alt="UDP 报文"></p><p>UDP 首部</p><p><img src="/images/imageProgramC/interview/UDP%E9%A6%96%E9%83%A8.png" alt="UDP 首部"></p><blockquote><p>TCP/UDP 图片来源于：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0plcnJ5QzgwODAvdW5kZXJzdGFuZC10Y3AtdWRw" title="https://github.com/JerryC8080/understand-tcp-udp">https://github.com/JerryC8080/understand-tcp-udp<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h4><ol><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li><li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ol><h4 id="TCP-黏包问题"><a href="#TCP-黏包问题" class="headerlink" title="TCP 黏包问题"></a>TCP 黏包问题</h4><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5><p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li><li>在数据包之间设置边界，如添加特殊符号 <code>\r\n</code> 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 <code>\r\n</code>，则会误判为消息的边界。</li><li>使用更加复杂的应用层协议。</li></ul><h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><details><summary>利用可变窗口进行流量控制</summary><p><img src="/images/imageProgramC/interview/%E5%88%A9%E7%94%A8%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B.png" alt></p></details><h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul><li>慢开始( slow-start )</li><li>拥塞避免( congestion avoidance )</li><li>快重传( fast retransmit )</li><li>快恢复( fast recovery )</li></ul><details><summary>TCP的拥塞控制图</summary><p><img src="/images/imageProgramC/interview/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png" alt><br><img src="/images/imageProgramC/interview/%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt><br><img src="/images/imageProgramC/interview/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p></details><h4 id="TCP-传输连接管理"><a href="#TCP-传输连接管理" class="headerlink" title="TCP 传输连接管理"></a>TCP 传输连接管理</h4><blockquote><p>因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvYmxvYi9tYXN0ZXIvaW1hZ2VzL1RDUC10cmFuc3BvcnQtY29ubmVjdGlvbi1tYW5hZ2VtZW50LnBuZw==" title="https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png">https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png<i class="fa fa-external-link"></i></span></p></blockquote><h5 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h5><p><img src="/images/imageProgramC/interview/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p><p>【TCP 建立连接全过程解释】</p><ol><li>客户端发送 SYN 给服务器，说明客户端请求建立连接；</li><li>服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；</li><li>客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；</li><li>服务端收到客户端的 ACK，连接已建立，可以数据传输。</li></ol><h5 id="TCP-为什么要进行三次握手？"><a href="#TCP-为什么要进行三次握手？" class="headerlink" title="TCP 为什么要进行三次握手？"></a>TCP 为什么要进行三次握手？</h5><p>【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIW1zZy9wb25nYmEva0Y2TzctTUZ4TTAvNVM3eklKNHlxS1VK" title="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ">Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}<i class="fa fa-external-link"></i></span></p></blockquote><p>【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI0ODUzNjMzL2Fuc3dlci8xMTUxNzMzODY=" title="https://www.zhihu.com/question/24853633/answer/115173386">知乎 . TCP 为什么是三次握手，而不是两次或四次？<i class="fa fa-external-link"></i></span></p></blockquote><p>【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvYmxvYi9tYXN0ZXIvaW1hZ2VzL1RDUC10cmFuc3BvcnQtY29ubmVjdGlvbi1tYW5hZ2VtZW50LnBuZw==" title="https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png">《计算机网络（第 7 版）-谢希仁》<i class="fa fa-external-link"></i></span></p></blockquote><h5 id="TCP-四次挥手释放连接"><a href="#TCP-四次挥手释放连接" class="headerlink" title="TCP 四次挥手释放连接"></a>TCP 四次挥手释放连接</h5><p><img src="/images/imageProgramC/interview/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p><p>【TCP 释放连接全过程解释】</p><ol><li>客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li><li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li><li>客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li><li>服务端继续发送之前没发完的数据给客户端；</li><li>服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li><li>客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）；</li><li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。</li></ol><h5 id="TCP-为什么要进行四次挥手？"><a href="#TCP-为什么要进行四次挥手？" class="headerlink" title="TCP 为什么要进行四次挥手？"></a>TCP 为什么要进行四次挥手？</h5><p>【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？</p><p>【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p><p>【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</p><p>【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p><p>【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</p><p>【答案三】</p><ol><li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li><li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li></ol><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L292ZXJzdGFjay9hcnRpY2xlL2RldGFpbHMvODgzMzg5NA==" title="https://blog.csdn.net/overstack/article/details/8833894">Time-wait状态(2MSL)一些理解<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="TCP-有限状态机"><a href="#TCP-有限状态机" class="headerlink" title="TCP 有限状态机"></a>TCP 有限状态机</h4><details><summary>TCP 有限状态机图片</summary><p><img src="/images/imageProgramC/interview/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="TCP 的有限状态机"></p></details><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zMzVkZTEzMjNjZTk=" title="https://www.jianshu.com/p/335de1323ce9">TCP和UDP详解<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hNWNmODFiMWE5NzY=" title="https://www.jianshu.com/p/a5cf81b1a976">HTTP、TCP、UDP详解<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><ul><li>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</li></ul><p>域名：</p><ul><li><code>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}</code>，如：<code>blog.huihut.com</code></li></ul><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><ul><li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li><li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</li></ul><h4 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h4><ul><li><p>TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p></li><li><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。</p></li><li><p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。</p></li><li><p>Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。</p></li></ul><h4 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h4><ul><li>WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问</li></ul><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><ul><li>URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）</li></ul><p>标准格式：</p><ul><li><code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li></ul><p>完整格式：</p><ul><li><code>协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li></ul><blockquote><p>其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项<br>如：<code>https://github.com/huihut/interview#cc</code></p></blockquote><h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p><p>请求方法</p><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>OPTIONS</td><td>请求一些选项信息，允许客户端查看服务器的性能</td></tr><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>HEAD</td><td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>状态码（Status-Code）</p><ul><li>1xx：表示通知信息，如请求收到了或正在进行处理<ul><li>100 Continue：继续，客户端应继续其请求</li><li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li></ul></li><li>2xx：表示成功，如接收或知道了<ul><li>200 OK: 请求成功</li></ul></li><li>3xx：表示重定向，如要完成请求还必须采取进一步的行动<ul><li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li></ul></li><li>4xx：表示客户的差错，如请求中有错误的语法或不能完成<ul><li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li><li>401 Unauthorized: 请求要求用户的身份认证</li><li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li><li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li><li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li></ul></li><li>5xx：表示服务器的差错，如服务器失效无法完成请求<ul><li>500 Internal Server Error: 服务器内部错误，无法完成请求</li><li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li><li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li></ul></li></ul><blockquote><p>更多状态码：<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2h0dHAvaHR0cC1zdGF0dXMtY29kZXMuaHRtbA==" title="http://www.runoob.com/http/http-status-codes.html">菜鸟教程 . HTTP状态码<i class="fa fa-external-link"></i></span></p></blockquote><h5 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h5><ul><li>SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</li><li>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：<ul><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ul></li><li>SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2t5bmV0L2FyY2hpdmUvMjAxMC8xMi8xMi8xOTAzOTQ5Lmh0bWw=" title="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket 编程（不限 Linux）<i class="fa fa-external-link"></i></span></p><p><img src="/images/imageProgramC/interview/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF.jpg" alt="Socket 客户端服务器通讯"></p><h4 id="Socket-中的-read-、write-函数"><a href="#Socket-中的-read-、write-函数" class="headerlink" title="Socket 中的 read()、write() 函数"></a>Socket 中的 read()、write() 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><h5 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h5><ul><li>read 函数是负责从 fd 中读取内容。</li><li>当读成功时，read 返回实际所读的字节数。</li><li>如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。</li><li>如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。</li></ul><h5 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h5><ul><li>write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。</li><li>成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。</li><li>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</li><li>（1）write 的返回值大于 0，表示写了部分或者是全部的数据。</li><li>（2）返回的值小于 0，此时出现了错误。</li><li>如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。</li></ul><h4 id="Socket-中-TCP-的三次握手建立连接"><a href="#Socket-中-TCP-的三次握手建立连接" class="headerlink" title="Socket 中 TCP 的三次握手建立连接"></a>Socket 中 TCP 的三次握手建立连接</h4><p>我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</p><ol><li>客户端向服务器发送一个 SYN J</li><li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1</li><li>客户端再想服务器发一个确认 ACK K+1</li></ol><p>只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png" alt="socket 中发送的 TCP 三次握手"></p><p>从图中可以看出：</p><ol><li>当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；  </li><li>服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；  </li><li>客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；  </li><li>服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。</li></ol><h4 id="Socket-中-TCP-的四次握手释放连接"><a href="#Socket-中-TCP-的四次握手释放连接" class="headerlink" title="Socket 中 TCP 的四次握手释放连接"></a>Socket 中 TCP 的四次握手释放连接</h4><p>上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png" alt="socket 中发送的 TCP 四次握手"></p><p>图示过程如下：</p><ol><li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；</li><li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；</li><li>接收到这个 FIN 的源发送端 TCP 对它进行确认。</li></ol><p>这样每个方向上都有一个 FIN 和 ACK。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>数据库事务四大特性：原子性、一致性、分离性、持久性</li><li>数据库索引：顺序索引、B+ 树索引、hash 索引<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvYXJ0aWNsZXMvdGhlb3J5LW9mLW15c3FsLWluZGV4Lmh0bWw=" title="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vc3FsL3NxbF9jb25zdHJhaW50cy5hc3A=" title="http://www.w3school.com.cn/sql/sql_constraints.asp">SQL 约束 (Constraints)<i class="fa fa-external-link"></i></span></li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li>第一范式（1NF）：属性（字段）是最小单位不可再分</li><li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）</li><li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）</li><li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）</li><li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p>各大设计模式例子参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvbHVtbi9kZXRhaWxzLzE1MzkyLmh0bWw=" title="https://blog.csdn.net/column/details/15392.html">CSDN专栏 . C++ 设计模式<i class="fa fa-external-link"></i></span> 系列博文</p></blockquote><p><a href="DesignPattern">设计模式工程目录</a></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><a href="DesignPattern/SingletonPattern">单例模式例子</a></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><a href="DesignPattern/AbstractFactoryPattern">抽象工厂模式例子</a></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><a href="DesignPattern/AdapterPattern">适配器模式例子</a></p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><a href="DesignPattern/BridgePattern">桥接模式例子</a></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><a href="DesignPattern/ObserverPattern">观察者模式例子</a></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ul><li>单一职责原则（SRP，Single Responsibility Principle）</li><li>里氏替换原则（LSP，Liskov Substitution Principle）</li><li>依赖倒置原则（DIP，Dependence Inversion Principle）</li><li>接口隔离原则（ISP，Interface Segregation Principle）</li><li>迪米特法则（LoD，Law of Demeter）</li><li>开放封闭原则（OCP，Open Close Principle）</li></ul><h2 id="链接装载库"><a href="#链接装载库" class="headerlink" title="链接装载库"></a>链接装载库</h2><h3 id="内存、栈、堆"><a href="#内存、栈、堆" class="headerlink" title="内存、栈、堆"></a>内存、栈、堆</h3><p>一般应用程序内存空间有如下区域：</p><ul><li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文</li><li>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</li><li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里</li><li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：</p><ul><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>保存上下文：包括函数调用前后需要保持不变的寄存器</li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆分配算法：</p><ul><li>空闲链表（Free List）</li><li>位图（Bitmap）</li><li>对象池</li></ul><h4 id="“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”"><a href="#“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”" class="headerlink" title="“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”"></a>“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”</h4><p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。</p><p>普遍原因：</p><ul><li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针</li><li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</li></ul><h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><h4 id="各平台文件格式"><a href="#各平台文件格式" class="headerlink" title="各平台文件格式"></a>各平台文件格式</h4><table><thead><tr><th>平台</th><th>可执行文件</th><th>目标文件</th><th>动态库/共享对象</th><th>静态库</th></tr></thead><tbody><tr><td>Windows</td><td>exe</td><td>obj</td><td>dll</td><td>lib</td></tr><tr><td>Unix/Linux</td><td>ELF、out</td><td>o</td><td>so</td><td>a</td></tr><tr><td>Mac</td><td>Mach-O</td><td>o</td><td>dylib、tbd、framework</td><td>a、framework</td></tr></tbody></table><h4 id="编译链接过程"><a href="#编译链接过程" class="headerlink" title="编译链接过程"></a>编译链接过程</h4><ol><li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li><li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）</li><li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）</li><li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</li></ol><blockquote><p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</p></blockquote><blockquote><p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</p></blockquote><h4 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h4><p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p><blockquote><p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</p></blockquote><h5 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h5><ul><li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式</li><li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式</li><li>Intel/Microsoft 的 OMF（Object Module Format）</li><li>Unix 的 <code>a.out</code> 格式</li><li>MS-DOS 的 <code>.COM</code> 格式</li></ul><blockquote><p>PE 和 ELF 都是 COFF（Common File Format）的变种</p></blockquote><h5 id="目标文件存储结构"><a href="#目标文件存储结构" class="headerlink" title="目标文件存储结构"></a>目标文件存储结构</h5><table><thead><tr><th>段</th><th>功能</th></tr></thead><tbody><tr><td>File Header</td><td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td></tr><tr><td>.text section</td><td>代码段，执行语句编译成的机器代码</td></tr><tr><td>.data section</td><td>数据段，已初始化的全局变量和局部静态变量</td></tr><tr><td>.bss section</td><td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td></tr><tr><td>.rodata section</td><td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td></tr><tr><td>.comment section</td><td>注释信息段，存放编译器版本信息</td></tr><tr><td>.note.GNU-stack section</td><td>堆栈提示段</td></tr></tbody></table><blockquote><p>其他段略</p></blockquote><h4 id="链接的接口————符号"><a href="#链接的接口————符号" class="headerlink" title="链接的接口————符号"></a>链接的接口————符号</h4><p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p><p>如下符号表（Symbol Table）：</p><table><thead><tr><th>Symbol（符号名）</th><th>Symbol Value （地址）</th></tr></thead><tbody><tr><td>main</td><td>0x100</td></tr><tr><td>Add</td><td>0x123</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h3 id="Linux-的共享库（Shared-Library）"><a href="#Linux-的共享库（Shared-Library）" class="headerlink" title="Linux 的共享库（Shared Library）"></a>Linux 的共享库（Shared Library）</h3><p>Linux 下的共享库就是普通的 ELF 共享对象。</p><p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p><code>libname.so.x.y.z</code></p><ul><li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译</li><li>y：次版本号，高版本号向后兼容低版本号</li><li>z：发布版本号，不对接口进行更改，完全兼容</li></ul><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p><ul><li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li><li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li><li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li></ul><blockquote><p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p></blockquote><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul><li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li><li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li><li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li></ul><h4 id="so-共享库的编写"><a href="#so-共享库的编写" class="headerlink" title="so 共享库的编写"></a>so 共享库的编写</h4><details><summary>使用 CLion 编写共享库</summary><p>创建一个名为 MySharedLib 的共享库</p><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(MySharedLib SHARED library.cpp library.h)</span><br></pre></td></tr></table></figure><p>library.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 Hello World!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可变模版参数求和</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Types&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T first, Types ... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + sum&lt;T&gt;(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>library.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="so-共享库的使用（被可执行项目调用）"><a href="#so-共享库的使用（被可执行项目调用）" class="headerlink" title="so 共享库的使用（被可执行项目调用）"></a>so 共享库的使用（被可执行项目调用）</h4><details><summary>使用 CLion 调用共享库</summary><p>创建一个名为 TestSharedLib 的可执行项目</p><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(TestSharedLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++11 编译</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件路径</span></span><br><span class="line"><span class="keyword">set</span>(INC_DIR /home/xx/code/clion/MySharedLib)</span><br><span class="line"><span class="comment"># 库文件路径</span></span><br><span class="line"><span class="keyword">set</span>(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;INC_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(TestSharedLib main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 MySharedLib 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(TestSharedLib MySharedLib)</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 + 3 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1 + 2 = 3</span><br><span class="line">1 + 2 + 3 = 6</span><br></pre></td></tr></table></figure></details><h3 id="运行库（Runtime-Library）"><a href="#运行库（Runtime-Library）" class="headerlink" title="运行库（Runtime Library）"></a>运行库（Runtime Library）</h3><h4 id="典型程序运行步骤"><a href="#典型程序运行步骤" class="headerlink" title="典型程序运行步骤"></a>典型程序运行步骤</h4><ol><li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）</li><li>入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。</li><li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。</li><li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。</li></ol><blockquote><p>一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。</p></blockquote><h4 id="glibc-入口"><a href="#glibc-入口" class="headerlink" title="glibc 入口"></a>glibc 入口</h4><p><code>_start -&gt; __libc_start_main -&gt; exit -&gt; _exit</code></p><p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。</p><h4 id="MSVC-CRT-入口"><a href="#MSVC-CRT-入口" class="headerlink" title="MSVC CRT 入口"></a>MSVC CRT 入口</h4><p><code>int mainCRTStartup(void)</code></p><p>执行如下操作：</p><ol><li>初始化和 OS 版本有关的全局变量。</li><li>初始化堆。</li><li>初始化 I/O。</li><li>获取命令行参数和环境变量。</li><li>初始化 C 库的一些数据。</li><li>调用 main 并记录返回值。</li><li>检查错误并将 main 的返回值返回。</li></ol><h4 id="C-语言运行库（CRT）"><a href="#C-语言运行库（CRT）" class="headerlink" title="C 语言运行库（CRT）"></a>C 语言运行库（CRT）</h4><p>大致包含如下功能：</p><ul><li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li><li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。</li><li>I/O：I/O 功能的封装和实现。</li><li>堆：堆的封装和实现。</li><li>语言实现：语言中一些特殊功能的实现。</li><li>调试：实现调试功能的代码。</li></ul><h4 id="C语言标准库（ANSI-C）"><a href="#C语言标准库（ANSI-C）" class="headerlink" title="C语言标准库（ANSI C）"></a>C语言标准库（ANSI C）</h4><p>包含：</p><ul><li>标准输入输出（stdio.h）</li><li>文件操作（stdio.h）</li><li>字符操作（ctype.h）</li><li>字符串操作（string.h）</li><li>数学函数（math.h）</li><li>资源管理（stdlib.h）</li><li>格式转换（stdlib.h）</li><li>时间/日期（time.h）</li><li>断言（assert.h）</li><li>各种类型上的常数（limits.h &amp; float.h）</li><li>变长参数（stdarg.h）</li><li>非局部跳转（setjmp.h）</li></ul><h2 id="回调函数和钩子函数"><a href="#回调函数和钩子函数" class="headerlink" title="回调函数和钩子函数"></a>回调函数和钩子函数</h2><h3 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a>什么是回调函数？</h3><p>简而言之，回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。 </p><h4 id="为什么要使用回调函数？"><a href="#为什么要使用回调函数？" class="headerlink" title="为什么要使用回调函数？"></a>为什么要使用回调函数？</h4><p>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为 int ）的被调用函数。 </p><p>如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、 shell 排序、 shake 排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（ int 、 float 、 string ），此时，该怎么办呢？可以使用函数指针，并进行回调。 </p><p>回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API 使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。 </p><p>另一个使用回调机制的 API 函数是 EnumWindow() ，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。 EnumWindow() 并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。 </p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>不管怎么说，<strong>回调函数是继续自 C 语言的，因而，在 C++ 中，应只在与 C 代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在 C++ 中应使用虚拟方法或函数符（ functor ），而不是回调函数</strong>。</p><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p>也可以这样，更容易理解：回调函数就好像是一个中断处理函数，系统在符合你设定的条件时自动调用。</p><p>为此，你需要做三件事：</p><ol><li><p>声明；</p></li><li><p>定义；</p></li><li><p>设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用。</p></li></ol><p>声明和定义时应注意：回调函数由系统调用，所以可以认为它属于WINDOWS系统，不要把它当作你的某个类的成员函数</p><p>回调函数是一个程序员不能显式调用的函数；通过将回调函数的地址传给调用者从而实现调用。回调函数使用是必要的，在我们想通过一个统一接口实现不同的内容，这时用回掉函数非常合适。比如，我们为几个不同的设备分别写了不同的显示函数：void TVshow(); void ComputerShow(); void NoteBookShow()…等等。这是我们想用一个统一的显示函数，我们这时就可以用回掉函数了。void show(void (*ptr)()); 使用时根据所传入的参数不同而调用不同的回调函数。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy52b2lkY24uY29tL2FydGljbGUvcC1jcGl0dWdwdS1iY2cuaHRtbA==" title="http://www.voidcn.com/article/p-cpitugpu-bcg.html">C语言中的回调函数<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODI5MzkwMg==" title="https://segmentfault.com/a/1190000008293902">一文搞懂C语言回调函数<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvY2hvL2FydGljbGUvZGV0YWlscy81MTU4MzExMg==" title="https://blog.csdn.net/socho/article/details/51583112">c语言实现回调函数<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2Nwcm9ncmFtbWluZy9jLWZ1bi1wb2ludGVyLWNhbGxiYWNrLmh0bWw=" title="http://www.runoob.com/cprogramming/c-fun-pointer-callback.html">函数指针<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="什么是钩子函数？"><a href="#什么是钩子函数？" class="headerlink" title="什么是钩子函数？"></a>什么是钩子函数？</h3><p>钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。对每种类型的钩子由系统来维护一个钩子链，最近安装的钩子放在链的开始，而最先安装的钩子放在最后，也就是后加入的先获得控制权。</p><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>钩子函数是Windows消息处理机制的一部分，通过设置“钩子”，应用程序可以在系统级对所有消息、事件进行过滤，访问在正常情况下无法访问的消息。钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol><li><p>局部钩子：仅钩挂您自己进程的事件。</p></li><li><p>远程钩子：可以钩挂自己进程或其他进程的事件，</p><p>远程钩子又分为两种：</p><ul><li>一种是系统级的全局钩子，</li><li>一种是线程级的钩子。</li></ul><p>全局钩子函数需要定义在 DLL 中，线程级的钩子中经常用到 GetCurrentThreadID 函数来获取当前线程的ID。</p></li></ol><h4 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h4><p>当创建一个钩子时，WINDOWS会先在内存中创建一个数据结构，该数据结构包含了钩子的相关信息，然后把该结构体加到已经存在的钩子链表中去。新的钩子将加到老的前面。当一个事件发生时，如果安装的是一个局部钩子，自己进程中的钩子函数将被调用。如果是一个远程钩子，系统就必须把钩子函数插入到其他进程的地址空间，要做到这一点要求钩子函数必须在一个动态链接库中，所以如果想要使用远程钩子，就必须把该钩子函数放到动态链接库中去。</p><p>两个例外：</p><ul><li>工作日志钩子</li><li>工作日志回放钩子。</li></ul><p>这两个钩子的钩子函数必须在安装钩子的线程中。原因是：</p><ul><li>这两个钩子是用来监控比较底层的硬件事件的，既然是记录和回放，所有的事件就当然都是有先后次序的。所以如果把回调函数放在DLL中，输入的事件被放在几个线程中记录，所以我们无法保证得到正确的次序。</li></ul><p>解决办法：把钩子函数放到单个的线程中，譬如安装钩子的线程。</p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8xMjgxNDUuaHRt" title="https://www.jb51.net/article/128145.htm">浅谈c++ hook 钩子的使用介绍<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="异步消息的传递－回调机制"><a href="#异步消息的传递－回调机制" class="headerlink" title="异步消息的传递－回调机制"></a>异步消息的传递－回调机制</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWNhbGxiYWNrL2luZGV4Lmh0bWw=" title="https://www.ibm.com/developerworks/cn/linux/l-callback/index.html">异步消息的传递－回调机制<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="什么是回调"><a href="#什么是回调" class="headerlink" title="什么是回调"></a>什么是回调</h4><p>软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：</p><ul><li>同步调用</li><li>回调</li><li>异步调用</li></ul><p>同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。</p><p><strong>回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知</strong>。</p><p>同步调用是三者当中最简单的，而回调又常常是异步调用的基础，因此，下面我们着重讨论回调机制在不同软件架构中的实现。</p><img src="/images/imageProgramC/interview/回调机制-01.gif"><p>对于不同类型的语言（如结构化语言和对象语言）、平台（Win32、JDK）或构架（CORBA、DCOM、WebService），客户和服务的交互除了同步方式以外，都需要具备一定的异步通知机制，让服务方（或接口提供方）在某些情况下能够主动通知客户，而回调是实现异步的一个最简捷的途径。</p><p>对于一般的结构化语言，可以通过回调函数来实现回调。回调函数也是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数。</p><p>在面向对象的语言中，回调则是通过接口或抽象类来实现的，我们把实现这种接口的类成为回调类，回调类的对象成为回调对象。对于象C++或Object Pascal这些兼容了过程特性的对象语言，不仅提供了回调对象、回调方法等特性，也能兼容过程语言的回调函数机制。</p><p>Windows平台的消息机制也可以看作是回调的一种应用，我们通过系统提供的接口注册消息处理函数（即回调函数），从而实现接收、处理消息的目的。由于Windows平台的API是用C语言来构建的，我们可以认为它也是回调函数的一个特例。</p><p>对于分布式组件代理体系CORBA，异步处理有多种方式，如回调、事件服务、通知服务等。事件服务和通知服务是CORBA用来处理异步消息的标准服务，他们主要负责消息的处理、派发、维护等工作。对一些简单的异步处理过程，我们可以通过回调机制来实现。</p><p>下面我们集中比较具有代表性的语言（C、Object Pascal）和架构（CORBA）来分析回调的实现方式、具体作用等。</p><h4 id="过程语言中的回调（C）"><a href="#过程语言中的回调（C）" class="headerlink" title="过程语言中的回调（C）"></a>过程语言中的回调（C）</h4><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><p>回调在C语言中是通过函数指针来实现的，通过将回调函数的地址传给被调函数从而实现回调。因此，要实现回调，必须首先定义函数指针，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void Func(char *s)；// 函数原型</span><br><span class="line"><span class="keyword">void</span> (*pFunc) (<span class="keyword">char</span> *);<span class="comment">//函数指针</span></span><br></pre></td></tr></table></figure><p>可以看出，函数的定义和函数指针的定义非常类似。</p><p>一般的话，为了简化函数指针类型的变量定义，提高程序的可读性，我们需要把函数指针类型自定义一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pcb)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>回调函数可以象普通函数一样被程序调用，但是只有它被当作参数传递给被调函数时才能称作回调函数。</p><p>被调函数的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetCallBack</span><span class="params">(pcb callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户在调用上面的函数时，需要自己实现一个pcb类型的回调函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fCallback</span><span class="params">(<span class="keyword">char</span> *s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* do something */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 然后，就可以直接把fCallback当作一个变量传递给GetCallBack,</span></span><br><span class="line">GetCallBack（fCallback）;</span><br></pre></td></tr></table></figure><p>如果赋了不同的值给该参数，那么调用者将调用不同地址的函数。赋值可以发生在运行时，这样使你能实现动态绑定。</p><h5 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h5><p>到目前为止，我们只讨论了函数指针及回调而没有去注意 ANSI C/C++ 的编译器规范。许多编译器有几种调用规范。如在Visual C++中，可以在函数类型前加 <code>_cdecl</code>，<code>_stdcall</code> 或者 <code>_pascal</code> 来表示其调用规范（默认为 <code>_cdecl</code>）。C++ Builder也支持 <code>_fastcall</code> 调用规范。调用规范影响编译器产生的给定函数名，参数传递的顺序（从右到左或从左到右），堆栈清理责任（调用者或者被调用者）以及参数传递机制（堆栈，CPU寄存器等）。</p><p>将调用规范看成是函数类型的一部分是很重要的；不能用不兼容的调用规范将地址赋值给函数指针。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用函数是以 int 为参数，以 int 为返回值</span></span><br><span class="line">__<span class="function">stdcall <span class="keyword">int</span> <span class="title">callee</span><span class="params">(<span class="keyword">int</span>)</span></span>; </span><br><span class="line"><span class="comment">// 调用函数以函数指针为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">caller</span><span class="params">( __cdecl <span class="keyword">int</span>(*ptr)(<span class="keyword">int</span>))</span></span>; </span><br><span class="line"><span class="comment">// 在 p 中企图存储被调用函数地址的非法操作</span></span><br><span class="line">__<span class="function">cdecl <span class="title">int</span><span class="params">(*p)</span><span class="params">(<span class="keyword">int</span>)</span> </span>= callee; <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure><p>指针 p 和 callee() 的类型不兼容，因为它们有不同的调用规范。因此不能将被调用者的地址赋值给指针p，尽管两者有相同的返回值和参数列</p><h5 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h5><p>C 语言的标准库函数中很多地方就采用了回调函数来让用户定制处理过程。如常用的快速排序函数、二分搜索函数等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> width, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> (_USERENTRY *fcmp)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">// 二分搜索函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bsearch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *base, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> (_USERENTRY *fcmp)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><p>其中 fcmp 就是一个回调函数的变量。</p><p>下面给出一个具体的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">5</span>] = &#123; <span class="number">54</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">22</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x;</span><br><span class="line">   qsort((<span class="keyword">void</span> *)<span class="built_in">list</span>, <span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="built_in">list</span>[<span class="number">0</span>]), sort_function);</span><br><span class="line">   <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%i\n"</span>, <span class="built_in">list</span>[x]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> *(<span class="keyword">int</span>*)a-*(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回调在分布式计算中的应用（CORBA）"><a href="#回调在分布式计算中的应用（CORBA）" class="headerlink" title="回调在分布式计算中的应用（CORBA）"></a>回调在分布式计算中的应用（CORBA）</h4><h5 id="回调接口模型"><a href="#回调接口模型" class="headerlink" title="回调接口模型"></a>回调接口模型</h5><p>CORBA 的消息传递机制有很多种，比如回调接口、事件服务和通知服务等。回调接口的原理很简单，CORBA 客户和服务器都具有双重角色，即充当服务器也是客户客户。</p><p>回调接口的反向调用与正向调用往往是同时进行的，如果服务端多次调用该回调接口，那么这个回调接口就变成异步接口了。因此，回调接口在 CORBA 中常常充当事件注册的用途，客户端调用该注册函数时，客户函数就是回调函数，在此后的调用中，由于不需要客户端的主动参与，该函数就是实现了一种异步机制。</p><p>从 CORBA 规范我们知道，一个 CORBA 接口在服务端和客户端有不同的表现形式，在客户端一般使用桩（Stub）文件，服务端则用到框架（Skeleton）文件，接口的规格采用 IDL 来定义。而回调函数的引入，使得服务端和客户端都需要实现一定的桩和框架。下面是回调接口的实现模型：</p><img src="/images/imageProgramC/interview/回调机制-02.gif"><p>下面给出了一个使用回调的接口文件，服务端需要实现 Server 接口的框架，客户端需要实现 CallBack 的框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module cb</span><br><span class="line">&#123;</span><br><span class="line">    interface CallBack;</span><br><span class="line">    interface Server;</span><br><span class="line">    interface CallBack </span><br><span class="line">    &#123;</span><br><span class="line">    void OnEvent(in long Source,in long msg);</span><br><span class="line">    &#125;;</span><br><span class="line">    interface Server </span><br><span class="line">    &#123;</span><br><span class="line">        long RegisterCB(in CallBack cb);</span><br><span class="line">        void UnRegisterCB(in long hCb);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户端首先通过同步方式调用服务端的接口 RegistCB，用来注册回调接口 CallBack。服务端收到该请求以后，就会保留该接口引用，如果发生某种事件需要向客户端通知的时候就通过该引用调用客户方的 OnEvent 函数，以便对方及时处理。</p><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><h3 id="避免野指针的方法"><a href="#避免野指针的方法" class="headerlink" title="避免野指针的方法"></a>避免野指针的方法</h3><p>为了防止野指针带来的灾难，建议指针在定义时给一个初值，比如“NULL”，意思是不指向任何内存地址。然后再使用malloc函数给指针分配一块存储空间。</p><details><summary>避免野指针的方法</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"123"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="literal">NULL</span>; <span class="comment">//str2 赋初值，不指向任何内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2的值是: %u\n"</span>, str2);</span><br><span class="line">    </span><br><span class="line">    str2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2被分配的地址是: %u\n"</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(str2, str1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2指向的字符串是: %s\n"</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != str2)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">free</span>(str2); <span class="comment">// 主动释放分配给str2的内存</span></span><br><span class="line">    str2 = <span class="literal">NULL</span>; <span class="comment">// 让str2不指向任何内存    </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9qdWx5X3YvYXJ0aWNsZS9kZXRhaWxzLzY2ODU5NjI=" title="http://blog.csdn.net/v_july_v/article/details/6685962"> 海量数据处理面试题集锦<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9KVUxZX3YvYXJ0aWNsZS9kZXRhaWxzLzYyNzk0OTg=" title="http://blog.csdn.net/v_JULY_v/article/details/6279498">十道海量数据处理面试题与十个方法大总结<i class="fa fa-external-link"></i></span></li></ul><h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy55dW5saWFvaW0uY29tL2ltLzE4NjkuaHRtbA==" title="http://www.yunliaoim.com/im/1869.html">最全实时音视频开发要用到的开源工程汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlYnJ0Yy5vcmcuY24vMTglRTQlQjglQUElRTUlQUUlOUUlRTYlOTclQjYlRTklOUYlQjMlRTglQTclODYlRTklQTIlOTElRTUlQkMlODAlRTUlOEYlOTElRTQlQjglQUQlRTQlQkMlOUElRTclOTQlQTglRTUlODglQjAlRTUlQkMlODAlRTYlQkElOTAlRTklQTElQjklRTclOUIlQUUv" title="http://webrtc.org.cn/18%E4%B8%AA%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BC%9A%E7%94%A8%E5%88%B0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">18个实时音视频开发中会用到开源项目<i class="fa fa-external-link"></i></span></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9ic19mYXEuaHRtbA==" title="http://www.stroustrup.com/bs_faq.html">Bjarne Stroustrup 的常见问题<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9ic19mYXEyLmh0bWw=" title="http://www.stroustrup.com/bs_faq2.html">Bjarne Stroustrup 的 C++ 风格和技巧常见问题<i class="fa fa-external-link"></i></span></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul><li>《C++ Primer》</li><li>《Effective C++》</li><li>《More Effective C++》</li><li>《深度探索 C++ 对象模型》</li><li>《深入理解 C++11》</li><li>《STL 源码剖析》</li></ul><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><ul><li>《剑指 Offer》</li><li>《编程珠玑》</li><li>《程序员面试宝典》</li></ul><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul><li>《深入理解计算机系统》</li><li>《Windows 核心编程》</li><li>《Unix 环境高级编程》</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>《Unix 网络编程》</li><li>《TCP/IP 详解》</li></ul><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li>《程序员的自我修养》</li></ul><h2 id="复习刷题网站"><a href="#复习刷题网站" class="headerlink" title="复习刷题网站"></a>复习刷题网站</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20v" title="https://leetcode.com/">leetcode<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIubmV0Lw==" title="https://www.nowcoder.net/">牛客网<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW1vb2MuY29tLw==" title="https://www.imooc.com/">慕课网<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tLw==" title="http://www.runoob.com/">菜鸟教程<i class="fa fa-external-link"></i></span></li></ul><h2 id="招聘时间岗位"><a href="#招聘时间岗位" class="headerlink" title="招聘时间岗位"></a>招聘时间岗位</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2FjdGl2aXR5L2NhbXB1czIwMTk=" title="https://www.nowcoder.com/activity/campus2019">牛客网 . 2019 IT名企校招指南<i class="fa fa-external-link"></i></span></li></ul><h2 id="面试题目经验"><a href="#面试题目经验" class="headerlink" title="面试题目经验"></a>面试题目经验</h2><h3 id="牛客网-1"><a href="#牛客网-1" class="headerlink" title="牛客网"></a>牛客网</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvMTI4MDU=" title="https://www.nowcoder.com/discuss/12805">牛客网 . 2017秋季校园招聘笔经面经专题汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvMjUyNjg=" title="https://www.nowcoder.com/discuss/25268">牛客网 . 史上最全2017春招面经大合集！！<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvNTc5Nzg=" title="https://www.nowcoder.com/discuss/57978">牛客网 . 面试题干货在此<i class="fa fa-external-link"></i></span></li></ul><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI5NjkzMDE2" title="https://www.zhihu.com/question/29693016">知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI0OTY0OTg3" title="https://www.zhihu.com/question/24964987">知乎 . 互联网公司最常见的面试算法题有哪些？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMTg0ODU3" title="https://www.zhihu.com/question/20184857">知乎 . 面试 C++ 程序员，什么样的问题是好问题？<i class="fa fa-external-link"></i></span></li></ul><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGp6Y29tZS9hcnRpY2xlL2RldGFpbHMvNTc0MTU4" title="http://blog.csdn.net/ljzcome/article/details/574158">CSDN . 全面整理的C++面试题<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdjaGFvOTkvYXJ0aWNsZS9kZXRhaWxzLzc0NTI0ODA3P2xvY2F0aW9uTnVtPTYmZnBzPTE=" title="http://blog.csdn.net/Xiongchao99/article/details/74524807?locationNum=6&fps=1">CSDN . 百度研发类面试题（C++方向）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmFraW5lL2FydGljbGUvZGV0YWlscy81MTMyMTU0NA==" title="http://blog.csdn.net/fakine/article/details/51321544">CSDN . c++常见面试题30道<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb25ldmVyX3NheV9sb3ZlL2FydGljbGUvZGV0YWlscy81MTIyMzg4Ng==" title="http://blog.csdn.net/onever_say_love/article/details/51223886">CSDN . 腾讯2016实习生面试经验（已经拿到offer)<i class="fa fa-external-link"></i></span></li></ul><h3 id="cnblogs"><a href="#cnblogs" class="headerlink" title="cnblogs"></a>cnblogs</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vWTFGb2N1cy9wLzY3MDcxMjEuaHRtbA==" title="https://www.cnblogs.com/Y1Focus/p/6707121.html">cnblogs . C++面试集锦( 面试被问到的问题 )<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZmFuZ3l1a3Vhbi9hcmNoaXZlLzIwMTAvMDkvMTgvMTgyOTg3MS5odG1s" title="https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html">cnblogs . C/C++ 笔试、面试题目大汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTFVPNzcvcC81NzcxMjM3Lmh0bWw=" title="https://www.cnblogs.com/LUO77/p/5771237.html">cnblogs . 常见C++面试题及基本知识点总结（一）<i class="fa fa-external-link"></i></span></li></ul><h3 id="Segmentfault"><a href="#Segmentfault" class="headerlink" title="Segmentfault"></a>Segmentfault</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwMzc0NTUyOQ==" title="https://segmentfault.com/a/1190000003745529">segmentfault . C++常见面试问题总结<i class="fa fa-external-link"></i></span></li></ul><h3 id="HTTP相关知识"><a href="#HTTP相关知识" class="headerlink" title="HTTP相关知识"></a>HTTP相关知识</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjM2ODczMg==" title="https://segmentfault.com/a/1190000012368732">你必须知道的HTTP基本概念<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9pbXF1cXUuY29tL3Bvc3QvbmV0d29yay1wcm90b2NvbC1pbi1icm93c2VyLmh0bWw=" title="https://imququ.com/post/network-protocol-in-browser.html">浏览器中常见网络协议介绍<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDA3MzE3" title="https://cloud.tencent.com/developer/article/1007317">WebRTC介绍及简单应用<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2htYWkvYXJ0aWNsZS9kZXRhaWxzLzY5NjgxNTk1" title="https://blog.csdn.net/fishmai/article/details/69681595">WebRTC架构简介<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWIxNGJkOWNlNTFkNDUwNjg4MTM0NDMw" title="https://juejin.im/entry/5b14bd9ce51d450688134430">了不起的WebRTC：生态日趋完善，或将实时音视频技术白菜化<i class="fa fa-external-link"></i></span></li></ul><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><ul><li><span class="exturl" data-url="aHR0cDovL3NwYXJrLmFwYWNoZWNuLm9yZy9kb2NzL2NuLzIuMi4wLw==" title="http://spark.apachecn.org/docs/cn/2.2.0/">Apache Spark 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxODUyOTYvYXJ0aWNsZS9kZXRhaWxzLzc2ODU1Nzcw" title="https://blog.csdn.net/u012185296/article/details/76855770">Apache Spark 2.2.0 官方文档中文版（翻译完成 98%. 除 MLib 外） | ApacheCN<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h3YzM1MDQ3L2FydGljbGUvZGV0YWlscy82MDMzMDUyOA==" title="https://blog.csdn.net/xwc35047/article/details/60330528">30分钟概览Spark分布式计算引擎<i class="fa fa-external-link"></i></span></li></ul><h3 id="加密安全问题"><a href="#加密安全问题" class="headerlink" title="加密安全问题"></a>加密安全问题</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1ZmFsaWFuZzAwMy9hcnRpY2xlL2RldGFpbHMvNzk3ODIxNjg=" title="https://blog.csdn.net/wufaliang003/article/details/79782168">SHA算法系列介绍<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yMjVmZjk0MzkxMzI=" title="https://www.jianshu.com/p/225ff9439132">比特币背后的密码学原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5kaXd1eWEvYXJ0aWNsZS9kZXRhaWxzLzc5NTcxNjM5" title="https://blog.csdn.net/tiandiwuya/article/details/79571639">比特币的加密算法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnV4cHJvYmUyMDE3L2FydGljbGUvZGV0YWlscy82MjA0OTAwMQ==" title="https://blog.csdn.net/linuxprobe2017/article/details/62049001">密码学大事件！ SHA-1 哈希碰撞实例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzI4NTI3Lmh0bWw=" title="https://www.freebuf.com/articles/web/28527.html">如何安全的存储用户的密码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXFuaXUuY29tL2xlYXJuLzMwMjM4Lmh0bWw=" title="https://www.aqniu.com/learn/30238.html">机器学习作用于信息安全的五大顶级案例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzUwODUzODkx" title="https://www.zhihu.com/question/50853891">机器学习和数据挖掘在网络安全领域会有哪些应用？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGVpcGhvbmUuY29tL25ld3MvMjAxNjA5L2ZZNHB6dHQ0UlFzck9xamkuaHRtbA==" title="https://www.leiphone.com/news/201609/fY4pztt4RQsrOqji.html">机器学习正在安全领域挂起一阵小旋风，但这里面有BUG<i class="fa fa-external-link"></i></span></li></ul><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLm1iYWxpYi5jb20vc3RvcnkvODg1MDY=" title="https://news.mbalib.com/story/88506">终于有人把P2P、P2C、O2O、B2C、B2B、C2C 的区别讲透了！<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTA2NjkzOQ==" title="https://zhuanlan.zhihu.com/p/35066939">如何真正让小程序,WebRTC和APP互通连麦直播<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly8zNmtyLmNvbS9wLzUxMTc1NzUuaHRtbA==" title="https://36kr.com/p/5117575.html">创业者必读：开发一款 App 到底需要多久？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80MmMyNDkxNjgyNzU=" title="https://www.jianshu.com/p/42c249168275">如何开发一个app（Android）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hYWVmNWNlYjM5MzY=" title="https://www.jianshu.com/p/aaef5ceb3936">微信小程序开发教程–从零开始<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTkzMTU1MQ==" title="https://zhuanlan.zhihu.com/p/39931551">面向机器学习:数据平台的设计与搭建<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjEzNTQ4MmU1MWQ0NTA2ZGMwYWFhMTQ=" title="https://juejin.im/post/5b135482e51d4506dc0aaa14">基于Apache Spark以BigDL搭建可扩展的分布式深度学习框架<i class="fa fa-external-link"></i></span></li><li></li></ul><h3 id="高德面试"><a href="#高德面试" class="headerlink" title="高德面试"></a>高德面试</h3><p>基本知识</p><p>1、进程和线程</p><p>2、多线程通讯方式</p><p>3、消费者和生产者模式（消费者是否轮询方式读取消息，用等待信号方式）</p><p>4、linux命令   top、netstat</p><p>5、gdb调试，怎样切换到某个线程</p><p>6、inline和宏定义区别</p><p>7、vector和list区别，什么情况分别是用什么</p><p>8、类的什么函数不能作为虚函数、析构函数能否作为虚函数，虚函数怎么实现的</p><p>9、setsocektopt   no-delay，等参数的作用</p><p>10、tcp关闭时的几个步骤，tcp的慢启动时啥意思，，，，</p><p>11、epoll模型，我说的是多线程，每个线程一个epoll，一个专门接收链接，另外的读数据 ，解码在哪个线程中进行</p><p>12、c++11 智能指针</p><p>13、死锁概念</p><p>14、什么叫做稳定排序、有哪些排序算法、快排怎么实现的</p><p>15、怎么样判断一棵树和平衡二叉树</p><p>16、当前编写代码（输入一个字符串和一个分隔符，，，，，，把字符串用分割符分割几部分，然后输出）</p><p>项目：</p><p>1、freeswitch的系统结构模型、并发的语音的最大路数，语音编码</p><p>2、视频花屏是怎样优化的</p><p>3、rtp，udp</p><p>4、语音包、和视频包是不是固定大小的，，，是否分包</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-C-面试知识总结&quot;&gt;&lt;a href=&quot;#C-C-面试知识总结&quot; class=&quot;headerlink&quot; title=&quot;C/C++ 面试知识总结&quot;&gt;&lt;/a&gt;C/C++ 面试知识总结&lt;/h1&gt;&lt;p&gt;C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。&lt;/p&gt;
&lt;p&gt;勘误新增请 Issue、PR，建议、讨论请 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvaXNzdWVzLzEy&quot; title=&quot;https://github.com/huihut/interview/issues/12&quot;&gt;#issues/12&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;，排版使用 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL216bG9naW4vY2hpbmVzZS1jb3B5d3JpdGluZy1ndWlkZWxpbmVz&quot; title=&quot;https://github.com/mzlogin/chinese-copywriting-guidelines&quot;&gt;中文文案排版指北&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl + F&lt;/code&gt;：快速查找定位知识点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TOC 导航&lt;/code&gt;：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2phd2lsL0dheUh1Yg==&quot; title=&quot;https://github.com/jawil/GayHub&quot;&gt;jawil/GayHub&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt; 插件快速目录跳转&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>重拾十大经典排序算法</title>
    <link href="http://miaopei.github.io/2016/06/05/Program-C/algorithm/"/>
    <id>http://miaopei.github.io/2016/06/05/Program-C/algorithm/</id>
    <published>2016-06-05T02:14:50.000Z</published>
    <updated>2019-06-14T06:14:05.791Z</updated>
    
    <content type="html"><![CDATA[<p>最近在工作中偶然间涉及到数据库的存储和访问，数据库里存放着员工的指纹、年龄以及姓名等信息，当然指纹是通过<code>md5</code>加密存储的。目前需要对员工的年龄、学历、工作年限等进行排序，如果只有几十个上百个样本，应该不会那么麻烦；关键这是几万名员工的数据，这个量很大，马虎不得。悄悄的告诉你，别惹我，我懂得删库跑路哦。</p><p>脑海中对排序的记忆有点模糊，只对<span style="color: #1976D2; ">「归并排序」</span>印象较为深刻，为了加深理解，重拾<span style="color: #1976D2; ">「数据结构与算法」</span>，并总结了一下常用的十大经典排序算法，由于平台为<code>linux</code>，因此代码全部用<code>C++</code>实现，全部源码均在<code>linux</code>下编译通过并测试成功，可以作为参考。</p><a id="more"></a><p>排序算法在程序猿的编程生涯中虽然用的不多，但是作为基本功，还是要掌握一下。排序算法是<span style="color: #1976D2; ">「数据结构与算法」</span>中最基本的算法，它分为<span style="color: #1976D2; ">「内部排序」</span>和<span style="color: #1976D2; ">「外部排序」</span>；<span style="color: #1976D2; ">「内部排序」</span>一般在内存中实现；当数据量很大时，内存有限，不能将所有的数据都放到内存中来，这个时候必须使用<span style="color: #1976D2; ">「外部排序」</span>。</p><p>先看一张图，对常用算法的时间复杂度做个比较：</p><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最佳情况</th><th>最坏情况</th><th>空间复杂度</th><th>排序方式</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$O(n \log n)$</td><td>$O(n \log^2 n)$</td><td>$O(n \log^2 n)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n)$</td><td>Out-place</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n^2)$</td><td>$O(\log n)$</td><td>In-place</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(k)$</td><td>Out-place</td><td>稳定</td></tr><tr><td>桶排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n^2)$</td><td>$O(n+k)$</td><td>Out-place</td><td>稳定</td></tr><tr><td>基数排序</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n+k)$</td><td>Out-place</td><td>稳定</td></tr></tbody></table><p>这里的<span style="color: #1976D2; ">「稳定」</span>是指当排序后两个相等键值的顺序和排序之前的顺序相同；</p><ul><li>n: 代表数据规模及数据量大小</li><li>k: 桶的个数</li><li>In-place: 不占用额外内存，只占用常数内存</li><li>Out-place: 占用额外内存</li></ul><h2 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一 冒泡排序"></a><span style="color: #1976D2; ">一 冒泡排序</span></h2><p>冒泡排序是排序算法中较为简单的一种，英文称为<code>Bubble Sort。</code>它遍历所有的数据，每次对相邻元素进行两两比较，如果顺序和预先规定的顺序不一致，则进行位置交换；这样一次遍历会将最大或最小的数据上浮到顶端，之后再重复同样的操作，直到所有的数据有序。</p><p>如果有$n$个数据，那么需要$O(n^2)$的比较次数，所以当数据量很大时，冒泡算法的效率并不高。<br>当输入的数据是反序时，花的时间最长，当输入的数据是正序时，时间最短。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：<span style="color: #D32F2F; ">$O(n^2)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：<span style="color: #D32F2F; ">$O(1)$</span></p><p>动态演示：<br><img src="/images/imageProgramC/bubbleSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">61</span>, <span class="number">17</span>, <span class="number">29</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">60</span>, <span class="number">72</span>, <span class="number">21</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">62</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">bubble_sort(arr, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line">len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">bubble_sort(arrf, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>新建代码文件<code>bubble_sort.cpp，</code>将以上代码写入，<code>linux</code>下编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -o bubble_sort bubble_sort.cpp</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bubble_sort</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 17 21 22 29 34 50 60 61 62 72</span><br><span class="line">0.6 1.5 1.9 3.8 4.4 5.4 10.5 12.4 17.5 19.1 19.7 23.8 25.4 28.6</span><br></pre></td></tr></table></figure><p>以下的编译方法和测试方法和这里一样，所以下面不再重复编译和测试的说明。</p><h2 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二 选择排序"></a><span style="color: #1976D2; ">二 选择排序</span></h2><p>选择排序简单直观，英文称为<code>Selection Sort，</code>先在数据中找出最大或最小的元素，放到序列的起始；然后再从余下的数据中继续寻找最大或最小的元素，依次放到排序序列中，直到所有数据样本排序完成。很显然，选择排序也是一个费时的排序算法，无论什么数据，都需要$O(n^2)$的时间复杂度，不适宜大量数据的排序。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n^2)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(1)$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/selectionSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(T arr[],<span class="keyword">int</span> len )</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len  - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">min = j;</span><br><span class="line"><span class="built_in">std</span>::swap(arr[i], arr[min]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">selection_sort(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三 插入排序"></a><span style="color: #1976D2; ">三 插入排序</span></h2><p>插入排序英文称为<code>Insertion Sort，</code>它通过构建有序序列，对于未排序的数据序列，在已排序序列中从后向前扫描，找到相应的位置并插入，类似打扑克牌时的码牌。插入排序有一种优化的算法，可以进行拆半插入。</p><p>基本思路是先将待排序序列的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；然后从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置，直到所有数据都完成排序；如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n^2)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(1)$</span></p><p>动态演示：<br><img src="/images/imageProgramC/insertionSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(T arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        T key=arr[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; key&lt;arr[j];j--)</span><br><span class="line">        arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">        arr[j+<span class="number">1</span>]=key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">insertion_sort(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="四-希尔排序"><a href="#四-希尔排序" class="headerlink" title="四 希尔排序"></a><span style="color: #1976D2; ">四 希尔排序</span></h2><p>希尔排序也称递减增量排序，是插入排序的一种改进版本，英文称为<code>Shell Sort</code>，效率虽高，但它是一种不稳定的排序算法。</p><p>插入排序在对几乎已经排好序的数据操作时，效果是非常好的；但是插入排序每次只能移动一位数据，因此插入排序效率比较低。</p><p>希尔排序在插入排序的基础上进行了改进，它的基本思路是先将整个数据序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全部数据进行依次直接插入排序。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n \log n)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(1)$</span></p><p>假如有这样一组数据，<span style="color: #1976D2; ">[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，</span>如果以步长<code>5</code>进行分割，每一列为一组，那么这组数据应该首先分成这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>之后对每列进行插入排序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>将上述四行数据依序拼接在一起，得到<span style="color: #1976D2; ">[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]，</span>此时<code>10</code>已经移到正确的顺序了，之后以步长<code>3</code>进行插入排序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>排序之后变为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure><p>最后以步长 1 进行排序。</p><p>步长的选择是希尔排序的关键，只要最终步长为<code>1</code>，任何步长序列都可以。建议最初步长选择为数据长度的一半，直到最终的步长为<code>1</code>。</p><p>图解：</p><p><img src="/images/imageProgramC/shell.png" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(T <span class="built_in">array</span>[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; <span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[j - h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arrf[] = &#123; <span class="number">13</span>，<span class="number">14</span>，<span class="number">94</span>，<span class="number">33</span>，<span class="number">82</span>，<span class="number">25</span>，<span class="number">59</span>，<span class="number">94</span>，<span class="number">65</span>，<span class="number">23</span>，<span class="number">45</span>，<span class="number">27</span>，<span class="number">73</span>，<span class="number">25</span>，<span class="number">39</span>，<span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">shell_sort(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="五-归并排序"><a href="#五-归并排序" class="headerlink" title="五 归并排序"></a><span style="color: #1976D2; ">五 归并排序</span></h2><p>归并排序英文称为<code>Merge Sort</code>，归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法<code>（Divide and Conquer）</code>的一个非常典型的应用。它首先将数据样本拆分为两个子数据样本, 并分别对它们排序, 最后再将两个子数据样本合并在一起; 拆分后的两个子数据样本序列, 再继续递归的拆分为更小的子数据样本序列, 再分别进行排序, 直到最后数据序列为1，而不再拆分，此时即完成对数据样本的最终排序。 </p><p>归并排序严格遵循从左到右或从右到左的顺序合并子数据序列, 它不会改变相同数据之间的相对顺序, 因此归并排序是一种稳定的排序算法.</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现分为两种方法：</p><ul><li>自上而下的递归；</li><li>自下而上的迭代；</li></ul><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n \log n)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(n)$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/mergeSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_iteration</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;<span class="comment">//迭代法</span></span><br><span class="line">T* a = arr;</span><br><span class="line">T* b = <span class="keyword">new</span> T[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line"><span class="keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</span><br><span class="line"><span class="keyword">int</span> k = low;</span><br><span class="line"><span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line"><span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line"><span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">b[k++] = a[start1++];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">b[k++] = a[start2++];</span><br><span class="line">&#125;</span><br><span class="line">T* temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">b[i] = a[i];</span><br><span class="line">b = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive_t</span><span class="params">(T arr[], T reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;<span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"><span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line"><span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line"><span class="keyword">merge_sort_recursive_t</span>(arr, reg, start1, end1);</span><br><span class="line"><span class="keyword">merge_sort_recursive_t</span>(arr, reg, start2, end2);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> k = start;</span><br><span class="line"><span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">reg[k++] = arr[start1++];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">reg[k++] = arr[start2++];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(T arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">T *reg = <span class="keyword">new</span> T[len];</span><br><span class="line"><span class="keyword">merge_sort_recursive_t</span>(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">merge_sort_recursive(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">merge_sort_iteration(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="六-快速排序"><a href="#六-快速排序" class="headerlink" title="六 快速排序"></a><span style="color: #1976D2; ">六 快速排序</span></h2><p>快速排序,英文称为Quicksort，又称划分交换排序 partition-exchange sort 简称快排。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。首先从数列中挑出一个元素，并将这个元素称为「基准」，英文pivot。重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。之后，在子序列中继续重复这个方法，直到最后整个数据序列排序完成。</p><p>在平均状况下，排序n个项目要$O(n \log n)$次比较。在最坏状况下则需要$O(n^2)$次比较，但这种状况并不常见。事实上，快速排序通常明显比其他算法更快，因为它的内部循环可以在大部分的架构上很有效率地达成。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; "> $O(n \log n)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>： ：<span style="color: #D32F2F; ">$O(\log n)$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/quickSort.gif" alt></p><p>更直观一些的动图演示：</p><p><img src="/images/imageProgramC/Sorting_quicksort_anim.gif" alt></p><p>代码分两种方式实现，分别为迭代法和递归法。</p><details><summary>迭代法：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    Range(<span class="keyword">int</span> s = <span class="number">0</span>, <span class="keyword">int</span> e = <span class="number">0</span>) &#123;</span><br><span class="line">        start = s, end = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// </span></span><br><span class="line">    </span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        T mid = arr[range.end];</span><br><span class="line">        <span class="keyword">int</span> left = range.start, right = range.end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;</span><br><span class="line">            <span class="built_in">std</span>::swap(arr[left], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= arr[range.end])</span><br><span class="line">            <span class="built_in">std</span>::swap(arr[left], arr[range.end]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left++;</span><br><span class="line">        </span><br><span class="line">        r[p++] = Range(range.start, left - <span class="number">1</span>);</span><br><span class="line">        r[p++] = Range(left + <span class="number">1</span>, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>递归法：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(T arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    T mid = arr[end];</span><br><span class="line">    <span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[left], arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[left], arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    </span><br><span class="line">    quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="七-堆排序"><a href="#七-堆排序" class="headerlink" title="七 堆排序"></a><span style="color: #1976D2; ">七 堆排序</span></h2><p>堆排序，英文称Heapsort，是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序实现分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>算法步骤：</p><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1</li></ol><p><span style="color: #43A047; ">平均时间复杂度</span>： ：<span style="color: #D32F2F; ">$O(n \log n)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>： ：<span style="color: #D32F2F; ">$O(1)$</span></p><p>动图演示：</p><p><img src="/images/imageProgramC/Sorting_heapsort_anim.gif" alt></p><p>来一个更直观一些的：</p><p><img src="/images/imageProgramC/heapSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="comment">//建立父节点指标和子节点指标</span></span><br><span class="line"><span class="keyword">int</span> dad = start;</span><br><span class="line"><span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">//子节点指标在范围内才做比较</span></span><br><span class="line"><span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">//比较两个子节点大小，选择最大的</span></span><br><span class="line">son++;</span><br><span class="line"><span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点大于子节点代表调整完毕，直接跳出函数</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//否則交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">swap(arr[dad], arr[son]);</span><br><span class="line">dad = son;</span><br><span class="line">son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化，i从最后一个父节点开始调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//先將第一个元素和已经排好的元素前一位做交换，再重调整，(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">heap_sort(arr, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="八-计数排序"><a href="#八-计数排序" class="headerlink" title="八 计数排序"></a><span style="color: #1976D2; ">八 计数排序</span></h2><p>计数排序英文称Counting sort，是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于  i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。基本的步骤如下：</p><ol><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>对所有的计数累加,从C中的第一个元素开始，每一项和前一项相加</li><li>反向填充目标数组,将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1</li></ol><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n + k )$</span></p><p><span style="color: #43A047; ">空间复杂度</span>： ：<span style="color: #D32F2F; ">$O(k)$</span></p><p>动图演示：</p><p><img src="/images/imageProgramC/countingSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Count_Sort</span><span class="params">(<span class="keyword">int</span>* Data, <span class="keyword">int</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* Cout = <span class="literal">NULL</span>;           </span><br><span class="line">    Cout = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * Len);   </span><br><span class="line">    <span class="comment">//初始化记数为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Len; i++) &#123;</span><br><span class="line">        Cout[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录重复的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Len; i++) &#123;</span><br><span class="line">        Cout[Data[i]] += <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定不比该位置大的数据个数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Len; i++) &#123;</span><br><span class="line">        Cout[i] += Cout[i - <span class="number">1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* Sort = <span class="literal">NULL</span>;           </span><br><span class="line">    Sort = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * Len);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Len; i++) &#123;</span><br><span class="line">        <span class="comment">//将数组反向填充到Sort，每次拿出一个就减一</span></span><br><span class="line">        Cout[Data[i]] -= <span class="number">1</span>;   </span><br><span class="line">        Sort[Cout[Data[i]]] = Data[i];           </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序结束，将排序好的数据复制到原来数组中。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Len; ++i) &#123;</span><br><span class="line">        Data[i] = Sort[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放申请的空间。</span></span><br><span class="line">    <span class="built_in">free</span>(Cout);</span><br><span class="line">    <span class="built_in">free</span>(Sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="九-桶排序"><a href="#九-桶排序" class="headerlink" title="九 桶排序"></a><span style="color: #1976D2; ">九 桶排序</span></h2><p>桶排序也称为箱排序，英文称为 Bucket Sort。它是将数组划分到一定数量的有序的桶里，然后再对每个桶中的数据进行排序，最后再将各个桶里的数据有序的合并到一起。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n + k)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(n + k)$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/bucketsort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> tValue; </span><br><span class="line">tNode *next; </span><br><span class="line"></span><br><span class="line">tNode(<span class="keyword">int</span> val) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;tValue = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> *arrf, <span class="keyword">const</span> <span class="keyword">int</span> SIZE)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tNode **pNode = (tNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tNode *) * <span class="number">512</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pNode)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(pNode, <span class="number">0</span>, <span class="keyword">sizeof</span>(tNode *) * <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> shiftNum = <span class="number">0</span>;</span><br><span class="line">tNode *p = <span class="literal">NULL</span>;</span><br><span class="line">tNode *pLast = <span class="literal">NULL</span>;</span><br><span class="line">tNode *pNewNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">shiftNum = arrf[i] &gt;&gt; <span class="number">24</span>;</span><br><span class="line">p = pNode[shiftNum];</span><br><span class="line"></span><br><span class="line">pNewNode = <span class="keyword">new</span> tNode(arrf[i]);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pNewNode)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p) &#123;</span><br><span class="line">pNode[shiftNum] = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arrf[i] &lt;= p-&gt;tValue) &#123;</span><br><span class="line">pNode[shiftNum] = pNewNode;</span><br><span class="line">pNewNode-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">NULL</span> != p-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span> (arrf[i] &gt; p-&gt;next-&gt;tValue)</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pNewNode-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">p = pNode[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">NULL</span> != p) &#123;</span><br><span class="line">arrf[k++] = p-&gt;tValue;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>,<span class="number">558</span>,<span class="number">772</span>,<span class="number">935</span>,<span class="number">344</span>,<span class="number">487</span>,<span class="number">96</span>,<span class="number">665</span>,<span class="number">302</span>,<span class="number">735</span>,<span class="number">954</span>,<span class="number">308</span>,<span class="number">718</span>,<span class="number">147</span>,<span class="number">185</span>,<span class="number">371</span>,<span class="number">166</span>,<span class="number">849</span>,<span class="number">202</span>,<span class="number">478</span>,<span class="number">874</span>,<span class="number">169</span>,<span class="number">980</span>,<span class="number">125</span>,<span class="number">44</span>,<span class="number">15</span>,<span class="number">279</span>,<span class="number">882</span>,<span class="number">466</span>,<span class="number">974</span> &#125;;</span><br><span class="line"></span><br><span class="line">bucket_sort(arr,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="十-基数排序"><a href="#十-基数排序" class="headerlink" title="十 基数排序"></a><span style="color: #1976D2; ">十 基数排序</span></h2><p>基数排序英文称Radix sort，是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串和特定格式的浮点数，所以基数排序也仅限于整数。它首先将所有待比较数值，统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p><span style="color: #43A047; ">平均时间复杂度</span>： ：<span style="color: #D32F2F; ">$O(n \times k)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>： ：<span style="color: #D32F2F; ">$O(n + k )$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/radixSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> <span class="comment">//辅助函数，求数据的最大位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxData = data[<span class="number">0</span>];<span class="comment">///&lt; 最大数</span></span><br><span class="line">    <span class="comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p) &#123;</span><br><span class="line">        <span class="comment">//p *= 10; // Maybe overflow</span></span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"><span class="comment">/*  int d = 1; //保存最大的位数</span></span><br><span class="line"><span class="comment">    int p = 10;</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        while(data[i] &gt;= p)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p *= 10;</span></span><br><span class="line"><span class="comment">            ++d;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return d;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = maxbit(data, n);</span><br><span class="line">    <span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;  <span class="comment">//将所有桶中记录依次收集到tmp中      </span></span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        </span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><span style="color: #1976D2; ">参考</span></h2><p><span style="color: #1976D2; ">wiki</span><br><span style="color: #1976D2; "><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1c3RjYy9KUy1Tb3J0aW5nLUFsZ29yaXRobQ==" title="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm<i class="fa fa-external-link"></i></span></span><br><span style="color: #1976D2; ">「数据结构与算法」</span><br><span style="color: #1976D2; ">「算法导论」</span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在工作中偶然间涉及到数据库的存储和访问，数据库里存放着员工的指纹、年龄以及姓名等信息，当然指纹是通过&lt;code&gt;md5&lt;/code&gt;加密存储的。目前需要对员工的年龄、学历、工作年限等进行排序，如果只有几十个上百个样本，应该不会那么麻烦；关键这是几万名员工的数据，这个量很大，马虎不得。悄悄的告诉你，别惹我，我懂得删库跑路哦。&lt;/p&gt;
&lt;p&gt;脑海中对排序的记忆有点模糊，只对&lt;span style=&quot;color: #1976D2; &quot;&gt;「归并排序」&lt;/span&gt;印象较为深刻，为了加深理解，重拾&lt;span style=&quot;color: #1976D2; &quot;&gt;「数据结构与算法」&lt;/span&gt;，并总结了一下常用的十大经典排序算法，由于平台为&lt;code&gt;linux&lt;/code&gt;，因此代码全部用&lt;code&gt;C++&lt;/code&gt;实现，全部源码均在&lt;code&gt;linux&lt;/code&gt;下编译通过并测试成功，可以作为参考。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://miaopei.github.io/categories/algorithm/"/>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/algorithm/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
      <category term="algorithm" scheme="http://miaopei.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://miaopei.github.io/2016/06/03/Program-C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://miaopei.github.io/2016/06/03/Program-C/数据结构/</id>
    <published>2016-06-03T02:14:50.000Z</published>
    <updated>2019-06-14T06:15:56.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><a id="more"></a><img src="/images/imageProgramC/数据结构-00.png"><h2 id="一、数据结构概念"><a href="#一、数据结构概念" class="headerlink" title="一、数据结构概念"></a>一、数据结构概念</h2><h3 id="1-1-数据结构相关概念"><a href="#1-1-数据结构相关概念" class="headerlink" title="1.1 数据结构相关概念"></a>1.1 数据结构相关概念</h3><p><strong>疑惑</strong></p><p>1、我学完了C语言，可是现在感觉还是写不出代码。</p><p>2、为什么会有各种各样的程序存在？</p><p>3、程序的本质是什么？</p><ul><li><p>程序是为了具体问题而存在的 </p></li><li><p>程序需要围绕问题的解决进行设计</p></li><li><p>同一个问题可以有多种解决方案</p></li><li><p>如何追求程序的“性价比”？</p></li><li><p>是否有可量化的方法判别程序的好坏？</p></li></ul><p><strong>数据结构起源</strong></p><ul><li><p>计算机从解决数值计算问题到解决生活中的问题</p></li><li><p>现实生活中的问题涉及不同个体间的复杂联系</p></li><li><p>需要在计算机程序中描述生活中个体间的联系</p></li><li><p>*<em>数据结构主要研究非数值计算程序问题中的操作对象以及它们之间的关系 *</em></p></li><li><p><strong>不是研究复杂的算法</strong></p></li></ul><p><strong>数据结构中的基本概念</strong></p><p>数据 – 程序的操作对象，用于描述客观事物  (int a, int b,)</p><p>数据的特点：</p><ul><li><p>可以输入到计算机</p></li><li><p>可以被计算机程序处理</p></li></ul><p>数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等</p><p><strong>数据元素：组成数据的基本单位</strong></p><p>数据项：一个数据元素由若干数据项组成</p><p><strong>数据对象 – 性质相同的数据元素的集合   （比如：数组，链表）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyTeacher</span>&#123;</span>   <span class="comment">//一种数据类型</span></span><br><span class="line"><span class="keyword">char</span>name[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">char</span>tile[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span>age;</span><br><span class="line"><span class="keyword">char</span>addr[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main21</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyTeacher</span>  <span class="title">t1</span>;</span> <span class="comment">//数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyTeacher</span> <span class="title">tArray</span>[30];</span> <span class="comment">//数据对象</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;t1, <span class="number">0</span>, <span class="keyword">sizeof</span>(t1));</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(t1.name, <span class="string">"name"</span>); <span class="comment">//数据项</span></span><br><span class="line"><span class="built_in">strcpy</span>(t1.addr, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line"><span class="built_in">strcpy</span>(t1.tile, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line">t1.age = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/数据结构.png"><p>数据元素之间不是独立的，存在特定的关系，这些关系即结构</p><p>*<em>数据结构指数据对象中数据元素之间的关系   *</em></p><p>如：数组中各个元素之间存在固定的线性关系   </p><ul><li>编写一个“好”的程序之前，必须分析待处理问题中各个对象的特性，以及对象之间的关系。</li></ul><p>基本概念总结：</p><img src="/images/imageProgramC/数据结构-01.png"><p><strong>数据的逻辑结构</strong></p><p>指数据元素之间的逻辑关系。即从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。逻辑结构可细分为4类：</p><img src="/images/imageProgramC/数据结构-02.png"><p><strong>数据的物理结构</strong></p><img src="/images/imageProgramC/数据结构-03.png"><p><strong>数据的运算</strong></p><img src="/images/imageProgramC/数据结构-04.png"><h3 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h3><p><strong>算法概念</strong></p><ul><li><p>算法是<strong>特定问题求解步骤的描述</strong></p></li><li><p>在计算机中表现为指令的有限序列 </p></li><li><p>算法是独立存在的一种解决问题的方法和思想。</p></li><li><p>对于算法而言，语言并不重要，重要的是思想。</p></li></ul><p><strong>算法和数据结构区别</strong></p><ul><li><p>数据结构只是静态的描述了数据元素之间的关系</p></li><li><p>高效的程序需要在数据结构的基础上设计和选择算法</p></li></ul><p><strong>程序 = 数据结构 + 算法</strong></p><p>总结：</p><ul><li><p>算法是为了解决实际问题而设计的</p></li><li><p>数据结构是算法需要处理的问题载体</p></li><li><p>数据结构与算法相辅相成</p></li></ul><p><strong>算法特性</strong></p><p>输入</p><ul><li>算法具有0个或多个输入</li></ul><p>输出</p><ul><li>算法至少有1个或多个输出</li></ul><p>有穷性</p><ul><li>算法在有限的步骤之后会自动结束而不会无限循环</li></ul><p>确定性</p><ul><li>算法中的每一步都有确定的含义，不会出现二义性</li></ul><p>可行性</p><ul><li>算法的每一步都是可行的</li></ul><p><strong>算法效率的度量</strong></p><p>1、事后统计法</p><ul><li>比较不同算法对同一组输入数据的运行处理时间</li><li>缺陷    <ul><li>为了获得不同算法的运行时间必须编写相应程序</li><li>运行时间严重依赖硬件以及运行时的环境因素</li><li>算法的测试数据的选取相当困难</li></ul></li><li>事后统计法虽然直观，但是实施困难且缺陷多</li></ul><p>算法效率的度量</p><ul><li>事前分析估算</li><li>依据统计的方法对算法效率进行估算</li><li>影响算法效率的主要因素<ul><li>算法采用的策略和方法</li><li>问题的输入规模</li><li>编译器所产生的代码</li><li>计算机执行速度</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法最终编译成具体的计算机指令</span></span><br><span class="line"><span class="comment">//每一个指令，在具体的计算机上运行速度固定</span></span><br><span class="line"><span class="comment">//通过具体的n的步骤，就可以推导出算法的复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;                         </span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">array</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)   </span><br><span class="line">        <span class="built_in">array</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">        ret += <span class="built_in">array</span>[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>); </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">ret += i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>( n &gt; <span class="number">0</span> )</span><br><span class="line">        ret = (<span class="number">1</span> + n) * n / <span class="number">2</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum1(<span class="number">100</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum2(<span class="number">100</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum3(<span class="number">100</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;len; j++)&#123;</span><br><span class="line">            s += i*j;  <span class="comment">//n*n</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/数据结构-05.png"><p><strong>注意 1</strong>：判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略。</p><p><strong>注意 2</strong>：在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度。</p><p>2、大 O 表示法</p><ul><li><p>算法效率严重依赖于操作(Operation)数量</p></li><li><p>在判断时首先关注操作数量的最高次项</p></li><li><p>操作数量的估算可以作为时间复杂度的估算</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">5</span>) = O(<span class="number">1</span>)</span><br><span class="line">O(<span class="number">2</span>n + <span class="number">1</span>) = O(<span class="number">2</span>n) = O(n)  </span><br><span class="line">O(n2+ n + <span class="number">1</span>) = O(n2)</span><br><span class="line">O(<span class="number">3</span>n3+<span class="number">1</span>) = O(<span class="number">3</span>n3) = O(n3)</span><br></pre></td></tr></table></figure><p>常见时间复杂度</p><img src="/images/imageProgramC/数据结构-06.png"><p>关系</p><img src="/images/imageProgramC/数据结构-07.png"><p>3、算法的空间复杂度</p><p>算法的空间复杂度通过计算算法的存储空间实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S(n) = O(f(n))</span><br></pre></td></tr></table></figure><p>其中，<code>n</code> 为问题规模，<code>f(n)</code> 为在问题规模为 <code>n</code> 时所占用存储空间的函数</p><p>大 O 表示法同样适用于算法的空间复杂度</p><p><strong>当算法执行时所需要的空间是常数时，空间复杂度为O(1)</strong></p><p>空间与时间的策略：</p><ul><li><p>多数情况下，算法执行时所用的时间更令人关注</p></li><li><p>如果有必要，可以通过增加空间复杂度来降低时间复杂度</p></li><li><p>同理，也可以通过增加时间复杂度来降低空间复杂度</p></li></ul><p>练习1：分析 sum1 sum2 sum3 函数的空间复杂度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">4</span>n+<span class="number">12</span>)  O(<span class="number">8</span>)=O(<span class="number">1</span>)  O(<span class="number">4</span>)=O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>总结：实现算法时，需要分析具体问题，对执行时间和空间的要求。</p><p>练习2：时间换空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题： </span></span><br><span class="line"><span class="comment">    在一个由自然数 1-1000 中某些数字所组成的数组中，每个数字可能出现零次或者多次。</span></span><br><span class="line"><span class="comment">    设计一个算法，找出出现次数最多的数字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">方法<span class="number">1</span>：</span><br><span class="line">   排序，然后找出出现次数最多的数字</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sp[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = a[i] - <span class="number">1</span>;    </span><br><span class="line">        sp[index]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( max &lt; sp[i] )</span><br><span class="line">            max = sp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( max == sp[i] )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line">    search(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(*<span class="built_in">array</span>));   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把每个数字出现的次数的中间结果，缓存下来；在缓存的结果中求最大值。</p><img src="/images/imageProgramC/数据结构-08.png"><h2 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h2><h3 id="2-1-线性表基本概念"><a href="#2-1-线性表基本概念" class="headerlink" title="2.1 线性表基本概念"></a>2.1 线性表基本概念</h3><p><strong>线性表定义</strong></p><ul><li><p>线性表(List)是零个或多个数据元素的集合 </p></li><li><p>线性表中的数据元素之间是有顺序的</p></li><li><p>线性表中的数据元素个数是有限的</p></li><li><p>线性表中的数据元素的类型必须相同</p></li></ul><img src="/images/imageProgramC/数据结构-09.png"><p><strong>数学定义</strong></p><p>线性表是具有相同类型的 n（ ≥ 0）个数据元素的有限序列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（a1, a2, …, an）</span><br><span class="line">ai 是表项，n 是表长度。</span><br></pre></td></tr></table></figure><p><strong>性质</strong></p><ul><li><p>a0 为线性表的第一个元素，只有一个后继</p></li><li><p>an 为线性表的最后一个元素，只有一个前驱</p></li><li><p>除 a0 和 an 外的其它元素 ai，既有前驱，又有后继</p></li><li><p>线性表能够逐项访问和顺序存取</p></li></ul><p><strong>练习</strong></p><p>下面的关系中可以用线性表描述的是</p><ul><li><p>A.班级中同学的友谊关系 N:N</p></li><li><p>B.公司中的上下级关系  1:N</p></li><li><p>C.冬天图书馆排队占座关系 </p></li><li><p>D.花名册上名字之间的关系 1::1</p></li></ul><p><strong>线性表的操作</strong></p><ul><li><p>创建线性表</p></li><li><p>销毁线性表</p></li><li><p>清空线性表</p></li><li><p>将元素插入线性表</p></li><li><p>将元素从线性表中删除</p></li><li><p>获取线性表中某个位置的元素</p></li><li><p>获取线性表的长度</p></li></ul><blockquote><p>线性表在程序中表现为一种特殊的数据类型</p><p>线性表的操作在程序中的表现为一组函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C 语言描述=====》线性表的设计与实现</span></span><br><span class="line"><span class="comment">ADT 抽象层  《[数据结构(C语言版)].严蔚敏_吴伟民.扫描版.pdf》 p44页 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WBM_LIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WBM_LIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并且返回一个空的线性表</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//销毁一个线性表list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//将一个线性表list中的所有元素清空, 线性表回到创建时的初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//向一个线性表list的pos位置处插入新元素node</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;  </span><br><span class="line"><span class="comment">//获取一个线性表list的pos位置处的元素</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//删除一个线性表list的pos位置处的元素  返回值为被删除的元素，NULL表示删除失败</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意: */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;  (重点:分离思想)</span><br></pre></td></tr></table></figure><h3 id="2-2-线性表的顺序存储结构"><a href="#2-2-线性表的顺序存储结构" class="headerlink" title="2.2 线性表的顺序存储结构"></a>2.2 线性表的顺序存储结构</h3><p><strong>基本概念</strong></p><img src="/images/imageProgramC/数据结构-10.png"><p><strong>设计与实现</strong></p><p>插入元素算法</p><ul><li><p>判断线性表是否合法</p></li><li><p>判断插入位置是否合法</p></li><li><p>把最后一个元素到插入位置的元素后移一个位置</p></li><li><p>将新元素插入</p></li><li><p>线性表长度加 1</p></li></ul><p>获取元素操作</p><ul><li><p>判断线性表是否合法</p></li><li><p>判断位置是否合法</p></li><li><p>直接通过数组下标的方式获取元素</p></li></ul><p>删除元素算法</p><ul><li><p>判断线性表是否合法</p></li><li><p>判断删除位置是否合法</p></li><li><p>将元素取出</p></li><li><p>将删除位置后的元素分别向前移动一个位置</p></li><li><p>线性表长度减 1</p></li></ul><p>链表顺序存储插入算法和删除算法</p><img src="/images/imageProgramC/数据结构-11.png"><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><p>无需为线性表中的逻辑关系增加额外的空间</p></li><li><p>可以快速的获取表中合法位置的元素</p></li></ul><p>缺点：</p><ul><li><p>插入和删除操作需要移动大量元素</p></li><li><p>当线性表长度变化较大时难以确定存储空间的容量</p></li></ul><h3 id="2-3-线性表的链式存储"><a href="#2-3-线性表的链式存储" class="headerlink" title="2.3 线性表的链式存储"></a>2.3 线性表的链式存储</h3><p><strong>基本概念</strong></p><p>链式存储定义</p><ul><li>为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。</li></ul><img src="/images/imageProgramC/数据结构-12.png"><p>表头结点</p><ul><li>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息</li></ul><p>数据结点</p><ul><li>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息</li></ul><p>尾结点</p><ul><li>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li></ul><p><strong>链表技术领域推演</strong></p><img src="/images/imageProgramC/数据结构-13.png"><p><strong>设计与实现</strong></p><p>链表链式存储 <code>_api</code> 实现分析</p><p>在C语言中可以用结构体来定义链表中的指针域</p><p>链表中的表头结点也可以用结构体实现</p><img src="/images/imageProgramC/数据结构-14.png"><img src="/images/imageProgramC/数据结构-15.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> * LK;      <span class="comment">// 不希望看到内部数据是可以这么定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function">LK <span class="title">init_LinkList</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_LinkList</span><span class="params">(LK <span class="built_in">list</span>, <span class="keyword">int</span> position, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foreach_LinkList</span><span class="params">(LK <span class="built_in">list</span>, <span class="keyword">void</span>(*myforeach)(<span class="keyword">void</span> *))</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveByPos_LinkList</span><span class="params">(LK <span class="built_in">list</span>, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destroy_LinkList</span><span class="params">(LK <span class="built_in">list</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点、位置从0的单链表</span></span><br><span class="line"><span class="comment">// 返回链表中第3个位置处，元素的值</span></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Get</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>&#123; </span><br><span class="line"><span class="keyword">int</span>  i = <span class="number">0</span>;</span><br><span class="line">TLinkList *tList = (TLinkList *)<span class="built_in">list</span>;</span><br><span class="line">LinkListNode *current = <span class="literal">NULL</span>;</span><br><span class="line">LinkListNode *ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || pos &lt; <span class="number">0</span> || pos &gt;= tList-&gt;length)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">current = (LinkListNode *)tList;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">ret = current-&gt;next;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>返回第三个位置的,移动pos次以后，当前指针指向哪里？</p><p>答案：指向位置2，所以需要返回 <code>ret = current-&gt;next;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    备注：循环遍历时，</span></span><br><span class="line"><span class="comment">    遍历第1次，指向位置0</span></span><br><span class="line"><span class="comment">        遍历第2次，指向位置1</span></span><br><span class="line"><span class="comment">        遍历第3次，指向位置2</span></span><br><span class="line"><span class="comment">        遍历第n次，指向位置n-1;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以如果想返回位置 n 的元素的值，需要怎么做 <code>ret = current-&gt;next;</code></p><p>此问题是：*<em>指向头结点的指针移动 n 次 和 第 n 个元素之间的关系？ *</em></p><p>删除元素</p><img src="/images/imageProgramC/数据结构-16.png"><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><p>无需一次性定制链表的容量 </p></li><li><p>插入和删除操作无需移动数据元素</p></li></ul><p>缺点：</p><ul><li><p>数据元素必须保存后继元素的位置信息</p></li><li><p>获取指定数据的元素操作需要顺序访问之前的元素</p></li></ul><h3 id="2-4-循环链表"><a href="#2-4-循环链表" class="headerlink" title="2.4 循环链表"></a>2.4 循环链表</h3><p><strong>基本概念</strong></p><p>循环链表的定义：将单链表中最后一个数据元素的next指针指向第一个元素</p><img src="/images/imageProgramC/数据结构-17.png"><p>循环链表拥有单链表的所有操作</p><ul><li><p>创建链表</p></li><li><p>销毁链表</p></li><li><p>获取链表长度</p></li><li><p>清空链表</p></li><li><p>获取第pos个元素操作</p></li><li><p>插入元素到位置pos</p></li><li><p>删除位置pos处的元素</p></li></ul><p>新增功能：<strong>游标</strong> 的定义</p><p>在循环链表中可以定义一个“当前”指针，这个指针通常称为 <strong>游标</strong>，可以通过这个游标来遍历链表中的所有元素。</p><img src="/images/imageProgramC/数据结构-18.png"><p>循环链表新操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将游标重置指向链表中的第一个数据元素</span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_Reset</span><span class="params">(CircleList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前游标指向的数据元素</span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_Current</span><span class="params">(CircleList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将游标移动指向到链表中的下一个数据元素</span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_Next</span><span class="params">(CircleList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接指定删除链表中的某个数据元素 </span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_DeleteNode</span><span class="params">(CircleList* <span class="built_in">list</span>, CircleListNode* node)</span></span>;  </span><br><span class="line"><span class="comment">// 根据元素的 值 删除, 元素 pk 根据元素的 位置 删除元素</span></span><br></pre></td></tr></table></figure><p><strong>循环链表的应用</strong></p><p><strong>证明循环链表</strong></p><ul><li>打印两次。</li></ul><p><strong>约瑟夫问题求解</strong></p><blockquote><p>约瑟夫问题 - 循环链表典型应用</p><p>n 个人围成一个圆圈，首先第 1 个人从 1 开始一个人一个人顺时针报数，报到第 m 个人，令其出列。然后再从下一 个人开始从 1 顺时针报数，报到第 m 个人，再令其出列，…，如此下去，求出列顺序。</p></blockquote><img src="/images/imageProgramC/数据结构-19.png"><p><strong>设计与实现</strong></p><p><strong>循环链表插入元素的分析</strong> </p><p>1） 普通插入元素（和单链表是一样的）</p><p>2） 尾插法（和单链表是一样的，单链表的写法支持尾插法；因：辅助指针向后跳length次，指向最后面那个元素）</p><img src="/images/imageProgramC/数据结构-20.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList_Insert</span><span class="params">(<span class="built_in">list</span>, (CircleListNode*)&amp;v1, CircleList_Length(<span class="built_in">list</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>3） 头插法（要进行头插法，需要求出尾结点，和单链表不一样的地方，保证是循环链表）第一次插入元素时，让游标指向 0 号结点</p><img src="/images/imageProgramC/数据结构-21.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList_Insert</span><span class="params">(<span class="built_in">list</span>, (CircleListNode*)&amp;v1, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>4）第一次插入元素</p><img src="/images/imageProgramC/数据结构-22.png"><p><strong>循环链表插入综合场景分析图</strong></p><img src="/images/imageProgramC/数据结构-23.png"><p><strong>循环链表删除结点分析</strong></p><p>1、 删除普通结点</p><p>2、 删除头结点（删除 0 号位置处元素），需要求出尾结点</p><img src="/images/imageProgramC/数据结构-24.png"><p><strong>优点和缺点</strong></p><p>优点：功能强了。</p><ul><li><p>循环链表只是在单链表的基础上做了一个加强</p></li><li><p>循环链表可以完全取代单链表的使用</p></li><li><p>循环链表的 Next 和 Current 操作可以高效的遍历链表中的所有元素</p></li></ul><p>缺点：</p><ul><li>代码复杂度提高了</li></ul><h3 id="2-5-双向链表"><a href="#2-5-双向链表" class="headerlink" title="2.5 双向链表"></a>2.5 双向链表</h3><p><strong>基本概念</strong> </p><p>请思考： 为什么 <strong>需要</strong> 双向链表？</p><ul><li><p>单链表的结点都只有一个指向下一个结点的指针</p></li><li><p>单链表的数据元素无法直接访问其前驱元素</p></li><li><p><strong>逆序访问单链表</strong> 中的元素是极其 <strong>耗时</strong> 的操作！</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">len = LinkList_Length(<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">for</span> (i=len<span class="number">-1</span>; len&gt;=<span class="number">0</span>; i++) <span class="comment">//O(n)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode *p = LinkList_Get(<span class="built_in">list</span>, i); <span class="comment">//O(n)</span></span><br><span class="line">    <span class="comment">//访问数据元素p中的元素</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向链表的定义</strong></p><p>在单链表的结点中增加一个指向其前驱的 pre 指针</p><img src="/images/imageProgramC/数据结构-25.png"><p>双向链表拥有单链表的所有操作</p><ul><li><p>创建链表</p></li><li><p>销毁链表</p></li><li><p>获取链表长度</p></li><li><p>清空链表</p></li><li><p>获取第 pos 个元素操作</p></li><li><p>插入元素到位置 pos</p></li><li><p>删除位置 pos 处的元素</p></li></ul><p><strong>设计与实现</strong></p><p>循环链表一般操作</p><blockquote><p> 插入操作</p></blockquote><img src="/images/imageProgramC/数据结构-26.png"><p>插入操作异常处理</p><ul><li><p>插入第一个元素异常处理</p></li><li><p>在 0 号位置处插入元素；</p></li></ul><blockquote><p>删除操作</p></blockquote><img src="/images/imageProgramC/数据结构-27.png"><p>删除操作异常处理</p><p>双向链表的新操作</p><ul><li><p>获取当前游标指向的数据元素</p></li><li><p>将游标重置指向链表中的第一个数据元素</p></li><li><p>将游标移动指向到链表中的下一个数据元素</p></li><li><p>将游标移动指向到链表中的上一个数据元素</p></li><li><p>直接指定删除链表中的某个数据元素</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_DeleteNode</span><span class="params">(DLinkList* <span class="built_in">list</span>, DLinkListNode* node)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Reset</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Current</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Next</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Pre</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//大家一定要注意：教科书不会告诉你 项目上如何用；哪些点是项目的重点；做一个企业级的财富库，完成你人生开发经验的积累，是我们的学习重点，要注意！</span></span><br></pre></td></tr></table></figure><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><p>双向链表在单链表的基础上增加了指向前驱的指针</p></li><li><p>功能上双向链表可以完全取代单链表的使用</p></li><li><p>双向链表的 Next，Pre 和 Current 操作可以高效的遍历链表中的所有元素</p></li></ul><p>缺点：</p><ul><li>代码复杂</li></ul><h2 id="三、栈-stack-和队列-queue"><a href="#三、栈-stack-和队列-queue" class="headerlink" title="三、栈 stack 和队列 queue"></a>三、栈 stack 和队列 queue</h2><h3 id="3-1栈-stack"><a href="#3-1栈-stack" class="headerlink" title="3.1栈 stack"></a>3.1栈 stack</h3><p><strong>Stack基本概念</strong></p><ul><li><p>栈是一种  特殊的线性表  </p></li><li><p>栈仅能在线性表的一端进行操作</p><ul><li>栈顶(Top)：允许操作的一端</li><li>栈底(Bottom)：不允许操作的一端</li></ul></li></ul><img src="/images/imageProgramC/数据结构-28.png"><p><strong>Stack的常用操作</strong></p><ul><li><p>创建栈</p></li><li><p>销毁栈</p></li><li><p>清空栈</p></li><li><p>进栈</p></li><li><p>出栈</p></li><li><p>获取栈顶元素</p></li><li><p>获取栈的大小 </p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack* <span class="title">Stack_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack_Destroy</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack_Clear</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack_Push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Stack_Pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Stack_Top</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack_Size</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_STACK_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>栈模型和链表模型关系分析</strong></p><img src="/images/imageProgramC/数据结构-29.png"><p><strong>栈的顺序存储设计与实现</strong></p><img src="/images/imageProgramC/数据结构-30.png"><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  __MY_SEQLIST_H__ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MY_SEQLIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqListNode;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqStack_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SeqStack _Destroy(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SeqStack _Clear(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SeqStack _Length(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SeqStack _Capacity(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SeqStack _Insert(SeqStack * <span class="built_in">list</span>, SeqListNode* node, <span class="keyword">int</span> pos);</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Get</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Delete</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//__MY_SEQLIST_H__</span></span></span><br></pre></td></tr></table></figure><p><strong>栈的链式存储设计与实现</strong></p><img src="/images/imageProgramC/数据结构-31.png"><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_LINKSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_LINKSTACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack* <span class="title">LinkStack_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack_Destroy</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack_Clear</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack_Push</span><span class="params">(LinkStack* <span class="built_in">stack</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkStack_Pop</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkStack_Top</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack_Size</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_LINKSTACK_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>栈的应用</strong></p><p><strong>案例1：就近匹配</strong></p><blockquote><p>应用1：就近匹配 </p><p>几乎所有的编译器都具有检测括号是否匹配的能力</p><p>如何实现编译器中的符号成对检测？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>]; </span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">4</span>]; </span><br><span class="line">    p = a[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>算法思路</p><ul><li><p>从第一个字符开始扫描</p></li><li><p>当遇见普通字符时忽略，</p></li><li><p>当遇见左符号时压入栈中</p></li><li><p>当遇见右符号时从栈中弹出栈顶符号，并进行匹配</p><ul><li>匹配成功：继续读入下一个字符</li><li>匹配失败：立即停止，并报错</li></ul></li><li><p>结束：</p><ul><li>成功: 所有字符扫描完毕，且栈为空</li><li>失败：匹配失败或所有字符扫描完毕但栈非空</li></ul></li></ul></blockquote><p>当需要检测成对出现但又互不相邻的事物时，可以使用栈 “后进先出” 的特性，栈非常适合于需要“就近匹配”的场合</p><p><strong>案例2：中缀表达式和后缀表达式</strong></p><blockquote><p>应用2：中缀 后缀</p></blockquote><blockquote><p>计算机的本质工作就是做数学运算，那计算机可以读入字符串</p><p>“9 + (3 - 1) * 5 + 8 / 2”并计算值吗？</p></blockquote><blockquote><p>后缀表达式  ==？符合计算机运算</p><p>波兰科学家在20世纪50年代提出了一种将运算符放在数字后面的后缀表达式对应的，</p><p>我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例：</span></span><br><span class="line"><span class="number">5</span> + <span class="number">4</span>=&gt; <span class="number">5</span> <span class="number">4</span> +  </span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> * <span class="number">3</span> =&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> * +  </span><br><span class="line"><span class="number">8</span> + ( <span class="number">3</span> – <span class="number">1</span> ) * <span class="number">5</span> =&gt; <span class="number">8</span> <span class="number">3</span> <span class="number">1</span> – <span class="number">5</span> * +</span><br></pre></td></tr></table></figure><blockquote><p>中缀表达式符合人类的阅读和思维习惯</p><p>后缀表达式符合计算机的“运算习惯”</p><p>如何将中缀表达式转换成后缀表达式？</p></blockquote><blockquote><p>中缀转后缀算法：</p><ul><li><p>遍历中缀表达式中的数字和符号</p></li><li><p>对于数字：直接输出</p></li><li><p>对于符号：</p><ul><li>左括号：进栈  </li><li>运算符号：与栈顶符号进行优先级比较<ul><li>若栈顶符号优先级低：此符合进栈  （默认栈顶若是左括号，左括号优先级最低）</li><li>若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈</li></ul></li></ul></li><li><p>右括号：将栈顶符号弹出并输出，直到匹配左括号</p></li><li><p>遍历结束：将栈中的所有符号弹出并输出</p></li><li><p>中缀转后缀</p></li></ul></blockquote><img src="/images/imageProgramC/数据结构-32.png"><blockquote><p>计算机是如何基于后缀表达式计算的？</p><p>8 3 1 – 5 * + </p></blockquote><blockquote><p>遍历后缀表达式中的数字和符号</p><p>对于数字：进栈</p><p>对于符号：</p><ul><li><p>从栈中弹出右操作数</p></li><li><p>从栈中弹出左操作数</p></li><li><p>根据符号进行运算</p></li><li><p>将运算结果压入栈中</p></li></ul><p>遍历结束：栈中的唯一数字为计算结果</p></blockquote><img src="/images/imageProgramC/数据结构-33.png"><blockquote><p>栈的神奇！    </p><p>中缀表达式是人习惯的表达方式</p><p>后缀表达式是计算机喜欢的表达方式</p><p>通过栈可以方便的将中缀形式变换为后缀形式</p><p>中缀表达式的计算过程类似程序编译运行的过程  </p></blockquote><blockquote><p>扩展：给你一个字符串，计算结果</p><p>“1 + 2 * (66 / (2 * 3) + 7 )”   </p><ul><li><p>字符串解析</p></li><li><p>词法语法分析</p></li><li><p>优先级分析     </p></li><li><p>数据结构选型===》栈还是树？</p></li></ul></blockquote><h3 id="3-2-队列queue"><a href="#3-2-队列queue" class="headerlink" title="3.2 队列queue"></a>3.2 <strong>队列queue</strong></h3><p><strong>queue基本概念</strong></p><ul><li><p>队列是一种特殊的线性表  </p></li><li><p>队列仅在线性表的两端进行操作</p></li><li><p>队头(Front)：取出数据元素的一端</p></li><li><p>队尾(Rear)：插入数据元素的一端</p></li><li><p>队列不允许在中间部位进行操作！</p></li></ul><img src="/images/imageProgramC/数据结构-34.png"><p><strong>queue常用操作</strong></p><ul><li><p>销毁队列</p></li><li><p>清空队列</p></li><li><p>进队列</p></li><li><p>出队列</p></li><li><p>获取队头元素</p></li><li><p>获取队列的长度</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue* <span class="title">Queue_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Destroy</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Clear</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Append</span><span class="params">(Queue* <span class="built_in">queue</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Queue_Retrieve</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Queue_Header</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Length</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_QUEUE_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>队列模型和链表模型关系分析</strong></p><img src="/images/imageProgramC/数据结构-35.png"><p><strong>队列的顺序存储设计与实现</strong></p><p>队列也是一种特殊的线性表；可以用线性表顺序存储来模拟队列。</p><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_SEQQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_SEQQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqQueue* <span class="title">SeqQueue_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue_Destroy</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue_Clear</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue_Append</span><span class="params">(SeqQueue* <span class="built_in">queue</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">SeqQueue_Retrieve</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">SeqQueue_Header</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue_Length</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue_Capacity</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_SEQQUEUE_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>队列的链式存储设计与实现</strong></p><p>队列也是一种特殊的线性表；可以用线性表链式存储来模拟队列的链式存储。</p><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_LINKQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_LINKQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkQueue* <span class="title">LinkQueue_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue_Destroy</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue_Clear</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue_Append</span><span class="params">(LinkQueue* <span class="built_in">queue</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkQueue_Retrieve</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkQueue_Header</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue_Length</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_LINKQUEUE_H_</span></span></span><br></pre></td></tr></table></figure><h2 id="四、树专题"><a href="#四、树专题" class="headerlink" title="四、树专题"></a>四、树专题</h2><p><strong>树基本概念</strong></p><p>非线性结构，一个直接前驱，但可能有多个直接后继（1:n）</p><img src="/images/imageProgramC/数据结构-79.png"><img src="/images/imageProgramC/数据结构-78.png"><p><strong>树的表示法</strong></p><ul><li><p>图形表示法</p></li><li><p>广义表表示法</p></li><li><p>左孩子－右兄弟表示法</p></li><li><p>双亲孩子表示法</p></li></ul><p><strong>树的逻辑结构</strong></p><ul><li><p>一对多（1:n），有多个直接后继（如家谱树、目录树等等），但只有一个根结点，且子树之间互不相交。</p></li><li><p>广义表表示法</p></li><li><p>左孩子－右兄弟表示法</p></li></ul><h3 id="4-1-二叉树概念"><a href="#4-1-二叉树概念" class="headerlink" title="4.1 二叉树概念"></a>4.1 二叉树概念</h3><img src="/images/imageProgramC/数据结构-80.png"><img src="/images/imageProgramC/数据结构-81.png"><img src="/images/imageProgramC/数据结构-82.png"><img src="/images/imageProgramC/数据结构-83.png"><img src="/images/imageProgramC/数据结构-84.png"><img src="/images/imageProgramC/数据结构-85.png"><img src="/images/imageProgramC/数据结构-86.png"><img src="/images/imageProgramC/数据结构-87.png"><img src="/images/imageProgramC/数据结构-38.png"><p>先序遍历（DLR）：先访问根、再访问左、再访问右</p><p>中序遍历（LDR）：先访问左、再访问根、再访问右</p><p>后序遍历（LRD）：先访问左、再访问右、再访问根</p><img src="/images/imageProgramC/数据结构-88.png"><img src="/images/imageProgramC/数据结构-89.png"><p>二叉树的结构最简单，规律性最强。可以证明，所有树都能转为唯一对应的二叉树，不失一般性</p><p>定义：是 n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成</p><p>二叉树性质</p><blockquote><p>性质1: 在二叉树的第 <code>i</code> 层上至多有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PTJee2ktMX0=" title="https://www.codecogs.com/eqnedit.php?latex=2^{i-1}"><img src="https://latex.codecogs.com/gif.latex?2^{i-1}" title="2^{i-1}"><i class="fa fa-external-link"></i></span> 个结点（<code>i&gt;0</code>）</p></blockquote><blockquote><p>性质2: 深度为 <code>k</code> 的二叉树至多有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PTJeayZzcGFjZTstMQ==" title="https://www.codecogs.com/eqnedit.php?latex=2^k&space;-1"><img src="https://latex.codecogs.com/gif.latex?2^k&space;-1" title="2^k -1"><i class="fa fa-external-link"></i></span> 个结点（<code>k&gt;0</code>）</p></blockquote><blockquote><p>性质3: 对于任何一棵二叉树，若 2 度的结点数有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMg==" title="https://www.codecogs.com/eqnedit.php?latex=n_2"><img src="https://latex.codecogs.com/gif.latex?n_2" title="n_2"><i class="fa fa-external-link"></i></span> 个，则叶子数（<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMA==" title="https://www.codecogs.com/eqnedit.php?latex=n_0"><img src="https://latex.codecogs.com/gif.latex?n_0" title="n_0"><i class="fa fa-external-link"></i></span>）必定为 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMiZzcGFjZTsmcGx1czsmc3BhY2U7MQ==" title="https://www.codecogs.com/eqnedit.php?latex=n_2&space;&plus;&space;1"><img src="https://latex.codecogs.com/gif.latex?n_2&space;&plus;&space;1" title="n_2 + 1"><i class="fa fa-external-link"></i></span> （即<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMCZzcGFjZTs9JnNwYWNlO25fMiZzcGFjZTsmcGx1czsmc3BhY2U7MQ==" title="https://www.codecogs.com/eqnedit.php?latex=n_0&space;=&space;n_2&space;&plus;&space;1"><img src="https://latex.codecogs.com/gif.latex?n_0&space;=&space;n_2&space;&plus;&space;1" title="n_0 = n_2 + 1"><i class="fa fa-external-link"></i></span>）</p></blockquote><p>满二叉树：一棵深度为 <code>k</code> 且有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PTJeayZzcGFjZTstJnNwYWNlOzE=" title="https://www.codecogs.com/eqnedit.php?latex=2^k&space;-&space;1"><img src="https://latex.codecogs.com/gif.latex?2^k&space;-&space;1" title="2^k - 1"><i class="fa fa-external-link"></i></span> 个结点的二叉树。（特点：每层都“充满”了结点）</p><p>完全二叉树：深度为 <code>k</code> 的，有 <code>n</code> 个结点的二叉树，当且仅当其每一个结点都与深度为 <code>k</code> 的满二叉树中编号从 1 至 <code>n</code> 的结点一一对应。</p><p>理解：（<code>k-1</code> 层与满二叉树完全相同，第 <code>k</code> 层结点尽力靠左）</p> <img src="/images/imageProgramC/数据结构-36.png"><blockquote><p>性质4: 具有 <code>n</code> 个结点的完全二叉树的深度必为 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PXxcbG9nXzJufCZzcGFjZTsmcGx1czsmc3BhY2U7MQ==" title="https://www.codecogs.com/eqnedit.php?latex=|\log_2n|&space;&plus;&space;1"><img src="https://latex.codecogs.com/gif.latex?|\log_2n|&space;&plus;&space;1" title="|\log_2n| + 1"><i class="fa fa-external-link"></i></span></p></blockquote><blockquote><p>性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为 <code>i</code> 的结点，其左孩子编号必为 <code>2i</code>，其右孩子编号必为 <code>2i + 1</code>；其双亲的编号必为 <code>i/2</code>（<code>i=1</code> 时为根,除外）</p></blockquote><p><strong>二叉树的存储结构</strong></p><ul><li><p>1、顺序存储结构</p><p>按二叉树的结点“自上而下、从左至右”编号，用一组连续的存储单元存储。</p><p>答：一律转为完全二叉树！</p><p>讨论：不是完全二叉树怎么办？</p><p>方法很简单，将各层空缺处统统补上“虚结点”，其内容为空</p></li><li><p>2、链式存储结构</p></li></ul><p><strong>二叉树的表示</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct BiTNode</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">intdata;</span></span><br><span class="line"><span class="comment"> struct BiTNode *lchild, *rchild;</span></span><br><span class="line"><span class="comment">&#125;BiTNode, *BiTree;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> <span class="title">BiTNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> * <span class="title">BiTree</span>;</span></span><br></pre></td></tr></table></figure><p><strong>树的三叉链表表示</strong></p><img src="/images/imageProgramC/数据结构-37.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="comment">//左右孩子指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">&#125;TriTNode, *TriTree;</span><br><span class="line"></span><br><span class="line">双亲链表法</span><br><span class="line"><span class="comment">//双亲链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> parentPosition; <span class="comment">//指向双亲的指针 //数组下标</span></span><br><span class="line"><span class="keyword">char</span> LRTag; <span class="comment">//左右孩子标志域</span></span><br><span class="line">&#125;BPTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BPTNode nodes[<span class="number">100</span>]; <span class="comment">//因为节点之间是分散的，需要把节点存储到数组中</span></span><br><span class="line"><span class="keyword">int</span> num_node;  <span class="comment">//节点数目</span></span><br><span class="line"><span class="keyword">int</span> root; <span class="comment">//根结点的位置 //注意此域存储的是父亲节点在数组的下标</span></span><br><span class="line">&#125;BPTree;</span><br><span class="line"><span class="comment">//用这个数据结构能表达出一颗树，为什么？</span></span><br></pre></td></tr></table></figure><p><strong>二叉树的遍历</strong></p><img src="/images/imageProgramC/数据结构-38.png"><p>树的遍历本质剖析</p><img src="/images/imageProgramC/数据结构-39.png"><h3 id="4-2-二叉树编程实践"><a href="#4-2-二叉树编程实践" class="headerlink" title="4.2 二叉树编程实践"></a>4.2 二叉树编程实践</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span>  data; </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>；</span></span><br><span class="line"><span class="class">&#125; <span class="title">NODE</span>;</span></span><br><span class="line">NODE *root;</span><br></pre></td></tr></table></figure><p><strong>先序遍历算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DLR(NODE *root )</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (root) <span class="comment">//非空二叉树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“%d”,root-&gt;data); <span class="comment">//访问D</span></span><br><span class="line">        DLR(root-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">        DLR(root-&gt;rchild); <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LDR(NODE *root)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(root !=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        LDR(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(“%d”,root-&gt;data);</span><br><span class="line">        LDR(root-&gt;rchild); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LRD (NODE *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root !=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        LRD(root-&gt;lchild);</span><br><span class="line">        LRD(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(“%d”,root-&gt;data); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例1：计算二叉树中叶子结点的数目</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//全局变量</span></span><br><span class="line">DLR_CountLeafNum(NODE *root)<span class="comment">//采用中序遍历的递归算法</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> ( root)  <span class="comment">//非空二叉树条件，还可写成if(root !=NULL )</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;lchild&amp;&amp;!root-&gt;rchild)  <span class="comment">//是叶子结点则统计并打印</span></span><br><span class="line">        &#123;   </span><br><span class="line">            sum++;     </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);  </span><br><span class="line">        &#125;</span><br><span class="line">        DLR_CountLeafNum(root-&gt;lchild); <span class="comment">//递归遍历左子树，直到叶子处；</span></span><br><span class="line">        DLR_CountLeafNum(root-&gt;rchild);&#125;<span class="comment">//递归遍历右子树，直到叶子处；</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思想：    1）求根结点左子树的叶子结点个数，累计到sum中，求根结点右子树的叶子结点个数累计到sum中。<br>​        2）若左子树还是树，重复步骤1；若右子树还是树，重复步骤1。<br>​        3）全局变量转成函数参数<br>​        4）按照先序、中序、后序方式计算叶子结点，<br>===》三种遍历的本质思想强化：访问结点的路径都是一样的，计算结点的时机不同。</p></blockquote><p><strong>案例2：求二叉树的深度</strong></p><blockquote><p>思想：    1）求根结点左子树高度，根结点右子树高度，比较的子树最大高度，再 +1。</p><p>​        2）若左子树还是树，重复步骤 1；若右子树还是树，重复步骤 1。</p></blockquote><p><strong>案例3：完全Copy二叉树</strong></p><blockquote><p>思想：    1）malloc新结点，</p><p>​        2）拷贝左子树，拷贝右子树，让新结点连接左子树，右子树</p><p>​        3）若左子树还是树，重复步骤1、2；若右子树还是树，重复步骤1、2。</p></blockquote><p><strong>案例4：树的非递归遍历(中序遍历)</strong></p><blockquote><p>中序 遍历的几种情况</p><p>分析1：</p><ul><li>什么时候访问根、什么时候访问左子树、什么访问右子树</li><li>当左子树为空或者左子树已经访问完毕以后，再访问根</li><li>访问完毕根以后，再访问右子树。</li></ul><p>分析2：</p><ul><li>非递归遍历树，访问结点时，为什么是栈，而不是其他模型（比如说是队列）。</li><li>先走到的后访问、后走到的先访问，显然是栈结构</li></ul><p>分析3：结点所有路径情况</p><ul><li><p>步骤1：</p><ul><li>如果结点有左子树，该结点入栈；</li><li>如果结点没有左子树，访问该结点；</li></ul></li><li><p>步骤2：</p><ul><li>如果结点有右子树，重复步骤1；</li><li>如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1</li><li>如果栈为空，表示遍历结束。 </li></ul></li></ul><p>注意：入栈的结点表示，本身没有被访问过，同时右子树也没有被访问过。</p><p>分析4：有一个一直往左走入栈的操作，中序遍历的起点</p></blockquote><img src="/images/imageProgramC/数据结构-40.png"><img src="/images/imageProgramC/数据结构-41.png"><p>作业：自己编写堆栈函数原型，实现中序遍历非递归算法</p><h3 id="4-3-二叉树的创建"><a href="#4-3-二叉树的创建" class="headerlink" title="4.3 二叉树的创建"></a>4.3 <strong>二叉树的创建</strong></h3><p><strong>中序和先序创建树</strong></p><p>1、根据中序遍历的结果能确定一棵树吗？</p><p>中序遍历：结果为：“12345”，这个“12345”能确定一棵树吗？</p><p>请思考，会有多少种形状。</p><p>2、如何才能确定一棵树？</p><blockquote><p>结论：    通过中序遍历和先序遍历可以确定一个树</p><p>​        通过中序遍历和后续遍历可以确定一个树</p><p>​        通过先序遍历和后序遍历确定不了一个树。</p></blockquote><p>单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。</p><p>3、根据先序和中序结果画树</p><blockquote><p>算法</p><p>1、通过先序遍历找到根结点A，再通过A在中序遍历的位置找出左子树，右子树</p><p>2、在A的左子树中，找左子树的根结点（在先序中找），转步骤1</p><p>3、在A的右子树中，找右子树的根结点（在先序中找），转步骤1</p></blockquote><blockquote><p>讲解：</p><p>先序遍历结果：ADEBCF</p><p>中序遍历结果：DEACFB</p></blockquote><blockquote><p>练习：</p><p>先序遍历结果：ABDHKECFIGJ</p><p>中序遍历结果：HKDBEAIFCGJ</p></blockquote><p>4、学习算法可借助工具、动画</p><p><strong>#号法创建树</strong></p><p>1、什么是 <code>#</code> 号法创建树</p><p><code>#</code> 创建树，让树的每一个节点都变成度数为2的树</p><img src="/images/imageProgramC/数据结构-42.png"><p>先序遍历：<code>124###3##</code> 可以唯一确定一棵树吗，为什么？</p><img src="/images/imageProgramC/数据结构-43.png"><p>2、<code>#</code> 创建树练习</p><p>先序遍历：<code>ABDH#K###E##CFI###G#J##</code> ,请画出树的形状</p><p><code>#</code> 号法画出树关键点：</p><p>要清楚的确定<strong>左子树什么结束</strong>，<strong>右子树什么时候开始</strong>。</p><p>3、<code>#</code> 号法编程实践</p><p>利用前序遍历来建树（结点值陆续从键盘输入，用 DLR 为宜）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bintree <span class="title">createBTpre</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    Bintree T; </span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(“%c”,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch==’#’) </span><br><span class="line">        T=<span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        T=( Bintree )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTNode));</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        T-&gt;lchild=createBTpre(); </span><br><span class="line">        T-&gt;rchild=createBTpre();</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历销毁一个树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BiTree_Free</span><span class="params">(BiTNode* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode *tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (T!= <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T-&gt;rchild != <span class="literal">NULL</span>) BiTree_Free(T-&gt;rchild);</span><br><span class="line"><span class="keyword">if</span> (T-&gt;lchild != <span class="literal">NULL</span>) BiTree_Free(T-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(T); </span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-二叉线索树"><a href="#4-4-二叉线索树" class="headerlink" title="4.4 二叉线索树"></a>4.4 <strong>二叉线索树</strong></h3><p><strong>线索化概念</strong></p><p>1、前言</p><p>普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得。</p><p>若可将遍历后对应的有关前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树了。</p><p>二叉线索树思想是干什么的？</p><img src="/images/imageProgramC/数据结构-44.png"><p>中序遍历这棵树===》转换成链表访问</p><p>2、线索化思想</p><img src="/images/imageProgramC/数据结构-45.png"><img src="/images/imageProgramC/数据结构-46.png"><img src="/images/imageProgramC/数据结构-47.png"><blockquote><p>结论：    线索化过程就是在遍历过程（假设是中序遍历）中修改空指针的过程：</p><p>​        将空的lchild改为结点的直接前驱；</p><p>​        将空的rchild改为结点的直接后继。</p></blockquote><p>3、线索化思想训练</p><img src="/images/imageProgramC/数据结构-48.png"><p>请将此树线索化。</p><p>1）右空指针线索化：</p><img src="/images/imageProgramC/数据结构-49.png"><p>2）左空指针线索化</p><img src="/images/imageProgramC/数据结构-50.png"><p>3）总结</p><img src="/images/imageProgramC/数据结构-51.png"><p><strong>线索化的实现</strong></p><p>1）线索化树结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>/* 二叉线索存储结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>data;<span class="comment">/* 结点数据 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">/* 左右孩子指针 */</span></span><br><span class="line"><span class="keyword">int</span>LTag;</span><br><span class="line"><span class="keyword">int</span>RTag;<span class="comment">/* 左右标志 */</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><p>2）线索化思想分析</p><img src="/images/imageProgramC/数据结构-52.png"><p>线索化的本质：让前后结点，建立关系；</p><p>1）两个辅助指针变量形成差值后：后继结点的左孩子指向前驱结点，前驱结点的右孩子指向后继结点。</p><p>2）赋值指针变量和业务操作的逻辑关系</p><img src="/images/imageProgramC/数据结构-53.png"><img src="/images/imageProgramC/数据结构-54.png"><p>4） 二叉树线索化树的遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 中序遍历二叉线索树T(头结点)的非递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrNode* T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">BiThrNode* p;</span><br><span class="line">p = T-&gt;lchild; <span class="comment">/* p指向根结点 */</span></span><br><span class="line"><span class="keyword">while</span> (p != T)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">/* 空树或遍历结束时,p==T */</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;LTag == Link)</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-霍夫曼树"><a href="#4-5-霍夫曼树" class="headerlink" title="4.5 霍夫曼树"></a>4.5 <strong>霍夫曼树</strong></h3><p>组建一个网络，耗费最小 WPL最小；这个方法是霍夫曼想出来的，称为霍夫曼树</p><img src="/images/imageProgramC/数据结构-55.png"><p><strong>霍夫曼树的构造</strong></p><p>对于文本 ”BADCADFEED” 的传输而言，因为重复出现的只有 ”ABCDEF” 这6个字符，因此可以用下面的方式编码：</p><img src="/images/imageProgramC/数据结构-56.png"><p>接收方可以根据每3个bit进行一次字符解码的方式还原文本信息。</p><p>这样的编码方式需要30个bit位才能表示10个字符</p><p>那么当传输一篇500个字符的情报时，需要15000个bit位</p><p>在战争年代，这种编码方式对于情报的发送和接受是很低效且容易出错的。</p><p>如何提高收发效率？</p><p>要提高效率，必然要从编码方式的改进入手，要避免每个字符都占用相同的bit位</p><img src="/images/imageProgramC/数据结构-57.png"><p>准则：任一字符的<strong>编码</strong>都不是另一个字符编码的前缀！</p><p>也就是说：每一个字符的编码路径，都不包含另外一个字符的路径。</p><blockquote><p>霍夫曼树</p><p>1、给定 n 个数值 { v1, v2, …, vn}</p><p>2、根据这 n 个数值构造二叉树集合 F</p><p>F = { T1, T2, …, Tn}</p><p>Ti 的数据域为 vi，左右子树为空</p><p>3、在 F 中选取两棵根结点的值最小的树作为左右子树构造一棵新的二叉树，这棵二叉树的根结点中的值为左右子树根结点中的值之和</p><p>4、在 F 中删除这两棵子树，并将构造的新二叉树加入F中</p><p>5、重复 3 和 4，直到 F 中只剩下一个树为止。这棵树即霍夫曼树</p></blockquote><p>假设经过统计 ABCDEF 在需要传输的报文中出现的概率如下</p><img src="/images/imageProgramC/数据结构-58.png"><img src="/images/imageProgramC/数据结构-59.png"><p>霍夫曼树是一种特殊的二叉树           </p><p>霍夫曼树应用于信息编码和数据压缩领域 </p><p>霍夫曼树是现代压缩算法的基础 </p><h2 id="五、-排序"><a href="#五、-排序" class="headerlink" title="五、 排序"></a>五、 排序</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。</p><p>排序数学定义：</p><ul><li>假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：Kp1≤Kp2≤…≤Kpn 。按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序 </li></ul><p>排序的稳定性：</p><ul><li>如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的；否则称这个排序方法是不稳定的。</li></ul><p>多关键字排序：</p><ul><li><p>排序时需要比较的关键字多余一个</p></li><li><p>排序结果首先按关键字1进行排序</p></li><li><p>当关键字1相同时按关键字2进行排序</p></li><li><p>当关键字n-1相同时按关键字n进行排序</p></li><li><p>对于多关键字排序，只需要在比较操作时同时考虑多个关键字即可！</p></li></ul><p>排序中的关键操作：</p><ul><li><p>比较</p><ul><li>任意两个数据元素通过比较操作确定先后次序</li></ul></li><li><p>交换</p><ul><li>数据元素之间需要交换才能得到预期结果</li></ul></li></ul><p>内排序和外排序：</p><ul><li><p>内排序</p><ul><li>整个排序过程不需要访问外存便能完成  </li></ul></li><li><p>外排序</p><ul><li>待排序的数据元素数量很大，整个序列的排序过程不可能在内存中完成</li></ul></li></ul><p>排序的审判：</p><ul><li><p>时间性能</p><ul><li>关键性能差异体现在比较和交换的数量  </li></ul></li><li><p>辅助存储空间</p><ul><li>为完成排序操作需要的额外的存储空间  </li><li>必要时可以“空间换时间”</li></ul></li><li><p>算法的实现复杂性</p><ul><li>过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能</li></ul></li></ul><p>总结：</p><ul><li><p>排序是数据元素从无序到有序的过程</p></li><li><p>排序具有稳定性，是选择排序算法的因素之一</p></li><li><p>比较和交换是排序的基本操作</p></li><li><p>多关键字排序与单关键字排序无本质区别</p></li><li><p>排序的时间性能是区分排序算法好坏的主要因素</p></li></ul><h3 id="5-2-选择法"><a href="#5-2-选择法" class="headerlink" title="5.2 选择法"></a>5.2 选择法</h3><p>基本思想：</p><ul><li>每一趟 (例如第 i 趟，i = 0, 1, …,n-2)在后面 n-i个待排的数据元素中选出关键字最小的元素, 作为有序元素序列的第 i 个元素。</li></ul><p>排序过程：</p><ul><li><p>首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换</p></li><li><p>再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第二个记录交换</p></li><li><p>重复上述操作，共进行n-1趟排序后，排序结束</p></li></ul><img src="/images/imageProgramC/数据结构-60.png"><img src="/images/imageProgramC/数据结构-61.png"><h3 id="5-3-插入排序"><a href="#5-3-插入排序" class="headerlink" title="5.3 插入排序"></a>5.3 插入排序</h3><p>基本思想：</p><ul><li>元素1个元素，</li></ul><p>排序过程：</p><ul><li>整个排序过程为 n-1 趟插入，即先将序列中第 1 个记录看成是一个有序子序列，然后从第 2 个记录开始，逐个进行插入，直至整个序列有序</li></ul><p>实质：对线性表执行 n-1 次插入操作，只是先要找到插入位置</p><p>V[0], V[1], …, V[i-1] 已经排好序。这时已经排好序。这时,用V[i]的关键字与 V[i-1], V[i-2], …的关键字进行比较, 找到插入位置即将V[i]]插入, 原来位置上的对象向后顺移。</p><p>插入排序关键点：</p><ul><li>1、拿出一个元素，留出位置</li><li>2、符合条件的元素后移</li></ul><img src="/images/imageProgramC/数据结构-62.png"><h3 id="5-4-冒泡排序"><a href="#5-4-冒泡排序" class="headerlink" title="5.4 冒泡排序"></a>5.4 冒泡排序</h3><img src="/images/imageProgramC/数据结构-63.png"><img src="/images/imageProgramC/数据结构-64.png"><h3 id="5-5-希尔排序"><a href="#5-5-希尔排序" class="headerlink" title="5.5 希尔排序"></a>5.5 希尔排序</h3><p>排序过程：</p><ul><li>先取一个正整数 d1&lt;n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2&lt;d1，重复上述分组和排序操作；直至 di=1，即所有记录放进一个组中排序为止</li></ul><p>O(n-1.3)</p><p>Q(nlogn)    </p><p>希尔排序是不稳定的。</p><img src="/images/imageProgramC/数据结构-65.png"><h3 id="5-6-快速排序"><a href="#5-6-快速排序" class="headerlink" title="5.6 快速排序"></a>5.6 快速排序</h3><p>思想：</p><ul><li><p>快速排序是对冒泡排序的一种改进。它的基本思想是：</p></li><li><p>通过一躺排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，基准数据排在这两个子序列的中间；</p></li><li><p>然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></li></ul><img src="/images/imageProgramC/数据结构-67.png"><img src="/images/imageProgramC/数据结构-68.png"><img src="/images/imageProgramC/数据结构-69.png"><img src="/images/imageProgramC/数据结构-70.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n*logn)</span></span><br><span class="line">不稳定，分组，后面的有可能跑到前面去了。</span><br><span class="line"><span class="number">21</span> <span class="number">100</span> <span class="number">3</span> <span class="number">50</span> <span class="number">1</span>  </span><br><span class="line"><span class="number">3</span> <span class="number">1</span>  <span class="number">21</span>  <span class="number">100</span> <span class="number">50</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span>    <span class="number">21</span>   <span class="number">50</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="5-7-归并排序"><a href="#5-7-归并排序" class="headerlink" title="5.7 归并排序"></a>5.7 归并排序</h3><p>注意：一个元素，可以看做有序的，是稳定的算法</p><img src="/images/imageProgramC/数据结构-71.png"><img src="/images/imageProgramC/数据结构-72.png"><img src="/images/imageProgramC/数据结构-73.png"><p>对一个数组分成两路，mid中间</p><img src="/images/imageProgramC/数据结构-74.png"><p>设两个有序的子文件(相当于输入堆)放在同一向量中相邻的位置上：R[low..m],R[m+1..high],先将它们合并到一个局部的暂存向量R1(相当于输出堆)中,待合并完成后将R1复制回R[low..high]中。  </p><img src="/images/imageProgramC/数据结构-75.png"><h3 id="5-8-排序总结"><a href="#5-8-排序总结" class="headerlink" title="5.8 排序总结"></a>5.8 排序总结</h3><img src="/images/imageProgramC/数据结构-90.png"><h2 id="六、C-模板类与数据结构基础"><a href="#六、C-模板类与数据结构基础" class="headerlink" title="六、C++ 模板类与数据结构基础"></a>六、C++ 模板类与数据结构基础</h2><p>C++模板是容器的概念。</p><img src="/images/imageProgramC/数据结构-77.png"><p><strong>理论提高：</strong>所有容器提供的都是值（value）语意，而非引用（reference）语意。<strong>容器执行插入元素的操作时，内部实施拷贝动作。</strong>所以STL容器内存储的元素必须<strong>能够被拷贝</strong>（必须提供拷贝构造函数）。</p><p>加入到容器中的元素，应该可以被加入才行。</p><p><strong>模板类设计与实现</strong></p><blockquote><p>链表类_链式存储设计与实现 </p><p>栈类_链式存储设计与实现 </p><p>队列类_链式存储设计与实现 </p></blockquote><blockquote><p>链表类_顺序存储设计与实现 </p><p>栈类_顺序存储设计与实现 </p><p>队列类_顺序存储设计与实现 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://miaopei.github.io/categories/DataStructure/"/>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/DataStructure/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
      <category term="DataStructure" scheme="http://miaopei.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>C 进阶</title>
    <link href="http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/"/>
    <id>http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/</id>
    <published>2016-05-24T02:14:50.000Z</published>
    <updated>2019-06-14T06:13:11.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-语言进阶"><a href="#C-语言进阶" class="headerlink" title="C 语言进阶"></a>C 语言进阶</h1><h2 id="一、-内存分区"><a href="#一、-内存分区" class="headerlink" title="一、 内存分区"></a>一、 内存分区</h2><p>栈区</p><ul><li>由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。</li></ul><a id="more"></a><p>堆区</p><ul><li>由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：在内存动态存储区中分配nmemb块长度为size字节的连续区域。<span class="built_in">calloc</span>自动将分配的内存置<span class="number">0</span>。</span><br><span class="line">参数：</span><br><span class="line">nmemb：所需内存单元数量</span><br><span class="line">size：每个内存单元的大小（单位：字节）</span><br><span class="line">返回值：</span><br><span class="line">成功：分配空间的起始地址</span><br><span class="line">失败：<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：重新分配用<span class="built_in">malloc</span>或者<span class="built_in">calloc</span>函数在堆中分配内存空间的大小。<span class="built_in">realloc</span>不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么<span class="built_in">realloc</span>会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。</span><br><span class="line">参数：</span><br><span class="line">ptr：为之前用<span class="built_in">malloc</span>或者<span class="built_in">calloc</span>分配的内存地址，如果此参数等于<span class="literal">NULL</span>，那么和<span class="built_in">realloc</span>与<span class="built_in">malloc</span>功能一致</span><br><span class="line">size：为重新分配内存的大小, 单位：字节</span><br><span class="line">返回值：</span><br><span class="line">成功：新分配的堆内存地址</span><br><span class="line">失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>全局/静态区</p><ul><li><p>全局静态区内的变量在编译阶段已经分配好内存空间并初始化。这块内存在程序运行期间一直存在,它主要存储<strong>全局变量</strong>、<strong>静态变量</strong>和<strong>常量</strong>。</p><p><strong>注意</strong>：</p><ul><li>这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。</li><li>全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。</li><li>字符串常量存储在全局/静态存储区的常量区。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">10</span>;<span class="comment">//全局/静态区</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> v2 = <span class="number">20</span>; <span class="comment">//常量，一旦初始化，不可修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> v3 = <span class="number">20</span>; <span class="comment">//全局/静态区</span></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局/静态区，编译器默认初始化为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么全局static int 和 全局int变量有什么区别？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> v4 = <span class="number">20</span>; <span class="comment">//全局/静态区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串常量是否可修改？字符串常量优化</strong>：</p><table><thead><tr><th>ANSI C中规定：修改字符串常量，结果是未定义的。<br>ANSI C并没有规定编译器的实现者对字符串的处理，例如：<br>1. 有些编译器可修改字符串常量，有些编译器则不可修改字符串常量。<br>2. 有些编译器把多个相同的字符串常量看成一个（这种优化可能出现在字符串常量中，节省空间），有些则不进行此优化。如果进行优化，则可能导致修改一个字符串常量导致另外的字符串常量也发生变化，结果不可知。<br><strong>所以尽量不要去修改字符串常量</strong>！</th></tr></thead><tbody><tr><td>C99标准：<br>char <em>p = “abc”; defines p with type ‘‘pointer to char’’ and initializes it to point to an object with type ‘‘array of char’’ with length 4 whose elements are initialized with a character string literal. *</em>If an attempt is made to use p to modify the contents of the array, the behavior is undefined**.</td></tr></tbody></table><p><strong>总结</strong></p><p>在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等，初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。</p><p><strong>数据区包括</strong>：堆，栈，全局/静态存储区。</p><p><strong>全局/静态存储区包括</strong>：常量区，全局区、静态区。</p><p><strong>常量区包括</strong>：字符串常量区、常变量区。</p><p><strong>代码区</strong>：存放程序编译后的二进制代码，不可寻址区。</p><p><strong>可以说，C/C++内存分区其实只有两个，即代码区和数据区</strong>。</p><p>函数调用模型：</p><ul><li>在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。</li></ul><p>栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：</p><ul><li>函数的返回地址；</li><li>函数的参数；</li><li>临时变量；</li><li>保存的上下文：包括在函数调用前后需要保持不变的寄存器。</li></ul><img src="/images/imageProgramC/函数调用流程.png"><p>栈的生长方向和内存存放方向：</p><img src="/images/imageProgramC/栈的生长方向和内存存放方向.png"><h2 id="二、指针强化"><a href="#二、指针强化" class="headerlink" title="二、指针强化"></a>二、指针强化</h2><p><strong>指针是一种数据类型，占用内存空间，用来保存内存地址</strong>。</p><h3 id="2-1-野指针和空指针"><a href="#2-1-野指针和空指针" class="headerlink" title="2.1 野指针和空指针"></a>2.1 野指针和空指针</h3><h4 id="2-1-1-空指针"><a href="#2-1-1-空指针" class="headerlink" title="2.1.1 空指针"></a>2.1.1 空指针</h4><p>标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。</p><p>对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未执行任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。</p><p>如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。</p><p><strong>不允许向NULL和非法地址拷贝内存</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//给p指向的内存区域拷贝内容</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"1111"</span>); <span class="comment">//err</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *q = <span class="number">0x1122</span>;</span><br><span class="line"><span class="comment">//给q指向的内存区域拷贝内容</span></span><br><span class="line"><span class="built_in">strcpy</span>(q, <span class="string">"2222"</span>); <span class="comment">//err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-野指针"><a href="#2-1-2-野指针" class="headerlink" title="2.1.2 野指针"></a>2.1.2 野指针</h4><p><strong>在使用指针时，要避免野指针的出现</strong>：</p><p>野指针指向一个已删除的对象或未申请访问受限内存区域的<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzE1OTQxNy5odG0=" title="http://baike.baidu.com/view/159417.htm">指针<i class="fa fa-external-link"></i></span>。与空指针不同，野指针无法通过简单地判断是否为 <span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzMyOTQ4NC5odG0=" title="http://baike.baidu.com/view/329484.htm">NULL<i class="fa fa-external-link"></i></span>避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。</p><p><strong>什么情况下会导致野指针</strong>？</p><ul><li><p><strong>指针变量未初始化</strong></p><ul><li>任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</li></ul></li><li><p><strong>指针释放后未置空</strong></p><ul><li>有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。</li></ul></li><li><p><strong>指针操作超越变量作用域</strong></p><ul><li><strong>不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放</strong>。</li></ul></li></ul><p><strong>操作野指针是非常危险的操作，应该规避野指针的出现</strong>：</p><ul><li><p><strong>初始化时置 NULL</strong></p><ul><li>指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。</li></ul></li><li><p><strong>释放时置 NULL</strong></p><ul><li>当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。</li></ul></li></ul><p><strong>用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据</strong>，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。请看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func(), n;</span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value = %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">100</span></span><br></pre></td></tr></table></figure><p> n 是 func() 内部的局部变量，func() 返回了指向 n 的指针，根据上面的观点，func() 运行结束后 n 将被销毁，使用 <code>*p</code> 应该获取不到 n 的值。但是从运行结果来看，我们的推理好像是错误的，func() 运行结束后 <code>*p</code> 依然可以获取局部变量 n 的值，这个上面的观点不是相悖吗？</p><p>为了进一步看清问题的本质，不妨将上面的代码稍作修改，在第9~10行之间增加一个函数调用，看看会有什么效果：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func(), n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c.biancheng.net\n"</span>);</span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value = %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.biancheng.net</span><br><span class="line">value = <span class="number">-2</span></span><br></pre></td></tr></table></figure><p>可以看到，现在 p 指向的数据已经不是原来 n 的值了，它变成了一个毫无意义的甚至有些怪异的值。与前面的代码相比，该段代码仅仅是在 <code>*p</code> 之前增加了一个函数调用，这一细节的不同却导致运行结果有天壤之别，究竟是为什么呢？</p><p>前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。</p><blockquote><p>关于函数调用的原理以及函数如何占用内存的更多细节，我们将在《<span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9jcHAvdS9jMjAv" title="http://c.biancheng.net/cpp/u/c20/">C语言和内存<i class="fa fa-external-link"></i></span>》专题中深入探讨，相信你必将有所顿悟，解开心中的谜团。</p></blockquote><p>第一个例子在调用其他函数之前使用 <code>*p</code> 抢先获得了 n 的值并将它保存起来，第二个例子显然没有抓住机会，有其他函数被调用后才使用 <code>*p</code> 获取数据，这个时候已经晚了，内存已经被后来的函数覆盖了，而覆盖它的究竟是一份什么样的数据我们无从推断（一般是一个没有意义甚至有些怪异的值）。</p><p><strong>总结</strong>：</p><p>常规程序中，函数返回的指针通常应该是：</p><ul><li>指向静态（static）变量；</li><li>指向专门申请分配的（如用malloc）空间；</li><li>指向常量区（如指向字符串”hello”）；</li><li>指向全局变量；</li><li>指向程序代码区（如指向函数的指针）。 </li></ul><p>除这5项以外，其它怪技巧不提倡。</p><p><strong>函数内的变量，没有关键字static修饰的变量的生命周期只在本函数内，函数结束后变量自动销毁</strong>。当返回为指针的时候需要特别注意，因为<strong>函数结束后指针所指向的地址依然存在，但是该地址可以被其他程序修改，里面的内容就不确定了，有可能后面的操作会继续用到这块地址，有可能不会用到，所以会出现时对时错的情况，如果需要返回一个指针而又不出错的话只能调用内存申请函数</strong></p><h3 id="2-2-间接访问操作符"><a href="#2-2-间接访问操作符" class="headerlink" title="2.2 间接访问操作符"></a>2.2 间接访问操作符</h3><p>通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是 <code>*</code>。</p><p>注意：对一个<code>int*</code>类型指针解引用会产生一个整型值，类似地，对一个<code>float*</code>指针解引用会产生了一个float类型的值。</p><ul><li><p>在指针声明时，<code>*</code> 号表示所声明的变量为指针</p></li><li><p>在指针使用时，<code>*</code> 号表示操作指针所指向的内存空间</p><ul><li><code>*</code> 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存</li><li><code>*</code> 放在等号的左边赋值（给内存赋值，写内存）</li><li><code>*</code> 放在等号的右边取值（从内存中取值，读内存）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指针</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//指针指向谁，就把谁的地址赋给指针</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">p = &amp;a;</span><br><span class="line">*p = <span class="number">20</span>;<span class="comment">//*在左边当左值，必须确保内存可写</span></span><br><span class="line"><span class="comment">//*号放右面，从内存中读值</span></span><br><span class="line"><span class="keyword">int</span> b = *p;</span><br><span class="line"><span class="comment">//必须确保内存可写</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"hello world!"</span>;</span><br><span class="line">*str = <span class="string">'m'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p:%d\n"</span>, *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b:%d\n"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-指针的步长"><a href="#2-3-指针的步长" class="headerlink" title="2.3 指针的步长"></a>2.3 <strong>指针的步长</strong></h3><p>指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。</p><h3 id="2-4-指针的意义-间接赋值"><a href="#2-4-指针的意义-间接赋值" class="headerlink" title="2.4 指针的意义_间接赋值"></a>2.4 指针的意义_间接赋值</h3><p>通过指针间接赋值成立的三大条件：</p><ul><li><p>2个变量（一个普通变量一个指针变量、或者一个实参一个形参）</p></li><li><p>建立关系</p></li><li><p>通过 <code>*</code> 操作指针指向的内存</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;<span class="comment">//两个变量</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//建立关系</span></span><br><span class="line"><span class="comment">//指针指向谁，就把谁的地址赋值给指针</span></span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="comment">//通过*操作内存</span></span><br><span class="line">*p = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>间接赋值：从1级指针到2级指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllocateSpace</span><span class="params">(<span class="keyword">char</span>** p)</span></span>&#123;</span><br><span class="line">*p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(*p, <span class="string">"hello world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeSpace</span><span class="params">(<span class="keyword">char</span>** p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(*p);</span><br><span class="line">*p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AllocateSpace(&amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br><span class="line">FreeSpace(&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p内存释放!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>间接赋值的推论</strong>：</p><ul><li><p>用 1 级指针形参，去间接修改了 0 级指针(实参)的值。</p></li><li><p>用 2 级指针形参，去间接修改了 1 级指针(实参)的值。</p></li><li><p>用 3 级指针形参，去间接修改了 2 级指针(实参)的值。</p></li><li><p>用 n 级指针形参，去间接修改了 n-1 级指针(实参)的值。</p></li></ul><h3 id="2-5-指针做函数参数"><a href="#2-5-指针做函数参数" class="headerlink" title="2.5 指针做函数参数"></a>2.5 指针做函数参数</h3><p>指针做函数参数，具备输入和输出特性：</p><ul><li><p>输入：主调函数分配内存</p></li><li><p>输出：被调用函数分配内存</p></li></ul><p>输入特性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p <span class="comment">/* in */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//给p指向的内存区域拷贝内容</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"abcddsgsd"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输入，主调函数分配内存</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">fun(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf  = %s\n"</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出特性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> **p <span class="comment">/* out */</span>, <span class="keyword">int</span> *len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp, <span class="string">"adlsgjldsk"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//间接赋值</span></span><br><span class="line">*p = tmp;</span><br><span class="line">*len = <span class="built_in">strlen</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输出，被调用函数分配内存，地址传递</span></span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">fun(&amp;p, &amp;len);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p = %s, len = %d\n"</span>, p, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-字符串指针强化"><a href="#2-6-字符串指针强化" class="headerlink" title="2.6 字符串指针强化"></a>2.6 字符串指针强化</h3><p><strong>字符串是以0或者’\0’结尾的字符数组，(数字0和字符’\0’等价)</strong></p><p><strong>如果以字符串初始化，那么编译器默认会在字符串尾部添加’\0’</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str3[] = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><ul><li><p>sizeof 计算数组大小，数组包含’\0’字符</p></li><li><p>strlen 计算字符串的长度，到’\0’结束</p></li></ul><p>字符串拷贝功能实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1）应该判断下传入的参数是否为NULL</span></span><br><span class="line"><span class="comment">//2）最好不要直接使用形参</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_string04</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">char</span>* source)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dest == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (source == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* src = source;</span><br><span class="line"><span class="keyword">char</span>* tar = dest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*tar++ = *src++)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串的格式化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">     根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 <span class="string">'\0'</span> 为止。</span><br><span class="line">参数： </span><br><span class="line">str：字符串首地址</span><br><span class="line">format：字符串格式，用法和<span class="built_in">printf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际格式化的字符个数</span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 格式化字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"你好,%s,欢迎加入我们!"</span>, <span class="string">"John"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>,buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"我今年%d岁了!"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 拼接字符串</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">sprintf</span>(buf,<span class="string">"%s %s"</span>,str1,str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s len:%d\n"</span>, buf,len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 数字转字符串</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"><span class="comment">//设置宽度 右对齐</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%8d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"><span class="comment">//设置宽度 左对齐</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%-8d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</span><br><span class="line">参数：</span><br><span class="line">str：指定的字符串首地址</span><br><span class="line">format：字符串格式，用法和<span class="built_in">scanf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际读取的字符个数</span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>格式</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>%*s或%*d</code></td><td>跳过数据</td></tr><tr><td>%[width]s</td><td>读指定宽度的数据</td></tr><tr><td>%[a-z]</td><td>匹配a到z中任意字符(尽可能多的匹配)</td></tr><tr><td>%[aBc]</td><td>匹配a、B、c中一员，贪婪性</td></tr><tr><td><code>%[^a]</code></td><td>匹配非a的任意字符，贪婪性</td></tr><tr><td><code>%[^a-z]</code></td><td>表示读取除a-z以外的所有字符</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 跳过数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//匹配第一个字符是否是数字，如果是，则跳过</span></span><br><span class="line"><span class="comment">//如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"123456aaaa"</span>, <span class="string">"%*d%s"</span>, buf); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 读取指定宽度数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"123456aaaa"</span>, <span class="string">"%7s"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 匹配a-z中任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line">  <span class="comment">//先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配</span></span><br><span class="line"><span class="comment">//如果不是停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"abcdefg123456"</span>, <span class="string">"%[a-z]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 匹配aBc中的任何一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"abcdefg123456"</span>, <span class="string">"%[aBc]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 匹配非a的任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"bcdefag123456"</span>, <span class="string">"%[^a]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 匹配非a-z中的任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"123456ABCDbcdefag"</span>, <span class="string">"%[^a-z]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-1-一级指针易错点"><a href="#2-6-1-一级指针易错点" class="headerlink" title="2.6.1 一级指针易错点"></a>2.6.1 一级指针易错点</h4><ul><li><p>越界</p></li><li><p>指针叠加会不断改变指针指向 <code>p++</code></p></li><li><p>返回局部变量地址</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdedsgads"</span>; <span class="comment">//栈区，</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[get_str]str = %s\n"</span>, str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同一块内存释放多次<ul><li>free()函数的功能只是告诉系统 p 指向的内存可以回收了。就是说，p 指向的内存使用权交还给系统。但是，p的值还是原来的值(野指针)，p还是指向原来的内存</li></ul></li></ul><h3 id="2-7-const使用"><a href="#2-7-const使用" class="headerlink" title="2.7 const使用"></a>2.7 const使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const修饰变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1. const基本概念</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//i = 100; //错误，只读变量初始化之后不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义const变量最好初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="comment">//j = 100; //错误，不能再次赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. c语言的const是一个只读变量，并不是一个常量，可通过指针间接修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//k = 100; //错误，不可直接修改，我们可通过指针间接修改</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"k:%d\n"</span>, k);</span><br><span class="line"><span class="keyword">int</span>* p = &amp;k;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"k:%d\n"</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const 修饰指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//const放在*号左侧 修饰p_a指针指向的内存空间不能修改,但可修改指针的指向</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p_a = &amp;a;</span><br><span class="line"><span class="comment">//*p_a = 100; //不可修改指针指向的内存空间</span></span><br><span class="line">p_a = &amp;b; <span class="comment">//可修改指针的指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const放在*号的右侧， 修饰指针的指向不能修改，但是可修改指针指向的内存空间</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p_b = &amp;a;</span><br><span class="line"><span class="comment">//p_b = &amp;b; //不可修改指针的指向</span></span><br><span class="line">*p_b = <span class="number">100</span>; <span class="comment">//可修改指针指向的内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的指向和指针指向的内存空间都不能修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p_c = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const指针用法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次都对对象进行拷贝，效率低，应该用指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonByValue</span><span class="params">(struct Person person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, person.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是用指针会有副作用，可能会不小心修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonByPointer</span><span class="params">(<span class="keyword">const</span> struct Person *person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, person-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span> = &#123;</span> <span class="string">"Obama"</span>, <span class="number">1101</span>, <span class="number">23</span>, <span class="number">87</span> &#125;;</span><br><span class="line"><span class="comment">//printPersonByValue(p);</span></span><br><span class="line">printPersonByPointer(&amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、指针的指针-二级指针"><a href="#三、指针的指针-二级指针" class="headerlink" title="三、指针的指针(二级指针)"></a>三、指针的指针(二级指针)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br></pre></td></tr></table></figure><p>它在内存中的大概模样大致如下：</p><img src="/images/imageProgramC/二级指针.png"><h3 id="3-1-二级指针做形参输出特性"><a href="#3-1-二级指针做形参输出特性" class="headerlink" title="3.1 二级指针做形参输出特性"></a>3.1 二级指针做形参输出特性</h3><p>二级指针做参数的输出特性是指由被调函数分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调函数,由参数n确定分配多少个元素内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate_space</span><span class="params">(<span class="keyword">int</span> **arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//堆上分配n个int类型元素内存</span></span><br><span class="line"><span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)* n);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == temp)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给内存初始化值</span></span><br><span class="line"><span class="keyword">int</span> *pTemp = temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line"><span class="comment">//temp[i] = i + 100;</span></span><br><span class="line">*pTemp = i + <span class="number">100</span>;</span><br><span class="line">pTemp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针间接赋值</span></span><br><span class="line">*arr = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二级指针输出特性(由被调函数分配内存)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//给arr指针间接赋值</span></span><br><span class="line">allocate_space(&amp;arr,n);</span><br><span class="line"><span class="comment">//输出arr指向数组的内存</span></span><br><span class="line">print_array(arr, n);</span><br><span class="line"><span class="comment">//释放arr所指向内存空间的值</span></span><br><span class="line"><span class="keyword">if</span> (arr != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-二级指针做形参输入特性"><a href="#3-2-二级指针做形参输入特性" class="headerlink" title="3.2 二级指针做形参输入特性"></a>3.2 二级指针做形参输入特性</h3><p>二级指针做形参输入特性是指由主调函数分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> **arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,*(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二级指针输入特性(由主调函数分配内存)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> a5 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>** arr = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * n);</span><br><span class="line">arr[<span class="number">0</span>] = &amp;a1;</span><br><span class="line">arr[<span class="number">1</span>] = &amp;a2;</span><br><span class="line">arr[<span class="number">2</span>] = &amp;a3;</span><br><span class="line">arr[<span class="number">3</span>] = &amp;a4;</span><br><span class="line">arr[<span class="number">4</span>] = &amp;a5;</span><br><span class="line"></span><br><span class="line">print_array(arr,n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、位运算"><a href="#四、位运算" class="headerlink" title="四、位运算"></a>四、位运算</h2><h3 id="4-1-位逻辑运算符"><a href="#4-1-位逻辑运算符" class="headerlink" title="4.1 位逻辑运算符"></a>4.1 位逻辑运算符</h3><p>4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(&amp;&amp; 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。</p><ul><li><strong>按位取反~</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> a = <span class="number">2</span>;   <span class="comment">//00000010</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b = ~a;  <span class="comment">//11111101</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, a); <span class="comment">//ret = 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, b); <span class="comment">//ret = 253</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>位与（AND）: &amp;</strong></p><ul><li>二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。</li></ul></li><li><p><strong>位或（OR）: |</strong></p><ul><li>二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1.</li></ul></li><li><p><strong>位异或:</strong></p><ul><li>二进制运算符 <code>^</code> 对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0.</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10010011</span>) </span><br><span class="line">^ (<span class="number">00111101</span>)</span><br><span class="line">= (<span class="number">10101110</span>)</span><br></pre></td></tr></table></figure><p><strong>用法</strong>：</p><ul><li>打开位</li></ul><p>已知：10011010：</p><ol><li><p>将位2打开</p><p><code>flag | 10011010</code></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">| (<span class="number">00000100</span>)</span><br><span class="line">= (<span class="number">10011110</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>将所有位打开。</p><p><code>flag | ~flag</code></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">| (<span class="number">01100101</span>)</span><br><span class="line">= (<span class="number">11111111</span>)</span><br></pre></td></tr></table></figure><ul><li><p>关闭位</p><p><code>flag &amp; ~flag</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">&amp; (<span class="number">01100101</span>)</span><br><span class="line">= (<span class="number">00000000</span>)</span><br></pre></td></tr></table></figure><ul><li><p>转置位</p><ul><li>转置(toggling)一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开。您可以使用位异或运算符来转置。其思想是如果b是一个位(1或0)，那么如果b为1则 <code>b^1</code> 为0，如果b为0，则 <code>1^b</code> 为1。无论b的值是0还是1, <code>0^b</code> 为b.</li></ul><p><code>flag ^ 0xff</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10010011</span>)</span><br><span class="line">^ (<span class="number">11111111</span>)</span><br><span class="line">= (<span class="number">01101100</span>)</span><br></pre></td></tr></table></figure><ul><li>交换两个数不需要临时变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a ^ b = temp;</span></span><br><span class="line"><span class="comment">//a ^ temp = b;</span></span><br><span class="line"><span class="comment">//b ^ temp = a</span></span><br><span class="line">  (<span class="number">10010011</span>)</span><br><span class="line">^ (<span class="number">00100110</span>)</span><br><span class="line">= (<span class="number">10110101</span>)</span><br><span class="line"></span><br><span class="line">  (<span class="number">10110101</span>)</span><br><span class="line">^ (<span class="number">00100110</span>)</span><br><span class="line">   <span class="number">10010011</span></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = b ^ a;</span><br><span class="line">    a = a ^ b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d b = %d/n"</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-移位运算符"><a href="#4-2-移位运算符" class="headerlink" title="4.2 移位运算符"></a>4.2 移位运算符</h3><ul><li><p><strong>左移 &lt;&lt;</strong></p><ul><li><p>左移运算符 <code>&lt;&lt;</code> 将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。</p></li><li><p>左移一位相当于原值 <code>*2</code>.</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10001010</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">(<span class="number">00101000</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">1</span> = <span class="number">2</span>;</span><br><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">1</span> = <span class="number">4</span>;</span><br><span class="line"><span class="number">4</span> &lt;&lt; <span class="number">1</span> = <span class="number">8</span>;</span><br><span class="line"><span class="number">8</span> &lt;&lt; <span class="number">2</span> = <span class="number">32</span></span><br></pre></td></tr></table></figure><ul><li><strong>右移 &gt;&gt;</strong><ul><li>右移运算符 <code>&gt;&gt;</code> 将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。<strong>对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充</strong>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有符号值</span></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">00100010</span>)     <span class="comment">//在某些系统上的结果值</span></span><br><span class="line"></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">11100010</span>)     <span class="comment">//在另一些系统上的解雇</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号值</span></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">00100010</span>)    <span class="comment">//所有系统上的结果值</span></span><br></pre></td></tr></table></figure><p><strong>用法：移位运算符</strong>：</p><ul><li>移位运算符能够提供快捷、高效（依赖于硬件）对2的幂的乘法和除法。</li></ul><table><thead><tr><th>number &lt;&lt; n</th><th>number乘以2的n次幂</th></tr></thead><tbody><tr><td>number &gt;&gt; n</td><td>如果number非负，则用number除以2的n次幂</td></tr></tbody></table><h2 id="五、多维数组"><a href="#五、多维数组" class="headerlink" title="五、多维数组"></a>五、多维数组</h2><h3 id="5-1-一维数组"><a href="#5-1-一维数组" class="headerlink" title="5.1 一维数组"></a>5.1 一维数组</h3><ul><li>元素类型角度：数组是相同类型的变量的有序集合</li><li>内存角度：连续的一大片内存空间</li></ul><p><strong>请问：指针和数组是等价的吗？</strong></p><p>答案是<strong>否定</strong>的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下：</p><ul><li>当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。</li><li>当数组名作为&amp;操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//arr = NULL; //arr作为指针常量，不可修改</span></span><br><span class="line"><span class="keyword">int</span> *p = arr; <span class="comment">//此时arr作为指针常量来使用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(arr):%d\n"</span>, <span class="keyword">sizeof</span>(arr)); <span class="comment">//此时sizeof结果为整个数组的长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;arr type is %s\n"</span>, <span class="keyword">typeid</span>(&amp;arr).name()); <span class="comment">//int(*)[10]而不是int*</span></span><br></pre></td></tr></table></figure><p><strong>下标引用</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>*(arr + 3)</strong> ,这个表达式是什么意思呢？<ul><li>首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(arr + <span class="number">3</span>)</span><br><span class="line">arr[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>问题 1</strong>：数组下标可否为负值？</p><p><strong>问题 2</strong>：请阅读如下代码，说出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, *p); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, p[<span class="number">-1</span>]);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="5-1-1-数组和指针"><a href="#5-1-1-数组和指针" class="headerlink" title="5.1.1 数组和指针"></a>5.1.1 数组和指针</h4><p>指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *b;</span><br></pre></td></tr></table></figure><p>声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。</p><p>因此，表达式 <code>*a</code> 是完全合法的，但是表达式 <code>*b</code> 却是非法的。<code>*b</code> 将访问内存中一个不确定的位置，将会导致程序终止。另一方面 b++ 可以通过编译，a++ 却不行，因为 a 是一个常量值。</p><h4 id="5-1-2-作为函数参数的数组名"><a href="#5-1-2-作为函数参数的数组名" class="headerlink" title="5.1.2 作为函数参数的数组名"></a>5.1.2 作为函数参数的数组名</h4><p>当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> *arr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。<strong>同样sizeof arr值是指针的长度，而不是数组的长度</strong>。</p><p>现在我们清楚了，<strong>为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数</strong>。</p><h3 id="5-2-多维数组"><a href="#5-2-多维数组" class="headerlink" title="5.2 多维数组"></a>5.2 多维数组</h3><p><strong>数组名</strong>：</p><ul><li>一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。</p><p><strong>指向数组的指针(数组指针)</strong>：</p><p>数组指针，它是指针，指向数组的指针。</p><p>数组的类型由<strong>元素类型</strong>和<strong>数组大小</strong>共同决定：int array[5]  的类型为  int[5]；C语言可通过typedef定义一个数组类型：</p><p>定义数组指针有一下三种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先定义数组类型，再用数组类型定义数组指针</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType</span></span><br><span class="line">typedef int(ArrayType)[10];</span><br><span class="line"><span class="comment">//int ArrayType[10]; //定义一个数组，数组名为ArrayType</span></span><br><span class="line"></span><br><span class="line">ArrayType myarr; <span class="comment">//等价于 int myarr[10];</span></span><br><span class="line">ArrayType* pArr = &amp;arr; <span class="comment">//定义了一个数组指针pArr，并且指针指向数组arr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,(*pArr)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//定义数组指针类型</span></span><br><span class="line">typedef int(*ArrayType)[10];</span><br><span class="line">ArrayType pArr = &amp;arr; <span class="comment">//定义了一个数组指针pArr，并且指针指向数组arr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">(*pArr)[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, (*pArr)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>(*pArr)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">(*pArr)[i] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, (*pArr)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-1-指针数组-元素为指针"><a href="#5-2-1-指针数组-元素为指针" class="headerlink" title="5.2.1 指针数组(元素为指针)"></a>5.2.1 指针数组(元素为指针)</h4><p><strong>栈区指针数组</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组做函数函数，退化为指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_sort</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j --)&#123;</span><br><span class="line"><span class="comment">//比较两个字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(arr[j<span class="number">-1</span>],arr[j]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">char</span>* temp = arr[j - <span class="number">1</span>];</span><br><span class="line">arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//主调函数分配内存</span></span><br><span class="line"><span class="comment">//指针数组</span></span><br><span class="line"><span class="keyword">char</span>* p[] = &#123; <span class="string">"bbb"</span>, <span class="string">"aaa"</span>, <span class="string">"ccc"</span>, <span class="string">"eee"</span>, <span class="string">"ddd"</span>&#125;;</span><br><span class="line"><span class="comment">//char** p = &#123; "aaa", "bbb", "ccc", "ddd", "eee" &#125;; //错误</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">array_print(p, len);</span><br><span class="line"><span class="comment">//对字符串进行排序</span></span><br><span class="line">array_sort(p, len);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">array_print(p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆区指针数组</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">allocate_memory</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>** temp = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * n);</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分别给每一个指针malloc分配内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">temp[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)* <span class="number">30</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp[i], <span class="string">"%2d_hello world!"</span>, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(<span class="keyword">char</span>** buf,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buf == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line"><span class="built_in">free</span>(buf[i]);</span><br><span class="line">buf[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span>** p = allocate_memory(n);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">array_print(p, n);</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line">free_memory(p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维数组的线性存储特性式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的线性存储</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[][<span class="number">3</span>] = &#123;</span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr2[][<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何证明二维数组是线性的？</span></span><br><span class="line"><span class="comment">//通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">PrintArray((<span class="keyword">int</span>*)arr, len);</span><br><span class="line">PrintArray((<span class="keyword">int</span>*)arr2, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维数组的3种形式参数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组的第一种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray01</span><span class="params">(<span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的第二种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray02</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的第二种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray03</span><span class="params">(<span class="keyword">int</span>(*arr)[<span class="number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[][<span class="number">3</span>] = &#123; </span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintArray01(arr);</span><br><span class="line">PrintArray02(arr);</span><br><span class="line">PrintArray03(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p><strong>编程提示</strong>：</p><ul><li>源代码的可读性几乎总是比程序的运行时效率更为重要</li><li><strong>只要有可能，函数的指针形参都应该声明为const</strong></li><li>在多维数组的初始值列表中使用完整的多层花括号提供可读性</li></ul><p><strong>内容总结</strong>：</p><ul><li>在绝大多数表达式中，数组名的值是指向数组第1个元素的指针。<strong>这个规则只有两个例外，sizeof和对数组名&amp;</strong>。</li><li>指针和数组并不相等。当我们声明一个数组的时候，同时也分配了内存。但是声明指针的时候，只分配容纳指针本身的空间。</li><li>当数组名作为函数参数时，实际传递给函数的是一个指向数组第1个元素的指针。</li><li>我们不单可以创建指向普通变量的指针，也可创建指向数组的指针。</li></ul><h2 id="六、结构体"><a href="#六、结构体" class="headerlink" title="六、结构体"></a>六、结构体</h2><h3 id="6-1-结构体基础知识"><a href="#6-1-结构体基础知识" class="headerlink" title="6.1 结构体基础知识"></a>6.1 结构体基础知识</h3><p>结构体类型的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PERSON</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;Person;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。</p><p><strong>结构体变量的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;p1; <span class="comment">//定义类型同时定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;p2; <span class="comment">//定义类型同时定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p3</span>;</span> <span class="comment">//通过类型直接定义</span></span><br></pre></td></tr></table></figure><p><strong>结构体成员的使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//在栈上分配空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(p1.name, <span class="string">"John"</span>);</span><br><span class="line">p1.age = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//如果是普通变量，通过点运算符操作结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p1.name, p1.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆上分配空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">p2</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>));</span></span><br><span class="line"><span class="built_in">strcpy</span>(p2-&gt;name, <span class="string">"Obama"</span>);</span><br><span class="line">p2-&gt;age = <span class="number">33</span>;</span><br><span class="line"><span class="comment">//如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p2-&gt;name, p2-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝和浅拷贝</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个老师有N个学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Teacher t1;</span><br><span class="line">t1.name = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t1.name , <span class="string">"John"</span>);</span><br><span class="line"></span><br><span class="line">Teacher t2;</span><br><span class="line">t2 = t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对手动开辟的内存，需要手动拷贝</span></span><br><span class="line">t2.name = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t2.name, t1.name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(t1.name);</span><br><span class="line">t1.name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(t2.name);</span><br><span class="line">t1.name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//在栈上分配空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>[3] = &#123;</span></span><br><span class="line">&#123; <span class="string">"John"</span>, <span class="number">30</span> &#125;,</span><br><span class="line">&#123; <span class="string">"Obama"</span>, <span class="number">33</span> &#125;,</span><br><span class="line">&#123; <span class="string">"Edward"</span>, <span class="number">25</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>[3] = &#123;</span> <span class="string">"John"</span>, <span class="number">30</span>, <span class="string">"Obama"</span>, <span class="number">33</span>, <span class="string">"Edward"</span>, <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>,p1[i].name,p1[i].age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----------------\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p2[i].name, p2[i].age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----------------\n"</span>);</span><br><span class="line"><span class="comment">//在堆上分配结构体数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">p3</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>) * 3);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(p3[i].name, <span class="string">"Name_%d"</span>, i + <span class="number">1</span>);</span><br><span class="line">p3[i].age = <span class="number">20</span> + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p3[i].name, p3[i].age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-结构体嵌套指针"><a href="#6-2-结构体嵌套指针" class="headerlink" title="6.2 结构体嵌套指针"></a>6.2 结构体嵌套指针</h3><p><strong>结构体嵌套一级指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate_memory</span><span class="params">(struct Person** person)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (person == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">temp</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>));</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给name指针分配内存</span></span><br><span class="line">temp-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)* <span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(temp-&gt;name, <span class="string">"John"</span>);</span><br><span class="line">temp-&gt;age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">*person = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_person</span><span class="params">(struct Person* person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>,person-&gt;name,person-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(struct Person** person)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (person == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">temp</span> = *<span class="title">person</span>;</span></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(temp-&gt;name);</span><br><span class="line">temp-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">allocate_memory(&amp;p);</span><br><span class="line">print_person(p);</span><br><span class="line">free_memory(&amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体嵌套二级指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个老师有N个学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">char</span>** students;</span><br><span class="line">&#125;Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_teacher</span><span class="params">(Teacher** teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (teacher == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建老师数组</span></span><br><span class="line">Teacher* teachers = (Teacher*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Teacher)* n);</span><br><span class="line"><span class="keyword">if</span> (teachers == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给每一个老师分配学生</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(teachers[i].name, <span class="string">"老师_%d"</span>, i + <span class="number">1</span>);</span><br><span class="line">teachers[i].students = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)&#123;</span><br><span class="line">teachers[i].students[j] = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(teachers[i].students[j], <span class="string">"学生_%d"</span>, num + <span class="number">1</span>);</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*teacher = teachers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_teacher</span><span class="params">(Teacher* teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, teacher[i].name);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  %s"</span>,teacher[i].students[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(Teacher** teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (teacher == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher* temp = *teacher;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j ++)&#123;</span><br><span class="line"><span class="built_in">free</span>(temp[i].students[j]);</span><br><span class="line">temp[i].students[j] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(temp[i].students);</span><br><span class="line">temp[i].students = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Teacher* p = <span class="literal">NULL</span>;</span><br><span class="line">create_teacher(&amp;p,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">print_teacher(p, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">free_memory(&amp;p,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-结构体成员偏移量"><a href="#6-3-结构体成员偏移量" class="headerlink" title="6.3 结构体成员偏移量"></a>6.3 结构体成员偏移量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一旦结构体定义下来，则结构体中的成员内存布局就定下了</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> a;  </span><br><span class="line"><span class="keyword">int</span> b;      </span><br><span class="line"><span class="keyword">int</span> c;        </span><br><span class="line"></span><br><span class="line">&#125; Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Teacher  t1;</span><br><span class="line">Teacher*p = <span class="literal">NULL</span>;</span><br><span class="line">p = &amp;t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> offsize1 = (<span class="keyword">int</span>)&amp;(p-&gt;b) - (<span class="keyword">int</span>)p;  <span class="comment">//age 相对于结构体 Teacher的偏移量</span></span><br><span class="line"><span class="keyword">int</span> offsize2 = (<span class="keyword">int</span>)&amp;(((Teacher *)<span class="number">0</span>)-&gt;b);<span class="comment">//绝对0地址 age的偏移量</span></span><br><span class="line"><span class="keyword">int</span> offsize3 = offsetof(Teacher, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"offsize1:%d \n"</span>, offsize1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"offsize2:%d \n"</span>, offsize2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"offsize3:%d \n"</span>, offsize3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-结构体字节对齐"><a href="#6-4-结构体字节对齐" class="headerlink" title="6.4 结构体字节对齐"></a>6.4 结构体字节对齐</h3><p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。</p><p>从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是<strong>内存对齐</strong>。</p><h4 id="6-4-1-内存对齐原因"><a href="#6-4-1-内存对齐原因" class="headerlink" title="6.4.1 内存对齐原因"></a>6.4.1 内存对齐原因</h4><p>我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等</p><p>内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)。如果没有对齐，为了访问一个变量可能产生二次访问。</p><p><strong>为什么要简单内存对齐？</strong></p><ul><li>提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量。</li><li>某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。</li></ul><h4 id="6-4-2-如何内存对齐"><a href="#6-4-2-如何内存对齐" class="headerlink" title="6.4.2 如何内存对齐"></a>6.4.2 如何内存对齐</h4><ul><li>对于标准数据类型，它的地址只要是它的长度的整数倍。</li><li>对于非标准数据类型，比如结构体，要遵循一下对齐原则：<ul><li>数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为<strong>min（当前成员的大小，#pargama pack(n)）</strong>整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。</li><li>结构体总的大小，也就是sizeof的结果，必须是<strong>min（结构体内部最大成员，#pargama pack(n)）</strong>的整数倍，不足要补齐。</li><li>结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。</li></ul></li></ul><p>手动设置对齐模数:</p><ul><li><strong>#pragma pack(show)</strong><ul><li>显示当前packing alignment的字节数，以warning message的形式被显示。</li></ul></li><li><strong>#pragma pack(push)</strong> <ul><li>将当前指定的packing alignment数组进行压栈操作，这里的栈是the internal compiler stack,同事设置当前的packing alignment为n；如果n没有指定，则将当前的packing alignment数组压栈。</li></ul></li><li><strong>#pragma pack(pop)</strong> <ul><li>从internal compiler stack中删除最顶端的reaord; 如果没有指定n,则当前栈顶record即为新的packing alignement数值；如果指定了n，则n成为新的packing alignment值</li></ul></li><li><strong>#pragma pack(n)</strong><ul><li>指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 </li></ul></li></ul><p>内存对齐案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> b;</span><br><span class="line"><span class="keyword">double</span> c;</span><br><span class="line"><span class="keyword">float</span> d;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT2</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line">Student b; </span><br><span class="line"><span class="keyword">double</span> c;</span><br><span class="line">&#125;Student2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//a从偏移量0位置开始存储</span></span><br><span class="line"><span class="comment">//b从4位置开始存储</span></span><br><span class="line"><span class="comment">//c从8位置开始存储</span></span><br><span class="line"><span class="comment">//d从12位置开存储</span></span><br><span class="line"><span class="comment">//所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof Student:%d\n"</span>,<span class="keyword">sizeof</span>(Student));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Student2 </span></span><br><span class="line"><span class="comment">//a从偏移量为0位置开始 8</span></span><br><span class="line"><span class="comment">//b从偏移量为Student内部最大成员整数倍开始，也就是8开始 24</span></span><br><span class="line"><span class="comment">//c从8的整数倍地方开始,也就是32开始</span></span><br><span class="line"><span class="comment">//所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof Student2:%d\n"</span>, <span class="keyword">sizeof</span>(Student2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、文件操作"><a href="#七、文件操作" class="headerlink" title="七、文件操作"></a>七、文件操作</h2><p>文件在今天的计算机系统中作用是很重要的。文件用来存放程序、文档、数据、表格、图片和其他很多种类的信息。作为一名程序员，您必须编程来创建、写入和读取文件。编写程序从文件读取信息或者将结果写入文件是一种经常性的需求。C提供了强大的和文件进行通信的方法。使用这种方法我们可以在程序中打开文件，然后使用专门的I/O函数读取文件或者写入文件。</p><p><strong>文件的概念</strong></p><ul><li>一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。</li></ul><p><strong>流的概念</strong></p><p>流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。</p><p>C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。</p><p><strong>文本流</strong></p><ul><li>文本流，也就是我们常说的以文本模式读取文件。文本流的有些特性在不同的系统中可能不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只使用一个换行符结尾。</li><li>标准C把文本定义为零个或者多个字符，后面跟一个表示结束的换行符(\n).对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式和内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形势而操纵文本的能力简化了可移植程序的创建。</li></ul><p><strong>二进制流</strong></p><ul><li>二进制流中的字节将完全根据程序编写它们的形式写入到文件中，而且完全根据它们从文件或设备读取的形式读入到程序中。它们并未做任何改变。这种类型的流适用于非文本数据，但是如果你不希望I/O函数修改文本文件的行末字符，也可以把它们用于文本文件。</li></ul><p>c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。</p><p><strong>我们程序中，经常看到的文本方式打开文件和二进制方式打开文件仅仅体现在换行符的处理上</strong>。</p><p>比如说，在widows下，文件的换行符是 <code>\r\n</code>，而在Linux下换行符则是 <code>\n</code>.</p><p>当对文件使用文本方式打开的时候，读写的windows文件中的换行符\r\n会被替换成\n读到内存中，当在windows下写入文件的时候，\n被替换成\r\n再写入文件。如果使用二进制方式打开文件，则不进行\r\n和\n之间的转换。 那么由于Linux下的换行符就是\n, 所以文本文件方式和二进制方式无区别。</p><h3 id="7-1-文件的操作"><a href="#7-1-文件的操作" class="headerlink" title="7.1 文件的操作"></a>7.1 文件的操作</h3><p><strong>文件流总览</strong></p><p>标准库函数是的我们在C程序中执行与文件相关的I/O任务非常方便。下面是关于文件I/O的一般概况。</p><ul><li>程序为同时处于活动状态的每个文件声明一个指针变量，其类型为 <code>FILE*</code>。这个指针指向这个FILE结构，当它处于活动状态时由流使用。</li><li>流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式(读、写、或者读写)。Fopen和操作系统验证文件或者设备是否存在并初始化FILE。</li><li>根据需要对文件进行读写操作。</li><li>最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放FILE结构。</li></ul><p>标准I/O更为简单，因为它们并不需要打开或者关闭。</p><p>I/O函数以三种基本的形式处理数据：<strong>单个字符</strong>、<strong>文本行</strong>和<strong>二进制数据</strong>。对于每种形式都有一组特定的函数对它们进行处理。</p><p><strong>输入/输出函数家族</strong></p><table><thead><tr><th>家族名</th><th>目的</th><th>可用于所有流</th><th>只用于stdin和stdout</th></tr></thead><tbody><tr><td>getchar</td><td>字符输入</td><td>fgetc、getc</td><td>getchar</td></tr><tr><td>putchar</td><td>字符输出</td><td>fputc、putc</td><td>putchar</td></tr><tr><td>gets</td><td>文本行输入</td><td>fgets</td><td>gets</td></tr><tr><td>puts</td><td>文本行输出</td><td>fputs</td><td>puts</td></tr><tr><td>scanf</td><td>格式化输入</td><td>fscanf</td><td>scanf</td></tr><tr><td>printf</td><td>格式化输出</td><td>fprintf</td><td>printf</td></tr></tbody></table><h3 id="7-2-文件打开关闭"><a href="#7-2-文件打开关闭" class="headerlink" title="7.2 文件打开关闭"></a>7.2 文件打开关闭</h3><p>文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line">功能：打开文件</span><br><span class="line">参数：</span><br><span class="line">filename：需要打开的文件名，根据需要加上路径</span><br><span class="line">mode：打开文件的权限设置</span><br><span class="line">返回值：</span><br><span class="line">成功：文件指针</span><br><span class="line">失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方式</th><th>含义</th></tr></thead><tbody><tr><td>“r”</td><td>打开，只读，文件必须已经存在。</td></tr><tr><td>“w”</td><td>只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。</td></tr><tr><td>“a”</td><td>只能在文件末尾追加数据,如果文件不存在则创建</td></tr><tr><td>“rb”</td><td>打开一个二进制文件，只读</td></tr><tr><td>“wb”</td><td>打开一个二进制文件，只写</td></tr><tr><td>“ab”</td><td>打开一个二进制文件，追加</td></tr><tr><td>“r+”</td><td>允许读和写,文件必须已存在</td></tr><tr><td>“w+”</td><td>允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。</td></tr><tr><td>“a+”</td><td>允许读和追加数据,如果文件不存在则创建</td></tr><tr><td>“rb+”</td><td>以读/写方式打开一个二进制文件</td></tr><tr><td>“wb+”</td><td>以读/写方式建立一个新的二进制文件</td></tr><tr><td>“ab+”</td><td>以读/写方式打开一个二进制文件进行追加</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "\\"这样的路径形式，只能在windows使用</span></span><br><span class="line"><span class="comment">// "/"这样的路径形式，windows和linux平台下都可用，建议使用这种</span></span><br><span class="line"><span class="comment">// 路径可以是相对路径，也可是绝对路径</span></span><br><span class="line">fp = fopen(<span class="string">"../test"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="comment">//fp = fopen("..\\test", "w");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) <span class="comment">//返回空，说明打开失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//perror()是标准出错打印函数，能打印调用库函数出错原因</span></span><br><span class="line">perror(<span class="string">"open"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。</span><br><span class="line">参数：</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值.</p><p><strong>文件读写函数回顾</strong></p><ul><li>按照字符读写文件：fgetc(), fputc()</li><li>按照行读写文件：fputs(), fgets()</li><li>按照块读写文件：fread(), fwirte()</li><li>按照格式化读写文件：fprintf(), fscanf()</li><li>按照随机位置读写文件：fseek(), ftell(), rewind()    </li></ul><p><strong>块读写函数回顾</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式给文件写入内容</span><br><span class="line">参数：</span><br><span class="line">ptr：准备写入文件数据的地址</span><br><span class="line">size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定写入文件内容的块数据大小</span><br><span class="line">nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功写入文件数据的块数，此值和nmemb相等</span><br><span class="line">失败：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式从文件中读取内容</span><br><span class="line">参数：</span><br><span class="line">ptr：存放读取出来数据的内存空间</span><br><span class="line">size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定读取文件内容的块数据大小</span><br><span class="line">nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于<span class="number">0</span>，说明读到文件的结尾。</span><br><span class="line">失败：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>格式化读写函数回顾</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件</span><br><span class="line">format：字符串格式，用法和<span class="built_in">printf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际写入文件的字符个数</span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件</span><br><span class="line">format：字符串格式，用法和<span class="built_in">scanf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际从文件中读取的字符个数</span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>fscanf遇到空格和换行时结束。</strong></p><h3 id="7-3-读写配置文件"><a href="#7-3-读写配置文件" class="headerlink" title="7.3 读写配置文件"></a>7.3 读写配置文件</h3><img src="/images/imageProgramC/文件读写案例.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> key[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">char</span> val[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span>&#123;</span></span><br><span class="line">FILE *fp; <span class="comment">//保存文件指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">list</span>;</span> <span class="comment">//保存配置信息</span></span><br><span class="line"><span class="keyword">int</span> lines; <span class="comment">//配置信息条数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_file</span><span class="params">(<span class="keyword">char</span> *path, struct config **myconfig)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == path)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以读写的方式打开文件</span></span><br><span class="line">FILE *fp = fopen(path, <span class="string">"r+"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> ==fp)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件打开失败!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置文件信息分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span> *<span class="title">conf</span> = (<span class="title">struct</span> <span class="title">config</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">config</span>));</span></span><br><span class="line">conf-&gt;fp = fp;</span><br><span class="line">conf-&gt;<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的间接赋值</span></span><br><span class="line">*myconfig = conf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计文件行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> lines = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="number">1024</span>, config-&gt;fp))&#123;</span><br><span class="line"><span class="comment">//如果是注释则不统计</span></span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'#'</span>)&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">lines++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将文件指针重置到开始位置</span></span><br><span class="line">fseek(config-&gt;fp,<span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得配置文件行数</span></span><br><span class="line">config-&gt;lines = count_file(config);</span><br><span class="line"><span class="comment">//给每一行配置信息分配内存</span></span><br><span class="line">config-&gt;<span class="built_in">list</span> = (struct info *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct info) * config-&gt;lines);</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="number">1024</span>, config-&gt;fp))&#123;</span><br><span class="line"><span class="comment">//去除每一行最后的\n字符</span></span><br><span class="line">buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">//如果是注释则不显示</span></span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'#'</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(config-&gt;<span class="built_in">list</span>[index].key, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">memset</span>(config-&gt;<span class="built_in">list</span>[index].val, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *delimit = <span class="built_in">strchr</span>(buf, <span class="string">':'</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(config-&gt;<span class="built_in">list</span>[index].key, buf, delimit - buf);</span><br><span class="line"><span class="built_in">strncpy</span>(config-&gt;<span class="built_in">list</span>[index].val, delimit + <span class="number">1</span>, <span class="built_in">strlen</span>(delimit + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span> , <span class="number">1024</span>);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">get_file</span><span class="params">(struct config *config, <span class="keyword">char</span> *key)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == key)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; config-&gt;lines;i ++)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(config-&gt;<span class="built_in">list</span>[i].key,key) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> config-&gt;<span class="built_in">list</span>[i].val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件指针</span></span><br><span class="line">fclose(config-&gt;fp);</span><br><span class="line">config-&gt;fp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//释放配置信息</span></span><br><span class="line"><span class="built_in">free</span>(config-&gt;<span class="built_in">list</span>);</span><br><span class="line">config-&gt;<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *path = <span class="string">"./my.ini"</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span> *<span class="title">conf</span> = <span class="title">NULL</span>;</span></span><br><span class="line">load_file(path, &amp;conf);</span><br><span class="line">parse_file(conf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"username"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"password"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"server_ip"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"server_port"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"aaaa"</span>));</span><br><span class="line">destroy_file(conf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、链表"><a href="#八、链表" class="headerlink" title="八、链表"></a>八、链表</h2><h3 id="8-1-链表基本概念"><a href="#8-1-链表基本概念" class="headerlink" title="8.1 链表基本概念"></a>8.1 链表基本概念</h3><img src="/images/imageProgramC/链表.png"><ul><li>链表是一种常用的数据结构，它通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的动态性（<strong>非顺序存储</strong>）。</li><li>数据域用来存储数据，指针域用于建立与下一个结点的联系。</li><li>建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。</li><li><strong>链表的开销，主要是访问顺序性和组织链的空间损失</strong>。</li></ul><p><strong>数组和链表的区别</strong>：</p><ul><li><p>数组：一次性分配一块连续的存储区域。</p><p>优点：随机访问元素效率高</p><p>缺点：</p><ul><li>需要分配一块连续的存储区域（很大区域，有可能分配失败）</li><li>删除和插入某个元素效率低</li></ul></li><li><p>链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。</p><p>优点：</p><ul><li>不需要一块连续的存储区域</li><li>删除和插入某个元素效率高</li></ul><p>缺点：随机访问元素效率低</p></li></ul><h4 id="8-1-1-有关结构体的自身引用"><a href="#8-1-1-有关结构体的自身引用" class="headerlink" title="8.1.1 有关结构体的自身引用"></a>8.1.1 有关结构体的自身引用</h4><p>问题1：请问结构体可以嵌套本类型的结构体变量吗？</p><p>问题2：请问结构体可以嵌套本类型的结构体指针变量吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">Student stu; <span class="comment">//结构体可以嵌套其他类型的结构体</span></span><br><span class="line"><span class="comment">//Teacher stu;</span></span><br><span class="line"><span class="comment">//struct _TEACHER teacher; //此时Teacher类型的成员还没有确定，编译器无法分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>* <span class="title">teacher</span>;</span> <span class="comment">//不论什么类型的指针，都只占4个字节，编译器可确定内存分配</span></span><br><span class="line">&#125;Teacher;</span><br></pre></td></tr></table></figure><ul><li>结构体可以嵌套另外一个结构体的任何类型变量;</li><li><strong>结构体嵌套本结构体普通变量（不可以）</strong>。本结构体的类型大小无法确定，类型本质：固定大小内存块别名;</li><li><strong>结构体嵌套本结构体指针变量（可以）</strong>, 指针变量的空间能确定，32位， 4字节， 64位， 8字节;</li></ul><h4 id="8-1-2-链表节点"><a href="#8-1-2-链表节点" class="headerlink" title="8.1.2 链表节点"></a>8.1.2 <strong>链表节点</strong></h4><p>大家思考一下，我们说链表是由一系列的节点组成，那么如何表示一个包含了数据域和指针域的节点呢？</p><p><strong>链表的节点类型实际上是结构体变量，此结构体包含数据域和指针域</strong>：</p><ul><li><p>数据域用来存储数据；</p></li><li><p>指针域用于建立与下一个结点的联系，<strong>当此节点为尾节点时，指针域的值为NULL</strong>；</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>       </span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/链表-01.png"><h4 id="8-1-3-链表的分类"><a href="#8-1-3-链表的分类" class="headerlink" title="8.1.3 链表的分类"></a>8.1.3 链表的分类</h4><p>链表分为：</p><ul><li>静态链表</li><li>动态链表</li></ul><p>静态链表和动态链表是线性表链式存储结构的两种不同的表示方式：</p><ul><li><p>所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表称为“静态链表”。</p></li><li><p>所谓动态链表，是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。</p></li></ul><p><strong>静态链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化三个结构体变量</span></span><br><span class="line">Stu s1 = &#123; <span class="number">1</span>, <span class="string">"yuri"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">Stu s2 = &#123; <span class="number">2</span>, <span class="string">"lily"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">Stu s3 = &#123; <span class="number">3</span>, <span class="string">"lilei"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">s1.next = &amp;s2; <span class="comment">//s1的next指针指向s2</span></span><br><span class="line">s2.next = &amp;s3;</span><br><span class="line">s3.next = <span class="literal">NULL</span>; <span class="comment">//尾结点</span></span><br><span class="line"></span><br><span class="line">Stu *p = &amp;s1;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d, name = %s\n"</span>, p-&gt;id, p-&gt;name);</span><br><span class="line"><span class="comment">//结点往后移动一位</span></span><br><span class="line">p = p-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//动态分配3个节点</span></span><br><span class="line">Stu *s1 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">s1-&gt;id = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s1-&gt;name, <span class="string">"yuri"</span>);</span><br><span class="line"></span><br><span class="line">Stu *s2 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">s2-&gt;id = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s2-&gt;name, <span class="string">"lily"</span>);</span><br><span class="line"></span><br><span class="line">Stu *s3 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">s3-&gt;id = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s3-&gt;name, <span class="string">"lilei"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立节点的关系</span></span><br><span class="line">s1-&gt;next = s2; <span class="comment">//s1的next指针指向s2</span></span><br><span class="line">s2-&gt;next = s3;</span><br><span class="line">s3-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历节点</span></span><br><span class="line">Stu *p = s1;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d, name = %s\n"</span>, p-&gt;id, p-&gt;name);</span><br><span class="line"><span class="comment">//结点往后移动一位</span></span><br><span class="line">p = p-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点空间</span></span><br><span class="line">p = s1;</span><br><span class="line">Stu *tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">tmp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带头和不带头链表</strong></p><ul><li>带头链表：固定一个节点作为头结点(数据域不保存有效数据)，起一个标志位的作用，以后不管链表节点如何改变，此头结点固定不变。</li></ul><img src="/images/imageProgramC/链表-02.png"><ul><li>不带头链表：头结点不固定，根据实际需要变换头结点(如在原来头结点前插入新节点，然后，新节点重新作为链表的头结点)。</li></ul><img src="/images/imageProgramC/链表-03.png"><p><strong>单向链表、双向链表、循环链表</strong></p><ul><li>单向链表：</li></ul><img src="/images/imageProgramC/链表-04.png"><ul><li>双向链表：</li></ul><img src="/images/imageProgramC/链表-05.png"><ul><li>循环链表：</li></ul><img src="/images/imageProgramC/链表-06.png"><h3 id="8-2-链表基本操作"><a href="#8-2-链表基本操作" class="headerlink" title="8.2 链表基本操作"></a>8.2 链表基本操作</h3><h4 id="8-2-1-创建链表"><a href="#8-2-1-创建链表" class="headerlink" title="8.2.1 创建链表"></a>8.2.1 <strong>创建链表</strong></h4><p>使用结构体定义节点类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id; <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;link_node;</span><br></pre></td></tr></table></figure><p>编写函数：<code>link_node* init_linklist()</code></p><p>建立带有头结点的单向链表，循环创建结点，结点数据域中的数值从键盘输入，以 -1 作为输入结束标志，链表的头结点地址由函数值返回.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;link_node;</span><br><span class="line"></span><br><span class="line"><span class="function">link_node *<span class="title">init_linklist</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建头结点指针</span></span><br><span class="line">link_node* head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//给头结点分配内存</span></span><br><span class="line">head = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前节点</span></span><br><span class="line">link_node* p_current = head;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//循环向链表中插入节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input data:\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果输入-1，则退出循环</span></span><br><span class="line"><span class="keyword">if</span> (data == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给新节点分配内存</span></span><br><span class="line">link_node* newnode = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给节点赋值</span></span><br><span class="line">newnode-&gt;data = data;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//新节点入链表，也就是将节点插入到最后一个节点的下一个位置</span></span><br><span class="line">p_current-&gt;next = newnode;</span><br><span class="line"><span class="comment">//更新辅助指针p_current</span></span><br><span class="line">p_current = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-遍历链表"><a href="#8-2-2-遍历链表" class="headerlink" title="8.2.2 遍历链表"></a>8.2.2 遍历链表</h4><p>编写函数：<code>void foreach_linklist(link_node* head)</code></p><p>顺序输出单向链表各项结点数据域中的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foreach_linklist</span><span class="params">(link_node* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值指针变量</span></span><br><span class="line">link_node* p_current = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,p_current-&gt;data);</span><br><span class="line">p_current = p_current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-3-插入节点"><a href="#8-2-3-插入节点" class="headerlink" title="8.2.3 插入节点"></a>8.2.3 <strong>插入节点</strong></h4><p>编写函数: <code>void insert_linklist(link_node* head,int val,int data).</code></p><p>在指定值后面插入数据data,如果值val不存在，则在尾部插入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在值val前插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_linklist</span><span class="params">(link_node* head, <span class="keyword">int</span> val, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个辅助指针</span></span><br><span class="line">link_node* p_prev = head;</span><br><span class="line">link_node* p_current = p_prev-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (p_current-&gt;data == val)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">p_prev = p_current;</span><br><span class="line">p_current = p_prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果p_current为NULL，说明不存在值为val的节点</span></span><br><span class="line"><span class="keyword">if</span> (p_current == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在值为%d的节点!\n"</span>,val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建新的节点</span></span><br><span class="line">link_node* newnode = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line">newnode-&gt;data = data;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新节点入链表</span></span><br><span class="line">newnode-&gt;next = p_current;</span><br><span class="line">p_prev-&gt;next = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-4-删除节点"><a href="#8-2-4-删除节点" class="headerlink" title="8.2.4 删除节点"></a>8.2.4 <strong>删除节点</strong></h4><p>编写函数: <code>void remove_linklist(link_node* head,int val)</code></p><p>删除第一个值为val的结点.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除值为val的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_linklist</span><span class="params">(link_node* head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助指针</span></span><br><span class="line">link_node* p_prev = head;</span><br><span class="line">link_node* p_current = p_prev-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找值为val的节点</span></span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (p_current-&gt;data == val)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">p_prev = p_current;</span><br><span class="line">p_current = p_prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果p_current为NULL，表示没有找到</span></span><br><span class="line"><span class="keyword">if</span> (p_current == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除当前节点： 重新建立待删除节点(p_current)的前驱后继节点关系</span></span><br><span class="line">p_prev-&gt;next = p_current-&gt;next;</span><br><span class="line"><span class="comment">//释放待删除节点的内存</span></span><br><span class="line"><span class="built_in">free</span>(p_current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-5-销毁链表"><a href="#8-2-5-销毁链表" class="headerlink" title="8.2.5 销毁链表"></a>8.2.5 <strong>销毁链表</strong></h4><p>编写函数: <code>void destroy_linklist(link_node* head)</code></p><p>销毁链表，释放所有节点的空间.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_linklist</span><span class="params">(link_node* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值指针</span></span><br><span class="line">link_node* p_current = head;</span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//缓存当前节点下一个节点</span></span><br><span class="line">link_node* p_next = p_current-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p_current);</span><br><span class="line">p_current = p_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、函数指针"><a href="#九、函数指针" class="headerlink" title="九、函数指针"></a>九、函数指针</h2><h3 id="9-1-函数类型"><a href="#9-1-函数类型" class="headerlink" title="9.1 函数类型"></a>9.1 函数类型</h3><p>通过什么来区分两个不同的函数？</p><p>一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，<strong>函数名代表函数的入口地址</strong>。</p><p>函数三要素： 名称、参数、返回值。C语言中的函数有自己特定的类型。</p><p>c 语言中通过 typedef 为函数类型重命名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;<span class="comment">// f 为函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">// p 为函数类型</span></span><br></pre></td></tr></table></figure><p>这一点和数组一样，因此我们可以用一个指针变量来存放这个入口地址，然后通过该指针变量调用函数。</p><p><strong>注意：</strong>通过函数类型定义的变量是不能够直接执行，因为没有函数体。只能通过类型定义一个函数指针指向某一个具体函数，才能调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(p)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">p p1;</span><br><span class="line"><span class="comment">//p1(10,20); //错误，不能直接调用，只描述了函数类型，但是并没有定义函数体，没有函数体无法调用</span></span><br><span class="line">p* p2 = my_func;</span><br><span class="line">p2(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//正确，指向有函数体的函数入口地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-函数指针-指向函数的指针"><a href="#9-2-函数指针-指向函数的指针" class="headerlink" title="9.2 函数指针(指向函数的指针)"></a>9.2 函数指针(指向函数的指针)</h3><ul><li>函数指针定义方式(先定义函数类型，根据类型定义指针变量);</li><li>先定义函数指针类型，根据类型定义指针变量;</li><li>直接定义函数指针变量;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret:%d\n"</span>, a + b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 先定义函数类型，通过类型定义指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(FUNC_TYPE)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">FUNC_TYPE* f = my_func;</span><br><span class="line"><span class="comment">//如何调用？</span></span><br><span class="line">(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FUNC_POINTER)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">FUNC_POINTER f = my_func;</span><br><span class="line"><span class="comment">//如何调用？</span></span><br><span class="line">(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 直接定义函数指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>(*f)(<span class="keyword">int</span>, <span class="keyword">int</span>) = my_func;</span><br><span class="line"><span class="comment">//如何调用？</span></span><br><span class="line">(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-函数指针数组"><a href="#9-3-函数指针数组" class="headerlink" title="9.3 函数指针数组"></a>9.3 <strong>函数指针数组</strong></h3><p>函数指针数组，每个元素都是函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func01</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func01:%d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func02</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func02:%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func03</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func03:%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//定义函数指针</span></span><br><span class="line"><span class="keyword">void</span>(*func_array[])(<span class="keyword">int</span>) = &#123; func01, func02, func03 &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">void</span>(*func_array[<span class="number">3</span>])(<span class="keyword">int</span>);</span><br><span class="line">func_array[<span class="number">0</span>] = func01;</span><br><span class="line">func_array[<span class="number">1</span>] = func02;</span><br><span class="line">func_array[<span class="number">2</span>] = func03;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)&#123;</span><br><span class="line">func_array[i](<span class="number">10</span> + i);</span><br><span class="line">(*func_array[i])(<span class="number">10</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-函数指针做函数参数-回调函数"><a href="#9-4-函数指针做函数参数-回调函数" class="headerlink" title="9.4 函数指针做函数参数(回调函数)"></a>9.4 <strong>函数指针做函数参数(回调函数)</strong></h3><p>函数参数除了是普通变量，还可以是函数指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参为普通变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">int</span> x )</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//形参为函数指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">int</span>(*p)(<span class="keyword">int</span> a) )</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>函数指针变量常见的用途之一是把指针作为参数传递到其他函数，指向函数的指针也可以作为参数，以实现函数地址的传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caculator</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>(*func)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> func(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FUNC_POINTER)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caculator</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, FUNC_POINTER func)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> func(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>函数指针和指针函数的区别：</p><ul><li><p>函数指针是指向函数的指针；</p></li><li><p>指针函数是返回类型为指针的函数；</p></li></ul><h2 id="十、预处理"><a href="#十、预处理" class="headerlink" title="十、预处理"></a>十、预处理</h2><h3 id="10-1-预处理的基本概念"><a href="#10-1-预处理的基本概念" class="headerlink" title="10.1 预处理的基本概念"></a>10.1 预处理的基本概念</h3><p>C 语言对源程序处理的四个步骤：<strong>预处理、编译、汇编、链接</strong>。</p><p>预处理是在程序源代码被编译之前，由预处理器（Preprocessor）对程序源代码进行的处理。这个过程并不对程序的源代码语法进行解析，但它会把源代码分割或处理成为特定的符号为下一步的编译做准备工作。</p><h3 id="10-2-文件包含指令-include"><a href="#10-2-文件包含指令-include" class="headerlink" title="10.2 文件包含指令(#include)"></a>10.2 文件包含指令(#include)</h3><p>“文件包含处理”是指一个源文件可以将另外一个文件的全部内容包含进来。Ｃ语言提供了 #include 命令用来实现“文件包含”的操作。</p><p><strong>#incude&lt;&gt; 和 #include”” 区别</strong></p><ul><li><p><strong>“”</strong> 表示系统先在 file1.c 所在的当前目录找 file1.h，如果找不到，再按系统指定的目录检索。</p></li><li><p><strong>&lt; &gt;</strong> 表示系统直接按系统指定的目录检索。</p></li></ul><p>注意：</p><p>​    1. #include &lt;&gt; 常用于包含库函数的头文件；</p><p>​    2. #include “” 常用于包含自定义的头文件；</p><p>​    3. 理论上 #include 可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含；</p><h3 id="10-3-宏定义"><a href="#10-3-宏定义" class="headerlink" title="10.3 宏定义"></a>10.3 宏定义</h3><h4 id="10-3-1-无参数的宏定义-宏常量"><a href="#10-3-1-无参数的宏定义-宏常量" class="headerlink" title="10.3.1 无参数的宏定义(宏常量)"></a>10.3.1 无参数的宏定义(宏常量)</h4><p>如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为：</p><p>const int num = 100; 但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用：</p><p>#define num 100</p><p>在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。<strong>宏定义，只在宏定义的文件中起作用</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> r = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">double</span> s = PI * r * r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s = %lf\n"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>1)宏名一般用大写，以便于与变量区别；</p></li><li><p>2) 宏定义可以是常数、表达式等；</p></li><li><p>3) 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错；</p></li><li><p>4) 宏定义不是C语言，不在行末加分号；</p></li><li><p>5) <strong>宏名有效范围为从定义到本源文件结束</strong>；</p></li><li><p>6) <strong>可以用#undef命令终止宏定义的作用域</strong>；</p></li><li><p>7) 在宏定义中，可以引用已定义的宏名；</p></li></ul><h4 id="10-3-2-带参数的宏定义-宏函数"><a href="#10-3-2-带参数的宏定义-宏函数" class="headerlink" title="10.3.2 带参数的宏定义(宏函数)"></a>10.3.2 带参数的宏定义(宏函数)</h4><p>在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。</p><p>宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(x,y) ((x)+(y))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//仅仅只是做文本替换 下例替换为 int ret = ((10)+(20));</span></span><br><span class="line"><span class="comment">//不进行计算</span></span><br><span class="line"><span class="keyword">int</span> ret = SUM(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret:%d\n"</span>,ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p>1) 宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格；</p></li><li><p>2) 用括号括住每一个参数，并括住宏的整体定义。</p></li><li><p>3) 用大写字母表示宏的函数名。</p></li><li><p>4) 如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。</p></li></ul><h3 id="10-4-条件编译"><a href="#10-4-条件编译" class="headerlink" title="10.4 条件编译"></a>10.4 条件编译</h3><p>一般情况下，源程序中所有的行都参加编译。但有时希望对部分源程序行只在满足一定条件时才编译，即对这部分源程序行指定编译条件。</p><img src="/images/imageProgramC/条件编译.png"><p><strong>条件编译</strong></p><ul><li>防止头文件被重复包含引用；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SOMEFILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SOMEFILE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要声明的变量、函数</span></span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="10-5-一些特殊的预定宏"><a href="#10-5-一些特殊的预定宏" class="headerlink" title="10.5 一些特殊的预定宏"></a>10.5 <strong>一些特殊的预定宏</strong></h3><p>C 编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__FILE__宏所在文件的源文件名 </span></span><br><span class="line"><span class="comment">//__LINE__宏所在行的行号</span></span><br><span class="line"><span class="comment">//__DATE__代码编译的日期</span></span><br><span class="line"><span class="comment">//__TIME__代码编译的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __FILE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, __LINE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __DATE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __TIME__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、动态库的封装和使用"><a href="#十一、动态库的封装和使用" class="headerlink" title="十一、动态库的封装和使用"></a>十一、动态库的封装和使用</h2><h3 id="11-1-库的基本概念"><a href="#11-1-库的基本概念" class="headerlink" title="11.1 库的基本概念"></a>11.1 库的基本概念</h3><p>库是已经写好的、成熟的、可复用的代码。每个程序都需要依赖很多底层库，不可能每个人的代码从零开始编写代码，因此库的存在具有非常重要的意义。</p><p>在我们的开发的应用中经常有一些公共代码是需要反复使用的，就把这些代码编译为库文件。</p><p>库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。像在Windows这样的平台上，最常用的 c 语言库是由集成按开发环境所附带的运行库，这些库一般由编译厂商提供。</p><p>库：就是已经编写好的，后续可以直接使用的代码。</p><p>c++静态库：会合入到最终生成的程序，<strong>使得结果文件比较大</strong>。优点是不再有任何依赖。</p><p>c++动态库：动态库，<strong>一个文件可以多个代码同时使用内存中只有一份，节省内存</strong>，可以随主代码一起编译。缺点是需要头文件。</p><p><strong>网友说：库就是除了main函数之外的其他代码，都可以组成库</strong>。</p><h3 id="11-2-静态库优缺点"><a href="#11-2-静态库优缺点" class="headerlink" title="11.2 静态库优缺点"></a>11.2 静态库优缺点</h3><ul><li><p><strong>静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系</strong>；</p></li><li><p>程序在运行时与函数库再无瓜葛，移植方便。</p></li><li><p><strong>浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</strong>。</p></li></ul><p><strong>内存和磁盘空间</strong></p><ul><li>静态链接这种方法很简单，原理上也很容易理解，在操作系统和硬件不发达的早期，绝大部门系统采用这种方案。随着计算机软件的发展，这种方法的缺点很快暴露出来，那就是静态链接的方式对于计算机内存和磁盘空间浪费非常严重。特别是多进程操作系统下，静态链接极大的浪费了内存空间。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。</li></ul><p><strong>程序开发和发布</strong></p><ul><li>空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也会带来很多麻烦。比如程序中所使用的mylib.lib是由一个第三方厂商提供的，当该厂商更新容量mylib.lib的时候，那么我们的程序就要拿到最新版的mylib.lib，然后将其重新编译链接后，将新的程序整个发布给用户。这样的做缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。</li></ul><p>要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，<strong>把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想</strong>。</p><h3 id="11-3-Linux-下-gcc-编译器生成和使用静态库和动态库"><a href="#11-3-Linux-下-gcc-编译器生成和使用静态库和动态库" class="headerlink" title="11.3 Linux 下 gcc 编译器生成和使用静态库和动态库"></a>11.3 Linux 下 gcc 编译器生成和使用静态库和动态库</h3><p>我们通常把一些公用函数制作成函数库，供其它程序使用。函数库分为静态库和动态库两种。</p><ul><li><p>静态库<strong>在程序编译时会被链接并拷贝到目标代码中，程序运行时将不再需要该静态库</strong>。</p></li><li><p>动态库<strong>在程序编译时并不会被拷贝到目标代码中，而是在程序运行时才被载入</strong>，因此在程序运行时还需要动态库存在。本质上说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。</p></li></ul><p>windows 和 linux 库的二进制是不兼容的（主要是编译器、汇编器和连接器的不同）。</p><h4 id="11-3-1-基本概念"><a href="#11-3-1-基本概念" class="headerlink" title="11.3.1 基本概念"></a>11.3.1 基本概念</h4><p><strong>库的种类</strong>：</p><p>linux下的库有两种：</p><ul><li>静态库</li><li>共享库（动态库）。</li></ul><p>二者区别在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。</p><p><strong>库文件是如何产生的</strong>：</p><p>静态库的后缀是 <code>.a</code>，它的产生分两步:</p><ul><li><p>Step 1. 由源文件编译生成一堆 <code>.o</code>，每个 <code>.o</code> 里都包含这个编译单元的符号表</p></li><li><p>Step 2. ar 命令将很多 <code>.o</code> 转换成 <code>.a</code>，成为静态库</p></li></ul><p>动态库的后缀是 <code>.so</code>，它由 gcc 加特定参数编译产生。</p><p><strong>库文件命名规范</strong>：</p><p>库文件一般放在 <code>/usr/local/lib</code>，<code>/usr/lib</code>，<code>/lib</code>，或者其他自定义的 <code>lib</code> 下。</p><ul><li><p>静态库的名字一般为 <code>libxxxx.a</code>，其中 <code>xxxx</code> 是该 <code>lib</code> 的名称</p></li><li><p>动态库的名字一般为 <code>libxxxx.so.major.minor</code>， <code>xxxx</code> 是该 <code>lib</code> 的名称，<code>major</code> 是主版本号， <code>minor</code> 是副版本号</p></li></ul><p><strong>如何知道一个可执行程序依赖哪些库</strong>：</p><p><code>ldd</code> 命令可以查看一个可执行程序依赖的共享库，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd /lib/i386-linux-gnu/libc.so.6</span></span><br><span class="line">/lib/ld-linux.so.2 (0xf7740000)</span><br><span class="line">linux-gate.so.1 =&gt;  (0xf773f000)</span><br></pre></td></tr></table></figure><p>可以看到 <code>libc</code> 命令依赖于 <code>linux-gate</code> 库和 <code>ld-linux</code> 库</p><p><strong>可执行程序在执行的时候如何定位共享库文件</strong>：</p><p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(<code>dynamic linker/loader</code>)</p><p>对于 <code>elf</code> 格式的可执行程序，是由 <code>ld-linux.so*</code> 来完成的，它先后搜索 <code>elf</code> 文件的 <code>DT_RPATH</code> 段—环境变量 <code>LD_LIBRARY_PATH—/etc/ld.so.cache</code> 文件列表— <code>/lib/,/usr/lib</code> 目录找到库文件后将其载入内存</p><p>如：<code>export LD_LIBRARY_PATH=’pwd’</code></p><p>将当前文件目录添加为共享目录</p><p><strong>在新安装一个库之后如何让系统能够找到他</strong>：</p><p>如果安装在 <code>/lib</code> 或者 <code>/usr/lib</code> 下，那么 <code>ld</code> 默认能够找到，无需其他操作。如果安装在其他目录，需要将其添加到 <code>/etc/ld.so.cache</code> 文件中，步骤如下：</p><ol><li><p>编辑 <code>/etc/ld.so.conf</code> 文件，加入库文件所在目录的路径</p></li><li><p>运行 <code>ldconfig</code>，该命令会重建 <code>/etc/ld.so.cache</code> 文件</p></li></ol><h4 id="11-3-2-用-gcc-生成静态和动态链接库的示例"><a href="#11-3-2-用-gcc-生成静态和动态链接库的示例" class="headerlink" title="11.3.2 用 gcc 生成静态和动态链接库的示例"></a>11.3.2 用 gcc 生成静态和动态链接库的示例</h4><p>假设有1个类 hello，和一个 main 函数。如下：</p><p><strong>hello.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HELLO_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_H </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>hello.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    hello(<span class="string">"world!"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello.c 是一个没有 main 函数的 <code>.c</code> 程序，因此不够成一个完整的程序，如果使用 <code>gcc –o</code> 编译并连接它，<code>gcc</code> 将报错，无法通过编译。</p><p>前面提过，无论静态库，还是动态库，都是由 <code>.o</code>文件创建的。那么我们如何才能让 main.c 调用 hello 类呢？也就是说该如何才能将 hello.c 通过 gcc 先编译成 <code>.o</code> 文件，并且让 main.c 在编译时能找到它？有三种途径可以实现：</p><ul><li><p>1）通过编译多个源文件，直接将目标代码合成一个 <code>.o</code> 文件。</p></li><li><p>2）通过创建静态链接库 <code>libmyhello.a</code>，使得 main 函数调用 hello 函数时可调用静态链接库。</p></li><li><p>3）通过创建动态链接库 <code>libmyhello.so</code>，使得 main 函数调用 hello 函数时可调用动态链接库。</p></li></ul><h5 id="11-3-2-1-途径一：编译多个源文件"><a href="#11-3-2-1-途径一：编译多个源文件" class="headerlink" title="11.3.2.1 途径一：编译多个源文件"></a>11.3.2.1 途径一：编译多个源文件</h5><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c main.c</span></span><br></pre></td></tr></table></figure><p>这里提醒一下：<code>gcc –o</code> 是将 <code>.c</code> 源文件编译成为一个可执行的二进制代码。而 <code>gcc –c</code> 是使用GNU汇编器将源文件转化为目标代码。更多 gcc 编译选项的常识点<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FyYWNrZXRoaXMvYXJ0aWNsZS9kZXRhaWxzLzQzMzcwMzA3" title="https://blog.csdn.net/arackethis/article/details/43370307">这里<i class="fa fa-external-link"></i></span>。</p><p>这时可以看到生成了 hello.o 和 main.o 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c  main.o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将两个文件链接成一个 `.o` 文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看此时已经生成了可执行文件sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c  main.o  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure><h5 id="11-3-2-2-途径二：静态链接库"><a href="#11-3-2-2-途径二：静态链接库" class="headerlink" title="11.3.2.2 途径二：静态链接库"></a>11.3.2.2 途径二：静态链接库</h5><p>静态库文件名是以 lib 为前缀，紧接着是静态库名，扩展名为 <code>.a</code>。例如：我们将创建的静态库名为myhello，则静态库文件名就是 <code>libmyhello.a</code> 。创建静态库用 <code>ar</code> 命令。</p><p>删除途径一中生成的3个文件，回到原始的三个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm hello.o main.o sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始尝试途径二，创建静态库文件libmyhello.a：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs libmyhello.a hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下已经生成了：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  libmyhello.a  main.c</span><br></pre></td></tr></table></figure><p>静态库制作完了，如何使用它内部的函数呢？</p><p><strong>只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明，然后在用 gcc 命令生成目标文件时指明静态库名，gcc 将会从静态库中将公用函数连接到目标文件中</strong>。</p><p><strong>注意</strong>，gcc 会在静态库名前加上前缀 lib，然后追加扩展名 <code>.a</code> 得到的静态库文件名来查找静态库文件。</p><p>因此，我们在写需要连接的库时，只写静态库名就可以，如 <code>libmyhello.a</code> 的库，只写: <code>-lmyhello</code><br>在 main.c 中，我们已包含了该静态库的头文件 hello.h。现在在主程序 main.c 中直接调用它内部的函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里-L.告诉 gcc 先在当前目录下查找库文件。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.c -static -L. -lmyhello       </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下，已经生成可执行文件sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  libmyhello.a  main.c  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure><p>前面提过静态库在编译过程中会被拷贝到目标程序中，运行时不再需要静态库的存在。这里可以简单验证一下：我们删除静态库文件，然后再试着调用函数 hello 看是否还能调用成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm libmyhello.a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure><p>程序照常运行，静态库中的函数已经被复制到目标程序中了，编译完成后，静态库就没用了，执行时不再需要静态库的存在。</p><p><strong>静态链接库的一个缺点是</strong>：</p><ul><li>如果我们同时运行了许多程序，并且它们使用了同一个库函数，这样，在内存中会大量拷贝同一库函数。这样，就会浪费内存和存储空间。</li></ul><p>使用了共享链接库的Linux就可以避免这个问题。共享函数库和静态函数在同一个地方，只是后缀不同。比如，在Linux系统，标准的共享数序函数库是 <code>/usr/lib/libm.so</code>。<strong>当一个程序使用共享函数库时，在连接阶段并不把函数代码连接进来，而只是链接函数的一个引用。当最终的函数导入内存开始真正执行时，函数引用被解析，共享函数库的代码才真正导入到内存中</strong>。这样，共享链接库的函数就可以被许多程序同时共享，并且只需存储一次就可以了。<strong>共享函数库的另一个优点是，它可以独立更新，与调用它的函数毫不影响</strong>。</p><h5 id="11-3-2-3-途径三：动态链接库（共享函数库）"><a href="#11-3-2-3-途径三：动态链接库（共享函数库）" class="headerlink" title="11.3.2.3 途径三：动态链接库（共享函数库）"></a>11.3.2.3 途径三：动态链接库（共享函数库）</h5><p>动态库文件名和静态库类似，也是在动态库名增加前缀 lib，但其文件扩展名为 <code>.so</code>。例如：我们将创建的动态库名为 myhello，则动态库文件名就是 <code>libmyhello.so</code> 。用 gcc 来创建动态库。</p><p>删除途径二中生成的2个文件，回到原始的三个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm hello.o sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始尝试途径三，创建静态库文件libmyhello.so：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按教程里，会报错：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -fPIC -o libmyhello.so hello.o</span></span><br><span class="line">/usr/bin/ld: hello.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC</span><br><span class="line">hello.o: could not read symbols: Bad value</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>正确方法是，这样就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared -o libmyhello.so hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 已生成libmyhello.so，是绿色。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  libmyhello.so  main.c</span><br></pre></td></tr></table></figure><p>最主要的是 GCC 命令行的选项:</p><ul><li><p><code>-shared</code>：指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件</p></li><li><p><code>-fPIC</code>：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。</p></li></ul><p>下面调用该动态链接库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.c -L. -lmyhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  libmyhello.so  main.c  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br><span class="line">成功！</span><br></pre></td></tr></table></figure><p>按教程里说的：他以这种方式调用动态链接库出错，找不到动态库文件 <code>libmyhello.so</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sayhello: error while loading shared libraries: libmyhello.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>程序在运行时，会在 /usr/lib 和 /lib 等目录中查找需要的动态库文件。若找到，则载入动态库，否则将提示类似上述错误而终止程序运行。解决此类问题有如下三种方法：</p><ul><li><p>（1）我们将文件 libmyhello.so复制到目录/usr/lib中。</p></li><li><p>（2）既然连接器会搜寻LD_LIBRARY_PATH所指定的目录，那么我们只要将当前目录添加到环境变量：</p><p><code>export LD_LIBRARY_PATH=$(pwd)</code></p></li><li><p>（3）执行： <code>ldconfig /usr/zhsoft/lib</code></p></li></ul><p>说明：当用户在某个目录下面创建或拷贝了一个动态链接库，若想使其被系统共享，可以执行一下 “ldconfig 目录名” 这个命令。此命令的功能在于让 ldconfig 将指定目录下的动态链接库被系统共享起来，意即：在缓存文件 <code>/etc/ld.so.cache</code> 中追加进指定目录下的共享库。该命令会重建 <code>/etc/ld.so.cache</code> 文件。</p><p>参考教程：</p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlheW91eGpoL2FydGljbGUvZGV0YWlscy83NjAyNzI5" title="http://blog.csdn.net/jiayouxjh/article/details/7602729">http://blog.csdn.net/jiayouxjh/article/details/7602729<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzU0ZjgyY2MyMDEwMTE1M3guaHRtbA==" title="http://blog.sina.com.cn/s/blog_54f82cc20101153x.html">http://blog.sina.com.cn/s/blog_54f82cc20101153x.html<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25hdnlhaWptLmJsb2cuNTFjdG8uY29tLzQ2NDcwNjgvODA5NDI0" title="http://navyaijm.blog.51cto.com/4647068/809424">http://navyaijm.blog.51cto.com/4647068/809424<i class="fa fa-external-link"></i></span></p><h2 id="十二、递归函数"><a href="#十二、递归函数" class="headerlink" title="十二、递归函数"></a>十二、递归函数</h2><h3 id="12-1-递归函数基本概念"><a href="#12-1-递归函数基本概念" class="headerlink" title="12.1 递归函数基本概念"></a>12.1 <strong>递归函数基本概念</strong></h3><p>C通过运行时堆栈来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。</p><h3 id="12-2-普通函数调用"><a href="#12-2-普通函数调用" class="headerlink" title="12.2 普通函数调用"></a>12.2 普通函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funB</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b = %d\n"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">funB(a - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">funA(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用流程如下：</p><img src="/images/imageProgramC/递归函数.png"><h3 id="12-3-递归函数调用"><a href="#12-3-递归函数调用" class="headerlink" title="12.3 递归函数调用"></a>12.3 递归函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//中断函数很重要</span></span><br><span class="line">&#125;</span><br><span class="line">fun(a - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">fun(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用流程如下：</p><img src="/images/imageProgramC/递归函数-01.png"><p><strong>递归实现给出一个数8793，依次打印千位数字8、百位数字7、十位数字9、个位数字3。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (val == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret = val / <span class="number">10</span>;</span><br><span class="line">recursion(ret);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,val % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-递归实现字符串反转"><a href="#12-4-递归实现字符串反转" class="headerlink" title="12.4 递归实现字符串反转"></a>12.4 递归实现字符串反转</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse1</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">'\0'</span>) &#123;  <span class="comment">// 函数递归调用结束条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse1(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, *str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( *str == <span class="string">'\0'</span> ) &#123;<span class="comment">// 函数递归调用结束条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse2(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strncat</span>(buf, str, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse3</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> *dst)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span> || dst == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">'\0'</span>) &#123;<span class="comment">// 函数递归调用结束条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse3(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strncat</span>(dst, str, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-递归实现链表逆序打印"><a href="#12-5-递归实现链表逆序打印" class="headerlink" title="12.5 递归实现链表逆序打印"></a>12.5 递归实现链表逆序打印</h3><p>TODO</p><h2 id="十三、面向接口编程"><a href="#十三、面向接口编程" class="headerlink" title="十三、面向接口编程"></a>十三、面向接口编程</h2><h3 id="13-1-案例背景"><a href="#13-1-案例背景" class="headerlink" title="13.1 案例背景"></a>13.1 案例背景</h3><p>一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。</p><h3 id="13-2-案例需求"><a href="#13-2-案例需求" class="headerlink" title="13.2 案例需求"></a>13.2 案例需求</h3><p>要求在企业信息系统框架中集成第三方厂商的socket通信产品和第三方厂商加密产品。软件设计要求：模块要求松、接口要求紧。</p><h3 id="13-3-案例要求"><a href="#13-3-案例要求" class="headerlink" title="13.3 案例要求"></a>13.3 案例要求</h3><ul><li><p>1）能支持多个厂商的 socket 通信产品入围</p></li><li><p>2）能支持多个第三方厂商加密产品的入围</p></li><li><p>3）企业信息系统框架不轻易发生框架</p></li></ul><h3 id="13-4-编程提示"><a href="#13-4-编程提示" class="headerlink" title="13.4 编程提示"></a>13.4 编程提示</h3><ul><li><p>1）抽象通信接口结构体设计（CSocketProtocol）</p></li><li><p>2）框架接口设计（framework）</p></li><li><p>3）   a) 通信厂商1入围（CSckImp1）  b) 通信厂商2入围（CSckImp2）</p></li><li><p>4）   a) 抽象加密接口结构体设计（CEncDesProtocol） b) 升级框架函数（增加加解密功能）  c) 加密厂商1入围(CHwImp)、加密厂商2入围(CCiscoImp)</p></li><li><p>5）框架接口分文件</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-语言进阶&quot;&gt;&lt;a href=&quot;#C-语言进阶&quot; class=&quot;headerlink&quot; title=&quot;C 语言进阶&quot;&gt;&lt;/a&gt;C 语言进阶&lt;/h1&gt;&lt;h2 id=&quot;一、-内存分区&quot;&gt;&lt;a href=&quot;#一、-内存分区&quot; class=&quot;headerlink&quot; title=&quot;一、 内存分区&quot;&gt;&lt;/a&gt;一、 内存分区&lt;/h2&gt;&lt;p&gt;栈区&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>C 基础</title>
    <link href="http://miaopei.github.io/2016/05/10/Program-C/program-c/"/>
    <id>http://miaopei.github.io/2016/05/10/Program-C/program-c/</id>
    <published>2016-05-10T02:14:50.000Z</published>
    <updated>2019-06-14T06:12:55.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C 语言基础"></a>C 语言基础</h1><h2 id="一、C-语言概述"><a href="#一、C-语言概述" class="headerlink" title="一、C 语言概述"></a>一、C 语言概述</h2><a id="more"></a><img src="/images/imageProgramC/03_C语言概述.png"><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><img src="/images/imageProgramC/04_数据类型.png"><h2 id="三、字符串处理和函数"><a href="#三、字符串处理和函数" class="headerlink" title="三、字符串处理和函数"></a>三、字符串处理和函数</h2><ul><li><p>声明变量不需要建立存储空间，如：extern int a;</p></li><li><p>定义变量需要建立存储空间，如：int b;</p></li><li><p>全局数组若不初始化，编译器将其初始化为零。局部数组若不初始化，内容为随机值。</p></li><li><p>数字 0 (和字符 ‘\0’ 等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。</p></li></ul><p>gets(str)与scanf(“%s”,str)的区别：</p><ul><li><p>gets(str)允许输入的字符串含有空格</p></li><li><p>scanf(“%s”,str)不允许含有空格</p></li><li><p>注意：由于scanf()和gets()无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字符数组越界(缓冲区溢出)的情况。</p></li></ul><p>gets() 、puts()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">功能：从标准输入读入字符，并保存到s指定的内存空间，直到出现换行符或读到文件结尾为止。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">功能：标准设备输出s字符串，在输出完成后自动输出一个<span class="string">'\n'</span>。</span><br></pre></td></tr></table></figure><p>fgets() 、fputs()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line">功能：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - <span class="number">1</span>个字符为止，最后会自动加上字符 <span class="string">'\0'</span> 作为字符串结束。</span><br><span class="line">fgets()在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。通过<span class="built_in">scanf</span>和gets输入一个字符串的时候，不包含结尾的“\n”，但通过fgets结尾多了“\n”。fgets()函数是安全的，不存在缓冲区溢出的问题。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, FILE * stream)</span></span>;</span><br><span class="line">功能：将str所指定的字符串写入到stream指定的文件中， 字符串结束符 <span class="string">'\0'</span>  不写入文件。</span><br><span class="line"><span class="built_in">fputs</span>()是<span class="built_in">puts</span>()的文件操作版本，但<span class="built_in">fputs</span>()不会自动输出一个<span class="string">'\n'</span>。</span><br></pre></td></tr></table></figure><p>strlen() 、strcpy() 、strncpy() 、strcat() 、strncat() 、strcmp() 、strncmp() 、sprintf() 、sscanf() 、strchr() 、strstr() 、strtok() 、atoi()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">功能：计算指定指定字符串s的长度，不包含字符串结束符‘\<span class="number">0</span>’</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br><span class="line">功能：把src所指向的字符串复制到dest所指向的空间中，<span class="string">'\0'</span>也会拷贝过去</span><br><span class="line">注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含<span class="string">'\0'</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br><span class="line">功能：将src字符串连接到dest的尾部，‘\<span class="number">0</span>’也会追加过去</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：将src字符串前n个字符连接到dest的尾部，‘\<span class="number">0</span>’也会追加过去</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line">功能：比较 s1 和 s2 的大小，比较的是字符ASCII码大小。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *_CRT_SECURE_NO_WARNINGS, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line">功能：在字符串s中查找字母c出现的位置</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle)</span></span>;</span><br><span class="line">功能：在字符串haystack中查找字符串needle出现的位置</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *delim)</span></span>;</span><br><span class="line">功能：来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\<span class="number">0</span> 字符，当连续出现多个时只替换第一个为\<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br><span class="line">功能：atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(<span class="string">'\0'</span>)才结束转换，并将结果返回返回值。</span><br><span class="line">类似的函数有：</span><br><span class="line">- atof()：把一个小数形式的字符串转化为一个浮点数。</span><br><span class="line">- atol()：将一个字符串转化为<span class="keyword">long</span>类型</span><br></pre></td></tr></table></figure><p>形参列表</p><ul><li>在定义函数时指定的形参，<strong>在未出现函数调用时，它们并不占内存中的存储单元</strong>，因此称它们是形式参数或虚拟参数，简称形参，表示它们并不是实际存在的数据，所以，形参里的变量不能赋值。</li></ul><p>如果函数返回的类型和return语句中表达式的值不一致，则以函数返回类型为准，即<strong>函数返回类型决定返回值的类型</strong>。对数值型数据，可以自动进行类型转换。</p><p><strong>注意</strong>：如果函数返回的类型和return语句中表达式的值不一致，而它又无法自动进行类型转换，程序则会报错。</p><p><strong>当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</strong> </p><p><strong>extern告诉编译器这个变量或函数在其他文档里已被定义了。</strong></p><p>static法则：</p><ul><li>A、若全局变量仅在单个C文档中访问，则能够将这个变量修改为静态全局变量，以降低模块间的耦合度; </li><li>B、若全局变量仅由单个函数访问，则能够将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； </li><li>C、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多文件编译</span></span><br><span class="line">gcc -o 可执行程序 文件<span class="number">1.</span>c 文件<span class="number">2.</span>c 头文件.h</span><br></pre></td></tr></table></figure><h2 id="四、指针和指针变量"><a href="#四、指针和指针变量" class="headerlink" title="四、指针和指针变量"></a>四、指针和指针变量</h2><ul><li><strong>内存区的每一个字节都有一个编号，这就是“地址”</strong>。</li><li>如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)</li><li>指针的实质就是内存“地址”。指针就是地址，地址就是指针。</li><li><strong>指针是内存单元的编号，指针变量是存放地址的变量</strong>。</li><li>通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。</li><li>指针也是一种数据类型，指针变量也是一种变量</li><li>指针变量指向谁，就把谁的地址赋值给指针变量</li><li><strong>“*” 操作符操作的是指针变量指向的内存空间</strong></li></ul><p>指针大小</p><ul><li><strong>使用sizeof()测量指针的大小，得到的总是：4或8</strong></li><li>sizeof()测的是指针变量指向存储地址的大小</li><li>在32位平台，所有的指针（地址）都是32位(4字节)</li><li>在64位平台，所有的指针（地址）都是64位(8字节)</li></ul><p>野指针和空指针</p><ul><li>指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，<strong>任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针</strong>，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，<strong>野指针不会直接引发错误，操作野指针指向的内存区域才会出问题</strong>。</li><li>但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。</li><li>NULL是一个值为0的宏常量：<code>#define NULL    ((void *)0)</code></li></ul><p>万能指针 <code>void *</code></p><p><code>void *</code> 指针可以指向任意变量的内存空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">p = (<span class="keyword">void</span> *)&amp;a; <span class="comment">//指向变量时，最好转换为void *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指针变量指向的内存时，转换为int *</span></span><br><span class="line">*( (<span class="keyword">int</span> *)p ) = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br></pre></td></tr></table></figure><p>const修饰的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向常量的指针</span></span><br><span class="line"><span class="comment">//修饰*，指针指向内存区域不能修改，指针指向可以变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a; <span class="comment">//等价于int const *p1 = &amp;a;</span></span><br><span class="line"><span class="comment">//*p1 = 111; //err</span></span><br><span class="line">p1 = &amp;b; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//修饰p1，指针指向不能变，指针指向的内存可以修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; //err</span></span><br><span class="line">*p2 = <span class="number">222</span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>指针操作数组元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf("%d, ", a[i]);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(a+i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a; <span class="comment">//定义一个指针变量保存a的地址</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(p + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针加减运算</p><ul><li>指针计算不是简单的整数相加</li><li>如果是一个<code>int *</code>，+1的结果是增加一个int的大小</li><li>如果是一个<code>char *</code>，+1的结果是增加一个char大小</li></ul><p>通过改变指针指向操作数组元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *p);</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针数组</p><ul><li>指针数组，它是数组，数组的每个元素都是指针类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//指针数组</span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>] = &amp;a;</span><br><span class="line">p[<span class="number">1</span>] = &amp;b;</span><br><span class="line">p[<span class="number">2</span>] = &amp;c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(p[<span class="number">0</span>]); i++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(p[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多级指针 </p><ul><li>C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针。</li><li>二级指针就是指向一个一级指针变量地址的指针。</li><li>三级指针基本用不着，但考试会考。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">//一级指针</span></span><br><span class="line">*p = <span class="number">100</span>; <span class="comment">//*p就是a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **q = &amp;p;</span><br><span class="line"><span class="comment">//*q就是p</span></span><br><span class="line"><span class="comment">//**q就是a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ***t = &amp;q;</span><br><span class="line"><span class="comment">//*t就是q</span></span><br><span class="line"><span class="comment">//**t就是p</span></span><br><span class="line"><span class="comment">//***t就是a</span></span><br></pre></td></tr></table></figure><p>数组名做函数参数</p><ul><li>数组名做函数参数，函数的形参会退化为指针：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void printArrary(int a[10], int n)</span></span><br><span class="line"><span class="comment">//void printArrary(int a[], int n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArrary</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组名做函数参数</span></span><br><span class="line">printArrary(a, n); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针做为函数的返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*( getA() ) = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针和字符串</p><ul><li>字符指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = str;</span><br><span class="line">*p = <span class="string">'m'</span>;</span><br><span class="line">p++;</span><br><span class="line">*p = <span class="string">'i'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);  <span class="comment">// millo world</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">"mike jiang"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p); <span class="comment">// mike jiang</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *q = <span class="string">"test"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, q); <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const修饰的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//const修饰一个变量为只读</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//a = 100; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量， 指针指向的内存， 2个不同概念</span></span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"aklgjdlsgjlkds"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从左往右看，跳过类型，看修饰哪个字符</span></span><br><span class="line"><span class="comment">//如果是*， 说明指针指向的内存不能改变</span></span><br><span class="line"><span class="comment">//如果是指针变量，说明指针的指向不能改变，指针的值不能修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = buf;</span><br><span class="line"><span class="comment">// 等价于上面 char const *p1 = buf;</span></span><br><span class="line"><span class="comment">//p[1] = '2'; //err</span></span><br><span class="line">p = <span class="string">"agdlsjaglkdsajgl"</span>; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p2 = buf;</span><br><span class="line">p2[<span class="number">1</span>] = <span class="string">'3'</span>;</span><br><span class="line"><span class="comment">//p2 = "salkjgldsjaglk"; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p3为只读，指向不能变，指向的内存也不能变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p3 = buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、内存管理"><a href="#五、内存管理" class="headerlink" title="五、内存管理"></a>五、内存管理</h2><h3 id="5-1-作用域"><a href="#5-1-作用域" class="headerlink" title="5.1 作用域"></a>5.1 作用域</h3><p>C语言变量的作用域分为：</p><ul><li>代码块作用域(代码块是{}之间的一段代码)</li><li>函数作用域</li><li>文件作用域</li></ul><p>局部变量也叫auto自动变量(auto可写可不写)，一般情况下代码块{}内部定义的变量都是自动变量，它有如下特点：</p><ul><li>在一个函数内定义，只在函数范围内有效</li><li>在复合语句中定义，只在复合语句中有效</li><li><strong>随着函数调用的结束或复合语句的结束局部变量的声明声明周期也结束</strong></li><li>如果没有赋初值，内容为随机</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//auto写不写是一样的</span></span><br><span class="line"><span class="comment">//auto只能出现在&#123;&#125;内部</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">int</span> b = <span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//b = 100; //err， 在main作用域中没有b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在复合语句中定义，只在复合语句中有效</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = 10; //err离开if()的复合语句，a已经不存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态(static)局部变量</p><ul><li>static局部变量的作用域也是在定义的函数内有效</li><li>static局部变量的生命周期和程序运行周期一样，同时staitc局部变量的值<strong>只初始化一次，但可以赋值多次</strong></li><li>static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0，字符型变量赋空字符</li></ul><p>全局变量</p><ul><li>在函数外定义，可被本文件及其它文件中的函数所共用，<strong>若其它文件中的函数调用此变量,须用extern声明</strong></li><li>全局变量的生命周期和程序运行周期一样</li><li>不同文件的全局变量不可重名</li></ul><p>静态(static)全局变量</p><ul><li>在函数外定义,作用范围被限制在所定义的文件中</li><li>不同文件静态全局变量可以重名,但作用域不冲突</li><li>static全局变量的生命周期和程序运行周期一样，同时staitc全局变量的值只初始化一次</li></ul><p>extern全局变量声明</p><ul><li>extern int a; 声明一个变量，这个变量在别的文件中已经定义了，这里只是声明，而不是定义</li></ul><p>全局函数和静态函数</p><ul><li>在C语言中函数默认都是全局的，使用关键字static可以将函数声明为静态，函数定义为static就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数都没用。</li></ul><p><strong>注意</strong>：</p><ul><li>允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰。</li><li>同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。</li><li>所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。</li></ul><p>总结：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th></tr></thead><tbody><tr><td>auto变量</td><td>一对{}内</td><td>当前函数</td></tr><tr><td>static局部变量</td><td>一对{}内</td><td>整个程序运行期</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>register变量</td><td>一对{}内</td><td>当前函数</td></tr></tbody></table><h3 id="5-2-内存布局"><a href="#5-2-内存布局" class="headerlink" title="5.2 内存布局"></a>5.2 内存布局</h3><p>内存分区</p><ul><li>C代码经过<strong>预处理、编译、汇编、链接</strong>4步后生成一个可执行程序。</li></ul><p>在 Linux 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况：</p><img src="/images/imageProgramC/fileinfo.png"><p>通过上图可以得知，在没有运行程序前，也就是说<strong>程序没有加载到内存前</strong>，可执行程序内部已经分好3段信息，分别为<strong>代码区（text）、数据区（data）和未初始化数据区（bss）</strong>3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。</p><ul><li><p><strong>代码区</strong></p><ul><li>存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。<strong>代码区通常是只读的</strong>，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。</li></ul></li><li><p><strong>全局初始化数据区/静态数据区（data段）</strong></p><ul><li>该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</li></ul></li><li><p><strong>未初始化数据区（又叫 bss 区）</strong></p><ul><li>存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。</li></ul><p>程序在加载到内存前，<strong>代码区和全局区(data和bss)的大小就是固定的</strong>，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，<strong>除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区</strong>。</p></li></ul><img src="/images/imageProgramC/内存分区.png"><ul><li><p>代码区（text segment）</p><ul><li>加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。</li></ul></li><li><p>未初始化数据区（BSS）</p><ul><li>加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。</li></ul></li><li><p>全局初始化数据区/静态数据区（data segment）</p><ul><li>加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。</li></ul></li><li><p>栈区（stack）</p><ul><li><strong>栈是一种先进后出的内存结构</strong>，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。</li></ul></li><li><p>堆区（heap）</p><ul><li>堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。<strong>堆在内存中位于BSS区和栈区之间</strong>。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</li></ul></li></ul><p>存储类型总结：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th><th><strong>存储位置</strong></th></tr></thead><tbody><tr><td>auto变量</td><td>一对{}内</td><td>当前函数</td><td>栈区</td></tr><tr><td>static局部变量</td><td>一对{}内</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td><td>代码区</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td><td>代码区</td></tr><tr><td>register变量</td><td>一对{}内</td><td>当前函数</td><td>运行时存储在CPU寄存器</td></tr><tr><td>字符串常量</td><td>当前文件</td><td>整个程序运行期</td><td>data段</td></tr></tbody></table><p><strong>存储类型总结内存操作函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：将s的内存区域的前n个字节以参数c填入</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。</span><br><span class="line"></span><br><span class="line">memmove()</span><br><span class="line">memmove()功能用法和<span class="built_in">memcpy</span>()一样，区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比<span class="built_in">memcpy</span>()低些。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：比较s1和s2所指向内存区域的前n个字节</span><br></pre></td></tr></table></figure><p><strong>堆区内存分配和释放</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用<span class="built_in">memset</span>初始化。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count, *<span class="built_in">array</span>, n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入要申请数组的个数:\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"申请空间失败!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将申请到空间清0</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; n; count++) <span class="comment">/*给数组赋值*/</span></span><br><span class="line"><span class="built_in">array</span>[count] = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; n; count++) <span class="comment">/*打印数组元素*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%2d"</span>, <span class="built_in">array</span>[count]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回堆区地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">tmp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*tmp = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;<span class="comment">//返回堆区地址，函数调用完毕，不释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = fun();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, *p);<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//堆区空间，使用完毕，手动释放</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、复合类型-自定义类型"><a href="#六、复合类型-自定义类型" class="headerlink" title="六、复合类型(自定义类型)"></a>六、复合类型(自定义类型)</h2><h3 id="6-1-结构体"><a href="#6-1-结构体" class="headerlink" title="6.1 结构体"></a>6.1 结构体</h3><p>定义结构体变量的方式：</p><ul><li>先声明结构体类型再定义变量名</li><li>在声明类型的同时定义变量</li><li>直接定义结构体类型变量（无类型名）</li></ul><img src="/images/imageProgramC/结构体.png"><p>结构体类型和结构体变量关系：</p><ul><li>结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。</li><li>结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先定义类型，再定义变量（常用）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span> = &#123;</span> <span class="string">"mike"</span>, <span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类型同时定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;s2 = &#123; <span class="string">"lily"</span>, <span class="number">22</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;s3 = &#123; <span class="string">"yuri"</span>, <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure><p>结构体成员的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是普通变量，通过点运算符操作结构体成员</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1.name, <span class="string">"abc"</span>);</span><br><span class="line">s1.age = <span class="number">18</span>;   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s1.name = %s, s1.age = %d\n"</span>, s1.name, s1.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line"><span class="built_in">strcpy</span>((&amp;s1)-&gt;name, <span class="string">"test"</span>);</span><br><span class="line">(&amp;s1)-&gt;age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(&amp;s1)-&gt;name = %s, (&amp;s1)-&gt;age = %d\n"</span>, (&amp;s1)-&gt;name, (&amp;s1)-&gt;age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体套结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">info</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[2] = &#123;</span> <span class="number">1</span>, <span class="string">"lily"</span>, <span class="string">'F'</span>, <span class="number">2</span>, <span class="string">"yuri"</span>, <span class="string">'M'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d\tinfo.name=%s\tinfo.sex=%c\n"</span>, s[i].id, s[i].info.name, s[i].info.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体套一级指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *name; <span class="comment">//一级指针</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">p = (struct stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct  stu));</span><br><span class="line">p-&gt;name = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">"test"</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(p-&gt;name, <span class="string">"test"</span>);</span><br><span class="line">p-&gt;age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p-&gt;name = %s, p-&gt;age=%d\n"</span>, p-&gt;name, p-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(*p).name = %s, (*p).age=%d\n"</span>, (*p).name, (*p).age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;name != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p-&gt;name);</span><br><span class="line">p-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体普通变量做函数参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数参数为结构体普通变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stu</span><span class="params">(struct stu tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp.name, <span class="string">"mike"</span>);</span><br><span class="line">tmp.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"tmp.name = %s, tmp.age = %d\n"</span>, tmp.name, tmp.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">set_stu(s); <span class="comment">//值传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s.name = %s, s.age = %d\n"</span>, s.name, s.age);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体指针变量做函数参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数参数为结构体指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stu_pro</span><span class="params">(struct stu *tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp-&gt;name, <span class="string">"mike"</span>);</span><br><span class="line">tmp-&gt;age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">set_stu_pro(&amp;s); <span class="comment">//地址传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s.name = %s, s.age = %d\n"</span>, s.name, s.age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体数组名做函数参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void set_stu_pro(struct stu tmp[100], int n)</span></span><br><span class="line"><span class="comment">//void set_stu_pro(struct stu tmp[], int n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stu_pro</span><span class="params">(struct stu *tmp, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(tmp-&gt;name, <span class="string">"name%d%d%d"</span>, i, i, i);</span><br><span class="line">tmp-&gt;age = <span class="number">20</span> + i;</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[3] = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">set_stu_pro(s, n); <span class="comment">//数组名传递</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s, %d\n"</span>, s[i].name, s[i].age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-共用体-联合体"><a href="#6-2-共用体-联合体" class="headerlink" title="6.2 共用体(联合体)"></a>6.2 共用体(联合体)</h3><ul><li>联合union是一个能在同一个存储空间存储不同类型数据的类型；</li><li>联合体所占的内存长度等于其最长成员的长度，也有叫做共用体；</li><li>同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用；</li><li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖；</li><li>共用体变量的地址和它的各成员的地址都是同一地址。</li></ul><h3 id="6-3-枚举"><a href="#6-3-枚举" class="headerlink" title="6.3 枚举"></a>6.3 枚举</h3><p>枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p><p>枚举类型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  枚举名</span><br><span class="line">&#123;</span><br><span class="line">枚举值表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在枚举值表中应列出所有可用值，也称为枚举元素。</li><li>枚举值是常量，不能在程序中用赋值语句再对它赋值。</li><li>枚举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 …</li></ul><h3 id="6-4-typedef"><a href="#6-4-typedef" class="headerlink" title="6.4 typedef"></a>6.4 typedef</h3><p>typedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，<strong>不能创建新类型</strong>。</p><ul><li><p>与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值</p></li><li><p>#define发生在预处理，typedef发生在编译阶段</p></li></ul><h2 id="七、文件操作"><a href="#七、文件操作" class="headerlink" title="七、文件操作"></a>七、文件操作</h2><p>磁盘文件和设备文件</p><ul><li>磁盘文件<ul><li>指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。</li></ul></li><li>设备文件<ul><li>在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。</li></ul></li></ul><h3 id="7-1-文件的打开和关闭"><a href="#7-1-文件的打开和关闭" class="headerlink" title="7.1 文件的打开和关闭"></a>7.1 文件的打开和关闭</h3><p>文件指针</p><ul><li>在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">short</span>           level;<span class="comment">//缓冲区"满"或者"空"的程度 </span></span><br><span class="line"><span class="keyword">unsigned</span>        flags;<span class="comment">//文件状态标志 </span></span><br><span class="line"><span class="keyword">char</span>            fd;<span class="comment">//文件描述符</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>   hold;<span class="comment">//如无缓冲区不读取字符</span></span><br><span class="line"><span class="keyword">short</span>           bsize;<span class="comment">//缓冲区的大小</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>   *buffer;<span class="comment">//数据缓冲区的位置 </span></span><br><span class="line"><span class="keyword">unsigned</span>        ar; <span class="comment">//指针，当前的指向</span></span><br><span class="line"><span class="keyword">unsigned</span>        istemp;<span class="comment">//临时文件，指示器</span></span><br><span class="line"><span class="keyword">short</span>           token;<span class="comment">//用于有效性的检查 </span></span><br><span class="line">&#125;FILE;</span><br></pre></td></tr></table></figure><p>FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，<strong>结构中含有文件名、文件状态和文件当前位置等信息</strong>。</p><p>声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 </p><p>文件的打开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line">功能：打开文件</span><br></pre></td></tr></table></figure><p>第二个参数的几种形式(打开文件的方式)：</p><table><thead><tr><th><strong>打开模式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>r或rb</td><td>以只读方式打开一个文本文件（不创建文件，若文件不存在则报错）</td></tr><tr><td>w或wb</td><td>以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a或ab</td><td>以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件</td></tr><tr><td>r+或rb+</td><td>以可读、可写的方式打开文件(不创建新文件)</td></tr><tr><td>w+或wb+</td><td>以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a+或ab+</td><td>以添加方式打开文件，打开文件并在末尾更改文件,若文件不存在则创建文件</td></tr></tbody></table><p>注意：</p><ul><li><p>b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的</p></li><li><p>Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾</p></li><li><p>在Windows平台下，以“文本”方式打开文件，不加b：</p><ul><li>当读取文件的时候，系统会将所有的 “\r\n” 转换成 “\n”</li><li>当写入文件的时候，系统会将 “\n” 转换成 “\r\n” 写入 </li><li><strong>以”二进制”方式打开文件，则读\写都不会进行这样的转换</strong></li></ul></li><li><p>在Unix/Linux平台下，“文本”与“二进制”模式没有区别，”\r\n” 作为两个字符原样输入输出</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径可以是相对路径，也可是绝对路径</span></span><br><span class="line">fp = fopen(<span class="string">"../test"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="comment">//fp = fopen("..\\test", "w");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) <span class="comment">//返回空，说明打开失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//perror()是标准出错打印函数，能打印调用库函数出错原因</span></span><br><span class="line">perror(<span class="string">"open"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-文件的顺序读写"><a href="#7-2-文件的顺序读写" class="headerlink" title="7.2 文件的顺序读写"></a>7.2 文件的顺序读写</h3><ul><li>按照字符读写文件fgetc、fputc</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE * stream)</span></span>;</span><br><span class="line">功能：将ch转换为<span class="keyword">unsigned</span> <span class="keyword">char</span>后写入stream指定的文件中</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：从stream指定的文件中读取一个字符</span><br></pre></td></tr></table></figure><p>在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，<strong>这种以EOF作为文件结束标志的文件，必须是文本文件</strong>。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。<code>#define EOF    (-1)</code></p><p>当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。<strong>feof函数既可用以判断二进制文件又可用以判断文本文件</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：检测是否读取到了文件结尾。**判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)**。</span><br></pre></td></tr></table></figure><ul><li>按照行读写文件fgets、fputs</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, FILE * stream)</span></span>;</span><br><span class="line">功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 <span class="string">'\0'</span>  不写入文件。 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> * str, <span class="keyword">int</span> size, FILE * stream)</span></span>;</span><br><span class="line">功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - <span class="number">1</span>个字符为止，最后会自动加上字符 <span class="string">'\0'</span> 作为字符串结束。</span><br></pre></td></tr></table></figure><ul><li>按照格式化文件fprintf、fscanf</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</span><br></pre></td></tr></table></figure><ul><li>按照块读写文件fread、fwrite</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式给文件写入内容</span><br><span class="line">参数：</span><br><span class="line">ptr：准备写入文件数据的地址</span><br><span class="line">size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定写入文件内容的块数据大小</span><br><span class="line">nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功写入文件数据的块数目，此值和nmemb相等</span><br><span class="line">失败：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式从文件中读取内容</span><br></pre></td></tr></table></figure><h3 id="7-3-文件的随机读写"><a href="#7-3-文件的随机读写" class="headerlink" title="7.3 文件的随机读写"></a>7.3 文件的随机读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line">功能：移动文件流（文件光标）的读写位置。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line">whence：其取值如下：</span><br><span class="line">SEEK_SET：从文件开头移动offset个字节</span><br><span class="line">SEEK_CUR：从当前位置移动offset个字节</span><br><span class="line">SEEK_END：从文件末尾移动offset个字节</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">功能：获取文件流（文件光标）的读写位置。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：当前文件流（文件光标）的读写位置</span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">功能：把文件流（文件光标）的读写位置移动到文件开头。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">无返回值</span><br></pre></td></tr></table></figure><h3 id="7-4-获取文件状态"><a href="#7-4-获取文件状态" class="headerlink" title="7.4 获取文件状态"></a>7.4 获取文件状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line">功能：获取文件状态信息</span><br><span class="line">参数：</span><br><span class="line">path：文件名</span><br><span class="line">buf：保存文件信息的结构体</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="keyword">dev_t</span>         st_dev;         <span class="comment">//文件的设备编号</span></span><br><span class="line"><span class="keyword">ino_t</span>         st_ino;          <span class="comment">//节点</span></span><br><span class="line"><span class="keyword">mode_t</span>        st_mode;   <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line"><span class="keyword">nlink_t</span>       st_nlink;     <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line"><span class="keyword">uid_t</span>         st_uid;         <span class="comment">//用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span>         st_gid;         <span class="comment">//组ID</span></span><br><span class="line"><span class="keyword">dev_t</span>         st_rdev;      <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line"><span class="keyword">off_t</span>         st_size;        <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;   <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks;    <span class="comment">//块数</span></span><br><span class="line"><span class="keyword">time_t</span>        st_atime;     <span class="comment">//最后一次访问时间</span></span><br><span class="line"><span class="keyword">time_t</span>        st_mtime;    <span class="comment">//最后一次修改时间</span></span><br><span class="line"><span class="keyword">time_t</span>        st_ctime;     <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">stat(args[<span class="number">1</span>], &amp;st);</span><br><span class="line"><span class="keyword">int</span> size = st.st_size;<span class="comment">//得到结构体中的成员变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, size);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-删除文件、重命名文件名"><a href="#7-5-删除文件、重命名文件名" class="headerlink" title="7.5 删除文件、重命名文件名"></a>7.5 删除文件、重命名文件名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line">功能：删除文件</span><br><span class="line">参数：</span><br><span class="line">pathname：文件名</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line">功能：把oldpath的文件名改为newpath</span><br><span class="line">参数：</span><br><span class="line">oldpath：旧文件名</span><br><span class="line">newpath：新文件名</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="7-6-文件缓冲区"><a href="#7-6-文件缓冲区" class="headerlink" title="7.6 文件缓冲区"></a>7.6 文件缓冲区</h3><p>ANSI C标准采用“缓冲文件系统”处理数据文件。</p><p>所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。</p><p>如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。</p><p>磁盘文件的存取：</p><img src="/images/imageProgramC/磁盘文件的读取.png"><ul><li><p>磁盘文件，一般保存在硬盘、U盘等掉电不丢失的磁盘设备中，在需要时调入内存</p></li><li><p>在内存中对文件进行编辑处理后，保存到磁盘中</p></li><li><p>程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率</p></li></ul><p>更新缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">功能：更新缓冲区，让缓冲区的数据立马写到文件中。</span><br><span class="line">参数：</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-语言基础&quot;&gt;&lt;a href=&quot;#C-语言基础&quot; class=&quot;headerlink&quot; title=&quot;C 语言基础&quot;&gt;&lt;/a&gt;C 语言基础&lt;/h1&gt;&lt;h2 id=&quot;一、C-语言概述&quot;&gt;&lt;a href=&quot;#一、C-语言概述&quot; class=&quot;headerlink&quot; title=&quot;一、C 语言概述&quot;&gt;&lt;/a&gt;一、C 语言概述&lt;/h2&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Program-C 交叉编译</title>
    <link href="http://miaopei.github.io/2016/05/05/Program-C/compile/"/>
    <id>http://miaopei.github.io/2016/05/05/Program-C/compile/</id>
    <published>2016-05-05T02:14:50.000Z</published>
    <updated>2019-06-14T06:11:29.888Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><img src="/images/imageProgramC/03_C语言概述.png"><h1 id="建立ARM交叉编译环境arm-none-linux-gnueabi-gcc"><a href="#建立ARM交叉编译环境arm-none-linux-gnueabi-gcc" class="headerlink" title="建立ARM交叉编译环境arm-none-linux-gnueabi-gcc"></a>建立ARM交叉编译环境arm-none-linux-gnueabi-gcc</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> add2line：将你要找的地址转成文件和行号，它要使用 debug 信息</span></span><br><span class="line">arm-none-linux-gnueabi-addr2line </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ar：产生、修改和解开一个存档文件</span></span><br><span class="line">arm-none-linux-gnueabi-ar </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> as：gnu的汇编器</span></span><br><span class="line">arm-none-linux-gnueabi-as   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ld：gnu 的连接器</span></span><br><span class="line">arm-none-linux-gnueabi-ld </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gprof：gnu 汇编器预编译器</span></span><br><span class="line">arm-none-linux-gnueabi-gprof </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nm：列出目标文件的符号和对应的地址</span></span><br><span class="line">arm-none-linux-gnueabi-nm      </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> objdump：显示目标文件的信息</span></span><br><span class="line">arm-none-linux-gnueabi-objdump </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> readelf：显示 elf 格式的目标文件的信息</span></span><br><span class="line">arm-none-linux-gnueabi-readelf </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> strings：打印出目标文件中可以打印的字符串，有个默认的长度，为4</span></span><br><span class="line">arm-none-linux-gnueabi-strings </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> c++filt：C++ 和 java 中有一种重载函数，所用的重载函数最后会被编译转化成汇编的标，c++filt 就是实现这种反向的转化，根据标号得到函数名</span></span><br><span class="line">arm-none-linux-gnueabi-c++filt </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> objcopy：将某种格式的目标文件转化成另外格式的目标文件</span></span><br><span class="line">arm-none-linux-gnueabi-objcopy </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ranlib：为一个存档文件产生一个索引，并将这个索引存入存档文件中</span></span><br><span class="line">arm-none-linux-gnueabi-ranlib  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> size：显示目标文件各个节的大小和目标文件的大小</span></span><br><span class="line">arm-none-linux-gnueabi-size    </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> strip：剥掉目标文件的所有的符号信息</span></span><br><span class="line">arm-none-linux-gnueabi-strip</span><br></pre></td></tr></table></figure><h1 id="C调用C-库和C-调用C库的方法"><a href="#C调用C-库和C-调用C库的方法" class="headerlink" title="C调用C++库和C++调用C库的方法"></a>C调用C++库和C++调用C库的方法</h1><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW9zdW5yaXNlL2FydGljbGUvZGV0YWlscy84MTE3Njg4MA==" title="https://blog.csdn.net/shaosunrise/article/details/81176880">C调用C++库和C++调用C库的方法<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="C-调用C的静态库-动态库"><a href="#C-调用C的静态库-动态库" class="headerlink" title="C++调用C的静态库/动态库"></a>C++调用C的静态库/动态库</h2><p>C++ 调用 C 的函数比较简单，直接使用 <code>extern &quot;C&quot; {}</code> 告诉编译器用 C 的规则去调用 C 函数就可以了。</p><p><strong>CAdd.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>CAdd.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CAdd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"from C function.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译libCAdd.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c CAdd.c           # 生成CAdd.o</span><br><span class="line">ar -r libCAdd.a CAdd.o  # 归档生成libCAdd.a</span><br></pre></td></tr></table></figure><p><strong>编译动态库 libCAdd.so</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libCAdd.so CAdd.c</span><br></pre></td></tr></table></figure><p><strong>cppmain.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CAdd.h"</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = cadd(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1+2 = %d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译main</strong></p><p><code>-l</code> 指定库名称，优先链接so动态库，没有动态库再链接 <code>.a</code> 静态库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o cppmain cppmain.cpp -L. -lCAdd</span><br></pre></td></tr></table></figure><p><strong>运行</strong> </p><p>如果链接的是静态库就可以直接运行了，如果链接的是动态库可能会提示 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cppmain: error while loading shared libraries: libCAdd.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>是因为Linux系统程序和Windows不一样，Linux系统只会从系统环境变量指定的路径加载动态库，可以把生成的动态库放到系统目录，或者执行 <code>export LD_LIBRARY_PATH=./</code> 设置当前路径为系统链接库目录就可以了。</p><p>*<em>注释 *</em></p><p>这里是在 include 头文件的外面包裹了 <code>extern &quot;C&quot; { }</code>，是告诉编译器以 C 语言的命名方式去加载这个符号。还有一种比较常见的方式是在头文件中进行编译声明，如下所示，这样的话，无论 C 还是 C++ 直接正常include就可以使用了。</p><p><strong>CAdd.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C-调用-C-的静态库"><a href="#C-调用-C-的静态库" class="headerlink" title="C 调用 C++ 的静态库"></a>C 调用 C++ 的静态库</h2><p>C 语言没法直接调用 C++ 的函数，<strong>但可以使用包裹函数来实现</strong>。C++ 文件 <code>.cpp</code> 中可以调用 C 和 C++ 的函数，但是 C 代码 <code>.c</code> 只能调用 C 的函数，所以可以用包裹函数去包裹C ++ 函数，然后把这个包裹函数以 C 的规则进行编译，这样 C 就可以调用这个包裹函数了。</p><p><strong>CppAdd.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>CppAdd.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAdd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from C++ function.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译静态库 libCppAdd.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c CppAdd.cpp</span><br><span class="line">ar -r libCppAdd.a CppAdd.o</span><br></pre></td></tr></table></figure><p><strong>CppAddWrapper.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppaddwrapper</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>CppAddWrapper.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAddWrapper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAdd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppaddwrapper</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from wrapper.\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = cppadd(x, y);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译 wrapper 静态库 libCppAddWrapper.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c CppAddWrapper.cpp</span><br><span class="line">ar -r libCppAddWrapper.a CppAddWrapper.o</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAddWrapper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = cppaddwrapper(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"1+2 = %d\n"</span>, sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译 main，同时指定 libCppAdd.a 和 libCppAddWrapper.a。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -L. -lCppAddWrapper -lCppAdd</span><br></pre></td></tr></table></figure><p>或者把 libCppAdd.a 合并到 libCppAddWrapper.a 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ar -x libCppAdd.a         # 提取CppAdd.o</span><br><span class="line">ar -x libCppAddWrapper.a  # 提取CppAddWrapper.o</span><br><span class="line">ar -r libCppAddWrapper.a CppAdd.o CppAddWrapper.o # 打包libCppAddWrapper.a</span><br><span class="line">gcc -o main main.c -L. -lCppAddWrapper  # 只需要连接libCppAddWrapper.a即可</span><br></pre></td></tr></table></figure><p>如果是 C 调用 C++ 的 so 动态库的话，类似于调用静态库的方法应该也是有效的，太麻烦我没试过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>C/C++ 函数符号的区别</strong></p><p>C++ 可以兼容 C 的语法，C/C++ 主要的区别是编译函数符号规则不一样，C 语言代码编译后的函数名还是原来函数名，C++ 代码编译后的函数名带有参数信息。 </p><p>做个测试来检验一下。一个简单的函数，分别用 C 和 C++ 进行编译。 </p><p><strong>hello1.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hello2.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello1.c     # 生成hello1.o</span><br><span class="line">g++ -c hello1.cpp   # 生成hello2.o</span><br></pre></td></tr></table></figure><p><strong>查看符号表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nm hello1.o</span></span><br><span class="line">0000000000000000 T test</span><br><span class="line"><span class="meta">$</span><span class="bash"> nm hello2.o</span></span><br><span class="line">0000000000000000 T _Z4testiPc</span><br></pre></td></tr></table></figure><p>从上面信息可以看出，C 语言编译后的函数符号还是原函数名，而 C++ 编译后的函数符号由test变成了 <code>_Z4testiPc</code>，从这个符号名字可以看出 test 前面有个数字 4 应该是函数名长度，test 后面 <code>iPc</code> 应该就是函数的参数签名。C++ 之所以这样规定编译后的函数符号是因为对面对象的 C++ 具有函数重载功能，以此来区分不同的函数。</p><p><strong>.so 动态库、.a 静态库和 .o 中间文件的关系</strong></p><p>程序的运行都要经过<strong>编译和链接</strong>两个步骤。假如有文件 <code>add.c</code>，可以使用命令 <code>gcc -c add.c</code> 进行编译，生成 add.o 中间文件，使用命令 <code>ar -r libadd.a add.o</code> 可以生成 <code>libadd.a</code> 静态库文件。静态库文件其实就是对 <code>.o</code> 中间文件进行的封装，使用 <code>nm libadd.a</code> 命令可以查看其中封装的中间文件以及函数符号。 </p><p>链接静态库就是链接静态库中的 <code>.o</code> 文件，这和直接编译多个文件再链接成可执行文件一样。 </p><p>动态链接库是程序执行的时候直接调用的“插件”，使用命令 <code>gcc -shared -o libadd.so add.c</code> 生成 so 动态库。动态库链接的时候可以像静态库一样链接，告诉编译器函数的定义在这个静态库中（避免找不到函数定义的错误），只是不把这个 so 打包到可执行文件中。如果没有头文件的话，可以使用 <code>dlopen/dlsum</code> 函数手动去加载相应的动态库。详细做法参考上一篇文章《<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW9zdW5yaXNlL2FydGljbGUvZGV0YWlscy84MTE2MTA2NA==" title="https://blog.csdn.net/shaosunrise/article/details/81161064">C语言调用so动态库的两种方式<i class="fa fa-external-link"></i></span>》。</p><h1 id="ar-nm-命令的详细解释"><a href="#ar-nm-命令的详细解释" class="headerlink" title="ar nm 命令的详细解释"></a>ar nm 命令的详细解释</h1><p>功能说明：建立或修改备存文件，或是从备存文件中抽取文件。</p><p>语　　法：<code>ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件]</code></p><p>补充说明：ar 可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p><p>参　　数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指令参数</span></span><br><span class="line">　-d 　删除备存文件中的成员文件。</span><br><span class="line">　-m 　变更成员文件在备存文件中的次序。</span><br><span class="line">　-p 　显示备存文件中的成员文件内容。</span><br><span class="line">　-q 　将问家附加在备存文件末端。</span><br><span class="line">　-r 　将文件插入备存文件中。</span><br><span class="line">　-t 　显示备存文件中所包含的文件。</span><br><span class="line">　-x 　自备存文件中取出成员文件。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项参数</span></span><br><span class="line">　a&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之后。</span><br><span class="line">　b&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</span><br><span class="line">　c 　建立备存文件。</span><br><span class="line">　f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。</span><br><span class="line">　i&lt;成员文件&gt; 　将问家插入备存文件中指定的成员文件之前。</span><br><span class="line">　o 　保留备存文件中文件的日期。</span><br><span class="line">　s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。</span><br><span class="line">　S 　不产生符号表。</span><br><span class="line">　u 　只将日期较新文件插入备存文件中。</span><br><span class="line">　v 　程序执行时显示详细的信息。</span><br><span class="line">　V 　显示版本信息。</span><br></pre></td></tr></table></figure><h2 id="ar基本用法"><a href="#ar基本用法" class="headerlink" title="ar基本用法"></a>ar基本用法</h2><p>ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。</p><p>下面是ar命令的格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ar [-]&#123;dmpqrtx&#125;[abcfilNoPsSuvV][membername] [count] archive files...</span></span><br></pre></td></tr></table></figure><p>例如我们可以用<strong>ar rv libtest.a hello.o hello1.o</strong>来生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-‘字符，也可以没有。下面我们来看看命令的操作选项<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q9JUU1JTkyJThDJUU0JUJCJUJCJnRuPTI0MDA0NDY5X29lbV9kZyZyc3ZfZGw9Z2hfcGxfc2xfY3Nk" title="https://www.baidu.com/s?wd=%E5%92%8C%E4%BB%BB&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">和任<i class="fa fa-external-link"></i></span>选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。</p><p>{dmpqrtx} 中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：</p><ul><li>d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。</li><li>m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用’a’，’b’，或’I’任选项移动到指定的位置。</li><li>p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。</li><li>q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。’a’，’b’，或’I’任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用’ar s’或ranlib来更新库的符号表索引。</li><li>r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。</li><li>t：显示库的模块表清单。一般只显示模块名。</li><li>x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。</li></ul><p>　　下面在看看可与操作选项结合使用的任选项：</p><ul><li>a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。</li><li>b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。</li><li>c：创建一个库。不管库是否存在，都将创建。</li><li>f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。</li><li>i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。</li><li>l：暂未使用</li><li>N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。</li><li>o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。</li><li>P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。</li><li>s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。</li><li>S：不创建目标文件索引，这在创建较大的库时能加快时间。</li><li>u：一般说来，命令ar r…插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。</li><li>v：该选项用来显示执行操作选项的附加信息。</li><li>V：显示ar的版本。</li></ul><h2 id="nm基本用法命令"><a href="#nm基本用法命令" class="headerlink" title="nm基本用法命令"></a>nm基本用法命令</h2><p>nm用来列出目标文件的符号清单。下面是nm命令的格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [-a|--debug-syms][-g|--extern-only] [-B][-C|--demangle] [-D|--dynamic][-s|--print-armap][-o|--print-file-name][-n|--numeric-sort][-p|--no-sort][-r|--reverse-sort] [--size-sort][-u|--undefined-only] [-l|--line-numbers][--help][--version][-t radix|--radix=radix][-P|--portability][-f format|--format=format][--target=bfdname][objfile...]</span><br></pre></td></tr></table></figure><p>如果没有为 nm 命令指出目标文件，则 nm 假定目标文件是a.out。下面列出该命令的任选项，大部分支持”-“开头的短格式和”—“开头的长格式。</p><ul><li><p>-A、-o或–print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。</p><p>例如nm libtest.a的输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CPThread.o:</span><br><span class="line">00000068 T Main__8CPThreadPv</span><br><span class="line">00000038 T Start__8CPThread</span><br><span class="line">00000014 T _._8CPThread</span><br><span class="line">00000000 T __8CPThread</span><br><span class="line">00000000 ? __FRAME_BEGIN__</span><br><span class="line">.......................................</span><br><span class="line"><span class="meta">#</span><span class="bash"> 则nm -A 的输出如下：</span></span><br><span class="line">libtest.a:CPThread.o:00000068 T Main__8CPThreadPv</span><br><span class="line">libtest.a:CPThread.o:00000038 T Start__8CPThread</span><br><span class="line">libtest.a:CPThread.o:00000014 T _._8CPThread</span><br><span class="line">libtest.a:CPThread.o:00000000 T __8CPThread</span><br><span class="line">libtest.a:CPThread.o:00000000 ? __FRAME_BEGIN__</span><br><span class="line">..................................................................</span><br></pre></td></tr></table></figure></li><li><p>-a或–debug-syms：显示调试符号。</p></li><li><p>-B：等同于–format=bsd，用来兼容MIPS的nm。</p></li><li><p>-C或–demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</p></li><li><p>-D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</p></li><li><p>-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。</p></li><li><p>-g或–extern-only：仅显示外部符号。</p></li><li><p>-n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。</p></li><li><p>-p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。</p></li><li><p>-P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。</p></li><li><p>-s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。</p></li><li><p>-r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。</p></li><li><p>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。</p></li><li><p>-t radix或–radix=radix：使用radix进制显示符号值。radix只能为”d”表示十进制、”o”表示八进制或”x”表示十六进制。</p></li><li><p>–target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。</p></li><li><p>-u或–undefined-only：仅显示没有定义的符号(那些外部符号)。</p></li><li><p>-l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。</p></li><li><p>-V或–version：显示nm的版本号。</p></li><li><p>–help：显示nm的任选项。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;img src=&quot;/images/imageProgramC/03_C语言概述.png&quot;&gt;

&lt;h1 id=&quot;建立ARM交叉编译环境arm-none-linux-gnueabi-gcc&quot;&gt;&lt;a href=&quot;#建立ARM交叉编译环境arm-n
      
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程</title>
    <link href="http://miaopei.github.io/2016/05/01/Program-C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://miaopei.github.io/2016/05/01/Program-C/Linux系统编程基础/</id>
    <published>2016-05-01T02:14:50.000Z</published>
    <updated>2019-06-14T06:12:24.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-Note"><a href="#Linux-Note" class="headerlink" title="Linux Note"></a>Linux Note</h1><blockquote><h3 id="C-语言之解析局部变量返回"><a href="#C-语言之解析局部变量返回" class="headerlink" title="C 语言之解析局部变量返回"></a>C 语言之解析局部变量返回</h3><p>一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。</p><p>准确的来说，<strong>函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)</strong>。</p></blockquote><a id="more"></a><h2 id="1-Linux-基础命令"><a href="#1-Linux-基础命令" class="headerlink" title="1. Linux 基础命令"></a>1. Linux 基础命令</h2><blockquote><p><strong>stat命令</strong>用于显示文件的状态信息。stat命令的输出信息比 <span class="exturl" data-url="aHR0cDovL21hbi5saW51eGRlLm5ldC9scw==" title="http://man.linuxde.net/ls">ls<i class="fa fa-external-link"></i></span> 命令的输出信息要更详细。</p></blockquote><h3 id="1-0-创建用户"><a href="#1-0-创建用户" class="headerlink" title="1.0 创建用户"></a>1.0 创建用户</h3><p><strong>创建用户命令两条</strong>：</p><ul><li><p>adduser</p></li><li><p>useradd</p></li></ul><p><strong>用户删除命令</strong>：</p><ul><li>userdel</li></ul><p><strong>两个用户创建命令之间的区别</strong>：</p><ul><li><p>adduser： 会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。</p></li><li><p>useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 adduser</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adduser apple</span></span><br><span class="line">正在添加用户"apple"...</span><br><span class="line">正在添加新组"apple" (1007)...</span><br><span class="line">正在添加新用户"apple" (1007) 到组"apple"...</span><br><span class="line">创建主目录"/home/apple"...</span><br><span class="line">正在从"/etc/skel"复制文件...</span><br><span class="line">输入新的 UNIX 密码： </span><br><span class="line">重新输入新的 UNIX 密码： </span><br><span class="line">passwd：已成功更新密码</span><br><span class="line">正在改变 apple 的用户信息</span><br><span class="line">请输入新值，或直接敲回车键以使用默认值</span><br><span class="line">        全名 []: </span><br><span class="line">        房间号码 []: </span><br><span class="line">        工作电话 []: </span><br><span class="line">        家庭电话 []: </span><br><span class="line">        其它 []: </span><br><span class="line">这些信息是否正确？ [Y/n] y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样在创建用户名时，就创建了用户的主目录以及密码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> adduser在创建用户时会主动调用  /etc/adduser.conf；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在创建用户主目录时默认在/home下，而且创建为 /home/用户名   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果主目录已经存在，就不再创建，但是此主目录虽然作为新用户的主目录，而且默认登录时会进入这个目录下，但是这个目录并不是属于新用户，当使用userdel删除新用户时，并不会删除这个主目录，因为这个主目录在创建前已经存在且并不属于这个用户。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为用户指定shell版本为：/bin/bash</span></span><br></pre></td></tr></table></figure><p>因此 adduser 常用参数选项为：</p><ul><li><p><code>--home</code>：  指定创建主目录的路径，默认是在/home目录下创建用户名同名的目录，这里可以指定；如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。</p></li><li><p><code>--quiet</code>：  即只打印警告和错误信息，忽略其他信息。</p></li><li><p><code>--debug</code>：  定位错误信息。</p></li><li><p><code>--conf</code>：   在创建用户时使用指定的configuration文件。</p></li><li><p><code>--force-badname</code>：  默认在创建用户时会进行/etc/adduser.conf中的正则表达式检查用户名是否合法，如果想使用弱检查，则使用这个选项，如果不想检查，可以将/etc/adduser.conf中相关选项屏蔽。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 useradd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意： 在使用useradd命令创建新用户时，不会为用户创建主目录，不会为用户指定shell版本，不会为用户创建密码。</span></span><br></pre></td></tr></table></figure><p>为用户指定参数的 useradd 命令，常用命令行选项：</p><ul><li><p><code>-d</code>：   指定用户的主目录</p></li><li><p><code>-m</code>：   如果存在不再创建，但是此目录并不属于新创建用户；如果主目录不存在，则强制创建； -m和-d一块使用。</p></li><li><p><code>-s</code>：   指定用户登录时的shell版本</p></li><li><p><code>-M</code>：   不创建主目录</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解释：   </span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -d   “/home/tt<span class="string">" ：就是指定/home/tt为主目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -m   就是如果/home/tt不存在就强制创建</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -s   就是指定shell版本           </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo  useradd  -d  <span class="string">"/home/tt"</span>  -m   -s <span class="string">"/bin/bash"</span>   tt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 tt 密码：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo passwd tt</span></span><br></pre></td></tr></table></figure><p><strong>删除用户命令</strong></p><ul><li><p>userdel</p></li><li><p>只删除用户：</p><ul><li><code>sudo   userdel   用户名</code></li></ul></li><li><p>连同用户主目录一块删除：</p><ul><li><code>sudo  userdel   -r   用户名</code></li></ul></li></ul><p><strong>相关文件</strong>：</p><ul><li>/etc/passwd - 使 用 者 帐 号 资 讯，可以查看用户信息</li><li>/etc/shadow - 使 用 者 帐 号 资 讯 加 密</li><li>/etc/group - 群 组 资 讯</li><li>/etc/default/useradd - 定 义 资 讯</li><li>/etc/login.defs - 系 统 广 义 设 定</li><li>/etc/skel - 内 含 定 义 档 的 目 录</li></ul><p><strong>为组用户增加 root 权限</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改 /etc/sudoers 文件，找到下面一行，在 root 下面添加一行，如下所示：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line">tommy   ALL=(ALL)     ALL</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改完毕，现在可以用 tommy 帐号登录，然后用命令 sudo – ，即可获得 root 权限进行操作。</span></span><br></pre></td></tr></table></figure><h3 id="1-1-ln-软硬链接"><a href="#1-1-ln-软硬链接" class="headerlink" title="1.1 ln 软硬链接"></a>1.1 ln 软硬链接</h3><p><strong>硬链接</strong></p><p>硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。可以用: ln 命令来建立硬链接。</p><p>尽管硬链接节省空间，也是Linux系统整合文件系统的传统方式，但是存在一下不足之处：</p><ul><li><p>（1）不可以在不同文件系统的文件间建立链接</p></li><li><p>（2）只有超级用户才可以为目录创建硬链接。</p></li></ul><p><strong>软链接（符号链接）</strong></p><p>软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。<br>建立软链接，只要在 ln 后面加上选项  –s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ln -s abc cde <span class="comment"># 建立 abc 的软连接</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln abc cde <span class="comment"># 建立 abc 的硬连接，</span></span></span><br></pre></td></tr></table></figure><p><strong>删除链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf symbolic_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> unlink symbolic_name</span></span><br></pre></td></tr></table></figure><h3 id="1-2-find-grep-xargs"><a href="#1-2-find-grep-xargs" class="headerlink" title="1.2 find grep xargs"></a>1.2 find grep xargs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前目录及子目录下所有文件和文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在/home目录下查找以.txt结尾的文件名 但忽略大小写</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /home -iname <span class="string">"*.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . \( -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span> \)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 匹配文件路径或者文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /usr/ -path <span class="string">"*local*"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于正则表达式匹配文件路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -regex <span class="string">".*\(\.txt\|\.pdf\)$"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，但忽略大小写</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -iregex <span class="string">".*\(\.txt\|\.pdf\)$"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出/home下 不是 以 .txt 结尾的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /home ! -name <span class="string">"*.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件类型进行搜索</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 类型参数列表：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  f 普通文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  l 符号连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  d 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  c 字符设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  b 块设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  s 套接字</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  p Fifo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> 类型参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于目录深度搜索 向下最大深度限制为3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -maxdepth 3 -<span class="built_in">type</span> f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索出深度距离当前目录至少2个子目录的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -mindepth 2 -<span class="built_in">type</span> f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件时间戳进行搜索</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UNIX/Linux文件系统每个文件都有三种时间戳：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索最近七天内被访问过的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -atime -7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索恰好在七天前被访问过的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -atime 7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索超过七天内被访问过的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -atime +7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索访问时间超过10分钟的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -amin +10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出比 file.log 修改时间更长的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -newer file.log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件大小进行匹配</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件大小单元：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  b —— 块（512字节）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  c —— 字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  w —— 字（2字节）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  k —— 千字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  M —— 兆字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  G —— 吉字节</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size 文件大小单元</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索大于10KB的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size +10k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索小于10KB的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size -10k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索等于10KB的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size 10k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除匹配文件 删除当前目录下所有.txt文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -delete</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件权限/所有权进行匹配 当前目录下搜索出权限为777的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -perm 777</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录下权限不是644的php文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.php"</span> ! -perm 644</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录用户tom拥有的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -user tom</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录用户组sunk拥有的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -group sunk</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 借助-<span class="built_in">exec</span>选项与其他命令结合使用 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录下所有root的文件，并把所有权更改为用户tom</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;&#125; 用于与 -<span class="built_in">exec</span> 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find .-<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> chown tom &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出自己家目录下所有的.txt文件并删除</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ok 和 -<span class="built_in">exec</span> 行为一样，不过它会给出提示，是否执行相应的操作。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find <span class="variable">$HOME</span>/. -name <span class="string">"*.txt"</span> -ok rm &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> cat &#123;&#125; \;&gt; all.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将30天前的.<span class="built_in">log</span>文件移动到old目录中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -mtime +30 -name <span class="string">"*.log"</span> -<span class="built_in">exec</span> cp &#123;&#125; old \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录下所有.txt文件并以 “File:文件名” 的形式打印出来</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> <span class="built_in">printf</span> <span class="string">"File: %s\n"</span> &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为单行命令中 -<span class="built_in">exec</span> 参数中无法使用多个命令，以下方法可以实现在 -<span class="built_in">exec</span> 之后接受多条命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -<span class="built_in">exec</span> ./text.sh &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索但跳出指定的目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -path <span class="string">"./sk"</span> -prune -o -name <span class="string">"*.txt"</span> -<span class="built_in">print</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> find其他技巧收集</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要列出所有长度为零的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -empty</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -<span class="built_in">exec</span> 接收 find 传过来的所有内容，容易造成溢出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xargs find 的好伴侣，xargs 将 find 命令查找的结果分成若干模块输出给后面的指令</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> grep 内容过滤</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep match_pattern file_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"match_pattern"</span> file_name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出除之外的所有行 -v 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -v <span class="string">"match_pattern"</span> file_name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 标记匹配颜色 --color=auto 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"match_pattern"</span> file_name --color=auto</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用正则表达式 -E 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -E <span class="string">"[1-9]+"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> egrep <span class="string">"[1-9]+"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只输出文件中匹配到的部分 -o 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a <span class="built_in">test</span> line. | grep -o -E <span class="string">"[a-z]+\."</span></span></span><br><span class="line">line.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a <span class="built_in">test</span> line. | egrep -o <span class="string">"[a-z]+\."</span></span></span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计文件或者文本中包含匹配字符串的行数 -c 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -c <span class="string">"text"</span> file_name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出包含匹配字符串的行数 -n 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"text"</span> -n file_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file_name | grep <span class="string">"text"</span> -n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索多个文件并查找匹配文本在哪些文件中：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -l <span class="string">"text"</span> file1 file2 file3...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在多级目录中对文本进行递归搜索：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"text"</span> . -r -n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 忽略匹配样式中的字符大小写：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span> | grep -i <span class="string">"HELLO"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项 -e 制动多个匹配样式：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a text line | grep -e <span class="string">"is"</span> -e <span class="string">"line"</span> -o</span></span><br><span class="line">is</span><br><span class="line">line</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。</span></span><br><span class="line">cat patfile</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> aaa bbb ccc ddd eee | grep -f patfile -o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在grep搜索结果中包括或者排除指定文件：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只在目录中所有的.php和.html文件中递归搜索字符<span class="string">"main()"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"main()"</span> . -r --include *.&#123;php,html&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在搜索结果中排除所有README文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"main()"</span> . -r --exclude <span class="string">"README"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在搜索结果中排除filelist文件列表里的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"main()"</span> . -r --exclude-from filelist</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用0值字节后缀的grep与xargs：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"aaa"</span> &gt; file1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"bbb"</span> &gt; file2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"aaa"</span> &gt; file3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"aaa"</span> file* -lZ | xargs -0 rm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后会删除 file1 和 file3，grep 输出用 -Z 选项来指定以 0 值字节作为终结符文件名（\0），xargs -0 读取输入并用 0 值字节终结符分隔文件名，然后删除匹配文件，-Z 通常和 -l 结合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> grep静默输出：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -q <span class="string">"test"</span> filename</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印出匹配文本之前或者之后的行：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配某个结果 之后的3行，使用 -A 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">"5"</span> -A 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配某个结果 之前的3行，使用 -B 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">"5"</span> -B 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配某个结果的 前三行和后三行，使用 -C 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">"5"</span> -C 3</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> xargs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数：</span></span><br><span class="line">-a file 从文件中读入作为sdtin</span><br><span class="line">-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</span><br><span class="line">-p 当每次执行一个argument的时候询问一次用户。</span><br><span class="line">-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</span><br><span class="line">-t 表示先打印命令，然后再执行。</span><br><span class="line">-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 &#123;&#125;，可以用 &#123;&#125; 代替。</span><br><span class="line">-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</span><br><span class="line">-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</span><br><span class="line">-L num 从标准输入一次读取 num 行送给 command 命令。</span><br><span class="line">-l 同 -L。</span><br><span class="line">-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</span><br><span class="line">-x exit的意思，主要是配合-s使用。。</span><br><span class="line">-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</span><br></pre></td></tr></table></figure><h3 id="1-3-VIM"><a href="#1-3-VIM" class="headerlink" title="1.3 VIM"></a>1.3 VIM</h3><p>设置 ~/.bashrc</p><p>添加 set -o vi     – 可以直接使用 vim 的各种快捷键</p><p>VIM 快捷键：</p><img src="/images/imageProgramC/vim.gif"><h3 id="1-4-GCC"><a href="#1-4-GCC" class="headerlink" title="1.4 GCC"></a>1.4 GCC</h3><p>gcc 工作流程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 预处理 头文件展开 宏替换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -E hello.c</span></span><br><span class="line">hello.i</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成汇编代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -S hello.i</span></span><br><span class="line">hello.s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将汇编编译成二进制文件 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hell0.s</span></span><br><span class="line">hello.o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc hello.o</span></span><br><span class="line">a.out</span><br></pre></td></tr></table></figure><p>gcc 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定编译输出的名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 -Wall 参数启用所有警告</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -E 参数只产生预处理输出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -E main.c &gt; main.i</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -S 参数只产生汇编代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -S main.c &gt; main.s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -C 参数只产生编译的代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -C main.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面的代码产生main.o, 包含机器级别的代码或者编译的代码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用-save-temps参数产生所有的中间步骤的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -save-temps main.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">a.out  main.c  main.i  main.o  main.s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -l 参数链接共享库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc  -Wall main.c -o main -lCPPfile</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -fPIC 产生位置无关的代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当产生共享库的时候，应该创建位置无关的代码，这会让共享库使用任意的地址而不是固定的地址，要实现这个功能，需要使用-fPIC参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面的例子产生libCfile.so动态库。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c -Wall -Werror -fPIC Cfile.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -o libCfile.so Cfile.o</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 产生共享库的时候使用了-fPIC 参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意 -shared 产生共享库。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -V 打印所有的执行命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -v main.c -o main</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/4.6/lto-wrapper</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -D 参数可以使用编译时的宏</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -D MY_MACRO main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -Werror 将警告升级为错误</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -Werror main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 @ 参数从文件中读取参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc参数可以从文件中读取，通过@后跟文件名的方式提供， 多个参数可以使用空格区隔。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat opt_file </span></span><br><span class="line">-Wall -omain</span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c @opt_file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用参数 -I 指定头文件的文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -I/home/codeman/include input-file.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I 取消前一个参数功能，一般用在 -Idir 之后。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用参数-std指定支持的c++/c的标准</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -std=c++11 hello-world.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -static 生成静态链接的文件 静态编译文件(把动态库的函数和其它依赖都编译进最终文件)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -static -o main -lpthread</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相反的使用 -shared 使用动态库链接。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -g 用于 gdb 调试</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -static -o main -g</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -lstdc++ 指定 gcc 以 c++ 方式编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.cpp -lstdc++ -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -O 优化选项， 1-3 越高优先级越高</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.cpp -lstdc++ -o main -O1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -M 生成文件关联的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -M main.c</span></span><br><span class="line">main.o: main.c /usr/include/stdc-predef.h /usr/include/stdio.h \</span><br><span class="line"> /usr/include/features.h /usr/include/sys/cdefs.h \</span><br><span class="line"> /usr/include/bits/wordsize.h /usr/include/gnu/stubs.h \</span><br><span class="line"> /usr/include/gnu/stubs-64.h \</span><br><span class="line"> /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h \</span><br><span class="line"> /usr/include/bits/types.h /usr/include/bits/typesizes.h \</span><br><span class="line"> /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \</span><br><span class="line"> /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdarg.h \</span><br><span class="line"> /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h</span><br></pre></td></tr></table></figure><h3 id="1-5-库文件制作"><a href="#1-5-库文件制作" class="headerlink" title="1.5 库文件制作"></a>1.5 库文件制作</h3><p><strong>静态库制作和使用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 步骤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 编译为 .o 文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将 .o 文件打包：ar rcs libmycalc.a file1.0 file2.o ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 将头文件与库一起发布</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看库信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nm libmycalc.a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译时 需要加静态库名（记得路径），-I 包含头文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -o app -I include/ -L lib/ -lmycalc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 优点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行快</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 发布应用时不需要发布库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缺点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行程序体积比较大</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 库变更时需要重新编译应用</span></span><br></pre></td></tr></table></figure><p><strong>动态库制作和使用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 步骤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 编译与位置无关的代码，生成 .o 关键参数 -fPIC</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将 .o 文件打包， 关键参数 -shared</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 将库与头文件一起发布</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -o libcalc.so *.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -L 指定动态库路径 -I 指定库名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -o app -I include/ -L lib/ -lcalc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ldd 查看库依赖</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd libcalc.so</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 优点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行程序体积小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 库变更时，一般不需要重新发布动态库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缺点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行时需要加载动态库，相对而言，比静态库慢</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 发布应用时需要同时发布动态库</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决不能加载动态库的问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 拷贝到 /lib 下。 一般不允许</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将库路径增加到环境变量 LD_LIBRARY_PATH 中，不是特别推荐</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 配置 /etc/ld.so.conf 文件，增加 当前项目库路径，执行 sudo ldconfig -v</span></span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/数据段.png"><h3 id="1-6-Makefile"><a href="#1-6-Makefile" class="headerlink" title="1.6 Makefile"></a>1.6 Makefile</h3><p>makefile 的三要素：</p><ul><li>目标</li><li>依赖</li><li>规则命令</li></ul><p>写法：</p><ul><li>目标：依赖</li><li>tab键 规则命令</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app: main.c add.c sub.c div.c mul.c</span></span><br><span class="line">gcc -o app -I./<span class="keyword">include</span>/ main.c add.c sub.c div.c mul.c</span><br></pre></td></tr></table></figure><p>如果更改其中一个文件，所有的源码都重新编译</p><p>可以考虑编译过程分解，先生成 .o 文件，然后使用 .o 文件编程结果</p><p>规则是递归的，依赖文件如果比目标文件新，则重新生成目标文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ObjFiles=main.o add.o sub.o div.o mul.o</span><br><span class="line">app: $(ObjFiles)</span><br><span class="line">gcc -o app -I./include/ $(ObjFiles)</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">gcc -c main.c -I./include/</span><br><span class="line">add.o: add.c</span><br><span class="line">gcc -c add.c -I./include/</span><br><span class="line">sub.o: sub.c</span><br><span class="line">gcc -c sub.c -I./include/</span><br><span class="line">div.o: div.c</span><br><span class="line">gcc -c div.c -I./include/</span><br><span class="line">mul.o: mul.c</span><br><span class="line">gcc -c mul.c -I./include/</span><br></pre></td></tr></table></figure><p>makefile 的隐含规则：默认处理第一个目标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> get all .c files</span></span><br><span class="line">SrcFiles=$(wildcard *.c)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> all .c files --&gt; .o file</span></span><br><span class="line">ObjFiles=$(patsubst %.c,%.o,$(SrcFiles))</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">echo $(SrcFiles)</span><br><span class="line">echo $(ObjFiles)</span><br></pre></td></tr></table></figure><p>makefile 变量：</p><ul><li>$@    代表目标</li><li>$^    代表全部依赖</li><li>$&lt;    第一个依赖</li><li>$?    第一个变化的依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> get all .c files</span></span><br><span class="line">SrcFiles=$(wildcard *.c)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> all .c files --&gt; .o file</span></span><br><span class="line">ObjFiles=$(patsubst %.c,%.o,$(SrcFiles))</span><br><span class="line"></span><br><span class="line">all:app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目标文件用法 $(Var)</span></span><br><span class="line">app: $(ObjFiles)</span><br><span class="line">gcc -o $@ -I./include/ $(ObjFiles)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模式匹配规则， <span class="variable">$@</span> $&lt; 这样的变量，只能在规则中出现</span></span><br><span class="line"><span class="meta">%</span><span class="bash">.o:%.c</span></span><br><span class="line">gcc -c $&lt; -I./include/ -o $@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> @ 在规则前代表不输出该条规则的命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 规则前的“-”，代表该条规则报错，仍然继续执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .PHONY 定义伪目标，防止有歧义</span></span><br><span class="line">.PHONY:clean all</span><br><span class="line">clean:</span><br><span class="line">-@rm -f *.o</span><br><span class="line">-@rm -f app</span><br></pre></td></tr></table></figure><p>make -f makefile1    指定makefile文件进行编译</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SrcFiles=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">TargetFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(TargetFiles)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">%:%.c</span></span><br><span class="line">gcc -o <span class="variable">$@</span> %^</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f <span class="variable">$(TargetFiles)</span></span><br></pre></td></tr></table></figure><h3 id="1-7-gdb-调试"><a href="#1-7-gdb-调试" class="headerlink" title="1.7 gdb 调试"></a>1.7 gdb 调试</h3><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMTA3NzU5Lw==" title="http://blog.jobbole.com/107759/">gdb 调试入门，大牛写的高质量指南<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eHRvb2xzLXJzdC5yZWFkdGhlZG9jcy5pby96aF9DTi9sYXRlc3QvdG9vbC9nZGIuaHRtbA==" title="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">gdb 调试利器<i class="fa fa-external-link"></i></span></p></blockquote><p>启动gdb：gdb app</p><p>在gdb启动程序：</p><ul><li>r(un)   – 启动  可以带参数启动</li><li>start   – 启动 - 停留在main函数，分步调试</li><li>n(ent)   – 下一条指令</li><li>s(tep)  – 下一条指令，可以进入函数内部，库函数不能进</li><li>q(uit)   – 退出 gdb</li><li>b(reak)  num  – 指定行号，函数, 文件:行号  设置断点<ul><li>b 行号  – 主函数所在文件的行</li><li>b 函数名</li><li>b 文件名:行号</li></ul></li><li>l(ist) 文件：行号   – 查看代码<ul><li>l – 显示主函数对应的文件</li><li>l 文件名:行号</li></ul></li><li>info b   – 查看断点信息</li><li>d(el)  num – 删除断点</li><li>c – continue 跳到下一个断点</li><li>p(rint) – 打印参数，或者变量值</li><li>ptype 变量  – 查看变量类型</li><li>set  – 设置变量的值<ul><li>set argc=4</li><li>set argv[1]=“12”</li><li>set argv[2] = “7”</li></ul></li><li>display argc  –  跟踪显示参数或者变量的变化</li><li>info display</li><li>undisplay num</li><li>b num if xx == xx  – 条件断点</li></ul><p><strong>gdb跟踪core</strong></p><ul><li><p>设置生成 core ：ulimit -c unlimited</p></li><li><p>取消生成 core： ulimit -c 0</p></li><li><p>设置 core 文件格式：/proc/sys/kernel/core_pattern</p><p>文件不能 vi，可以用后面的套路：echo “/corefile/core-%e-%p-%t” &gt; core_pattern</p></li></ul><p>core 文件如何使用：</p><ul><li><p>gdb app core</p></li><li><p>如果看不到在哪儿core  可以用 where 查看在哪儿产生的 core</p></li></ul><h2 id="2-系统api与库函数的关系"><a href="#2-系统api与库函数的关系" class="headerlink" title="2. 系统api与库函数的关系"></a>2. 系统api与库函数的关系</h2><img src="/images/imageProgramC/系统api与函数关系.png"><h2 id="3-Linux-系统编程"><a href="#3-Linux-系统编程" class="headerlink" title="3. Linux 系统编程"></a>3. Linux 系统编程</h2><p>ulimit -a 查看所有资源的上限</p><p>env 查看环境变量</p><p>echo $PATH  打印指定的环境变量</p><p><code>char *getenv()</code> 获取环境变量</p><p><strong>创建一个进程</strong>：</p><p><code>pid_t fork(void)</code></p><p>返回值：</p><ul><li>失败 -1</li><li>成功，返回两次<ul><li>父进程返回子进程的 id</li><li>子进程返回 0</li></ul></li></ul><p>获得pid，进程 id，获得当前进程</p><p><code>pid_t getpid(void)</code></p><p>获得当前进程父进程的 id</p><p><code>pid_t getppid(void)</code></p><p>ps ajx 查看父进程和子进程相关信息</p><p><strong>进程共享</strong>：</p><p>父子进程之间在fork后，有哪些相同和不同：</p><ul><li>父子相同处：<ul><li>全局变量</li><li>data、text、栈、堆、环境变量</li><li>用户 ID</li><li>宿主目录、进程工作目录、信号处理方式…</li></ul></li><li>父子不同处：<ul><li>进程 ID</li><li>父进程 ID</li><li>进程运行时间</li><li>闹钟（定时器）</li><li>未决信号集</li></ul></li></ul><p>似乎，子进程复制了父进程 0-3G 用户空间内容，以及父进程的 PCB， 但 pid 不同。真的每 fork 一个子进程都要将父进程的 0-3G 地址空间完全拷贝一份，然后在映射至屋里内存吗？当然不是，父子进程间遵循<strong>读时共享写时复制</strong>。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p><p><strong>孤儿进程与僵尸进程</strong>：</p><ul><li>孤儿进程<ul><li>父进程死了，子进程被 init 进程领养</li></ul></li><li>僵尸进程<ul><li>子进程死了，父进程没有回收子进程的资源（PCB）</li></ul></li></ul><p>回收子进程，知道子进程的死亡原因，作用：</p><ul><li>阻塞等待</li><li>回收子进程资源</li><li>查看死亡原因</li></ul><p><code>pid_t wait(int *status)</code></p><ul><li>status 传出参数</li><li>返回值<ul><li>成功返回终止的子进程 ID</li><li>失败 返回 -1</li></ul></li></ul><p>子进程的死亡原因：</p><ul><li>正常死亡 WIFEXITED<ul><li>如果 WIFEXITED 为真，使用 WEXITSTATUS 得到退出的状态</li></ul></li><li>非正常死亡 WIFSIGNALED<ul><li>如果 WIFSIGNALED 为真，使用 WTERMSIG 得到信号</li></ul></li></ul><p><code>pid_t waitpid(pid_t pid, int *status, int options)</code></p><ul><li>pid<ul><li><code>&lt; -1</code> 组ID</li><li><code>-1</code> 回收任意</li><li><code>0</code> 回收和调用进程组 ID 相同组内的子进程</li><li><code>&gt;0</code> 回收指定的 pid</li></ul></li><li>option<ul><li>0 与 wait 相同，也会阻塞</li><li>WNOHANG 如果当前没有子进程退出，会立刻返回</li></ul></li><li>返回值<ul><li>如果设置了 WNOHANG ，那么如果没有子进程退出，返回 0<ul><li>如果有子进程退出返回退出的 pid</li></ul></li><li>失败返回 -1 （没有子进程）</li></ul></li></ul><h3 id="3-1-IPC-概念"><a href="#3-1-IPC-概念" class="headerlink" title="3.1 IPC 概念"></a>3.1 IPC 概念</h3><p>IPC ： 进程间通信，通过内核提供的缓存区进行数据交换的机制</p><p>IPC 通信的方式有几种：</p><ul><li>pipe 管道 – 最简单</li><li>fifo 有名管道</li><li>mmap 文件映射共享IO – 速度最快</li><li>本地 socket 最稳定</li><li>信号 携带信息量最小</li><li>共享内存</li><li>消息队列</li></ul><p><strong>读管道</strong>：</p><ul><li>写端全部关闭 – read 读到 0， 想当于读到文件末尾</li><li>写端没有全部关闭<ul><li>有数据 – read 读到数据</li><li>没有数据 – read 阻塞 fcntl 函数可以更改非阻塞</li></ul></li></ul><p><strong>写管道</strong>：</p><ul><li>读端全部关闭 – ？ 产生一个信号 SIGPIPE，程序异常终止</li><li>读端未全部关闭<ul><li>管道已满 – write 阻塞 – 如果要显示现象，读端一直不读，写端狂写。</li><li>管道未满 – write 正常写入</li></ul></li></ul><p><strong>管道缓冲区大小</strong></p><p>可以使用 <code>ulimit –a</code> 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe size            (512 bytes, -p) 8</span><br></pre></td></tr></table></figure><p>也可以使用 <code>fpathconf</code> 函数，借助参数选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p><p><code>long fpathconf(int fd, int name);</code>    </p><ul><li>成功：返回管道的大小    </li><li>失败：-1，设置errno</li></ul><p><strong>管道的优劣</strong></p><ul><li><p>优点：</p><ul><li>简单，相比信号，套接字实现进程间通信，简单很多。</li></ul></li><li><p>缺点：</p><ul><li>只能单向通信，双向通信需建立两个管道。</li><li>只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。</li></ul></li></ul><p><strong>FIFO通信</strong></p><p>FIFO 有名管道，实现无血缘关系进程通信</p><ul><li>创建一个管道的伪文件<ul><li>mkfifo myfifo 命令创建</li><li>也可以使用函数 <code>int mkfifo(const char *pathname,  mode_t mode);</code></li></ul></li><li>内核会针对 fifo 文件开辟一个缓存区，操作 fifo 文件，可以操作缓存区，实现进程间通信 – 实际上就是文件读写</li></ul><p><strong>mmap映射共享区</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *adrr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>返回：</p><ul><li>成功：返回创建的映射区首地址；</li><li><strong>失败：MAP_FAILED宏</strong></li></ul></li><li><p>参数：    </p><ul><li>addr:     建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</li><li>length：   欲创建映射区的大小</li><li>prot：       映射区权限 PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</li><li>flags：      标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)<ul><li>MAP_SHARED:  会将映射区所做的操作反映到物理设备（磁盘）上。（共享的）</li><li>MAP_PRIVATE:  映射区所做的修改不会反映到物理设备。（私有的）</li></ul></li><li>fd：      用来建立映射区的文件描述符</li><li>offset：   映射文件的偏移(4k的整数倍)</li></ul></li></ul><p>释放映射区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>匿名映射</strong></p><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。</p><p>使用 <code>MAP_ANONYMOUS</code>(或 <code>MAP_ANON</code> )， 如: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// "4"随意举例，该位置表大小，可依实际需要填写。</span></span><br></pre></td></tr></table></figure><p>需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/dev/zero 聚宝盆，可以随意映射</span></span><br><span class="line"><span class="comment">/dev/null 无底洞，一般错误信息重定向到这个文件中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fd = open(<span class="string">"/dev/zero"</span>, O_RDWR);</span><br><span class="line">p = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>信号的概念</strong></p><ul><li><p>信号的特点</p><ul><li>简单，不能带大量信息，满足特定条件发生</li></ul></li><li><p>信号的机制</p><ul><li>进程 B 发送给进程 A ，内核产生信号，内核处理</li></ul></li><li><p>信号的产生</p><ul><li>按键产生 </li><li>函数调用 kill、raise、abort</li><li>定时器 alarm、setitimer</li><li>命令产生 kill</li><li>硬件异常、段错误、浮点型错误、总线错误、SIGPIPE</li></ul></li><li><p>信号的状态</p><ul><li>产生</li><li>递达 信号到达并且处理完</li><li>未决 信号被阻塞</li></ul></li><li><p>信号的默认处理方式</p><ul><li>忽略</li><li>执行默认动作</li><li>捕捉</li></ul></li><li><p>信号的 4 要素</p><ul><li>编号</li><li>事件</li><li>名称</li><li>默认处理动作<ul><li>忽略</li><li>终止</li><li>终止 + core</li><li>暂停</li><li>继续</li></ul></li></ul></li></ul><h3 id="3-2-进程和线程"><a href="#3-2-进程和线程" class="headerlink" title="3.2 进程和线程"></a>3.2 进程和线程</h3><ul><li>进程组</li><li>会话</li><li>守护进程</li></ul><p>创建一个会话需要注意以下 5 点注意事项：</p><ul><li>调用进程不能是进程组组长，该进程编程新会话首进程（session header）</li><li>该进程成为一个新进程组的组长进程</li><li>新会话丢弃原有的控制终端，该会话没有控制终端</li><li>该调用进程是组长进程，则出错返回</li><li>建立会话时，先调用fork，父进程终止，子进程调用 setsid</li></ul><p>守护进程：</p><p>Daemon 进程，是 Linux 中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p><p>创建守护进程，最关键的一步是调用 setsid 函数创建一个新的 session 。并成为 session leader。</p><p><strong>创建守护进程模型</strong>：</p><ul><li>创建子进程，父进程退出<ul><li>所有工作在子进程中进行形式上脱离了控制终端</li></ul></li><li>在子进程中创建新会话<ul><li>setsid() 函数</li><li>使子进程完全能独立出来，脱离控制</li></ul></li><li>改变当前目录为根目录<ul><li>chdir() 函数</li><li>防止占用可卸载的文件系统</li><li>也可以换成其他路径</li></ul></li><li>重设文件权限掩码<ul><li>umask() 函数</li><li>防止继承的文件创建屏蔽字拒绝某些权限</li><li>增加守护进程灵活性</li></ul></li><li>关闭文件描述符<ul><li>继承的打开文件不会用到，浪费系统资源，无法卸载</li></ul></li><li>开始执行守护进程核心工作</li><li>守护进程退出处理程序模型</li></ul><blockquote><p>会话：进程组的更高一级，多个进程组对应一个会话</p><p>进程组：多个进程在同一个组，第一个进程默认是进程组的组长</p><p>创建会话的时候，组长不可以创建，必须是组员创建。</p><p>创建会话的步骤：创建子进程，父进程终止，子进程当会长</p><p>守护进程的步骤：</p><ul><li>创建子进程 fork</li><li>父进程退出</li><li>子进程当会长 setsid</li><li>切换工作目录 $HOME</li><li>设置掩码 umask</li><li>关闭文件描述符，为了避免浪费资源</li><li>执行核心逻辑</li><li>退出</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strFileName[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(strFileName, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(strFileName));</span><br><span class="line">        <span class="built_in">sprintf</span>(strFileName, <span class="string">"%s/log/Mr.Miaow.%ld"</span>, getenv(<span class="string">"HOME"</span>), time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> fd = open(strFileName, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"open err"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        sleep(<span class="number">5</span>);                                                                                      </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展了解：</p><p>通过 nohup 指令也可以达到守护进程创建的效果</p><p>nohup cmd [&gt; 1.log] &amp;</p><ul><li>nohup 指令会让 cmd 收不到 SIGHUP 信号</li><li>&amp; 代表后台运行</li></ul><p>线程是最小的执行单位，进程是最小的系统资源分配单位</p><p>查看 LWP 号：<code>ps -Lf pid</code> 查看指定线程的 lwp 号</p><p>线程非共享资源</p><ul><li>线程 ID</li><li>处理器现场和栈指针（内核栈）</li><li>独立的栈空间（用户空间栈）</li><li>errno 变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><p>线程优缺点：</p><ul><li>优点：<ul><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ul></li><li>缺点：<ul><li>库函数 不稳定</li><li>调试、编写困难</li><li>对信号支持不好</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alias echomake=`cat ~/bin/makefile.template &gt;&gt; makefile`</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/bin/makefile.template</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> create by Mr.Miaow `date +%Y%m%d`</span></span><br><span class="line">SrcFiles=$(wildcard *.c)</span><br><span class="line">TargetFiles=$(patsubst %.c,%,$(SrcFiles))</span><br><span class="line">all:$(TargetFiles)</span><br><span class="line"><span class="meta">%</span><span class="bash">:%.c</span></span><br><span class="line">gcc -o $@ %&lt; -lpthread -g</span><br><span class="line">clean:</span><br><span class="line">-rm -f $(TargetFiles)</span><br></pre></td></tr></table></figure><p><strong>线程退出注意事项</strong>：</p><ul><li>在线程中使用pthread_exit</li><li>在线程中使用 return （主控线程return 代表退出进程）</li><li>exit 代表退出整个进程</li></ul><p>线程回收函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><p>杀死线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>被pthread_cancel 杀死的线程，退出状态为 PTHREAD_CANCELED</p><p>线程分离：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>此时不需要 pthread_join回收资源</p><p>线程 ID 在进程内部是唯一的</p><p><strong>进程属性控制</strong>：</p><ul><li><p>初始化线程属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>销毁线程属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>设置属性分离态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="meta"># attr init 初始化的属性</span></span><br><span class="line"><span class="meta"># detachstate</span></span><br><span class="line"># - PTHREAD_CREATE_DETACHED 线程分离</span><br><span class="line"># - PTHREAD_CREATE_JOINABLE 允许回收</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>查看线程库版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> getconf GNU_LIBPTHREAD_VERSION</span></span><br></pre></td></tr></table></figure><p>创建多少个线程？</p><ul><li>cpu核数 * 2 + 2</li></ul><p><strong>线程同步</strong>：</p><ul><li>协调步骤，顺序执行</li></ul><p>解决同步的问题：加锁</p><p><strong>mutex 互斥量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> fastmutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">// 常量初始化，此时可以使用init</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>读写锁的特点：读共享，写独占，写优先级高</p><p>读写说任然是一把锁，有不同状态：</p><ul><li>未加锁</li><li>读锁</li><li>写锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>条件变量</strong>（生产者消费者模型）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒至少一个阻塞在条件变量 cond 上的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量 cond 上的全部线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 条件变量阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 超时等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> struct timespec *abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>信号量 加强版的互斥锁</strong>：</p><p>信号量是进化版的互斥量，允许多个线程访问共享资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="meta"># pshared</span></span><br><span class="line"># - <span class="number">0</span> 代表线程信号量</span><br><span class="line"># - 非<span class="number">0</span> 代表进程信号量</span><br><span class="line"><span class="meta"># value 定义信号量的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请信号量，申请成功 value--</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// 释放信号量 value++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abs_timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Link with -pthread.</span></span><br></pre></td></tr></table></figure><p><strong>文件锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-Note&quot;&gt;&lt;a href=&quot;#Linux-Note&quot; class=&quot;headerlink&quot; title=&quot;Linux Note&quot;&gt;&lt;/a&gt;Linux Note&lt;/h1&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;C-语言之解析局部变量返回&quot;&gt;&lt;a href=&quot;#C-语言之解析局部变量返回&quot; class=&quot;headerlink&quot; title=&quot;C 语言之解析局部变量返回&quot;&gt;&lt;/a&gt;C 语言之解析局部变量返回&lt;/h3&gt;&lt;p&gt;一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。&lt;/p&gt;
&lt;p&gt;准确的来说，&lt;strong&gt;函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
</feed>
