<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Miaow Blog</title>
  
  <subtitle>Do what you say, say what you do.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://miaopei.github.io/"/>
  <updated>2019-06-27T03:19:09.464Z</updated>
  <id>http://miaopei.github.io/</id>
  
  <author>
    <name>Mr.Miaow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>架构师之路</title>
    <link href="http://miaopei.github.io/2019/07/02/Architect/%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/"/>
    <id>http://miaopei.github.io/2019/07/02/Architect/架构师之路/</id>
    <published>2019-07-02T02:14:50.000Z</published>
    <updated>2019-06-27T03:19:09.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="架构师入门"><a href="#架构师入门" class="headerlink" title="架构师入门"></a>架构师入门</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hNzlkYzM1ZjQ1OTc=" title="https://www.jianshu.com/p/a79dc35f4597">我的职业是架构师：12年经验带你入门<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDkvc29mdHdhcmUtYXJjaGl0ZWN0dXJlLmh0bWw=" title="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html">软件架构入门 – 阮一峰<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzA3ODU4MA==" title="https://zhuanlan.zhihu.com/p/37078580">成为1个架构师的入门到进阶之路（学习路线图）<i class="fa fa-external-link"></i></span></p></blockquote><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvUmFoSnRBbFRGOXZrcnNqNFpscVBpZw==" title="https://mp.weixin.qq.com/s/RahJtAlTF9vkrsj4ZlqPig">架构师之路<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNjc2Nob29sLmNuL2FyY2hpdGVjdHJvYWQvYXJjaGl0ZWN0cm9hZC1hd2suaHRtbA==" title="https://www.w3cschool.cn/architectroad/architectroad-awk.html">W3Cschool架构师之路<i class="fa fa-external-link"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;架构师入门&quot;&gt;&lt;a href=&quot;#架构师入门&quot; class=&quot;headerlink&quot; title=&quot;架构师入门&quot;&gt;&lt;/a&gt;架构师入门&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3
      
    
    </summary>
    
      <category term="架构师" scheme="http://miaopei.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
    
      <category term="架构师" scheme="http://miaopei.github.io/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>实用的计算机工具库</title>
    <link href="http://miaopei.github.io/2019/05/29/%E5%AE%9E%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    <id>http://miaopei.github.io/2019/05/29/实用的计算机工具库/</id>
    <published>2019-05-29T02:14:50.000Z</published>
    <updated>2019-06-27T05:09:36.497Z</updated>
    
    <content type="html"><![CDATA[<p>在我们平时的工作过程中，经常会用到各种工具，每次遇到问题都得各种百度搜索，今天给大家带来几个私藏多年的工具库，有了它，你再也不用到处找工具了，里面包含了大量的使用工具。</p><h2 id="MikuTools"><a href="#MikuTools" class="headerlink" title="MikuTools"></a>MikuTools</h2><p><span class="exturl" data-url="aHR0cHM6Ly9taWt1LnRvb2xzLw==" title="https://miku.tools/">网站地址<i class="fa fa-external-link"></i></span></p><a id="more"></a><p>一个轻量的工具集合，里面包含有媒体类，图片类，文字处理类，编程开发类，日常实用类工具，基本覆盖了我们所有的需求，登录后还有更多的隐藏功能。</p><p><img src="/images/imageOther/mikutools.png" alt="mikutools"></p><h2 id="atoolbox"><a href="#atoolbox" class="headerlink" title="atoolbox"></a>atoolbox</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5hdG9vbGJveC5uZXQ=" title="http://www.atoolbox.net">网站地址<i class="fa fa-external-link"></i></span></p><p>一个工具箱，里面包含了143个在线工具，包括加密解密，文字编辑，编程开发，单位换算，日期时间，图形图像，金融理财，生活日常等各个门类，应该算是很全面了。</p><p><img src="/images/imageOther/atoolbox.png" alt="atoolbox"></p><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><p><span class="exturl" data-url="aHR0cHM6Ly90b29sLmx1Lw==" title="https://tool.lu/">网站地址<i class="fa fa-external-link"></i></span></p><p>程序员必备，里面包含各种常用的开发工具。</p><p><img src="/images/imageOther/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7.png" alt="在线工具"></p><h2 id="FrontEndNav"><a href="#FrontEndNav" class="headerlink" title="FrontEndNav"></a>FrontEndNav</h2><p><span class="exturl" data-url="aHR0cDovL25hdi53ZWItaHViLmNuLw==" title="http://nav.web-hub.cn/">网站地址<i class="fa fa-external-link"></i></span></p><p>前端程序员必备，收集了大量高质量的前端相关资源。</p><p><img src="/images/imageOther/frontEndNav.png" alt="frontEndNav"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们平时的工作过程中，经常会用到各种工具，每次遇到问题都得各种百度搜索，今天给大家带来几个私藏多年的工具库，有了它，你再也不用到处找工具了，里面包含了大量的使用工具。&lt;/p&gt;
&lt;h2 id=&quot;MikuTools&quot;&gt;&lt;a href=&quot;#MikuTools&quot; class=&quot;headerlink&quot; title=&quot;MikuTools&quot;&gt;&lt;/a&gt;MikuTools&lt;/h2&gt;&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9taWt1LnRvb2xzLw==&quot; title=&quot;https://miku.tools/&quot;&gt;网站地址&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://miaopei.github.io/categories/other/"/>
    
    
      <category term="other" scheme="http://miaopei.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg框架详解</title>
    <link href="http://miaopei.github.io/2019/05/27/FFmpeg/FFmpeg%E6%A1%86%E6%9E%B6%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/"/>
    <id>http://miaopei.github.io/2019/05/27/FFmpeg/FFmpeg框架函数分析/</id>
    <published>2019-05-27T02:14:50.000Z</published>
    <updated>2019-07-01T06:23:39.119Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy84NDQ5OTYzMg==" title="https://blog.csdn.net/leixiaohua1020/article/details/84499632">[总结]FFMPEG视音频编解码零基础学习方法<i class="fa fa-external-link"></i></span></p></blockquote><h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><h2 id="FFMPEG-SDL的视频播放器"><a href="#FFMPEG-SDL的视频播放器" class="headerlink" title="FFMPEG+SDL的视频播放器"></a>FFMPEG+SDL的视频播放器</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy8zODg2ODQ5OQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/38868499">最简单的基于FFMPEG+SDL的视频播放器 ver2 （采用SDL2.0）<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>FFmpeg 解码一个视频流程：</strong></p><a id="more"></a><p><img src="/images/imageFFmpeg/Thor/%E6%92%AD%E6%94%BE%E5%99%A8%E8%A7%A3%E7%A0%81%E7%9A%84%E6%B5%81%E7%A8%8B%E7%94%A8%E5%9B%BE.png" alt="FFmpeg解码一个视频流程"></p><p><strong>SDL2.0 显示 YUV 的流程：</strong></p><p><img src="/images/imageFFmpeg/Thor/SDL2.0%E6%98%BE%E7%A4%BAYUV%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="SDL2.0显示YUV的流程"></p><h2 id="FFMPEG的视频编码器（YUV编码为H-264）"><a href="#FFMPEG的视频编码器（YUV编码为H-264）" class="headerlink" title="FFMPEG的视频编码器（YUV编码为H.264）"></a>FFMPEG的视频编码器（YUV编码为H.264）</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy8yNTQzMDQyNQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/25430425">最简单的基于FFMPEG的视频编码器（YUV编码为H.264）<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy8zOTc3MDk0Nw==" title="https://blog.csdn.net/leixiaohua1020/article/details/39770947">最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80MjE4MTI3MQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/42181271">最简单的基于FFmpeg的编码器-纯净版（不包含libavformat）<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="FFmpeg编码视频的流程图"><a href="#FFmpeg编码视频的流程图" class="headerlink" title="FFmpeg编码视频的流程图"></a>FFmpeg编码视频的流程图</h3><p>通过该流程，不仅可以编码H.264/H.265的码流，而且可以编码MPEG4/MPEG2/VP9/VP8等多种码流。实际上使用FFmpeg编码视频的方式都是一样的。图中蓝色背景的函数是实际输出数据的函数。浅绿色的函数是视频编码的函数。</p><p><img src="/images/imageFFmpeg/Thor/FFmpeg%E7%BC%96%E7%A0%81%E8%A7%86%E9%A2%91%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="FFmpeg编码视频的流程图"></p><p>简单介绍一下流程中各个函数的意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">av_register_all()  <span class="comment">// 注册FFmpeg所有编解码器。</span></span><br><span class="line">avformat_alloc_output_context2()  <span class="comment">// 初始化输出码流的AVFormatContext。</span></span><br><span class="line">avio_open()  <span class="comment">// 打开输出文件。</span></span><br><span class="line">av_new_stream()  <span class="comment">// 创建输出码流的AVStream。</span></span><br><span class="line">avcodec_find_encoder()  <span class="comment">// 查找编码器。</span></span><br><span class="line">avcodec_open2()  <span class="comment">// 打开编码器。</span></span><br><span class="line">avformat_write_header()  <span class="comment">// 写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。</span></span><br><span class="line">avcodec_encode_video2()  <span class="comment">// 编码一帧视频。即将AVFrame（存储YUV像素数据）编码为AVPacket（存储H.264等格式的码流数据）。</span></span><br><span class="line">av_write_frame()  <span class="comment">// 将编码后的视频码流写入文件。</span></span><br><span class="line">flush_encoder()  <span class="comment">// 输入的像素数据读取完成后调用此函数。用于输出编码器中剩余的AVPacket。</span></span><br><span class="line">av_write_trailer()  <span class="comment">// 写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。</span></span><br></pre></td></tr></table></figure><h3 id="“纯净”的基于FFmpeg的视频编码器"><a href="#“纯净”的基于FFmpeg的视频编码器" class="headerlink" title="“纯净”的基于FFmpeg的视频编码器"></a>“纯净”的基于FFmpeg的视频编码器</h3><p>以下记录一个更加 “纯净” 的基于 FFmpeg 的视频编码器。此前记录过一个基于 FFmpeg 的视频编码器：</p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjAvYXJ0aWNsZS9kZXRhaWxzLzM5NzcwOTQ3" title="http://blog.csdn.net/leixiaohua1020/article/details/39770947"> 《最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）》<i class="fa fa-external-link"></i></span></p><p>这个视频编码器调用了 FFmpeg 中的 libavformat 和 libavcodec 两个库完成了视频编码工作。但是这不是一个 “纯净” 的编码器。</p><p>上述两个库中 libavformat 完成封装格式处理，而 libavcodec 完成编码工作。</p><p>一个 “纯净” 的编码器，理论上说只需要使用 libavcodec 就足够了，并不需要使用 libavformat。一下记录的编码器就是这样的一个 “纯净” 的编码器，它仅仅通过调用 libavcodec 将 YUV 数据编码为 H.264/HEVC 等格式的压缩视频码流。</p><p><strong>仅使用libavcodec（不使用libavformat）编码视频的流程：</strong></p><p><img src="/images/imageFFmpeg/Thor/%E4%BB%85%E4%BD%BF%E7%94%A8libavcodec%E7%BC%96%E7%A0%81%E8%A7%86%E9%A2%91%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="仅使用libavcodec（不使用libavformat）编码视频的流程"></p><p>流程图中关键函数的作用如下所列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">avcodec_register_all()  <span class="comment">// 注册所有的编解码器。</span></span><br><span class="line">avcodec_find_encoder()  <span class="comment">// 查找编码器。</span></span><br><span class="line">avcodec_alloc_context3()  <span class="comment">// 为AVCodecContext分配内存。</span></span><br><span class="line">avcodec_open2()  <span class="comment">// 打开编码器。</span></span><br><span class="line">avcodec_encode_video2()  <span class="comment">// 编码一帧数据。</span></span><br></pre></td></tr></table></figure><p>两个存储数据的结构体如下所列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVFrame  <span class="comment">// 存储一帧未编码的像素数据。</span></span><br><span class="line">AVPacket  <span class="comment">// 存储一帧压缩编码数据。</span></span><br></pre></td></tr></table></figure><p><strong>对比：</strong></p><p>简单记录一下这个只使用 libavcodec 的 “纯净版” 视频编码器和使用 libavcodec+libavformat 的视频编码器的不同。</p><p>（1）    下列与libavformat相关的函数在“纯净版”视频编码器中都不存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">av_register_all注册所有的编解码器，复用/解复用器等等组件。其中调用了</span><br><span class="line">avcodec_register_all()  <span class="comment">// 注册所有编解码器相关的组件。</span></span><br><span class="line">avformat_alloc_context()  <span class="comment">// 创建AVFormatContext结构体。</span></span><br><span class="line">avformat_alloc_output_context2()  <span class="comment">// 初始化一个输出流。</span></span><br><span class="line">avio_open()  <span class="comment">// 打开输出文件。</span></span><br><span class="line">avformat_new_stream()  <span class="comment">// 创建AVStream结构体。avformat_new_stream()中会调用</span></span><br><span class="line">avcodec_alloc_context3()  <span class="comment">// 创建AVCodecContext结构体。</span></span><br><span class="line">avformat_write_header()  <span class="comment">// 写文件头。</span></span><br><span class="line">av_write_frame()  <span class="comment">// 写编码后的文件帧。</span></span><br><span class="line">av_write_trailer()  <span class="comment">// 写文件尾。</span></span><br></pre></td></tr></table></figure><p>（2）    新增了如下几个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avcodec_register_all()  <span class="comment">// 只注册编解码器有关的组件。</span></span><br><span class="line">avcodec_alloc_context3()  <span class="comment">// 创建AVCodecContext结构体。</span></span><br></pre></td></tr></table></figure><p>可以看出，相比于“完整”的编码器，这个纯净的编码器函数调用更加简单，功能相对少一些，相对来说更加的“轻量”。</p><h2 id="解码框架图"><a href="#解码框架图" class="headerlink" title="解码框架图"></a>解码框架图</h2><p><img src="/images/imageFFmpeg/Thor/FFmpeg%E6%BA%90%E7%A0%81API%E7%BB%93%E6%9E%84%E5%9B%BE-%E8%A7%A3%E7%A0%81.png" alt="FFmpeg解码"></p><h2 id="编码框架图"><a href="#编码框架图" class="headerlink" title="编码框架图"></a>编码框架图</h2><p><img src="/images/imageFFmpeg/Thor/FFmpeg%E6%BA%90%E7%A0%81API%E7%BB%93%E6%9E%84%E5%9B%BE-%E7%BC%96%E7%A0%81.png" alt="FFmpeg编码"></p><h1 id="通用函数解析"><a href="#通用函数解析" class="headerlink" title="通用函数解析"></a>通用函数解析</h1><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDIyMDE1MQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/44220151">函数解析<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="av-register-all"><a href="#av-register-all" class="headerlink" title="av_register_all()"></a>av_register_all()</h2><p>ffmpeg 注册复用器，编码器等的函数 <code>av_register_all()</code>。该函数在所有基于ffmpeg的应用程序中几乎都是第一个被调用的。只有调用了该函数，才能使用复用器，编码器等。</p><p>函数调用关系图如下图所示。<code>av_register_all()</code> 调用了 <code>avcodec_register_all()</code>。<code>avcodec_register_all()</code> 注册了和编解码器有关的组件：硬件加速器，解码器，编码器，Parser，Bitstream Filter。<code>av_register_all()</code> 除了调用 <code>avcodec_register_all()</code> 之外，还注册了复用器，解复用器，协议处理器。</p><p><img src="/images/imageFFmpeg/Thor/av_register_all.png" alt="av_register_all"></p><h2 id="内存的分配和释放（av-malloc-、av-free-等）"><a href="#内存的分配和释放（av-malloc-、av-free-等）" class="headerlink" title="内存的分配和释放（av_malloc()、av_free()等）"></a>内存的分配和释放（av_malloc()、av_free()等）</h2><p>内存操作的常见函数位于 <code>libavutil\mem.c</code> 中。本文记录FFmpeg开发中最常使用的几个函数：<code>av_malloc()</code>，<code>av_realloc()</code>，<code>av_mallocz()</code>，<code>av_calloc()</code>，<code>av_free()</code>，<code>av_freep()</code>。</p><p><code>av_malloc()</code> 就是简单的封装了系统函数malloc()，并做了一些错误检查工作。</p><h3 id="关于size-t"><a href="#关于size-t" class="headerlink" title="关于size_t"></a>关于size_t</h3><p>size _t  这个类型在 FFmpeg 中多次出现，简单解释一下其作用。size _t 是为了增强程序的可移植性而定义的。不同系统上，定义 size_t 可能不一样。它实际上就是 unsigned int。</p><h3 id="为什么要内存对齐？"><a href="#为什么要内存对齐？" class="headerlink" title="为什么要内存对齐？"></a>为什么要内存对齐？</h3><p>FFmpeg 内存分配方面多次涉及到 “内存对齐”（memory alignment）的概念。</p><p>这方面内容在 IBM 的网站上有一篇文章，讲的挺通俗易懂的，在此简单转述一下。</p><p>程序员通常认为内存就是一个字节数组，每次可以一个一个字节存取内存。例如在 C 语言中使用 <code>char *</code> 指代 “一块内存”，Java 中使用 <code>byte[]</code> 指代一块内存。如下所示。</p><p><img src="/images/imageFFmpeg/Thor/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-01.png" alt></p><p>但那实际上计算机处理器却不是这样认为的。处理器相对比较 “懒惰”，它会以 2 字节，4 字节，8 字节，16 字节甚至 32 字节来存取内存。例如下图显示了以 4 字节为单位读写内存的处理器 “看待” 上述内存的方式。</p><p><img src="/images/imageFFmpeg/Thor/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-02.png" alt></p><p>上述的存取单位的大小称之为内存存取粒度。</p><p>下面看一个实例，分别从地址0，和地址 1 读取 4 个字节到寄存器。</p><p>从程序员的角度来看，读取方式如下图所示。</p><p><img src="/images/imageFFmpeg/Thor/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-03.png" alt></p><p>而 2 字节存取粒度的处理器的读取方式如下图所示。</p><p><img src="/images/imageFFmpeg/Thor/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-04.png" alt></p><p>可以看出 2 字节存取粒度的处理器从地址 0 读取 4 个字节一共读取 2 次；从地址 1 读取 4 个字节一共读取了 3 次。由于每次读取的开销是固定的，因此从地址 1 读取 4 字节的效率有所下降。</p><p>4 字节存取粒度的处理器的读取方式如下图所示。</p><p><img src="/images/imageFFmpeg/Thor/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-05.png" alt></p><p>可以看出 4 字节存取粒度的处理器从地址 0 读取 4 个字节一共读取 1 次；从地址 1 读取 4 个字节一共读取了 2 次。从地址 1 读取的开销比从地址 0 读取多了一倍。由此可见内存不对齐对 CPU 的性能是有影响的。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">av_malloc()  <span class="comment">// 是FFmpeg中最常见的内存分配函数, av_malloc()就是简单的封装了系统函数malloc()</span></span><br><span class="line">av_realloc()  <span class="comment">// 用于对申请的内存的大小进行调整。</span></span><br><span class="line">av_mallocz()  <span class="comment">// 可以理解为av_malloc()+zeromemory</span></span><br><span class="line">av_calloc()  <span class="comment">// 则是简单封装了av_mallocz()</span></span><br><span class="line">av_free()  <span class="comment">// 用于释放申请的内存</span></span><br><span class="line">av_freep()  <span class="comment">// 简单封装了av_free()。并且在释放内存之后将目标指针设置为NULL</span></span><br></pre></td></tr></table></figure><h2 id="常见结构体的初始化和销毁（AVFormatContext，AVFrame等）"><a href="#常见结构体的初始化和销毁（AVFormatContext，AVFrame等）" class="headerlink" title="常见结构体的初始化和销毁（AVFormatContext，AVFrame等）"></a>常见结构体的初始化和销毁（AVFormatContext，AVFrame等）</h2><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjAvYXJ0aWNsZS9kZXRhaWxzLzExNjkzOTk3" title="http://blog.csdn.net/leixiaohua1020/article/details/11693997">FFMPEG中最关键的结构体之间的关系<i class="fa fa-external-link"></i></span></p></blockquote><p>常见的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统领全局的基本结构体。主要用于处理封装格式（FLV/MKV/RMVB 等）</span></span><br><span class="line">AVFormatContext</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入输出对应的结构体，用于输入输出（读写文件，RTMP 协议等）</span></span><br><span class="line">AVIOContext</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视音频流对应的结构体，用于视音频编解码</span></span><br><span class="line">AVStream，AVCodecContext</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储非压缩的数据（视频对应 RGB/YUV 像素数据，音频对应 PCM 采样数据）</span></span><br><span class="line">AVFrame</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储压缩数据（视频对应 H.264 等码流数据，音频对应 AAC/MP3 等码流数据）</span></span><br><span class="line">AVPacket</span><br></pre></td></tr></table></figure><p>他们之间的关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/%E5%B8%B8%E8%A7%81%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="常见结构体之间的关系"></p><p>简单分析一下上述几个结构体的初始化和销毁函数。这些函数列表如下。</p><table><thead><tr><th>结构体</th><th>初始化</th><th>销毁</th></tr></thead><tbody><tr><td>AVFormatContext</td><td>avformat_alloc_context()</td><td>avformat_free_context()</td></tr><tr><td>AVIOContext</td><td>avio_alloc_context()</td><td></td></tr><tr><td>AVStream</td><td>avformat_new_stream()</td><td></td></tr><tr><td>AVCodecContext</td><td>avcodec_alloc_context3()</td><td></td></tr><tr><td>AVFrame</td><td>av_frame_alloc();<br>av_image_fill_arrays()</td><td>av_frame_free()</td></tr><tr><td>AVPacket</td><td>av_init_packet();<br>av_new_packet()</td><td>av_free_packet()</td></tr></tbody></table><h3 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context()"></a>avformat_alloc_context()</h3><p><code>avformat_alloc_context()</code> 的定义位于 <code>libavformat\options.c</code>。</p><p><code>avformat_alloc_context()</code> 调用 <code>av_malloc()</code> 为 AVFormatContext 结构体分配了内存，而且同时也给 AVFormatContext 中的 <code>internal</code> 字段分配内存（这个字段是 FFmpeg 内部使用的，先不分析）。此外调用了一个 <code>avformat_get_context_defaults()</code> 函数。该函数用于设置 AVFormatContext 的字段的默认值。它的定义也位于 <code>libavformat\options.c</code>，确切的说就位于 <code>avformat_alloc_context()</code>上面</p><p><code>avformat_get_context_defaults()</code> 首先调用 <code>memset()</code> 将 AVFormatContext 的所有字段置 0。而后调用了一个函数 <code>av_opt_set_defaults()</code> 。<code>av_opt_set_defaults()</code> 用于给字段设置默认值。</p><p><code>avformat_alloc_context()</code> 代码的函数调用关系如下图所示。</p><p><img src="/images/imageFFmpeg/Thor/avformat_alloc_context.png" alt="avformat_alloc_context"></p><p><code>avformat_free_context()</code> 的声明位于 <code>libavformat\avformat.h</code></p><p><code>avformat_free_context()</code> 的定义位于 <code>libavformat\options.c</code></p><p><code>avformat_free_context()</code> 调用了各式各样的销毁函数：<code>av_opt_free()</code>，<code>av_freep()</code>，<code>av_dict_free()</code>。这些函数分别用于释放不同种类的变量，在这里不再详细讨论。</p><p>在这里看一个释放 AVStream 的函数 <code>ff_free_stream()</code>。该函数的定义位于 <code>libavformat\options.c</code>（其实就在 <code>avformat_free_context()</code> 上方）, 与释放 AVFormatContext 类似，释放 AVStream 的时候，也是调用了 <code>av_freep()</code>，<code>av_dict_free()</code> 这些函数释放有关的字段。如果使用了 parser 的话，会调用 <code>av_parser_close()</code> 关闭该 parser。</p><h3 id="avio-alloc-context"><a href="#avio-alloc-context" class="headerlink" title="avio_alloc_context()"></a>avio_alloc_context()</h3><p>AVIOContext 的初始化函数是 <code>avio_alloc_context()</code>，销毁的时候使用 <code>av_free()</code> 释放掉其中的缓存即可。它的声明位于 <code>libavformat\avio.h</code> 中</p><p><code>avio_alloc_context()</code> 定义位于 <code>libavformat\aviobuf.c</code> 中</p><p><code>avio_alloc_context()</code> 首先调用 <code>av_mallocz()</code> 为 AVIOContext 分配内存。而后调用了一个函数 <code>ffio_init_context()</code> 。该函数完成了真正的初始化工作</p><h3 id="avformat-new-stream"><a href="#avformat-new-stream" class="headerlink" title="avformat_new_stream()"></a>avformat_new_stream()</h3><p><code>avformat_new_stream()</code> 的声明位于 <code>libavformat\avformat.h</code> 中</p><p>AVStream 的初始化函数是 <code>avformat_new_stream()</code>，销毁函数使用销毁 AVFormatContext 的 <code>avformat_free_context()</code> 就可以了。</p><p><code>avformat_new_stream()</code> 的定义位于 <code>libavformat\utils.c</code> 中</p><p><code>avformat_new_stream()</code> 首先调用 <code>av_mallocz()</code>  为 AVStream 分配内存。接着给新分配的AVStream 的各个字段赋上默认值。然后调用了另一个函数 <code>avcodec_alloc_context3()</code> 初始化 AVStream 中的 AVCodecContext。</p><h3 id="avcodec-alloc-context3"><a href="#avcodec-alloc-context3" class="headerlink" title="avcodec_alloc_context3()"></a>avcodec_alloc_context3()</h3><p><code>avcodec_alloc_context3()</code> 的声明位于 <code>libavcodec\avcodec.h</code> 中</p><p><code>avcodec_alloc_context3()</code> 的定义位于 <code>libavcodec\options.c</code> 中</p><p><code>avcodec_alloc_context3()</code> 首先调用 <code>av_malloc()</code> 为 AVCodecContext 分配存储空间，然后调用了一个函数 <code>avcodec_get_context_defaults3()</code> 用于设置该 AVCodecContext 的默认值</p><p><code>avformat_new_stream()</code> 函数的调用结构如下所示：</p><p><img src="/images/imageFFmpeg/Thor/avformat_new_stream.png" alt="avformat_new_stream"></p><h3 id="av-frame-alloc"><a href="#av-frame-alloc" class="headerlink" title="av_frame_alloc()"></a>av_frame_alloc()</h3><p>AVFrame 的初始化函数是 <code>av_frame_alloc()</code>，销毁函数是 <code>av_frame_free()</code>。在这里有一点需要注意，旧版的 FFmpeg 都是使用 <code>avcodec_alloc_frame()</code> 初始化 AVFrame 的，但是我在写这篇文章的时候，<code>avcodec_alloc_frame()</code> 已经被标记为 “过时的” 了，为了保证与时俱进，决定分析新的<code>API——av_frame_alloc()</code>。</p><p><code>av_frame_alloc()</code> 的声明位于 <code>libavutil\frame.h</code></p><p><code>av_frame_alloc()</code> 的定义位于 <code>libavutil\frame.c</code></p><p><code>av_frame_alloc()</code> 首先调用 <code>av_mallocz()</code> 为 AVFrame 结构体分配内存。而后调用了一个函数<code>get_frame_defaults()</code> 用于设置一些默认参数</p><p>从 <code>av_frame_alloc()</code> 的代码我们可以看出，该函数并没有为 AVFrame 的像素数据分配空间。因此AVFrame 中的像素数据的空间需要自行分配空间，例如使用 <code>avpicture_fill()</code>， <code>av_image_fill_arrays()</code> 等函数。</p><p><code>av_frame_alloc()</code> 函数的调用结构如下所示：</p><p><img src="/images/imageFFmpeg/Thor/av_frame_alloc.png" alt="av_frame_alloc"></p><h4 id="avpicture-fill"><a href="#avpicture-fill" class="headerlink" title="avpicture_fill()"></a>avpicture_fill()</h4><p><code>avpicture_fill()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p><p><code>avpicture_fill()</code> 的定义位于 <code>libavcodec\avpicture.c</code></p><p><code>avpicture_fill()</code> 仅仅是简单调用了一下 <code>av_image_fill_arrays()</code>。也就是说这两个函数实际上是等同的</p><h4 id="av-image-fill-arrays"><a href="#av-image-fill-arrays" class="headerlink" title="av_image_fill_arrays()"></a>av_image_fill_arrays()</h4><p><code>av_image_fill_arrays()</code> 的声明位于 <code>libavutil\imgutils.h</code> 中</p><p><code>av_image_fill_arrays()</code> 的定义位于 <code>libavutil\imgutils.c</code> 中</p><p><code>av_image_fill_arrays()</code> 函数中包含 3 个函数：<code>av_image_check_size()</code>，<code>av_image_fill_linesizes()</code>，<code>av_image_fill_pointers()</code>。<code>av_image_check_size()</code> 用于检查输入的宽高参数是否合理，即不能太大或者为负数。<code>av_image_fill_linesizes()</code> 用于填充dst_linesize。<code>av_image_fill_pointers()</code> 则用于填充 dst_data。它们的定义相对比较简单，不再详细分析。</p><p><code>avpicture_fill()</code> 函数调用关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/avpicture_fill.png" alt="avpicture_fill"></p><h3 id="av-init-packet"><a href="#av-init-packet" class="headerlink" title="av_init_packet()"></a>av_init_packet()</h3><p><code>av_init_packet()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p><p><code>av_init_packet()</code> 的定义位于 <code>libavcodec\avpacket.c</code></p><h3 id="av-new-packet"><a href="#av-new-packet" class="headerlink" title="av_new_packet()"></a>av_new_packet()</h3><p><code>av_new_packet()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p><p><code>av_new_packet()</code> 的定义位于 <code>libavcodec\avpacket.c</code></p><p><code>av_new_packet()</code> 调用了 <code>av_init_packet(pkt)</code>。此外还调用了一个函数 <code>packet_alloc()</code></p><p><code>packet_alloc()</code> 中调用 <code>av_buffer_realloc()</code> 为 AVPacket 分配内存。然后调用 <code>memset()</code> 将分配的内存置 0。</p><p>PS：发现 AVPacket 的结构随着 FFmpeg 的发展越发复杂了。原先 AVPacket 中的数据仅仅存在一个 uint8_t 类型的数组里，而现在已经使用一个专门的结构体 AVBufferRef 存储数据。</p><p><code>av_new_packet()</code> 代码的函数调用关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/av_new_packet.png" alt="av_new_packet"></p><p><code>av_free_packet()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p><p><code>av_free_packet()</code> 的定义位于 <code>libavcodec\avpacket.c</code></p><p><code>av_free_packet()</code> 调用 <code>av_buffer_unref()</code> 释放 AVPacket 中的数据，而后还调用了<code>av_packet_free_side_data()</code> 释放了 side_data（存储封装格式可以提供的额外的数据）。</p><h2 id="avio-open2"><a href="#avio-open2" class="headerlink" title="avio_open2()"></a>avio_open2()</h2><p>该函数用于打开 FFmpeg 的输入输出文件。<code>avio_open2()</code> 的声明位于 <code>libavformat\avio.h</code> 文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avio_open2</span><span class="params">(AVIOContext **s, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p><code>avio_open2()</code> 函数参数的含义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s：函数调用成功之后创建的AVIOContext结构体。</span><br><span class="line">url：输入输出协议的地址（文件也是一种“广义”的协议，对于文件来说就是文件的路径）。</span><br><span class="line">flags：打开地址的方式。可以选择只读，只写，或者读写。取值如下。</span><br><span class="line">AVIO_FLAG_READ：只读。</span><br><span class="line">AVIO_FLAG_WRITE：只写。</span><br><span class="line">AVIO_FLAG_READ_WRITE：读写。</span><br><span class="line">int_cb：目前还没有用过。</span><br><span class="line">options：目前还没有用过。</span><br></pre></td></tr></table></figure><p>函数调用结构图：</p><p><img src="/images/imageFFmpeg/Thor/avio_open2.png" alt="avio_open2"></p><h2 id="av-find-decoder-和-av-find-encoder"><a href="#av-find-decoder-和-av-find-encoder" class="headerlink" title="av_find_decoder() 和 av_find_encoder()"></a>av_find_decoder() 和 av_find_encoder()</h2><p><code>avcodec_find_encoder()</code> 用于查找 FFmpeg 的编码器，</p><p><code>avcodec_find_decoder()</code> 用于查找 FFmpeg 的解码器。</p><p><code>avcodec_find_encoder()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_encoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br></pre></td></tr></table></figure><p>函数的参数是一个编码器的 ID，返回查找到的编码器（没有找到就返回NULL）。</p><p><code>avcodec_find_decoder()</code> 的声明也位于 <code>libavcodec\avcodec.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br></pre></td></tr></table></figure><p>函数的参数是一个解码器的 ID，返回查找到的解码器（没有找到就返回NULL）。</p><p><code>avcodec_find_encoder()</code> 和 <code>avcodec_find_decoder()</code> 的函数调用关系图如下所示：</p><p><img src="/images/imageFFmpeg/Thor/avcodec_find_encoder.png" alt="函数调用关系图"></p><p><code>avcodec_find_encoder()</code> 的源代码位于 <code>libavcodec\utils.c</code></p><p><code>avcodec_find_encoder()</code> 调用了一个 <code>find_encdec()</code>，注意它的第二个参数是 1。</p><p><code>find_encdec()</code> 的源代码位于 <code>libavcodec\utils.c</code></p><p><code>find_encdec()</code> 中有一个循环，该循环会遍历 AVCodec 结构的链表，逐一比较输入的 ID 和每一个编码器的 ID，直到找到 ID 取值相等的编码器。</p><p>在这里有几点需要注意：</p><p>（1）first_avcodec 是一个全局变量，存储 AVCodec 链表的第一个元素。</p><p>（2）<code>remap_deprecated_codec_id()</code> 用于将一些过时的编码器 ID 映射到新的编码器 ID。</p><p>（3）函数的第二个参数 encoder 用于确定查找编码器还是解码器。当该值为 1 的时候，用于查找编码器，此时会调用 <code>av_codec_is_encoder()</code> 判断 AVCodec 是否为编码器；当该值为 0 的时候，用于查找解码器，此时会调用 <code>av_codec_is_decoder()</code> 判断 AVCodec 是否为解码器。</p><p><code>avcodec_find_decoder()</code> 的源代码位于 <code>libavcodec\utils.c</code></p><p><code>avcodec_find_decoder()</code> 同样调用了 <code>find_encdec()</code>，只是第 2 个参数设置为 0。</p><h2 id="avcodec-open2"><a href="#avcodec-open2" class="headerlink" title="avcodec_open2()"></a>avcodec_open2()</h2><p>该函数用于初始化一个视音频编解码器的 AVCodecContext。</p><p><code>avcodec_open2()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVCodec *codec, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>用中文简单转述一下avcodec_open2()各个参数的含义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avctx：需要初始化的 AVCodecContext。</span><br><span class="line">codec：输入的 AVCodec</span><br><span class="line">options：一些选项。例如使用 libx264 编码的时候，“preset”，“tune”等都可以通过该参数设置。</span><br></pre></td></tr></table></figure><p><code>avcodec_open2()</code> 函数调用关系非常简单，如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/avcodec_open2.png" alt="avcodec_open2"></p><p><code>avcodec_open2()</code> 的定义位于 <code>libavcodec\utils.c</code></p><p><code>avcodec_open2()</code> 的源代码量是非常长的，但是它的调用关系非常简单——它只调用了一个关键的函数，即 AVCodec 的 <code>init()</code>，后文将会对这个函数进行分析。</p><p>我们可以简单梳理一下 <code>avcodec_open2()</code> 所做的工作，如下所列：</p><p>（1）为各种结构体分配内存（通过各种 <code>av_malloc()</code> 实现）。</p><p>（2）将输入的 AVDictionary 形式的选项设置到 AVCodecContext。</p><p>（3）其他一些零零碎碎的检查，比如说检查编解码器是否处于 “实验” 阶段。</p><p>（4）如果是编码器，检查输入参数是否符合编码器的要求</p><p>（5）调用 AVCodec 的 <code>init()</code> 初始化具体的解码器。</p><p>前几步比较简单，不再分析。在这里我们分析一下第4步和第5步。</p><h3 id="检查输入参数是否符合编码器要求"><a href="#检查输入参数是否符合编码器要求" class="headerlink" title="检查输入参数是否符合编码器要求"></a>检查输入参数是否符合编码器要求</h3><p>在这里简单分析一下第 4 步，即 “检查输入参数是否符合编码器的要求”。这一步中检查了很多的参数，在这里我们随便选一个参数 pix_fmts（像素格式）看一下，如下所示。</p><details><summary>代码：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查像素格式</span></span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec-&gt;pix_fmts) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; avctx-&gt;codec-&gt;pix_fmts[i] != AV_PIX_FMT_NONE; i++)</span><br><span class="line">                <span class="keyword">if</span> (avctx-&gt;pix_fmt == avctx-&gt;codec-&gt;pix_fmts[i])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_NONE</span><br><span class="line">                &amp;&amp; !((avctx-&gt;codec_id == AV_CODEC_ID_MJPEG || avctx-&gt;codec_id == AV_CODEC_ID_LJPEG)</span><br><span class="line">                     &amp;&amp; avctx-&gt;strict_std_compliance &lt;= FF_COMPLIANCE_UNOFFICIAL)) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d"</span>, avctx-&gt;pix_fmt);</span><br><span class="line">                av_log(avctx, AV_LOG_ERROR, <span class="string">"Specified pixel format %s is invalid or not supported\n"</span>,</span><br><span class="line">                       (<span class="keyword">char</span> *)av_x_if_null(av_get_pix_fmt_name(avctx-&gt;pix_fmt), buf));</span><br><span class="line">                ret = AVERROR(EINVAL);</span><br><span class="line">                <span class="keyword">goto</span> free_and_end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||</span><br><span class="line">                avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||</span><br><span class="line">                avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||</span><br><span class="line">                avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||</span><br><span class="line">                avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ444P)</span><br><span class="line">                avctx-&gt;color_range = AVCOL_RANGE_JPEG;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></details><p>可以看出，该代码首先进入了一个 <code>for()</code> 循环，将 AVCodecContext 中设定的 <code>pix_fmt</code> 与编码器AVCodec 中的 <code>pix_fmts</code> 数组中的元素逐一比较。</p><p>先简单介绍一下 AVCodec 中的 <code>pix_fmts</code> 数组。AVCodec 中的 <code>pix_fmts</code> 数组存储了该种编码器支持的像素格式，并且规定以 AV_PIX_FMT_NONE（AV_PIX_FMT_NONE 取值为 -1）为结尾。例如，libx264 的 <code>pix_fmts</code> 数组的定义位于 <code>libavcodec\libx264.c</code>，如下所示。</p><details><summary>代码：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat pix_fmts_8bit[] = &#123;</span><br><span class="line">    AV_PIX_FMT_YUV420P,</span><br><span class="line">    AV_PIX_FMT_YUVJ420P,</span><br><span class="line">    AV_PIX_FMT_YUV422P,</span><br><span class="line">    AV_PIX_FMT_YUVJ422P,</span><br><span class="line">    AV_PIX_FMT_YUV444P,</span><br><span class="line">    AV_PIX_FMT_YUVJ444P,</span><br><span class="line">    AV_PIX_FMT_NV12,</span><br><span class="line">    AV_PIX_FMT_NV16,</span><br><span class="line">    AV_PIX_FMT_NONE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>从 <code>pix_fmts_8bit</code> 的定义可以看出 libx264 主要支持的是以 YUV 为主的像素格式。</p><p>现在回到 “检查输入 <code>pix_fmt</code> 是否符合编码器的要求” 的那段代码。如果 <code>for()</code> 循环从 <code>AVCodec-&gt;pix_fmts</code> 数组中找到了符合 <code>AVCodecContext-&gt;pix_fmt</code> 的像素格式，或者完成了 <code>AVCodec-&gt;pix_fmts</code> 数组的遍历，都会跳出循环。如果发现 <code>AVCodec-&gt;pix_fmts</code> 数组中索引为 <code>i</code> 的元素是 AV_PIX_FMT_NONE（即最后一个元素，取值为 -1）的时候，就认为没有找到合适的像素格式，并且最终提示错误信息。</p><h3 id="AVCodec-gt-init"><a href="#AVCodec-gt-init" class="headerlink" title="AVCodec-&gt;init()"></a>AVCodec-&gt;init()</h3><p><code>avcodec_open2()</code> 中最关键的一步就是调用 AVCodec 的 <code>init()</code> 方法初始化具体的编码器。AVCodec 的 <code>init()</code> 是一个函数指针，指向具体编解码器中的初始化函数。这里我们以 libx264 为例，看一下它对应的 AVCodec 的定义。</p><p>libx264 对应的 AVCodec 的定义位于 <code>libavcodec\libx264.c</code></p><details><summary>代码：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AVCodec ff_libx264_encoder = &#123;</span><br><span class="line">    .name             = <span class="string">"libx264"</span>,</span><br><span class="line">    .long_name        = NULL_IF_CONFIG_SMALL(<span class="string">"libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"</span>),</span><br><span class="line">    .type             = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id               = AV_CODEC_ID_H264,</span><br><span class="line">    .priv_data_size   = <span class="keyword">sizeof</span>(X264Context),</span><br><span class="line">    .init             = X264_init,</span><br><span class="line">    .encode2          = X264_frame,</span><br><span class="line">    .close            = X264_close,</span><br><span class="line">    .capabilities     = CODEC_CAP_DELAY | CODEC_CAP_AUTO_THREADS,</span><br><span class="line">    .priv_class       = &amp;x264_class,</span><br><span class="line">    .defaults         = x264_defaults,</span><br><span class="line">    .init_static_data = X264_init_static,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>可以看出在 <code>ff_libx264_encoder</code> 中 <code>init()</code> 指向 <code>X264_init()</code> 。<code>X264_init()</code> 的定义同样位于<code>libavcodec\libx264.c</code></p><p><code>X264_init()</code> 的代码以后研究 X264 的时候再进行细节的分析，在这里简单记录一下它做的两项工作：</p><p>（1）设置 X264Context 的参数。X264Context 主要完成了 libx264 和 FFmpeg 对接的功能。可以看出代码主要在设置一个 params 结构体变量，该变量的类型即是 x264 中存储参数的结构体 <code>x264_param_t</code>。（2）调用 libx264 的 API 进行编码器的初始化工作。例如调用 <code>x264_param_default()</code> 设置默认参数，调用 <code>x264_param_apply_profile()</code> 设置 profile，调用 <code>x264_encoder_open()</code> 打开编码器等等。</p><p>最后附上 X264Context 的定义，位于 <code>libavcodec\libx264.c</code></p><h2 id="avcodec-close"><a href="#avcodec-close" class="headerlink" title="avcodec_close()"></a>avcodec_close()</h2><p>该函数用于关闭编码器。<code>avcodec_close()</code> 函数的声明位于 <code>libavcodec\avcodec.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_close</span><span class="params">(AVCodecContext *avctx)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数只有一个参数，就是需要关闭的编码器的 AVCodecContext。</p><p>函数的调用关系图如下所示：</p><p><img src="/images/imageFFmpeg/Thor/avcodec_close.png" alt="avcodec_close"></p><p><code>avcodec_close()</code> 的定义位于 <code>libavcodec\utils.c</code></p><p>从 <code>avcodec_close()</code> 的定义可以看出，该函数释放 AVCodecContext 中有关的变量，并且调用了 AVCodec 的 <code>close()</code> 关闭了解码器。</p><h1 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h1><h2 id="图解-FFMPEG-打开媒体的函数-avformat-open-input"><a href="#图解-FFMPEG-打开媒体的函数-avformat-open-input" class="headerlink" title="图解 FFMPEG 打开媒体的函数 avformat_open_input"></a>图解 FFMPEG 打开媒体的函数 avformat_open_input</h2><p>FFMPEG打开媒体的的过程开始于avformat_open_input，因此该函数的重要性不可忽视。</p><p>在该函数中，FFMPEG完成了：</p><ul><li><p>输入输出结构体 AVIOContext 的初始化；</p></li><li><p>输入数据的协议（例如 RTMP，或者 file）的识别（通过一套评分机制）:</p><ul><li>判断文件名的后缀 </li><li>读取文件头的数据进行比对；</li></ul></li><li><p>使用获得最高分的文件协议对应的 URLProtocol，通过函数指针的方式，与 FFMPEG 连接（非专业用词）；</p></li></ul><p>剩下的就是调用该 URLProtocol 的函数进行 open, read 等操作了</p><p>以下是通过 eclipse+MinGW 调试 FFMPEG 源代码获得的函数调用关系图：</p><p><img src="/images/imageFFmpeg/Thor/%E5%9B%BE%E8%A7%A3FFMPEG%E6%89%93%E5%BC%80%E5%AA%92%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0avformat_open_input.png" alt></p><p>可见最终都调用了 URLProtocol 结构体中的函数指针。</p><p>URLProtocol 结构如下，是一大堆函数指针的集合（avio.h文件）</p><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> (*url_open)(URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_read)(URLContext *h, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size);</span><br><span class="line">    <span class="keyword">int</span> (*url_write)(URLContext *h, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_seek)(URLContext *h, <span class="keyword">int64_t</span> pos, <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int</span> (*url_close)(URLContext *h);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> (*url_read_pause)(URLContext *h, <span class="keyword">int</span> pause);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_read_seek)(URLContext *h, <span class="keyword">int</span> stream_index,</span><br><span class="line">                             <span class="keyword">int64_t</span> timestamp, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_file_handle)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> priv_data_size;</span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_data_class;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> (*url_check)(URLContext *h, <span class="keyword">int</span> mask);</span><br><span class="line">&#125; URLProtocol;</span><br></pre></td></tr></table></figure></details><p>URLProtocol 功能就是完成各种输入协议的读写等操作</p><p>但输入协议种类繁多，它是怎样做到 “大一统” 的呢？</p><p>原来，每个具体的输入协议都有自己对应的 URLProtocol。</p><p>比如 file 协议（FFMPEG 把文件也当做一种特殊的协议）（<code>*file.c</code> 文件）</p><details><summary>代码：</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">URLProtocol ff_pipe_protocol = &#123;</span><br><span class="line">    .name                = <span class="string">"pipe"</span>,</span><br><span class="line">    .url_open            = pipe_open,</span><br><span class="line">    .url_read            = file_read,</span><br><span class="line">    .url_write           = file_write,</span><br><span class="line">    .url_get_file_handle = file_get_handle,</span><br><span class="line">    .url_check           = file_check,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>或者rtmp协议（此处使用了librtmp）（librtmp.c文件）</p><details><summary>代码：</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URLProtocol ff_rtmp_protocol = &#123;</span><br><span class="line">    .name                = <span class="string">"rtmp"</span>,</span><br><span class="line">    .url_open            = rtmp_open,</span><br><span class="line">    .url_read            = rtmp_read,</span><br><span class="line">    .url_write           = rtmp_write,</span><br><span class="line">    .url_close           = rtmp_close,</span><br><span class="line">    .url_read_pause      = rtmp_read_pause,</span><br><span class="line">    .url_read_seek       = rtmp_read_seek,</span><br><span class="line">    .url_get_file_handle = rtmp_get_file_handle,</span><br><span class="line">    .priv_data_size      = <span class="keyword">sizeof</span>(RTMP),</span><br><span class="line">    .flags               = URL_PROTOCOL_FLAG_NETWORK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>可见它们把各自的函数指针都赋值给了 URLProtocol 结构体的函数指针</p><p>因此 <code>avformat_open_input</code> 只需调用 url_open, url_read 这些函数就可以完成各种具体输入协议的 open, read 等操作了</p><h2 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input()"></a>avformat_open_input()</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy8xMTg4NTgxMw==" title="https://blog.csdn.net/leixiaohua1020/article/details/11885813">FFMPEG源码分析：avformat_open_input()（媒体打开函数）<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDA2NDcxNQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/44064715">avformat_open_input()<i class="fa fa-external-link"></i></span></p></blockquote><p>个人感觉这个函数确实太重要了，可以算作 FFmpeg 的 “灵魂”</p><p>函数用于打开多媒体数据并且获得一些相关的信息。它的声明位于 <code>libavformat\avformat.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *filename, AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps：函数调用成功之后处理过的 AVFormatContext 结构体。</span><br><span class="line">file：打开的视音频流的 URL。</span><br><span class="line">fmt：强制指定 AVFormatContext 中 AVInputFormat 的。这个参数一般情况下可以设置为 NULL，这样 FFmpeg 可以自动检测 AVInputFormat。</span><br><span class="line">dictionay：附加的一些选项，一般情况下可以设置为 NULL。</span><br></pre></td></tr></table></figure><p>函数执行成功的话，其返回值大于等于 0。</p><p>函数调用结构图如下所示：</p><p><img src="/images/imageFFmpeg/Thor/avformat_open_input.png" alt="avformat_open_input"></p><p><code>avformat_open_input()</code> 定义位于 <code>libavformat\utils.c</code> 中</p><p><code>avformat_open_input()</code> 源代码比较长，一部分是一些容错代码，比如说如果发现传入的 AVFormatContext 指针没有初始化过，就调用 <code>avformat_alloc_context()</code> 初始化该结构体；还有一部分是针对一些格式做的特殊处理，比如 id3v2 信息的处理等等。有关上述两种信息不再详细分析，在这里只选择它关键的两个函数进行分析：</p><ul><li><p><strong><code>init_input()</code></strong>：绝大部分初始化工作都是在这里做的。</p></li><li><p><strong><code>s-&gt;iformat-&gt;read_header()</code></strong>：读取多媒体数据文件头，根据视音频流创建相应的 AVStream。</p></li></ul><h3 id="init-input"><a href="#init-input" class="headerlink" title="init_input()"></a>init_input()</h3><p><code>init_input()</code> 作为一个内部函数，竟然包含了一行注释（一般内部函数都没有注释），足可以看出它的重要性。它的主要工作就是打开输入的视频数据并且探测视频的格式。该函数的定义位于 <code>libavformat\utils.c</code></p><details><summary>代码：</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Open input file and probe the format if necessary. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_input</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                      AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVProbeData pd = &#123; filename, <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> score = AVPROBE_SCORE_RETRY;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb) &#123;</span><br><span class="line">        s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;iformat)</span><br><span class="line">            <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                         s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE)</span><br><span class="line">            av_log(s, AV_LOG_WARNING, <span class="string">"Custom AVIOContext makes no sense and "</span></span><br><span class="line">                                      <span class="string">"will be ignored with AVFMT_NOFILE format.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) ||</span><br><span class="line">        (!s-&gt;iformat &amp;&amp; (s-&gt;iformat = av_probe_input_format2(&amp;pd, <span class="number">0</span>, &amp;score))))</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((ret = avio_open2(&amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags,</span><br><span class="line">                          &amp;s-&gt;interrupt_callback, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                 s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这个函数在短短的几行代码中包含了好几个 return，因此逻辑还是有点复杂的，我们可以梳理一下：</p><p>在函数的开头的 score 变量是一个判决 AVInputFormat 的分数的门限值，如果最后得到的 AVInputFormat 的分数低于该门限值，就认为没有找到合适的 AVInputFormat 。</p><p>FFmpeg 内部判断封装格式的原理实际上是对每种 AVInputFormat 给出一个分数，满分是 100 分，越有可能正确的 AVInputFormat 给出的分数就越高。最后选择分数最高的 AVInputFormat 作为推测结果。score 的值是一个宏定义 AVPROBE_SCORE_RETRY，我们可以看一下它的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4)</span></span><br></pre></td></tr></table></figure><p>其中 AVPROBE_SCORE_MAX 是 score 的最大值，取值是 100：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_MAX       100 <span class="comment">///&lt; maximum score</span></span></span><br></pre></td></tr></table></figure><p>由此我们可以得出 score 取值是 25，即如果推测后得到的最佳 AVInputFormat 的分值低于 25，就认为没有找到合适的 AVInputFormat。</p><p>整个函数的逻辑大体如下：</p><p>（1）当使用了自定义的 AVIOContext 的时候（AVFormatContext 中的 AVIOContext 不为空，即 <code>s-&gt;pb!=NULL</code>），如果指定了 AVInputFormat 就直接返回，如果没有指定就调用 <code>av_probe_input_buffer2()</code> 推测 AVInputFormat。这一情况出现的不算很多，但是当我们从内存中读取数据的时候（需要初始化自定义的 AVIOContext），就会执行这一步骤。</p><p>（2）在更一般的情况下，如果已经指定了 AVInputFormat，就直接返回；如果没有指定 AVInputFormat，就调用 <code>av_probe_input_format(NULL,…)</code> 根据文件路径判断文件格式。这里特意把 <code>av_probe_input_format()</code> 的第 1 个参数写成 “NULL”，是为了强调这个时候实际上并没有给函数提供输入数据，此时仅仅通过文件路径推测 AVInputFormat。</p><p>（3）如果发现通过文件路径判断不出来文件格式，那么就需要打开文件探测文件格式了，这个时候会首先调用 <code>avio_open2()</code> 打开文件，然后调用 <code>av_probe_input_buffer2()</code> 推测 AVInputFormat。</p><h2 id="avformat-find-stream-info"><a href="#avformat-find-stream-info" class="headerlink" title="avformat_find_stream_info()"></a>avformat_find_stream_info()</h2><p>该函数可以读取一部分视音频数据并且获得一些相关的信息。</p><p><code>avformat_find_stream_info()</code> 的声明位于 <code>libavformat\avformat.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>简单解释一下它的参数的含义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic：输入的 AVFormatContext。</span><br><span class="line">options：额外的选项，目前没有深入研究过。</span><br></pre></td></tr></table></figure><p>函数正常执行后返回值大于等于 0。</p><p>PS：由于该函数比较复杂，所以只看了一部分代码，以后有时间再进一步分析。</p><p>函数的调用关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/avformat_find_stream_info.png" alt="avformat_find_stream_info"></p><p><code>avformat_find_stream_info()</code> 的定义位于 <code>libavformat\utils.c</code></p><p>由于<code>avformat_find_stream_info()</code> 代码比较长，难以全部分析，在这里只能简单记录一下它的要点。该函数主要用于给每个媒体流（音频/视频）的 AVStream 结构体赋值。我们大致浏览一下这个函数的代码，会发现它其实已经实现了解码器的查找，解码器的打开，视音频帧的读取，视音频帧的解码等工作。换句话说，该函数实际上已经“走通”的解码的整个流程。下面看一下除了成员变量赋值之外，该函数的几个关键流程。</p><ul><li><p>查找解码器：<code>find_decoder()</code></p></li><li><p>打开解码器：<code>avcodec_open2()</code></p></li><li><p>读取完整的一帧压缩编码的数据：<code>read_frame_internal()</code></p><p>注：<code>av_read_frame()</code> 内部实际上就是调用的 <code>read_frame_internal()</code>。</p></li><li><p>解码一些压缩编码数据：<code>try_decode_frame()</code></p></li></ul><h2 id="av-read-frame"><a href="#av-read-frame" class="headerlink" title="av_read_frame()"></a>av_read_frame()</h2><p>ffmpeg 中的 <code>av_read_frame()</code> 的作用是读取码流中的音频若干帧或者视频一帧。例如，解码视频的时候，每解码一个视频帧，需要先调用 <code>av_read_frame()</code> 获得一帧视频的压缩数据，然后才能对该数据进行解码（例如 H.264 中一帧压缩数据通常对应一个 NAL）。</p><p>上代码之前，先参考了其他人对 <code>av_read_frame()</code> 的解释，在此做一个参考：</p><blockquote><p>通过 <code>av_read_packet()</code>，读取一个包，需要说明的是此函数必须是包含整数帧的，不存在半帧的情况，以 ts 流为例，是读取一个完整的 PES 包（一个完整 pes 包包含若干视频或音频 es 包），读取完毕后，通过 <code>av_parser_parse2()</code> 分析出视频一帧（或音频若干帧），返回，下次进入循环的时候，如果上次的数据没有完全取完，则 <code>st = s-&gt;cur_st</code> ; 不会是 NULL，即再此进入 <code>av_parser_parse2()</code> 流程，而不是下面的 <code>av_read_packet（）</code> 流程，这样就保证了，如果读取一次包含了 N 帧视频数据（以视频为例），则调用 <code>av_read_frame（）</code> N 次都不会去读数据，而是返回第一次读取的数据，直到全部解析完毕。</p></blockquote><p><code>av_read_frame()</code> 的声明位于 <code>libavformat\avformat.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure><p><code>av_read_frame()</code> 使用方法在注释中写得很详细，用中文简单描述一下它的两个参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s：输入的AVFormatContext</span><br><span class="line">pkt：输出的AVPacket</span><br></pre></td></tr></table></figure><p>如果返回 0 则说明读取正常。</p><p>函数调用结构图如下所示：</p><p><img src="/images/imageFFmpeg/Thor/av_read_frame.png" alt="av_read_frame"></p><p><code>av_read_frame()</code> 的定义位于 <code>libavformat\utils.c</code></p><p><code>read_frame_internal()</code> 代码比较长，这里只简单看一下它前面的部分。它前面部分有 2 步是十分关键的：</p><p>（1）调用了 <code>ff_read_packet()</code> 从相应的 AVInputFormat 读取数据。</p><p>（2）如果媒体频流需要使用 AVCodecParser，则调用 <code>parse_packet()</code> 解析相应的 AVPacket。</p><p><code>ff_read_packet()</code> 中最关键的地方就是调用了 AVInputFormat 的 <code>read_packet()</code> 方法。 AVInputFormat 的 <code>read_packet()</code> 是一个函数指针，指向当前的 AVInputFormat 的读取数据的函数。在这里我们以 FLV 封装格式对应的 AVInputFormat 为例，看看 <code>read_packet()</code> 的实现函数是什么样子的。</p><p>FLV 封装格式对应的 AVInputFormat 的定义位于 <code>libavformat\flvdec.c</code></p><details><summary>代码：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AVInputFormat ff_flv_demuxer = &#123;</span><br><span class="line">    .name           = <span class="string">"flv"</span>,</span><br><span class="line">    .long_name      = NULL_IF_CONFIG_SMALL(<span class="string">"FLV (Flash Video)"</span>),</span><br><span class="line">    .priv_data_size = <span class="keyword">sizeof</span>(FLVContext),</span><br><span class="line">    .read_probe     = flv_probe,</span><br><span class="line">    .read_header    = flv_read_header,</span><br><span class="line">    .read_packet    = flv_read_packet,</span><br><span class="line">    .read_seek      = flv_read_seek,</span><br><span class="line">    .read_close     = flv_read_close,</span><br><span class="line">    .extensions     = <span class="string">"flv"</span>,</span><br><span class="line">    .priv_class     = &amp;flv_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>从 <code>ff_flv_demuxer</code> 的定义可以看出，<code>read_packet()</code> 对应的是 <code>flv_read_packet()</code> 函数。在看 <code>flv_read_packet()</code> 函数之前，我们先回顾一下 FLV 封装格式的结构，如下图所示。</p><p>PS：原图是网上找的，感觉画的很清晰，比官方的 Video File Format Specification 更加通俗易懂。但是图中有一个错误，就是 TagHeader 中的 StreamID 字段的长度写错了（查看了一下官方标准，应该是 3 字节，现在已经改过来了）。</p><p><img src="/images/imageFFmpeg/Thor/FLV%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F.png" alt="FLV封装格式"></p><p>从图中可以看出，FLV 文件体部分是由一个一个的 Tag 连接起来的（中间间隔着 Previous Tag Size）。每个 Tag 包含了 Tag Header 和 Tag Data 两个部分。</p><p>Tag Data 根据 Tag 的 Type 不同而不同：可以分为音频 Tag Data，视频 Tag Data 以及 Script Tag Data。下面简述一下音频 Tag Data 和视频 Tag Data。</p><h3 id="Audio-Tag-Data"><a href="#Audio-Tag-Data" class="headerlink" title="Audio Tag Data"></a>Audio Tag Data</h3><p>Audio Tag在官方标准中定义如下。</p><p><img src="/images/imageFFmpeg/Thor/AudioTag.png" alt="Audio Tag"></p><p>Audio Tag 开始的第 1 个字节包含了音频数据的参数信息，从第 2 个字节开始为音频流数据。<br>第 1 个字节的前 4 位的数值表示了音频数据格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 = Linear PCM, platform endian</span><br><span class="line">1 = ADPCM</span><br><span class="line">2 = MP3</span><br><span class="line">3 = Linear PCM, little endian</span><br><span class="line">4 = Nellymoser 16-kHz mono</span><br><span class="line">5 = Nellymoser 8-kHz mono</span><br><span class="line">6 = Nellymoser</span><br><span class="line">7 = G.711 A-law logarithmic PCM</span><br><span class="line">8 = G.711 mu-law logarithmic PCM</span><br><span class="line">9 = reserved</span><br><span class="line">10 = AAC</span><br><span class="line">14 = MP3 8-Khz</span><br><span class="line">15 = Device-specific sound</span><br></pre></td></tr></table></figure><p>第 1 个字节的第 5-6 位的数值表示采样率：<code>0 = 5.5kHz，1 = 11KHz，2 = 22 kHz，3 = 44 kHz</code>。</p><p>第 1 个字节的第7位表示采样精度：<code>0 = 8bits，1 = 16bits</code>。</p><p>第 1 个字节的第8位表示音频类型：<code>0 = sndMono，1 = sndStereo</code>。</p><p>其中，当音频编码为 AAC 的时候，第一个字节后面存储的是 AACAUDIODATA，格式如下所示。</p><p><img src="/images/imageFFmpeg/Thor/AACAUDIODATA%E6%A0%BC%E5%BC%8F.png" alt="AACAUDIODATA格式"></p><h3 id="Video-Tag-Data"><a href="#Video-Tag-Data" class="headerlink" title="Video Tag Data"></a>Video Tag Data</h3><p>Video Tag在官方标准中的定义如下：</p><p><img src="/images/imageFFmpeg/Thor/VideoTag.png" alt="Video Tag"></p><p>Video Tag 也用开始的第 1 个字节包含视频数据的参数信息，从第 2 个字节为视频流数据。</p><p>第 1 个字节的前 4 位的数值表示帧类型（FrameType）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1: keyframe (for AVC, a seekableframe)（关键帧）</span><br><span class="line">2: inter frame (for AVC, a nonseekableframe)</span><br><span class="line">3: disposable inter frame (H.263only)</span><br><span class="line">4: generated keyframe (reservedfor server use only)</span><br><span class="line">5: video info/command frame</span><br></pre></td></tr></table></figure><p>第 1 个字节的后 4 位的数值表示视频编码 ID（CodecID）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1: JPEG (currently unused)</span><br><span class="line">2: Sorenson H.263</span><br><span class="line">3: Screen video</span><br><span class="line">4: On2 VP6</span><br><span class="line">5: On2 VP6 with alpha channel</span><br><span class="line">6: Screen video version 2</span><br><span class="line">7: AVC</span><br></pre></td></tr></table></figure><p>其中，当音频编码为 AVC（H.264）的时候，第一个字节后面存储的是 AVCVIDEOPACKET，格式如下所示。</p><p><img src="/images/imageFFmpeg/Thor/AVCVIDEOPACKET%E6%A0%BC%E5%BC%8F.png" alt="AVCVIDEOPACKET格式"></p><p>了解了 FLV 的基本格式之后，就可以看一下 FLV 解析 Tag 的函数 <code>flv_read_packet()了</code>。</p><p><code>flv_read_packet()</code> 的定义位于 <code>libavformat\flvdec.c</code></p><p><code>flv_read_packet()</code> 的代码比较长，但是逻辑比较简单。它的主要功能就是根据 FLV 文件格式的规范，逐层解析 Tag 以及 TagData，获取 Tag 以及 TagData 中的信息。比较关键的地方已经写上了注释，不再详细叙述。</p><p><code>parse_packet()</code> 给需要 AVCodecParser 的媒体流提供解析 AVPacket 的功能。</p><p>从代码中可以看出，最终调用了相应 AVCodecParser 的 <code>av_parser_parse2()</code> 函数，解析出来 AVPacket。此后根据解析的信息还进行了一系列的赋值工作，不再详细叙述。</p><h2 id="avcodec-decode-video2"><a href="#avcodec-decode-video2" class="headerlink" title="avcodec_decode_video2()"></a>avcodec_decode_video2()</h2><p>ffmpeg 中的 <code>avcodec_decode_video2()</code> 的作用是解码一帧视频数据。输入一个压缩编码的结构体 AVPacket，输出一个解码后的结构体 AVFrame。该函数的声明位于 <code>libavcodec\avcodec.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_decode_video2</span><span class="params">(AVCodecContext *avctx, AVFrame *picture,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> *got_picture_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> AVPacket *avpkt)</span></span>;</span><br></pre></td></tr></table></figure><p>查看源代码之后发现，这个函数竟然十分的简单，源代码位于 <code>libavcodec\utils.c</code></p><p>从代码中可以看出，<code>avcodec_decode_video2()</code> 主要做了以下几个方面的工作：</p><p>（1）对输入的字段进行了一系列的检查工作：例如宽高是否正确，输入是否为视频等等。</p><p>（2）通过 <code>ret = avctx-&gt;codec-&gt;decode(avctx, picture, got_picture_ptr,&amp;tmp)</code> 这句代码，调用了相应 AVCodec 的 <code>decode()</code> 函数，完成了解码操作。</p><p>（3）对得到的 AVFrame 的一些字段进行了赋值，例如宽高、像素格式等等。</p><p>其中第二部是关键的一步，它调用了 AVCodec 的 <code>decode()</code> 方法完成了解码。AVCodec 的 <code>decode()</code> 方法是一个函数指针，指向了具体解码器的解码函数。在这里我们以 H.264 解码器为例，看一下解码的实现过程。H.264 解码器对应的 AVCodec 的定义位于 <code>libavcodec\h264.c</code>，如下所示。</p><details><summary>代码：</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AVCodec ff_h264_decoder = &#123;</span><br><span class="line">    .name                  = <span class="string">"h264"</span>,</span><br><span class="line">    .long_name             = NULL_IF_CONFIG_SMALL(<span class="string">"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"</span>),</span><br><span class="line">    .type                  = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id                    = AV_CODEC_ID_H264,</span><br><span class="line">    .priv_data_size        = <span class="keyword">sizeof</span>(H264Context),</span><br><span class="line">    .init                  = ff_h264_decode_init,</span><br><span class="line">    .close                 = h264_decode_end,</span><br><span class="line">    .decode                = h264_decode_frame,</span><br><span class="line">    .capabilities          = <span class="comment">/*CODEC_CAP_DRAW_HORIZ_BAND |*/</span> CODEC_CAP_DR1 |</span><br><span class="line">                             CODEC_CAP_DELAY | CODEC_CAP_SLICE_THREADS |</span><br><span class="line">                             CODEC_CAP_FRAME_THREADS,</span><br><span class="line">    .flush                 = flush_dpb,</span><br><span class="line">    .init_thread_copy      = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy),</span><br><span class="line">    .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context),</span><br><span class="line">    .profiles              = NULL_IF_CONFIG_SMALL(profiles),</span><br><span class="line">    .priv_class            = &amp;h264_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>从 <code>ff_h264_decoder</code> 的定义可以看出，<code>decode()</code> 指向了 <code>h264_decode_frame()</code> 函数。</p><p>从 <code>h264_decode_frame()</code> 的定义可以看出，它调用了 <code>decode_nal_units()</code> 完成了具体的 H.264 解码工作。</p><h2 id="avformat-close-input"><a href="#avformat-close-input" class="headerlink" title="avformat_close_input()"></a>avformat_close_input()</h2><p>该函数用于关闭一个 AVFormatContext，一般情况下是和 <code>avformat_open_input()</code> 成对使用的。</p><p>函数的调用关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/avformat_close_input.png" alt="avformat_close_input"></p><p><code>avformat_close_input()</code> 的源代码位于 <code>libavformat\utils.c</code></p><p>从源代码中可以看出，<code>avformat_close_input()</code> 主要做了以下几步工作：</p><p>（1）调用 AVInputFormat 的 <code>read_close()</code> 方法关闭输入流</p><p>（2）调用 <code>avformat_free_context()</code> 释放 AVFormatContext</p><p>（3）调用 <code>avio_close()</code> 关闭并且释放 AVIOContext</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="avformat-alloc-output-context2"><a href="#avformat-alloc-output-context2" class="headerlink" title="avformat_alloc_output_context2()"></a>avformat_alloc_output_context2()</h2><p>在基于 FFmpeg 的视音频编码器程序中，该函数通常是第一个调用的函数（除了组件注册函数 <code>av_register_all()</code>）。</p><p><code>avformat_alloc_output_context2()</code> 函数可以初始化一个用于输出的 AVFormatContext 结构体。它的声明位于 <code>libavformat\avformat.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_alloc_output_context2</span><span class="params">(AVFormatContext **ctx, AVOutputFormat *oformat,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">char</span> *format_name, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure><p>代码中的英文注释写的已经比较详细了，在这里拿中文简单叙述一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx：函数调用成功之后创建的AVFormatContext结构体。</span><br><span class="line">oformat：指定AVFormatContext中的AVOutputFormat，用于确定输出格式。如果指定为NULL，可以设定后两个参数（format_name或者filename）由FFmpeg猜测输出格式。</span><br><span class="line">PS：使用该参数需要自己手动获取AVOutputFormat，相对于使用后两个参数来说要麻烦一些。</span><br><span class="line">format_name：指定输出格式的名称。根据格式名称，FFmpeg会推测输出格式。输出格式可以是“flv”，“mkv”等等。</span><br><span class="line">filename：指定输出文件的名称。根据文件名称，FFmpeg会推测输出格式。文件名称可以是“xx.flv”，“yy.mkv”等等。</span><br></pre></td></tr></table></figure><p>函数执行成功的话，其返回值大于等于0。</p><p>首先贴出来最终分析得出的函数调用结构图，如下所示：</p><p><img src="/images/imageFFmpeg/Thor/avformat_alloc_output_context2.png" alt="avformat_alloc_output_context2"></p><p><code>avformat_alloc_output_context2()</code> 的函数定义位于 <code>libavformat\mux.c</code></p><p>从代码中可以看出，<code>avformat_alloc_output_context2()</code> 的流程如要包含以下 2 步：</p><p>1)    调用 <code>avformat_alloc_context()</code> 初始化一个默认的 AVFormatContext。</p><p>2)    如果指定了输入的 AVOutputFormat，则直接将输入的 AVOutputFormat 赋值给AVOutputFormat 的 oformat。如果没有指定输入的 AVOutputFormat，就需要根据文件格式名称或者文件名推测输出的 AVOutputFormat。无论是通过文件格式名称还是文件名推测输出格式，都会调用一个函数 <code>av_guess_format()</code>。</p><p><code>avformat_alloc_context()</code> 首先调用 <code>av_malloc()</code> 为 AVFormatContext 分配一块内存。然后调用了一个函数 <code>avformat_get_context_defaults()</code> 用于给 AVFormatContext 设置默认值</p><p><code>avformat_alloc_context()</code> 首先调用 <code>memset()</code> 将 AVFormatContext 的内存置零；然后指定它的AVClass（指定了 AVClass 之后，该结构体就支持和 AVOption 相关的功能）；最后调用 <code>av_opt_set_defaults()</code> 给 AVFormatContext 的成员变量设置默认值（<code>av_opt_set_defaults()</code> 就是和 AVOption 有关的一个函数，专门用于给指定的结构体设定默认值，此处暂不分析）。</p><p><code>av_guess_format()</code> 中使用一个整型变量 score 记录每种输出格式的匹配程度。函数中包含了一个 <code>while()</code> 循环，该循环利用函数 <code>av_oformat_next()</code> 遍历 FFmpeg 中所有的 AVOutputFormat，并逐一计算每个输出格式的 score。具体的计算过程分成如下几步：</p><p>1)    如果封装格式名称匹配，score 增加 100。匹配中使用了函数 <code>av_match_name()</code>。</p><p>2)    如果 mime 类型匹配，score 增加 10。匹配直接使用字符串比较函数 <code>strcmp()</code>。</p><p>3)    如果文件名称的后缀匹配，score 增加 5。匹配中使用了函数 <code>av_match_ext()</code>。</p><p><code>while()</code> 循环结束后，得到得分最高的格式，就是最匹配的格式。</p><p>下面看一下一个 AVOutputFormat 的实例，就可以理解 “封装格式名称”，“mine类型”，“文件名称后缀” 这些概念了。下面是 flv 格式的视音频复用器（Muxer）对应的 AVOutputFormat 格式的变量 <code>ff_flv_muxer</code>。</p><details><summary>代码：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AVOutputFormat ff_flv_muxer = &#123;</span><br><span class="line">    .name           = <span class="string">"flv"</span>,</span><br><span class="line">    .long_name      = NULL_IF_CONFIG_SMALL(<span class="string">"FLV (Flash Video)"</span>),</span><br><span class="line">    .mime_type      = <span class="string">"video/x-flv"</span>,</span><br><span class="line">    .extensions     = <span class="string">"flv"</span>,</span><br><span class="line">    .priv_data_size = <span class="keyword">sizeof</span>(FLVContext),</span><br><span class="line">    .audio_codec    = CONFIG_LIBMP3LAME ? AV_CODEC_ID_MP3 : AV_CODEC_ID_ADPCM_SWF,</span><br><span class="line">    .video_codec    = AV_CODEC_ID_FLV1,</span><br><span class="line">    .write_header   = flv_write_header,</span><br><span class="line">    .write_packet   = flv_write_packet,</span><br><span class="line">    .write_trailer  = flv_write_trailer,</span><br><span class="line">    .codec_tag      = (<span class="keyword">const</span> AVCodecTag* <span class="keyword">const</span> []) &#123;</span><br><span class="line">                          flv_video_codec_ids, flv_audio_codec_ids, <span class="number">0</span></span><br><span class="line">                      &#125;,</span><br><span class="line">    .flags          = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS |</span><br><span class="line">                      AVFMT_TS_NONSTRICT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h2 id="avformat-write-header"><a href="#avformat-write-header" class="headerlink" title="avformat_write_header()"></a>avformat_write_header()</h2><p>FFmpeg 的写文件用到的 3 个函数：</p><ul><li><strong><code>avformat_write_header()</code></strong></li><li><strong><code>av_write_frame()</code></strong></li><li><strong><code>av_write_trailer()</code></strong></li></ul><p>其中 <code>av_write_frame()</code> 用于写视频数据，<code>avformat_write_header()</code> 用于写视频文件头，而 <code>av_write_trailer()</code> 用于写视频文件尾。</p><p>本文首先分析<code>avformat_write_header()</code>。</p><p>PS：需要注意的是，尽管这 3 个函数功能是配套的，但是它们的前缀却不一样，写文件头 Header 的函数前缀是“<code>avformat_</code>”，其他两个函数前缀是“<code>av_</code>”（不太明白其中的原因）。</p><p><code>avformat_write_header()</code> 的声明位于 <code>libavformat\avformat.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_write_header</span><span class="params">(AVFormatContext *s, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>简单解释一下它的参数的含义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s：用于输出的AVFormatContext。</span><br><span class="line">options：额外的选项，目前没有深入研究过，一般为NULL。</span><br></pre></td></tr></table></figure><p>函数正常执行后返回值等于 0。</p><p><code>avformat_write_header()</code> 的调用关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/avformat_write_header.png" alt="avformat_write_header"></p><p><code>avformat_write_header()</code> 的定义位于 <code>libavformat\mux.c</code></p><p>从源代码可以看出，<code>avformat_write_header()</code> 完成了以下工作：</p><p>（1）调用 <code>init_muxer()</code> 初始化复用器</p><p>（2）调用 AVOutputFormat 的 <code>write_header()</code></p><p><code>init_muxer()</code> 代码很长，但是它所做的工作比较简单，可以概括成两个字：检查。函数的流程可以概括成以下几步：</p><p>（1）将传入的 AVDictionary 形式的选项设置到 AVFormatContext</p><p>（2）遍历 AVFormatContext 中的每个 AVStream，并作如下检查：</p><ul><li><p>a) AVStream 的 time_base 是否正确设置。如果发现 AVStream 的 time_base 没有设置，则会调用 <code>avpriv_set_pts_info()</code> 进行设置。</p></li><li><p>b) 对于音频，检查采样率设置是否正确；对于视频，检查宽、高、宽高比。</p></li><li><p>c) 其他一些检查，不再详述。</p></li></ul><p><strong>AVOutputFormat-&gt;write_header()</strong></p><p><code>avformat_write_header()</code> 中最关键的地方就是调用了 AVOutputFormat 的 <code>write_header()</code>。</p><p><code>write_header()</code> 是 AVOutputFormat 中的一个函数指针，指向写文件头的函数。不同的AVOutputFormat 有不同的 <code>write_header()</code> 的实现方法。在这里我们举例子看一下 FLV 封装格式对应的 AVOutputFormat，它的定义位于 <code>libavformat\flvenc.c</code></p><p>从 <code>ff_flv_muxer</code> 的定义中可以看出，<code>write_header()</code> 指向的函数为 <code>flv_write_header()</code>。我们继续看一下 <code>flv_write_header()</code> 函数。<code>flv_write_header()</code> 的定义同样位于 <code>libavformat\flvenc.c</code></p><p>从源代码可以看出，<code>flv_write_header()</code> 完成了FLV文件头的写入工作。该函数的工作可以大体分为以下两部分：</p><p>（1）给 FLVContext 设置参数</p><p>（2）写文件头，以及相关的 Tag</p><p>可以参考下图中 FLV 文件头的定义比对一下上面的代码。</p><p><img src="/images/imageFFmpeg/Thor/FLVHeader.png" alt="FLV Header.png"></p><h2 id="avcodec-encode-video"><a href="#avcodec-encode-video" class="headerlink" title="avcodec_encode_video()"></a>avcodec_encode_video()</h2><p>该函数用于编码一帧视频数据。<code>avcodec_encode_video2()</code> 函数的声明位于 <code>libavcodec\avcodec.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_encode_video2</span><span class="params">(AVCodecContext *avctx, AVPacket *avpkt,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> AVFrame *frame, <span class="keyword">int</span> *got_packet_ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数每个参数的含义在注释里面已经写的很清楚了，在这里用中文简述一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avctx：编码器的AVCodecContext。</span><br><span class="line">avpkt：编码输出的AVPacket。</span><br><span class="line">frame：编码输入的AVFrame。</span><br><span class="line">got_packet_ptr：成功编码一个AVPacket的时候设置为1。</span><br></pre></td></tr></table></figure><p>函数返回0代表编码成功。</p><p>函数的调用关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thoreavcodec_encode_video.png" alt="avcodec_encode_video"></p><p><code>avcodec_encode_video2()</code> 的定义位于 <code>libavcodec\utils.c</code></p><p>从函数的定义可以看出，<code>avcodec_encode_video2()</code> 首先调用了 <code>av_image_check_size()</code> 检查设置的宽高参数是否合理，然后调用了 AVCodec 的 <code>encode2()</code> 调用具体的解码器。</p><p><code>av_image_check_size()</code> 主要是要求图像宽高必须为正数，而且取值不能太大。</p><p>AVCodec 的 <code>encode2()</code> 是一个函数指针，指向特定编码器的编码函数</p><p>从 <code>ff_libx264_encoder</code> 的定义可以看出，<code>encode2()</code> 函数指向的是 <code>X264_frame()</code> 函数。</p><p><code>X264_frame()</code> 函数的定义位于 <code>libavcodec\libx264.c</code></p><h2 id="av-write-frame"><a href="#av-write-frame" class="headerlink" title="av_write_frame()"></a>av_write_frame()</h2><p><code>av_write_frame()</code> 用于输出一帧视音频数据，它的声明位于 <code>libavformat\avformat.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_write_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure><p>简单解释一下它的参数的含义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s：用于输出的AVFormatContext。</span><br><span class="line">pkt：等待输出的AVPacket。</span><br></pre></td></tr></table></figure><p>函数正常执行后返回值等于 0。</p><p><code>av_write_frame()</code> 的调用关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/av_write_frame.png" alt="av_write_frame"></p><p><code>av_write_frame()</code> 的定义位于 <code>libavformat\mux.c</code></p><p>从源代码可以看出，<code>av_write_frame()</code> 主要完成了以下几步工作：</p><p>（1）调用 <code>check_packet()</code> 做一些简单的检测</p><p>（2）调用 <code>compute_pkt_fields2()</code> 设置 AVPacket 的一些属性值</p><p>（3）调用 <code>write_packet()</code> 写入数据</p><p><code>check_packet()</code> 的功能比较简单：首先检查一下输入的 AVPacket 是否为空，如果为空，则是直接返回；然后检查一下 AVPacket 的 <code>stream_index</code>（标记了该 AVPacket 所属的 AVStream）设置是否正常，如果为负数或者大于 AVStream 的个数，则返回错误信息；最后检查 AVPacket 所属的 AVStream 是否属于 attachment stream，这个地方没见过，目前还没有研究。</p><p><code>compute_pkt_fields2()</code> 函数的定义位于 <code>libavformat\mux.c</code></p><p><code>compute_pkt_fields2()</code> 主要有两方面的功能：</p><ul><li>一方面用于计算 AVPacket 的 duration， dts 等信息；</li><li>另一方面用于检查 pts、dts 这些参数的合理性（例如 PTS 是否一定大于 DTS）。具体的代码还没有细看，以后有时间再进行分析。</li></ul><p><code>write_packet()</code> 函数的定义位于 <code>libavformat\mux.c</code></p><p><code>write_packet()</code> 函数最关键的地方就是调用了 AVOutputFormat 中写入数据的方法。如果 AVPacket 中的 flag 标记中包含 AV_PKT_FLAG_UNCODED_FRAME，就会调用 AVOutputFormat 的 <code>write_uncoded_frame()</code> 函数；如果不包含那个标记，就会调用 <code>write_packet()</code> 函数。 <code>write_packet()</code> 实际上是一个函数指针，指向特定的 AVOutputFormat 中的实现函数。例如，我们看一下 FLV 对应的 AVOutputFormat，位于 <code>libavformat\flvenc.c</code></p><p>从 <code>ff_flv_muxer</code> 的定义可以看出，<code>write_packet()</code> 指向的是 <code>flv_write_packet()</code> 函数。在看 <code>flv_write_packet()</code> 函数的定义之前，先回顾一下 FLV 封装格式的结构。</p><h2 id="av-write-trailer"><a href="#av-write-trailer" class="headerlink" title="av_write_trailer()"></a>av_write_trailer()</h2><p><code>av_write_trailer()</code> 用于输出文件尾，它的声明位于 <code>libavformat\avformat.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_write_trailer</span><span class="params">(AVFormatContext *s)</span></span>;</span><br></pre></td></tr></table></figure><p>它只需要指定一个参数，即用于输出的 AVFormatContext。</p><p>函数正常执行后返回值等于 0。</p><p><code>av_write_trailer()</code> 的调用关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/av_write_trailer.png" alt="av_write_trailer"></p><p><code>av_write_trailer()</code> 的定义位于 <code>libavformat\mux.c</code></p><p>从源代码可以看出 <code>av_write_trailer()</code> 主要完成了以下两步工作：</p><p>（1）循环调用 <code>interleave_packet()</code> 以及 <code>write_packet()</code>，将还未输出的 AVPacket 输出出来。</p><p>（2）调用 AVOutputFormat 的 <code>write_trailer()</code>，输出文件尾。</p><p>其中第一步和 <code>av_write_frame()</code> 中的步骤大致是一样的（<code>interleave_packet()</code> 这一部分在并不包含在 <code>av_write_frame()</code> 中，而是包含在 <code>av_interleaved_write_frame()</code> 中，这一部分源代码还没有分析）</p><p>AVOutputFormat 的 <code>write_trailer()</code> 是一个函数指针，指向特定的 AVOutputFormat 中的实现函数。我们以 FLV 对应的 AVOutputFormat 为例，看一下它的定义</p><p>从 FLV 对应的 AVOutputFormat 结构体的定义我们可以看出，<code>write_trailer()</code> 指向了<code>flv_write_trailer()</code> 函数。</p><p><code>flv_write_trailer()</code> 函数的定义位于 <code>libavformat\flvenc.c</code></p><p>从 <code>flv_write_trailer()</code> 的源代码可以看出该函数做了以下两步工作：</p><p>（1）如果视频流是 H.264，则添加包含 EOS（End Of Stream） NALU 的 Tag。</p><p>（2）更新 FLV 的时长信息，以及文件大小信息。</p><p>其中，<code>put_avc_eos_tag()</code> 函数用于添加包含 EOS NALU 的 Tag（包含结尾的一个PreviousTagSize）</p><p>可以参考 FLV 封装格式理解上述函数。由于前面的文章中已经描述过 FLV 封装格式，在这里不再重复叙述，在这里仅在此记录一下 AVCVIDEOPACKET 的格式，如下所示。</p><p><img src="/images/imageFFmpeg/Thor/AVCVIDEOPACKET%E6%A0%BC%E5%BC%8F.png" alt="AVCVIDEOPACKET格式"></p><p>可以看出包含 EOS NALU 的 AVCVIDEOPACKET 的 AVCPacketType 为 2。在这种情况下， AVCVIDEOPACKET 的 CompositionTime 字段取 0，并且无需包含 Data 字段。</p><h1 id="日志输出系统"><a href="#日志输出系统" class="headerlink" title="日志输出系统"></a>日志输出系统</h1><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDI0MzE1NQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/44243155">日志输出系统<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="av-log"><a href="#av-log" class="headerlink" title="av_log()"></a>av_log()</h2><p>本文分析一下 FFmpeg 的日志（Log）输出系统的源代码。日志输出部分的核心函数只有一个： <code>av_log()</code>。使用 <code>av_log()</code> 在控制台输出日志的效果如下图所示。</p><p><img src="/images/imageFFmpeg/Thor/av_log%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA.png" alt="av_log控制台日志输出"></p><p>FFmpeg 日志输出系统的函数调用结构图如图所示：</p><p><img src="/images/imageFFmpeg/Thor/av_log.png" alt="FFmpeg 日志输出系统的函数调用结构图"></p><p><code>av_log()</code> 是 FFmpeg 中输出日志的函数。随便打开一个 FFmpeg 的源代码文件，就会发现其中遍布着 <code>av_log()</code> 函数。一般情况下 FFmpeg 类库的源代码中是不允许使用 <code>printf()</code> 这种的函数的，所有的输出一律使用 <code>av_log()</code>。</p><p>av_log()的声明位于libavutil\log.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_log</span><span class="params">(<span class="keyword">void</span> *avcl, <span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">av_printf_format</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的声明有两个地方比较特殊：</p><p>（1）函数最后一个参数是 “…”。</p><p>在 C 语言中，在函数参数数量不确定的情况下使用 “…” 来代表参数。例如 <code>printf()</code> 的原型定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>（2）它的声明后面有一个 <code>av_printf_format(3, 4)</code>。有关这个地方的左右还没有深入研究，网上资料中说它的作用是按照 <code>printf()</code> 的格式检查 <code>av_log()</code> 的格式。</p><p>av_log()每个字段的含义如下：</p><ul><li>avcl：指定一个包含 AVClass 的结构体。</li><li>level：log 的级别</li><li>fmt：和 <code>printf()</code> 一样。</li></ul><p>由此可见，<code>av_log()</code> 和 <code>printf()</code> 的不同主要在于前面多了两个参数。其中第一个参数指定该 log 所属的结构体，例如 AVFormatContext、AVCodecContext 等等。第二个参数指定 log 的级别，源代码中定义了如下几个级别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_QUIET    -8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_PANIC     0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_FATAL     8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_ERROR    16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_WARNING  24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_INFO     32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_VERBOSE  40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_DEBUG    48</span></span><br></pre></td></tr></table></figure><p>从定义中可以看出来，随着严重程度逐渐下降，一共包含如下级别：</p><ul><li>AV_LOG_PANIC，</li><li>AV_LOG_FATAL，</li><li>AV_LOG_ERROR，</li><li>AV_LOG_WARNING，</li><li>AV_LOG_INFO，</li><li>AV_LOG_VERBOSE，</li><li>AV_LOG_DEBUG。</li></ul><p>每个级别定义的数值代表了严重程度，数值越小代表越严重。默认的级别是 AV_LOG_INFO。此外，还有一个级别不输出任何信息，即 AV_LOG_QUIET。</p><p>当前系统存在着一个 “Log级别”。所有严重程度高于该级别的 Log 信息都会输出出来。例如当前的 Log 级别是 AV_LOG_WARNING，则会输出 AV_LOG_PANIC，AV_LOG_FATAL，AV_LOG_ERROR，AV_LOG_WARNING 级别的信息，而不会输出 AV_LOG_INFO 级别的信息。可以通过 <code>av_log_get_level()</code> 获得当前 Log 的级别，通过另一个函数 <code>av_log_set_level()</code> 设置当前的 Log 级别。</p><p>可以通过 <code>av_log_set_level()</code> 设置当前 Log 的级别。</p><h1 id="接头体成员管理系统"><a href="#接头体成员管理系统" class="headerlink" title="接头体成员管理系统"></a>接头体成员管理系统</h1><h2 id="AVClass"><a href="#AVClass" class="headerlink" title="AVClass"></a>AVClass</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDI2ODMyMw==" title="https://blog.csdn.net/leixiaohua1020/article/details/44268323">FFmpeg源代码简单分析：结构体成员管理系统-AVClass<i class="fa fa-external-link"></i></span></p></blockquote><p>TODO</p><h2 id="AVOption"><a href="#AVOption" class="headerlink" title="AVOption"></a>AVOption</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDI3OTMyOQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/44279329">FFmpeg源代码简单分析：结构体成员管理系统-AVOption<i class="fa fa-external-link"></i></span></p></blockquote><p>TODO</p><h1 id="libswscale"><a href="#libswscale" class="headerlink" title="libswscale"></a>libswscale</h1><h2 id="sws-getContext"><a href="#sws-getContext" class="headerlink" title="sws_getContext()"></a>sws_getContext()</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDMwNTY5Nw==" title="https://blog.csdn.net/leixiaohua1020/article/details/44305697">FFmpeg源代码简单分析：libswscale的sws_getContext()<i class="fa fa-external-link"></i></span></p></blockquote><p>TODO</p><h2 id="sws-scale"><a href="#sws-scale" class="headerlink" title="sws_scale()"></a>sws_scale()</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDM0NjY4Nw==" title="https://blog.csdn.net/leixiaohua1020/article/details/44346687">FFmpeg源代码简单分析：libswscale的sws_scale()<i class="fa fa-external-link"></i></span></p></blockquote><p>TODO</p><h1 id="libavdevice"><a href="#libavdevice" class="headerlink" title="libavdevice"></a>libavdevice</h1><h2 id="avdevice-register-all"><a href="#avdevice-register-all" class="headerlink" title="avdevice_register_all()"></a>avdevice_register_all()</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80MTIxMTEyMQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/41211121">FFmpeg源代码简单分析：libavdevice的avdevice_register_all()<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="gdigrab"><a href="#gdigrab" class="headerlink" title="gdigrab"></a>gdigrab</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDU5Nzk1NQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/44597955">FFmpeg源代码简单分析：libavdevice的gdigrab<i class="fa fa-external-link"></i></span></p></blockquote><p><img src="/images/imageFFmpeg/Thor/" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy84NDQ5OTYzMg==&quot; title=&quot;https://blog.csdn.net/leixiaohua1020/article/details/84499632&quot;&gt;[总结]FFMPEG视音频编解码零基础学习方法&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;架构图&quot;&gt;&lt;a href=&quot;#架构图&quot; class=&quot;headerlink&quot; title=&quot;架构图&quot;&gt;&lt;/a&gt;架构图&lt;/h1&gt;&lt;h2 id=&quot;FFMPEG-SDL的视频播放器&quot;&gt;&lt;a href=&quot;#FFMPEG-SDL的视频播放器&quot; class=&quot;headerlink&quot; title=&quot;FFMPEG+SDL的视频播放器&quot;&gt;&lt;/a&gt;FFMPEG+SDL的视频播放器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy8zODg2ODQ5OQ==&quot; title=&quot;https://blog.csdn.net/leixiaohua1020/article/details/38868499&quot;&gt;最简单的基于FFMPEG+SDL的视频播放器 ver2 （采用SDL2.0）&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;FFmpeg 解码一个视频流程：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 源代码结构（编解码解析）</title>
    <link href="http://miaopei.github.io/2019/05/25/FFmpeg/FFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84note/"/>
    <id>http://miaopei.github.io/2019/05/25/FFmpeg/FFmpeg源代码结构note/</id>
    <published>2019-05-25T02:14:50.000Z</published>
    <updated>2019-06-24T10:43:19.873Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>特别说明，此文参考至<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDIyMDE1MQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/44220151">雷神笔记<i class="fa fa-external-link"></i></span>，做一个备忘录。</p></blockquote><h2 id="FFmpeg源代码结构图-解码"><a href="#FFmpeg源代码结构图-解码" class="headerlink" title="FFmpeg源代码结构图 - 解码"></a>FFmpeg源代码结构图 - 解码</h2><p>下图表明了 FFmpeg 在解码一个视频的时候的函数调用流程。为了保证结构清晰，其中仅列出了最关键的函数，剔除了其它不是特别重要的函数。</p><a id="more"></a><p><img src="/images/imageFFmpeg/Thor/FFmpeg%E6%BA%90%E7%A0%81API%E7%BB%93%E6%9E%84%E5%9B%BE-%E8%A7%A3%E7%A0%81.png" alt="FFmpeg源代码结构图 - 解码"></p><p>下面解释一下图中关键标记的含义。</p><h3 id="函数背景色"><a href="#函数背景色" class="headerlink" title="函数背景色"></a>函数背景色</h3><p>函数在图中以方框的形式表现出来。不同的背景色标志了该函数不同的作用：</p><ul><li>粉红色背景函数：FFmpeg 的 API函数。</li><li>白色背景的函数：FFmpeg 的内部函数。</li><li>黄色背景的函数：URLProtocol 结构体中的函数，包含处理协议（Protocol）的功能。</li><li>绿色背景的函数：AVInputFormat 结构体中的函数，包含处理封装格式（Format）的功能。</li><li>蓝色背景的函数：AVCodec 结构体中的函数，包含了编解码器（Codec）的功能。</li></ul><blockquote><p>PS：URLProtocol，AVInputFormat，AVCodec在FFmpeg开始运行并且注册完组件之后，都会分别被连接成一个个的链表。因此实际上是有很多的URLProtocol，AVInputFormat，AVCodec的。图中画出了解码一个输入协议是“文件”（其实就是打开一个文件。“文件”也被当做是一种广义的协议），封装格式为FLV，视频编码格式是H.264的数据的函数调用关系。</p></blockquote><h3 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h3><p>整个架构图可以分为以下几个区域：</p><ul><li><strong>左边区域——架构函数区域</strong>：这些函数并不针对某一特定的视频格式。</li><li><strong>右上方黄色区域——协议处理函数区域</strong>：不同的协议（RTP，RTMP，FILE）会调用不同的协议处理函数。</li><li><strong>右边中间绿色区域——封装格式处理函数区域</strong>：不同的封装格式（MKV，FLV，MPEGTS，AVI）会调用不同的封装格式处理函数。</li><li><strong>右边下方蓝色区域——编解码函数区域</strong>：不同的编码标准（HEVC，H.264，MPEG2）会调用不同的编解码函数。</li></ul><h3 id="箭头线"><a href="#箭头线" class="headerlink" title="箭头线"></a>箭头线</h3><p>为了把调用关系表示的更明显，图中的箭头线也使用了不同的颜色：</p><ul><li><p>黑色箭头线：标志了函数之间的调用关系。</p></li><li><p>红色的箭头线：标志了解码的流程。</p></li><li><p>其他颜色的箭头线：标志了函数之间的调用关系。其中：</p><ul><li>调用 URLProtocol 结构体中的函数用<strong>黄色箭头线</strong>标识；</li><li>调用 AVInputFormat 结构体中的函数用<strong>绿色箭头线</strong>标识；</li><li>调用 AVCodec 结构体中的函数用<strong>蓝色箭头线</strong>标识。</li></ul></li></ul><h3 id="函数所在的文件"><a href="#函数所在的文件" class="headerlink" title="函数所在的文件"></a>函数所在的文件</h3><p>每个函数旁边标识了它所在的文件的路径。</p><p>此外，还有一点需要注意的是，一些 API 函数内部也调用了另一些API函数。也就是说，API函数并不一定全部都调用FFmpeg的内部函数，他也有可能调用其他的API函数。例如从图中可以看出来， <code>avformat_close_input()</code> 调用了 <code>avformat_free_context()</code> 和 <code>avio_close()</code>。这些在内部代码中被调用的API函数也标记为粉红色。</p><h3 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h3><p>下面简单列出几个区域中函数之间的调用关系（函数之间的调用关系使用缩进的方式表现出来）。详细的函数分析可以参考相关的《FFmpeg源代码分析》系列文章。</p><h4 id="左边区域（FFmpeg架构函数）"><a href="#左边区域（FFmpeg架构函数）" class="headerlink" title="左边区域（FFmpeg架构函数）"></a>左边区域（FFmpeg架构函数）</h4><p><strong><font color="red">1.  av_register_all()【函数简单分析】</font>&gt;</strong></p><ul><li><strong><font color="red">1)  avcodec_register_all()</font></strong><ul><li><strong>(a) REGISTER_HWACCEL()</strong></li><li><strong>(b) REGISTER_ENCODER()</strong></li><li><strong>(c) REGISTER_DECODER()</strong></li><li><strong>(d) REGISTER_PARSER()</strong></li><li><strong>(e) REGISTER_BSF()</strong></li></ul></li><li><strong>2)  REGISTER_MUXER()</strong></li><li><strong>3)  REGISTER_DEMUXER()</strong></li><li><strong>4)  REGISTER_PROTOCOL()</strong></li></ul><p><strong><font color="red">2.  avformat_alloc_context()【函数简单分析】</font></strong></p><ul><li><p><strong>1) av_malloc(sizeof(AVFormatContext))</strong></p></li><li><p><strong>2) avformat_get_context_defaults()</strong></p><ul><li><strong>(a) av_opt_set_defaults()</strong></li></ul></li></ul><p><strong><font color="red">3.  avformat_open_input()【函数简单分析】</font></strong></p><ul><li><strong>1) init_input()</strong><ul><li><strong><font color="red">(a) avio_open2()【函数简单分析】</font></strong><ul><li><strong>a) ffurl_open()</strong><ul><li><strong>i. ffurl_alloc()</strong><ul><li><strong>url_find_protocol()</strong></li><li><strong>url_alloc_for_protocol()</strong></li></ul></li><li><strong>ii. ffurl_connect()</strong><ul><li><strong><font color="#FFC000">URLProtocol-&gt;url_open()</font></strong></li></ul></li></ul></li><li><strong>b) ffio_fdopen()</strong><ul><li><strong>i. av_malloc(buffer_size)</strong></li><li><strong>ii. <font color="red">avio_alloc_context()</font></strong><ul><li><strong>av_mallocz(sizeof(AVIOContext))</strong></li><li><strong>ffio_init_context()</strong></li></ul></li></ul></li></ul></li><li><strong><font color="red">(b) av_probe_input_buffer2()</font></strong><ul><li><strong><font color="red">a) avio_read()</font></strong><ul><li><strong>i.  <font color="#009900">AVInputFormat-&gt;read_packet()</font></strong></li></ul></li><li><strong><font color="red">b) av_probe_input_format2()</font></strong></li><li><strong><font color="red">c) av_probe_input_format3()</font></strong><ul><li><strong>i. <font color="red">av_iformat_next()</font></strong></li><li><strong>ii. <font color="red">av_match_name()</font></strong></li><li><strong>iii. <font color="red">av_match_ext()</font></strong></li><li><strong>iv. <font color="#009900">AVInputFormat-&gt;read_probe()</font></strong></li></ul></li></ul></li></ul></li><li><strong>2) <font color="#009900">AVInputFormat-&gt;read_header()</font></strong></li></ul><p><strong><font color="red">4. avformat_find_stream_info()【函数简单分析】</font></strong></p><ul><li><strong>1) find_decoder()</strong><ul><li><strong><font color="red">(a) avcodec_find_decoder()</font></strong></li></ul></li><li><strong><font color="red">2) avcodec_open2()</font></strong></li><li><strong>3) read_frame_internal()</strong></li><li><strong>4) try_decode_frame()</strong><ul><li><strong><font color="red">(a) avcodec_decode_video2()</font></strong></li></ul></li><li><strong><font color="red">5) avcodec_close()</font></strong></li><li><strong>6) estimate_timings()</strong><ul><li><strong>(a)  estimate_timings_from_pts()</strong></li><li><strong>(b)  estimate_timings_from_bit_rate()</strong></li><li><strong>(c)  update_stream_timings()</strong></li></ul></li></ul><p><strong><font color="red">5. avcodec_find_decoder()【函数简单分析】</font></strong></p><ul><li><strong>1) find_encdec()</strong></li></ul><p><strong><font color="red">6. avcodec_open2()【函数简单分析】</font></strong></p><ul><li><strong><font color="#3072C2">1) AVCodec-&gt;init()</font></strong></li></ul><p><strong><font color="red">7. av_read_frame()【函数简单分析】</font></strong></p><ul><li><p><strong>1) read_from_packet_buffer()</strong></p></li><li><p><strong>2) read_frame_internal()</strong></p><ul><li><strong>(a) ff_read_packet()</strong><ul><li><strong><font color="#009900">a) AVInputFormat-&gt;read_packet()</font></strong></li></ul></li><li><strong>(b) parse_packet()</strong><ul><li><strong>a) av_parser_parse2()</strong></li></ul></li></ul></li></ul><p><strong><font color="red">8. avcodec_decode_video2()【函数简单分析】</font></strong></p><ul><li><p><strong>1) av_packet_split_side_data()</strong></p></li><li><p><strong>2) <font color="#3072C2">AVCodec</font>-&gt; <font color="red">decode()</font></strong></p></li><li><p><strong>3) av_frame_set_pkt_pos()</strong></p></li><li><p><strong>4) av_frame_set_best_effort_timestamp()</strong></p></li></ul><p><strong><font color="red">9. avcodec_close()【函数简单分析】</font></strong></p><ul><li><strong><font color="#3072C2">1) AVCodec-&gt;close()</font></strong></li></ul><p><strong><font color="red">10. avformat_close_input()【函数简单分析】</font></strong></p><ul><li><p><strong><font color="#009900">1) AVInputFormat-&gt;read_close()</font></strong></p></li><li><p><strong>2) avformat_free_context()</strong></p><ul><li><strong>(a) ff_free_stream()</strong></li></ul></li><li><p><strong>3) avio_close()</strong></p><ul><li><strong>(a) avio_flush()</strong><ul><li><strong>a) flush_buffer()</strong></li></ul></li><li><strong>(b) ffurl_close()</strong><ul><li><strong>a) ffurl_closep()</strong><ul><li><strong><font color="#FFC000">URLProtocol-&gt;url_close()</font></strong></li></ul></li></ul></li></ul></li></ul><h4 id="右上区域（URLProtocol协议处理函数）"><a href="#右上区域（URLProtocol协议处理函数）" class="headerlink" title="右上区域（URLProtocol协议处理函数）"></a>右上区域（URLProtocol协议处理函数）</h4><p>URLProtocol结构体包含如下协议处理函数指针：</p><ul><li><strong><font color="#FFC000">url_open()：打开</font></strong></li><li><strong><font color="#FFC000">url_read()：读取</font></strong></li><li><strong><font color="#FFC000">url_write()：写入</font></strong></li><li><strong><font color="#FFC000">url_seek()：调整进度</font></strong></li><li><strong><font color="#FFC000">url_close()：关闭</font></strong></li></ul><p>【例子】不同的协议对应着上述接口有不同的实现函数，举几个例子：</p><p><strong>File协议（即文件）对应的URLProtocol结构体 <code>ff_file_protocol</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url_open() -&gt; file_open() -&gt; open()</span><br><span class="line">url_read() -&gt; file_read() -&gt; read()</span><br><span class="line">url_write() -&gt; file_write() -&gt; write()</span><br><span class="line">url_seek() -&gt; file_seek() -&gt; lseek()</span><br><span class="line">url_close() -&gt; file_close() -&gt; close()</span><br></pre></td></tr></table></figure><p><strong>RTMP协议（libRTMP）对应的URLProtocol结构体 <code>ff_librtmp_protocol</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url_open() -&gt; rtmp_open() -&gt; RTMP_Init(), RTMP_SetupURL(), RTMP_Connect(), RTMP_ConnectStream()</span><br><span class="line">url_read() -&gt; rtmp_read() -&gt; RTMP_Read()</span><br><span class="line">url_write() -&gt; rtmp_write() -&gt; RTMP_Write()</span><br><span class="line">url_seek() -&gt; rtmp_read_seek() -&gt; RTMP_SendSeek()</span><br><span class="line">url_close() -&gt; rtmp_close() -&gt; RTMP_Close()</span><br></pre></td></tr></table></figure><p><strong>UDP协议对应的URLProtocol结构体 <code>ff_udp_protocol</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url_open() -&gt; udp_open()</span><br><span class="line">url_read() -&gt; udp_read()</span><br><span class="line">url_write() -&gt; udp_write()</span><br><span class="line">url_seek() -&gt; udp_close()</span><br><span class="line">url_close() -&gt; udp_close()</span><br></pre></td></tr></table></figure><h4 id="右中区域（AVInputFormat封装格式处理函数）"><a href="#右中区域（AVInputFormat封装格式处理函数）" class="headerlink" title="右中区域（AVInputFormat封装格式处理函数）"></a>右中区域（AVInputFormat封装格式处理函数）</h4><p>AVInputFormat包含如下封装格式处理函数指针：</p><ul><li><strong><font color="#009900">read_probe()：检查格式</font></strong></li><li><strong><font color="#009900">read_header()：读取文件头</font></strong></li><li><strong><font color="#009900">read_packet()：读取一帧数据</font></strong></li><li><strong><font color="#009900">read_seek()：调整进度</font></strong></li><li><strong><font color="#009900">read_close()：关闭</font></strong></li></ul><p>【例子】不同的封装格式对应着上述接口有不同的实现函数，举几个例子：</p><p><strong>FLV封装格式对应的AVInputFormat结构体 <code>ff_flv_demuxer</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read_probe() -&gt; flv_probe() –&gt; probe()</span><br><span class="line">read_header() -&gt; flv_read_header() -&gt; create_stream() -&gt; avformat_new_stream()</span><br><span class="line">read_packet() -&gt; flv_read_packet()</span><br><span class="line">read_seek() -&gt; flv_read_seek()</span><br><span class="line">read_close() -&gt; flv_read_close()</span><br></pre></td></tr></table></figure><p><strong>MKV封装格式对应的AVInputFormat结构体 <code>ff_matroska_demuxer</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read_probe() -&gt; matroska_probe()</span><br><span class="line">read_header() -&gt; matroska_read_header()</span><br><span class="line">read_packet() -&gt; matroska_read_packet()</span><br><span class="line">read_seek() -&gt; matroska_read_seek()</span><br><span class="line">read_close() -&gt; matroska_read_close()</span><br></pre></td></tr></table></figure><p><strong>MPEG2TS封装格式对应的AVInputFormat结构体 <code>ff_mpegts_demuxer</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_probe() -&gt; mpegts_probe()</span><br><span class="line">read_header() -&gt; mpegts_read_header()</span><br><span class="line">read_packet() -&gt; mpegts_read_packet() </span><br><span class="line">read_close() -&gt; mpegts_read_close()</span><br></pre></td></tr></table></figure><p><strong>AVI封装格式对应的AVInputFormat结构体 <code>ff_avi_demuxer</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read_probe() -&gt; avi_probe()</span><br><span class="line">read_header() -&gt; avi_read_header()</span><br><span class="line">read_packet() -&gt; avi_read_packet()</span><br><span class="line">read_seek() -&gt; avi_read_seek()</span><br><span class="line">read_close() -&gt; avi_read_close()</span><br></pre></td></tr></table></figure><h4 id="右下区域（AVCodec编解码函数）"><a href="#右下区域（AVCodec编解码函数）" class="headerlink" title="右下区域（AVCodec编解码函数）"></a>右下区域（AVCodec编解码函数）</h4><p>AVCodec包含如下编解码函数指针：</p><ul><li><strong><font color="#3072C2">init()：初始化</font></strong></li><li><strong><font color="red">decode()</font>：解码一帧数据</strong></li><li><strong><font color="#3072C2">close()：关闭</font></strong></li></ul><p>【例子】不同的编解码器对应着上述接口有不同的实现函数，举几个例子：</p><p><strong>HEVC解码对应的AVCodec结构体 <code>ff_hevc_decoder</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() -&gt; hevc_decode_init()</span><br><span class="line">decode() -&gt; hevc_decode_frame() -&gt; decode_nal_units()</span><br><span class="line">close() -&gt; hevc_decode_free()</span><br></pre></td></tr></table></figure><p><strong>H.264解码对应的AVCodec结构体 <code>ff_h264_decoder</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() -&gt; ff_h264_decode_init()</span><br><span class="line">decode() -&gt; h264_decode_frame() -&gt; decode_nal_units()</span><br><span class="line">close() -&gt; h264_decode_end()</span><br></pre></td></tr></table></figure><p><strong>VP8解码（libVPX）对应的AVCodec结构体 <code>ff_libvpx_vp8_decoder</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() -&gt; vpx_init() -&gt; vpx_codec_dec_init()</span><br><span class="line">decode() -&gt; vp8_decode() -&gt; vpx_codec_decode(), vpx_codec_get_frame()</span><br><span class="line">close() -&gt; vp8_free() -&gt; vpx_codec_destroy()</span><br></pre></td></tr></table></figure><p><strong>MPEG2解码对应的AVCodec结构体 <code>ff_mpeg2video_decoder</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() -&gt; mpeg_decode_init()</span><br><span class="line">decode() -&gt; mpeg_decode_frame()</span><br><span class="line">close() -&gt; mpeg_decode_end()</span><br></pre></td></tr></table></figure><h3 id="avformat-open-input-函数"><a href="#avformat-open-input-函数" class="headerlink" title="avformat_open_input() 函数"></a>avformat_open_input() 函数</h3><p><img src="/images/imageFFmpeg/Thor/avformat_open_input.png" alt="avformat_open_input"></p><h2 id="FFmpeg源代码结构图-编码"><a href="#FFmpeg源代码结构图-编码" class="headerlink" title="FFmpeg源代码结构图 - 编码"></a>FFmpeg源代码结构图 - 编码</h2><h3 id="函数调用关系图"><a href="#函数调用关系图" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p>下图表明了FFmpeg在编码一个视频的时候的函数调用流程。为了保证结构清晰，其中仅列出了最关键的函数，剔除了其它不是特别重要的函数。</p><p><img src="/images/imageFFmpeg/Thor/FFmpeg%E6%BA%90%E7%A0%81API%E7%BB%93%E6%9E%84%E5%9B%BE-%E7%BC%96%E7%A0%81.png" alt="FFmpeg源代码结构图 - 编码"></p><p>下面解释一下图中关键标记的含义。</p><h3 id="函数背景色-1"><a href="#函数背景色-1" class="headerlink" title="函数背景色"></a>函数背景色</h3><p>函数在图中以方框的形式表现出来。不同的背景色标志了该函数不同的作用：</p><ul><li>粉红色背景函数：FFmpeg 的 API 函数。</li><li>白色背景的函数：FFmpeg 的内部函数。</li><li>黄色背景的函数：URLProtocol 结构体中的函数，包含了读写各种协议的功能。</li><li>绿色背景的函数：AVOutputFormat 结构体中的函数，包含了读写各种封装格式的功能。</li><li>蓝色背景的函数：AVCodec 结构体中的函数，包含了编解码的功能。</li></ul><h3 id="区域-1"><a href="#区域-1" class="headerlink" title="区域"></a>区域</h3><p>整个关系图可以分为以下几个区域：</p><ul><li><strong>左边区域——架构函数区域</strong>：这些函数并不针对某一特定的视频格式。</li><li><strong>右上方黄色区域——协议处理函数区域</strong>：不同的协议（RTP，RTMP，FILE）会调用不同的协议处理函数。</li><li><strong>右边中间绿色区域——封装格式处理函数区域</strong>：不同的封装格式（MKV，FLV，MPEG2TS，AVI）会调用不同的封装格式处理函数。</li><li><strong>右边下方蓝色区域——编解码函数区域</strong>：不同的编码标准（HEVC，H.264，MPEG2）会调用不同的编解码函数。</li></ul><h3 id="箭头线-1"><a href="#箭头线-1" class="headerlink" title="箭头线"></a>箭头线</h3><p>为了把调用关系表示的更明显，图中的箭头线也使用了不同的颜色：</p><ul><li><p>红色的箭头线：标志了编码的流程。</p></li><li><p>其他颜色的箭头线：标志了函数之间的调用关系。其中：</p><ul><li>调用 URLProtocol 结构体中的函数用<strong>黄色箭头线</strong>标识；</li><li>调用 AVOutputFormat 结构体中的函数用<strong>绿色箭头线</strong>标识；</li><li>调用 AVCodec 结构体中的函数用<strong>蓝色箭头线</strong>标识。</li></ul></li></ul><h3 id="函数所在的文件-1"><a href="#函数所在的文件-1" class="headerlink" title="函数所在的文件"></a>函数所在的文件</h3><p>每个函数标识了它所在的文件路径。</p><h3 id="函数功能简述"><a href="#函数功能简述" class="headerlink" title="函数功能简述"></a>函数功能简述</h3><p>下面简单列出几个区域中函数之间的调用关系（函数之间的调用关系使用缩进的方式表现出来）。详细的函数分析可以参考相关的《FFmpeg源代码分析》系列文章。</p><h4 id="左边区域（架构函数）"><a href="#左边区域（架构函数）" class="headerlink" title="左边区域（架构函数）"></a>左边区域（架构函数）</h4><p><strong><font color="red">1. av_register_all()【函数简单分析】</font></strong></p><ul><li><p><strong><font color="red">1) avcodec_register_all()</font></strong></p><ul><li><strong>(a) REGISTER_HWACCEL()</strong></li><li><strong>(b) REGISTER_ENCODER()</strong></li><li><strong>(c) REGISTER_DECODER()</strong></li><li><strong>(d) REGISTER_PARSER()</strong></li><li><strong>(e) REGISTER_BSF()</strong></li></ul></li><li><p><strong>2) REGISTER_MUXER()</strong></p></li><li><p><strong>3) REGISTER_DEMUXER()</strong></p></li><li><p><strong>4) REGISTER_PROTOCOL()</strong></p></li></ul><p><strong><font color="red">2. avformat_alloc_output_context2()【函数简单分析】</font></strong></p><ul><li><p><strong><font color="red">1) avformat_alloc_context()</font></strong></p><ul><li><p><strong>(a) av_malloc(sizeof(AVFormatContext))</strong></p></li><li><p><strong>(b) avformat_get_context_defaults()</strong></p><ul><li><strong>a) av_opt_set_defaults()</strong></li></ul></li></ul></li><li><p><strong><font color="red">2) av_guess_format()</font></strong></p><ul><li><strong><font color="red">(a) av_oformat_next()</font></strong></li><li><strong><font color="red">(b) av_match_name()</font></strong></li><li><strong><font color="red">(c) av_match_ext()</font></strong></li></ul></li></ul><p><strong><font color="red">3. avio_open2()【函数简单分析】</font></strong></p><ul><li><p><strong>1) ffurl_open()</strong></p><ul><li><strong>(a) ffurl_alloc()</strong><ul><li><strong>a) url_find_protocol()</strong></li><li><strong>b) url_alloc_for_protocol()</strong></li></ul></li><li><strong>(b) ffurl_connect()</strong><ul><li><strong><font color="#FFC000">a) URLProtocol-&gt;url_open()</font></strong></li></ul></li></ul></li><li><p><strong>2) ffio_fdopen()</strong></p><ul><li><strong>(a) av_malloc(buffer_size)</strong></li><li><strong><font color="red">(b) avio_alloc_context()</font></strong><ul><li><strong>a) av_mallocz(sizeof(AVIOContext))</strong></li><li><strong>b) ffio_init_context()</strong></li></ul></li></ul></li></ul><p><strong><font color="red">4. avformat_new_stream()【函数简单分析】</font></strong></p><ul><li><p><strong>1) av_mallocz(sizeof(AVStream))</strong></p></li><li><p><strong><font color="red">2) avcodec_alloc_context3()</font></strong></p><ul><li><strong>(a) av_malloc(sizeof(AVCodecContext))</strong></li><li><strong>(b) avcodec_get_context_defaults3()</strong></li></ul></li></ul><p><strong><font color="red">5. avcodec_find_encoder()【函数简单分析】</font></strong></p><ul><li><strong>1) find_encdec()</strong></li></ul><p><strong><font color="red">6. avcodec_open2()【函数简单分析】</font></strong></p><ul><li><strong>1) AVCodec-&gt;init()</strong></li></ul><p><strong><font color="red">7. avformat_write_header()【函数简单分析】</font></strong></p><ul><li><p><strong>1) init_muxer()</strong></p></li><li><p><strong><font color="#009900">2) AVOutputFormat-&gt;write_header()</font></strong></p></li><li><p><strong>3) init_pts()</strong></p></li></ul><p><strong><font color="red">8. avcodec_encode_video2()【函数简单分析】</font></strong></p><ul><li><strong><font color="#3072C2">1) AVCodec-&gt;encode2()</font></strong></li></ul><p><strong><font color="red">9. av_write_frame()【函数简单分析】</font></strong></p><ul><li><p><strong>1) check_packet()</strong></p></li><li><p><strong>2) compute_pkt_fields2()</strong></p></li><li><p><strong>3) write_packet()</strong></p><ul><li><strong><font color="#009900">(a) AVOutputFormat-&gt;write_packet()</font></strong></li></ul></li></ul><p><strong><font color="red">10. av_write_trailer()【函数简单分析】</font></strong></p><ul><li><p><strong>1) write_packet()</strong></p></li><li><p><strong><font color="#009900">2) AVOutputFormat-&gt;write_trailer()</font></strong></p></li></ul><p><strong><font color="red">11. avcodec_close()【函数简单分析】</font></strong></p><ul><li><strong><font color="#3072C2">1) AVCodec-&gt;close()</font></strong></li></ul><p><strong><font color="red">12. avformat_free_context()【函数简单分析】</font></strong></p><ul><li><strong>1) ff_free_stream()</strong></li></ul><p><strong><font color="red">13. avio_close()【函数简单分析】</font></strong></p><ul><li><strong>1) avio_flush()</strong><ul><li><strong>(a) flush_buffer()</strong></li></ul></li><li><strong>2) ffurl_close()</strong><ul><li><strong>(a) ffurl_closep()</strong><ul><li><strong><font color="#FFC000">a) URLProtocol-&gt;url_close()</font></strong></li></ul></li></ul></li></ul><h4 id="右上区域（URLProtocol协议处理函数）-1"><a href="#右上区域（URLProtocol协议处理函数）-1" class="headerlink" title="右上区域（URLProtocol协议处理函数）"></a>右上区域（URLProtocol协议处理函数）</h4><p>URLProtocol结构体包含如下协议处理函数指针：</p><ul><li><strong><font color="#FFC000">url_open()：打开</font></strong></li><li><strong><font color="#FFC000">url_read()：读取</font></strong></li><li><strong><font color="#FFC000">url_write()：写入</font></strong></li><li><strong><font color="#FFC000">url_seek()：调整进度</font></strong></li><li><strong><font color="#FFC000">url_close()：关闭</font></strong></li></ul><p>【例子】不同的协议对应着上述接口有不同的实现函数，举几个例子：</p><p><strong>File协议（即文件）对应的URLProtocol结构体 <code>ff_file_protocol</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url_open() -&gt; file_open() -&gt; open()</span><br><span class="line">url_read() -&gt; file_read() -&gt; read()</span><br><span class="line">url_write() -&gt; file_write() -&gt; write()</span><br><span class="line">url_seek() -&gt; file_seek() -&gt; lseek()</span><br><span class="line">url_close() -&gt; file_close() -&gt; close()</span><br></pre></td></tr></table></figure><p><strong>RTMP协议（libRTMP）对应的URLProtocol结构体 <code>ff_librtmp_protocol</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url_open() -&gt; rtmp_open() -&gt; RTMP_Init(), RTMP_SetupURL(), RTMP_Connect(), RTMP_ConnectStream()</span><br><span class="line">url_read() -&gt; rtmp_read() -&gt; RTMP_Read()</span><br><span class="line">url_write() -&gt; rtmp_write() -&gt; RTMP_Write()</span><br><span class="line">url_seek() -&gt; rtmp_read_seek() -&gt; RTMP_SendSeek()</span><br><span class="line">url_close() -&gt; rtmp_close() -&gt; RTMP_Close()</span><br></pre></td></tr></table></figure><p><strong>UDP协议对应的URLProtocol结构体 <code>ff_udp_protocol</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url_open() -&gt; udp_open()</span><br><span class="line">url_read() -&gt; udp_read()</span><br><span class="line">url_write() -&gt; udp_write()</span><br><span class="line">url_seek() -&gt; udp_close()</span><br><span class="line">url_close() -&gt; udp_close()</span><br></pre></td></tr></table></figure><h4 id="右中区域（AVOutputFormat封装格式处理函数）"><a href="#右中区域（AVOutputFormat封装格式处理函数）" class="headerlink" title="右中区域（AVOutputFormat封装格式处理函数）"></a>右中区域（AVOutputFormat封装格式处理函数）</h4><p>AVOutputFormat包含如下封装格式处理函数指针：</p><ul><li><strong><font color="#009900">write_header()：写文件头</font></strong></li><li><strong><font color="#009900">write_packet()：写一帧数据</font></strong></li><li><strong><font color="#009900">write_trailer()：写文件尾</font></strong></li></ul><p>【例子】不同的封装格式对应着上述接口有不同的实现函数，举几个例子：</p><p><strong>FLV封装格式对应的AVOutputFormat结构体 <code>ff_flv_muxer</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write_header() -&gt; flv_write_header()</span><br><span class="line">write_packet() –&gt; flv_write_packet()</span><br><span class="line">write_trailer() -&gt; flv_write_trailer()</span><br></pre></td></tr></table></figure><p><strong>MKV封装格式对应的AVOutputFormat结构体 <code>ff_matroska_muxer</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write_header() -&gt; mkv_write_header()</span><br><span class="line">write_packet() –&gt; mkv_write_flush_packet()</span><br><span class="line">write_trailer() -&gt; mkv_write_trailer()</span><br></pre></td></tr></table></figure><p><strong>MPEG2TS封装格式对应的AVOutputFormat结构体 <code>ff_mpegts_muxer</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write_header() -&gt; mpegts_write_header()</span><br><span class="line">write_packet() –&gt; mpegts_write_packet()</span><br><span class="line">write_trailer() -&gt; mpegts_write_end()</span><br></pre></td></tr></table></figure><p><strong>AVI封装格式对应的AVOutputFormat结构体 <code>ff_avi_muxer</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write_header() -&gt; avi_write_header()</span><br><span class="line">write_packet() –&gt; avi_write_packet()</span><br><span class="line">write_trailer() -&gt; avi_write_trailer()</span><br></pre></td></tr></table></figure><h4 id="右下区域（AVCodec编解码函数）-1"><a href="#右下区域（AVCodec编解码函数）-1" class="headerlink" title="右下区域（AVCodec编解码函数）"></a>右下区域（AVCodec编解码函数）</h4><p>AVCodec包含如下编解码函数指针：</p><ul><li><strong><font color="#3072C2">init()：初始化</font></strong></li><li><strong><font color="#3072C2">encode2()：编码一帧数据</font></strong></li><li><strong><font color="#3072C2">close()：关闭</font></strong></li></ul><p>【例子】不同的编解码器对应着上述接口有不同的实现函数，举几个例子：</p><p><strong>HEVC编码器对应的AVCodec结构体 <code>ff_libx265_encoder</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() -&gt; libx265_encode_init() -&gt; x265_param_alloc(), x265_param_default_preset(), x265_encoder_open()</span><br><span class="line">encode2() -&gt; libx265_encode_frame() -&gt; x265_encoder_encode()</span><br><span class="line">close() -&gt; libx265_encode_close() -&gt; x265_param_free(), x265_encoder_close()</span><br></pre></td></tr></table></figure><p><strong>H.264编码器对应的AVCodec结构体 <code>ff_libx264_encoder</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() -&gt; X264_init() -&gt; x264_param_default(), x264_encoder_open(), x264_encoder_headers()</span><br><span class="line">encode2() -&gt; X264_frame() -&gt; x264_encoder_encode()</span><br><span class="line">close() -&gt; X264_close() -&gt; x264_encoder_close()</span><br></pre></td></tr></table></figure><p><strong>VP8编码器（libVPX）对应的AVCodec结构体 <code>ff_libvpx_vp8_encoder</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() -&gt; vpx_init() -&gt; vpx_codec_enc_config_default()</span><br><span class="line">encode2() -&gt; vp8_encode() -&gt; vpx_codec_enc_init(), vpx_codec_encode()</span><br><span class="line">close() -&gt; vp8_free() -&gt; vpx_codec_destroy()</span><br></pre></td></tr></table></figure><p><strong>MPEG2编码器对应的AVCodec结构体 <code>ff_mpeg2video_encoder</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() -&gt; encode_init()</span><br><span class="line">encode2() -&gt; ff_mpv_encode_picture()</span><br><span class="line">close() -&gt; ff_mpv_encode_end()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;特别说明，此文参考至&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDIyMDE1MQ==&quot; title=&quot;https://blog.csdn.net/leixiaohua1020/article/details/44220151&quot;&gt;雷神笔记&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;，做一个备忘录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;FFmpeg源代码结构图-解码&quot;&gt;&lt;a href=&quot;#FFmpeg源代码结构图-解码&quot; class=&quot;headerlink&quot; title=&quot;FFmpeg源代码结构图 - 解码&quot;&gt;&lt;/a&gt;FFmpeg源代码结构图 - 解码&lt;/h2&gt;&lt;p&gt;下图表明了 FFmpeg 在解码一个视频的时候的函数调用流程。为了保证结构清晰，其中仅列出了最关键的函数，剔除了其它不是特别重要的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFMpeg实时美颜直播推流</title>
    <link href="http://miaopei.github.io/2019/05/19/FFmpeg/ffmpeg%E5%AE%9E%E6%97%B6%E7%BE%8E%E9%A2%9C%E6%8E%A8%E6%B5%81/"/>
    <id>http://miaopei.github.io/2019/05/19/FFmpeg/ffmpeg实时美颜推流/</id>
    <published>2019-05-19T02:14:50.000Z</published>
    <updated>2019-06-11T09:08:50.443Z</updated>
    
    <content type="html"><![CDATA[<p>实战 - 基于ffmpeg，qt5，opencv视频课程</p><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-直播推流流程分析"><a href="#1-1-直播推流流程分析" class="headerlink" title="1.1 直播推流流程分析"></a>1.1 直播推流流程分析</h3><a id="more"></a><img src="/images/imageFFmpeg/直播.png"><p>rtmp 延时一般 1-3 秒</p><img src="/images/imageFFmpeg/推流流程.png"><h3 id="1-2-直播-rtmp-协议分析"><a href="#1-2-直播-rtmp-协议分析" class="headerlink" title="1.2 直播 rtmp 协议分析"></a>1.2 直播 rtmp 协议分析</h3><img src="/images/imageFFmpeg/协议.png"><img src="/images/imageFFmpeg/传输协议.png"><img src="/images/imageFFmpeg/RTMP.png"><img src="/images/imageFFmpeg/RTMP优缺点.png"><img src="/images/imageFFmpeg/RTMP协议类型.png"><img src="/images/imageFFmpeg/握手.png"><img src="/images/imageFFmpeg/推流.png"><h2 id="2-直播服务器讲解和配置"><a href="#2-直播服务器讲解和配置" class="headerlink" title="2. 直播服务器讲解和配置"></a>2. 直播服务器讲解和配置</h2><img src="/images/imageFFmpeg/流媒体服务器.png"><h3 id="2-1-直播服务器介绍-crtmpserver-编译运行"><a href="#2-1-直播服务器介绍-crtmpserver-编译运行" class="headerlink" title="2.1 直播服务器介绍 crtmpserver 编译运行"></a>2.1 直播服务器介绍 crtmpserver 编译运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-get install wget cmake</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt-get install libssl-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget  https://codeload.github.com/j0sh/crtmpserver/zip/centosinit --no-check-certificate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> unzip centosinit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> builders/cmake</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake . </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./crtmpserver/crtmpserver ./crtmpserver/crtmpserver.lua</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -i test.flv  -f flv rtmp://192.168.1.44/live</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ʹc rtmp://192.168.1.44/live</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ʹplay ffplay rtmp://192.168.1.44/live  -fflags nobuffer</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> error</span></span><br><span class="line">CMake Error at cmake_find_modules/Find_openssl.cmake:99 (MESSAGE):</span><br><span class="line">  Looking for openssl headers - not found</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  CMakeLists.txt:46 (INCLUDE)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -DOPENSSL_ROOT_DIR=/usr/<span class="built_in">local</span>/opt/openssl -DOPENSSL_LIBRARIES=/usr/<span class="built_in">local</span>/opt/openssl/lib</span></span><br></pre></td></tr></table></figure><h3 id="2-2-下载-ffmpeg-工具推流并使用功能-vlc-拉流播放测试"><a href="#2-2-下载-ffmpeg-工具推流并使用功能-vlc-拉流播放测试" class="headerlink" title="2.2 下载 ffmpeg 工具推流并使用功能 vlc 拉流播放测试"></a>2.2 下载 ffmpeg 工具推流并使用功能 vlc 拉流播放测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://nginx.org/download/nginx-1.16.0.tar.gz --no-check-certificate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/arut/nginx-rtmp-module.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --add-module=/home/miaopei/workdir/<span class="built_in">test</span>/ffmpet-test/nginx/nginx-rtmp-module </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/ffmpeg工具推流测试.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx.conf 配置</span></span><br><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4096;</span><br><span class="line">        application live &#123;</span><br><span class="line">            live on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推流命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.mp4 -c copy -f flv rtmp://192.168.2.76/live</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网页查看推流的状态</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    location /stat&#123;</span><br><span class="line">        rtmp_stat all;</span><br><span class="line">        rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">    &#125;</span><br><span class="line">    location /stat.xsl&#123;</span><br><span class="line">        root /home/miaopei/workdir/test/ffmpet-test/nginx/nginx-rtmp-module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reload config:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s reload</span></span><br><span class="line">Reopen Logfile:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s reopen</span></span><br><span class="line">Stop process:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s stop</span></span><br><span class="line">Waiting on exit process</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nginx -s quit</span></span><br></pre></td></tr></table></figure><h2 id="3-FFMpeg-SDK-解封和推流"><a href="#3-FFMpeg-SDK-解封和推流" class="headerlink" title="3. FFMpeg SDK 解封和推流"></a>3. FFMpeg SDK 解封和推流</h2><h3 id="3-1-ffmpeg-SDK开发环境准备"><a href="#3-1-ffmpeg-SDK开发环境准备" class="headerlink" title="3.1 ffmpeg SDK开发环境准备"></a>3.1 ffmpeg SDK开发环境准备</h3><img src="/images/imageFFmpeg/使用FFMpegSDK推流.png"><img src="/images/imageFFmpeg/avformat_open_input.png"><img src="/images/imageFFmpeg/AVFormatContext.png"><img src="/images/imageFFmpeg/AVStream.png"><img src="/images/imageFFmpeg/AVPacket.png"><img src="/images/imageFFmpeg/GOP.png"><img src="/images/imageFFmpeg/基于海康或大华相机推流.png"><h2 id="4-OpencvSDK-基础"><a href="#4-OpencvSDK-基础" class="headerlink" title="4. OpencvSDK 基础"></a>4. OpencvSDK 基础</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNjQxOTAvYXJ0aWNsZS9kZXRhaWxzLzc5MTA4NjA4" title="https://blog.csdn.net/u010164190/article/details/79108608">Mac源码安装使用OpenCV<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hcmtzaW0vYXJ0aWNsZS9kZXRhaWxzLzc5MTQ2MzQ2" title="https://blog.csdn.net/marksim/article/details/79146346">在MacOS 10.13.2 下编译 OpenCV3.4.0 + OpenCV Contrib 3.4.0 成 Java 库<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hMzZkNDEyNDFhZTg=" title="https://www.jianshu.com/p/a36d41241ae8">在MacOS上安装OpenCV 3.4(c++)<i class="fa fa-external-link"></i></span></p></blockquote><details><summary>OpenCV 源码编译：</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 OpenCV 3.4.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压，进入到 opencv-3.4.0 目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p build/install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -G <span class="string">"Unix Makefiles"</span> -j8 -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_OSX_ARCHITECTURES=x86_64 -D CMAKE_INSTALL_PREFIX=/Users/miaopei/install/opencv/opencv-3.4.0/build/install ../</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j8</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib/pkgconfig</span><br><span class="line">export PKG_CONFIG_PATH</span><br><span class="line">export LD_LIBRARY_PATH=Users/miaopei/install/opencv/opencv-3.4.0/build/install/bin:SLD_LIBRARY_PATH</span><br><span class="line">export PATH=$&#123;PATH&#125;:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试demo,打印当前版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;opencv2/core/utility.hpp&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;iostream&gt;</span></span><br><span class="line">int main(int argc, const char* argv[])&#123;</span><br><span class="line">  std::cout &lt;&lt; "Welcome to OpenCV " &lt;&lt; CV_VERSION &lt;&lt; std::endl; </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Makefile</span></span><br><span class="line">CXX ?= g++</span><br><span class="line">CXXFLAGS += -c -Wall $(shell pkg-config --cflags opencv)</span><br><span class="line">LDFLAGS += $(shell pkg-config --libs --static opencv)</span><br><span class="line">all: test_version</span><br><span class="line">opencv_example: test_version.o; $(CXX) $&lt; -o $@ $(LDFLAGS)</span><br><span class="line"><span class="meta">%</span><span class="bash">.o: %.cpp; $(CXX) $&lt; -o <span class="variable">$@</span> $(CXXFLAGS)</span></span><br><span class="line">clean: ; rm -f test_version.o test_version</span><br></pre></td></tr></table></figure></details><img src="/images/imageFFmpeg/第一个例子显示图片.png"><img src="/images/imageFFmpeg/waitKey.png"><h3 id="4-1-VideoCapture打开摄像头接口讲解和源码分析"><a href="#4-1-VideoCapture打开摄像头接口讲解和源码分析" class="headerlink" title="4.1 VideoCapture打开摄像头接口讲解和源码分析"></a>4.1 VideoCapture打开摄像头接口讲解和源码分析</h3><img src="/images/imageFFmpeg/打开摄像头接口说明和源码分析.png"><img src="/images/imageFFmpeg/创建和清理mat空间.png"><img src="/images/imageFFmpeg/图像存放方式-连续.png"><img src="/images/imageFFmpeg/isContinuous.png"><img src="/images/imageFFmpeg/直接地址访问连续空间.png"><img src="/images/imageFFmpeg/读取一帧视频.png"><h2 id="5-视频采集编码推流和类封装"><a href="#5-视频采集编码推流和类封装" class="headerlink" title="5. 视频采集编码推流和类封装"></a>5. 视频采集编码推流和类封装</h2><img src="/images/imageFFmpeg/基于opencv采集推流.png"><img src="/images/imageFFmpeg/opencv采集rtsp解码.png"><img src="/images/imageFFmpeg/sws_getCachedContext.png"><img src="/images/imageFFmpeg/sws_scale.png"><img src="/images/imageFFmpeg/avcodec_find_encoder.png"><img src="/images/imageFFmpeg/avcodec_alloc_context3.png"><img src="/images/imageFFmpeg/avcodec_alloc_context3-01.png"><img src="/images/imageFFmpeg/gop-01.png"><img src="/images/imageFFmpeg/avcodec_send_frame.png"><h2 id="6-音频录制编码推流和类封装"><a href="#6-音频录制编码推流和类封装" class="headerlink" title="6. 音频录制编码推流和类封装"></a>6. 音频录制编码推流和类封装</h2><img src="/images/imageFFmpeg/音频.png"><img src="/images/imageFFmpeg/样本类型planar.png"><img src="/images/imageFFmpeg/大小端模式.png"><img src="/images/imageFFmpeg/一帧数据量.png"><p>QT音频录制接口：</p><img src="/images/imageFFmpeg/QAudioFormat.png"><img src="/images/imageFFmpeg/QAudioInput.png"><img src="/images/imageFFmpeg/QIODevice.png"><h2 id="7-音视频同步编码推流处理"><a href="#7-音视频同步编码推流处理" class="headerlink" title="7. 音视频同步编码推流处理"></a>7. 音视频同步编码推流处理</h2><img src="/images/imageFFmpeg/视频录制接口封装.png"><img src="/images/imageFFmpeg/音视频同步.png"><h2 id="8-XRtmpStreamer-项目完成（界面和美颜）"><a href="#8-XRtmpStreamer-项目完成（界面和美颜）" class="headerlink" title="8. XRtmpStreamer 项目完成（界面和美颜）"></a>8. XRtmpStreamer 项目完成（界面和美颜）</h2><p>直播推流要求实时性，一秒钟25帧，做美颜的总耗时一定要低于40ms（每帧消耗40ms）</p><p>现在视频推流一般都是1280 X 720</p><p>手机端是基于GPU 第三方库做的计算</p><p>美颜算法一般都是基于GPU做的</p><img src="/images/imageFFmpeg/使用opencv磨皮.png"><img src="/images/imageFFmpeg/bilateralFilter双边滤波-边缘平滑.png"><img src="/images/imageFFmpeg/自定义过滤器类XFilter.png"><img src="/images/imageFFmpeg/XController.png"><img src="/images/imageFFmpeg/类图.png"><p><strong>头文件尽量不用引用命名空间，因为不知道谁来调用，可能会出现问题</strong>。</p><p><strong>头文件中尽量不要引用第三方库文件，应为涉及到第三方库版本升级之类的，第三方头文件的引用应该在代码中引用</strong>。</p><h2 id="9-补充"><a href="#9-补充" class="headerlink" title="9. 补充"></a>9. 补充</h2><h3 id="9-0-流媒体协议介绍（rtp-rtcp-rtsp-rtmp-mms-hls）"><a href="#9-0-流媒体协议介绍（rtp-rtcp-rtsp-rtmp-mms-hls）" class="headerlink" title="9.0 流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）"></a>9.0 流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）</h3><p><strong>1. RTP</strong>：</p><blockquote><p>参考文档 RFC3550/RFC3551</p></blockquote><p>(Real-time Transport Protocol) 是用于 Internet 上针对多媒体数据流的一种传输层协议。RTP 协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP 协议常用于流媒体系统（配合 RTCP协议），视频会议和一键通（Push to Talk）系统（配合 H.323 或 SIP），使它成为 IP 电话产业的技术基础。<strong>RTP 协议和 RTP 控制协议 RTCP 一起使用</strong>，而且它是建立在 <strong>UDP</strong> 协议上的。</p><p><strong>RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证</strong>，它依赖于低层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。</p><p><strong>RTP 由两个紧密链接部分组成</strong>： </p><ul><li>RTP ― 传送具有实时属性的数据；</li><li>RTP 控制协议（RTCP） ― 监控服务质量并传送正在进行的会话参与者的相关信息。</li></ul><p><strong>2. RTCP</strong></p><p>实时传输控制协议（Real-time Transport Control Protocol 或 RTP Control Protocol 或简写 RTCP）是实时传输协议（RTP）的一个姐妹协议。RTCP 为 RTP 媒体流提供信道外（out-of-band）控制。<strong>RTCP 本身并不传输数据，但和 RTP 一起协作将多媒体数据打包和发送</strong>。RTCP 定期在流多媒体会话参加者之间传输控制数据。RTCP 的主要功能是为 RTP 所提供的服务质量（Quality of Service）提供反馈。</p><p>RTCP 收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等等。网络应用程序可以利用 RTCP 所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP 本身不提供数据加密或身份认证。SRTCP 可以用于此类用途。</p><p><strong>3. SRTP &amp; SRTCP</strong></p><blockquote><p>参考文档 RFC3711</p></blockquote><p>安全实时传输协议（Secure Real-time Transport Protocol 或 SRTP）是在实时传输协议（Real-time Transport Protocol 或 RTP）基础上所定义的一个协议，<strong>旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护</strong>。它是由 David Oran（思科）和 Rolf Blom（爱立信）开发的，并最早由 IETF 于 2004年3月作为 RFC3711 发布。</p><p>由于实时传输协议和可以被用来控制实时传输协议的会话的实时传输控制协议（RTP Control Protocol 或 RTCP）有着紧密的联系，安全实时传输协议同样也有一个伴生协议，它被称为安全实时传输控制协议（Secure RTCP 或 SRTCP）；安全实时传输控制协议为实时传输控制协议提供类似的与安全有关的特性，就像安全实时传输协议为实时传输协议提供的那些一样。</p><p>在使用实时传输协议或实时传输控制协议时，使不使用安全实时传输协议或安全实时传输控制协议是可选的；但即使使用了安全实时传输协议或安全实时传输控制协议，所有它们提供的特性（如加密和认证）也都是可选的，这些特性可以被独立地使用或禁用。唯一的例外是在使用安全实时传输控制协议时，必须要用到其消息认证特性。</p><p><strong>4. RTSP</strong></p><blockquote><p>参考文档 RFC2326</p></blockquote><p>是由 Real Networks 和 Netscape 共同提出的。该协议定义了一对多应用程序如何有效地通过 IP 网络传送多媒体数据。RTSP 提供了一个可扩展框架，使实时数据，如音频与视频的受控、点播成为可能。数据源包括现场数据与存储在剪辑中的数据。<strong>该协议目的在于控制多个数据发送连接，为选择发送通道，如UDP、多播UDP与TCP提供途径，并为选择基于RTP上发送机制提供方法</strong>。</p><p>RTSP（Real Time Streaming Protocol）是用来控制声音或影像的多媒体串流协议，并允许同时多个串流需求控制，传输时所用的网络通讯协定并不在其定义的范围内，服务器端可以自行选择使用 TCP 或 UDP来传送串流内容，它的语法和运作跟 HTTP 1.1 类似，<strong>但并不特别强调时间同步，所以比较能容忍网络延迟</strong>。而前面提到的允许同时多个串流需求控制（Multicast），除了可以降低服务器端的网络用量，更进而支持多方视讯会议（Video Conference）。 因为与 HTTP1.1 的运作方式相似，所以代理服务器《Proxy》的快取功能《Cache》也同样适用于 RTSP，并因 RTSP 具有重新导向功能，可视实际负载情况来转换提供服务的服务器，以避免过大的负载集中于同一服务器而造成延迟。</p><p><strong>5. RTSP 和 RTP 的关系</strong></p><p>RTP 不象 http 和 ftp 可完整的下载整个影视文件，它是以固定的数据率在网络上发送数据，客户端也是按照这种速度观看影视文件，当影视画面播放过后，就不可以再重复播放，除非重新向服务器端要求数据。</p><p>RTSP 与 RTP 最大的区别在于：RTSP 是一种双向实时数据传输协议，它允许客户端向服务器端发送请求，如回放、快进、倒退等操作。当然，RTSP 可基于 RTP 来传送数据，还可以选择 TCP、UDP、组播 UDP 等通道来发送数据，具有很好的扩展性。它是一种类似与 http 协议的网络应用层协议。目前碰到的一个应用：服务器端实时采集、编码并发送两路视频，客户端接收并显示两路视频。由于客户端不必对视频数据做任何回放、倒退等操作，可直接采用 UDP + RTP + 组播实现。</p><img src="/images/imageFFmpeg/RTSP和RTP的关系.png"><p>RTP：实时传输协议（Real-time Transport Protocol） </p><ul><li><p>RTP/RTCP 是实际传输数据的协议 </p></li><li><p>RTP 传输音频/视频数据，如果是 PLAY，Server 发送到 Client 端，如果是 RECORD，可以由Client 发送到 Server </p></li><li><p>整个 RTP 协议由两个密切相关的部分组成：</p><ul><li>RTP数据协议</li><li>RTP控制协议（即RTCP） </li></ul></li></ul><p>RTSP：实时流协议（Real Time Streaming Protocol，RTSP） </p><ul><li><p>RTSP 的请求主要有 DESCRIBE, SETUP, PLAY, PAUSE, TEARDOWN, OPTIONS 等，顾名思义可以知道起对话和控制作用 </p></li><li><p>RTSP 的对话过程中 SETUP 可以确定 RTP/RTCP 使用的端口，PLAY/PAUSE/TEARDOWN 可以开始或者停止 RTP 的发送，等等 </p></li></ul><p>RTCP： </p><ul><li>RTCP 包括 Sender Report 和 Receiver Report，用来进行音频/视频的同步以及其他用途，是一种控制协议</li></ul><p><strong>6. SDP</strong></p><p>会话描述协议（SDP）为会话通知、会话邀请和其它形式的多媒体会话初始化等目的提供了多媒体会话描述。</p><p>会话目录用于协助多媒体会议的通告，并为会话参与者传送相关设置信息。SDP 即用于将这种信息传输到接收端。<strong>SDP 完全是一种会话描述格式 ― 它不属于传输协议 ― 它只使用不同的适当的传输协议，包括会话通知协议（SAP）、会话初始协议（SIP）、实时流协议（RTSP）、MIME 扩展协议的电子邮件以及超文本传输协议（HTTP）</strong>。</p><p>SDP 的设计宗旨是通用性，它可以应用于大范围的网络环境和应用程序，而不仅仅局限于组播会话目录，<strong>但 SDP 不支持会话内容或媒体编码的协商</strong>。</p><p>在因特网组播骨干网（Mbone）中，会话目录工具被用于通告多媒体会议，并为参与者传送会议地址和参与者所需的会议特定工具信息，这由 SDP 完成。SDP 连接好会话后，传送足够的信息给会话参与者。SDP 信息发送利用了会话通知协议（SAP），它周期性地组播通知数据包到已知组播地址和端口处。这些信息是 UDP 数据包，其中包含 SAP 协议头和文本有效载荷（text payload）。这里文本有效载荷指的是 SDP 会话描述。此外信息也可以通过电子邮件或 WWW （World Wide Web） 进行发送。</p><p><strong>SDP 文本信息包括</strong>：</p><ul><li>会话名称和意图；</li><li>会话持续时间；</li><li>构成会话的媒体；</li><li>有关接收媒体的信息（地址等）。</li><li>协议结构</li></ul><p><strong>SDP 信息是文本信息，采用 UTF-8 编 码中的 ISO 10646 字符集。SDP 会话描述如下：（标注 * 符号的表示可选字段）</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v = （协议版本）</span><br><span class="line">o = （所有者/创建者和会话标识符）</span><br><span class="line">s = （会话名称）</span><br><span class="line">i = * （会话信息）</span><br><span class="line">u = * （URI 描述）</span><br><span class="line">e = * （Email 地址）</span><br><span class="line">p = * （电话号码）</span><br><span class="line">c = * （连接信息 ― 如果包含在所有媒体中，则不需要该字段）</span><br><span class="line">b = * （带宽信息）</span><br></pre></td></tr></table></figure><p>一个或更多时间描述（如下所示）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z = * （时间区域调整）</span><br><span class="line">k = * （加密密钥）</span><br><span class="line">a = * （0 个或多个会话属性行）</span><br></pre></td></tr></table></figure><p>0个或多个媒体描述（如下所示）</p><p>时间描述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = （会话活动时间）</span><br><span class="line">r = * （0或多次重复次数）</span><br></pre></td></tr></table></figure><p>媒体描述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = （媒体名称和传输地址）</span><br><span class="line">i = * （媒体标题）</span><br><span class="line">c = * （连接信息 — 如果包含在会话层则该字段可选）</span><br><span class="line">b = * （带宽信息）</span><br><span class="line">k = * （加密密钥）</span><br><span class="line">a = * （0 个或多个会话属性行）</span><br></pre></td></tr></table></figure><p><strong>7. RTMP/RTMPS</strong></p><p>RTMP(Real Time Messaging Protocol) 实时消息传送协议是 Adobe Systems 公司为 Flash 播放器和服务器之间音频、视频和数据传输 开发的开放协议。</p><p>它有三种变种：</p><blockquote><p>1) 工作在 TCP 之上的明文协议，使用端口1935；</p><p>2) RTMPT 封装在 HTTP 请求之中，可穿越防火墙；</p><p>3) RTMPS 类似 RTMPT，但使用的是 HTTPS 连接；</p></blockquote><p>RTMP 协议(Real Time Messaging Protocol)是被 Flash 用于对象, 视频, 音频的传输. <strong>这个协议建立在 TCP 协议或者轮询 HTTP 协议之上</strong>.</p><p>RTMP 协议就像一个用来装数据包的容器, 这些数据既可以是 AMF 格式的数据,也可以是 FLV 中的视/音频数据. 一个单一的连接可以通过不同的通道传输多路网络流. 这些通道中的包都是按照固定大小的包传输的.</p><p><strong>8. mms</strong></p><p>MMS (Microsoft Media Server Protocol)，中文“微软媒体服务器协议”，用来访问并流式接收 Windows Media 服务器中 <code>.asf</code> 文件的一种协议。MMS 协议用于访问 Windows Media 发布点上的单播内容。MMS 是连接 Windows Media 单播服务的默认方法。若观众在 Windows Media Player 中键入一个 URL 以连接内容，而不是通过超级链接访问内容，则他们必须使用MMS 协议引用该流。MMS的预设埠（端口）是1755</p><p>当使用 MMS 协议连接到发布点时，使用协议翻转以获得最佳连接。“协议翻转”始于试图通过 MMSU 连接客户端。 MMSU 是 MMS 协议结合 UDP 数据传送。如果 MMSU 连接不成功，则服务器试图使用 MMST。MMST 是 MMS 协议结合 TCP 数据传送。</p><p>如果连接到编入索引的 <code>.asf</code> 文件，想要快进、后退、暂停、开始和停止流，则必须使用 MMS。不能用 UNC 路径快进或后退。若您从独立的 Windows Media Player 连接到发布点，则必须指定单播内容的 URL。若内容在主发布点点播发布，则 URL 由服务器名和 <code>.asf</code> 文件名组成。例如：<code>mms://windows_media_server/sample.asf</code>。其中 windows_media_server 是 Windows Media 服务器名，sample.asf 是您想要使之转化为流的 <code>.asf</code> 文件名。</p><p>若您有实时内容要通过广播单播发布，则该 URL 由服务器名和发布点别名组成。例如：<code>mms://windows_media_server/LiveEvents</code>。这里 windows_media_server 是 Windows Media 服务器名，而 LiveEvents 是发布点名</p><p><strong>9. HLS</strong></p><p>HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在 iOS 系统，为 iOS 设备（如iPhone、iPad）提供音视频直播和点播方案。HLS 点播，基本上就是常见的分段 HTTP 点播，不同在于，它的分段非常小。</p><p>相对于常见的流媒体直播协议，例如 RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS 协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，<strong>HLS 是以点播的技术方式来实现直播</strong>。由于数据通过 HTTP 协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过 HLS 的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。　</p><p>根据以上的了解要实现 HTTP Live Streaming 直播，需要研究并实现以下技术关键点：</p><ul><li>采集视频源和音频源的数据</li><li>对原始数据进行H264编码和AAC编码</li><li>视频和音频数据封装为MPEG-TS包</li><li>HLS分段生成策略及m3u8索引文件</li><li>HTTP传输协议</li></ul><h3 id="9-1-HLS，RTSP，RTMP的区别"><a href="#9-1-HLS，RTSP，RTMP的区别" class="headerlink" title="9.1 HLS，RTSP，RTMP的区别"></a>9.1 HLS，RTSP，RTMP的区别</h3><ul><li><p>HLS （ HTTP Live Streaming）苹果公司提出的流媒体协议，直接把流媒体切片成一段段，信息保存到m3u列表文件中，可以将不同速率的版本切成相应的片；播放器可以直接使用http协议请求流数据，可以在不同速率的版本间自由切换，实现无缝播放；省去使用其他协议的烦恼。缺点是延迟大小受切片大小影响，不适合直播，适合视频点播。</p></li><li><p>RTSP （Real-Time Stream Protocol）由Real Networks 和 Netscape共同提出的，基于文本的多媒体播放控制协议。RTSP定义流格式，流数据经由RTP传输；RTSP实时效果非常好，适合视频聊天，视频监控等方向。</p></li><li><p>RTMP（Real Time Message Protocol） 有 Adobe 公司提出，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题，优势在于低延迟，稳定性高，支持所有摄像头格式，浏览器加载 flash插件就可以直接播放。</p></li></ul><p>总结：HLS 延迟大，适合视频点播；RTSP虽然实时性最好，但是实现复杂，适合视频聊天和视频监控；RTMP强在浏览器支持好，加载flash插件后就能直接播放，所以非常火，相反在浏览器里播放rtsp就很困难了。</p><h3 id="9-2-RTSP、RTCP、RTP区别"><a href="#9-2-RTSP、RTCP、RTP区别" class="headerlink" title="9.2 RTSP、RTCP、RTP区别"></a>9.2 RTSP、RTCP、RTP区别</h3><p><strong>1：RTSP实时流协议</strong></p><p>作为一个应用层协议，RTSP提供了一个可供扩展的框架，它的意义在于使得实时流媒体数据的受控和点播变得可能。总的说来，RTSP是一个流媒体表示 协议，主要用来控制具有实时特性的数据发送，但它本身并不传输数据，而是必须依赖于下层传输协议所提供的某些服务。RTSP可以对流媒体提供诸如播放、暂 停、快进等操作，它负责定义具体的控制消息、操作方法、状态码等，此外还描述了与RTP间的交互操作（RFC2326）。</p><p><strong>2：RTCP控制协议</strong></p><p>RTCP控制协议需要与RTP数据协议一起配合使用，当应用程序启动一个RTP会话时将同时占用两个端口，分别供RTP和RTCP使用。RTP本身并 不能为按序传输数据包提供可靠的保证，也不提供流量控制和拥塞控制，这些都由RTCP来负责完成。通常RTCP会采用与RTP相同的分发机制，向会话中的 所有成员周期性地发送控制信息，应用程序通过接收这些数据，从中获取会话参与者的相关资料，以及网络状况、分组丢失概率等反馈信息，从而能够对服务质量进 行控制或者对网络状况进行诊断。</p><p>RTCP协议的功能是通过不同的RTCP数据报来实现的，主要有如下几种类型：</p><ul><li><p>SR：发送端报告，所谓发送端是指发出RTP数据报的应用程序或者终端，发送端同时也可以是接收端。(SERVER定时间发送给CLIENT)。</p></li><li><p>RR：接收端报告，所谓接收端是指仅接收但不发送RTP数据报的应用程序或者终端。(SERVER接收CLIENT端发送过来的响应)。</p></li><li><p>SDES：源描述，主要功能是作为会话成员有关标识信息的载体，如用户名、邮件地址、电话号码等，此外还具有向会话成员传达会话控制信息的功能。</p></li><li><p>BYE：通知离开，主要功能是指示某一个或者几个源不再有效，即通知会话中的其他成员自己将退出会话。</p></li><li><p>APP：由应用程序自己定义，解决了RTCP的扩展性问题，并且为协议的实现者提供了很大的灵活性。</p></li></ul><p><strong>3：RTP数据协议</strong></p><p>RTP数据协议负责对流媒体数据进行封包并实现媒体流的实时传输，每一个RTP数据报都由头部（Header）和负载（Payload）两个部分组成，其中头部前12个字节的含义是固定的，而负载则可以是音频或者视频数据。</p><p>RTP用到的地方就是 PLAY ，服务器往客户端传输数据用UDP协议，RTP是在传输数据的前面加了个12字节的头(描述信息)。</p><p>RTP载荷封装设计本文的网络传输是基于IP协议，所以最大传输单元(MTU)最大为1500字节，在使用IP／UDP／RTP的协议层次结构的时候，这 其中包括至少20字节的IP头，8字节的UDP头，以及12字节的RTP头。这样，头信息至少要占用40个字节，那么RTP载荷的最大尺寸为1460字 节。以H264 为例，如果一帧数据大于1460，则需要分片打包，然后到接收端再拆包，组合成一帧数据，进行解码播放。</p><h3 id="9-3-RTSP、-RTMP、HTTP的共同点、区别"><a href="#9-3-RTSP、-RTMP、HTTP的共同点、区别" class="headerlink" title="9.3 RTSP、 RTMP、HTTP的共同点、区别"></a>9.3 RTSP、 RTMP、HTTP的共同点、区别</h3><p>共同点：</p><ul><li>RTSP RTMP HTTP都是在应用应用层。</li><li>理论上RTSP RTMPHTTP都可以做直播和点播，但一般做直播用RTSP RTMP，做点播用HTTP。做视频会议的时候原来用SIP协议，现在基本上被RTMP协议取代了。</li></ul><p>区别：</p><ul><li><p>HTTP: 即超文本传送协议(ftp即文件传输协议)。</p><ul><li><p>HTTP:（Real Time Streaming Protocol），实时流传输协议。</p></li><li><p>HTTP全称Routing Table Maintenance Protocol（路由选择表维护协议）。</p></li></ul></li><li><p>HTTP将所有的数据作为文件做处理。http协议不是流媒体协议。</p><ul><li>RTMP 和 RTSP协议是流媒体协议。</li></ul></li><li><p>RTMP协议是Adobe的私有协议,未完全公开，RTSP协议和HTTP协议是共有协议，并有专门机构做维护。</p></li><li><p>RTMP协议一般传输的是flv，f4v格式流，RTSP协议一般传输的是ts,mp4格式的流。HTTP没有特定的流。</p></li><li><p>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实战 - 基于ffmpeg，qt5，opencv视频课程&lt;/p&gt;
&lt;h2 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1. 基础知识&quot;&gt;&lt;/a&gt;1. 基础知识&lt;/h2&gt;&lt;h3 id=&quot;1-1-直播推流流程分析&quot;&gt;&lt;a href=&quot;#1-1-直播推流流程分析&quot; class=&quot;headerlink&quot; title=&quot;1.1 直播推流流程分析&quot;&gt;&lt;/a&gt;1.1 直播推流流程分析&lt;/h3&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFMPEG+SDL视频播放器</title>
    <link href="http://miaopei.github.io/2019/05/18/FFmpeg/FFmpeg+SDL%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>http://miaopei.github.io/2019/05/18/FFmpeg/FFmpeg+SDL视频播放器/</id>
    <published>2019-05-18T02:14:50.000Z</published>
    <updated>2019-07-01T06:16:22.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hhdHN1bmVNaWt1Vi9GRm1wZWdfTGVpeGlhb2h1YQ==" title="https://github.com/HatsuneMikuV/FFmpeg_Leixiaohua">GitHub<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2NvbHVtbi9pbmZvL2ZmbXBlZy1kZXZlbC83" title="https://blog.csdn.net/leixiaohua1020/column/info/ffmpeg-devel/7">FFmpeg<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy8xMjY3NzEyOQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/12677129">ffmpeg 源代码简单分析<i class="fa fa-external-link"></i></span></p></blockquote><h1 id="100行代码实现最简单的基于FFMPEG-SDL的视频播放器"><a href="#100行代码实现最简单的基于FFMPEG-SDL的视频播放器" class="headerlink" title="100行代码实现最简单的基于FFMPEG+SDL的视频播放器"></a>100行代码实现最简单的基于FFMPEG+SDL的视频播放器</h1><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlaXhpYW9odWExMDIwL3NpbXBsZXN0X2ZmbXBlZ19wbGF5ZXI=" title="https://github.com/leixiaohua1020/simplest_ffmpeg_player">simplest_ffmpeg_player<i class="fa fa-external-link"></i></span></p></blockquote><p>该播放器虽然简单，但是几乎包含了使用FFMPEG播放一个视频所有必备的API，并且使用SDL显示解码出来的视频。</p><a id="more"></a><p>并且支持流媒体等多种视频输入，处于简单考虑，没有音频部分，同时视频播放采用直接延时40ms的方式</p><p><img src="/images/imageFFmpeg/Thor/%E6%92%AD%E6%94%BE%E5%99%A8%E8%A7%A3%E7%A0%81%E7%9A%84%E6%B5%81%E7%A8%8B%E7%94%A8%E5%9B%BE.png" alt="播放器解码的流程用图"></p><p><img src="/images/imageFFmpeg/Thor/SDL%E6%98%BE%E7%A4%BAYUV%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="SDL1.x显示YUV图像的流程图"></p><p><img src="/images/imageFFmpeg/Thor/SDL2.0%E6%98%BE%E7%A4%BAYUV%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="SDL2.0显示YUV的流程图"></p><p>对比SDL1.2的流程图，发现变化还是很大的。几乎所有的API都发生了变化。但是函数和变量有一定的对应关系：</p><p>SDL_SetVideoMode()————SDL_CreateWindow()</p><p>SDL_Surface————SDL_Window</p><p>SDL_CreateYUVOverlay()————SDL_CreateTexture()</p><p>SDL_Overlay————SDL_Texture</p><p>简单解释各个变量的作用：</p><ul><li>SDL_Window就是使用SDL的时候弹出的那个窗口。在SDL1.x版本中，只可以创建一个一个窗口。在SDL2.0版本中，可以创建多个窗口。</li><li>SDL_Texture用于显示YUV数据。一个SDL_Texture对应一帧YUV数据。</li><li>SDL_Renderer用于渲染SDL_Texture至SDL_Window。</li><li>SDL_Rect用于确定SDL_Texture显示的位置。注意：一个SDL_Texture可以指定多个不同的</li><li>SDL_Rect，这样就可以在SDL_Window不同位置显示相同的内容（使用SDL_RenderCopy()函数）。</li></ul><p>它们的关系如下图所示：</p><p><img src="/images/imageFFmpeg/Thor/%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p><p>下图举了个例子，指定了4个SDL_Rect，可以实现4分屏的显示。</p><p><img src="/images/imageFFmpeg/Thor/SDL_Rect%E5%9B%9B%E5%88%86%E5%B1%8F%E6%98%BE%E7%A4%BA.png" alt="SDL_Rect四分屏显示"></p><h2 id="simplest-ffmpeg-player（标准版）代码"><a href="#simplest-ffmpeg-player（标准版）代码" class="headerlink" title="simplest_ffmpeg_player（标准版）代码"></a>simplest_ffmpeg_player（标准版）代码</h2><details><summary>最基础的版本，学习的开始。</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最简单的基于FFmpeg的视频播放器 2</span></span><br><span class="line"><span class="comment"> * Simplest FFmpeg Player 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本程序实现了视频文件的解码和显示(支持HEVC，H.264，MPEG2等)。</span></span><br><span class="line"><span class="comment"> * 是最简单的FFmpeg视频解码方面的教程。</span></span><br><span class="line"><span class="comment"> * 通过学习本例子可以了解FFmpeg的解码流程。</span></span><br><span class="line"><span class="comment"> * This software is a simplest video player based on FFmpeg.</span></span><br><span class="line"><span class="comment"> * Suitable for beginner of FFmpeg.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_CONSTANT_MACROS</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">//Windows</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavcodec/avcodec.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavformat/avformat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libswscale/swscale.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavutil/imgutils.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SDL2/SDL.h"</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//Linux...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//Output YUV420P data as a file </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT_YUV420P 0</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVFormatContext*pFormatCtx; <span class="comment">// 音视频格式化上下文</span></span><br><span class="line"><span class="keyword">int</span>i, videoindex;</span><br><span class="line">AVCodecContext*pCodecCtx;<span class="comment">// 音视频编解码器上下文</span></span><br><span class="line">AVCodec*pCodec;<span class="comment">// 音视频编解码器</span></span><br><span class="line">AVFrame*pFrame, *pFrameYUV;<span class="comment">// 音视频数据帧</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *out_buffer;</span><br><span class="line">AVPacket *packet;<span class="comment">// 音视频数据包</span></span><br><span class="line"><span class="keyword">int</span> y_size;</span><br><span class="line"><span class="keyword">int</span> ret, got_picture;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">img_convert_ctx</span>;</span> <span class="comment">// 视频图像转换上下文</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> filepath[]=<span class="string">"bigbuckbunny_480x272.h265"</span>;</span><br><span class="line"><span class="comment">//SDL---------------------------</span></span><br><span class="line"><span class="keyword">int</span> screen_w=<span class="number">0</span>, screen_h=<span class="number">0</span>;</span><br><span class="line">SDL_Window *screen; </span><br><span class="line">SDL_Renderer*sdlRenderer; <span class="comment">// SDL渲染器</span></span><br><span class="line">SDL_Texture*sdlTexture;<span class="comment">// SDL纹理</span></span><br><span class="line">SDL_Rect sdlRect;<span class="comment">// 确定SDL_Texture显示的位置</span></span><br><span class="line"> </span><br><span class="line">FILE *fp_yuv;</span><br><span class="line"> </span><br><span class="line">av_register_all();<span class="comment">// 注册所有的编解码器</span></span><br><span class="line">avformat_network_init();</span><br><span class="line">pFormatCtx = avformat_alloc_context();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(avformat_open_input(&amp;pFormatCtx, filepath, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Couldn't open input stream.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(avformat_find_stream_info(pFormatCtx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Couldn't find stream information.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">videoindex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) </span><br><span class="line"><span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123;</span><br><span class="line">videoindex = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(videoindex == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Didn't find a video stream.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">pCodecCtx = pFormatCtx-&gt;streams[videoindex]-&gt;codec;</span><br><span class="line">pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span>(pCodec == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Codec not found.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(avcodec_open2(pCodecCtx, pCodec,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Could not open codec.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pFrame = av_frame_alloc();</span><br><span class="line">pFrameYUV = av_frame_alloc();</span><br><span class="line">out_buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P,  pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="number">1</span>));</span><br><span class="line">av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize,out_buffer,</span><br><span class="line">AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">packet = (AVPacket *)av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line"><span class="comment">//Output Info-----------------------------</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--------------- File Information ----------------\n"</span>);</span><br><span class="line">av_dump_format(pFormatCtx, <span class="number">0</span>, filepath, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-------------------------------------------------\n"</span>);</span><br><span class="line">img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, </span><br><span class="line">pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OUTPUT_YUV420P </span></span><br><span class="line">    fp_yuv=fopen(<span class="string">"output.yuv"</span>, <span class="string">"wb+"</span>);  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;  </span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError()); </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">screen_w = pCodecCtx-&gt;width;</span><br><span class="line">screen_h = pCodecCtx-&gt;height;</span><br><span class="line"><span class="comment">//SDL 2.0 Support for multiple windows</span></span><br><span class="line">screen = SDL_CreateWindow(<span class="string">"Simplest ffmpeg player's Window"</span>, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">screen_w, screen_h,</span><br><span class="line">SDL_WINDOW_OPENGL);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(!screen) &#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"SDL: could not create window - exiting:%s\n"</span>,SDL_GetError()); </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">sdlRenderer = SDL_CreateRenderer(screen, <span class="number">-1</span>, <span class="number">0</span>);  </span><br><span class="line"><span class="comment">//IYUV: Y + U + V  (3 planes)</span></span><br><span class="line"><span class="comment">//YV12: Y + V + U  (3 planes)</span></span><br><span class="line">sdlTexture = SDL_CreateTexture(sdlRenderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-&gt;width, pCodecCtx-&gt;height);  </span><br><span class="line"> </span><br><span class="line">sdlRect.x = <span class="number">0</span>;</span><br><span class="line">sdlRect.y = <span class="number">0</span>;</span><br><span class="line">sdlRect.w = screen_w;</span><br><span class="line">sdlRect.h = screen_h;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//SDL End----------------------</span></span><br><span class="line"><span class="keyword">while</span>(av_read_frame(pFormatCtx, packet)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(packet-&gt;stream_index == videoindex)&#123;</span><br><span class="line">ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Decode Error.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(got_picture)&#123;</span><br><span class="line">sws_scale(img_convert_ctx, (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="keyword">const</span>*)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height, </span><br><span class="line">pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OUTPUT_YUV420P</span></span><br><span class="line">y_size = pCodecCtx-&gt;width*pCodecCtx-&gt;height;  </span><br><span class="line">fwrite(pFrameYUV-&gt;data[<span class="number">0</span>], <span class="number">1</span>, y_size, fp_yuv);    <span class="comment">//Y </span></span><br><span class="line">fwrite(pFrameYUV-&gt;data[<span class="number">1</span>], <span class="number">1</span>, y_size/<span class="number">4</span>, fp_yuv);  <span class="comment">//U</span></span><br><span class="line">fwrite(pFrameYUV-&gt;data[<span class="number">2</span>], <span class="number">1</span>, y_size/<span class="number">4</span>, fp_yuv);  <span class="comment">//V</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//SDL---------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">SDL_UpdateTexture(sdlTexture, <span class="literal">NULL</span>, pFrameYUV-&gt;data[<span class="number">0</span>], pFrameYUV-&gt;linesize[<span class="number">0</span>]);  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">SDL_UpdateYUVTexture(sdlTexture, &amp;sdlRect,</span><br><span class="line">pFrameYUV-&gt;data[<span class="number">0</span>], pFrameYUV-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">pFrameYUV-&gt;data[<span class="number">1</span>], pFrameYUV-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">pFrameYUV-&gt;data[<span class="number">2</span>], pFrameYUV-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">SDL_RenderClear(sdlRenderer);  </span><br><span class="line">SDL_RenderCopy(sdlRenderer, sdlTexture, <span class="literal">NULL</span>, &amp;sdlRect);  </span><br><span class="line">SDL_RenderPresent(sdlRenderer);  </span><br><span class="line"><span class="comment">//SDL End-----------------------</span></span><br><span class="line"><span class="comment">//Delay 40ms</span></span><br><span class="line">SDL_Delay(<span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">av_free_packet(packet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//flush decoder</span></span><br><span class="line"><span class="comment">//FIX: Flush Frames remained in Codec</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!got_picture)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">sws_scale(img_convert_ctx, (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="keyword">const</span>*)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height, </span><br><span class="line">pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OUTPUT_YUV420P</span></span><br><span class="line"><span class="keyword">int</span> y_size = pCodecCtx-&gt;width*pCodecCtx-&gt;height;  </span><br><span class="line">fwrite(pFrameYUV-&gt;data[<span class="number">0</span>], <span class="number">1</span>, y_size, fp_yuv);    <span class="comment">//Y </span></span><br><span class="line">fwrite(pFrameYUV-&gt;data[<span class="number">1</span>], <span class="number">1</span>, y_size/<span class="number">4</span>, fp_yuv);  <span class="comment">//U</span></span><br><span class="line">fwrite(pFrameYUV-&gt;data[<span class="number">2</span>], <span class="number">1</span>, y_size/<span class="number">4</span>, fp_yuv);  <span class="comment">//V</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//SDL---------------------------</span></span><br><span class="line">SDL_UpdateTexture(sdlTexture, &amp;sdlRect, pFrameYUV-&gt;data[<span class="number">0</span>], pFrameYUV-&gt;linesize[<span class="number">0</span>]);  </span><br><span class="line">SDL_RenderClear(sdlRenderer);  </span><br><span class="line">SDL_RenderCopy(sdlRenderer, sdlTexture, <span class="literal">NULL</span>, &amp;sdlRect);  </span><br><span class="line">SDL_RenderPresent(sdlRenderer);  </span><br><span class="line"><span class="comment">//SDL End-----------------------</span></span><br><span class="line"><span class="comment">//Delay 40ms</span></span><br><span class="line">SDL_Delay(<span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">sws_freeContext(img_convert_ctx);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OUTPUT_YUV420P </span></span><br><span class="line">    fclose(fp_yuv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line">SDL_Quit();</span><br><span class="line"> </span><br><span class="line">av_frame_free(&amp;pFrameYUV);</span><br><span class="line">av_frame_free(&amp;pFrame);</span><br><span class="line">avcodec_close(pCodecCtx);</span><br><span class="line">avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="simplest-ffmpeg-player-su（SU版）代码"><a href="#simplest-ffmpeg-player-su（SU版）代码" class="headerlink" title="simplest_ffmpeg_player_su（SU版）代码"></a>simplest_ffmpeg_player_su（SU版）代码</h2><p>标准版的基础之上引入了 SDL 的 Event。</p><p>效果如下：</p><ul><li>SDL弹出的窗口可以移动了</li><li>画面显示是严格的40ms一帧</li></ul><details><summary>代码：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最简单的基于FFmpeg的视频播放器2(SDL升级版)</span></span><br><span class="line"><span class="comment"> * Simplest FFmpeg Player 2(SDL Update)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本程序实现了视频文件的解码和显示(支持HEVC，H.264，MPEG2等)。</span></span><br><span class="line"><span class="comment"> * 是最简单的FFmpeg视频解码方面的教程。</span></span><br><span class="line"><span class="comment"> * 通过学习本例子可以了解FFmpeg的解码流程。</span></span><br><span class="line"><span class="comment"> * 本版本中使用SDL消息机制刷新视频画面。</span></span><br><span class="line"><span class="comment"> * This software is a simplest video player based on FFmpeg.</span></span><br><span class="line"><span class="comment"> * Suitable for beginner of FFmpeg.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 备注:</span></span><br><span class="line"><span class="comment"> * 标准版在播放视频的时候，画面显示使用延时40ms的方式。这么做有两个后果：</span></span><br><span class="line"><span class="comment"> * （1）SDL弹出的窗口无法移动，一直显示是忙碌状态</span></span><br><span class="line"><span class="comment"> * （2）画面显示并不是严格的40ms一帧，因为还没有考虑解码的时间。</span></span><br><span class="line"><span class="comment"> * SU（SDL Update）版在视频解码的过程中，不再使用延时40ms的方式，而是创建了</span></span><br><span class="line"><span class="comment"> * 一个线程，每隔40ms发送一个自定义的消息，告知主函数进行解码显示。这样做之后：</span></span><br><span class="line"><span class="comment"> * （1）SDL弹出的窗口可以移动了</span></span><br><span class="line"><span class="comment"> * （2）画面显示是严格的40ms一帧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_CONSTANT_MACROS</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">//Windows</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavcodec/avcodec.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavformat/avformat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libswscale/swscale.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavutil/imgutils.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SDL2/SDL.h"</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//Linux...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//Refresh Event</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFM_REFRESH_EVENT  (SDL_USEREVENT + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFM_BREAK_EVENT  (SDL_USEREVENT + 2)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> thread_exit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> thread_pause = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfp_refresh_thread</span><span class="params">(<span class="keyword">void</span> *opaque)</span></span>&#123;</span><br><span class="line">thread_exit = <span class="number">0</span>;</span><br><span class="line">thread_pause = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (!thread_exit) &#123;</span><br><span class="line"><span class="keyword">if</span>(!thread_pause)&#123;</span><br><span class="line">SDL_Event event;</span><br><span class="line">event.type = SFM_REFRESH_EVENT;</span><br><span class="line">SDL_PushEvent(&amp;event);</span><br><span class="line">&#125;</span><br><span class="line">SDL_Delay(<span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line">thread_exit = <span class="number">0</span>;</span><br><span class="line">thread_pause = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//Break</span></span><br><span class="line">SDL_Event event;</span><br><span class="line">event.type = SFM_BREAK_EVENT;</span><br><span class="line">SDL_PushEvent(&amp;event);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVFormatContext*pFormatCtx;</span><br><span class="line"><span class="keyword">int</span>i, videoindex;</span><br><span class="line">AVCodecContext*pCodecCtx;<span class="comment">// 音视频编解码器上下文</span></span><br><span class="line">AVCodec*pCodec;</span><br><span class="line">AVFrame*pFrame, *pFrameYUV;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *out_buffer;</span><br><span class="line">AVPacket *packet;</span><br><span class="line"><span class="keyword">int</span> ret, got_picture;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//------------SDL----------------</span></span><br><span class="line"><span class="keyword">int</span> screen_w, screen_h;</span><br><span class="line">SDL_Window *screen; </span><br><span class="line">SDL_Renderer*sdlRenderer;</span><br><span class="line">SDL_Texture*sdlTexture;</span><br><span class="line">SDL_Rect sdlRect;</span><br><span class="line">SDL_Thread *video_tid;</span><br><span class="line">SDL_Event event;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">img_convert_ctx</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//char filepath[]="bigbuckbunny_480x272.h265";</span></span><br><span class="line"><span class="keyword">char</span> filepath[]=<span class="string">"Titanic.ts"</span>;</span><br><span class="line"> </span><br><span class="line">av_register_all();<span class="comment">// 注册所有的编解码器</span></span><br><span class="line">avformat_network_init();</span><br><span class="line">pFormatCtx = avformat_alloc_context(); <span class="comment">// 分配内存并设置默认值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 该函数用于打开多媒体数据并且获得一些相关的信息,AVInputFormat的read_header()完成了视音频流对应的AVStream的创建</span></span><br><span class="line"><span class="keyword">if</span>(avformat_open_input(&amp;pFormatCtx, filepath, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Couldn't open input stream.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 该函数可以读取一部分视音频数据并且获得一些相关的信息,该函数主要用于给每个媒体流（音频/视频）的AVStream结构体赋值</span></span><br><span class="line"><span class="keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Couldn't find stream information.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">videoindex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) </span><br><span class="line"><span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123;</span><br><span class="line">videoindex = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(videoindex == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Didn't find a video stream.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pCodecCtx = pFormatCtx-&gt;streams[videoindex]-&gt;codec; <span class="comment">// 找到视频流编解码器</span></span><br><span class="line">pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); </span><br><span class="line"><span class="keyword">if</span>(pCodec == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Codec not found.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 该函数用于初始化一个视音频编解码器的AVCodecContext</span></span><br><span class="line">    <span class="comment">//（1）为各种结构体分配内存（通过各种av_malloc()实现）。</span></span><br><span class="line"><span class="comment">//（2）将输入的AVDictionary形式的选项设置到AVCodecContext。</span></span><br><span class="line"><span class="comment">//（3）其他一些零零碎碎的检查，比如说检查编解码器是否处于“实验”阶段。</span></span><br><span class="line"><span class="comment">//（4）如果是编码器，检查输入参数是否符合编码器的要求</span></span><br><span class="line"><span class="comment">//（5）调用AVCodec的init()初始化具体的解码器。</span></span><br><span class="line"><span class="keyword">if</span>(avcodec_open2(pCodecCtx, pCodec,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Could not open codec.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pFrame = av_frame_alloc();</span><br><span class="line">pFrameYUV = av_frame_alloc();</span><br><span class="line"> </span><br><span class="line">out_buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="number">1</span>));</span><br><span class="line">av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize,</span><br><span class="line">                         out_buffer,AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, </span><br><span class="line">                         pCodecCtx-&gt;height, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Output Info-----------------------------</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"---------------- File Information ---------------\n"</span>);</span><br><span class="line">av_dump_format(pFormatCtx, <span class="number">0</span>, filepath, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个SwsContext</span></span><br><span class="line">    <span class="comment">// 参数说明：</span></span><br><span class="line">    <span class="comment">// 源图像的宽, 源图像的高, 源图像的像素格式, </span></span><br><span class="line">    <span class="comment">// 目标图像的宽, 目标图像的高, 目标图像的像素格式, 设定图像拉伸使用的算法</span></span><br><span class="line">img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, </span><br><span class="line">                                     pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, </span><br><span class="line">                                     pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, </span><br><span class="line">                                     SWS_BICUBIC, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;  </span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError()); </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//SDL 2.0 Support for multiple windows</span></span><br><span class="line">screen_w = pCodecCtx-&gt;width;</span><br><span class="line">screen_h = pCodecCtx-&gt;height;</span><br><span class="line">screen = SDL_CreateWindow(<span class="string">"Simplest ffmpeg player's Window"</span>, </span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              screen_w, screen_h, SDL_WINDOW_OPENGL);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(!screen) &#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"SDL: could not create window - exiting:%s\n"</span>,SDL_GetError()); </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sdlRenderer = SDL_CreateRenderer(screen, <span class="number">-1</span>, <span class="number">0</span>);  </span><br><span class="line"><span class="comment">//IYUV: Y + U + V  (3 planes)</span></span><br><span class="line"><span class="comment">//YV12: Y + V + U  (3 planes)</span></span><br><span class="line">sdlTexture = SDL_CreateTexture(sdlRenderer, SDL_PIXELFORMAT_IYUV, </span><br><span class="line">                                   SDL_TEXTUREACCESS_STREAMING, </span><br><span class="line">                                   pCodecCtx-&gt;width, pCodecCtx-&gt;height);  </span><br><span class="line"> </span><br><span class="line">sdlRect.x = <span class="number">0</span>;</span><br><span class="line">sdlRect.y = <span class="number">0</span>;</span><br><span class="line">sdlRect.w = screen_w;</span><br><span class="line">sdlRect.h = screen_h;</span><br><span class="line"> </span><br><span class="line">packet = (AVPacket *)av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line"> </span><br><span class="line">video_tid = SDL_CreateThread(sfp_refresh_thread, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//------------SDL End------------</span></span><br><span class="line"><span class="comment">//Event Loop</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">//Wait</span></span><br><span class="line">SDL_WaitEvent(&amp;event);</span><br><span class="line"><span class="keyword">if</span>(event.type == SFM_REFRESH_EVENT)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// av_read_frame()的作用是读取码流中的音频若干帧或者视频一帧</span></span><br><span class="line">                <span class="comment">// 例如，解码视频的时候，每解码一个视频帧，需要先调用 av_read_frame()获得一帧视频的压缩数据，然后才能对该数据进行解码（例如H.264中一帧压缩数据通常对应一个NAL）</span></span><br><span class="line">                <span class="comment">// 参数说明：输入的AVFormatContext, 输出的AVPacket</span></span><br><span class="line"><span class="keyword">if</span>(av_read_frame(pFormatCtx, packet)&lt;<span class="number">0</span>)</span><br><span class="line">thread_exit = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(packet-&gt;stream_index == videoindex)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 作用是解码一帧视频数据,输入一个压缩编码的结构体AVPacket，输出一个解码后的结构体AVFrame</span></span><br><span class="line">            <span class="comment">// avcodec_decode_video2()主要做了以下几个方面的工作：</span></span><br><span class="line">            <span class="comment">//（1）对输入的字段进行了一系列的检查工作：例如宽高是否正确，输入是否为视频等等。</span></span><br><span class="line"><span class="comment">//（2）通过ret = avctx-&gt;codec-&gt;decode(avctx, picture, got_picture_ptr,&amp;tmp)这句代码，调用了相应AVCodec的decode()函数，完成了解码操作。</span></span><br><span class="line"><span class="comment">//（3）对得到的AVFrame的一些字段进行了赋值，例如宽高、像素格式等等。</span></span><br><span class="line">ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Decode Error.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(got_picture)&#123;</span><br><span class="line">                <span class="comment">// sws_scale()是用于转换像素的函数</span></span><br><span class="line">                <span class="comment">// 参数说明：</span></span><br><span class="line">                <span class="comment">// 1）转换格式的上下文。也就是 sws_getContext 函数返回的结果。</span></span><br><span class="line">                <span class="comment">// 2）输入图像的每个颜色通道的数据指针</span></span><br><span class="line">                <span class="comment">// 3）输入图像的每个颜色通道的跨度</span></span><br><span class="line">                <span class="comment">// 4）参数int srcSliceY, int srcSliceH,定义在输入图像上处理区域，srcSliceY是起始位置，srcSliceH是处理多少行。</span></span><br><span class="line">                <span class="comment">// 如果srcSliceY=0，srcSliceH=height，表示一次性处理完整个图像。// 这种设置是为了多线程并行，例如可以创建两个线程，第一个线程处理 [0, h/2-1]行，第二个线程处理 [h/2, h-1]行。并行处理加快速度。</span></span><br><span class="line">                <span class="comment">// 5）参数uint8_t *const dst[], const int dstStride[]定义输出图像信息（输出的每个颜色通道数据指针，每个颜色通道行字节数）</span></span><br><span class="line">sws_scale(img_convert_ctx, </span><br><span class="line">                          (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="keyword">const</span>*)pFrame-&gt;data, </span><br><span class="line">                          pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height, </span><br><span class="line">                          pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"><span class="comment">//SDL---------------------------</span></span><br><span class="line">SDL_UpdateTexture( sdlTexture, <span class="literal">NULL</span>, pFrameYUV-&gt;data[<span class="number">0</span>], pFrameYUV-&gt;linesize[<span class="number">0</span>] );  </span><br><span class="line">SDL_RenderClear( sdlRenderer );  </span><br><span class="line"><span class="comment">//SDL_RenderCopy( sdlRenderer, sdlTexture, &amp;sdlRect, &amp;sdlRect );  </span></span><br><span class="line">SDL_RenderCopy( sdlRenderer, sdlTexture, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  </span><br><span class="line">SDL_RenderPresent( sdlRenderer );  </span><br><span class="line"><span class="comment">//SDL End-----------------------</span></span><br><span class="line">&#125;</span><br><span class="line">av_free_packet(packet);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.type == SDL_KEYDOWN)&#123;</span><br><span class="line"><span class="comment">//Pause</span></span><br><span class="line"><span class="keyword">if</span>(event.key.keysym.sym == SDLK_SPACE)</span><br><span class="line">thread_pause =! thread_pause;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.type == SDL_QUIT)&#123;</span><br><span class="line">thread_exit = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.type == SFM_BREAK_EVENT)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">sws_freeContext(img_convert_ctx);</span><br><span class="line"> </span><br><span class="line">SDL_Quit();</span><br><span class="line"><span class="comment">//--------------</span></span><br><span class="line">av_frame_free(&amp;pFrameYUV);</span><br><span class="line">av_frame_free(&amp;pFrame);</span><br><span class="line">avcodec_close(pCodecCtx);</span><br><span class="line">avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="av-read-packet"><a href="#av-read-packet" class="headerlink" title="av_read_packet()"></a>av_read_packet()</h3><p>通过 <code>av_read_packet()</code>，读取一个包，需要说明的是此函数必须是包含整数帧的，不存在半帧的情况。</p><p>以 ts 流为例，是读取一个完整的 PES 包（一个完整 pes 包包含若干视频或音频 es 包），读取完毕后，通过 <code>av_parser_parse2()</code> 分析出视频一帧（或音频若干帧），返回，下次进入循环的时候，如果上次的数据没有完全取完，则 <code>st = s-&gt;cur_st</code> ; 不会是NULL，即再此进入 <code>av_parser_parse2()</code> 流程，而不是下面的 <code>av_read_packet（）</code> 流程.</p><p>这样就保证了，如果读取一次包含了 N 帧视频数据（以视频为例），则调用 <code>av_read_frame（）</code> N 次都不会去读数据，而是返回第一次读取的数据，直到全部解析完毕。</p><p>函数调用结构图：</p><p><img src="/images/imageFFmpeg/Thor/av_read_packet.png" alt="av_read_packet"></p><h2 id="FFmpeg-源码分析"><a href="#FFmpeg-源码分析" class="headerlink" title="FFmpeg 源码分析"></a>FFmpeg 源码分析</h2><h3 id="av-register-all"><a href="#av-register-all" class="headerlink" title="av_register_all()"></a>av_register_all()</h3><ul><li><code>av_register_all()</code> - ffmpeg注册复用器，编码器</li></ul><p>该函数在所有基于ffmpeg的应用程序中几乎都是第一个被调用的。只有调用了该函数，才能使用复用器，编码器等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可见解复用器注册都是用</span></span><br><span class="line">REGISTER_DEMUXER  (X,x)</span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line">REGISTER_DEMUXER  (AAC, aac)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可见复用器注册都是用</span></span><br><span class="line">REGISTER_MUXER    (X,x))</span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line">REGISTER_MUXER    (ADTS, adts)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 既有解复用器又有复用器的话，可以用</span></span><br><span class="line">REGISTER_MUXDEMUX (X,x));</span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line">REGISTER_MUXDEMUX (AC3, ac3);</span><br></pre></td></tr></table></figure><p>看一下宏的定义，这里以<strong>解复用器</strong>为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_DEMUXER(X,x) &#123; \</span></span><br><span class="line">    <span class="keyword">extern</span> AVInputFormat ff_#<span class="meta">#x##_demuxer; \</span></span><br><span class="line">    <span class="keyword">if</span>(CONFIG_##X##_DEMUXER) av_register_input_format(&amp;ff_##x##_demuxer); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意：define 里面的##可能不太常见，它的含义就是拼接两个字符串，比如</span></span><br><span class="line"><span class="comment"> * #define Conn(x,y) x##y</span></span><br><span class="line"><span class="comment"> * 那么</span></span><br><span class="line"><span class="comment"> * int n = Conn(123,456);  结果就是 n = 123456;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>我们以 <code>REGISTER_DEMUXER  (AAC, aac)</code> 为例，则它等效于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> AVInputFormat ff_aac_demuxer; </span><br><span class="line"><span class="keyword">if</span>(CONFIG_AAC_DEMUXER) av_register_input_format(&amp;ff_aac_demuxer);</span><br></pre></td></tr></table></figure><p>从上面这段代码我们可以看出，真正注册的函数是 <code>av_register_input_format(&amp;ff_aac_demuxer)</code>，那我就看看这个和函数的作用，查看一下 <code>av_register_input_format()</code> 的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_register_input_format</span><span class="params">(AVInputFormat *format)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVInputFormat **p;</span><br><span class="line">    p = &amp;first_iformat;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="literal">NULL</span>) p = &amp;(*p)-&gt;next;</span><br><span class="line">    *p = format;</span><br><span class="line">    format-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是比较容易理解的，首先先提一点，first_iformat 是个什么东东呢？其实它是 Input Format 链表的头部地址，是一个全局静态变量，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** head of registered input format linked list */</span></span><br><span class="line"><span class="keyword">static</span> AVInputFormat *first_iformat = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>由此我们可以分析出 <code>av_register_input_format()</code> 的含义，一句话概括就是：</p><ul><li>遍历链表并把当前的 Input Format 加到链表的尾部。</li></ul><p>至此 <code>REGISTER_DEMUXER  (X, x)</code> 分析完毕。</p><p>同理，<strong>复用器</strong>道理是一样的，只是注册函数改为 <code>av_register_output_format()</code>；</p><p><strong>既有解复用器又有复用器</strong>的话，有一个宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_MUXDEMUX(X,x)  REGISTER_MUXER(X,x); REGISTER_DEMUXER(X,x)</span></span><br></pre></td></tr></table></figure><p>可见是分别注册了复用器和解复用器。</p><p>此外还有网络协议的注册，注册函数为 <code>ffurl_register_protocol()</code>，在此不再详述。</p><details><summary>下面贴出它的源代码（allformats.c）</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"avformat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rtp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rdt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"url.h"</span></span></span><br><span class="line"><span class="comment">// 定义的宏？宏的速度会快一点？注册 AVOutputFormat</span></span><br><span class="line"><span class="comment">// define中，#用来把参数转换成字符串，##则用来连接前后两个参数，把它们变成一个字符串。</span></span><br><span class="line"><span class="comment">// 感觉有点像JAva中的EL，可以随意拼接字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_MUXER(X,x) &#123; \</span></span><br><span class="line">    <span class="keyword">extern</span> AVOutputFormat ff_#<span class="meta">#x##_muxer; \</span></span><br><span class="line">    <span class="keyword">if</span>(CONFIG_##X##_MUXER) av_register_output_format(&amp;ff_##x##_muxer); &#125;</span><br><span class="line"><span class="comment">// 定义的宏？宏的速度会快一点？注册AVInputFormat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_DEMUXER(X,x) &#123; \</span></span><br><span class="line">    <span class="keyword">extern</span> AVInputFormat ff_#<span class="meta">#x##_demuxer; \</span></span><br><span class="line">    <span class="keyword">if</span>(CONFIG_##X##_DEMUXER) av_register_input_format(&amp;ff_##x##_demuxer); &#125;</span><br><span class="line"><span class="comment">// 注册函数 av_register_input_format</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义的宏？宏的速度会快一点？两个一起注册！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_MUXDEMUX(X,x)  REGISTER_MUXER(X,x); REGISTER_DEMUXER(X,x)</span></span><br><span class="line"><span class="comment">// 定义的宏？宏的速度会快一点？注册URLProtocol</span></span><br><span class="line"><span class="comment">// extern URLProtocol ff_##x##_protocol;</span></span><br><span class="line"><span class="comment">// 在 librtmp 中，对应的就是 ff_rtmp_protocol</span></span><br><span class="line"><span class="comment">// 这样就把 librtmp 整合起来了</span></span><br><span class="line"><span class="comment">// 由此可见 URLProtocol 的名字是固定的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_PROTOCOL(X,x) &#123; \</span></span><br><span class="line">    <span class="keyword">extern</span> URLProtocol ff_#<span class="meta">#x##_protocol; \</span></span><br><span class="line">    <span class="keyword">if</span>(CONFIG_##X##_PROTOCOL) ffurl_register_protocol(&amp;ff_##x##_protocol, <span class="keyword">sizeof</span>(ff_##x##_protocol)); &#125;</span><br><span class="line"><span class="comment">// 注册函数 ffurl_register_protocol</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_register_all</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> initialized;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (initialized)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注册所有的 codec</span></span><br><span class="line">    avcodec_register_all();</span><br><span class="line">    <span class="comment">// 注册所有的 MUXER（复用器和解复用器）</span></span><br><span class="line">    <span class="comment">/* (de)muxers */</span></span><br><span class="line">    REGISTER_MUXER    (A64, a64);</span><br><span class="line">    REGISTER_DEMUXER  (AAC, aac);</span><br><span class="line">    REGISTER_MUXDEMUX (AC3, ac3);</span><br><span class="line">    REGISTER_DEMUXER  (ACT, act);</span><br><span class="line">    REGISTER_DEMUXER  (ADF, adf);</span><br><span class="line">    REGISTER_MUXER    (ADTS, adts);</span><br><span class="line">    REGISTER_MUXDEMUX (ADX, adx);</span><br><span class="line">    REGISTER_DEMUXER  (AEA, aea);</span><br><span class="line">    REGISTER_MUXDEMUX (AIFF, aiff);</span><br><span class="line">    REGISTER_MUXDEMUX (AMR, amr);</span><br><span class="line">    REGISTER_DEMUXER  (ANM, anm);</span><br><span class="line">    REGISTER_DEMUXER  (APC, apc);</span><br><span class="line">    REGISTER_DEMUXER  (APE, ape);</span><br><span class="line">    REGISTER_DEMUXER  (APPLEHTTP, applehttp);</span><br><span class="line">    REGISTER_MUXDEMUX (ASF, asf);</span><br><span class="line">    REGISTER_MUXDEMUX (ASS, ass);</span><br><span class="line">    REGISTER_MUXER    (ASF_STREAM, asf_stream);</span><br><span class="line">    REGISTER_MUXDEMUX (AU, au);</span><br><span class="line">    REGISTER_MUXDEMUX (AVI, avi);</span><br><span class="line">    REGISTER_DEMUXER  (AVISYNTH, avisynth);</span><br><span class="line">    REGISTER_MUXER    (AVM2, avm2);</span><br><span class="line">    REGISTER_DEMUXER  (AVS, avs);</span><br><span class="line">    REGISTER_DEMUXER  (BETHSOFTVID, bethsoftvid);</span><br><span class="line">    REGISTER_DEMUXER  (BFI, bfi);</span><br><span class="line">    REGISTER_DEMUXER  (BINTEXT, bintext);</span><br><span class="line">    REGISTER_DEMUXER  (BINK, bink);</span><br><span class="line">    REGISTER_MUXDEMUX (BIT, bit);</span><br><span class="line">    REGISTER_DEMUXER  (BMV, bmv);</span><br><span class="line">    REGISTER_DEMUXER  (C93, c93);</span><br><span class="line">    REGISTER_MUXDEMUX (CAF, caf);</span><br><span class="line">    REGISTER_MUXDEMUX (CAVSVIDEO, cavsvideo);</span><br><span class="line">    REGISTER_DEMUXER  (CDG, cdg);</span><br><span class="line">    REGISTER_MUXER    (CRC, crc);</span><br><span class="line">    REGISTER_MUXDEMUX (DAUD, daud);</span><br><span class="line">    REGISTER_DEMUXER  (DFA, dfa);</span><br><span class="line">    REGISTER_MUXDEMUX (DIRAC, dirac);</span><br><span class="line">    REGISTER_MUXDEMUX (DNXHD, dnxhd);</span><br><span class="line">    REGISTER_DEMUXER  (DSICIN, dsicin);</span><br><span class="line">    REGISTER_MUXDEMUX (DTS, dts);</span><br><span class="line">    REGISTER_MUXDEMUX (DV, dv);</span><br><span class="line">    REGISTER_DEMUXER  (DXA, dxa);</span><br><span class="line">    REGISTER_DEMUXER  (EA, ea);</span><br><span class="line">    REGISTER_DEMUXER  (EA_CDATA, ea_cdata);</span><br><span class="line">    REGISTER_MUXDEMUX (EAC3, eac3);</span><br><span class="line">    REGISTER_MUXDEMUX (FFM, ffm);</span><br><span class="line">    REGISTER_MUXDEMUX (FFMETADATA, ffmetadata);</span><br><span class="line">    REGISTER_MUXDEMUX (FILMSTRIP, filmstrip);</span><br><span class="line">    REGISTER_MUXDEMUX (FLAC, flac);</span><br><span class="line">    REGISTER_DEMUXER  (FLIC, flic);</span><br><span class="line">    REGISTER_MUXDEMUX (FLV, flv);</span><br><span class="line">    REGISTER_DEMUXER  (FOURXM, fourxm);</span><br><span class="line">    REGISTER_MUXER    (FRAMECRC, framecrc);</span><br><span class="line">    REGISTER_MUXER    (FRAMEMD5, framemd5);</span><br><span class="line">    REGISTER_MUXDEMUX (G722, g722);</span><br><span class="line">    REGISTER_MUXDEMUX (G723_1, g723_1);</span><br><span class="line">    REGISTER_DEMUXER  (G729, g729);</span><br><span class="line">    REGISTER_MUXER    (GIF, gif);</span><br><span class="line">    REGISTER_DEMUXER  (GSM, gsm);</span><br><span class="line">    REGISTER_MUXDEMUX (GXF, gxf);</span><br><span class="line">    REGISTER_MUXDEMUX (H261, h261);</span><br><span class="line">    REGISTER_MUXDEMUX (H263, h263);</span><br><span class="line">    REGISTER_MUXDEMUX (H264, h264);</span><br><span class="line">    REGISTER_DEMUXER  (ICO, ico);</span><br><span class="line">    REGISTER_DEMUXER  (IDCIN, idcin);</span><br><span class="line">    REGISTER_DEMUXER  (IDF, idf);</span><br><span class="line">    REGISTER_DEMUXER  (IFF, iff);</span><br><span class="line">    REGISTER_MUXDEMUX (IMAGE2, image2);</span><br><span class="line">    REGISTER_MUXDEMUX (IMAGE2PIPE, image2pipe);</span><br><span class="line">    REGISTER_DEMUXER  (INGENIENT, ingenient);</span><br><span class="line">    REGISTER_DEMUXER  (IPMOVIE, ipmovie);</span><br><span class="line">    REGISTER_MUXER    (IPOD, ipod);</span><br><span class="line">    REGISTER_MUXER    (ISMV, ismv);</span><br><span class="line">    REGISTER_DEMUXER  (ISS, iss);</span><br><span class="line">    REGISTER_DEMUXER  (IV8, iv8);</span><br><span class="line">    REGISTER_MUXDEMUX (IVF, ivf);</span><br><span class="line">    REGISTER_DEMUXER  (JV, jv);</span><br><span class="line">    REGISTER_MUXDEMUX (LATM, latm);</span><br><span class="line">    REGISTER_DEMUXER  (LMLM4, lmlm4);</span><br><span class="line">    REGISTER_DEMUXER  (LOAS, loas);</span><br><span class="line">    REGISTER_DEMUXER  (LXF, lxf);</span><br><span class="line">    REGISTER_MUXDEMUX (M4V, m4v);</span><br><span class="line">    REGISTER_MUXER    (MD5, md5);</span><br><span class="line">    REGISTER_MUXDEMUX (MATROSKA, matroska);</span><br><span class="line">    REGISTER_MUXER    (MATROSKA_AUDIO, matroska_audio);</span><br><span class="line">    REGISTER_MUXDEMUX (MICRODVD, microdvd);</span><br><span class="line">    REGISTER_MUXDEMUX (MJPEG, mjpeg);</span><br><span class="line">    REGISTER_MUXDEMUX (MLP, mlp);</span><br><span class="line">    REGISTER_DEMUXER  (MM, mm);</span><br><span class="line">    REGISTER_MUXDEMUX (MMF, mmf);</span><br><span class="line">    REGISTER_MUXDEMUX (MOV, mov);</span><br><span class="line">    REGISTER_MUXER    (MP2, mp2);</span><br><span class="line">    REGISTER_MUXDEMUX (MP3, mp3);</span><br><span class="line">    REGISTER_MUXER    (MP4, mp4);</span><br><span class="line">    REGISTER_DEMUXER  (MPC, mpc);</span><br><span class="line">    REGISTER_DEMUXER  (MPC8, mpc8);</span><br><span class="line">    REGISTER_MUXER    (MPEG1SYSTEM, mpeg1system);</span><br><span class="line">    REGISTER_MUXER    (MPEG1VCD, mpeg1vcd);</span><br><span class="line">    REGISTER_MUXER    (MPEG1VIDEO, mpeg1video);</span><br><span class="line">    REGISTER_MUXER    (MPEG2DVD, mpeg2dvd);</span><br><span class="line">    REGISTER_MUXER    (MPEG2SVCD, mpeg2svcd);</span><br><span class="line">    REGISTER_MUXER    (MPEG2VIDEO, mpeg2video);</span><br><span class="line">    REGISTER_MUXER    (MPEG2VOB, mpeg2vob);</span><br><span class="line">    REGISTER_DEMUXER  (MPEGPS, mpegps);</span><br><span class="line">    REGISTER_MUXDEMUX (MPEGTS, mpegts);</span><br><span class="line">    REGISTER_DEMUXER  (MPEGTSRAW, mpegtsraw);</span><br><span class="line">    REGISTER_DEMUXER  (MPEGVIDEO, mpegvideo);</span><br><span class="line">    REGISTER_MUXER    (MPJPEG, mpjpeg);</span><br><span class="line">    REGISTER_DEMUXER  (MSNWC_TCP, msnwc_tcp);</span><br><span class="line">    REGISTER_DEMUXER  (MTV, mtv);</span><br><span class="line">    REGISTER_DEMUXER  (MVI, mvi);</span><br><span class="line">    REGISTER_MUXDEMUX (MXF, mxf);</span><br><span class="line">    REGISTER_MUXER    (MXF_D10, mxf_d10);</span><br><span class="line">    REGISTER_DEMUXER  (MXG, mxg);</span><br><span class="line">    REGISTER_DEMUXER  (NC, nc);</span><br><span class="line">    REGISTER_DEMUXER  (NSV, nsv);</span><br><span class="line">    REGISTER_MUXER    (<span class="literal">NULL</span>, null);</span><br><span class="line">    REGISTER_MUXDEMUX (NUT, nut);</span><br><span class="line">    REGISTER_DEMUXER  (NUV, nuv);</span><br><span class="line">    REGISTER_MUXDEMUX (OGG, ogg);</span><br><span class="line">    REGISTER_MUXDEMUX (OMA, oma);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_ALAW,  pcm_alaw);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_MULAW, pcm_mulaw);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_F64BE, pcm_f64be);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_F64LE, pcm_f64le);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_F32BE, pcm_f32be);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_F32LE, pcm_f32le);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_S32BE, pcm_s32be);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_S32LE, pcm_s32le);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_S24BE, pcm_s24be);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_S24LE, pcm_s24le);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_S16BE, pcm_s16be);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_S16LE, pcm_s16le);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_S8,    pcm_s8);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_U32BE, pcm_u32be);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_U32LE, pcm_u32le);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_U24BE, pcm_u24be);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_U24LE, pcm_u24le);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_U16BE, pcm_u16be);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_U16LE, pcm_u16le);</span><br><span class="line">    REGISTER_MUXDEMUX (PCM_U8,    pcm_u8);</span><br><span class="line">    REGISTER_DEMUXER  (PMP, pmp);</span><br><span class="line">    REGISTER_MUXER    (PSP, psp);</span><br><span class="line">    REGISTER_DEMUXER  (PVA, pva);</span><br><span class="line">    REGISTER_DEMUXER  (QCP, qcp);</span><br><span class="line">    REGISTER_DEMUXER  (R3D, r3d);</span><br><span class="line">    REGISTER_MUXDEMUX (RAWVIDEO, rawvideo);</span><br><span class="line">    REGISTER_DEMUXER  (RL2, rl2);</span><br><span class="line">    REGISTER_MUXDEMUX (RM, rm);</span><br><span class="line">    REGISTER_MUXDEMUX (ROQ, roq);</span><br><span class="line">    REGISTER_DEMUXER  (RPL, rpl);</span><br><span class="line">    REGISTER_MUXDEMUX (RSO, rso);</span><br><span class="line">    REGISTER_MUXDEMUX (RTP, rtp);</span><br><span class="line">    REGISTER_MUXDEMUX (RTSP, rtsp);</span><br><span class="line">    REGISTER_MUXDEMUX (SAP, sap);</span><br><span class="line">    REGISTER_DEMUXER  (SBG, sbg);</span><br><span class="line">    REGISTER_DEMUXER  (SDP, sdp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_RTPDEC</span></span><br><span class="line">    av_register_rtp_dynamic_payload_handlers();</span><br><span class="line">    av_register_rdt_dynamic_payload_handlers();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    REGISTER_DEMUXER  (SEGAFILM, segafilm);</span><br><span class="line">    REGISTER_MUXER    (SEGMENT, segment);</span><br><span class="line">    REGISTER_DEMUXER  (SHORTEN, shorten);</span><br><span class="line">    REGISTER_DEMUXER  (SIFF, siff);</span><br><span class="line">    REGISTER_DEMUXER  (SMACKER, smacker);</span><br><span class="line">    REGISTER_MUXDEMUX (SMJPEG, smjpeg);</span><br><span class="line">    REGISTER_DEMUXER  (SOL, sol);</span><br><span class="line">    REGISTER_MUXDEMUX (SOX, sox);</span><br><span class="line">    REGISTER_MUXDEMUX (SPDIF, spdif);</span><br><span class="line">    REGISTER_MUXDEMUX (SRT, srt);</span><br><span class="line">    REGISTER_DEMUXER  (STR, str);</span><br><span class="line">    REGISTER_MUXDEMUX (SWF, swf);</span><br><span class="line">    REGISTER_MUXER    (TG2, tg2);</span><br><span class="line">    REGISTER_MUXER    (TGP, tgp);</span><br><span class="line">    REGISTER_DEMUXER  (THP, thp);</span><br><span class="line">    REGISTER_DEMUXER  (TIERTEXSEQ, tiertexseq);</span><br><span class="line">    REGISTER_MUXER    (MKVTIMESTAMP_V2, mkvtimestamp_v2);</span><br><span class="line">    REGISTER_DEMUXER  (TMV, tmv);</span><br><span class="line">    REGISTER_MUXDEMUX (TRUEHD, truehd);</span><br><span class="line">    REGISTER_DEMUXER  (TTA, tta);</span><br><span class="line">    REGISTER_DEMUXER  (TXD, txd);</span><br><span class="line">    REGISTER_DEMUXER  (TTY, tty);</span><br><span class="line">    REGISTER_DEMUXER  (VC1, vc1);</span><br><span class="line">    REGISTER_MUXDEMUX (VC1T, vc1t);</span><br><span class="line">    REGISTER_DEMUXER  (VMD, vmd);</span><br><span class="line">    REGISTER_MUXDEMUX (VOC, voc);</span><br><span class="line">    REGISTER_DEMUXER  (VQF, vqf);</span><br><span class="line">    REGISTER_DEMUXER  (W64, w64);</span><br><span class="line">    REGISTER_MUXDEMUX (WAV, wav);</span><br><span class="line">    REGISTER_DEMUXER  (WC3, wc3);</span><br><span class="line">    REGISTER_MUXER    (WEBM, webm);</span><br><span class="line">    REGISTER_DEMUXER  (WSAUD, wsaud);</span><br><span class="line">    REGISTER_DEMUXER  (WSVQA, wsvqa);</span><br><span class="line">    REGISTER_MUXDEMUX (WTV, wtv);</span><br><span class="line">    REGISTER_DEMUXER  (WV, wv);</span><br><span class="line">    REGISTER_DEMUXER  (XA, xa);</span><br><span class="line">    REGISTER_DEMUXER  (XBIN, xbin);</span><br><span class="line">    REGISTER_DEMUXER  (XMV, xmv);</span><br><span class="line">    REGISTER_DEMUXER  (XWMA, xwma);</span><br><span class="line">    REGISTER_DEMUXER  (YOP, yop);</span><br><span class="line">    REGISTER_MUXDEMUX (YUV4MPEGPIPE, yuv4mpegpipe);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* external libraries */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_LIBMODPLUG</span></span><br><span class="line">    REGISTER_DEMUXER  (LIBMODPLUG, libmodplug);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    REGISTER_MUXDEMUX (LIBNUT, libnut);</span><br><span class="line">    <span class="comment">// 注册所有的 Protocol（位于 DEMUXER 之前（我的理解~~））</span></span><br><span class="line">    <span class="comment">// 文件也是一种Protocol</span></span><br><span class="line">    <span class="comment">/* protocols */</span></span><br><span class="line">    REGISTER_PROTOCOL (APPLEHTTP, applehttp);</span><br><span class="line">    REGISTER_PROTOCOL (CACHE, cache);</span><br><span class="line">    REGISTER_PROTOCOL (CONCAT, concat);</span><br><span class="line">    REGISTER_PROTOCOL (CRYPTO, crypto);</span><br><span class="line">    REGISTER_PROTOCOL (FILE, file);</span><br><span class="line">    REGISTER_PROTOCOL (GOPHER, gopher);</span><br><span class="line">    REGISTER_PROTOCOL (HTTP, http);</span><br><span class="line">    REGISTER_PROTOCOL (HTTPPROXY, httpproxy);</span><br><span class="line">    REGISTER_PROTOCOL (HTTPS, https);</span><br><span class="line">    REGISTER_PROTOCOL (MMSH, mmsh);</span><br><span class="line">    REGISTER_PROTOCOL (MMST, mmst);</span><br><span class="line">    REGISTER_PROTOCOL (MD5,  md5);</span><br><span class="line">    REGISTER_PROTOCOL (PIPE, pipe);</span><br><span class="line">    REGISTER_PROTOCOL (RTMP, rtmp);</span><br><span class="line"><span class="comment">// 如果包含了 LibRTMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_LIBRTMP</span></span><br><span class="line">    REGISTER_PROTOCOL (RTMP, rtmpt);</span><br><span class="line">    REGISTER_PROTOCOL (RTMP, rtmpe);</span><br><span class="line">    REGISTER_PROTOCOL (RTMP, rtmpte);</span><br><span class="line">    REGISTER_PROTOCOL (RTMP, rtmps);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    REGISTER_PROTOCOL (RTP, rtp);</span><br><span class="line">    REGISTER_PROTOCOL (TCP, tcp);</span><br><span class="line">    REGISTER_PROTOCOL (TLS, tls);</span><br><span class="line">    REGISTER_PROTOCOL (UDP, udp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>整个代码没太多可说的，首先确定是不是已经初始化过了（initialized），如果没有，就调用 <code>avcodec_register_all()</code> 注册编解码器（这个先不分析），然后就是注册，注册，注册…直到完成所有注册。</p><p>PS：曾经研究过一阵子 RTMP 协议，以及对应的开源工程 librtmp。在这里发现有一点值得注意，ffmpeg自带了 RTMP 协议的支持，只有使用 <code>rtmpt://, rtmpe://, rtmpte://</code> 等的时候才会使用 librtmp 库。</p><p>函数调用关系图如下图所示。<code>av_register_all()</code> 调用了 <code>avcodec_register_all()</code> 。 <code>avcodec_register_all()</code> 注册了和编解码器有关的组件：硬件加速器，解码器，编码器，Parser，Bitstream Filter。<code>av_register_all()</code> 除了调用 <code>avcodec_register_all()</code> 之外，还注册了复用器，解复用器，协议处理器。</p><p><img src="/images/imageFFmpeg/Thor/av_register_all.png" alt="av_register_all 函数调用关系图"></p><p>下面附上复用器，解复用器，协议处理器的代码。</p><p>注册复用器的函数是 <code>av_register_output_format()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_register_output_format</span><span class="params">(AVOutputFormat *format)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVOutputFormat **p;</span><br><span class="line">    p = &amp;first_oformat;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="literal">NULL</span>) p = &amp;(*p)-&gt;next;</span><br><span class="line">    *p = format;</span><br><span class="line">    format-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册解复用器的函数是 <code>av_register_input_format()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_register_input_format</span><span class="params">(AVInputFormat *format)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVInputFormat **p;</span><br><span class="line">    p = &amp;first_iformat;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="literal">NULL</span>) p = &amp;(*p)-&gt;next;</span><br><span class="line">    *p = format;</span><br><span class="line">    format-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册协议处理器的函数是 <code>ffurl_register_protocol()</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffurl_register_protocol</span><span class="params">(URLProtocol *protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    URLProtocol **p;</span><br><span class="line">    p = &amp;first_protocol;</span><br><span class="line">    <span class="keyword">while</span> (*p)</span><br><span class="line">        p = &amp;(*p)-&gt;next;</span><br><span class="line">    *p = protocol;</span><br><span class="line">    protocol-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="avcodec-register-all"><a href="#avcodec-register-all" class="headerlink" title="avcodec_register_all()"></a>avcodec_register_all()</h3><p>ffmpeg注册编解码器等的函数 <code>avcodec_register_all()</code>（注意不是 <code>av_register_all()</code>，那是注册所有东西的）。该函数在所有基于ffmpeg的应用程序中几乎都是第一个被调用的。只有调用了该函数，才能使用编解码器等。</p><p>其实注册编解码器和注册复用器解复用器道理是差不多的，重复的内容不再多说。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码器的注册是：</span></span><br><span class="line">REGISTER_ENCODER (X,x);REGISTER_ENCODER (LJPEG, ljpeg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码器的注册是：</span></span><br><span class="line">REGISTER_DECODER (X,x);REGISTER_DECODER (H264, h264);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 既包含编码器有包含解码器的注册是：</span></span><br><span class="line">REGISTER_ENCDEC  (X,x);REGISTER_ENCDEC  (BMP, bmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外还有几种注册：</span></span><br><span class="line"><span class="comment">// Parser：</span></span><br><span class="line">REGISTER_PARSER  (X,x);REGISTER_PARSER  (H264, h264);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BSF（bitstream filters，比特流滤镜，有一个常用：h264_mp4toannexb）：</span></span><br><span class="line">REGISTER_BSF     (X,x);REGISTER_BSF (H264_MP4TOANNEXB, h264_mp4toannexb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HWACCEL（hardware accelerators，硬件加速器）：</span></span><br><span class="line">REGISTER_HWACCEL (X,x);REGISTER_HWACCEL (H264_DXVA2, h264_dxva2);</span><br></pre></td></tr></table></figure><p>我们来看一下宏的定义，这里以编解码器为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_ENCODER(X,x) &#123; \</span></span><br><span class="line">          <span class="keyword">extern</span> AVCodec ff_#<span class="meta">#x##_encoder; \</span></span><br><span class="line">          <span class="keyword">if</span>(CONFIG_##X##_ENCODER)  avcodec_register(&amp;ff_##x##_encoder); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_DECODER(X,x) &#123; \</span></span><br><span class="line">          <span class="keyword">extern</span> AVCodec ff_#<span class="meta">#x##_decoder; \</span></span><br><span class="line">          <span class="keyword">if</span>(CONFIG_##X##_DECODER)  avcodec_register(&amp;ff_##x##_decoder); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_ENCDEC(X,x)  REGISTER_ENCODER(X,x); REGISTER_DECODER(X,x)</span></span><br></pre></td></tr></table></figure><p>在这里，我发现其实编码器和解码器用的注册函数都是一样的：<code>avcodec_register()</code></p><p>以 <code>REGISTER_DECODER (H264, h264)</code> 为例，就是等效于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> AVCodec ff_h264_decoder; </span><br><span class="line"><span class="keyword">if</span>(CONFIG_H264_DECODER)  avcodec_register(&amp;ff_h264_decoder);</span><br></pre></td></tr></table></figure><p>下面看一下 <code>avcodec_register()</code> 的源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册所有的AVCodec</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avcodec_register</span><span class="params">(AVCodec *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodec **p;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    avcodec_init();</span><br><span class="line">    <span class="comment">//从第一个开始</span></span><br><span class="line">    p = &amp;first_avcodec;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="literal">NULL</span>) p = &amp;(*p)-&gt;next;</span><br><span class="line">    *p = codec;</span><br><span class="line">    codec-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;init_static_data)</span><br><span class="line">        codec-&gt;init_static_data(codec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是比较容易理解的。首先先提一点，first_avcdec 是就是 AVCodec 链表的头部地址，是一个全局静态变量，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* encoder management */</span></span><br><span class="line"><span class="keyword">static</span> AVCodec *first_avcodec = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>由此我们可以分析出avcodec_register()的含义，一句话概括就是：遍历链表并把当前的AVCodec加到链表的尾部。<br>同理，<strong>Parser，BSF（bitstream filters，比特流滤镜），HWACCEL（hardware accelerators，硬件加速器）</strong>的注册方式都是类似的。不再详述。</p><details><summary>下面贴出它的原代码：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"avcodec.h"</span></span></span><br><span class="line"><span class="comment">// 硬件加速</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_HWACCEL(X,x) &#123; \</span></span><br><span class="line">          <span class="keyword">extern</span> AVHWAccel ff_#<span class="meta">#x##_hwaccel; \</span></span><br><span class="line">          <span class="keyword">if</span>(CONFIG_##X##_HWACCEL) av_register_hwaccel(&amp;ff_##x##_hwaccel); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_ENCODER(X,x) &#123; \</span></span><br><span class="line">          <span class="keyword">extern</span> AVCodec ff_#<span class="meta">#x##_encoder; \</span></span><br><span class="line">          <span class="keyword">if</span>(CONFIG_##X##_ENCODER)  avcodec_register(&amp;ff_##x##_encoder); &#125;</span><br><span class="line"><span class="comment">// 定义的宏？宏的速度会快一点？注册AVCodec</span></span><br><span class="line"><span class="comment">// extern AVCodec ff_##x##_decoder;</span></span><br><span class="line"><span class="comment">// 注意：extern 表明全局唯一</span></span><br><span class="line"><span class="comment">// 在h264中，对应的就是 ff_h264_decoder</span></span><br><span class="line"><span class="comment">// 由此可见 AVCodecParser 的名字是固定的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_DECODER(X,x) &#123; \</span></span><br><span class="line">          <span class="keyword">extern</span> AVCodec ff_#<span class="meta">#x##_decoder; \</span></span><br><span class="line">          <span class="keyword">if</span>(CONFIG_##X##_DECODER)  avcodec_register(&amp;ff_##x##_decoder); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_ENCDEC(X,x)  REGISTER_ENCODER(X,x); REGISTER_DECODER(X,x)</span></span><br><span class="line"><span class="comment">// 定义的宏？宏的速度会快一点？注册AVCodecParser</span></span><br><span class="line"><span class="comment">// extern AVCodecParser ff_##x##_parser;</span></span><br><span class="line"><span class="comment">// 在h264中，对应的就是ff_h264_parser</span></span><br><span class="line"><span class="comment">// 由此可见AVCodecParser的名字是固定的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_PARSER(X,x) &#123; \</span></span><br><span class="line">          <span class="keyword">extern</span> AVCodecParser ff_#<span class="meta">#x##_parser; \</span></span><br><span class="line">          <span class="keyword">if</span>(CONFIG_##X##_PARSER)  av_register_codec_parser(&amp;ff_##x##_parser); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_BSF(X,x) &#123; \</span></span><br><span class="line">          <span class="keyword">extern</span> AVBitStreamFilter ff_#<span class="meta">#x##_bsf; \</span></span><br><span class="line">          <span class="keyword">if</span>(CONFIG_##X##_BSF)     av_register_bitstream_filter(&amp;ff_##x##_bsf); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avcodec_register_all</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> initialized;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (initialized)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* hardware accelerators */</span></span><br><span class="line">    REGISTER_HWACCEL (H263_VAAPI, h263_vaapi);</span><br><span class="line">    REGISTER_HWACCEL (H264_DXVA2, h264_dxva2);</span><br><span class="line">    REGISTER_HWACCEL (H264_VAAPI, h264_vaapi);</span><br><span class="line">    REGISTER_HWACCEL (H264_VDA, h264_vda);</span><br><span class="line">    REGISTER_HWACCEL (MPEG1_VDPAU, mpeg1_vdpau);</span><br><span class="line">    REGISTER_HWACCEL (MPEG2_DXVA2, mpeg2_dxva2);</span><br><span class="line">    REGISTER_HWACCEL (MPEG2_VAAPI, mpeg2_vaapi);</span><br><span class="line">    REGISTER_HWACCEL (MPEG2_VDPAU, mpeg2_vdpau);</span><br><span class="line">    REGISTER_HWACCEL (MPEG4_VAAPI, mpeg4_vaapi);</span><br><span class="line">    REGISTER_HWACCEL (VC1_DXVA2, vc1_dxva2);</span><br><span class="line">    REGISTER_HWACCEL (VC1_VAAPI, vc1_vaapi);</span><br><span class="line">    REGISTER_HWACCEL (WMV3_DXVA2, wmv3_dxva2);</span><br><span class="line">    REGISTER_HWACCEL (WMV3_VAAPI, wmv3_vaapi);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* video codecs */</span></span><br><span class="line">    REGISTER_ENCODER (A64MULTI, a64multi);</span><br><span class="line">    REGISTER_ENCODER (A64MULTI5, a64multi5);</span><br><span class="line">    REGISTER_DECODER (AASC, aasc);</span><br><span class="line">    REGISTER_ENCDEC  (AMV, amv);</span><br><span class="line">    REGISTER_DECODER (ANM, anm);</span><br><span class="line">    REGISTER_DECODER (ANSI, ansi);</span><br><span class="line">    REGISTER_ENCDEC  (ASV1, asv1);</span><br><span class="line">    REGISTER_ENCDEC  (ASV2, asv2);</span><br><span class="line">    REGISTER_DECODER (AURA, aura);</span><br><span class="line">    REGISTER_DECODER (AURA2, aura2);</span><br><span class="line">    REGISTER_ENCDEC  (AVRP, avrp);</span><br><span class="line">    REGISTER_DECODER (AVS, avs);</span><br><span class="line">    REGISTER_DECODER (BETHSOFTVID, bethsoftvid);</span><br><span class="line">    REGISTER_DECODER (BFI, bfi);</span><br><span class="line">    REGISTER_DECODER (BINK, bink);</span><br><span class="line">    REGISTER_ENCDEC  (BMP, bmp);</span><br><span class="line">    REGISTER_DECODER (BMV_VIDEO, bmv_video);</span><br><span class="line">    REGISTER_DECODER (C93, c93);</span><br><span class="line">    REGISTER_DECODER (CAVS, cavs);</span><br><span class="line">    REGISTER_DECODER (CDGRAPHICS, cdgraphics);</span><br><span class="line">    REGISTER_DECODER (CINEPAK, cinepak);</span><br><span class="line">    REGISTER_ENCDEC  (CLJR, cljr);</span><br><span class="line">    REGISTER_DECODER (CSCD, cscd);</span><br><span class="line">    REGISTER_DECODER (CYUV, cyuv);</span><br><span class="line">    REGISTER_DECODER (DFA, dfa);</span><br><span class="line">    REGISTER_DECODER (DIRAC, dirac);</span><br><span class="line">    REGISTER_ENCDEC  (DNXHD, dnxhd);</span><br><span class="line">    REGISTER_ENCDEC  (DPX, dpx);</span><br><span class="line">    REGISTER_DECODER (DSICINVIDEO, dsicinvideo);</span><br><span class="line">    REGISTER_ENCDEC  (DVVIDEO, dvvideo);</span><br><span class="line">    REGISTER_DECODER (DXA, dxa);</span><br><span class="line">    REGISTER_DECODER (DXTORY, dxtory);</span><br><span class="line">    REGISTER_DECODER (EACMV, eacmv);</span><br><span class="line">    REGISTER_DECODER (EAMAD, eamad);</span><br><span class="line">    REGISTER_DECODER (EATGQ, eatgq);</span><br><span class="line">    REGISTER_DECODER (EATGV, eatgv);</span><br><span class="line">    REGISTER_DECODER (EATQI, eatqi);</span><br><span class="line">    REGISTER_DECODER (EIGHTBPS, eightbps);</span><br><span class="line">    REGISTER_DECODER (EIGHTSVX_EXP, eightsvx_exp);</span><br><span class="line">    REGISTER_DECODER (EIGHTSVX_FIB, eightsvx_fib);</span><br><span class="line">    REGISTER_DECODER (ESCAPE124, escape124);</span><br><span class="line">    REGISTER_DECODER (ESCAPE130, escape130);</span><br><span class="line">    REGISTER_ENCDEC  (FFV1, ffv1);</span><br><span class="line">    REGISTER_ENCDEC  (FFVHUFF, ffvhuff);</span><br><span class="line">    REGISTER_ENCDEC  (FLASHSV, flashsv);</span><br><span class="line">    REGISTER_ENCDEC  (FLASHSV2, flashsv2);</span><br><span class="line">    REGISTER_DECODER (FLIC, flic);</span><br><span class="line">    REGISTER_ENCDEC  (FLV, flv);</span><br><span class="line">    REGISTER_DECODER (FOURXM, fourxm);</span><br><span class="line">    REGISTER_DECODER (FRAPS, fraps);</span><br><span class="line">    REGISTER_DECODER (FRWU, frwu);</span><br><span class="line">    REGISTER_ENCDEC  (GIF, gif);</span><br><span class="line">    REGISTER_ENCDEC  (H261, h261);</span><br><span class="line">    REGISTER_ENCDEC  (H263, h263);</span><br><span class="line">    REGISTER_DECODER (H263I, h263i);</span><br><span class="line">    REGISTER_ENCODER (H263P, h263p);</span><br><span class="line">    REGISTER_DECODER (H264, h264);</span><br><span class="line">    REGISTER_DECODER (H264_CRYSTALHD, h264_crystalhd);</span><br><span class="line">    REGISTER_DECODER (H264_VDPAU, h264_vdpau);</span><br><span class="line">    REGISTER_ENCDEC  (HUFFYUV, huffyuv);</span><br><span class="line">    REGISTER_DECODER (IDCIN, idcin);</span><br><span class="line">    REGISTER_DECODER (IFF_BYTERUN1, iff_byterun1);</span><br><span class="line">    REGISTER_DECODER (IFF_ILBM, iff_ilbm);</span><br><span class="line">    REGISTER_DECODER (INDEO2, indeo2);</span><br><span class="line">    REGISTER_DECODER (INDEO3, indeo3);</span><br><span class="line">    REGISTER_DECODER (INDEO4, indeo4);</span><br><span class="line">    REGISTER_DECODER (INDEO5, indeo5);</span><br><span class="line">    REGISTER_DECODER (INTERPLAY_VIDEO, interplay_video);</span><br><span class="line">    REGISTER_ENCDEC  (JPEG2000, jpeg2000);</span><br><span class="line">    REGISTER_ENCDEC  (JPEGLS, jpegls);</span><br><span class="line">    REGISTER_DECODER (JV, jv);</span><br><span class="line">    REGISTER_DECODER (KGV1, kgv1);</span><br><span class="line">    REGISTER_DECODER (KMVC, kmvc);</span><br><span class="line">    REGISTER_DECODER (LAGARITH, lagarith);</span><br><span class="line">    REGISTER_ENCODER (LJPEG, ljpeg);</span><br><span class="line">    REGISTER_DECODER (LOCO, loco);</span><br><span class="line">    REGISTER_DECODER (MDEC, mdec);</span><br><span class="line">    REGISTER_DECODER (MIMIC, mimic);</span><br><span class="line">    REGISTER_ENCDEC  (MJPEG, mjpeg);</span><br><span class="line">    REGISTER_DECODER (MJPEGB, mjpegb);</span><br><span class="line">    REGISTER_DECODER (MMVIDEO, mmvideo);</span><br><span class="line">    REGISTER_DECODER (MOTIONPIXELS, motionpixels);</span><br><span class="line">    REGISTER_DECODER (MPEG_XVMC, mpeg_xvmc);</span><br><span class="line">    REGISTER_ENCDEC  (MPEG1VIDEO, mpeg1video);</span><br><span class="line">    REGISTER_ENCDEC  (MPEG2VIDEO, mpeg2video);</span><br><span class="line">    REGISTER_ENCDEC  (MPEG4, mpeg4);</span><br><span class="line">    REGISTER_DECODER (MPEG4_CRYSTALHD, mpeg4_crystalhd);</span><br><span class="line">    REGISTER_DECODER (MPEG4_VDPAU, mpeg4_vdpau);</span><br><span class="line">    REGISTER_DECODER (MPEGVIDEO, mpegvideo);</span><br><span class="line">    REGISTER_DECODER (MPEG_VDPAU, mpeg_vdpau);</span><br><span class="line">    REGISTER_DECODER (MPEG1_VDPAU, mpeg1_vdpau);</span><br><span class="line">    REGISTER_DECODER (MPEG2_CRYSTALHD, mpeg2_crystalhd);</span><br><span class="line">    REGISTER_DECODER (MSMPEG4_CRYSTALHD, msmpeg4_crystalhd);</span><br><span class="line">    REGISTER_DECODER (MSMPEG4V1, msmpeg4v1);</span><br><span class="line">    REGISTER_ENCDEC  (MSMPEG4V2, msmpeg4v2);</span><br><span class="line">    REGISTER_ENCDEC  (MSMPEG4V3, msmpeg4v3);</span><br><span class="line">    REGISTER_DECODER (MSRLE, msrle);</span><br><span class="line">    REGISTER_ENCDEC  (MSVIDEO1, msvideo1);</span><br><span class="line">    REGISTER_DECODER (MSZH, mszh);</span><br><span class="line">    REGISTER_DECODER (MXPEG, mxpeg);</span><br><span class="line">    REGISTER_DECODER (NUV, nuv);</span><br><span class="line">    REGISTER_ENCDEC  (PAM, pam);</span><br><span class="line">    REGISTER_ENCDEC  (PBM, pbm);</span><br><span class="line">    REGISTER_ENCDEC  (PCX, pcx);</span><br><span class="line">    REGISTER_ENCDEC  (PGM, pgm);</span><br><span class="line">    REGISTER_ENCDEC  (PGMYUV, pgmyuv);</span><br><span class="line">    REGISTER_DECODER (PICTOR, pictor);</span><br><span class="line">    REGISTER_ENCDEC  (PNG, png);</span><br><span class="line">    REGISTER_ENCDEC  (PPM, ppm);</span><br><span class="line">    REGISTER_ENCDEC  (PRORES, prores);</span><br><span class="line">    REGISTER_DECODER (PRORES_LGPL, prores_lgpl);</span><br><span class="line">    REGISTER_DECODER (PTX, ptx);</span><br><span class="line">    REGISTER_DECODER (QDRAW, qdraw);</span><br><span class="line">    REGISTER_DECODER (QPEG, qpeg);</span><br><span class="line">    REGISTER_ENCDEC  (QTRLE, qtrle);</span><br><span class="line">    REGISTER_ENCDEC  (R10K,  r10k);</span><br><span class="line">    REGISTER_ENCDEC  (R210,  r210);</span><br><span class="line">    REGISTER_ENCDEC  (RAWVIDEO, rawvideo);</span><br><span class="line">    REGISTER_DECODER (RL2, rl2);</span><br><span class="line">    REGISTER_ENCDEC  (ROQ, roq);</span><br><span class="line">    REGISTER_DECODER (RPZA, rpza);</span><br><span class="line">    REGISTER_ENCDEC  (RV10, rv10);</span><br><span class="line">    REGISTER_ENCDEC  (RV20, rv20);</span><br><span class="line">    REGISTER_DECODER (RV30, rv30);</span><br><span class="line">    REGISTER_DECODER (RV40, rv40);</span><br><span class="line">    REGISTER_DECODER (S302M, s302m);</span><br><span class="line">    REGISTER_ENCDEC  (SGI, sgi);</span><br><span class="line">    REGISTER_DECODER (SMACKER, smacker);</span><br><span class="line">    REGISTER_DECODER (SMC, smc);</span><br><span class="line">    REGISTER_ENCDEC  (SNOW, snow);</span><br><span class="line">    REGISTER_DECODER (SP5X, sp5x);</span><br><span class="line">    REGISTER_DECODER (SUNRAST, sunrast);</span><br><span class="line">    REGISTER_ENCDEC  (SVQ1, svq1);</span><br><span class="line">    REGISTER_DECODER (SVQ3, svq3);</span><br><span class="line">    REGISTER_ENCDEC  (TARGA, targa);</span><br><span class="line">    REGISTER_DECODER (THEORA, theora);</span><br><span class="line">    REGISTER_DECODER (THP, thp);</span><br><span class="line">    REGISTER_DECODER (TIERTEXSEQVIDEO, tiertexseqvideo);</span><br><span class="line">    REGISTER_ENCDEC  (TIFF, tiff);</span><br><span class="line">    REGISTER_DECODER (TMV, tmv);</span><br><span class="line">    REGISTER_DECODER (TRUEMOTION1, truemotion1);</span><br><span class="line">    REGISTER_DECODER (TRUEMOTION2, truemotion2);</span><br><span class="line">    REGISTER_DECODER (TSCC, tscc);</span><br><span class="line">    REGISTER_DECODER (TXD, txd);</span><br><span class="line">    REGISTER_DECODER (ULTI, ulti);</span><br><span class="line">    REGISTER_DECODER (UTVIDEO, utvideo);</span><br><span class="line">    REGISTER_ENCDEC  (V210,  v210);</span><br><span class="line">    REGISTER_DECODER (V210X, v210x);</span><br><span class="line">    REGISTER_ENCDEC  (V308, v308);</span><br><span class="line">    REGISTER_ENCDEC  (V410, v410);</span><br><span class="line">    REGISTER_DECODER (VB, vb);</span><br><span class="line">    REGISTER_DECODER (VBLE, vble);</span><br><span class="line">    REGISTER_DECODER (VC1, vc1);</span><br><span class="line">    REGISTER_DECODER (VC1_CRYSTALHD, vc1_crystalhd);</span><br><span class="line">    REGISTER_DECODER (VC1_VDPAU, vc1_vdpau);</span><br><span class="line">    REGISTER_DECODER (VC1IMAGE, vc1image);</span><br><span class="line">    REGISTER_DECODER (VCR1, vcr1);</span><br><span class="line">    REGISTER_DECODER (VMDVIDEO, vmdvideo);</span><br><span class="line">    REGISTER_DECODER (VMNC, vmnc);</span><br><span class="line">    REGISTER_DECODER (VP3, vp3);</span><br><span class="line">    REGISTER_DECODER (VP5, vp5);</span><br><span class="line">    REGISTER_DECODER (VP6, vp6);</span><br><span class="line">    REGISTER_DECODER (VP6A, vp6a);</span><br><span class="line">    REGISTER_DECODER (VP6F, vp6f);</span><br><span class="line">    REGISTER_DECODER (VP8, vp8);</span><br><span class="line">    REGISTER_DECODER (VQA, vqa);</span><br><span class="line">    REGISTER_ENCDEC  (WMV1, wmv1);</span><br><span class="line">    REGISTER_ENCDEC  (WMV2, wmv2);</span><br><span class="line">    REGISTER_DECODER (WMV3, wmv3);</span><br><span class="line">    REGISTER_DECODER (WMV3_CRYSTALHD, wmv3_crystalhd);</span><br><span class="line">    REGISTER_DECODER (WMV3_VDPAU, wmv3_vdpau);</span><br><span class="line">    REGISTER_DECODER (WMV3IMAGE, wmv3image);</span><br><span class="line">    REGISTER_DECODER (WNV1, wnv1);</span><br><span class="line">    REGISTER_DECODER (XAN_WC3, xan_wc3);</span><br><span class="line">    REGISTER_DECODER (XAN_WC4, xan_wc4);</span><br><span class="line">    REGISTER_DECODER (XL, xl);</span><br><span class="line">    REGISTER_ENCDEC  (XWD, xwd);</span><br><span class="line">    REGISTER_ENCDEC  (Y41P, y41p);</span><br><span class="line">    REGISTER_DECODER (YOP, yop);</span><br><span class="line">    REGISTER_ENCDEC  (YUV4, yuv4);</span><br><span class="line">    REGISTER_ENCDEC  (ZLIB, zlib);</span><br><span class="line">    REGISTER_ENCDEC  (ZMBV, zmbv);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* audio codecs */</span></span><br><span class="line">    REGISTER_ENCDEC  (AAC, aac);</span><br><span class="line">    REGISTER_DECODER (AAC_LATM, aac_latm);</span><br><span class="line">    REGISTER_ENCDEC  (AC3, ac3);</span><br><span class="line">    REGISTER_ENCODER (AC3_FIXED, ac3_fixed);</span><br><span class="line">    REGISTER_ENCDEC  (ALAC, alac);</span><br><span class="line">    REGISTER_DECODER (ALS, als);</span><br><span class="line">    REGISTER_DECODER (AMRNB, amrnb);</span><br><span class="line">    REGISTER_DECODER (AMRWB, amrwb);</span><br><span class="line">    REGISTER_DECODER (APE, ape);</span><br><span class="line">    REGISTER_DECODER (ATRAC1, atrac1);</span><br><span class="line">    REGISTER_DECODER (ATRAC3, atrac3);</span><br><span class="line">    REGISTER_DECODER (BINKAUDIO_DCT, binkaudio_dct);</span><br><span class="line">    REGISTER_DECODER (BINKAUDIO_RDFT, binkaudio_rdft);</span><br><span class="line">    REGISTER_DECODER (BMV_AUDIO, bmv_audio);</span><br><span class="line">    REGISTER_DECODER (COOK, cook);</span><br><span class="line">    REGISTER_ENCDEC  (DCA, dca);</span><br><span class="line">    REGISTER_DECODER (DSICINAUDIO, dsicinaudio);</span><br><span class="line">    REGISTER_ENCDEC  (EAC3, eac3);</span><br><span class="line">    REGISTER_DECODER (FFWAVESYNTH, ffwavesynth);</span><br><span class="line">    REGISTER_ENCDEC  (FLAC, flac);</span><br><span class="line">    REGISTER_ENCDEC  (G723_1, g723_1);</span><br><span class="line">    REGISTER_DECODER (G729, g729);</span><br><span class="line">    REGISTER_DECODER (GSM, gsm);</span><br><span class="line">    REGISTER_DECODER (GSM_MS, gsm_ms);</span><br><span class="line">    REGISTER_DECODER (IMC, imc);</span><br><span class="line">    REGISTER_DECODER (MACE3, mace3);</span><br><span class="line">    REGISTER_DECODER (MACE6, mace6);</span><br><span class="line">    REGISTER_DECODER (MLP, mlp);</span><br><span class="line">    REGISTER_DECODER (MP1, mp1);</span><br><span class="line">    REGISTER_DECODER (MP1FLOAT, mp1float);</span><br><span class="line">    REGISTER_ENCDEC  (MP2, mp2);</span><br><span class="line">    REGISTER_DECODER (MP2FLOAT, mp2float);</span><br><span class="line">    REGISTER_DECODER (MP3, mp3);</span><br><span class="line">    REGISTER_DECODER (MP3FLOAT, mp3float);</span><br><span class="line">    REGISTER_DECODER (MP3ADU, mp3adu);</span><br><span class="line">    REGISTER_DECODER (MP3ADUFLOAT, mp3adufloat);</span><br><span class="line">    REGISTER_DECODER (MP3ON4, mp3on4);</span><br><span class="line">    REGISTER_DECODER (MP3ON4FLOAT, mp3on4float);</span><br><span class="line">    REGISTER_DECODER (MPC7, mpc7);</span><br><span class="line">    REGISTER_DECODER (MPC8, mpc8);</span><br><span class="line">    REGISTER_ENCDEC  (NELLYMOSER, nellymoser);</span><br><span class="line">    REGISTER_DECODER (QCELP, qcelp);</span><br><span class="line">    REGISTER_DECODER (QDM2, qdm2);</span><br><span class="line">    REGISTER_ENCDEC  (RA_144, ra_144);</span><br><span class="line">    REGISTER_DECODER (RA_288, ra_288);</span><br><span class="line">    REGISTER_DECODER (SHORTEN, shorten);</span><br><span class="line">    REGISTER_DECODER (SIPR, sipr);</span><br><span class="line">    REGISTER_DECODER (SMACKAUD, smackaud);</span><br><span class="line">    REGISTER_ENCDEC  (SONIC, sonic);</span><br><span class="line">    REGISTER_ENCODER (SONIC_LS, sonic_ls);</span><br><span class="line">    REGISTER_DECODER (TRUEHD, truehd);</span><br><span class="line">    REGISTER_DECODER (TRUESPEECH, truespeech);</span><br><span class="line">    REGISTER_DECODER (TTA, tta);</span><br><span class="line">    REGISTER_DECODER (TWINVQ, twinvq);</span><br><span class="line">    REGISTER_DECODER (VMDAUDIO, vmdaudio);</span><br><span class="line">    REGISTER_ENCDEC  (VORBIS, vorbis);</span><br><span class="line">    REGISTER_DECODER (WAVPACK, wavpack);</span><br><span class="line">    REGISTER_DECODER (WMALOSSLESS, wmalossless);</span><br><span class="line">    REGISTER_DECODER (WMAPRO, wmapro);</span><br><span class="line">    REGISTER_ENCDEC  (WMAV1, wmav1);</span><br><span class="line">    REGISTER_ENCDEC  (WMAV2, wmav2);</span><br><span class="line">    REGISTER_DECODER (WMAVOICE, wmavoice);</span><br><span class="line">    REGISTER_DECODER (WS_SND1, ws_snd1);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* PCM codecs */</span></span><br><span class="line">    REGISTER_ENCDEC  (PCM_ALAW, pcm_alaw);</span><br><span class="line">    REGISTER_DECODER (PCM_BLURAY, pcm_bluray);</span><br><span class="line">    REGISTER_DECODER (PCM_DVD, pcm_dvd);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_F32BE, pcm_f32be);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_F32LE, pcm_f32le);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_F64BE, pcm_f64be);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_F64LE, pcm_f64le);</span><br><span class="line">    REGISTER_DECODER (PCM_LXF, pcm_lxf);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_MULAW, pcm_mulaw);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_S8, pcm_s8);</span><br><span class="line">    REGISTER_DECODER (PCM_S8_PLANAR, pcm_s8_planar);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_S16BE, pcm_s16be);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_S16LE, pcm_s16le);</span><br><span class="line">    REGISTER_DECODER (PCM_S16LE_PLANAR, pcm_s16le_planar);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_S24BE, pcm_s24be);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_S24DAUD, pcm_s24daud);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_S24LE, pcm_s24le);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_S32BE, pcm_s32be);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_S32LE, pcm_s32le);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_U8, pcm_u8);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_U16BE, pcm_u16be);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_U16LE, pcm_u16le);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_U24BE, pcm_u24be);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_U24LE, pcm_u24le);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_U32BE, pcm_u32be);</span><br><span class="line">    REGISTER_ENCDEC  (PCM_U32LE, pcm_u32le);</span><br><span class="line">    REGISTER_DECODER (PCM_ZORK , pcm_zork);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* DPCM codecs */</span></span><br><span class="line">    REGISTER_DECODER (INTERPLAY_DPCM, interplay_dpcm);</span><br><span class="line">    REGISTER_ENCDEC  (ROQ_DPCM, roq_dpcm);</span><br><span class="line">    REGISTER_DECODER (SOL_DPCM, sol_dpcm);</span><br><span class="line">    REGISTER_DECODER (XAN_DPCM, xan_dpcm);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ADPCM codecs */</span></span><br><span class="line">    REGISTER_DECODER (ADPCM_4XM, adpcm_4xm);</span><br><span class="line">    REGISTER_ENCDEC  (ADPCM_ADX, adpcm_adx);</span><br><span class="line">    REGISTER_DECODER (ADPCM_CT, adpcm_ct);</span><br><span class="line">    REGISTER_DECODER (ADPCM_EA, adpcm_ea);</span><br><span class="line">    REGISTER_DECODER (ADPCM_EA_MAXIS_XA, adpcm_ea_maxis_xa);</span><br><span class="line">    REGISTER_DECODER (ADPCM_EA_R1, adpcm_ea_r1);</span><br><span class="line">    REGISTER_DECODER (ADPCM_EA_R2, adpcm_ea_r2);</span><br><span class="line">    REGISTER_DECODER (ADPCM_EA_R3, adpcm_ea_r3);</span><br><span class="line">    REGISTER_DECODER (ADPCM_EA_XAS, adpcm_ea_xas);</span><br><span class="line">    REGISTER_ENCDEC  (ADPCM_G722, adpcm_g722);</span><br><span class="line">    REGISTER_ENCDEC  (ADPCM_G726, adpcm_g726);</span><br><span class="line">    REGISTER_DECODER (ADPCM_IMA_AMV, adpcm_ima_amv);</span><br><span class="line">    REGISTER_DECODER (ADPCM_IMA_APC, adpcm_ima_apc);</span><br><span class="line">    REGISTER_DECODER (ADPCM_IMA_DK3, adpcm_ima_dk3);</span><br><span class="line">    REGISTER_DECODER (ADPCM_IMA_DK4, adpcm_ima_dk4);</span><br><span class="line">    REGISTER_DECODER (ADPCM_IMA_EA_EACS, adpcm_ima_ea_eacs);</span><br><span class="line">    REGISTER_DECODER (ADPCM_IMA_EA_SEAD, adpcm_ima_ea_sead);</span><br><span class="line">    REGISTER_DECODER (ADPCM_IMA_ISS, adpcm_ima_iss);</span><br><span class="line">    REGISTER_ENCDEC  (ADPCM_IMA_QT, adpcm_ima_qt);</span><br><span class="line">    REGISTER_DECODER (ADPCM_IMA_SMJPEG, adpcm_ima_smjpeg);</span><br><span class="line">    REGISTER_ENCDEC  (ADPCM_IMA_WAV, adpcm_ima_wav);</span><br><span class="line">    REGISTER_DECODER (ADPCM_IMA_WS, adpcm_ima_ws);</span><br><span class="line">    REGISTER_ENCDEC  (ADPCM_MS, adpcm_ms);</span><br><span class="line">    REGISTER_DECODER (ADPCM_SBPRO_2, adpcm_sbpro_2);</span><br><span class="line">    REGISTER_DECODER (ADPCM_SBPRO_3, adpcm_sbpro_3);</span><br><span class="line">    REGISTER_DECODER (ADPCM_SBPRO_4, adpcm_sbpro_4);</span><br><span class="line">    REGISTER_ENCDEC  (ADPCM_SWF, adpcm_swf);</span><br><span class="line">    REGISTER_DECODER (ADPCM_THP, adpcm_thp);</span><br><span class="line">    REGISTER_DECODER (ADPCM_XA, adpcm_xa);</span><br><span class="line">    REGISTER_ENCDEC  (ADPCM_YAMAHA, adpcm_yamaha);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* subtitles */</span></span><br><span class="line">    REGISTER_ENCDEC  (ASS, ass);</span><br><span class="line">    REGISTER_ENCDEC  (DVBSUB, dvbsub);</span><br><span class="line">    REGISTER_ENCDEC  (DVDSUB, dvdsub);</span><br><span class="line">    REGISTER_DECODER (PGSSUB, pgssub);</span><br><span class="line">    REGISTER_ENCDEC  (SRT, srt);</span><br><span class="line">    REGISTER_ENCDEC  (XSUB, xsub);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* external libraries */</span></span><br><span class="line">    REGISTER_ENCODER (LIBAACPLUS, libaacplus);</span><br><span class="line">    REGISTER_DECODER (LIBCELT, libcelt);</span><br><span class="line">    REGISTER_ENCDEC  (LIBDIRAC, libdirac);</span><br><span class="line">    REGISTER_ENCODER (LIBFAAC, libfaac);</span><br><span class="line">    REGISTER_ENCDEC  (LIBGSM, libgsm);</span><br><span class="line">    REGISTER_ENCDEC  (LIBGSM_MS, libgsm_ms);</span><br><span class="line">    REGISTER_ENCODER (LIBMP3LAME, libmp3lame);</span><br><span class="line">    REGISTER_ENCDEC  (LIBOPENCORE_AMRNB, libopencore_amrnb);</span><br><span class="line">    REGISTER_DECODER (LIBOPENCORE_AMRWB, libopencore_amrwb);</span><br><span class="line">    REGISTER_ENCDEC (LIBOPENJPEG, libopenjpeg);</span><br><span class="line">    REGISTER_ENCDEC  (LIBSCHROEDINGER, libschroedinger);</span><br><span class="line">    REGISTER_ENCDEC  (LIBSPEEX, libspeex);</span><br><span class="line">    REGISTER_DECODER (LIBSTAGEFRIGHT_H264, libstagefright_h264);</span><br><span class="line">    REGISTER_ENCODER (LIBTHEORA, libtheora);</span><br><span class="line">    REGISTER_DECODER (LIBUTVIDEO, libutvideo);</span><br><span class="line">    REGISTER_ENCODER (LIBVO_AACENC, libvo_aacenc);</span><br><span class="line">    REGISTER_ENCODER (LIBVO_AMRWBENC, libvo_amrwbenc);</span><br><span class="line">    REGISTER_ENCODER (LIBVORBIS, libvorbis);</span><br><span class="line">    REGISTER_ENCDEC  (LIBVPX, libvpx);</span><br><span class="line">    REGISTER_ENCODER (LIBX264, libx264);</span><br><span class="line">    REGISTER_ENCODER (LIBX264RGB, libx264rgb);</span><br><span class="line">    REGISTER_ENCODER (LIBXAVS, libxavs);</span><br><span class="line">    REGISTER_ENCODER (LIBXVID, libxvid);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* text */</span></span><br><span class="line">    REGISTER_DECODER (BINTEXT, bintext);</span><br><span class="line">    REGISTER_DECODER  (XBIN, xbin);</span><br><span class="line">    REGISTER_DECODER  (IDF, idf);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* parsers */</span></span><br><span class="line">    REGISTER_PARSER  (AAC, aac);</span><br><span class="line">    REGISTER_PARSER  (AAC_LATM, aac_latm);</span><br><span class="line">    REGISTER_PARSER  (AC3, ac3);</span><br><span class="line">    REGISTER_PARSER  (ADX, adx);</span><br><span class="line">    REGISTER_PARSER  (CAVSVIDEO, cavsvideo);</span><br><span class="line">    REGISTER_PARSER  (DCA, dca);</span><br><span class="line">    REGISTER_PARSER  (DIRAC, dirac);</span><br><span class="line">    REGISTER_PARSER  (DNXHD, dnxhd);</span><br><span class="line">    REGISTER_PARSER  (DVBSUB, dvbsub);</span><br><span class="line">    REGISTER_PARSER  (DVDSUB, dvdsub);</span><br><span class="line">    REGISTER_PARSER  (FLAC, flac);</span><br><span class="line">    REGISTER_PARSER  (GSM, gsm);</span><br><span class="line">    REGISTER_PARSER  (H261, h261);</span><br><span class="line">    REGISTER_PARSER  (H263, h263);</span><br><span class="line">    REGISTER_PARSER  (H264, h264);</span><br><span class="line">    REGISTER_PARSER  (MJPEG, mjpeg);</span><br><span class="line">    REGISTER_PARSER  (MLP, mlp);</span><br><span class="line">    REGISTER_PARSER  (MPEG4VIDEO, mpeg4video);</span><br><span class="line">    REGISTER_PARSER  (MPEGAUDIO, mpegaudio);</span><br><span class="line">    REGISTER_PARSER  (MPEGVIDEO, mpegvideo);</span><br><span class="line">    REGISTER_PARSER  (PNM, pnm);</span><br><span class="line">    REGISTER_PARSER  (RV30, rv30);</span><br><span class="line">    REGISTER_PARSER  (RV40, rv40);</span><br><span class="line">    REGISTER_PARSER  (VC1, vc1);</span><br><span class="line">    REGISTER_PARSER  (VP3, vp3);</span><br><span class="line">    REGISTER_PARSER  (VP8, vp8);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* bitstream filters */</span></span><br><span class="line">    REGISTER_BSF     (AAC_ADTSTOASC, aac_adtstoasc);</span><br><span class="line">    REGISTER_BSF     (CHOMP, chomp);</span><br><span class="line">    REGISTER_BSF     (DUMP_EXTRADATA, dump_extradata);</span><br><span class="line">    REGISTER_BSF     (H264_MP4TOANNEXB, h264_mp4toannexb);</span><br><span class="line">    REGISTER_BSF     (IMX_DUMP_HEADER, imx_dump_header);</span><br><span class="line">    REGISTER_BSF     (MJPEG2JPEG, mjpeg2jpeg);</span><br><span class="line">    REGISTER_BSF     (MJPEGA_DUMP_HEADER, mjpega_dump_header);</span><br><span class="line">    REGISTER_BSF     (MP3_HEADER_COMPRESS, mp3_header_compress);</span><br><span class="line">    REGISTER_BSF     (MP3_HEADER_DECOMPRESS, mp3_header_decompress);</span><br><span class="line">    REGISTER_BSF     (MOV2TEXTSUB, mov2textsub);</span><br><span class="line">    REGISTER_BSF     (NOISE, noise);</span><br><span class="line">    REGISTER_BSF     (REMOVE_EXTRADATA, remove_extradata);</span><br><span class="line">    REGISTER_BSF     (TEXT2MOVSUB, text2movsub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>整个代码的过程就是首先确定是不是已经初始化过了（initialized），如果没有，就注册，注册，注册…直到完成所有注册。</p><p>函数的调用关系图如下图所示。<code>av_register_all()</code> 调用了 <code>avcodec_register_all()</code>。因此如果调用过 <code>av_register_all()</code> 的话就不需要再调用 <code>avcodec_register_all()</code> 了。</p><p><img src="/images/imageFFmpeg/Thor/av_register_all.png" alt="av_register_all 函数调用关系图"></p><p>下面附上硬件加速器，编码器/解码器，parser，Bitstream Filter的注册代码。</p><p>硬件加速器注册函数是 <code>av_register_hwaccel()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_register_hwaccel</span><span class="params">(AVHWAccel *hwaccel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVHWAccel **p = last_hwaccel;</span><br><span class="line">    hwaccel-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(*p || avpriv_atomic_ptr_cas((<span class="keyword">void</span> * <span class="keyword">volatile</span> *)p, <span class="literal">NULL</span>, hwaccel))</span><br><span class="line">        p = &amp;(*p)-&gt;next;</span><br><span class="line">    last_hwaccel = &amp;hwaccel-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编解码器注册函数是 <code>avcodec_register()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">av_cold <span class="keyword">void</span> <span class="title">avcodec_register</span><span class="params">(AVCodec *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodec **p;</span><br><span class="line">    avcodec_init();</span><br><span class="line">    p = last_avcodec;</span><br><span class="line">    codec-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(*p || avpriv_atomic_ptr_cas((<span class="keyword">void</span> * <span class="keyword">volatile</span> *)p, <span class="literal">NULL</span>, codec))</span><br><span class="line">        p = &amp;(*p)-&gt;next;</span><br><span class="line">    last_avcodec = &amp;codec-&gt;next;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;init_static_data)</span><br><span class="line">        codec-&gt;init_static_data(codec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parser注册函数是 <code>av_register_codec_parser()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_register_codec_parser</span><span class="params">(AVCodecParser *parser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parser-&gt;next = av_first_parser;</span><br><span class="line">    &#125; <span class="keyword">while</span> (parser-&gt;next != avpriv_atomic_ptr_cas((<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;av_first_parser, parser-&gt;next, parser));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bitstream Filter注册函数是 <code>av_register_bitstream_filter()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_register_bitstream_filter</span><span class="params">(AVBitStreamFilter *bsf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        bsf-&gt;next = first_bitstream_filter;</span><br><span class="line">    &#125; <span class="keyword">while</span>(bsf-&gt;next != avpriv_atomic_ptr_cas((<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;first_bitstream_filter, bsf-&gt;next, bsf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后两个函数中的 <code>avpriv_atomic_ptr_cas()</code> 定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">avpriv_atomic_ptr_cas</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">volatile</span> *ptr, <span class="keyword">void</span> *oldval, <span class="keyword">void</span> *newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*ptr == oldval) &#123;</span><br><span class="line">        *ptr = newval;</span><br><span class="line">        <span class="keyword">return</span> oldval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL0hhdHN1bmVNaWt1Vi9GRm1wZWdfTGVpeGlhb2h1YQ==&quot; title=&quot;https://github.com/HatsuneMikuV/FFmpeg_Leixiaohua&quot;&gt;GitHub&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2NvbHVtbi9pbmZvL2ZmbXBlZy1kZXZlbC83&quot; title=&quot;https://blog.csdn.net/leixiaohua1020/column/info/ffmpeg-devel/7&quot;&gt;FFmpeg&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy8xMjY3NzEyOQ==&quot; title=&quot;https://blog.csdn.net/leixiaohua1020/article/details/12677129&quot;&gt;ffmpeg 源代码简单分析&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;100行代码实现最简单的基于FFMPEG-SDL的视频播放器&quot;&gt;&lt;a href=&quot;#100行代码实现最简单的基于FFMPEG-SDL的视频播放器&quot; class=&quot;headerlink&quot; title=&quot;100行代码实现最简单的基于FFMPEG+SDL的视频播放器&quot;&gt;&lt;/a&gt;100行代码实现最简单的基于FFMPEG+SDL的视频播放器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2xlaXhpYW9odWExMDIwL3NpbXBsZXN0X2ZmbXBlZ19wbGF5ZXI=&quot; title=&quot;https://github.com/leixiaohua1020/simplest_ffmpeg_player&quot;&gt;simplest_ffmpeg_player&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该播放器虽然简单，但是几乎包含了使用FFMPEG播放一个视频所有必备的API，并且使用SDL显示解码出来的视频。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC</title>
    <link href="http://miaopei.github.io/2019/05/14/WebRTC/webrtc/"/>
    <id>http://miaopei.github.io/2019/05/14/WebRTC/webrtc/</id>
    <published>2019-05-14T02:14:50.000Z</published>
    <updated>2019-07-01T09:06:02.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h1><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYlJUQ19BUEk=" title="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API">WebRTC API<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkv" title="http://nodejs.cn/api/">Node.js v10.15.3 文档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI1MjM1MzU5MDQw" title="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040">廖雪峰 - nodejs<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zMTBjMGQxMzNjM2M=" title="https://www.jianshu.com/p/310c0d133c3c">Webrtc笔记-获取源码<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81YThhOTFjZDg0ZWY=" title="https://www.jianshu.com/p/5a8a91cd84ef">WebRTC音频引擎实现分析<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-WebRTC-介绍"><a href="#1-WebRTC-介绍" class="headerlink" title="1. WebRTC 介绍"></a>1. WebRTC 介绍</h2><a id="more"></a><ul><li>Google 开源</li><li>跨平台</li><li>用于浏览器</li><li>实时传输<ul><li>100ms 延迟 通话质量非常好</li><li>200ms 延迟 通话质量比较优质</li><li>500ms 延迟 可以接受</li><li>超过1s 非常迟滞</li></ul></li><li>音视频引擎</li></ul><p>WebRTC 应用：</p><img src="/images/imageWebRTC/webrtc应用.png"><p>WebRTC 愿景：</p><img src="/images/imageWebRTC/webrtc愿景.png"><p>学习 WebRTC 的难点：</p><img src="/images/imageWebRTC/学习WebRTC的难点.png"><p>学习路线：</p><img src="/images/imageWebRTC/学习路线.png"><p>学习内容：</p><img src="/images/imageWebRTC/学习内容.png"><p>学习收获：</p><img src="/images/imageWebRTC/学习收获.png"><p>WebRTC能做啥：</p><img src="/images/imageWebRTC/WebRTC能做啥.png"><p>能学到什么：</p><img src="/images/imageWebRTC/能学到什么.png"><p>google webrtc 示例：<span class="exturl" data-url="aHR0cHM6Ly9hcHByLnRjLw==" title="https://appr.tc/">https://appr.tc/<i class="fa fa-external-link"></i></span></p><h2 id="2-WebRTC-原理与架构"><a href="#2-WebRTC-原理与架构" class="headerlink" title="2. WebRTC 原理与架构"></a>2. WebRTC 原理与架构</h2><p>WebRTC 整体架构：</p><img src="/images/imageWebRTC/webrtc架构.png"><p>WebRTC 的目录结构图：</p><img src="/images/imageWebRTC/WebRTC目录结构-01.png"><img src="/images/imageWebRTC/WebRTC目录结构-02.png"><img src="/images/imageWebRTC/WebRTCModules目录-01.png"><img src="/images/imageWebRTC/WebRTCModules目录-02.png"><p>WebRTC 两个基本概念：轨与流</p><ul><li>Track</li><li>MediaStream</li></ul><p>WebRTC重要类：</p><ul><li>MediaStream</li><li>RTCPeerConnection</li><li>RTCDataChannel</li></ul><p>PeerConnection调用过程：</p><img src="/images/imageWebRTC/PeerConnection调用过程.png"><p>调用时序图：</p><img src="/images/imageWebRTC/调用时序图.png"><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3RoZXIvcC9teVBlZXJDb25uZWN0aW9uLmh0bWw=" title="https://www.cnblogs.com/cther/p/myPeerConnection.html">WebRTC之PeerConnection的建立过程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80Mzk1N2VlMThmMWE=" title="https://www.jianshu.com/p/43957ee18f1a">WebRTC系列（3）：PeerConnection通信建立流程<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="3-Web服务器原理与Nodejs搭建"><a href="#3-Web服务器原理与Nodejs搭建" class="headerlink" title="3. Web服务器原理与Nodejs搭建"></a>3. Web服务器原理与Nodejs搭建</h2><p>Web服务器选型：</p><ul><li>Nodejs</li><li>Nginx</li><li>Apache</li></ul><p>Web服务工作原理：</p><img src="/images/imageWebRTC/web服务工作原理.png"><p>Nodejs工作原理：</p><img src="/images/imageWebRTC/Nodejs工作原理.png"><p>JavaScript解析：</p><img src="/images/imageWebRTC/JavaScript解析.png"><p>Nodejs 事件处理：</p><img src="/images/imageWebRTC/Nodejs事件处理.png"><p>两个V8引擎：</p><img src="/images/imageWebRTC/两个V8引擎.png"><p>最简单的http服务：</p><ul><li><strong>require</strong> 引入http模块</li><li>创建http服务</li><li>侦听端口</li></ul><p>启动Nodejs服务：</p><ul><li>node app.js</li><li>nohub node app.js</li><li>forever start app.js</li><li>pm2 start app.js</li></ul><p>Https基本原理：</p><img src="/images/imageWebRTC/https基本原理.png"><p>Nodejs 搭建 https 服务：</p><ul><li>生成 HTTPS证书</li><li>引入 HTTPS模块</li><li>指定证书位置，并创建 HTTPS 服务</li></ul><p>真正的Web服务：</p><ul><li>引用 express 模块</li><li>引入 server-index 模块</li><li>指定发布目录</li></ul><h2 id="4-JavaScript-必备知识回顾"><a href="#4-JavaScript-必备知识回顾" class="headerlink" title="4. JavaScript 必备知识回顾"></a>4. JavaScript 必备知识回顾</h2><p>基础知识：</p><ul><li>变量与类型</li><li>基本运算</li><li><code>if/else</code></li><li>for循环</li><li>函数</li><li>日志打印</li></ul><p>变量与类型：</p><img src="/images/imageWebRTC/变量与类型.png"><p>基本运算：</p><img src="/images/imageWebRTC/基本运算.png"><img src="/images/imageWebRTC/ifelse.png"><img src="/images/imageWebRTC/for循环.png"><img src="/images/imageWebRTC/函数.png"><h2 id="5-WebRTC设备管理"><a href="#5-WebRTC设备管理" class="headerlink" title="5. WebRTC设备管理"></a>5. WebRTC设备管理</h2><p>enumerateDevices：</p><img src="/images/imageWebRTC/enumerateDevices.png"><p>JavaScript中的Promise：</p><img src="/images/imageWebRTC/JavaScript中的Promise.png"><h2 id="6-WebRTC音视频数据采集"><a href="#6-WebRTC音视频数据采集" class="headerlink" title="6. WebRTC音视频数据采集"></a>6. WebRTC音视频数据采集</h2><p>音视频采集API：</p><img src="/images/imageWebRTC/音视频采集API.png"><p>getUserMedia的不同实现：</p><img src="/images/imageWebRTC/getUserMedia的不同实现.png"><p>适配置不同浏览器的方法：</p><img src="/images/imageWebRTC/适配置不同浏览器的方法.png"><p><code>https://webrtc.github.io/adapter/adapter-latest.js</code></p><p>WebRTC音视频采集约束：</p><p>约束详解：</p><ul><li><p>width</p></li><li><p>height</p><p>宽高比例：<code>4:3</code>  <code>16:9</code></p></li><li><p>aspectRatio</p></li><li><p>frameRate</p></li><li><p>facingMode</p><ul><li>user - 前置摄像头</li><li>environment - 后置摄像头</li><li>left - 前置左侧摄像头</li><li>right - 前置右侧摄像头</li></ul></li><li><p>resizeMode</p></li></ul><p>音频约束详解：</p><ul><li>volume - <code>范围 0 - 1.0</code></li><li>sampleRate</li><li>sampleSize -  一般16位</li><li>echoCancellation - 回音消除</li><li>autoGainControl - 是否在原有声音基础上增加音量</li><li>noiseSuppression - 降噪</li><li>latency - 延迟大小</li><li>channelCount - 声道  乐器一般是双声道</li><li>deviceID - 作用是多个设备切换</li><li>groupID </li></ul><p>WebRTC约束例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    audio: true,</span><br><span class="line">    video: &#123;</span><br><span class="line">        width: &#123;</span><br><span class="line">            min: 300,</span><br><span class="line">            max: 640,</span><br><span class="line">        &#125;,</span><br><span class="line">        height: &#123;</span><br><span class="line">            min: 300,</span><br><span class="line">            max: 480,</span><br><span class="line">        &#125;,</span><br><span class="line">        frameRate: &#123;</span><br><span class="line">            min: 15,</span><br><span class="line">            max: 30,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器视频特效：</p><ul><li>CSS filter，<code>-webkit-filter/filter</code></li><li>如何将 video 与 filter 关联</li><li>OpenGL/Metal/…</li></ul><p>支持的特效种类：</p><img src="/images/imageWebRTC/支持的特效种类.png"><p>保存图片是实现滤镜效果，可以对 canvas.data 进行数据修改。</p><p>MediaStream API 获取视频约束：</p><img src="/images/imageWebRTC/MediaStream.png"><img src="/images/imageWebRTC/MediaStream事件.png"><h2 id="7-WebRTC音视频录制实战"><a href="#7-WebRTC音视频录制实战" class="headerlink" title="7. WebRTC音视频录制实战"></a>7. WebRTC音视频录制实战</h2><h3 id="7-1-WebRTC录制基本知识"><a href="#7-1-WebRTC录制基本知识" class="headerlink" title="7.1 WebRTC录制基本知识"></a>7.1 WebRTC录制基本知识</h3><p>MediaRecoder类：</p><img src="/images/imageWebRTC/MediaRecoder.png"><img src="/images/imageWebRTC/MediaRecorder参数.png"><img src="/images/imageWebRTC/MediaRecorderAPI-01.png"><img src="/images/imageWebRTC/MediaRecorderAPI-02.png"><img src="/images/imageWebRTC/MediaRecorder事件.png"><img src="/images/imageWebRTC/JavaScript几种存储数据的方式.png"><h3 id="7-2-WebRTC-捕获桌面"><a href="#7-2-WebRTC-捕获桌面" class="headerlink" title="7.2 WebRTC 捕获桌面"></a>7.2 WebRTC 捕获桌面</h3><img src="/images/imageWebRTC/getDisplayMedia.png"><p>捕获桌面需要设置Chrome，具体 操作：<span class="exturl" data-url="Y2hyb21lOi8vZmxhZ3MvI2VuYWJsZS1leHBlcmltZW50YWwtd2ViLXBsYXRmb3JtLWZlYXR1cmVz" title="chrome://flags/#enable-experimental-web-platform-features">chrome://flags/#enable-experimental-web-platform-features<i class="fa fa-external-link"></i></span></p><ul><li>Experimental Web Platform features 设置为 enable</li></ul><h2 id="8-WebRTC信令服务器实现"><a href="#8-WebRTC信令服务器实现" class="headerlink" title="8. WebRTC信令服务器实现"></a>8. WebRTC信令服务器实现</h2><p>如果没有信令服务器WebRTC之间是不能通信的。</p><p>两个client之间通信必须有两个信息通过信令服务器的：</p><ul><li>媒体信息， SDP</li><li>网络信息</li><li>具体的业务</li></ul><img src="/images/imageWebRTC/信令服务器的作用.png"><img src="/images/imageWebRTC/为什么要使用socketio.png"><img src="/images/imageWebRTC/socketio工作原理.png"><p>Socket.IO 发送消息：</p><ul><li><p>给本次连接发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.emit()</span><br></pre></td></tr></table></figure></li><li><p>给某个房间内所有人发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.in(room).emit()</span><br></pre></td></tr></table></figure></li><li><p>除本链接外，给某个房间内所有人发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.to(room).emit()</span><br></pre></td></tr></table></figure></li><li><p>除本链接外，给所有人发送消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.broadcast.emit()</span><br></pre></td></tr></table></figure></li></ul><p>Socket.IO 客户端处理消息：</p><ul><li><p>发送 action 命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>);</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送了一个 action 命令，还有 data 数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>, data);</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送了 action 命令，还有两个数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>, arg1, arg2);</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送了一个 action 命令，在 emit 方法中包含回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: socket.emit(<span class="string">'action'</span>, data, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)</span>&#123;...&#125;;</span><br><span class="line">C: socket.on(<span class="string">'action'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, fn</span>)</span>&#123;fn(<span class="string">'a'</span>, <span class="string">'b'</span>);&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-1-实战-通过-socket-io-实现信令服务器"><a href="#8-1-实战-通过-socket-io-实现信令服务器" class="headerlink" title="8.1 [实战] 通过 socket.io 实现信令服务器"></a>8.1 [实战] 通过 socket.io 实现信令服务器</h3><p>改造服务端的基本流程：</p><ul><li>安装 socket.io</li><li>引入 socket.io</li><li>处理 connection 消息</li></ul><h2 id="9-WebRTC网络基础补充：P2P-STUN-TRUN-ICE知识"><a href="#9-WebRTC网络基础补充：P2P-STUN-TRUN-ICE知识" class="headerlink" title="9. WebRTC网络基础补充：P2P/STUN/TRUN/ICE知识"></a>9. WebRTC网络基础补充：P2P/STUN/TRUN/ICE知识</h2><h3 id="9-1-WebRTC-网络传输基本知识"><a href="#9-1-WebRTC-网络传输基本知识" class="headerlink" title="9.1 WebRTC 网络传输基本知识"></a>9.1 WebRTC 网络传输基本知识</h3><p>WebRTC 传输基本知识：</p><ul><li>NAT（Network Address Translator）</li><li>STUN（Simple Traversal of UDP Through NAT）</li><li>TURN（Travelsal Using Relays around NAT）</li><li>ICE（Interactive Connectivity Establishment）</li></ul><img src="/images/imageWebRTC/NAT.png"><p>NAT 产生的原因：</p><ul><li>由于IPv4的地址不够</li><li>处于网络安全的原因</li></ul><p>NAT 的种类：</p><ul><li>完全锥型 NAT（Full Cone NAT）</li><li>地址限制锥型 NAT（Address Restricted Cone NAT）</li><li>端口限制锥型 NAT（Port Restricted Cone NAT）</li><li>对称型 NAT（Symmetric NAT）</li></ul><h3 id="9-2-NAT-打洞原理"><a href="#9-2-NAT-打洞原理" class="headerlink" title="9.2 NAT 打洞原理"></a>9.2 NAT 打洞原理</h3><img src="/images/imageWebRTC/完全锥型NAT.png"><img src="/images/imageWebRTC/地址限制锥型NAT.png"><img src="/images/imageWebRTC/端口限制锥型NAT.png"><img src="/images/imageWebRTC/对称型NAT.png"><p>NAT 穿越原理：</p><ul><li>C1，C2 向 STUN 发消息</li><li>交换公网 IP 及 端口</li><li>C1 -&gt; C2，C2 -&gt; C1，甚至是端口猜测</li></ul><img src="/images/imageWebRTC/NAT穿越组合.png"><h3 id="9-3-NAT-类型检测"><a href="#9-3-NAT-类型检测" class="headerlink" title="9.3 NAT 类型检测"></a>9.3 NAT 类型检测</h3><img src="/images/imageWebRTC/NAT类型判断.png"><p>公网 IP：</p><img src="/images/imageWebRTC/NAT类型检测-01.png"><p>如果 Client 收到的 IP 和第一次发出去的 IP 是不一样的，则是对称型 NAT，如果是一样的需要进一步判断：</p><img src="/images/imageWebRTC/NAT类型检测-02.png"><p>Client 通过 Port2 发送消息到 STUN Port1，STUN Server 通过 Port2 给 Client 回消息，如果 Client 能收到消息，则说明是 IP 限制型的；如果不能收到，则说明是端口限制型的：</p><img src="/images/imageWebRTC/NAT类型检测-03.png"><h3 id="9-4-【协议规范】STUN-协议一"><a href="#9-4-【协议规范】STUN-协议一" class="headerlink" title="9.4 【协议规范】STUN 协议一"></a>9.4 【协议规范】STUN 协议一</h3><p>STUN 介绍：</p><ul><li>STUN 存在的目的就是进行 NAT 穿越</li><li>STUN 是典型的客户端 / 服务器模式。客户端发送请求，服务端进行响应</li></ul><p>RFC STUN 规范：</p><ul><li><p><strong>RFC3489/STUN</strong></p><p>SImple Traversal of UDP Trough NAT</p></li><li><p><strong>RFC5389/STUN</strong> — 包含UDP和TCP</p><p>Session Traversal Utilities for NAT</p></li></ul><p>STUN 协议：</p><ul><li>包括 20 字节的 STUN header</li><li>Body 中可以有 0 个或多个 Attribute</li></ul><p>STUN header（RFC3489）：</p><ul><li>其中 2 个字节（16bit）类型</li><li>2 个字节（16bit）消息长度，不包括消息头</li><li>16 个字节（128bit）事物ID，请求与响应事物 ID 相同</li></ul><p>STUN header（RFC5389）格式：</p><img src="/images/imageWebRTC/STUNHeader格式.png"><img src="/images/imageWebRTC/STUNMessageType.png"><p>M 代表请求值，C 代表分类：</p><img src="/images/imageWebRTC/STUNMessageType-01.png"><img src="/images/imageWebRTC/C0C1.png"><p>RFC5389 把私密类型去掉了：</p><img src="/images/imageWebRTC/STUN消息类型.png"><h3 id="9-5-【协议规范】STUN-协议二"><a href="#9-5-【协议规范】STUN-协议二" class="headerlink" title="9.5 【协议规范】STUN 协议二"></a>9.5 【协议规范】STUN 协议二</h3><p>Inter 机子都是小端模式：</p><img src="/images/imageWebRTC/大小端模式.png"><img src="/images/imageWebRTC/STUNMessageType-02.png"><img src="/images/imageWebRTC/TransactionID.png"><img src="/images/imageWebRTC/STUNMessageBody.png"><img src="/images/imageWebRTC/TLV.png"><img src="/images/imageWebRTC/RFC3489定义的属性.png"><img src="/images/imageWebRTC/Attribute的使用.png"><h3 id="9-6-【协议规范】TURN-协议"><a href="#9-6-【协议规范】TURN-协议" class="headerlink" title="9.6 【协议规范】TURN 协议"></a>9.6 【协议规范】TURN 协议</h3><p>TURN 介绍：</p><ul><li>其目的是解决对称 NAT 无法穿越的问题</li><li>其建立在 STUN 之上，消息格式使用 STUN 格式消息</li><li>TURN Client 要求服务端分配一个公共 IP 和 Port 用于接受 或 发送数据</li></ul><img src="/images/imageWebRTC/TURN例子.png"><img src="/images/imageWebRTC/TURN使用的传输协议.png"><img src="/images/imageWebRTC/TURNAllocate.png"><p>TURN 发送机制：</p><ul><li>Send 和 Data</li><li>Channel</li></ul><img src="/images/imageWebRTC/TURNSendAndData.png"><img src="/images/imageWebRTC/TURNChannel.png"><img src="/images/imageWebRTC/TURN的使用.png"><h3 id="9-7-【协议规范】ICE-框架"><a href="#9-7-【协议规范】ICE-框架" class="headerlink" title="9.7 【协议规范】ICE 框架"></a>9.7 【协议规范】ICE 框架</h3><img src="/images/imageWebRTC/ICE.png"><img src="/images/imageWebRTC/ICECandidate.png"><p>Candidate 类型：</p><ul><li>主机候选者</li><li>反射侯选者</li><li>中继候选者</li></ul><p>ICE 具体做些什么：</p><ul><li>收集 Candidate</li><li>对 Candidate Pair 排序</li><li>连通性检查</li></ul><img src="/images/imageWebRTC/Candidate关系图.png"><p>收集 Candidate：</p><ul><li>Host Candidate：本机所有 IP 和指定端口</li><li>Reflexive Candidate：STUN/TURN</li><li>Relay Candidate：TURN</li></ul><p>什么是 SDP：</p><ul><li><strong>SDP（Session Description Protocol）</strong> 它只是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息。</li></ul><img src="/images/imageWebRTC/SDP例子.png"><p>形成 Candidate Pair：</p><ul><li>一方收集到所有候选者后，通过信令传给对方</li><li>同样，另一方收到候选者后，也做收集工作</li><li>当双方拿到全部列表后，将侯选者形成匹配对儿</li></ul><p>连通性检查：</p><ul><li>对侯选者进行优先级排序</li><li>对每个侯选对进行发送检查</li><li>对每个侯选对进行接收检查</li></ul><img src="/images/imageWebRTC/连通性过程.png"><h3 id="9-8-网络协议分析方法-tcpdump-与-wireshark讲解"><a href="#9-8-网络协议分析方法-tcpdump-与-wireshark讲解" class="headerlink" title="9.8 网络协议分析方法 tcpdump 与 wireshark讲解"></a>9.8 网络协议分析方法 tcpdump 与 wireshark讲解</h3><p>常用工具：</p><ul><li>Linux 服务端用 tcpdump</li><li>其它端 WireShark</li></ul><img src="/images/imageWebRTC/tcpdump.png"><h3 id="9-9-网络协议分析方法-tcpdump-与-wireshark-实战"><a href="#9-9-网络协议分析方法-tcpdump-与-wireshark-实战" class="headerlink" title="9.9 网络协议分析方法 tcpdump 与 wireshark 实战"></a>9.9 网络协议分析方法 tcpdump 与 wireshark 实战</h3><p>vim 打开二进制数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：%！xxd</span><br></pre></td></tr></table></figure><p>WireShark 中的逻辑运算：</p><ul><li>与：and 或 &amp;&amp;</li><li>或：or 或 ||</li><li>非：not 或 ！</li></ul><p>WireShark 中判断语句：</p><ul><li>等于：eq 或 ==</li><li>小于：lt 或 &lt;</li><li>大于：gt 或 &gt;</li><li>小于等于：le 或 &lt;=</li><li>大于等于：ge 或 &gt;=</li><li>不等于：ne 或 !=</li></ul><p>WireShark 按协议过滤：</p><ul><li>stun</li><li>tcp</li><li>udp</li></ul><p>模拟STUN数据可以使用这个网站中的工具：<span class="exturl" data-url="aHR0cHM6Ly93ZWJydGMuZ2l0aHViLmlvL3NhbXBsZXM=" title="https://webrtc.github.io/samples">https://webrtc.github.io/samples<i class="fa fa-external-link"></i></span></p><p>Wireshark 按 IP 过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip.dst == 192.168.1.2</span><br><span class="line">ip.src == 192.168.1.2</span><br><span class="line">ip.addr == 192.168.1.2</span><br></pre></td></tr></table></figure><p>WireShark 按 port 过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == 8080</span><br><span class="line">udp.port == 3478</span><br><span class="line">udp.dstport == 3478</span><br><span class="line">udp.srcport == 3478</span><br></pre></td></tr></table></figure><p>WireShark 过滤长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">udp.length &lt; 30</span><br><span class="line">tcp.length &lt; 30</span><br><span class="line">http.content_length &lt; 30</span><br></pre></td></tr></table></figure><p>WireShark 过滤内容：</p><p>TODO</p><h2 id="10-端对端1V1传输基本流程"><a href="#10-端对端1V1传输基本流程" class="headerlink" title="10. 端对端1V1传输基本流程"></a>10. 端对端1V1传输基本流程</h2><h3 id="10-1-媒体能力协商过程"><a href="#10-1-媒体能力协商过程" class="headerlink" title="10.1 媒体能力协商过程"></a>10.1 媒体能力协商过程</h3><p>WebRTC 端对端连接：</p><p><strong>RTCPeerConnection</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc = <span class="keyword">new</span> RTCPeerConnection([configuration]);</span><br></pre></td></tr></table></figure></li></ul><p><strong>RTCPeerConnection 方法分类</strong>：</p><ul><li>媒体协商</li><li>Stream/Track</li><li>传输相关方法</li><li>统计相关方法</li></ul><img src="/images/imageWebRTC/媒体协商过程.png"><img src="/images/imageWebRTC/协商状态变化.png"><p><strong>媒体协商方法</strong>：</p><ul><li>createOffer</li><li>createAnswer</li><li>setLocakDescription</li><li>setRemoteDescription</li></ul><p><strong>createOffer</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPeerConnection.createOffer([options]);</span><br></pre></td></tr></table></figure></li></ul><p><strong>createAnswer</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPeerConnection.createAnswer([options]);</span><br></pre></td></tr></table></figure></li></ul><p><strong>setLocakDescription</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPc.setLocalDescription(sessionDescription);</span><br></pre></td></tr></table></figure></li></ul><p><strong>setRemoteDescription</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise = myPc.setRemoteDescription(sessionDescription);</span><br></pre></td></tr></table></figure></li></ul><p><strong>Track 方法</strong>：</p><ul><li>addTrack</li><li>removeTrack</li></ul><p><strong>addTrack</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtpSender = myPc.addTrack(track, stream...);</span><br></pre></td></tr></table></figure></li><li><p>Parameters</p><img src="/images/imageWebRTC/addTrackParameters.png"></li></ul><p><strong>removeTrack</strong>：</p><ul><li><p>基本格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPc.remoteTrack(rtpSender);</span><br></pre></td></tr></table></figure></li></ul><p><strong>重要事件</strong>：</p><ul><li>onnegotiationneeded  - 协商的时候触发这个事件</li><li>onicecandidate - 当收到 ICE 候选者的时候触发这个事件</li></ul><h3 id="10-2-1-1-连接的基本流程"><a href="#10-2-1-1-连接的基本流程" class="headerlink" title="10.2 1:1 连接的基本流程"></a>10.2 1:1 连接的基本流程</h3><img src="/images/imageWebRTC/端对端连接的基本流程.png"><p><strong>A 与 B 通信，大的方向分为三部分</strong>：</p><ul><li>媒体协商部分</li><li>ICE 候选者的交换、连接、检测部分</li><li>媒体数据流的通信部分</li></ul><h3 id="10-3-【实战】WebRTC-视频传输"><a href="#10-3-【实战】WebRTC-视频传输" class="headerlink" title="10.3 【实战】WebRTC 视频传输"></a>10.3 【实战】WebRTC 视频传输</h3><p>TODO</p><h3 id="10-4-【实战】显示通讯双方的-SDP-内容"><a href="#10-4-【实战】显示通讯双方的-SDP-内容" class="headerlink" title="10.4 【实战】显示通讯双方的 SDP 内容"></a>10.4 【实战】显示通讯双方的 SDP 内容</h3><p>TODO</p><h2 id="11-WebRTC核心之SDP详解"><a href="#11-WebRTC核心之SDP详解" class="headerlink" title="11. WebRTC核心之SDP详解"></a>11. WebRTC核心之SDP详解</h2><h3 id="11-1-【协议规范】SDP-规范"><a href="#11-1-【协议规范】SDP-规范" class="headerlink" title="11.1 【协议规范】SDP 规范"></a>11.1 【协议规范】SDP 规范</h3><p><strong>SDP 规范</strong>：</p><ul><li>会话层</li><li>媒体层</li></ul><p>可以把会话层看做树根，媒体层看成树干。</p><p><strong>会话层</strong>：</p><ul><li>会话的名称与目的</li><li>会话的存活时间</li><li>会话中包含多个媒体信息</li></ul><p><strong>SDP 媒体信息</strong>：</p><ul><li>媒体格式</li><li>传输协议</li><li>传输 IP 和 端口</li><li>媒体负载类型</li></ul><p><strong>SDP 格式</strong>：</p><ul><li>由多个 <code>&lt;type&gt;=&lt;value&gt;</code> 组成</li><li>一个会话级描述</li><li>多个媒体级描述</li></ul><p><strong>SDP 结构</strong>：</p><ul><li>Session Description</li><li>Time Description</li><li>Media Description</li></ul><img src="/images/imageWebRTC/SessionDescription.png"><img src="/images/imageWebRTC/TimeDescription.png"><img src="/images/imageWebRTC/MediaDescription.png"><img src="/images/imageWebRTC/字段含义-01.png"><img src="/images/imageWebRTC/字段含义-02.png"><img src="/images/imageWebRTC/字段含义-03.png"><img src="/images/imageWebRTC/字段含义-04.png"><img src="/images/imageWebRTC/字段含义-05.png"><img src="/images/imageWebRTC/字段含义-06.png"><img src="/images/imageWebRTC/字段含义-07.png"><h3 id="11-2-【协议规范】WebRTC-中的-SDP"><a href="#11-2-【协议规范】WebRTC-中的-SDP" class="headerlink" title="11.2 【协议规范】WebRTC 中的 SDP"></a>11.2 【协议规范】WebRTC 中的 SDP</h3><img src="/images/imageWebRTC/WebRTC中的SDP.png"><h3 id="11-3-【详解】WebRTC-中-Offer-Answer-SDP"><a href="#11-3-【详解】WebRTC-中-Offer-Answer-SDP" class="headerlink" title="11.3 【详解】WebRTC 中 Offer_Answer SDP"></a>11.3 【详解】WebRTC 中 Offer_Answer SDP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-实现1V1音视频实时互动直播系统"><a href="#12-实现1V1音视频实时互动直播系统" class="headerlink" title="12. 实现1V1音视频实时互动直播系统"></a>12. 实现1V1音视频实时互动直播系统</h2><h3 id="12-1-STUN-TURN-服务器搭建"><a href="#12-1-STUN-TURN-服务器搭建" class="headerlink" title="12.1 STUN/TURN 服务器搭建"></a>12.1 STUN/TURN 服务器搭建</h3><p>coTurn Download Address：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvdHVybi9jb3R1cm4=" title="https://github.com/coturn/coturn">https://github.com/coturn/coturn<i class="fa fa-external-link"></i></span></p><p>ICE 测试地址：<span class="exturl" data-url="aHR0cHM6Ly93ZWJydGMuZ2l0aHViLmlvL3NhbXBsZXM=" title="https://webrtc.github.io/samples">https://webrtc.github.io/samples<i class="fa fa-external-link"></i></span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 turn server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> turnserver -c /usr/<span class="built_in">local</span>/coturn/etc/turnserver.conf</span></span><br></pre></td></tr></table></figure><img src="/images/imageWebRTC/STUNTURN服务器选型.png"><img src="/images/imageWebRTC/coTurn服务器搭建与部署.png"><img src="/images/imageWebRTC/coTurn服务器配置.png"><img src="/images/imageWebRTC/测试turn服务.png"><h3 id="12-2-【参数介绍】再论-RTCPeerConnection"><a href="#12-2-【参数介绍】再论-RTCPeerConnection" class="headerlink" title="12.2 【参数介绍】再论 RTCPeerConnection"></a>12.2 【参数介绍】再论 RTCPeerConnection</h3><img src="/images/imageWebRTC/RTCPeerConnection-01.png"><img src="/images/imageWebRTC/Configurations-01.png"><img src="/images/imageWebRTC/Configurations-02.png"><img src="/images/imageWebRTC/Configurations-03.png"><img src="/images/imageWebRTC/Configurations-04.png"><img src="/images/imageWebRTC/addIceCandidate.png"><h3 id="12-3-直播系统中的信令及其逻辑关系"><a href="#12-3-直播系统中的信令及其逻辑关系" class="headerlink" title="12.3 直播系统中的信令及其逻辑关系"></a>12.3 直播系统中的信令及其逻辑关系</h3><p>【实战】真正的音视频传输</p><p><strong>客户端信令消息</strong>：</p><ul><li>join 加入房间</li><li>leave 离开房间</li><li>message 端到端消息</li></ul><p><strong>端到端信令消息</strong>：</p><ul><li>Offer 消息</li><li>Answer 消息</li><li>Candidate 消息</li></ul><p><strong>服务端信令消息</strong>：</p><ul><li>joined 已加入房间</li><li>otherjoin 其它用户加入房间</li><li>full 房间人数已满</li><li>leaved 已离开房间</li><li>bye 对方离开房间</li></ul><img src="/images/imageWebRTC/直播系统消息处理流程.png"><h3 id="12-4-实现-1：1-音视频实时互动信令服务器"><a href="#12-4-实现-1：1-音视频实时互动信令服务器" class="headerlink" title="12.4 实现 1：1 音视频实时互动信令服务器"></a>12.4 实现 1：1 音视频实时互动信令服务器</h3><p>信令服务器改造</p><p>TODO</p><h3 id="12-5-再论CreateOffer"><a href="#12-5-再论CreateOffer" class="headerlink" title="12.5 再论CreateOffer"></a>12.5 再论CreateOffer</h3><img src="/images/imageWebRTC/createOffer.png"><p><strong>CreateOffer 实战</strong>：</p><ul><li>接收远端音频</li><li>接收远端视频</li><li>静音检测</li><li>ICE restart</li></ul><h3 id="12-6-WebRTC-客户端状态机及处理逻辑"><a href="#12-6-WebRTC-客户端状态机及处理逻辑" class="headerlink" title="12.6 WebRTC 客户端状态机及处理逻辑"></a>12.6 WebRTC 客户端状态机及处理逻辑</h3><p>直播客户端的实现：</p><img src="/images/imageWebRTC/客户端状态机.png"><img src="/images/imageWebRTC/客户端流程图.png"><img src="/images/imageWebRTC/客户端流程图-01.png"><img src="/images/imageWebRTC/端对端连接的基本流程.png"><h3 id="12-7-WebRTC-客户端的实现"><a href="#12-7-WebRTC-客户端的实现" class="headerlink" title="12.7 WebRTC 客户端的实现"></a>12.7 WebRTC 客户端的实现</h3><img src="/images/imageWebRTC/注意要点.png"><h3 id="12-8-共享远程桌面"><a href="#12-8-共享远程桌面" class="headerlink" title="12.8 共享远程桌面"></a>12.8 共享远程桌面</h3><img src="/images/imageWebRTC/getDisplayMedia-01.png"><img src="/images/imageWebRTC/需要注意的点.png"><h2 id="13-WebRTC核心之RTP媒体控制与数据统计"><a href="#13-WebRTC核心之RTP媒体控制与数据统计" class="headerlink" title="13. WebRTC核心之RTP媒体控制与数据统计"></a>13. WebRTC核心之RTP媒体控制与数据统计</h2><h3 id="13-1-RTPPReceiver-发送器"><a href="#13-1-RTPPReceiver-发送器" class="headerlink" title="13.1 RTPPReceiver 发送器"></a>13.1 RTPPReceiver 发送器</h3><p>RTP Media</p><img src="/images/imageWebRTC/Receiver和Sender.png"><img src="/images/imageWebRTC/RTCRtpSender属性.png"><img src="/images/imageWebRTC/RTCRtpReceiver.png"><h3 id="13-2-RTPSender-发送器"><a href="#13-2-RTPSender-发送器" class="headerlink" title="13.2 RTPSender 发送器"></a>13.2 RTPSender 发送器</h3><img src="/images/imageWebRTC/RTCRtpSender.png"><img src="/images/imageWebRTC/RTPMedia.png"><img src="/images/imageWebRTC/RTCRtpTransceiver.png"><h3 id="13-3-传输速率的控制"><a href="#13-3-传输速率的控制" class="headerlink" title="13.3 传输速率的控制"></a>13.3 传输速率的控制</h3><img src="/images/imageWebRTC/RTPMedia-01.png"><img src="/images/imageWebRTC/chromeWebRTC-internals.png"><p>chrome WebRTC 状态查询地址：<span class="exturl" data-url="Y2hyb21lOi8vd2VicnRjLWludGVybmFscw==" title="chrome://webrtc-internals">chrome://webrtc-internals<i class="fa fa-external-link"></i></span></p><h3 id="13-4-【实战】WebRTC统计信息"><a href="#13-4-【实战】WebRTC统计信息" class="headerlink" title="13.4 【实战】WebRTC统计信息"></a>13.4 【实战】WebRTC统计信息</h3><p>TODO</p><h2 id="14-WebRTC非音视频数据传输"><a href="#14-WebRTC非音视频数据传输" class="headerlink" title="14. WebRTC非音视频数据传输"></a>14. WebRTC非音视频数据传输</h2><h3 id="14-1-传输非音视频数据基础知识"><a href="#14-1-传输非音视频数据基础知识" class="headerlink" title="14.1 传输非音视频数据基础知识"></a>14.1 传输非音视频数据基础知识</h3><img src="/images/imageWebRTC/createDataChannel.png"><img src="/images/imageWebRTC/option-01.png"><img src="/images/imageWebRTC/option-02.png"><img src="/images/imageWebRTC/使用Options.png"><img src="/images/imageWebRTC/DataChannel事件.png"><img src="/images/imageWebRTC/创建RTCDataChannel.png"><img src="/images/imageWebRTC/非音视频数据传输方式.png"><ul><li>Reliability：可靠性</li><li>Delivery：可达性</li><li>Transmission：传输方式</li><li>Flow control：流控</li><li>Congestion control：拥塞控制</li></ul><h3 id="14-2-端到端文本聊天"><a href="#14-2-端到端文本聊天" class="headerlink" title="14.2 端到端文本聊天"></a>14.2 端到端文本聊天</h3><p>TODO</p><h3 id="14-3-文件实时传输"><a href="#14-3-文件实时传输" class="headerlink" title="14.3 文件实时传输"></a>14.3 文件实时传输</h3><img src="/images/imageWebRTC/知识点.png"><h2 id="15-WebRTC实时数据传输网络协议详解"><a href="#15-WebRTC实时数据传输网络协议详解" class="headerlink" title="15. WebRTC实时数据传输网络协议详解"></a>15. WebRTC实时数据传输网络协议详解</h2><h3 id="15-1-【协议规范】RTP-SRTP协议头详解"><a href="#15-1-【协议规范】RTP-SRTP协议头详解" class="headerlink" title="15.1 【协议规范】RTP-SRTP协议头详解"></a>15.1 【协议规范】RTP-SRTP协议头详解</h3><img src="/images/imageWebRTC/协议栈.png"><img src="/images/imageWebRTC/传输协议.png"><img src="/images/imageWebRTC/RTP协议.png"><img src="/images/imageWebRTC/RTP字段说明.png"><h3 id="15-2-【协议规范】RTCP-中的-SR-与-RR-报文"><a href="#15-2-【协议规范】RTCP-中的-SR-与-RR-报文" class="headerlink" title="15.2 【协议规范】RTCP 中的 SR 与 RR 报文"></a>15.2 【协议规范】RTCP 中的 SR 与 RR 报文</h3><img src="/images/imageWebRTC/RTCP包.png"><img src="/images/imageWebRTC/RTCPPayloadType.png"><img src="/images/imageWebRTC/RTCPHeader.png"><img src="/images/imageWebRTC/RTCPHeader说明.png"><img src="/images/imageWebRTC/RTCPSenderReport.png"><img src="/images/imageWebRTC/SenderInfomationBlock.png"><img src="/images/imageWebRTC/SenderInfo说明.png"><img src="/images/imageWebRTC/ReportBlock.png"><img src="/images/imageWebRTC/ReceiveReportBlock.png"><img src="/images/imageWebRTC/RTCPReceiverReport.png"><img src="/images/imageWebRTC/RTCPSR-RR发送时机.png"><img src="/images/imageWebRTC/RTCPSDES.png"><img src="/images/imageWebRTC/SDESitem.png"><img src="/images/imageWebRTC/SDES说明.png"><img src="/images/imageWebRTC/RTCPBYE.png"><img src="/images/imageWebRTC/RTCPAPP.png"><img src="/images/imageWebRTC/RTCPAPP字段说明.png"><h3 id="15-3-【协议规范】DTSL"><a href="#15-3-【协议规范】DTSL" class="headerlink" title="15.3 【协议规范】DTSL"></a>15.3 【协议规范】DTSL</h3><img src="/images/imageWebRTC/DTLS.png"><img src="/images/imageWebRTC/SRTP.png"><h3 id="15-4-wireshark-分析-rtp-rtcp-包"><a href="#15-4-wireshark-分析-rtp-rtcp-包" class="headerlink" title="15.4 wireshark 分析 rtp-rtcp 包"></a>15.4 wireshark 分析 rtp-rtcp 包</h3><p>TODO</p><h2 id="16-Android端与浏览器互通"><a href="#16-Android端与浏览器互通" class="headerlink" title="16. Android端与浏览器互通"></a>16. Android端与浏览器互通</h2><h3 id="16-1-Android-与浏览器互通"><a href="#16-1-Android-与浏览器互通" class="headerlink" title="16.1 Android 与浏览器互通"></a>16.1 Android 与浏览器互通</h3><img src="/images/imageWebRTC/主要内容.png"><img src="/images/imageWebRTC/需要权限.png"><img src="/images/imageWebRTC/Android权限管理.png"><img src="/images/imageWebRTC/引入库.png"><img src="/images/imageWebRTC/信令处理.png"><img src="/images/imageWebRTC/AndroidSocketio.png"><img src="/images/imageWebRTC/socketio接收消息.png"><h3 id="16-2-WebRTCNative-开发逻辑"><a href="#16-2-WebRTCNative-开发逻辑" class="headerlink" title="16.2 WebRTCNative 开发逻辑"></a>16.2 WebRTCNative 开发逻辑</h3><img src="/images/imageWebRTC/结构图.png"><img src="/images/imageWebRTC/呼叫端时序图.png"><img src="/images/imageWebRTC/被叫端时序图.png"><img src="/images/imageWebRTC/关闭时序图.png"><img src="/images/imageWebRTC/webrtc处理流程.png"><img src="/images/imageWebRTC/重要类-01.png"><img src="/images/imageWebRTC/重要类-02.png"><img src="/images/imageWebRTC/两个观察者.png"><h3 id="16-3-实战-权限申请-库的引入与界面"><a href="#16-3-实战-权限申请-库的引入与界面" class="headerlink" title="16.3 实战-权限申请-库的引入与界面"></a>16.3 实战-权限申请-库的引入与界面</h3><img src="/images/imageWebRTC/权限库界面.png"><h3 id="16-4-实战-通过-socket-io-实现信令收发"><a href="#16-4-实战-通过-socket-io-实现信令收发" class="headerlink" title="16.4 实战-通过 socket.io 实现信令收发"></a>16.4 实战-通过 socket.io 实现信令收发</h3><img src="/images/imageWebRTC/收发信令.png"><h3 id="16-5-实战-Android-与浏览器互通"><a href="#16-5-实战-Android-与浏览器互通" class="headerlink" title="16.5 实战-Android 与浏览器互通"></a>16.5 实战-Android 与浏览器互通</h3><p>创建 PeerConnection：</p><ul><li>音视频数据采集</li><li>创建 PeerConnection</li></ul><p>媒体能力协商：</p><ul><li>协商媒体能力</li><li>Candidate 连通</li><li>视频渲染</li></ul><h2 id="17-iOS端与浏览器互通"><a href="#17-iOS端与浏览器互通" class="headerlink" title="17. iOS端与浏览器互通"></a>17. iOS端与浏览器互通</h2><h3 id="17-1-IOS权限获取"><a href="#17-1-IOS权限获取" class="headerlink" title="17.1 IOS权限获取"></a>17.1 IOS权限获取</h3><img src="/images/imageWebRTC/主要内容-01.png"><img src="/images/imageWebRTC/主要内容-02.png"><h3 id="17-2-IOS引入WebRTC库"><a href="#17-2-IOS引入WebRTC库" class="headerlink" title="17.2 IOS引入WebRTC库"></a>17.2 IOS引入WebRTC库</h3><img src="/images/imageWebRTC/引入WebRTC库的方式.png"><img src="/images/imageWebRTC/引入WebRTC库.png"><img src="/images/imageWebRTC/Podfile.png"><h3 id="17-3-IOS端SocketIO的使用"><a href="#17-3-IOS端SocketIO的使用" class="headerlink" title="17.3 IOS端SocketIO的使用"></a>17.3 IOS端SocketIO的使用</h3><img src="/images/imageWebRTC/socketio的使用.png"><img src="/images/imageWebRTC/连接服务器.png"><img src="/images/imageWebRTC/发送消息.png"><img src="/images/imageWebRTC/注册侦听消息.png"><h3 id="17-4-IOS界面布局"><a href="#17-4-IOS界面布局" class="headerlink" title="17.4 IOS界面布局"></a>17.4 IOS界面布局</h3><p>TODO</p><h3 id="17-5-IOS本地视频采集与展示"><a href="#17-5-IOS本地视频采集与展示" class="headerlink" title="17.5 IOS本地视频采集与展示"></a>17.5 IOS本地视频采集与展示</h3><p>TODO</p><h3 id="17-6-IOS端RTCPeerConnection"><a href="#17-6-IOS端RTCPeerConnection" class="headerlink" title="17.6 IOS端RTCPeerConnection"></a>17.6 IOS端RTCPeerConnection</h3><p>TODO</p><h3 id="17-7-IOS媒体协商"><a href="#17-7-IOS媒体协商" class="headerlink" title="17.7 IOS媒体协商"></a>17.7 IOS媒体协商</h3><img src="/images/imageWebRTC/媒体协商.png"><img src="/images/imageWebRTC/信令时序图.png"><h3 id="17-8-IOS远端视频渲染"><a href="#17-8-IOS远端视频渲染" class="headerlink" title="17.8 IOS远端视频渲染"></a>17.8 IOS远端视频渲染</h3><img src="/images/imageWebRTC/RTCPeerConnection委托.png"><h2 id="18-课程总结"><a href="#18-课程总结" class="headerlink" title="18. 课程总结"></a>18. 课程总结</h2><img src="/images/imageWebRTC/小结.png"><img src="/images/imageWebRTC/信令服务器.png"><img src="/images/imageWebRTC/JS客户端实现.png"><img src="/images/imageWebRTC/JS客户端实现-01.png"><img src="/images/imageWebRTC/进阶.png"><img src="/images/imageWebRTC/进阶-01.png"><img src="/images/imageWebRTC/行业痛点.png"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzUxMTIxOWU1MWQ0NTUyMmMzMDY2Yzk=" title="https://juejin.im/post/5c511219e51d45522c3066c9">JavaScript 是如何工作的:WebRTC 和对等网络的机制！<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTQwMzU5Nw==" title="https://segmentfault.com/a/1190000011403597">深入理解WebRTC<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2htYWkvYXJ0aWNsZS9kZXRhaWxzLzY5NjgxNTk1" title="https://blog.csdn.net/fishmai/article/details/69681595">WebRTC架构简介<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFycmV0bGVlLmNvbS9ibG9nLzIwMTUvMTAvMDUvaG93LXRvLWJ1aWxkLWEtaHR0cHMtc2VydmVyLw==" title="https://www.barretlee.com/blog/2015/10/05/how-to-build-a-https-server/">HTTPS证书生成原理和部署细节<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85MDkxZWJkNDM5YTA=" title="https://www.jianshu.com/p/9091ebd439a0">SSL证书生成流程<i class="fa fa-external-link"></i></span></p></blockquote><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ncmFkbGUub3JnL2luc3RhbGwv" title="https://gradle.org/install/">Gradle官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3Rvb2xzLmFuZHJvaWQtc3R1ZGlvLm9yZy9pbmRleC5waHAvOS10b29scy8xMDktYW5kcm9pZC10b29scy1kb3dubG9hZA==" title="http://tools.android-studio.org/index.php/9-tools/109-android-tools-download">Gradle 包<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zNmU1NjljMWJiMTI=" title="https://www.jianshu.com/p/36e569c1bb12">Mac下AndroidStudio中手动配置Gradle<i class="fa fa-external-link"></i></span></p></blockquote><p>WebRTC的分层协议图：</p><img src="/images/imageWebRTC/webrtc分层协议图.png"><p>信令，会话和协议：</p><img src="/images/imageWebRTC/信令会话协议.png"><h2 id="问题解决里程"><a href="#问题解决里程" class="headerlink" title="问题解决里程"></a>问题解决里程</h2><p>node 启动 server 报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">events.js:141</span><br><span class="line">      throw er; // Unhandled 'error' event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EACCES 0.0.0.0:443</span><br><span class="line">    at Object.exports._errnoException (util.js:870:11)</span><br><span class="line">    at exports._exceptionWithHostPort (util.js:893:20)</span><br><span class="line">    at Server._listen2 (net.js:1224:19)</span><br><span class="line">    at listen (net.js:1273:10)</span><br><span class="line">    at net.js:1382:9</span><br><span class="line">    at nextTickCallbackWith3Args (node.js:452:9)</span><br><span class="line">    at process._tickCallback (node.js:358:17)</span><br><span class="line">    at Function.Module.runMain (module.js:444:11)</span><br><span class="line">    at startup (node.js:136:18)</span><br><span class="line">    at node.js:966:3</span><br><span class="line"><span class="meta">[Solve]$</span><span class="bash"> sudo <span class="built_in">setcap</span> <span class="string">'cap_net_bind_service=+ep'</span> $(readlink -f $(<span class="built_in">which</span> node))</span></span><br></pre></td></tr></table></figure><p>查询端口是否别占用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -ntpl | grep 443</span></span><br></pre></td></tr></table></figure><h2 id="VIM-快捷键温习"><a href="#VIM-快捷键温习" class="headerlink" title="VIM 快捷键温习"></a>VIM 快捷键温习</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93eG5hY3kuY29tLzIwMTcvMDkvMjIvdmltLXBsdWdpbi10ZXJuLw==" title="https://wxnacy.com/2017/09/22/vim-plugin-tern/">Vim 插件 tern_for_vim Javascript 自动补全<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hcmNoaXZlLzIwMTIvMDYvMTQvdmltX25vdGVzLmh0bWwjaWQxMDc=" title="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107">最全的vim快捷键<i class="fa fa-external-link"></i></span></p></blockquote><p>vim 格式化文本，调整缩进：</p><blockquote><p>= 是格式化文本的快捷方法， 当你发现代码缩进的不整齐的，可以用这个快速对齐它们。</p><p>直接按＝号就可以，不能进入命令模式（以 “:” 冒号开始的命令行）。</p><p>gg=G ：从头格到尾，爽。</p><p>＝＝ 格式化一行</p><p>如要格式化一段代码，可以先选中这些代码，再按＝号。</p><p>调整缩进还有个比较慢的办法，按＞＞，向右缩进一格，＜＜向左缩进一格。</p></blockquote><p>vim常用快捷键总结：</p><ul><li><p>光标移动到行首：0</p></li><li><p>光标移动到行尾：$</p></li><li><p>光标移动到文件开始：GG</p></li><li><p>光标移动到文件末尾：shift +G</p></li><li><p>先前翻页：Ctrl+f</p></li><li><p>向后翻页：Ctrl+b</p></li><li><p>删至行首：d0</p></li><li><p>删至行尾：d$</p></li><li><p>删除当前行及其后面n-1行：ndd</p></li><li><p>删除当前字符：x</p></li><li><p>删除当前字符的前一个字符：X</p></li><li><p>删除当前字符：dl</p></li><li><p>删除到第三个字符的结尾位置：d3w</p></li><li><p>删除到某个单词的末尾：dw</p></li><li><p>删除到某个单词的开始：db</p></li><li><p>删除当前行到文件的末尾：dG</p></li><li><p>删除当前行到文件第一行：dH</p></li><li><p>删除知道屏幕上最后一行：dL</p></li><li><p>替换当前行所有temp为hehe：:s/temp/hehe/g</p></li><li><p>替换每行中第一个#include为hehe：:%s/#include/hehe/</p></li><li><p>替换每行中所有的#include为hehe：:%s/#include/hehe/g</p></li><li><p>替换第n行开始到最后一行中每一行的第一个#include为hehe：:n,$s/#include/hehe/</p></li><li><p>替换第n行开始到最后一行中每一行的所有#include为hehe：:n,$s/#include/hehe/g</p></li><li><p>替换当前行到末尾的所有#include为hehe：:.,$s/#include/hehe/g</p></li><li><p>替换正文中所有出现的#include为hehe：:1,$s/#include/hehe/g</p></li><li><p>回复上一步操作：u</p></li><li><p>全部回复操作：shift + u</p></li><li><p>重做上一步操作：Ctrl + r</p></li><li><p>把下一行合并到当前行尾：J</p></li><li><p>选中当前行及其后面的n-1行：nV</p></li><li><p>复制当前光标到此单词末尾：yw</p></li><li><p>批量添加注释：Ctrl+v可视模式，上、下、左、右移动光标选择若干行开头；Shift+i进入插入模式；输入// 者；按Esc</p></li><li><p>批量去掉注释：Ctrl+v可视模式，上、下、左、右移动关闭选择要删除的注释符，如//或#；按d删除</p></li><li><p>横向打开另一个窗口：:sp 文件名</p></li><li><p>竖向打开另一个窗口：:vsp 文件名</p></li><li><p>关闭当前打开的所有窗口：:qa</p></li><li><p>选择当前字符所在的单词：Ctrl+v可视模式，然后a+w或i+w</p></li><li><p>选择当前字符所在的段落：Ctrl+v可视模视，然后i+p或a+p</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WebRTC&quot;&gt;&lt;a href=&quot;#WebRTC&quot; class=&quot;headerlink&quot; title=&quot;WebRTC&quot;&gt;&lt;/a&gt;WebRTC&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYlJUQ19BUEk=&quot; title=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API&quot;&gt;WebRTC API&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL25vZGVqcy5jbi9hcGkv&quot; title=&quot;http://nodejs.cn/api/&quot;&gt;Node.js v10.15.3 文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI1MjM1MzU5MDQw&quot; title=&quot;https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040&quot;&gt;廖雪峰 - nodejs&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zMTBjMGQxMzNjM2M=&quot; title=&quot;https://www.jianshu.com/p/310c0d133c3c&quot;&gt;Webrtc笔记-获取源码&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81YThhOTFjZDg0ZWY=&quot; title=&quot;https://www.jianshu.com/p/5a8a91cd84ef&quot;&gt;WebRTC音频引擎实现分析&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-WebRTC-介绍&quot;&gt;&lt;a href=&quot;#1-WebRTC-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. WebRTC 介绍&quot;&gt;&lt;/a&gt;1. WebRTC 介绍&lt;/h2&gt;
    
    </summary>
    
      <category term="WebRTC" scheme="http://miaopei.github.io/categories/WebRTC/"/>
    
    
      <category term="WebRTC" scheme="http://miaopei.github.io/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg命令大全</title>
    <link href="http://miaopei.github.io/2019/05/04/FFmpeg/FFmpeg%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://miaopei.github.io/2019/05/04/FFmpeg/FFmpeg命令大全/</id>
    <published>2019-05-04T02:14:50.000Z</published>
    <updated>2019-06-05T04:03:57.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p><p>本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。</p><a id="more"></a><h2 id="2-FFMPEG-目录及作用"><a href="#2-FFMPEG-目录及作用" class="headerlink" title="2. FFMPEG 目录及作用"></a>2. FFMPEG 目录及作用</h2><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各类工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h2 id="3-FFMPEG-基本概念"><a href="#3-FFMPEG-基本概念" class="headerlink" title="3. FFMPEG 基本概念"></a>3. FFMPEG 基本概念</h2><p>在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。</p><ul><li><p>音／视频流</p><p>在音视频领域，我们把一路音／视频称为一路<strong>流</strong>。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p></li><li><p>容器</p><p>我们一般把 MP4､ FLV、MOV 等文件格式称之为<strong>容器</strong>。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p></li><li><p>channel</p><p>channel 是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p></li></ul><h2 id="4-FFMPEG-命令"><a href="#4-FFMPEG-命令" class="headerlink" title="4. FFMPEG 命令"></a>4. FFMPEG 命令</h2><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解 / 复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><img src="/images/imageFFmpeg/音视频处理流程.png"><p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。</p><p>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。</p><p>您可以通过使用 <code>-vn / -an / -sn / -dn</code> 选项来禁用某些默认设置。 要进行全面的手动控制，请使用 <code>-map</code>选项，该选项禁用刚描述的默认设置。</p><p>下面我们就来详细介绍一下这些命令。</p><h2 id="5-基本信息查询命令"><a href="#5-基本信息查询命令" class="headerlink" title="5. 基本信息查询命令"></a>5. 基本信息查询命令</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 <code>ffmpeg -filters</code> 来查询。详细参数说明如下：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-version</td><td>显示版本。</td></tr><tr><td>-formats</td><td>显示可用的格式（包括设备）。</td></tr><tr><td>-demuxers</td><td>显示可用的demuxers。</td></tr><tr><td>-muxers</td><td>显示可用的muxers。</td></tr><tr><td>-devices</td><td>显示可用的设备。</td></tr><tr><td>-codecs</td><td>显示libavcodec已知的所有编解码器。</td></tr><tr><td>-decoders</td><td>显示可用的解码器。</td></tr><tr><td>-encoders</td><td>显示所有可用的编码器。</td></tr><tr><td>-bsfs</td><td>显示可用的比特流filter。</td></tr><tr><td>-protocols</td><td>显示可用的协议。</td></tr><tr><td>-filters</td><td>显示可用的libavfilter过滤器。</td></tr><tr><td>-pix_fmts</td><td>显示可用的像素格式。</td></tr><tr><td>-sample_fmts</td><td>显示可用的采样格式。</td></tr><tr><td>-layouts</td><td>显示channel名称和标准channel布局。</td></tr><tr><td>-colors</td><td>显示识别的颜色名称。</td></tr></tbody></table><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。</p><h2 id="6-命令基本格式及参数"><a href="#6-命令基本格式及参数" class="headerlink" title="6. 命令基本格式及参数"></a>6. 命令基本格式及参数</h2><p>下面是 FFMPEG 的基本命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ...</span></span><br><span class="line">                         &#123;[output_file_options] output_url&#125; ...</span><br></pre></td></tr></table></figure><p>ffmpeg 通过 <code>-i</code> 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等），并写入任意数量的输出“文件”。</p><p>原则上，每个输入 / 输出“文件”都可以包含任意数量的不同类型的视频流（视频 / 音频 / 字幕 / 附件 / 数据）。 <strong>流的数量和 / 或类型是由容器格式来限制</strong>。 选择从哪个输入进入到哪个输出将自动完成或使用 <code>-map</code> 选项。</p><p>要引用选项中的输入文件，您必须使用它们的索引（从 0 开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 <strong>例如： 2：3 是指第三个输入文件中的第四个流</strong>。</p><p>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p><h3 id="6-1-主要参数"><a href="#6-1-主要参数" class="headerlink" title="6.1 主要参数"></a>6.1 主要参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-f fmt（输入/输出）</td><td>强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。</td></tr><tr><td>-i url（输入）</td><td>输入文件的网址</td></tr><tr><td>-y（全局参数）</td><td>覆盖输出文件而不询问。</td></tr><tr><td>-n（全局参数）</td><td>不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。</td></tr><tr><td>-c [：stream_specifier] codec（输入/输出，每个流）</td><td>选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：<code>ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT</code></td></tr><tr><td>-codec [：stream_specifier]编解码器（输入/输出，每个流）</td><td>同 -c</td></tr><tr><td>-t duration（输入/输出）</td><td>当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</td></tr><tr><td>-ss位置（输入/输出）</td><td>当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</td></tr><tr><td>-frames [：stream_specifier] framecount（output，per-stream）</td><td>停止在帧计数帧之后写入流。</td></tr><tr><td>-filter [：stream_specifier] filtergraph（output，per-stream）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</td></tr></tbody></table><h3 id="6-2-视频参数"><a href="#6-2-视频参数" class="headerlink" title="6.2 视频参数"></a>6.2 视频参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-vframes num（输出）</td><td>设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。</td></tr><tr><td>-r [：stream_specifier] fps（输入/输出，每个流）</td><td>设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。</td></tr><tr><td>-s [：stream_specifier]大小（输入/输出，每个流）</td><td>设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。</td></tr><tr><td>-aspect [：stream_specifier] 宽高比（输出，每个流）</td><td>设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。</td></tr><tr><td>-vn（输出）</td><td>禁用视频录制。</td></tr><tr><td>-vcodec编解码器（输出）</td><td>设置视频编解码器。这是 <code>-codec：v</code> 的别名。</td></tr><tr><td>-vf filtergraph（输出）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><h3 id="6-3-音频参数"><a href="#6-3-音频参数" class="headerlink" title="6.3 音频参数"></a>6.3 音频参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-aframes（输出）</td><td>设置要输出的音频帧的数量。这是 <code>-frames：a</code> 的一个过时的别名。</td></tr><tr><td>-ar [：stream_specifier] freq（输入/输出，每个流）</td><td>设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td>-ac [：stream_specifier]通道（输入/输出，每个流）</td><td>设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td>-an（输出）</td><td>禁用录音。</td></tr><tr><td>-acodec编解码器（输入/输出）</td><td>设置音频编解码器。这是-codec的别名：a。</td></tr><tr><td>-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</td><td>设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。</td></tr><tr><td>-af filtergraph（输出）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><p>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p><h2 id="7-录制"><a href="#7-录制" class="headerlink" title="7. 录制"></a>7. 录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -list_devices <span class="literal">true</span> -i <span class="string">""</span></span></span><br></pre></td></tr></table></figure><p><strong>录屏</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span></span><br></pre></td></tr></table></figure><ul><li><p>-f 指定使用 avfoundation 采集数据。</p></li><li><p>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</p></li><li><p>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而 -r 用于限制输出。</p></li></ul><p>注意：桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</p><p><strong>录屏+声音</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</span></span><br></pre></td></tr></table></figure><ul><li><p>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</p></li><li><p>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</p></li><li><p>-crf 是 x264 的参数。 0 表式无损压缩。</p></li><li><p>-c:a 与参数 -acodec 一样，表示音频编码器。</p></li><li><p>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</p></li><li><p>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</p></li></ul><p><strong>录视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</p></li><li><p>-f 指定使用 avfoundation 采集数据。</p></li><li><p>-i 指定视频设备的索引号。</p></li></ul><p><strong>视频+音频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</span></span><br></pre></td></tr></table></figure><p><strong>录音</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -i :0 out.wav</span></span><br></pre></td></tr></table></figure><p><strong>录制音频裸数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</span></span><br></pre></td></tr></table></figure><h2 id="8-分解与复用"><a href="#8-分解与复用" class="headerlink" title="8. 分解与复用"></a>8. 分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p><img src="/images/imageFFmpeg/分解与复用.png"><p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p><p><strong>抽取音频流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -acodec copy -vn out.aac</span></span><br></pre></td></tr></table></figure><ul><li><p>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</p></li><li><p>vn: v 代表视频，n 代表 no 也就是无视频的意思。</p></li></ul><p><strong>抽取视频流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -vcodec copy -an out.h264</span></span><br></pre></td></tr></table></figure><ul><li><p>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</p></li><li><p>an: a 代表视频，n 代表 no 也就是无音频的意思。</p></li></ul><p><strong>转格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span></span><br></pre></td></tr></table></figure><p>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了 flv。</p><p><strong>音视频合并</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</span></span><br></pre></td></tr></table></figure><h2 id="9-处理原始数据"><a href="#9-处理原始数据" class="headerlink" title="9. 处理原始数据"></a>9. <strong>处理原始数据</strong></h2><p><strong>提取YUV数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffplay -s wxh out.yuv</span></span><br></pre></td></tr></table></figure><ul><li><p>-c:v rawvideo 指定将视频转成原始数据</p></li><li><p>-pixel_format yuv420p 指定转换格式为 yuv420p</p></li></ul><p><strong>YUV 转 H264</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</span></span><br></pre></td></tr></table></figure><p><strong>提取 PCM 数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</span></span><br></pre></td></tr></table></figure><p><strong>PCM 转 WAV</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</span></span><br></pre></td></tr></table></figure><h2 id="10-滤镜"><a href="#10-滤镜" class="headerlink" title="10. 滤镜"></a>10. <strong>滤镜</strong></h2><p>在编码之前，ffmpeg 可以使用 libavfilter 库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg 区分两种类型的过滤器图形：简单和复杂。</p><h3 id="10-1-简单滤镜"><a href="#10-1-简单滤镜" class="headerlink" title="10.1 简单滤镜"></a>10.1 简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p><img src="/images/imageFFmpeg/简单滤镜.png"><p>简单的 filtergraphs 配置了 per-stream-filter 选项（分别为视频和音频使用 <code>-vf</code> 和 <code>-af</code> 别名）。 一个简单的视频 filtergraph 可以看起来像这样的例子：</p><img src="/images/imageFFmpeg/简单滤镜-01.png"><p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的 fps 过滤器会改变帧数，但不会触及帧内容。 另一个例子是 setpts 过滤器，它只设置时间戳，否则不改变帧。</p><h3 id="10-2-复杂滤镜"><a href="#10-2-复杂滤镜" class="headerlink" title="10.2 复杂滤镜"></a>10.2 复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p><img src="/images/imageFFmpeg/复杂滤镜.png"><p>复杂的过滤器图使用 <code>-filter_complex</code> 选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。</p><p><code>-lavfi</code> 选项等同于 <code>-filter_complex</code>。</p><p>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是 amix 滤波器。</p><p><strong>添加水印</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4  -vf <span class="string">"movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]"</span> water.mp4</span></span><br></pre></td></tr></table></figure><ul><li>-vf 中的 movie 指定 logo 位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。</li></ul><p><strong>删除水印</strong></p><p>先通过 ffplay 找到要删除 LOGO 的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -i test.flv -vf delogo=x=806:y=20:w=70:h=80:show=1</span></span><br></pre></td></tr></table></figure><p>使用 delogo 滤镜删除 LOGO</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.flv -vf delogo=x=806:y=20:w=70:h=80 output.flv</span></span><br></pre></td></tr></table></figure><p><strong>视频缩小一倍</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4</span></span><br></pre></td></tr></table></figure><ul><li>-vf scale 指定使用简单过滤器 scale，<code>iw/2:-1</code> 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</li></ul><p><strong>视频裁剪</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i VR.mov  -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</span></span><br></pre></td></tr></table></figure><p>crop 格式：<code>crop=out_w:out_h:x:y</code></p><ul><li><p>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</p></li><li><p>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</p></li><li><p>x : X坐标</p></li><li><p>y : Y坐标</p></li></ul><p>如果 x 和 y 设置为 0, 说明从左上角开始裁剪。如果不写是从中心点裁剪。</p><p><strong>倍速播放</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -filter_complex <span class="string">"[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]"</span> -map <span class="string">"[v]"</span> -map <span class="string">"[a]"</span> speed2.0.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-filter_complex 复杂滤镜，<code>[0:v]</code> 表示第一个（文件索引号是 0）文件的视频作为输入。<code>setpts=0.5*PTS</code> 表示每帧视频的 pts 时间戳都乘 0.5 ，也就是差少一半。<code>[v]</code> 表示输出的别名。音频同理就不详述了。</p></li><li><p>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</p></li></ul><p><strong>对称视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -i out.mp4 -filter_complex <span class="string">"[0:v]pad=w=2*iw[a];[0:v]hflip[b];[a][b]overlay=x=w"</span> duicheng.mp4</span></span><br></pre></td></tr></table></figure><ul><li>hflip 水平翻转</li></ul><p>如果要修改为垂直翻转可以用 vflip。</p><p><strong>画中画</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -i out1.mp4 -filter_complex <span class="string">"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart new.mp4</span></span><br></pre></td></tr></table></figure><p><strong>录制画中画</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation -i <span class="string">"0:0"</span> </span></span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast </span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 </span><br><span class="line">-filter_complex "[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[a];[0:v][a]overlay=x=W-w-10:y=0[out]" </span><br><span class="line">-map "[out]" -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure><p><strong>多路视频拼接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation   -i <span class="string">"0:0"</span> -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex <span class="string">"[0:v]scale=320:240[a];[a]pad=640:240[b];[b][1:v]overlay=320:0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart  -map 1:a  c.mp4</span></span><br></pre></td></tr></table></figure><h2 id="11-音视频的拼接与裁剪"><a href="#11-音视频的拼接与裁剪" class="headerlink" title="11. 音视频的拼接与裁剪"></a>11. <strong>音视频的拼接与裁剪</strong></h2><p><strong>裁剪</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-ss 指定裁剪的开始时间，精确到秒</p></li><li><p>-t 被裁剪后的时长。</p></li></ul><p><strong>合并</strong></p><p>首先创建一个 inputs.txt 文件，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'1.flv'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'2.flv'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'3.flv'</span></span></span><br></pre></td></tr></table></figure><p>然后执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f concat -i inputs.txt -c copy output.flv</span></span><br></pre></td></tr></table></figure><p><strong>hls切片</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</span></span><br></pre></td></tr></table></figure><ul><li><p>-strict -2 指明音频使有AAC。</p></li><li><p>-f hls 转成 m3u8 格式。</p></li></ul><h2 id="12-视频图片互转"><a href="#12-视频图片互转" class="headerlink" title="12. 视频图片互转"></a>12. 视频图片互转</h2><p><strong>视频转 JPEG</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</span></span><br></pre></td></tr></table></figure><p><strong>视频转 gif</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</span></span><br></pre></td></tr></table></figure><p><strong>图片转视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</span></span><br></pre></td></tr></table></figure><h2 id="13-直播相关"><a href="#13-直播相关" class="headerlink" title="13. 直播相关"></a>13. <strong>直播相关</strong></h2><p><strong>推流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span></span><br></pre></td></tr></table></figure><p><strong>拉流保存</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><p><strong>转流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream</span></span><br></pre></td></tr></table></figure><p><strong>实时推流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 15 -f avfoundation -i <span class="string">"1"</span> -s 1280x720 -c:v libx264  -f  flv rtmp://localhost:1935/live/room</span></span><br></pre></td></tr></table></figure><h2 id="14-ffplay"><a href="#14-ffplay" class="headerlink" title="14. ffplay"></a>14. <strong>ffplay</strong></h2><p><strong>播放 YUV 数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -pix_fmt nv12 -s 192x144 1.yuv</span></span><br></pre></td></tr></table></figure><p><strong>播放 YUV 中的 Y 平面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes=<span class="string">'y'</span> 1.yuv</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。&lt;/p&gt;
&lt;p&gt;本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频核心技术</title>
    <link href="http://miaopei.github.io/2019/04/30/FFmpeg/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>http://miaopei.github.io/2019/04/30/FFmpeg/音视频核心技术/</id>
    <published>2019-04-30T06:14:50.000Z</published>
    <updated>2019-06-21T04:04:52.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDIyMDE1MQ==" title="https://blog.csdn.net/leixiaohua1020/article/details/44220151">雷神 FFmpeg源代码结构图 - 解码<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hhdHN1bmVNaWt1Vi9GRm1wZWdfTGVpeGlhb2h1YQ==" title="https://github.com/HatsuneMikuV/FFmpeg_Leixiaohua">雷神 GitHub<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2NvbHVtbi9pbmZvL2ZmbXBlZy1kZXZlbC83" title="https://blog.csdn.net/leixiaohua1020/column/info/ffmpeg-devel/7">雷神 FFmpeg blog<i class="fa fa-external-link"></i></span></p></blockquote><a id="more"></a><img src="/images/imageFFmpeg/FFmpeg音视频架构-01.png"><img src="/images/imageFFmpeg/FFmpeg音视频架构-02.png"><h2 id="1-学习大纲"><a href="#1-学习大纲" class="headerlink" title="1. 学习大纲"></a>1. 学习大纲</h2><p><strong>FFmpeg 常用命令</strong>：</p><ul><li>视频录制命令</li><li>多媒体文件的分解/复用命令</li><li>裁剪与合并命令</li><li>图片/视频互转命令</li><li>直播相关命令</li><li>各种滤镜命令</li></ul><p><strong>FFmpeg 基本开发</strong>：</p><ul><li>C 语言回顾</li><li>FFmpeg 核心概念与常用结构体</li><li>实战 - 多媒体文件的分解与复用</li><li>实战 - 多媒体格式的互转</li><li>实战 - 从 MP4 裁剪一段视频</li><li>作业 - 实现一个简单的小咖秀</li></ul><p><strong>音视频编解码实战</strong>：</p><ul><li>实战 - H264 解码</li><li>实战 - H264 编码</li><li>实战 - 音频 AAC 解码</li><li>实战 - 音频 AAC 编码</li><li>实战 - 视频转图片</li></ul><p><strong>音视频渲染实战</strong>：</p><ul><li>SDL 事件处理</li><li>SDL 视频文理渲染</li><li>SDL 音频渲染</li><li>实战1 - 实现 YUV 视频播放</li><li>实战2 - YUV 视频倍数播放</li><li>实战3 - 实现 PCM 播放器</li></ul><p><strong>FFmpeg 开发播放器核心功能</strong>：</p><ul><li>实战 - 实现 MP4 文件的视频播放</li><li>实战 - 实现 MP4 文件的音频播放</li><li>实战 - 实现一个初级播放器</li><li>实战 - 音视频同步</li><li>实战 - 实现播放器内核</li></ul><p><strong>Android 中实战 FFmpeg</strong>：</p><ul><li>编译 Android 端可以使用的 FFmpeg</li><li>Java 与 C 语言相互调用</li><li>实战 - Android 调用 FFmpeg</li></ul><p><strong>学习建议</strong>：</p><ul><li>牢牢抓住音视频的处理机制，了解其本质</li><li>勤加练习，熟能生巧</li><li>待着问题去学习，事半功倍</li></ul><p><strong>音视频的广泛应用</strong>：</p><ul><li>直播类：音视频会议、教育直播、娱乐/游戏直播</li><li>短视频：抖音、快手、小咖秀</li><li>网络视频：优酷、腾讯视频、爱奇艺等</li><li>音视频通话：微信、QQ、Skype等</li><li>视频监控</li><li>人工智能：人脸识别，智能音箱等，更关注算法</li></ul><p><strong>播放器架构</strong>：</p><img src="/images/imageFFmpeg/播放器架构.png"><p><strong>渲染流程</strong>：</p><img src="/images/imageFFmpeg/渲染流程.png"><p><strong>FFmpeg 都能做啥</strong>：</p><ul><li>FFmpeg 是一个非常优秀的多媒体框架</li><li>FFmpeg 可以运行在 Linux、Mac、Windows 等平台上</li><li>能够解码、编码、转码、复用、解复用、过滤音视频数据</li></ul><p><strong>FFmpeg 下载与安装</strong>：</p><details><summary>FFMpeg 下载与安装</summary> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://git.ffmpeg.org/ffmpeg.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> config -- <span class="built_in">help</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure></details><h2 id="2-FFmpeg-常用命令实战"><a href="#2-FFmpeg-常用命令实战" class="headerlink" title="2. FFmpeg 常用命令实战"></a>2. FFmpeg 常用命令实战</h2><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解 / 复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><img src="/images/imageFFmpeg/FFmpeg处理音视频流程.png"><img src="/images/imageFFmpeg/FFmpeg基本信息查询命令.png"><img src="/images/imageFFmpeg/FFmpeg录屏命令.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -s 2560x1600 -pix_fmt uyvy422 out.yuv</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/分解与复用-01.png"><img src="/images/imageFFmpeg/多媒体格式转换.png"><h2 id="3-初级开发内容"><a href="#3-初级开发内容" class="headerlink" title="3. 初级开发内容"></a>3. 初级开发内容</h2><ul><li>FFmpeg 日志的使用及目录的操作</li><li>介绍 FFmpeg 的基本概念及常用的结构体</li><li>对复用/解复用及流程操作的各种实践</li></ul><p>FFmpeg 代码结构：</p><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各类工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h3 id="3-1-FFmpeg-日志系统"><a href="#3-1-FFmpeg-日志系统" class="headerlink" title="3.1 FFmpeg 日志系统"></a>3.1 FFmpeg 日志系统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">av_log_set_level(AV_LOG_DEBUG)</span><br><span class="line">    </span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"...%s\n"</span>, op)</span><br></pre></td></tr></table></figure><ul><li>AV_LOG_ERROR</li><li>AV_LOG_WARNING</li><li>AV_LOG_INFO</li></ul><details><summary>FFmpeg日志系统使用</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line"></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"hello world: %s!\n"</span>, <span class="string">"aaa"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="3-2-FFmpeg-文件与目录操作"><a href="#3-2-FFmpeg-文件与目录操作" class="headerlink" title="3.2 FFmpeg 文件与目录操作"></a>3.2 FFmpeg 文件与目录操作</h3><p>文件的删除与重命名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">avpriv_io_delete()</span><br><span class="line">    </span><br><span class="line">avpriv_io_move(src, dst)</span><br></pre></td></tr></table></figure><details><summary>FFmpeg文件与目录操作</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = avpriv_io_delete(<span class="string">"./mytestfile.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to delete file mytestfile.txt\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = avpriv_io_move(<span class="string">"111.txt"</span>, <span class="string">"222.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Filed to rename\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --libs libavformat`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pkg-config --libs libavformat 指令可以搜索libavformat库所在路径</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> pkg-config --libs libavformat</span></span><br><span class="line">-L/usr/local/ffmpeg/lib -lavformat</span><br></pre></td></tr></table></figure></details><h3 id="3-3-FFmpeg-操作目录重要函数"><a href="#3-3-FFmpeg-操作目录重要函数" class="headerlink" title="3.3 FFmpeg 操作目录重要函数"></a>3.3 FFmpeg 操作目录重要函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avio_open_dir()</span><br><span class="line">avio_read_dir()</span><br><span class="line">avio_close_dir()</span><br></pre></td></tr></table></figure><p>操作目录重要结构体：</p><ul><li><p>AVIODirContext</p><p>操作目录的上下文</p></li><li><p>AVIODirEntry</p><p>目录项。用于存放文件名，文件大小等信息</p></li></ul><details><summary>FFmpeg操作目录</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVIODirContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVIODirEntry *entry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = avio_open_dir(&amp;ctx, <span class="string">"./"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant open dir:%s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = avio_read_dir(ctx, &amp;entry);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant read dir: %s\n"</span>, av_err2str(ret));</span><br><span class="line">            <span class="keyword">goto</span> __fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"%l2"</span>PRId64<span class="string">" %s\n"</span>,</span><br><span class="line">               entry-&gt;size,</span><br><span class="line">               entry-&gt;name);</span><br><span class="line"></span><br><span class="line">        avio_free_directory_entry(&amp;entry);</span><br><span class="line">    &#125;</span><br><span class="line">__fail:</span><br><span class="line">    avio_close_dir(&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o list ffmpeg_list.c `pkg-config --libs libavformat libavutil`</span></span><br></pre></td></tr></table></figure></details><h3 id="3-4-多媒体文件的基本概念"><a href="#3-4-多媒体文件的基本概念" class="headerlink" title="3.4 多媒体文件的基本概念"></a>3.4 多媒体文件的基本概念</h3><ul><li>多媒体文件其实是个容器</li><li>在容器里有很多流（Stream/Track)</li><li>每种流是由不同的编码器编码的</li><li>从流中读出的数据称为包</li><li>在一个包中包含着一个或多个帧</li></ul><p>几个重要的结构体：</p><ul><li>AVFormatContext</li><li>AVStream</li><li>AVPacket</li></ul><p>FFmpeg 操作流数据的基本步骤：</p><p>解复用 —&gt; 获取流 —&gt; 读取数据包 —&gt;  释放资源</p><h3 id="3-5-实战-打印音-视频信息"><a href="#3-5-实战-打印音-视频信息" class="headerlink" title="3.5 [实战] 打印音/视频信息"></a>3.5 [实战] 打印音/视频信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_register_all()</span><br><span class="line">avformat_open_input() / avformat_close_input()</span><br><span class="line">av_dump_format()</span><br></pre></td></tr></table></figure><details><summary>[实战] 打印音/视频信息</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    ret = avformat_open_input(&amp;fmt_ctx, <span class="string">"./test.mp4"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open file: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, <span class="string">"./test.mp4"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;fmt_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="3-6-实战-抽取音频数据"><a href="#3-6-实战-抽取音频数据" class="headerlink" title="3.6 [实战] 抽取音频数据"></a>3.6 [实战] 抽取音频数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_init_packet()</span><br><span class="line">av_find_best_stream()</span><br><span class="line">av_read_frame() / av_packet_unref()</span><br></pre></td></tr></table></figure><details><summary>[实战] 抽取音频数据</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> audio_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *src = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *dst = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. read two params form console</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"eg: %s in_file out_file\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    src = argv[<span class="number">1</span>];</span><br><span class="line">    dst = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (!src || !dst) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"src or dst is null\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = avformat_open_input(&amp;fmt_ctx, src, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open file: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *dst_fd = fopen(dst, <span class="string">"wb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dst_fd) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open out file!\n"</span>);</span><br><span class="line">        avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, src, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. get stream</span></span><br><span class="line">    ret = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't find the best stream!\n"</span>);</span><br><span class="line">        avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">        fclose(dst_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_index = ret;</span><br><span class="line">    av_init_packet(&amp;pkt);</span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(fmt_ctx, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt.stream_index == audio_index) &#123;</span><br><span class="line">            <span class="comment">// 3. write audio data to aac file.</span></span><br><span class="line">            len = fwrite(pkt.data, <span class="number">1</span>, pkt.size, dst_fd);</span><br><span class="line">            <span class="keyword">if</span> (len != pkt.size) &#123;</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">"warning, length of data is not equal size of pkt!\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">    <span class="keyword">if</span> (dst_fd) &#123;</span><br><span class="line">        fclose(dst_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lang -g -o extra_audio extra_audio.c `pkg-config --libs libavutil libavformat`</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./extra_audio test.mp4 killer.aa</span></span><br></pre></td></tr></table></figure></details><h3 id="3-7-实战-抽取视频数据"><a href="#3-7-实战-抽取视频数据" class="headerlink" title="3.7 [实战] 抽取视频数据"></a>3.7 [实战] 抽取视频数据</h3><ul><li>Start code</li><li>SPS/PPS</li><li>codec -&gt; extradata</li></ul><h3 id="3-8-实战-将-MP4-转成-FLV-格式"><a href="#3-8-实战-将-MP4-转成-FLV-格式" class="headerlink" title="3.8 [实战] 将 MP4 转成 FLV 格式"></a>3.8 [实战] 将 MP4 转成 FLV 格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">avformat_alloc_output_context2() / avformat_free_context();</span><br><span class="line">avformat_new_stream();</span><br><span class="line">avcodec_parameters_copy();</span><br><span class="line">avformat_write_header();</span><br><span class="line">av_write_frame() / av_interleaved_write_frame();</span><br><span class="line">av_write_trailer()</span><br></pre></td></tr></table></figure><h3 id="3-9-实战-从-MP4-截取一段视频"><a href="#3-9-实战-从-MP4-截取一段视频" class="headerlink" title="3.9 [实战] 从 MP4 截取一段视频"></a>3.9 [实战] 从 MP4 截取一段视频</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_seek_frame()</span><br></pre></td></tr></table></figure><details><summary>从 MP4 截取一段视频代码:</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_packet</span><span class="params">(<span class="keyword">const</span> AVFormatContext *fmt_ctx, <span class="keyword">const</span> AVPacket *pkt, <span class="keyword">const</span> <span class="keyword">char</span> *tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVRational *time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\n"</span>,</span><br><span class="line">           tag,</span><br><span class="line">           av_ts2str(pkt-&gt;pts), av_ts2timestr(pkt-&gt;pts, time_base),</span><br><span class="line">           av_ts2str(pkt-&gt;dts), av_ts2timestr(pkt-&gt;dts, time_base),</span><br><span class="line">           av_ts2str(pkt-&gt;duration), av_ts2timestr(pkt-&gt;duration, time_base),</span><br><span class="line">           pkt-&gt;stream_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_video</span><span class="params">(<span class="keyword">double</span> from_seconds, <span class="keyword">double</span> end_seconds, <span class="keyword">const</span> <span class="keyword">char</span>* in_filename, <span class="keyword">const</span> <span class="keyword">char</span>* out_filename)</span> </span>&#123;</span><br><span class="line">    AVOutputFormat *ofmt = <span class="literal">NULL</span>;</span><br><span class="line">    AVFormatContext *ifmt_ctx = <span class="literal">NULL</span>, *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    <span class="keyword">int</span> ret, i;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = avformat_open_input(&amp;ifmt_ctx, in_filename, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open input file '%s'"</span>, in_filename);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = avformat_find_stream_info(ifmt_ctx, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to retrieve input stream information"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_dump_format(ifmt_ctx, <span class="number">0</span>, in_filename, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, out_filename);</span><br><span class="line">    <span class="keyword">if</span> (!ofmt_ctx) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not create output context\n"</span>);</span><br><span class="line">        ret = AVERROR_UNKNOWN;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ofmt = ofmt_ctx-&gt;oformat;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *in_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        AVStream *out_stream = avformat_new_stream(ofmt_ctx, in_stream-&gt;codec-&gt;codec);</span><br><span class="line">        <span class="keyword">if</span> (!out_stream) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed allocating output stream\n"</span>);</span><br><span class="line">            ret = AVERROR_UNKNOWN;</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ret = avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy context from input to output stream codec context\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        out_stream-&gt;codec-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)</span><br><span class="line">            out_stream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line">    av_dump_format(ofmt_ctx, <span class="number">0</span>, out_filename, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">        ret = avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open output file '%s'"</span>, out_filename);</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error occurred when opening output file\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    int indexs[8] = &#123;0&#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    int64_t start_from = 8*AV_TIME_BASE;</span></span><br><span class="line">    ret = av_seek_frame(ifmt_ctx, <span class="number">-1</span>, from_seconds*AV_TIME_BASE, AVSEEK_FLAG_ANY);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error seek\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int64_t</span> *dts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="built_in">memset</span>(dts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="keyword">int64_t</span> *pts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="built_in">memset</span>(pts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        AVStream *in_stream, *out_stream;</span><br><span class="line">    </span><br><span class="line">        ret = av_read_frame(ifmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">        in_stream  = ifmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">        out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">    </span><br><span class="line">        log_packet(ifmt_ctx, &amp;pkt, <span class="string">"in"</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (av_q2d(in_stream-&gt;time_base) * pkt.pts &gt; end_seconds) &#123;</span><br><span class="line">            av_free_packet(&amp;pkt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (dts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            dts_start_from[pkt.stream_index] = pkt.dts;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"dts_start_from: %s\n"</span>, av_ts2str(dts_start_from[pkt.stream_index]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            pts_start_from[pkt.stream_index] = pkt.pts;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"pts_start_from: %s\n"</span>, av_ts2str(pts_start_from[pkt.stream_index]));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* copy packet */</span></span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts - pts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts - dts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);</span><br><span class="line">        <span class="keyword">if</span> (pkt.pts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.pts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pkt.dts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.dts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pkt.duration = (<span class="keyword">int</span>)av_rescale_q((<span class="keyword">int64_t</span>)pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line">        log_packet(ofmt_ctx, &amp;pkt, <span class="string">"out"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">        ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error muxing packet\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        av_free_packet(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(dts_start_from);</span><br><span class="line">    <span class="built_in">free</span>(pts_start_from);</span><br><span class="line">    </span><br><span class="line">    av_write_trailer(ofmt_ctx);</span><br><span class="line">    </span><br><span class="line">end:</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* close output */</span></span><br><span class="line">    <span class="keyword">if</span> (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">        avio_closep(&amp;ofmt_ctx-&gt;pb);</span><br><span class="line">    avformat_free_context(ofmt_ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error occurred: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: \</span></span><br><span class="line"><span class="string">                command startime, endtime, srcfile, outfile"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> startime = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">double</span> endtime = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    cut_video(startime, endtime, argv[<span class="number">3</span>], argv[<span class="number">4</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="3-10-实战-一个简单的小咖秀"><a href="#3-10-实战-一个简单的小咖秀" class="headerlink" title="3.10 [实战] 一个简单的小咖秀"></a>3.10 [实战] 一个简单的小咖秀</h3><ul><li><p>将两个媒体文件中分别抽取音频与视频轨</p></li><li><p>将音频与视频轨合并成一个新文件</p></li><li><p>对音频与视频轨进行裁剪</p><h2 id="4-FFmpeg-中级开发内容"><a href="#4-FFmpeg-中级开发内容" class="headerlink" title="4. FFmpeg 中级开发内容"></a>4. FFmpeg 中级开发内容</h2></li><li><p>FFmpeg H264 解码</p></li><li><p>FFmpeg H264 编码</p></li><li><p>FFmpeg AAC 解码</p></li><li><p>FFmpeg AAC 编码</p></li></ul><h3 id="4-1-FFmpeg-H264-解码"><a href="#4-1-FFmpeg-H264-解码" class="headerlink" title="4.1 FFmpeg H264 解码"></a>4.1 FFmpeg H264 解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>常用数据结构：</p><ul><li><p>AVCodec 编码器结构体</p></li><li><p>AVCodecContext 编码器上下文</p></li><li><p>AVFrame 解码后的帧</p><p>结构体内存的分配与释放：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_frame_alloc / av_frame_free();</span><br><span class="line">avcodec_alloc_context3();</span><br><span class="line">avcodec_free_context();</span><br></pre></td></tr></table></figure><p>解码步骤：</p><ul><li>查找解码器（avcodec_find_decoder）</li><li>打开解码器（avcodec_open2）</li><li>解码（avcodec_decode_video2）</li></ul><h3 id="4-2-FFmpeg-H264-编码"><a href="#4-2-FFmpeg-H264-编码" class="headerlink" title="4.2 FFmpeg H264 编码"></a>4.2 FFmpeg H264 编码</h3><p>H264编码流程：</p><ul><li>查找编码器（avcodec_find_encoder_by_name）</li><li>设置参数，打开编码器（avcondec_open2）</li><li>编码（avcondec_encode_video2）</li></ul><h3 id="4-3-视频转图片"><a href="#4-3-视频转图片" class="headerlink" title="4.3 视频转图片"></a>4.3 视频转图片</h3><p>TODO</p><h3 id="4-4-FFmpeg-AAC-编码"><a href="#4-4-FFmpeg-AAC-编码" class="headerlink" title="4.4 FFmpeg AAC 编码"></a>4.4 FFmpeg AAC 编码</h3><ul><li>编码流程与视频相同</li><li>编码函数 avcodec_encodec_audio2</li></ul><h2 id="5-SDL-介绍"><a href="#5-SDL-介绍" class="headerlink" title="5. SDL 介绍"></a>5. SDL 介绍</h2><blockquote><p><a href="[http://www.libsdl.org](http://www.libsdl.org/)">SDL 官网</a></p></blockquote><ul><li>SDL（Simple DirectMedia Layer） 是一套<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTk2JThCJUU2JTk0JUJFJUU1JThFJTlGJUU1JUE3JThCJUU3JUEyJUJD" title="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%8E%9F%E5%A7%8B%E7%A2%BC">开放源代码<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUE4JUU1JUI5JUIzJUU1JThGJUIw" title="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JTlBJUU1JUFBJTkyJUU5JUFCJTk0" title="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E9%AB%94">多媒体<i class="fa fa-external-link"></i></span>开发<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg3JUJEJUU1JUJDJThGJUU1JUJBJUFC" title="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">库<i class="fa fa-external-link"></i></span></li><li>由 C 语言实现的跨平台的媒体开源库</li><li>多用于开发游戏、模拟器、媒体播放器等多媒体应用领域</li></ul><p>语法与子系统：</p><p>SDL将功能分成下列数个子系统（subsystem）：</p><ul><li><strong>Video（图像）</strong>—图像控制以及线程（thread）和事件管理（event）。</li><li><strong>Audio（声音）</strong>—声音控制</li><li><strong>Joystick（摇杆）</strong>—游戏摇杆控制</li><li><strong>CD-ROM（光盘驱动器）</strong>—光盘媒体控制</li><li><strong>Window Management（视窗管理）</strong>－与视窗程序设计集成</li><li><strong>Event（事件驱动）</strong>－处理事件驱动</li></ul><p>以下是一支用C语言写成、非常简单的SDL示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Headers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SDL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize SDL</span></span><br><span class="line">    <span class="keyword">if</span>(SDL_Init(SDL_INIT_EVERYTHING) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delay 2 seconds</span></span><br><span class="line">    SDL_Delay(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Quit SDL</span></span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序会加载所有SDL子系统（出错则退出程序），然后暂停两秒，最后关闭SDL并退出程序。</p><h3 id="5-1-SDL-编译与安装"><a href="#5-1-SDL-编译与安装" class="headerlink" title="5.1 SDL 编译与安装"></a>5.1 SDL 编译与安装</h3><ul><li>下载 SDL 源码</li><li>生成Makefile configure –prefix=/usr/local</li><li>安装 sudo make -j 8 &amp;&amp; make install</li></ul><h3 id="5-2-使用-SDL-基本步骤"><a href="#5-2-使用-SDL-基本步骤" class="headerlink" title="5.2 使用 SDL 基本步骤"></a>5.2 使用 SDL 基本步骤</h3><ul><li>添加头文件 #include &lt;SDL.h&gt;</li><li>初始化 SDL</li><li>退出 SDL</li></ul><p>SDL 渲染窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_Init() / SDL_Quit();</span><br><span class="line">SDL_CreateWindow() / SDL_DestoryWindow();</span><br><span class="line">SDL_CreateRender();  <span class="comment">// 创建渲染器</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o first_sdl first_sdl.c `pkg-config --libs sdl2`</span></span><br></pre></td></tr></table></figure><p>SDL 渲染窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateRender() / SDL_DestoryRenderer();</span><br><span class="line">SDL_RenderClear();</span><br><span class="line">SDL_RenderPresent();</span><br></pre></td></tr></table></figure><h3 id="5-3-SDL-事件基本原理"><a href="#5-3-SDL-事件基本原理" class="headerlink" title="5.3 SDL 事件基本原理"></a>5.3 SDL 事件基本原理</h3><ul><li>SDL 将所有的事件都存放在一个队列中</li><li>所有对事件的操作，其实就是队列的操作</li></ul><p>SDL 事件种类：</p><ul><li>SDL_WindowEvent：窗口事件</li><li>SDL_KeyboardEvent：键盘事件</li><li>SDL_MouseMotionEvent：鼠标事件</li><li>自定义事件</li></ul><p>SDL 事件处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_PollEvent(); <span class="comment">// 轮询检测</span></span><br><span class="line">SDL_WaitEvent(); <span class="comment">// 常用的方式</span></span><br><span class="line">SDL_WaitEventTimeout();</span><br></pre></td></tr></table></figure><h3 id="5-4-文理渲染"><a href="#5-4-文理渲染" class="headerlink" title="5.4 文理渲染"></a>5.4 文理渲染</h3><p>SDL 渲染基本原理：</p><img src="/images/imageFFmpeg/SDL渲染基本原理.png"><p>SDL 文理相关 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateTexture();</span><br><span class="line">- format: YUV, RGB</span><br><span class="line">- access: Texture 类型， Target， Stream</span><br><span class="line"></span><br><span class="line">SDL_DestroyTexture();</span><br></pre></td></tr></table></figure><p>SDL 渲染相关 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_SetRenderTarget();</span><br><span class="line">SDL_RenderClear();</span><br><span class="line">SDL_RenderCopy();</span><br><span class="line">SDL_RenderPresent();</span><br></pre></td></tr></table></figure><h3 id="5-5-实战-YUV-视频播放器"><a href="#5-5-实战-YUV-视频播放器" class="headerlink" title="5.5 [实战] YUV 视频播放器"></a>5.5 [实战] YUV 视频播放器</h3><p>创建线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateThread();</span><br><span class="line">- fn: 线程执行函数</span><br><span class="line">- name: 线程名</span><br><span class="line">- data: 执行函数参数</span><br></pre></td></tr></table></figure><p>SDL 更新文理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_UpdateTexture();</span><br><span class="line">SDL_UpdateYUVTexture();</span><br></pre></td></tr></table></figure><h3 id="5-6-SDL-播放音频"><a href="#5-6-SDL-播放音频" class="headerlink" title="5.6 SDL 播放音频"></a>5.6 SDL 播放音频</h3><p>播放音频基本流程：</p><img src="/images/imageFFmpeg/播放音频基本流程.png"><p>播放音频的基本原则：</p><ul><li>声卡向你要数据而不是你主动推给声卡</li><li>数据的多少由音频参数决定的</li></ul><p>SDL 音频 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_OpenAudio() / SDL_CloseAudio();</span><br><span class="line">SDL_PauseAudio();</span><br><span class="line">SDL_MixAudio();</span><br></pre></td></tr></table></figure><h3 id="5-7-实现-PCM-播放器"><a href="#5-7-实现-PCM-播放器" class="headerlink" title="5.7 实现 PCM 播放器"></a>5.7 实现 PCM 播放器</h3><p>TODO</p><h2 id="6-最简单的播放器"><a href="#6-最简单的播放器" class="headerlink" title="6. 最简单的播放器"></a>6. 最简单的播放器</h2><ul><li>该播放器只实现视频播放</li><li>将 FFmpeg 与 SDL 结合到一起</li><li>通过 FFmpeg 解码视频数据</li><li>通过 SDL 进行渲染</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o player2 player2.c `pkg-config --cflags --libs sdl2 libavformat libavutil libswscale libavcodec libswresample`</span></span><br></pre></td></tr></table></figure><p>最简单的播放器之二：</p><ul><li>可以同时播放音频与视频</li><li>使用队列存放音频包</li></ul><h3 id="6-1-多线程与锁"><a href="#6-1-多线程与锁" class="headerlink" title="6.1 多线程与锁"></a>6.1 多线程与锁</h3><p>为什么要用多线程：</p><ul><li>多线程的好处</li><li>多线程带来的问题</li></ul><p>线程的互斥与同步：</p><ul><li><p>互斥</p></li><li><p>同步</p><p>大的任务分为很多小任务通过信号协调</p></li></ul><p>锁与信号量：</p><ul><li>锁的种类</li><li>通过信号进行同步</li></ul><p>锁的中种类：</p><ul><li>读写锁</li><li>自旋锁</li><li>可重入锁</li></ul><p>SDL 线程的创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateThread();</span><br><span class="line">SDL_WaitThread();</span><br></pre></td></tr></table></figure><p>SDL 锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateMutex() / SDL_DestroyMutex();  <span class="comment">// 创建互斥量</span></span><br><span class="line">SDL_LockMutex() / SDL_UnlockMutex(); <span class="comment">// 锁互斥量于解锁互斥量</span></span><br></pre></td></tr></table></figure><p>SDL 条件变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateCond() / SDL_DestroyCond();</span><br><span class="line">SDL_CondWait() / SDL_CondSignal();</span><br></pre></td></tr></table></figure><h3 id="6-2-锁与条件变量的使用"><a href="#6-2-锁与条件变量的使用" class="headerlink" title="6.2 锁与条件变量的使用"></a>6.2 锁与条件变量的使用</h3><p>TODO</p><h3 id="6-3-播放器线程模型"><a href="#6-3-播放器线程模型" class="headerlink" title="6.3 播放器线程模型"></a>6.3 播放器线程模型</h3><img src="/images/imageFFmpeg/播放器线程模型.png"><h3 id="6-4-线程的退出机制"><a href="#6-4-线程的退出机制" class="headerlink" title="6.4 线程的退出机制"></a>6.4 线程的退出机制</h3><ul><li>主线程接收到退出事件</li><li>解复用线程在循环分流时对 quit 进行判断</li><li>视频解码线程从视频流队列中取包时对 quit 进行判断</li><li>音视解码从音频流队列中取包时对 quit 进行判断</li><li>音视循环解码时对 quit 进行判断</li><li>在收到信号变量消息时对 quit 进行判断</li></ul><h3 id="6-5-音视频同步"><a href="#6-5-音视频同步" class="headerlink" title="6.5 音视频同步"></a>6.5 音视频同步</h3><p>时间戳：</p><ul><li>PTS：Presentation timestamp  渲染时间戳</li><li>DTS：Decoding timestamp 解码时间戳</li><li>I（intra）/ B（bidirectional）/ P（predicted）帧</li></ul><p>时间戳顺序：</p><ul><li>实际帧顺序：I B B P</li><li>存放帧顺序：I P B B</li><li>解码时间戳：1 4 2 3</li><li>展示时间戳：1 2 3 4</li></ul><p>由于有了 B 帧之后，它打乱了 PTS 时间戳，所以加了 DTS 解码时间戳。在大多数没有 B 帧的情况下 PTS 和 DTS 是一致的。</p><p>从哪儿获得 PTS：</p><ul><li>AVPacket 中的 PTS</li><li>AVFrame 中的 PTS</li><li>av_frame_get_best_effort_timestamp()</li></ul><p>时间基：</p><ul><li>tbr：帧率</li><li>tbn：time base of stream 流的时间基</li><li>tbc：time base of codec 解码的时间基</li></ul><p>计算当前帧的 PTS：</p><ul><li><code>PTS = PTS * av_q2d(video_stream-&gt;time_base)</code></li><li><code>av_q2d(AVRotional a){ return a.num / (double)a.den; }</code></li></ul><p>计算下一帧的 PTS：</p><ul><li>video_clock：预测的下一帧视频的 PTS</li><li>frame_delay：1/tbr</li><li>audio_clock：音频当前播放的时间戳</li></ul><p>音视频同步的时候需要计算 audio_clock 和 video_clock，看视屏时间是在音频时间之前还是在音频时间之后，如果是在音频时间之前就立即播放，如果在音频时间之后需要 delay 一段时间播放（delay的时间计算：audio_clock  - video_clock）</p><p>音视频同步方式：</p><ul><li>视频同步到音频</li><li>音频同步到视频</li><li>音频和视频都同步到系统时钟  </li></ul><p>视频播放的基本思路：</p><ul><li>一般的做法，展示第一帧视频帧后，获得要显示的下一个视频帧的 PTS，然后设置一个定时器，当定时器超时时后，刷新新的视屏帧，如此反复操作。</li></ul><details><summary>最简单的播放器：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compatibility with newer API</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> av_frame_free avcodec_free_frame</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000 <span class="comment">//channels(2) * data_size(2) * sample_rate(48000)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_AUDIO_MASTER <span class="comment">//AV_SYNC_VIDEO_MASTER</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span></span><br><span class="line">AVPacketList *first_pkt, *last_pkt;</span><br><span class="line">    <span class="keyword">int</span> nb_packets;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    SDL_mutex *mutex;</span><br><span class="line">    SDL_cond *cond;</span><br><span class="line">&#125; PacketQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoPicture</span> &#123;</span></span><br><span class="line">    AVPicture *bmp;</span><br><span class="line">    <span class="keyword">int</span> width, height; <span class="comment">/* source height &amp; width */</span></span><br><span class="line">    <span class="keyword">int</span> allocated;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">&#125; VideoPicture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoState</span> &#123;</span></span><br><span class="line">    <span class="comment">//multi-media file</span></span><br><span class="line">    <span class="keyword">char</span>            filename[<span class="number">1024</span>];</span><br><span class="line">    AVFormatContext *pFormatCtx;</span><br><span class="line">    <span class="keyword">int</span>             videoStream, audioStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sync</span></span><br><span class="line">    <span class="keyword">int</span>             av_sync_type;</span><br><span class="line">    <span class="keyword">double</span>          external_clock; <span class="comment">/* external clock base */</span></span><br><span class="line">    <span class="keyword">int64_t</span>         external_clock_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>          audio_diff_cum; <span class="comment">/* used for AV difference average computation */</span></span><br><span class="line">    <span class="keyword">double</span>          audio_diff_avg_coef;</span><br><span class="line">    <span class="keyword">double</span>          audio_diff_threshold;</span><br><span class="line">    <span class="keyword">int</span>             audio_diff_avg_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>          audio_clock;</span><br><span class="line">    <span class="keyword">double</span>          frame_timer;</span><br><span class="line">    <span class="keyword">double</span>          frame_last_pts;</span><br><span class="line">    <span class="keyword">double</span>          frame_last_delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>          video_clock; <span class="comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span></span><br><span class="line">    <span class="keyword">double</span>          video_current_pts; <span class="comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span></span><br><span class="line">    <span class="keyword">int64_t</span>         video_current_pts_time;  <span class="comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//audio</span></span><br><span class="line">    AVStream        *audio_st;</span><br><span class="line">    AVCodecContext  *audio_ctx;</span><br><span class="line">    PacketQueue     audioq;</span><br><span class="line">    <span class="keyword">uint8_t</span>         audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="number">3</span>) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    audio_buf_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    audio_buf_index;</span><br><span class="line">    AVFrame         audio_frame;</span><br><span class="line">    AVPacket        audio_pkt;</span><br><span class="line">    <span class="keyword">uint8_t</span>         *audio_pkt_data;</span><br><span class="line">    <span class="keyword">int</span>             audio_pkt_size;</span><br><span class="line">    <span class="keyword">int</span>             audio_hw_buf_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//video</span></span><br><span class="line">    AVStream        *video_st;</span><br><span class="line">    AVCodecContext  *video_ctx;</span><br><span class="line">    PacketQueue     videoq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">video_sws_ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_swr_ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];</span><br><span class="line">    <span class="keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;</span><br><span class="line">    SDL_mutex       *pictq_mutex;</span><br><span class="line">    SDL_cond        *pictq_cond;</span><br><span class="line"></span><br><span class="line">    SDL_Thread      *parse_tid;</span><br><span class="line">    SDL_Thread      *video_tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>             quit;</span><br><span class="line">&#125; VideoState;</span><br><span class="line"></span><br><span class="line">SDL_mutex    *text_mutex;</span><br><span class="line">SDL_Window   *win = <span class="literal">NULL</span>;</span><br><span class="line">SDL_Renderer *renderer;</span><br><span class="line">SDL_Texture  *texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    AV_SYNC_AUDIO_MASTER,</span><br><span class="line">    AV_SYNC_VIDEO_MASTER,</span><br><span class="line">    AV_SYNC_EXTERNAL_MASTER,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE *yuvfd = <span class="literal">NULL</span>;</span><br><span class="line">FILE *audiofd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Since we only have one decoding thread, the Big Struct</span></span><br><span class="line"><span class="comment">   can be global in case we need it. */</span></span><br><span class="line">VideoState *global_video_state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_queue_init</span><span class="params">(PacketQueue *q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span>(PacketQueue));</span><br><span class="line">    q-&gt;mutex = SDL_CreateMutex();</span><br><span class="line">    q-&gt;cond = SDL_CreateCond();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">packet_queue_put</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span> </span>&#123;</span><br><span class="line">    AVPacketList *pkt1;</span><br><span class="line">    <span class="keyword">if</span>(av_dup_packet(pkt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pkt1 = av_malloc(<span class="keyword">sizeof</span>(AVPacketList));</span><br><span class="line">    <span class="keyword">if</span> (!pkt1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pkt1-&gt;pkt = *pkt;</span><br><span class="line">    pkt1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    SDL_LockMutex(q-&gt;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;last_pkt)</span><br><span class="line">        q-&gt;first_pkt = pkt1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q-&gt;last_pkt-&gt;next = pkt1;</span><br><span class="line">    q-&gt;last_pkt = pkt1;</span><br><span class="line">    q-&gt;nb_packets++;</span><br><span class="line">    q-&gt;size += pkt1-&gt;pkt.size;</span><br><span class="line">    </span><br><span class="line">    SDL_CondSignal(q-&gt;cond);</span><br><span class="line">    SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVPacketList *pkt1;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    SDL_LockMutex(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(global_video_state-&gt;quit) &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt1 = q-&gt;first_pkt;</span><br><span class="line">        <span class="keyword">if</span> (pkt1) &#123;</span><br><span class="line">            q-&gt;first_pkt = pkt1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!q-&gt;first_pkt)</span><br><span class="line">                q-&gt;last_pkt = <span class="literal">NULL</span>;</span><br><span class="line">            q-&gt;nb_packets--;</span><br><span class="line">            q-&gt;size -= pkt1-&gt;pkt.size;</span><br><span class="line">            *pkt = pkt1-&gt;pkt;</span><br><span class="line">            av_free(pkt1);</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SDL_CondWait(q-&gt;cond, q-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_audio_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">    <span class="keyword">int</span> hw_buf_size, bytes_per_sec, n;</span><br><span class="line"></span><br><span class="line">    pts = is-&gt;audio_clock; <span class="comment">/* maintained in the audio thread */</span></span><br><span class="line">    hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">    bytes_per_sec = <span class="number">0</span>;</span><br><span class="line">    n = is-&gt;audio_ctx-&gt;channels * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;audio_st) &#123;</span><br><span class="line">        bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bytes_per_sec) &#123;</span><br><span class="line">        pts -= (<span class="keyword">double</span>)hw_buf_size / bytes_per_sec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_video_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> delta;</span><br><span class="line">    delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="keyword">return</span> is-&gt;video_current_pts + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_external_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_master_clock</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> get_video_clock(is);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> get_audio_clock(is);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get_external_clock(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add or subtract samples to get a better sync, return new</span></span><br><span class="line"><span class="comment">   audio buffer size */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">synchronize_audio</span><span class="params">(VideoState *is, <span class="keyword">short</span> *samples,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> samples_size, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> ref_clock;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">        <span class="keyword">double</span> diff, avg_diff;</span><br><span class="line">        <span class="keyword">int</span> wanted_size, min_size, max_size <span class="comment">/*, nb_samples */</span>;</span><br><span class="line"></span><br><span class="line">        ref_clock = get_master_clock(is);</span><br><span class="line">        diff = get_audio_clock(is) - ref_clock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// accumulate the diffs</span></span><br><span class="line">            is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef</span><br><span class="line">                * is-&gt;audio_diff_cum;</span><br><span class="line">            <span class="keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) &#123;</span><br><span class="line">                is-&gt;audio_diff_avg_count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                avg_diff = is-&gt;audio_diff_cum * (<span class="number">1.0</span> - is-&gt;audio_diff_avg_coef);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123;</span><br><span class="line">                    wanted_size = samples_size + ((<span class="keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);</span><br><span class="line">                    min_size = samples_size * ((<span class="number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>);</span><br><span class="line">                    max_size = samples_size * ((<span class="number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">if</span>(wanted_size &lt; min_size) &#123;</span><br><span class="line">                        wanted_size = min_size;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wanted_size &gt; max_size) &#123;</span><br><span class="line">                        wanted_size = max_size;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(wanted_size &lt; samples_size) &#123;</span><br><span class="line">                        <span class="comment">/* remove samples */</span></span><br><span class="line">                        samples_size = wanted_size;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wanted_size &gt; samples_size) &#123;</span><br><span class="line">                        <span class="keyword">uint8_t</span> *samples_end, *q;</span><br><span class="line">                        <span class="keyword">int</span> nb;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* add samples by copying final sample*/</span></span><br><span class="line">                        nb = (samples_size - wanted_size);</span><br><span class="line">                        samples_end = (<span class="keyword">uint8_t</span> *)samples + samples_size - n;</span><br><span class="line">                        q = samples_end + n;</span><br><span class="line">                        <span class="keyword">while</span>(nb &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">memcpy</span>(q, samples_end, n);</span><br><span class="line">                            q += n;</span><br><span class="line">                            nb -= n;</span><br><span class="line">                        &#125;</span><br><span class="line">                        samples_size = wanted_size;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* difference is TOO big; reset diff stuff */</span></span><br><span class="line">            is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">            is-&gt;audio_diff_cum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> samples_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">audio_decode_frame</span><span class="params">(VideoState *is, <span class="keyword">uint8_t</span> *audio_buf, </span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> buf_size, <span class="keyword">double</span> *pts_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1, data_size = <span class="number">0</span>;</span><br><span class="line">    AVPacket *pkt = &amp;is-&gt;audio_pkt;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">            len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);</span><br><span class="line">            <span class="keyword">if</span>(len1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* if error, skip frame */</span></span><br><span class="line">                is-&gt;audio_pkt_size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data_size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(got_frame) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">data_size = av_samples_get_buffer_size(NULL, </span></span><br><span class="line"><span class="comment">       is-&gt;audio_ctx-&gt;channels,</span></span><br><span class="line"><span class="comment">       is-&gt;audio_frame.nb_samples,</span></span><br><span class="line"><span class="comment">       is-&gt;audio_ctx-&gt;sample_fmt,</span></span><br><span class="line"><span class="comment">       1);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">                data_size = <span class="number">2</span> * is-&gt;audio_frame.nb_samples * <span class="number">2</span>;</span><br><span class="line">                assert(data_size &lt;= buf_size);</span><br><span class="line"></span><br><span class="line">                swr_convert(is-&gt;audio_swr_ctx,</span><br><span class="line">                            &amp;audio_buf,</span><br><span class="line">                            MAX_AUDIO_FRAME_SIZE*<span class="number">3</span>/<span class="number">2</span>,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)is-&gt;audio_frame.data,</span><br><span class="line">                            is-&gt;audio_frame.nb_samples);</span><br><span class="line"></span><br><span class="line">                fwrite(audio_buf, <span class="number">1</span>, data_size, audiofd);</span><br><span class="line">                <span class="comment">//memcpy(audio_buf, is-&gt;audio_frame.data[0], data_size);</span></span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_pkt_data += len1;</span><br><span class="line">            is-&gt;audio_pkt_size -= len1;</span><br><span class="line">            <span class="keyword">if</span>(data_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* No data yet, get more frames */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pts = is-&gt;audio_clock;</span><br><span class="line">            *pts_ptr = pts;</span><br><span class="line">            n = <span class="number">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class="line">            is-&gt;audio_clock += (<span class="keyword">double</span>)data_size /</span><br><span class="line">                (<span class="keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class="line">            <span class="comment">/* We have data, return it and come back for more later */</span></span><br><span class="line">            <span class="keyword">return</span> data_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pkt-&gt;data)</span><br><span class="line">            av_free_packet(pkt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* next packet */</span></span><br><span class="line">        <span class="keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        is-&gt;audio_pkt_data = pkt-&gt;data;</span><br><span class="line">        is-&gt;audio_pkt_size = pkt-&gt;size;</span><br><span class="line">        <span class="comment">/* if update, update the audio clock w/pts */</span></span><br><span class="line">        <span class="keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">audio_callback</span><span class="params">(<span class="keyword">void</span> *userdata, Uint8 *stream, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *)userdata;</span><br><span class="line">    <span class="keyword">int</span> len1, audio_size;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">            <span class="comment">/* We have already sent all our data; get more */</span></span><br><span class="line">            audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);</span><br><span class="line">            <span class="keyword">if</span>(audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* If error, output silence */</span></span><br><span class="line">                is-&gt;audio_buf_size = <span class="number">1024</span> * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">memset</span>(is-&gt;audio_buf, <span class="number">0</span>, is-&gt;audio_buf_size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                audio_size = synchronize_audio(is, (<span class="keyword">int16_t</span> *)is-&gt;audio_buf, audio_size, pts);</span><br><span class="line">                is-&gt;audio_buf_size = audio_size;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len)</span><br><span class="line">            len1 = len;</span><br><span class="line">        SDL_MixAudio(stream,(<span class="keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME);</span><br><span class="line">        <span class="comment">//memcpy(stream, (uint8_t *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span></span><br><span class="line">        len -= len1;</span><br><span class="line">        stream += len1;</span><br><span class="line">        is-&gt;audio_buf_index += len1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Uint32 <span class="title">sdl_refresh_timer_cb</span><span class="params">(Uint32 interval, <span class="keyword">void</span> *opaque)</span> </span>&#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    event.type = FF_REFRESH_EVENT;</span><br><span class="line">    event.user.data1 = opaque;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 0 means stop timer */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* schedule a video refresh in 'delay' ms */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_refresh</span><span class="params">(VideoState *is, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">    SDL_AddTimer(delay, sdl_refresh_timer_cb, is);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">video_display</span><span class="params">(VideoState *is)</span> </span>&#123;</span><br><span class="line">    SDL_Rect rect;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    <span class="keyword">float</span> aspect_ratio;</span><br><span class="line">    <span class="keyword">int</span> w, h, x, y;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line">    <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line"></span><br><span class="line">        SDL_UpdateYUVTexture(texture, <span class="literal">NULL</span>, </span><br><span class="line">                             vp-&gt;bmp-&gt;data[<span class="number">0</span>], vp-&gt;bmp-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                             vp-&gt;bmp-&gt;data[<span class="number">1</span>], vp-&gt;bmp-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                             vp-&gt;bmp-&gt;data[<span class="number">2</span>], vp-&gt;bmp-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        rect.x = <span class="number">0</span>;</span><br><span class="line">        rect.y = <span class="number">0</span>;</span><br><span class="line">        rect.w = is-&gt;video_ctx-&gt;width;</span><br><span class="line">        rect.h = is-&gt;video_ctx-&gt;height;</span><br><span class="line">        SDL_LockMutex(text_mutex);</span><br><span class="line">        SDL_RenderClear( renderer );</span><br><span class="line">        SDL_RenderCopy( renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">        SDL_RenderPresent( renderer );</span><br><span class="line">        SDL_UnlockMutex(text_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">video_refresh_timer</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *)userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    <span class="keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;video_st) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;pictq_size == <span class="number">0</span>) &#123;</span><br><span class="line">            schedule_refresh(is, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//fprintf(stderr, "no picture in the queue!!!\n");</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//fprintf(stderr, "get picture from queue!!!\n");</span></span><br><span class="line">            vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line"></span><br><span class="line">            is-&gt;video_current_pts = vp-&gt;pts;</span><br><span class="line">            is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line">            delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="comment">/* the pts from last time */</span></span><br><span class="line">            <span class="keyword">if</span>(delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="comment">/* if incorrect delay, use previous one */</span></span><br><span class="line">                delay = is-&gt;frame_last_delay;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* save for next time */</span></span><br><span class="line">            is-&gt;frame_last_delay = delay;</span><br><span class="line">            is-&gt;frame_last_pts = vp-&gt;pts;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update delay to sync to audio if not master source */</span></span><br><span class="line">            <span class="keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">                ref_clock = get_master_clock(is);</span><br><span class="line">                diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Skip or repeat the frame. Take delay into account</span></span><br><span class="line"><span class="comment">       FFPlay still doesn't "know if this is the best guess." */</span></span><br><span class="line">                sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(diff &lt;= -sync_threshold) &#123;</span><br><span class="line">                        delay = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(diff &gt;= sync_threshold) &#123;</span><br><span class="line">                        delay = <span class="number">2</span> * delay;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;frame_timer += delay;</span><br><span class="line">            <span class="comment">/* computer the REAL delay */</span></span><br><span class="line">            actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line">            <span class="keyword">if</span>(actual_delay &lt; <span class="number">0.010</span>) &#123;</span><br><span class="line">                <span class="comment">/* Really it should skip the picture instead */</span></span><br><span class="line">                actual_delay = <span class="number">0.010</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            schedule_refresh(is, (<span class="keyword">int</span>)(actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* show the picture! */</span></span><br><span class="line">            video_display(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update queue for next picture! */</span></span><br><span class="line">            <span class="keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">                is-&gt;pictq_rindex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">            is-&gt;pictq_size--;</span><br><span class="line">            SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">            SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        schedule_refresh(is, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc_picture</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *)userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line"></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line">    <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line">        <span class="comment">// we already have one make another, bigger/smaller</span></span><br><span class="line">        avpicture_free(vp-&gt;bmp);</span><br><span class="line">        <span class="built_in">free</span>(vp-&gt;bmp);</span><br><span class="line">        vp-&gt;bmp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a place to put our YUV image on that screen</span></span><br><span class="line">    SDL_LockMutex(text_mutex);</span><br><span class="line"></span><br><span class="line">    vp-&gt;bmp = (AVPicture*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVPicture));</span><br><span class="line">    ret = avpicture_alloc(vp-&gt;bmp, AV_PIX_FMT_YUV420P, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate temporary picture: %s\n"</span>, av_err2str(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_UnlockMutex(text_mutex);</span><br><span class="line"></span><br><span class="line">    vp-&gt;width = is-&gt;video_ctx-&gt;width;</span><br><span class="line">    vp-&gt;height = is-&gt;video_ctx-&gt;height;</span><br><span class="line">    vp-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_picture</span><span class="params">(VideoState *is, AVFrame *pFrame, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until we have space for a new pic */</span></span><br><span class="line">    SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    <span class="keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;</span><br><span class="line">          !is-&gt;quit) &#123;</span><br><span class="line">        SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;quit)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// windex is set to 0 initially</span></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate or resize the buffer! */</span></span><br><span class="line">    <span class="keyword">if</span>(!vp-&gt;bmp ||</span><br><span class="line">       vp-&gt;width != is-&gt;video_ctx-&gt;width ||</span><br><span class="line">       vp-&gt;height != is-&gt;video_ctx-&gt;height) &#123;</span><br><span class="line"></span><br><span class="line">        vp-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">        alloc_picture(is);</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have a place to put our picture on the queue */</span></span><br><span class="line">    <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line">        vp-&gt;pts = pts;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert the image into YUV format that SDL uses</span></span><br><span class="line">        sws_scale(is-&gt;video_sws_ctx, (<span class="keyword">uint8_t</span> <span class="keyword">const</span> * <span class="keyword">const</span> *)pFrame-&gt;data,</span><br><span class="line">                  pFrame-&gt;linesize, <span class="number">0</span>, is-&gt;video_ctx-&gt;height,</span><br><span class="line">                  vp-&gt;bmp-&gt;data, vp-&gt;bmp-&gt;linesize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* now we inform our display thread that we have a pic ready */</span></span><br><span class="line">        <span class="keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">            is-&gt;pictq_windex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        is-&gt;pictq_size++;</span><br><span class="line">        SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">synchronize_video</span><span class="params">(VideoState *is, AVFrame *src_frame, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> frame_delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pts != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* if we have pts, set video clock to it */</span></span><br><span class="line">        is-&gt;video_clock = pts;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* if we aren't given a pts, set it to the clock */</span></span><br><span class="line">        pts = is-&gt;video_clock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* update the video clock */</span></span><br><span class="line">    frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);</span><br><span class="line">    <span class="comment">/* if we are repeating a frame, adjust clock accordingly */</span></span><br><span class="line">    frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="number">0.5</span>);</span><br><span class="line">    is-&gt;video_clock += frame_delay;</span><br><span class="line">    <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode_video_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *)arg;</span><br><span class="line">    AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line">    <span class="keyword">int</span> frameFinished;</span><br><span class="line">    AVFrame *pFrame;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// means we quit getting packets</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decode video frame</span></span><br><span class="line">        avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) != AV_NOPTS_VALUE) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Did we get a video frame?</span></span><br><span class="line">        <span class="keyword">if</span>(frameFinished) &#123;</span><br><span class="line">            pts = synchronize_video(is, pFrame, pts);</span><br><span class="line">            <span class="keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stream_component_open</span><span class="params">(VideoState *is, <span class="keyword">int</span> stream_index)</span> </span>&#123;</span><br><span class="line">    AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;</span><br><span class="line">    AVCodecContext *codecCtx = <span class="literal">NULL</span>;</span><br><span class="line">    AVCodec *codec = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_AudioSpec wanted_spec, spec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stream_index &lt; <span class="number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codecCtx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = avcodec_parameters_to_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codecpar);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span>(!codec) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unsupported codec!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">        <span class="comment">// Set audio settings from codec info</span></span><br><span class="line">        wanted_spec.freq = codecCtx-&gt;sample_rate;</span><br><span class="line">        wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">        wanted_spec.channels = <span class="number">2</span>;<span class="comment">//codecCtx-&gt;channels;</span></span><br><span class="line">        wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">        wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</span><br><span class="line">        wanted_spec.callback = audio_callback;</span><br><span class="line">        wanted_spec.userdata = is;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"wanted spec: channels:%d, sample_fmt:%d, sample_rate:%d \n"</span>,</span><br><span class="line">                <span class="number">2</span>, AUDIO_S16SYS, codecCtx-&gt;sample_rate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        is-&gt;audio_hw_buf_size = spec.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unsupported codec!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(codecCtx-&gt;codec_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            is-&gt;audioStream = stream_index;</span><br><span class="line">            is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">            is-&gt;audio_ctx = codecCtx;</span><br><span class="line">            is-&gt;audio_buf_size = <span class="number">0</span>;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="number">0</span>, <span class="keyword">sizeof</span>(is-&gt;audio_pkt));</span><br><span class="line">            packet_queue_init(&amp;is-&gt;audioq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Out Audio Param</span></span><br><span class="line">            <span class="keyword">uint64_t</span> out_channel_layout=AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//AAC:1024  MP3:1152</span></span><br><span class="line">            <span class="keyword">int</span> out_nb_samples= is-&gt;audio_ctx-&gt;frame_size;</span><br><span class="line">            <span class="comment">//AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> out_sample_rate=is-&gt;audio_ctx-&gt;sample_rate;</span><br><span class="line">            <span class="keyword">int</span> out_channels=av_get_channel_layout_nb_channels(out_channel_layout);</span><br><span class="line">            <span class="comment">//Out Buffer Size</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int out_buffer_size=av_samples_get_buffer_size(NULL,</span></span><br><span class="line"><span class="comment">                                                   out_channels,</span></span><br><span class="line"><span class="comment">                                                   out_nb_samples,</span></span><br><span class="line"><span class="comment">                                                   AV_SAMPLE_FMT_S16,</span></span><br><span class="line"><span class="comment">                                                   1);</span></span><br><span class="line"><span class="comment">                                                   */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//uint8_t *out_buffer=(uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE*2);</span></span><br><span class="line">            <span class="keyword">int64_t</span> in_channel_layout=av_get_default_channel_layout(is-&gt;audio_ctx-&gt;channels);</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_convert_ctx</span>;</span></span><br><span class="line">            audio_convert_ctx = swr_alloc();</span><br><span class="line">            swr_alloc_set_opts(audio_convert_ctx,</span><br><span class="line">                               out_channel_layout,</span><br><span class="line">                               AV_SAMPLE_FMT_S16,</span><br><span class="line">                               out_sample_rate,</span><br><span class="line">                               in_channel_layout,</span><br><span class="line">                               is-&gt;audio_ctx-&gt;sample_fmt,</span><br><span class="line">                               is-&gt;audio_ctx-&gt;sample_rate,</span><br><span class="line">                               <span class="number">0</span>,</span><br><span class="line">                               <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"swr opts: out_channel_layout:%lld, out_sample_fmt:%d, out_sample_rate:%d, in_channel_layout:%lld, in_sample_fmt:%d, in_sample_rate:%d"</span>,</span><br><span class="line">                    out_channel_layout, </span><br><span class="line">                    AV_SAMPLE_FMT_S16, </span><br><span class="line">                    out_sample_rate, </span><br><span class="line">                    in_channel_layout, </span><br><span class="line">                    is-&gt;audio_ctx-&gt;sample_fmt, </span><br><span class="line">                    is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class="line">            swr_init(audio_convert_ctx);</span><br><span class="line">            is-&gt;audio_swr_ctx = audio_convert_ctx;</span><br><span class="line"></span><br><span class="line">            SDL_PauseAudio(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            is-&gt;videoStream = stream_index;</span><br><span class="line">            is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">            is-&gt;video_ctx = codecCtx;</span><br><span class="line"></span><br><span class="line">            is-&gt;frame_timer = (<span class="keyword">double</span>)av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">            is-&gt;frame_last_delay = <span class="number">40e-3</span>;</span><br><span class="line">            is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line"></span><br><span class="line">            packet_queue_init(&amp;is-&gt;videoq);</span><br><span class="line">            is-&gt;video_sws_ctx = sws_getContext(</span><br><span class="line">                is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">                        is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,</span><br><span class="line">                        is-&gt;video_ctx-&gt;height, AV_PIX_FMT_YUV420P,</span><br><span class="line">                        SWS_BILINEAR, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            is-&gt;video_tid = SDL_CreateThread(decode_video_thread, <span class="string">"decode_video_thread"</span>, is);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">demux_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err_code;</span><br><span class="line">    <span class="keyword">char</span> errors[<span class="number">1024</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *)arg;</span><br><span class="line">    AVFormatContext *pFormatCtx;</span><br><span class="line">    AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> video_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> audio_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    is-&gt;videoStream=<span class="number">-1</span>;</span><br><span class="line">    is-&gt;audioStream=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    global_video_state = is;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open input file, and allocate format context */</span></span><br><span class="line">    <span class="keyword">if</span> ((err_code=avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_strerror(err_code, errors, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open source file %s, %d(%s)\n"</span>, is-&gt;filename, err_code, errors);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    is-&gt;pFormatCtx = pFormatCtx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve stream information</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Couldn't find stream information</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dump information about file onto standard error</span></span><br><span class="line">    av_dump_format(pFormatCtx, <span class="number">0</span>, is-&gt;filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the first video stream</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">           video_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            video_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">           audio_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            audio_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(audio_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, audio_index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(video_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, video_index);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;videoStream &lt; <span class="number">0</span> || is-&gt;audioStream &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: could not open codecs\n"</span>, is-&gt;filename);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//creat window from SDL</span></span><br><span class="line">    win = SDL_CreateWindow(<span class="string">"Media Player"</span>,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">                           SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);</span><br><span class="line">    <span class="keyword">if</span>(!win) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SDL: could not set video mode - exiting\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer = SDL_CreateRenderer(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IYUV: Y + U + V  (3 planes)</span></span><br><span class="line">    <span class="comment">//YV12: Y + V + U  (3 planes)</span></span><br><span class="line">    Uint32 pixformat= SDL_PIXELFORMAT_IYUV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create texture for render</span></span><br><span class="line">    texture = SDL_CreateTexture(renderer,</span><br><span class="line">                                pixformat,</span><br><span class="line">                                SDL_TEXTUREACCESS_STREAMING,</span><br><span class="line">                                is-&gt;video_ctx-&gt;width,</span><br><span class="line">                                is-&gt;video_ctx-&gt;height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main decode loop</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// seek stuff goes here</span></span><br><span class="line">        <span class="keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||</span><br><span class="line">           is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) &#123;</span><br><span class="line">            SDL_Delay(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="number">0</span>) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">100</span>); <span class="comment">/* no error; wait for user input */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Is this a packet from the video stream?</span></span><br><span class="line">        <span class="keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            av_free_packet(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* all done - wait for it */</span></span><br><span class="line">    <span class="keyword">while</span>(!is-&gt;quit) &#123;</span><br><span class="line">        SDL_Delay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        SDL_Event event;</span><br><span class="line">        event.type = FF_QUIT_EVENT;</span><br><span class="line">        event.user.data1 = is;</span><br><span class="line">        SDL_PushEvent(&amp;event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    SDL_Event       event;</span><br><span class="line">    VideoState      *is;</span><br><span class="line"></span><br><span class="line">    is = av_mallocz(<span class="keyword">sizeof</span>(VideoState));</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: test &lt;file&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yuvfd = fopen(<span class="string">"testout.yuv"</span>, <span class="string">"wb+"</span>);</span><br><span class="line">    audiofd = fopen(<span class="string">"testout.pcm"</span>, <span class="string">"wb+"</span>);</span><br><span class="line">    <span class="comment">// Register all formats and codecs</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    text_mutex = SDL_CreateMutex();</span><br><span class="line">    av_strlcpy(is-&gt;filename, argv[<span class="number">1</span>], <span class="keyword">sizeof</span>(is-&gt;filename));</span><br><span class="line">    is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class="line">    is-&gt;pictq_cond = SDL_CreateCond();</span><br><span class="line"></span><br><span class="line">    schedule_refresh(is, <span class="number">40</span>);</span><br><span class="line">    is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;</span><br><span class="line">    is-&gt;parse_tid = SDL_CreateThread(demux_thread,<span class="string">"demux_thread"</span>, is);</span><br><span class="line">    <span class="keyword">if</span>(!is-&gt;parse_tid) &#123;</span><br><span class="line">        av_free(is);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        SDL_WaitEvent(&amp;event);</span><br><span class="line">        <span class="keyword">switch</span>(event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> FF_QUIT_EVENT:</span><br><span class="line">            <span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">                is-&gt;quit = <span class="number">1</span>;</span><br><span class="line">                SDL_Quit();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FF_REFRESH_EVENT:</span><br><span class="line">                video_refresh_timer(event.user.data1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(yuvfd);</span><br><span class="line">    fclose(audiofd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="7-如何在-Android-下使用-FFmpeg"><a href="#7-如何在-Android-下使用-FFmpeg" class="headerlink" title="7. 如何在 Android 下使用 FFmpeg"></a>7. 如何在 Android 下使用 FFmpeg</h2><p>Android 架构：</p><img src="/images/imageFFmpeg/Android架构.png"><p>内容：</p><ul><li>Java 与 C 之间的相互调用</li><li>Android 下 FFmpeg 的编译</li><li>Android 下如何使用FFmpeg</li></ul><p>第一个 JNI 程序：</p><p>TODO</p><p>JNI 基本概念：</p><ul><li>JNIEnv</li><li>JavaVM  一个Android APP只有一个 JavaVM， 一个 JavaVM 可以有多个JNIEnv</li><li>线程  一个线程对应一个JNIEnv</li></ul><p>Java调用C/C++ 方法一：</p><ul><li><p>在Java层定义 native 关键字函数</p></li><li><p>方法一：在C/C++层创建</p><p>Java_packname_classname_methodname 函数</p></li></ul><p>Java调用C/C++方法二：</p><img src="/images/imageFFmpeg/java调用c方法二.png"><img src="/images/imageFFmpeg/注册Native方法的最佳时机.png"><p>什么是Signature：</p><ul><li>Java与C/C++ 相互调用时，表式函数参数的描述符</li><li>输入参数放在（）内，输出参数放在（）外</li><li>多个参数之间顺序存放，且用 “；” 分割</li></ul><img src="/images/imageFFmpeg/原始类型的Signature.png"><img src="/images/imageFFmpeg/类的Signature.png"> <img src="/images/imageFFmpeg/例子.png"><p>C/C++ 调用 Java 方法：</p><ul><li>FindClass</li><li>GetMethodID / GetFieldID</li><li>NewObject</li><li><code>Call&lt;TYPE&gt;Method / [G/S]et&lt;type&gt;Field</code></li></ul><h3 id="7-1-实战-Android-下的播放器"><a href="#7-1-实战-Android-下的播放器" class="headerlink" title="7.1 [实战] Android 下的播放器"></a>7.1 [实战] Android 下的播放器</h3><p>TODO</p><h2 id="8-IOS-下使用-FFmpeg"><a href="#8-IOS-下使用-FFmpeg" class="headerlink" title="8. IOS 下使用 FFmpeg"></a>8. IOS 下使用 FFmpeg</h2><p>TODO</p><h2 id="9-音视频进阶"><a href="#9-音视频进阶" class="headerlink" title="9. 音视频进阶"></a>9. 音视频进阶</h2><ul><li>FFmpeg Filter 的使用 </li><li>FFmpeg 裁剪与优化</li><li>视频渲染（OpenGL / Metal）</li><li>声音的特效</li><li>网络传输</li><li>Webrtc - 实时互动、直播、P2P音视频传输</li><li>AR技术</li><li>OpenCV</li></ul><p>行业痛点：</p><ul><li>回音消除</li><li>降噪</li><li>视频秒开</li><li>多人多视频实时互动</li><li>PC端/APP/网页实时视频互通</li><li>实时互动与大并发负载</li></ul><h2 id="FFmpeg音视频同步原理与实现"><a href="#FFmpeg音视频同步原理与实现" class="headerlink" title="FFmpeg音视频同步原理与实现"></a>FFmpeg音视频同步原理与实现</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaG95cy9hcmNoaXZlLzIwMTEvMDYvMDgvMjA3NTE1OS5odG1s" title="https://www.cnblogs.com/hoys/archive/2011/06/08/2075159.html">音视频同步解决方案<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy54bWwtZGF0YS5vcmcvR0RHWURYWEIvaHRtbC8yMDE3MDQxMS5odG0=" title="http://www.xml-data.org/GDGYDXXB/html/20170411.htm">一种基于FFMPEG的音视频同步算法<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="音视频同步原理"><a href="#音视频同步原理" class="headerlink" title="音视频同步原理"></a>音视频同步原理</h3><p>如果简单的按照音频的采样率与视频的帧率去播放，由于机器运行速度，解码效率等种种造成时间差异的因素影响，很难同步，音视频时间差将会呈现线性增长。所以要做音视频的同步，有三种方式：</p><p>参考一个外部时钟，将音频与视频同步至此时间。我首先想到这种方式，但是并不好，由于某些生物学的原理，人对声音的变化比较敏感，但是对视觉变化不太敏感。所以频繁的去调整声音的播放会有些刺耳或者杂音吧影响用户体验。（ps：顺便科普生物学知识，自我感觉好高大上_）。</p><ul><li>以视频为基准，音频去同步视频的时间。不采用，理由同上。</li><li>以音频为基准，视频去同步音频的时间。 所以这个办法了。</li></ul><p>所以，原理就是以音频时间为基准，判断视频快了还是慢了，从而调整视频速度。其实是一个动态的追赶与等待的过程。</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>音视频中都有 <code>DTS</code> 与 <code>PTS</code>。</p><ul><li>DTS ，Decoding Time Stamp，解码时间戳，告诉解码器packet的解码顺序。</li><li>PTS ，Presentation Time Stamp，显示时间戳，指示从packet中解码出来的数据的显示顺序。</li><li>音频中二者是相同的，但是视频由于B帧（双向预测）的存在，会造成解码顺序与显示顺序并不相同，也就是视频中 DTS 与 PTS 不一定相同。</li></ul><p>时间基 : 看 FFmpeg 源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVRational time_base;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* rational number numerator/denominator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> num; <span class="comment">///&lt; numerator</span></span><br><span class="line">   <span class="keyword">int</span> den; <span class="comment">///&lt; denominator</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><p>个人理解，其实就是 ffmpeg中 的用分数表示时间单位，num 为分子，den 为分母。并且 ffmpeg 提供了计算方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Convert rational to double.</span></span><br><span class="line"><span class="comment">* @param a rational to convert</span></span><br><span class="line"><span class="comment">* @return (double) a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">av_q2d</span><span class="params">(AVRational a)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a.num / (<span class="keyword">double</span>) a.den;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 视频中某帧的显示时间 计算方式为(单位为妙)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time = pts * av_q2d(time_base);</span><br></pre></td></tr></table></figure><h3 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h3><p><strong>音频部分</strong></p><p>clock 为音频的播放时长（从开始到当前的时间）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (packet-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    audio-&gt;clock = av_q2d(audio-&gt;time_base) * packet-&gt;pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后加上此 packet 中数据需要播放的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> time = datalen/((<span class="keyword">double</span>) <span class="number">44100</span> *<span class="number">2</span> * <span class="number">2</span>);</span><br><span class="line">audio-&gt;clock = audio-&gt;clock +time;</span><br></pre></td></tr></table></figure><p>datalen 为数据长度。采样率为 44100，采样位数为 16，通道数为 2。所以 数据长度 / 每秒字节数。</p><p>ps：此处计算方式不是很完美，有很多问题，回头研究在再补上。</p><p><strong>视频部分</strong></p><details><summary>先定义几个值：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>  last_play  <span class="comment">//上一帧的播放时间</span></span><br><span class="line">   ,play             <span class="comment">//当前帧的播放时间</span></span><br><span class="line">   , last_delay    <span class="comment">// 上一次播放视频的两帧视频间隔时间</span></span><br><span class="line">   ,delay         <span class="comment">//两帧视频间隔时间</span></span><br><span class="line">   ,audio_clock <span class="comment">//音频轨道 实际播放时间</span></span><br><span class="line">   ,diff   <span class="comment">//音频帧与视频帧相差时间</span></span><br><span class="line">   ,sync_threshold <span class="comment">//合理的范围</span></span><br><span class="line">   ,start_time  <span class="comment">//从第一帧开始的绝对时间</span></span><br><span class="line">   ,pts</span><br><span class="line">   ,actual_delay<span class="comment">//真正需要延迟时间</span></span><br><span class="line">   start_time = av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line"><span class="comment">//        获取pts</span></span><br><span class="line">       <span class="keyword">if</span> ((pts = av_frame_get_best_effort_timestamp(frame)) == AV_NOPTS_VALUE) &#123;</span><br><span class="line">           pts = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       play = pts * av_q2d(vedio-&gt;time_base);</span><br><span class="line"><span class="comment">//        纠正时间</span></span><br><span class="line">       play = vedio-&gt;synchronize(frame, play);</span><br><span class="line">       delay = play - last_play;</span><br><span class="line">       <span class="keyword">if</span> (delay &lt;= <span class="number">0</span> || delay &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           delay = last_delay;</span><br><span class="line">       &#125;</span><br><span class="line">       audio_clock = vedio-&gt;audio-&gt;clock;</span><br><span class="line">       last_delay = delay;</span><br><span class="line">       last_play = play;</span><br><span class="line"><span class="comment">//音频与视频的时间差</span></span><br><span class="line">       diff = vedio-&gt;clock - audio_clock;</span><br><span class="line"><span class="comment">//        在合理范围外  才会延迟  加快</span></span><br><span class="line">       sync_threshold = (delay &gt; <span class="number">0.01</span> ? <span class="number">0.01</span> : delay);</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">fabs</span>(diff) &lt; <span class="number">10</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (diff &lt;= -sync_threshold) &#123;</span><br><span class="line">               delay = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold) &#123;</span><br><span class="line">               delay = <span class="number">2</span> * delay;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       start_time += delay;</span><br><span class="line">       actual_delay = start_time - av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">       <span class="keyword">if</span> (actual_delay &lt; <span class="number">0.01</span>) &#123;</span><br><span class="line">           actual_delay = <span class="number">0.01</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//  休眠时间 ffmpeg 建议这样写  为什么 要这样写 有待研究</span></span><br><span class="line">       av_usleep(actual_delay * <span class="number">1000000.0</span> + <span class="number">6000</span>);</span><br><span class="line">纠正play （播放时间）的方法 repeat_pict / (<span class="number">2</span> * fps) 是ffmpeg注释里教的</span><br><span class="line">synchronize(AVFrame *frame, <span class="keyword">double</span> play) &#123;</span><br><span class="line">   <span class="comment">//clock是当前播放的时间位置</span></span><br><span class="line">   <span class="keyword">if</span> (play != <span class="number">0</span>)</span><br><span class="line">       clock=play;</span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//pst为0 则先把pts设为上一帧时间</span></span><br><span class="line">       play = clock;</span><br><span class="line">   <span class="comment">//可能有pts为0 则主动增加clock</span></span><br><span class="line">   <span class="comment">//需要求出扩展延时：</span></span><br><span class="line">   <span class="keyword">double</span> repeat_pict = frame-&gt;repeat_pict;</span><br><span class="line">   <span class="comment">//使用AvCodecContext的而不是stream的</span></span><br><span class="line">   <span class="keyword">double</span> frame_delay = av_q2d(codec-&gt;time_base);</span><br><span class="line">   <span class="comment">//fps </span></span><br><span class="line">   <span class="keyword">double</span> fps = <span class="number">1</span> / frame_delay;</span><br><span class="line">   <span class="comment">//pts 加上 这个延迟 是显示时间  </span></span><br><span class="line">   <span class="keyword">double</span> extra_delay = repeat_pict / (<span class="number">2</span> * fps);</span><br><span class="line">   <span class="keyword">double</span> delay = extra_delay + frame_delay;</span><br><span class="line">   clock += delay;</span><br><span class="line">   <span class="keyword">return</span> play;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="FFmpeg-痛点解决"><a href="#FFmpeg-痛点解决" class="headerlink" title="FFmpeg 痛点解决"></a>FFmpeg 痛点解决</h2><p><strong>回音消除解决方案：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoYW9nL2FydGljbGUvZGV0YWlscy83MTE1Mjc0Mw==" title="https://blog.csdn.net/shichaog/article/details/71152743">语音自适应回声消除（AEC）算法<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmdiZWk5MDI5L2FydGljbGUvZGV0YWlscy84MTIzNzQwMg==" title="https://blog.csdn.net/longbei9029/article/details/81237402">回声消除(AEC)原理<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9RT3A0SU9hb19ESko2ZU5zSU9YcA==" title="https://www.infoq.cn/article/QOp4IOao_DJJ6eNsIOXp">音频降噪在 58 直播中的研究与实现<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>视频秒开：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoYXJlVXMvYXJ0aWNsZS9kZXRhaWxzLzc5MTE1ODE2" title="https://blog.csdn.net/ShareUs/article/details/79115816">直播视频秒开及视频优化<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGVhZjQ5YThkNmQ4MTAwNjE4YmMyMzg=" title="https://juejin.im/post/58eaf49a8d6d8100618bc238">视频直播秒开背后的技术与优化经验<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDQwNTkxMw==" title="https://segmentfault.com/a/1190000014405913">短视频“秒播”那点事<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy52b2lkY24uY29tL2FydGljbGUvcC1xa2R2dHR1ZS1ibWQuaHRtbA==" title="http://www.voidcn.com/article/p-qkdvttue-bmd.html">百度LSS 音视频直播 秒开<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDE1OTkxMA==" title="https://zhuanlan.zhihu.com/p/34159910">播放器的“妥协”造就了视频“秒开”的实现！<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>多人视频实时互动：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Y2IwMDhjMjZmYjlhMDY4NTQ3MzQ1ZWI=" title="https://juejin.im/post/5cb008c26fb9a068547345eb">WebRTC现状以及多人视频通话分析<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5wb2x5di5uZXQvbmV3cy8yMDE5LzAyL2h5MDM5Ni8=" title="http://www.polyv.net/news/2019/02/hy0396/">多人视频连麦——直播高效互动方式<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>实时互动与大并发负载：</strong></p><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy5tZWRpYXByby5jYy9ydHDovazlj5HmnI3liqHlmagv" title="http://www.mediapro.cc/rtp转发服务器/">RTP直播分发服务器集群方案<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzA1NTY1OQ==" title="https://zhuanlan.zhihu.com/p/23055659">海量用户实时互动直播架构探索<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuaXRwdWIubmV0LzY5OTA3OTgxL3ZpZXdzcGFjZS0yNTY0NDc5Lw==" title="http://blog.itpub.net/69907981/viewspace-2564479/">直播开发过程中关于直播技术的架构问题<i class="fa fa-external-link"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy80NDIyMDE1MQ==&quot; title=&quot;https://blog.csdn.net/leixiaohua1020/article/details/44220151&quot;&gt;雷神 FFmpeg源代码结构图 - 解码&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL0hhdHN1bmVNaWt1Vi9GRm1wZWdfTGVpeGlhb2h1YQ==&quot; title=&quot;https://github.com/HatsuneMikuV/FFmpeg_Leixiaohua&quot;&gt;雷神 GitHub&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2NvbHVtbi9pbmZvL2ZmbXBlZy1kZXZlbC83&quot; title=&quot;https://blog.csdn.net/leixiaohua1020/column/info/ffmpeg-devel/7&quot;&gt;雷神 FFmpeg blog&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频入门知识</title>
    <link href="http://miaopei.github.io/2019/04/23/FFmpeg/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8/"/>
    <id>http://miaopei.github.io/2019/04/23/FFmpeg/移动端音视频入门/</id>
    <published>2019-04-23T02:14:50.000Z</published>
    <updated>2019-06-13T02:01:37.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85N2I0ZGM4YzdmMDA=" title="https://www.jianshu.com/p/97b4dc8c7f00">H264基本原理<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-万人直播架构讲解"><a href="#1-万人直播架构讲解" class="headerlink" title="1. 万人直播架构讲解"></a>1. 万人直播架构讲解</h2><p>直播产品的种类：</p><ul><li><p>泛娱乐化直播</p><p>花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播</p></li><li><p>实时互动直播</p><p>音视频会议、教育直播等，像 思科、全时、声网</p></li></ul><a id="more"></a><p>泛娱乐化直播架构</p><blockquote><p>信令服务器：创建房间、聊天、礼物。。。。</p><p>美女主播 –信令–&gt; 信令服务器</p><p>信令服务器–rtmp流地址–&gt;美女主播</p><p>美女主播 –推流–&gt; 流媒体云CDN</p><p>观众 –信令–&gt; 信令服务器：将观众加入到美女主播间</p><p>信令服务器–rmtp流地址–&gt; 观众</p><p>观众 &lt;–拉流–&gt; 流媒体云CDN</p></blockquote><p>泛娱乐化直播架构</p><p>基于TCP协议实现</p><ol><li>发送信令到信令服务器, 服务器收到\执行后, 返回给共享端一个流媒体云的地址</li><li>共享端采集自己音视频数据, 形成rtmp流, 推送到CDN网络(推流)</li><li>获取流媒体云地址</li><li>拉流</li></ol><img src="/images/imageFFmpeg/泛娱乐化直播架构.png"><p>实时互动直播架构</p><p>基于UDP实现</p><ol><li>自有网络: UDP没有自有网络, 需自己搭建</li><li>多个节点: 为了保障服务的稳定性以及负载均衡</li><li>控制中心: 每个节点定期(心跳)向控制中心报告健康程度, 控制中心根据响应的数据做出决策</li><li>内总线: 数据安全性\吞吐量等可靠性得以保障</li><li>媒体服务器: 将RTP协议的数据转换成RTMP协议的数据</li><li>CDN网络: 根据用户需求进行拉流</li></ol><img src="/images/imageFFmpeg/实时互动直播架构.png"><h2 id="2-CDN网络介绍"><a href="#2-CDN网络介绍" class="headerlink" title="2. CDN网络介绍"></a>2. CDN网络介绍</h2><blockquote><p>CDN网络是为了解决什么问题而出现的？</p><p>总结为一句话：CDN网络是为了解决用户访问网络资源慢而出现的一个技术，两个原因：</p><ol><li>网络链路太长</li><li>人为因素（南电信北联通，利益相关）</li></ol></blockquote><p>CDN构成：</p><p>边缘结点：用户从边缘节点上获取数据</p><p>二级节点：主干网节点，主要用于缓存、减转源站压力</p><p>源站：CP(内容提供方)将内容放到源站</p><p>查找顺序：边缘结点-&gt;二级节点-&gt;源站</p><img src="/images/imageFFmpeg/CDN网络.png"><h2 id="3-亲手搭建一套简单的直播系统"><a href="#3-亲手搭建一套简单的直播系统" class="headerlink" title="3. 亲手搭建一套简单的直播系统"></a>3. 亲手搭建一套简单的直播系统</h2><p>安装nginx 配置rtmp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install nginx-full --with-rtmp-module</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">(这一步卡了我好久，安装nginx提示一直找不到nginx-full,网上相关的教程没更新，原因在于nginx仓库已搬迁)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew tap denji/nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nginx -s reload 重启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nginx  启动</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/nginx-trmp配置.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/FFMPEG直播命令.png"><img src="/images/imageFFmpeg/测试流媒体服务器.png"><h2 id="4-音频基础知识"><a href="#4-音频基础知识" class="headerlink" title="4. 音频基础知识"></a>4. 音频基础知识</h2><img src="/images/imageFFmpeg/声音三要素.png"><p>图一音量：甲乙的振动频率相同、振幅不同。图二音调：甲乙振幅相同、频率不同</p><img src="/images/imageFFmpeg/音量与音调.png"><img src="/images/imageFFmpeg/音色.png"><img src="/images/imageFFmpeg/人类听觉范围.png"><img src="/images/imageFFmpeg/听觉-发声范围.png"><h2 id="5-音频的量化与编码"><a href="#5-音频的量化与编码" class="headerlink" title="5. 音频的量化与编码"></a>5. 音频的量化与编码</h2><p>模拟信号进行采样，采样时分频率的从模拟信号获取数据波形值，采样后，进行数据量化，量化后进行编码，把采样的十进制转化为计算机的二进制，也就是数字信号。</p><p>模拟数据——》采样——》量化——》编码——》数字信号</p><img src="/images/imageFFmpeg/音频量化过程.png"><p>采样大小决定了音频的振幅的高度，采样时指一个采样用多少bit存放，常用的是16bit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bit：位     一个二进制数据0或1，是1bit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> byte：字节  存储空间的基本计量单位，如：MySQL中定义 VARCHAR(45) 即是指 45个字节；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 Byte = 8 Bit = 1 字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2^8 = 256, 2^16 = 65535</span></span><br></pre></td></tr></table></figure><p>aac通常44.1k采样率</p><p>采样率:采样频率8k/秒、16k/秒、32k/秒、44.1k/秒、48k/秒</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzUxNjky" title="https://www.zhihu.com/question/20351692">什么是音频的采样率？采样率和音质有没有关系？<i class="fa fa-external-link"></i></span> - 知乎</p></blockquote><img src="/images/imageFFmpeg/量化基本概念.png"><p>人能听到的声音范围是20hz-2whz</p><p>码率 = 采样率 x 采样大小 x 声道数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 宽带速率的单位用 bps(或b/s)表示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 B = 8 b   1 B/s = 8 b/s</span></span><br></pre></td></tr></table></figure><img src="/images/imageFFmpeg/码率计算.png"><p>原始的wav文件，大小是1411.2Kb/s</p><p>做完aaclc的编码，大小是128Kb/s</p><p>如果是aache-vr这种编码，大小是32Kb/s</p><h2 id="6-音频压缩技术讲解"><a href="#6-音频压缩技术讲解" class="headerlink" title="6. 音频压缩技术讲解"></a>6. 音频压缩技术讲解</h2><p>音频压缩技术</p><p>1、消除冗余数据（有损压缩技术）。</p><p>压缩的主要方法是去除采集到的音频冗余信息，所谓冗余信息包括人耳听觉范围外的音频信号以及被掩蔽掉的音频信号</p><p>信号的掩蔽可分为频域掩蔽和时域掩蔽</p><p>频域掩蔽：一个强纯音会掩蔽在其附近同时发声的弱纯音。也称同时掩蔽</p><p>时域掩蔽：在时间上相邻的声音之间也有掩蔽现象，主要原因是人的大脑处理信息需要花费时间。</p><p>同步掩蔽效应和不同频率声音的频率和相对竟是有关，而时间掩蔽则仅仅和时间有关。如果两个声音在时间上特别接近，分辨会有困难（如两个声音音量相差较大且两个声音间隔时间低于5毫秒，则其中弱的那个声音会听不到）。</p><p>2、哈夫曼无损编码</p><img src="/images/imageFFmpeg/音频压缩技术.png"><p>音频压缩：频域，时域。</p><ul><li><p>频域: 截取人耳能听到的频率范围，滤掉响度低的声音，去掉某个高频周围低频的声音；</p></li><li><p>时域: 滤掉某个长时间说话中的低音</p></li></ul><img src="/images/imageFFmpeg/音频冗余信息.png"><img src="/images/imageFFmpeg/频域掩蔽效应.png"><img src="/images/imageFFmpeg/时域掩蔽效应.png"><img src="/images/imageFFmpeg/音频编码过程.png"><h2 id="7-音频编解码器选型"><a href="#7-音频编解码器选型" class="headerlink" title="7. 音频编解码器选型"></a>7. 音频编解码器选型</h2><p>网上测评结果：音频编解码器 opus &gt; aac &gt; vorbis </p><p>音频编解码器：</p><p>1：opus，</p><ul><li>口模型：实时互动，对实时性要求非常高 </li><li>耳模型：高保真，对质量要求非常高</li></ul><p>至于什么时候使用那个模型，由opus自己内部来决定，同时，他是性能最好的，压缩率最好。</p><p>2：AAC，经常用于泛娱乐化直播，因为其对实时性要求不是很高但是对音质要求可能较高，所以，选用AAC，当然也可以选用opus的耳模型</p><p>3：sppex，最大的特点就是不仅可以编码音频，还可以对音频进行降噪，优化，尽可能的获取原音频数据</p><p>4：G.711(722)，主要用于音视频会议，为了和固话进行相应的融合</p><img src="/images/imageFFmpeg/常见的音频编码器.png"><img src="/images/imageFFmpeg/音频编码器性能对比.png"><h2 id="8-AAC-讲解"><a href="#8-AAC-讲解" class="headerlink" title="8. AAC 讲解"></a>8. AAC 讲解</h2><p>cdn，rtmp  支持 aac</p><p>AAC 产生的目的是取代 MP3 格式：</p><p>AAC 相对优点：压缩率高，损耗低</p><img src="/images/imageFFmpeg/AAC介绍.png"><img src="/images/imageFFmpeg/AAC规格.png"><p>aac 三种类型<br>aac<br>aacv1: aac+sbr(频率复用-高频部分采样率高，低频部分采样率低)<br>aacv2: aac+sbr+ps(声道关联，一个声道采集全部，一个声道只采集相对不同的声音)</p><p>AAC规格描述（AAC、AAC HE、AAC HE V2）–&gt; AAC+SBR=AAC HE V1, AAC + SBR + PS = AAC HE V2</p><img src="/images/imageFFmpeg/AAC规格描述.png"><p>AAC格式：</p><p>1、ADIF(Audio Data Interchange Format):只能从头开始解码，常用在磁盘文件中。</p><p>2、ADTS(Audio Data Transport Stream)：这种格式每一帧都有一个同步字，可以在音频流的任何位置开始解码，它似于数据流格式（缺点：文件比ADIF大，优点:每个帧都可以被单独解码播放）</p><img src="/images/imageFFmpeg/AAC格式.png"><p>aac 编码库 ffmpeg AAC，libfdk AAC</p><img src="/images/imageFFmpeg/AAC编码库那个好.png"><h2 id="9-视频基本知识"><a href="#9-视频基本知识" class="headerlink" title="9. 视频基本知识"></a>9. 视频基本知识</h2><p>I帧：关键帧，采用帧内压缩技术</p><p>P帧：向前参考帧，压缩时只参考前一个帧，属于帧间压缩技术</p><p>B帧：双向参考帧，压缩时即参考前一帧也参考后一帧，属于帧间压缩技术</p><p>一般实时互动都不会使用 B 帧</p><img src="/images/imageFFmpeg/H264基本概念.png"><p>GOF(group of frame): 一组帧，可以将一段时间内画面变化不大的所有帧划为一组帧</p><img src="/images/imageFFmpeg/GOF.png"><p>SPS与PPS（这两种都划为 I 帧）：</p><ul><li><p>SPS(Sequence Parameter Set): </p><p>序列参数集，存放帧数、参考帧数目、解码图像尺寸、帧场编码模式选择标识等。</p></li><li><p>PPS(Picture Parameter Set):</p><p>图像参数集，存放熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系统数调整标识等</p></li></ul><img src="/images/imageFFmpeg/SPS与PPS.png"><p>视频花屏/卡顿原因：</p><p>1、如果 GOP 分组中的 P 帧丢失会造成解码端的图像发生错误（于是形成了花屏）。</p><p>2、为了避免花屏问题的发生，一般如果发现 P 帧或者I帧丢失，就不显示本 GOP 内的所有帧，直到下一个 I 帧来后重新刷新图像（因为丢了一组数据，所以形成了卡顿）</p><img src="/images/imageFFmpeg/视频花屏卡顿的原因.png"><p>视频编码器：</p><p>1、x264/x265。</p><p>2、openH264(支持 SVC（分层传输） 技术)。</p><p>3、vp8/vp9</p><img src="/images/imageFFmpeg/视频都有哪些视频编码器.png"><h2 id="10-H264-宏块的划分与帧分组"><a href="#10-H264-宏块的划分与帧分组" class="headerlink" title="10. H264 宏块的划分与帧分组"></a>10. H264 宏块的划分与帧分组</h2><p>H264压缩技术</p><ol><li>帧内预测压缩，解决的是空域数据冗余问题（将一幅图里的人眼不是很敏感的色彩、光亮等数据剔除）</li><li>帧间预测压缩，解决的是时域数据冗余问题（将一组图里面连续的重复性高的帧剔除）</li><li>整数离散余弦变换(DCT)，将空间上的相关性变为频域上无关的数据然后进行量化</li><li>CABAC压缩，也叫上下文适应无损压缩</li></ol><img src="/images/imageFFmpeg/H264压缩技术.png"><p>宏块的划分与分组：</p><p>H264宏块划分与子块划分：宏块里面可以再包含很多子块</p><img src="/images/imageFFmpeg/H264宏块划分.png"><img src="/images/imageFFmpeg/宏块划分完成.png"><p>子块划分：</p><img src="/images/imageFFmpeg/子块划分.png"><p>帧分组(一组连续的图片，一幅图片为一帧)</p><img src="/images/imageFFmpeg/帧分组.png"><h2 id="11-视频压缩技术详解"><a href="#11-视频压缩技术详解" class="headerlink" title="11. 视频压缩技术详解"></a>11. 视频压缩技术详解</h2><ul><li><p>帧间预测: </p><p>解决时间数据冗余，比较相邻两帧不同给出运动矢量 + 残差值</p></li><li><p>帧内预测: </p><p>解决空间数据冗余，每一个宏块有一个预测模式，然后讲预测后的图像与原图比较算差值，最后存储预测模式和差值即可。帧内压缩是针对于 I 帧的</p></li></ul><h3 id="11-1-帧间预测"><a href="#11-1-帧间预测" class="headerlink" title="11.1 帧间预测"></a>11.1 帧间预测</h3><p>组内宏块查找：</p><img src="/images/imageFFmpeg/组内宏块查找.png"><img src="/images/imageFFmpeg/运动估算.png"><img src="/images/imageFFmpeg/运动矢量与补偿压缩.png"><h3 id="11-2-帧内预测"><a href="#11-2-帧内预测" class="headerlink" title="11.2 帧内预测"></a>11.2 帧内预测</h3><img src="/images/imageFFmpeg/帧内预测.png"><img src="/images/imageFFmpeg/计算帧内预测残差值.png"><img src="/images/imageFFmpeg/预测模式与残差值压缩.png"><h3 id="11-3-DCT-压缩"><a href="#11-3-DCT-压缩" class="headerlink" title="11.3 DCT 压缩"></a>11.3 DCT 压缩</h3><img src="/images/imageFFmpeg/DCT压缩.png"><img src="/images/imageFFmpeg/压缩后的结果.png"><h3 id="11-4-VLC-压缩"><a href="#11-4-VLC-压缩" class="headerlink" title="11.4 VLC 压缩"></a>11.4 VLC 压缩</h3><img src="/images/imageFFmpeg/VLC压缩.png"><h3 id="11-5-CABAC-压缩"><a href="#11-5-CABAC-压缩" class="headerlink" title="11.5 CABAC 压缩"></a>11.5 CABAC 压缩</h3><img src="/images/imageFFmpeg/CABAC压缩.png"><h2 id="12-H264-结构与码流"><a href="#12-H264-结构与码流" class="headerlink" title="12. H264 结构与码流"></a>12. H264 结构与码流</h2><p>H264编码分层：</p><p>1、NAL层（Network Abstraction Layer）, 视频数据网络抽象层。</p><p>2、VCL层（Video Coding Layer），视频数据编码层，对原始数据进行压缩</p><p>码流基本概念：</p><p>1、SODB（String Of Data Bits）,原始数据比特流，长度不一定是8的倍数，它是由VCL层产生的。</p><p>2、RBSP（Raw Byte Sequence Payload,SODB+trailing bits），算法是在SODB最后一位补1，不按字节对齐则补0。</p><p>3、EBSP(Encapsulate Byte Sequence Payload)，需到两个连续的0x00就增加一个0x03。</p><p>4、NALU，NAL Header(1B)+EBSP</p><img src="/images/imageFFmpeg/H264结构图.png"><p>以太网最大传输字节 1500 字节。</p><img src="/images/imageFFmpeg/H264编码分层.png"><img src="/images/imageFFmpeg/码流基本概念一.png"><img src="/images/imageFFmpeg/码流基本概念二.png"><p>一个H264帧最少要有一个切片(NAL Unit)</p><img src="/images/imageFFmpeg/NALUnit.png"><p>切片与宏块的关系：</p><ul><li>每个切片都包括切片头和切片数据，</li><li>每个切片数据又包括了很多宏块，</li><li>每个宏块又包括了宏块的类型、宏块的预测、编码的残渣数据等</li></ul><img src="/images/imageFFmpeg/切片与宏.png"><img src="/images/imageFFmpeg/H264切片.png"><img src="/images/imageFFmpeg/H264码流分层.png"><h2 id="13-NAL-单元详解"><a href="#13-NAL-单元详解" class="headerlink" title="13. NAL 单元详解"></a>13. NAL 单元详解</h2><img src="/images/imageFFmpeg/NALHeader.png"><p>5 - 关键帧</p><p>7- SPS 序列参数集</p><p>8- PPS 图像参数集</p><img src="/images/imageFFmpeg/NALType一.png"><img src="/images/imageFFmpeg/NALType二.png"><img src="/images/imageFFmpeg/NAL类型介绍.png"><img src="/images/imageFFmpeg/单一NALU的RTP包.png"><img src="/images/imageFFmpeg/组合NALU的RTP包.png"><p>如：</p><p>P帧B帧很多都是单一类型。</p><p>SPS和PPS这两个NAL单元一般放在同一个RTP包里头</p><img src="/images/imageFFmpeg/分片NALU的RTP包.png"><img src="/images/imageFFmpeg/FUHeader.png"><h2 id="14-YUV-讲解"><a href="#14-YUV-讲解" class="headerlink" title="14. YUV 讲解"></a>14. YUV 讲解</h2><img src="/images/imageFFmpeg/图像除了RGB还是有YUV.png"><img src="/images/imageFFmpeg/YUV.png"><p>YUV常见格式：YUV4:2:0、YUV4:2:2、YUV4:4:4</p><p>RGB8:8:8</p><img src="/images/imageFFmpeg/YUV常见格式.png"><img src="/images/imageFFmpeg/YUV420.png"><ul><li>UV 混存则为packed(打包存储)，</li><li>UV分开存则为planar(平面存储) </li></ul><img src="/images/imageFFmpeg/YUV存储格式.png"><h2 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h2><img src="/images/imageFFmpeg/小结.png"><img src="/images/imageFFmpeg/音频小结.png"><img src="/images/imageFFmpeg/视频小结.png"><p>rtmp 实时消息传输: tcp/ip 应用层协议  推送/直播  基本数据单元为消息</p><p>1B 消息类型  2B 长度  3B 时间 4B  流id 消息体</p><p>传输时 消息回被拆分成消息块 chunk chunk header + chunk data</p><p>flv: 大块音视频 加入标记头信息   延迟表现和大规模并发成熟 </p><p>HLS：分成5-10s 用m3u8索引管理 用于朋友圈分享  </p><p>m3u8索引： 直播信号源–视频编码器（后台视频处理）–流切片器–各种ts媒体文件（分发模块）–索引文件（数据库）–客户端</p><p>cdn网络 为了解决用户访问资源慢出现的技术</p><p>边缘节点  二级节点（大城市） 源站</p><p>搭建流媒体服务：</p><p>准备流媒体服务器 linux max 编译安装nginx服务  配置rtmp服务并启动nginx服务</p><p>声音三要素：音调 音量 音色</p><p>音频量化(模数转换)：模拟数据 采样  量化 编码  数字信号  == 0101001110</p><p>码率 = 采样率（1.6w/44.1/48k）x 采样大小(8位-电话/16位-常见) x 声道数（单/双）</p><p>音频压缩： 有损消除冗余数据   哈夫曼无损编码</p><p>音频编码： 时域转频域—心里声学模型—量化编码—比特流格式化—比特流</p><p>音频编解码 ： opus（口 耳 实时互动 最快）  aac(直播用 次快)  speed(回音 降噪等)   g.711（固话）</p><p>aac : 取代mp3 加入 sir ps 技术  </p><p>aac lc 128k / aac he v2 64k /  aac he v2 32k/</p><p>aac 格式 ： adif 从头开始解码，用在磁盘文件中  adts 每一帧都有一个同步字，可以在任何位置解码</p><p>aac 编码库 ： libfdk_aac &gt; ffmpeg aac &gt;libfaac&gt; libvo_aacenc</p><p>H264： I帧 关键 帧内压缩  / p帧 向前参考1帧 / B帧 双向参考帧</p><p>sps: 序列参数集/pps:图像参数集 </p><p>GOF： 一组帧数  p帧丢失 会花屏卡顿</p><p>视频编码器： x264/x265 /open h264(svc)/vp8/vp9</p><p>h264 压缩技术-编码原理： 帧内预测压缩，空域冗余数据/帧间预测压缩，时域冗余数据/dcp整数离散余炫变换，傅立叶变换/cabac压缩</p><p>h264结构：视频序列–图像–片–宏块–子快</p><p>h264编码分层：nal 视频数据网络抽象层–vcl 视频数据编码层</p><p>码率：sodb 原始比特流 / rbsp sodb最后补1 / ebsp 起始码增加一个起始位0x03 /  nalu nal+ebsp</p><p>nal unit = nalu 头部 + 一个切片（头/数据） 切片 </p><p>yuv格式：4：4:4/4:4:2/4：2:0 （平坦编码 /半平坦编码）</p><img src="/images/imageFFmpeg/后续.png"><img src="/images/imageFFmpeg/音视频知识01.png"><img src="/images/imageFFmpeg/音视频知识02.png"><img src="/images/imageFFmpeg/音视频知识03.png"><img src="/images/imageFFmpeg/行业痛点-01.png"><img src="/images/imageFFmpeg/行业痛点-02.png">]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85N2I0ZGM4YzdmMDA=&quot; title=&quot;https://www.jianshu.com/p/97b4dc8c7f00&quot;&gt;H264基本原理&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-万人直播架构讲解&quot;&gt;&lt;a href=&quot;#1-万人直播架构讲解&quot; class=&quot;headerlink&quot; title=&quot;1. 万人直播架构讲解&quot;&gt;&lt;/a&gt;1. 万人直播架构讲解&lt;/h2&gt;&lt;p&gt;直播产品的种类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;泛娱乐化直播&lt;/p&gt;
&lt;p&gt;花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实时互动直播&lt;/p&gt;
&lt;p&gt;音视频会议、教育直播等，像 思科、全时、声网&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg入门</title>
    <link href="http://miaopei.github.io/2019/04/20/FFmpeg/FFmpeg%E5%85%A5%E9%97%A8/"/>
    <id>http://miaopei.github.io/2019/04/20/FFmpeg/FFmpeg入门/</id>
    <published>2019-04-20T02:14:50.000Z</published>
    <updated>2019-07-01T07:37:16.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以文档的形式来描述FFmpeg怎么入门，这也是为以后写文档做的一个大题框架格式。</p></blockquote><h1 id="文档介绍"><a href="#文档介绍" class="headerlink" title="文档介绍"></a>文档介绍</h1><h2 id="文档目的"><a href="#文档目的" class="headerlink" title="文档目的"></a>文档目的</h2><p>整理出开源代码 ffmpeg 的资料，方便公司同事后续使用。</p><a id="more"></a><h2 id="文档范围"><a href="#文档范围" class="headerlink" title="文档范围"></a>文档范围</h2><p>较为详细的介绍 ffmpeg 的功能、使用以及二次开发。</p><h2 id="读者对象"><a href="#读者对象" class="headerlink" title="读者对象"></a>读者对象</h2><p>希望了解 ffmpeg 知识，从事 USM 及 IPTV 的同事。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>TODO</p><h2 id="术语与缩写解释"><a href="#术语与缩写解释" class="headerlink" title="术语与缩写解释"></a>术语与缩写解释</h2><table><thead><tr><th>缩略语/术语</th><th>全 称</th><th>说 明</th></tr></thead><tbody><tr><td>ffmpeg</td><td>Fast forword mpeg</td><td>音视频转换器</td></tr><tr><td>ffplay</td><td>Fast forword play</td><td>用 ffmpeg 实现的播放器</td></tr><tr><td>ffserver</td><td>Fast forword server</td><td>用 ffmpeg 实现的 rstp 服务器</td></tr><tr><td>ffprobe</td><td>Fast forword probe</td><td>用来输入分析输入流。</td></tr></tbody></table><h1 id="FFmpeg-支持能力说明"><a href="#FFmpeg-支持能力说明" class="headerlink" title="FFmpeg 支持能力说明"></a>FFmpeg 支持能力说明</h1><h2 id="FFmpeg-介绍及安装"><a href="#FFmpeg-介绍及安装" class="headerlink" title="FFmpeg 介绍及安装"></a>FFmpeg 介绍及安装</h2><h3 id="FFmpeg-简介"><a href="#FFmpeg-简介" class="headerlink" title="FFmpeg 简介"></a>FFmpeg 简介</h3><p>FFmpeg 是一个开源免费跨平台的视频和音频流方案，属于自由软件，采用 LGPL 或 GPL 许可证（依据你选择的组件）。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库 libavcodec，为了保证高可移植性和编解码质量，libavcodec 里很多 codec 都是从头开发的。</p><p>FFmpeg 项目由以下几部分组成:</p><p>（1）ffmpeg 视频文件转换命令行工具, 也支持经过实时电视卡抓取和编码成视频文件.</p><p>（2）ffserver 基于 HTTP、RTSP 用于实时广播的多媒体服务器. 也支持时间平移</p><p>（3）ffplay 用 SDL 和 FFmpeg 库开发的一个简单的媒体播放器</p><p>（4）libavcodec 一个包含了所有 FFmpeg 音视频编解码器的库. 为了保证最优性能和高可复用性, 大多数编解码器从头开发的.</p><p>（5）libavformat 一个包含了所有的普通音视格式的解析器和产生器的库</p><h3 id="FFmpeg-安装"><a href="#FFmpeg-安装" class="headerlink" title="FFmpeg 安装"></a>FFmpeg 安装</h3><p>将所有源代码压缩在一个文件夹中，例如 <code>/绝对路径/ffmpeg</code>。</p><p>在终端输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /绝对路径/ffmpeg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure   <span class="comment">#(此时，会出现问题。然后重新输入./configure –disable-yasm-)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> Make</span></span><br></pre></td></tr></table></figure><p>至此，ffmpeg 安装编译通过，可以进行对音视频的操作。</p><p>ffplay 的编译需要依赖于 SDL 库，所以要想编译成功 ffplay，必须先安装 SDL 库，</p><p>安装方法：下载最新版本的 SDL 相应版本的 SDL 源码，编译，即可生成 SDL 库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先下载 SDL 软件包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> configure --prefix=/usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure><h2 id="FFmpeg-参数说明"><a href="#FFmpeg-参数说明" class="headerlink" title="FFmpeg 参数说明"></a>FFmpeg 参数说明</h2><h3 id="通用选项"><a href="#通用选项" class="headerlink" title="通用选项"></a>通用选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-L license</span><br><span class="line">-h 帮助</span><br><span class="line">-fromats 显示可用的格式，编解码的，协议的。</span><br><span class="line">-f fmt 强迫采用格式 fmt</span><br><span class="line">-i filename 输入文件</span><br><span class="line">-y 覆盖输出文件</span><br><span class="line">-t duration 设置纪录时间 hh:mm:ss[.xxx]格式的记录时间也支持</span><br><span class="line">-ss position 搜索到指定的时间 [-]hh:mm:ss[.xxx]的格式也支持</span><br><span class="line">-title string 设置标题</span><br><span class="line">-author string 设置作者</span><br><span class="line">-copyright string 设置版权</span><br><span class="line">-comment string 设置评论</span><br><span class="line">-target type 设置目标文件类型(vcd，svcd，dvd) 所有的格式选项（比特率，编解码以及缓冲区大小）自动设置 ，只需要输入如下的就可以了：</span><br><span class="line">ffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg</span><br><span class="line">-hq 激活高质量设置</span><br><span class="line">-itsoffset offset 设置以秒为基准的时间偏移，该选项影响所有后面的输入文件。该偏移被加到输 入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset 秒。</span><br><span class="line">[-]hh:mm:ss[.xxx] 的格式也支持</span><br></pre></td></tr></table></figure><h3 id="视频选项"><a href="#视频选项" class="headerlink" title="视频选项"></a>视频选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-b bitrate 设置比特率，缺省 200kb/s</span><br><span class="line">-r fps 设置帧频 缺省 25</span><br><span class="line">-s size 设置帧大小 格式为 WXH 缺省 160X128.下面的简写也可以直接使用：</span><br><span class="line">Sqcif 128X96 qcif 176X144 cif 252X288 4cif 704X576</span><br><span class="line">-aspect aspect 设置横纵比 4:3 16:9 或 1.3333 1.7777</span><br><span class="line">-croptop size 设置顶部切除带大小 像素单位</span><br><span class="line">-cropbottom size –cropleft size –cropright size 底部，左边，右边切除带大小。</span><br><span class="line">-padtop size 设置顶部补齐的大小 像素单位</span><br><span class="line">-padbottom size –padleft size –padright size –padcolor color 设置补齐条大小</span><br><span class="line">和颜色(hex，6 个 16 进制的数，红:绿:兰排列，比如 000000 代表黑色)</span><br><span class="line">-vn 不做视频记录</span><br><span class="line">-bt tolerance 设置视频码率容忍度 kbit/s</span><br><span class="line">-maxrate bitrate 设置最大视频码率容忍度</span><br><span class="line">-minrate bitreate 设置最小视频码率容忍度</span><br><span class="line">-bufsize size 设置码率控制缓冲区大小</span><br><span class="line">-vcodec codec 强制使用 codec 编解码方式。 如果用 copy 表示原始编解码数据必须被拷贝。</span><br><span class="line">-sameq 使用同样视频质量作为源（VBR）</span><br><span class="line">-pass n 选择处理遍数（1 或者 2）。两遍编码非常有用。第一遍生成统计信息，第二遍生成精确的请求的码率</span><br><span class="line">-passlogfile file 选择两遍的纪录文件名为 file</span><br></pre></td></tr></table></figure><h3 id="高级视频选项"><a href="#高级视频选项" class="headerlink" title="高级视频选项"></a>高级视频选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">-g gop_size 设置图像组大小</span><br><span class="line">-intra 仅适用帧内编码</span><br><span class="line">-qscale q 使用固定的视频量化标度(VBR)</span><br><span class="line">-qmin q 最小视频量化标度(VBR)</span><br><span class="line">-qmax q 最大视频量化标度(VBR)</span><br><span class="line">-qdiff q 量化标度间最大偏差 (VBR)</span><br><span class="line">-qblur blur 视频量化标度柔化(VBR)</span><br><span class="line">-qcomp compression 视频量化标度压缩(VBR)</span><br><span class="line">-rc_init_cplx complexity 一遍编码的初始复杂度</span><br><span class="line">-b_qfactor factor 在 p 和 b 帧间的 qp 因子</span><br><span class="line">-i_qfactor factor 在 p 和 i 帧间的 qp 因子</span><br><span class="line">-b_qoffset offset 在 p 和 b 帧间的 qp 偏差</span><br><span class="line">-i_qoffset offset 在 p 和 i 帧间的 qp 偏差</span><br><span class="line">-rc_eq equation 设置码率控制方程 默认 tex^qComp</span><br><span class="line">-rc_override override 特定间隔下的速率控制重载</span><br><span class="line">-me method 设置运动估计的方法 可用方法有 zero phods log x1 epzs(缺省) full</span><br><span class="line">-dct_algo algo 设置 dct 的算法可用的有 0 FF_DCT_AUTO 缺省的 DCT </span><br><span class="line">1 FF_DCT_FASTINT </span><br><span class="line">2 FF_DCT_INT </span><br><span class="line">3 FF_DCT_MMX </span><br><span class="line">4 FF_DCT_MLIB </span><br><span class="line">5 FF_DCT_ALTIVEC</span><br><span class="line">-idct_algo algo 设置 idct 算法。可用的有 0 FF_IDCT_AUTO 缺省的 IDCT </span><br><span class="line">1 FF_IDCT_INT </span><br><span class="line">2 FF_IDCT_SIMPLE </span><br><span class="line">3 FF_IDCT_SIMPLEMMX </span><br><span class="line">4 FF_IDCT_LIBMPEG2MMX </span><br><span class="line">5 FF_IDCT_PS2 </span><br><span class="line">6 FF_IDCT_MLIB </span><br><span class="line">7 FF_IDCT_ARM </span><br><span class="line">8 FF_IDCT_ALTIVEC </span><br><span class="line">9 FF_IDCT_SH4 </span><br><span class="line">10 FF_IDCT_SIMPLEARM</span><br><span class="line">-er n 设置错误残留为 n 1 FF_ER_CAREFULL 缺省 </span><br><span class="line">2 FF_ER_COMPLIANT </span><br><span class="line">3 FF_ER_AGGRESSIVE </span><br><span class="line">4 FF_ER_VERY_AGGRESSIVE</span><br><span class="line">-ec bit_mask 设置错误掩蔽为 bit_mask ， 该值为如下值的位掩码 </span><br><span class="line">1 FF_EC_GUESS_MVS (default=enabled) </span><br><span class="line">2 FF_EC_DEBLOCK (default=enabled)</span><br><span class="line">-bf frames 使用 frames B 帧，支持 mpeg1，mpeg2，mpeg4</span><br><span class="line">-mbd mode 宏块决策 0 FF_MB_DECISION_SIMPLE 使 用 mb_cmp </span><br><span class="line">1 FF_MB_DECISION_BITS </span><br><span class="line">2 FF_MB_DECISION_RD</span><br><span class="line">-4mv 使用 4 个运动矢量 仅用于 mpeg4</span><br><span class="line">-part 使用数据划分 仅用于 mpeg4</span><br><span class="line">-bug param 绕过没有被自动监测到编码器的问题</span><br><span class="line">-strict strictness 跟标准的严格性</span><br><span class="line">-aic 使能高级帧内编码 h263+</span><br><span class="line">-umv 使能无限运动矢量 h263+</span><br><span class="line">-deinterlace 不采用交织方法</span><br><span class="line">-interlace 强迫交织法编码 仅对 mpeg2 和 mpeg4 有效。当你的输入是交织的并且你想要保持交织以最小图像损失的时候采用该选项。可选的方法是不交织，但是损失更大</span><br><span class="line">-psnr 计算压缩帧的 psnr</span><br><span class="line">-vstats 输出视频编码统计到 vstats_hhmmss.log</span><br><span class="line">-vhook module 插入视频处理模块 module 包括了模块名和参数，用空格分开</span><br></pre></td></tr></table></figure><h3 id="音频选项"><a href="#音频选项" class="headerlink" title="音频选项"></a>音频选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-ab bitrate 设置音频码率</span><br><span class="line">-ar freq 设置音频采样率</span><br><span class="line">-ac channels 设置通道 缺省为 1</span><br><span class="line">-an 不使能音频纪录</span><br><span class="line">-acodec codec 使用 codec 编解码</span><br></pre></td></tr></table></figure><h3 id="音频-视频捕获选项"><a href="#音频-视频捕获选项" class="headerlink" title="音频/视频捕获选项"></a>音频/视频捕获选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-vd device 设置视频捕获设备。比如/dev/video0</span><br><span class="line">-vc channel 设置视频捕获通道 DV1394 专用</span><br><span class="line">-tvstd standard 设置电视标准 NTSC PAL(SECAM)</span><br><span class="line">-dv1394 设置 DV1394 捕获</span><br><span class="line">-av device 设置音频设备 比如/dev/dsp</span><br></pre></td></tr></table></figure><h3 id="高级选项"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-map file:stream 设置输入流映射</span><br><span class="line">-debug 打印特定调试信息</span><br><span class="line">-benchmark 为基准测试加入时间</span><br><span class="line">-hex 倾倒每一个输入包</span><br><span class="line">-bitexact 仅使用位精确算法 用于编解码测试</span><br><span class="line">-ps size 设置包大小，以 bits 为单位</span><br><span class="line">-re 以本地帧频读数据，主要用于模拟捕获设备</span><br><span class="line">-loop 循环输入流。只工作于图像流，用于 ffserver 测试</span><br></pre></td></tr></table></figure><h3 id="FFmpeg-参数实例"><a href="#FFmpeg-参数实例" class="headerlink" title="FFmpeg 参数实例"></a>FFmpeg 参数实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg -y -i /rootVideoConverter/123.avi -ab 56 -ar 22050 -b 1500 -r 15 -qscale 10 –s 480x350 /root/VideoConverter/234.flv</span></span><br><span class="line">============================================================</span><br><span class="line">-y （覆盖输出文件，即如果 1.***文件已经存在的话，不经提示就覆盖掉了）</span><br><span class="line">-i "1.avi"（输入文件是和 ffmpeg 在同一目录下的 1.avi 文件，可以自己加路径，改名字）</span><br><span class="line">-s （输出的分辨率，注意片源一定要是 16:9 的不然会变形）</span><br><span class="line">-r （帧数，一般就用这个吧）</span><br><span class="line">-b 1500（视频数据流量，用-b xxxx 的指令则使用固定码率，数字随便改，1500 以上没效果；</span><br><span class="line">还可以用动态码率如：-qscale 4 和-qscale 6，4 的质量比 6 高）</span><br><span class="line">-acodec aac（音频编码用 AAC）</span><br><span class="line">-ac 2 （声道数 1 或 2）</span><br><span class="line">-ar 24000（声音的采样频率，好像 PSP 只能支持 24000Hz）</span><br><span class="line">-ab 128 （ 音频数据流量，一般选择 32、64、96、128）</span><br><span class="line">-vol 200（200%的音量，自己改）</span><br><span class="line">-f psp （输出 psp 专用格式）</span><br><span class="line">-muxvb 768（给 PSP 机器识别的码率，一般选择 384、512 和 768）</span><br><span class="line">-ab bitrate 设置音频码率</span><br><span class="line">-ar freq 设置音频采样率</span><br><span class="line">-ss 指定时间点开始转换任务，(time_off set the start time offset)，-ss 后跟的时间单位为秒 .</span><br><span class="line">-s 320x240 指定分辨率</span><br><span class="line">-r 29.97 桢速率</span><br><span class="line">-bitexact 使用标准比特率</span><br><span class="line">-vcodec xvid 使用 xvid 压缩</span><br></pre></td></tr></table></figure><h2 id="FFmpeg-支持能力说明-1"><a href="#FFmpeg-支持能力说明-1" class="headerlink" title="FFmpeg 支持能力说明"></a>FFmpeg 支持能力说明</h2><h3 id="FFmpeg-对编码解码器的支持"><a href="#FFmpeg-对编码解码器的支持" class="headerlink" title="FFmpeg 对编码解码器的支持"></a>FFmpeg 对编码解码器的支持</h3><p>ffmpeg 支持的编解码器种类共有 280 多种，涵盖了几乎所有常见音视频编码格式，能解码几乎所有的音视频，每种音视频编解码器的实现都在 libavcodec 目录下有具体的C 语言实现，具体的支持情况参见：</p><blockquote><p><a href>ffmpeg支持的编解码器</a></p></blockquote><p>注：编码器和解码器的名称不是完全匹配的，因此有些编码器没有对应相同名称的解码器，反之，<br>解码器也一样。即使编码和解码都支持也不一定是完全对应的，例如 h263 解码器对应有 h263p 和 h263 编码器。</p><h3 id="FFmpeg-对容器格式的支持"><a href="#FFmpeg-对容器格式的支持" class="headerlink" title="FFmpeg 对容器格式的支持"></a>FFmpeg 对容器格式的支持</h3><p>ffmpeg 支持对绝大多数的容器格式的读写操作，共计 190 多种，涵盖了互联网上各种常见媒体格式及日常生活中及专业应用中的各种媒体格式。详细的支持情况参见：</p><blockquote><p><a href>FFmpeg支持的媒体文件格式</a></p></blockquote><h3 id="FFmpeg-对过滤器的支持"><a href="#FFmpeg-对过滤器的支持" class="headerlink" title="FFmpeg 对过滤器的支持"></a>FFmpeg 对过滤器的支持</h3><table><thead><tr><th>Filters</th><th>说明</th></tr></thead><tbody><tr><td>aformat</td><td>Convert the input audio to one of the specified formats.</td></tr><tr><td>anull</td><td>Pass the source unchanged to the output.</td></tr><tr><td>aresample</td><td>Resample audio data.</td></tr><tr><td>ashowinfo</td><td>Show textual information for each audio frame.</td></tr><tr><td>abuffer</td><td>Buffer audio frames， and make them accessible to the filterchain.</td></tr><tr><td>anullsrc</td><td>Null audio source， never return audio frames.</td></tr><tr><td>abuffersink</td><td>Buffer audio frames， and make them available to the end of the filter graph.</td></tr><tr><td>anullsink</td><td>Do absolutely nothing with the input audio.</td></tr><tr><td>copy</td><td>Copy the input video unchanged to the output.</td></tr><tr><td>crop</td><td>Crop the input video to <code>width:height:x:y</code>.</td></tr><tr><td>drawbox</td><td>Draw a colored box on the input video.</td></tr><tr><td>fade</td><td>Fade in/out input video</td></tr><tr><td>fieldorder</td><td>Set the field order.</td></tr><tr><td>fifo</td><td>Buffer input images and send them when they are requested.</td></tr><tr><td>format</td><td>Convert the input video to one of the specified pixel formats.</td></tr><tr><td>gradfun</td><td>Debands video quickly using gradients.</td></tr><tr><td>hflip</td><td>Horizontally flip the input video.</td></tr><tr><td>lut</td><td>Compute and apply a lookup table to the RGB/YUV input video.</td></tr><tr><td>lutrgb</td><td>Compute and apply a lookup table to the RGB input video.</td></tr><tr><td>lutyuv</td><td>Compute and apply a lookup table to the YUV input video.</td></tr><tr><td>negate</td><td>Negate input video.</td></tr><tr><td>noformat</td><td>Force libavfilter not to use any of the specified pixel formats for the input to the next filter.</td></tr><tr><td>null</td><td>Pass the source unchanged to the output.</td></tr><tr><td>overlay</td><td>Overlay a video source on top of the input.</td></tr><tr><td>pad</td><td>Pad input image to <code>width:height[:x:y[:color]] (default x and y: 0， default color: black)</code>.</td></tr><tr><td>pixdesctest</td><td>Test pixel format definitions.</td></tr><tr><td>scale</td><td>Scale the input video to width:height size and/or convert the image format.</td></tr><tr><td>select</td><td>Select frames to pass in output.</td></tr><tr><td>setdar</td><td>Set the frame display aspect ratio.</td></tr><tr><td>setpts</td><td>Set PTS for the output video frame.</td></tr><tr><td>setsar</td><td>Set the pixel sample aspect ratio.</td></tr><tr><td>settb</td><td>Set timebase for the output link.</td></tr><tr><td>showinfo</td><td>Show textual information for each video frame.</td></tr><tr><td>slicify</td><td>Pass the images of input video on to next video filter as multiple slices.</td></tr><tr><td>split</td><td>Pass on the input to two outputs.</td></tr><tr><td>transpose</td><td>Transpose input video.</td></tr><tr><td>unsharp</td><td>Sharpen or blur the input video.</td></tr><tr><td>vflip</td><td>Flip the input video vertically.</td></tr><tr><td>buffer</td><td>Buffer video frames， and make them accessible to the filterchain.</td></tr><tr><td>color</td><td>Provide an uniformly colored input， syntax is: [color[:size[:rate]]]</td></tr><tr><td>movie</td><td>Read from a movie source.</td></tr><tr><td>nullsrc</td><td>Null video source， never return images.</td></tr><tr><td>rgbtestsrc</td><td>Generate RGB test pattern.</td></tr><tr><td>testsrc</td><td>Generate test pattern.</td></tr><tr><td>buffersink</td><td>Buffer video frames， and make them available to the end of the filter graph.</td></tr><tr><td>nullsink</td><td>Do absolutely nothing with the input video.</td></tr></tbody></table><h3 id="FFmpeg-对图像颜色空间的支持"><a href="#FFmpeg-对图像颜色空间的支持" class="headerlink" title="FFmpeg 对图像颜色空间的支持"></a>FFmpeg 对图像颜色空间的支持</h3><p>ffmpeg 支持常见的图像颜色空间，并且在 libavswcale 中定义了颜色空间转换的相关函数实现各种颜色模式的互转。具体的支持情况见:</p><blockquote><p><a href>FFmpeg支持的图像颜色空间</a></p></blockquote><h2 id="FFmpeg-功能及使用说明"><a href="#FFmpeg-功能及使用说明" class="headerlink" title="FFmpeg 功能及使用说明"></a>FFmpeg 功能及使用说明</h2><h3 id="ffplay-对多媒体的支持能力验证"><a href="#ffplay-对多媒体的支持能力验证" class="headerlink" title="ffplay 对多媒体的支持能力验证"></a>ffplay 对多媒体的支持能力验证</h3><p><strong>一、视频</strong></p><p><code>3gp 177X144</code> 支持播放，在 windows 下播放正常，但是在 linux 下面偶有 BUG 如果发现画面无法显示而声音可以播放的情况下 可以试着切换全屏或者切换分辨率。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AVI 208X176 支持</span><br><span class="line"> 320X240 支持</span><br><span class="line"> 720X400 支持</span><br><span class="line"> 720X576 支持</span><br><span class="line">DAT 352X288 支持</span><br><span class="line">DiVX 720X576 支持</span><br><span class="line">MKV 320X240 支持</span><br><span class="line">352X288 支持</span><br><span class="line"> 704X304 支持</span><br><span class="line"> 720X576 支持</span><br><span class="line">MP4 320X240 支持</span><br><span class="line">352X288 支持</span><br><span class="line">        720X400 支持</span><br><span class="line">MPG 320X240 支持</span><br><span class="line"> 352X288 支持</span><br><span class="line"> 480X576 支持</span><br><span class="line"> 720X576 支持</span><br><span class="line"> 720X480 支持</span><br><span class="line">VOB 352X288 支持</span><br><span class="line">XVID 720X576 支持</span><br><span class="line">MOV 支持</span><br><span class="line">RMVB 支持</span><br></pre></td></tr></table></figure><p><strong>二、音频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">AC3 48KHZ 支持</span><br><span class="line">APE 11KHZ 支持</span><br><span class="line"> 22KHZ 支持</span><br><span class="line"> 44KHZ 支持</span><br><span class="line"> 48KHZ 支持</span><br><span class="line">MP3 32KHZ 64Kbps 支持</span><br><span class="line">        32KHZ 128KbpS 支持</span><br><span class="line">        32KHZ 160Kbps 支持</span><br><span class="line">        32KHZ 192Kbps 支持</span><br><span class="line">        32KHZ 320Kbps 支持</span><br><span class="line">        44KHZ64Kbps 支持</span><br><span class="line">        44KHZ 128Kbps 支持</span><br><span class="line">        44KHZ 160Kbps 支持</span><br><span class="line">        44KHZ 192Kbps 支持</span><br><span class="line">        44KHZ 320Kbps 支持</span><br><span class="line">        48KHZ 64Kbps 支持</span><br><span class="line">        48KHZ 128Kbps 支持</span><br><span class="line">        48KHZ 160Kbps 支持</span><br><span class="line">        48KHZ 192Kbps 支持</span><br><span class="line">        48KHZ 320Kbps 支持</span><br><span class="line">OGG 32KHZ 128Kbps 支持</span><br><span class="line">        32KHZ 192Kbps 支持</span><br><span class="line">        44KHZ 64Kbps 支持</span><br><span class="line">        44KHZ 128Kbps 支持</span><br><span class="line">        44KHZ 192Kbps 支持</span><br><span class="line">        48KHZ 64Kbps 支持</span><br><span class="line">        44KHZ 128Kbps 支持</span><br><span class="line">        44KHZ 192Kbps 支持</span><br><span class="line">WAV 11KHZ 支持</span><br><span class="line">        22KHZ 16Kbps 支持</span><br><span class="line">        44KHZ 16Kbps 支持</span><br><span class="line">        48KHZ 16Kbps 支持</span><br><span class="line">WMA 8KHZ 16Kbps 支持</span><br><span class="line">        11KHZ 16Kbps 支持</span><br><span class="line">        16KHZ 16Kbps 支持</span><br><span class="line">        22KHZ 16Kbps 支持</span><br><span class="line">        44KHZ 16Kbps 支持</span><br><span class="line">        48KHZ 16Kbps 支持</span><br></pre></td></tr></table></figure><p><strong>三、图像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PNG 支持</span><br><span class="line">JPG 支持</span><br><span class="line">JPEG 支持</span><br><span class="line">GIF 支持</span><br><span class="line">BMP 支持</span><br></pre></td></tr></table></figure><h3 id="FFmpeg-格式转换"><a href="#FFmpeg-格式转换" class="headerlink" title="FFmpeg 格式转换"></a>FFmpeg 格式转换</h3><p><strong>第一步：准备媒体</strong></p><p>前面已经讲的很清楚了，ffmpeg 如何安装不在赘述。准备好相应的文件，如图 2-1所示。</p><p><img src="/images/imageFFmpeg/Thor/2-1.png" alt="图 2-1"></p><p><strong>第二步：启动 ffmpeg</strong></p><p>由于做的是格式转换，在 ffserver 上不能直观的看见结果，故我是在 linux 下进行的。打开终端，值得一提的是格式转换需要超级用户才能进行，故在命令行输入：<code>su，&lt;回车&gt;</code>，输入密码进入超级用户，本例中，以 FFmpeg 将 test.avi 转换为 test.mpg。在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg –i test.avi –r 25 –s 720x400 test.mpg</span></span><br></pre></td></tr></table></figure><p>其中原格式分辨率为 320x240，将转为 720x400，-r 前面已经解释其含义，表示设置帧频为 25。转换成功后如图 2-2 所示，前后两种格式播放效果如图 2-3 所示。相应的，转换为其他格式做相应的变化即可。</p><p>同时还可以在转换格式时进行强制的音视频转换，如 <code>–vcodec + 格式</code>，将会强制将视频按指定格式编码，<code>-acodec +格式</code>，将会强制按指定格式编码音频信息。在转换中有很多其他参数可以指定，如码率、分辨率、帧率等，具体按照 ffmpeg 的参数说明指定参数即可。但有一条转低不转高的原则需要注意，即品质差的音视频转换不建议转换到品质好的音视频。</p><p><img src="/images/imageFFmpeg/Thor/2-2.png" alt="图 2-2"></p><p><img src="/images/imageFFmpeg/Thor/2-3.png" alt="图 2-3"></p><p>再说说如何在转换视频的时候将音频合成到视频中，且覆盖其原来的音频。这个现在摸索出两种方法。</p><p><strong>方法一</strong>：需要两条命令实现，先在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg –i test.avi -an –r 25 test.mpg</span></span><br></pre></td></tr></table></figure><p>此时将生成一个没有声音的 test.mpg 视频，再在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg –i test.mpg –i test.mp3 –r 25 test1.mpg</span></span><br></pre></td></tr></table></figure><p>此时将会生成一个名为 test1.mpg 的视频。该视频播放时视频为 test.avi 的视频，但音频变为了 test.mp3 的音频了。</p><p><strong>方法二</strong>：只要一条指令即可实现。在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg –i test.avi –i test.mp3 –vcodec copy –acodec copy –r 25 test2.mpg</span></span><br></pre></td></tr></table></figure><p>此时将会生成一个名为 test2.mpg 的视频，播放时其视频为 test.avi 的视频，音频为 test.mp3。<code>–vcodec copy</code> 为 force video codec(‘copy’ to copy stream)。</p><p>有一点需要注意，文件命名不能有空格，否则会导致编译时不能通过。另外，<code>-an</code> 为不能使音频记录。</p><p><strong>第三步：播放媒体</strong></p><p>播放我们转换的媒体，看看是否满足我们当初的愿望，不出什么差错的话，是完全能够满足我们的要求的。</p><h3 id="FFmpeg-视频截图"><a href="#FFmpeg-视频截图" class="headerlink" title="FFmpeg 视频截图"></a>FFmpeg 视频截图</h3><p>截取一张 <code>300x200</code> 尺寸大小的格式为 jpg 的一张图片：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg –i test.avi –y –f image2 –t 0.001 –s 300x200 test.jpg</span></span><br></pre></td></tr></table></figure><p>要截取指定时间的图片，如 5 秒之后的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg –i test.avi –y –f image2 –ss 5 –t 0.001 –s 300x200 test.jpg</span></span><br></pre></td></tr></table></figure><p>其中，<code>-ss</code> 后的单位为秒，也可写成：<code>-ss 00:00:05</code>。</p><p>把视频的前 30 帧转换为一个动态的 gif 图。需要说明的是，转换成功之后，如果用 ffplay 播放是看不出效果的，建议换成其他图片播放器播放。其转换命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg –i test.avi –vframes 30 –pix_fmt rgb24–y –f gif test.gif</span></span><br></pre></td></tr></table></figure><p>也可以从视频中的第 10 秒开始截取后面的 5 秒内容转换为一个无限重播的动态 gif 图。其命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg –i test.avi –pix_fmt rgb24 –ss 10 –t 5 –y –f gif test.gif</span></span><br></pre></td></tr></table></figure><p>上面两种动态 gif 都是只播一次，想让其一直播，可再加一个参数：<code>-loop_output 0</code>。</p><h3 id="FFmpeg-屏幕录制"><a href="#FFmpeg-屏幕录制" class="headerlink" title="FFmpeg 屏幕录制"></a>FFmpeg 屏幕录制</h3><p>屏幕录制其命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg -f x11grab -r 25 -s wxga -i :0.0 /tmp/outputFile.mpg</span></span><br></pre></td></tr></table></figure><p>其他相关参数可自行添加。需要说明的是，各个版本的 ffmpeg 对屏幕录制的命令不一。如果你只想录制一个应用程序窗口或者桌面上的一个固定区域，那么可以指定偏移位置和区域大小。使用 <code>xwininfo -frame</code> 命令可以完成查找上述参数。</p><p>注：ffmpeg 的屏幕录制功能只能在 Linux 环境下有效。并且在配置时需要添加 <code>–enable-x11grub</code> 指令，默认关闭。</p><h3 id="FFmpeg-音视频采集"><a href="#FFmpeg-音视频采集" class="headerlink" title="FFmpeg 音视频采集"></a>FFmpeg 音视频采集</h3><p>把摄像头的实时视频录制下来，存储为文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg -f video4linux -s 320x240 -r 10 -i /dev/video0 test.asf</span></span><br></pre></td></tr></table></figure><p>录音，其命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg –i /dev/dsp -f oss test.mp3</span></span><br></pre></td></tr></table></figure><h2 id="FFmpeg-应用实例"><a href="#FFmpeg-应用实例" class="headerlink" title="FFmpeg 应用实例"></a>FFmpeg 应用实例</h2><h3 id="用-FFserver-从文件生成流媒体"><a href="#用-FFserver-从文件生成流媒体" class="headerlink" title="用 FFserver 从文件生成流媒体"></a>用 FFserver 从文件生成流媒体</h3><p><strong>一、安装 ffmpeg</strong></p><p>在 ubuntu 下，运行 <code>sudo apt-get ffmpeg</code> 安装 ffmpeg，在其他 linux 操作系统下，见 ffmpeg 的编译过程（编译完成后可执行自动安装）。</p><p><strong>二、准备预播放的媒体文件</strong></p><p>如 test.Mp3，在本文档中，默认放入用户文件夹下得 Music 文件夹内.(直接从设备采集不在本文档叙述范围之内)</p><p><strong>三、修改 ffserver 配置信息</strong></p><p>ffserver 配置文件为: <code>/etc/ffserver.conf</code> 打开，填写配置信息.配置信息包括三方面:</p><p>（1）端口绑定等基本信息，在 ·/etc/ffserver.conf· 中有详细注释，在此不再重复，最终配置信息为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Port 8090</span><br><span class="line">BindAddress 0.0.0.0</span><br><span class="line">MaxHTTPConnections 2000</span><br><span class="line">MaxClients 1000</span><br><span class="line">MaxBandwidth 1000</span><br></pre></td></tr></table></figure><p>（2）媒体文件配置信息.本信息根据具体的媒体文件类型直接在配置文件中取消注释掉相应文件类型的配置信息，然后填写文件路径即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> MP3 audio</span></span><br><span class="line">&lt;Stream test.mp3&gt;</span><br><span class="line">File "/home/xiaoma/Music/test.mp3"</span><br><span class="line">Format mp2</span><br><span class="line">NoVideo</span><br><span class="line">&lt;/Stream&gt;</span><br></pre></td></tr></table></figure><p><strong>四、启动 ffserver</strong></p><p>在终端中运行: <code>sudo ffserver -f /etc/ffserver.conf</code>  启动 ffserver.</p><p><strong>五、播放流媒体</strong></p><p>在浏览器中输入 <a href>http://127.0.0.1:8090/test.mp3</a> 即可播放音乐.</p><p>在终端中输入 <code>ffplay http://localhost:8090/test.mp3</code> 可播放流媒体.</p><h3 id="用-FFserver-从设备生成实时流"><a href="#用-FFserver-从设备生成实时流" class="headerlink" title="用 FFserver 从设备生成实时流"></a>用 FFserver 从设备生成实时流</h3><p><strong>一、准备媒体</strong></p><p>按照上节步骤安装 ffmpeg，保证摄像头和声卡可用，将从摄像头和声卡获取音视频信息。</p><p><strong>二、修改 ffserver 配置信息</strong></p><p>ffserver 配置文件为: <code>/etc/ffserver.conf</code> 打开，填写配置信息.配置信息包括三方面:</p><p>（1）端口绑定等基本信息，在 <code>/etc/ffserver.conf</code> 中有详细注释，在此不再重复，最终配<br>置信息为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Port 8090</span><br><span class="line">BindAddress 0.0.0.0</span><br><span class="line">MaxHTTPConnections 2000</span><br><span class="line">MaxClients 1000</span><br><span class="line">MaxBandwidth 1000</span><br></pre></td></tr></table></figure><p>（2）fend(传冲信息)，在文件播放中，基本不用动本配置信息，只需要根据具体情况分配缓冲文件.最终配置信息如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Feed feed1.ffm&gt;</span><br><span class="line">File /tmp/feed1.ffm</span><br><span class="line">FileMaxSize 2M</span><br><span class="line">ACL allow 127.0.0.1</span><br><span class="line">&lt;/Feed&gt;</span><br></pre></td></tr></table></figure><p>（3）媒体文件配置信息.本信息根据具体的媒体文件类型直接在配置文件中取消注释掉相应文件类型的配置信息，然后填写文件路径即可:</p><p>(中间会有很多很多配置信息，都是关于音视频的，有些配置还不懂，慢慢摸索吧)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;Stream test1.mpg&gt;</span><br><span class="line">Feed feed1.ffm</span><br><span class="line">Format mpeg</span><br><span class="line">AudioBitRate 32</span><br><span class="line">AudioChannels 1</span><br><span class="line">AudioSampleRate 44100</span><br><span class="line">VideoBitRate 64</span><br><span class="line">VideoBufferSize 40</span><br><span class="line">VideoFrameRate 3</span><br><span class="line">VideoSize 160x128</span><br><span class="line">VideoGopSize 12</span><br><span class="line">&lt;/Stream&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Flash</span></span><br><span class="line">&lt;Stream test.swf&gt;</span><br><span class="line">Feed feed1.ffm</span><br><span class="line">Format swf</span><br><span class="line">VideoFrameRate 2</span><br><span class="line">VideoIntraOnly</span><br><span class="line">NoAudio</span><br><span class="line">&lt;/Stream&gt;</span><br></pre></td></tr></table></figure><p><strong>三、启动 FFserver</strong></p><p>在终端中运行: <code>sudo ffserver -f /etc/ffserver.conf</code> 启动 ffserver.</p><p><strong>四、启动 ffmpeg</strong></p><p>本例中，以 ffmpeg 作为实时摄像头采集输入.在命令行中输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg -f video4linux2 -r 25 -i /dev/video0 /tmp/feed1.ffm</span></span><br></pre></td></tr></table></figure><p>如果有音频设备，则采集音频的命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ffmpeg -f oss -i /dev/dsp -f video4linux2 -r 25 -i /dev/video0 /tmp/feed1.ffm</span></span><br></pre></td></tr></table></figure><p>(音频格式参数自己配置)</p><p><strong>五、播放流媒体</strong></p><p>在浏览器中输入 <a href>http://127.0.0.1:8090/test1.mpg</a> 即可播放音乐.</p><p>在终端中输入 <code>ffplay http://localhost:8090/test.swf</code> 可播放流媒体.</p><h1 id="FFmpeg-架构"><a href="#FFmpeg-架构" class="headerlink" title="FFmpeg 架构"></a>FFmpeg 架构</h1><h2 id="FFmpeg-文件结构"><a href="#FFmpeg-文件结构" class="headerlink" title="FFmpeg 文件结构"></a>FFmpeg 文件结构</h2><p><img src="/images/imageFFmpeg/Thor/markdown-table.png" alt="markdown table"></p><table>    <tr>        <td>目录</td>        <td>文件</td>        <td>简要说明</td>    </tr>    <tr>        <td rowspan="14">            <font style="color:red;font-weight:bold;">libavformat</font> <br><br>            主要存放ffmpeg<br>            支持的各种编解码<br>            器的实现及ffmpeg<br>            编解码功能相关的<br>            数据结构定义及函<br>            数定义和声明        </td>           <td>allcodecs.c</td>        <td>简单的注册类函数</td>    </tr>    <tr>        <td>avcodec.h</td>        <td>编解码相关结构体定义和函数原型声明</td>    </tr>    <tr>        <td>dsputil.c</td>        <td>限幅数组初始化</td>    </tr>    <tr>        <td>dsputil.h</td>        <td>限幅数组声明</td>    </tr>    <tr>        <td>imgconvert.c</td>        <td>颜色空间转换相关函数实现</td>    </tr>    <tr>        <td>imgconvert_template.h</td>        <td>颜色空间转换相关结构体定义和函数声明</td>    </tr>    <tr>        <td>utils_codec.c </td>        <td>一些解码相关的工具类函数的实现</td>    </tr>    <tr>        <td>mpeg4audio.c</td>        <td>mpeg4 音频编解码器的函数实现</td>    </tr>    <tr>        <td>mpeg4audio.h</td>        <td>mpeg4 音频编解码器的函数声明</td>    </tr>    <tr>        <td>mpeg4data.h</td>        <td>mpeg4 音视频编解码器的公用的函数声明及数据结构定义</td>    </tr>    <tr>        <td>mpeg4video.c </td>        <td>mpeg4 视频编解码器的函数实现</td>    </tr>    <tr>        <td>mpeg4video.h</td>        <td>mpeg4 视频编解码器的函数的声明及先关数据结构的定义</td>    </tr>    <tr>        <td>mpeg4videodec.c</td>        <td>mpeg4 视频解码器的函数实现</td>    </tr>    <tr>        <td>mpeg4videoenc.c</td>        <td>mpeg4 视频编码器的函数实现</td>    </tr>    <tr>        <td rowspan="14">            <font style="color:red;font-weight:bold;">libavformat</font> <br><br>            主要存放ffmpeg支<br>            持的各种媒体格式<br>            MUXER/DEMUXER<br>            和数据流协议的定<br>            义和实现文件以及<br>            ffmpeg解复用相<br>            关的数据结构及<br>            函数定        </td>           <td>allformats.c</td>        <td>简单注册类函数</td>    </tr>    <tr>        <td>avformat.h</td>        <td>文件和媒体格式相关函数声明和数据结构定义</td>    </tr>    <tr>        <td>avio.c</td>        <td>无缓冲 IO 相关函数实现</td>    </tr>    <tr>        <td>avio.h</td>        <td>无缓冲 IO 相关结构定义和函数声明</td>    </tr>    <tr>        <td>aviobuf.c</td>        <td>有缓冲数据 IO 相关函数实现</td>    </tr>    <tr>        <td>cutils.c</td>        <td>简单的字符串操作函数</td>    </tr>    <tr>        <td>utils_format.c</td>        <td>文件和媒体格式相关的工具函数的实现</td>    </tr>    <tr>        <td>file.c</td>        <td>文件 io 相关函数</td>    </tr>    <tr>        <td>......</td>        <td>其他相关媒体流 IO 的函数和数据结构实现文件。如：rtsp、http 等。</td>    </tr>    <tr>        <td>avi.c</td>        <td>AVI 格式的相关函数定西</td>    </tr>    <tr>        <td>avi.h</td>        <td>AVI 格式的相关函数声明及数据结构定义</td>    </tr>    <tr>        <td>avidec.c</td>        <td>AVI 格式 DEMUXER 相关函数定义</td>    </tr>    <tr>        <td>avienc.c</td>        <td>AVI 格式 MUXER 相关函数定义</td>    </tr>    <tr>        <td>......</td>        <td>其他媒体格式的 muxer/demuxer 相关函数及数据结构定义和声明文件</td>    </tr>    <tr>        <td rowspan="14">            <font style="color:red;font-weight:bold;">libavutil</font> <br><br>            主要存放ffmpeg<br>            工具类函数的定义        </td>           <td>avutil.h</td>        <td>简单的像素格式宏定义</td>    </tr>    <tr>        <td>bswap.h</td>        <td>简单的大小端转换函数的实现</td>    </tr>    <tr>        <td>commom.h</td>        <td>公共的宏定义和简单函数的实现</td>    </tr><tr>        <td>mathematics.c</td>        <td>数学运算函数实现</td>    </tr>    <tr>        <td>rational.h</td>        <td>分数相关表示的函数实现</td>    </tr></table><h2 id="I-O-模块分析"><a href="#I-O-模块分析" class="headerlink" title="I\O 模块分析"></a>I\O 模块分析</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ffmpeg 项目的数据 IO 部分主要是在 libavformat 库中实现，某些对于内存的操作部分在 libavutil 库中。数据 IO 是基于文件格式（Format）以及文件传输协议(Protocol)的，与具体的编解码标准无关。</p><p>ffmpeg 工程转码时数据 IO 层次关系如图所示：</p><p><img src="/images/imageFFmpeg/Thor/ffmpeg%E8%BD%AC%E7%A0%81%E6%95%B0%E6%8D%AEIO%E6%B5%81%E7%A8%8B.png" alt="ffmpeg转码数据IO流程"></p><p>对于上面的数据 IO 流程，具体可以用下面的例子来说明，我们从一个 http 服务器获取音视频数据，格式是 flv 的，需要通过转码后变成 avi 格式，然后通过 udp 协议进行发布。其过程就如下所示：</p><ul><li>读入 http 协议数据流，根据 http 协议获取真正的文件数据（去除无关报文信息）；</li><li>根据 flv 格式对数据进行解封装；</li><li>读取帧进行转码操作；</li><li>按照目标格式 avi 进行封装；</li><li>通过 udp 协议发送出去。</li></ul><h3 id="相关数据结构介绍"><a href="#相关数据结构介绍" class="headerlink" title="相关数据结构介绍"></a>相关数据结构介绍</h3><p>在 libavformat 库中与数据 IO 相关的数据结构主要有 URLProtocol、URLContext、ByteIOContext、AVFormatContext 等，各结构之间的关系如图所示。</p><p><img src="/images/imageFFmpeg/Thor/libavformat%E5%BA%93%E4%B8%ADIO%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="libavformat库中IO相关数据结构之间的关系"></p><p><strong>1、URLProtocol 结构</strong></p><p>表示广义的输入文件，该结构体提供了很多的功能函数，每一种广义的输入文件（如：file、pipe、tcp、rtp 等等）对应着一个 <code>URLProtocol</code> 结构，在 <code>av_register_all()</code> 中将该结构体初始化为一个链表，表头为 <code>avio.c</code> 里的 <code>URLProtocol *first_protocol = NULL;</code> 保存所有支持的输入文件协议，该结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> (*url_open)(URLContext *h， <span class="keyword">const</span> <span class="keyword">char</span> *url， <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_read)(URLContext *h， <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf， <span class="keyword">int</span> size);</span><br><span class="line">    <span class="keyword">int</span> (*url_write)(URLContext *h， <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf， <span class="keyword">int</span> size);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_seek)(URLContext *h， <span class="keyword">int64_t</span> pos， <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int</span> (*url_close)(URLContext *h);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> (*url_read_pause)(URLContext *h， <span class="keyword">int</span> pause);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_read_seek)(URLContext *h， <span class="keyword">int</span> stream_index，</span><br><span class="line">                             <span class="keyword">int64_t</span> timestamp， <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_file_handle)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> priv_data_size;</span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_data_class;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> (*url_check)(URLContext *h， <span class="keyword">int</span> mask);</span><br><span class="line">&#125; URLProtocol;</span><br></pre></td></tr></table></figure><p>注意到，<code>URLProtocol</code> 是一个链表结构，这是为了协议的统一管理，ffmpeg 项目中将所有的用到的协议都存放在一个全局变量 first_protocol 中，协议的注册是在 <code>av_register_all</code> 中完成的，新添加单个协议可以调用 <code>av_register_protocol2</code> 函数实现。而协议的注册就是将具体的协议对象添加至 <code>first_protocol</code> 链表的末尾。</p><p><code>URLProtocol</code> 在各个具体的文件协议中有一个具体的实例，如在 file 协议中定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URLProtocol ff_file_protocol = &#123;</span><br><span class="line">    .name = <span class="string">"file"</span>，</span><br><span class="line">.url_open = file_open，</span><br><span class="line">.url_read = file_read，</span><br><span class="line">    .url_write = file_write，</span><br><span class="line">    .url_seek = file_seek，</span><br><span class="line">    .url_close = file_close，</span><br><span class="line">    .url_get_file_handle = file_get_handle，</span><br><span class="line">    .url_check = file_check，</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2、URLContext 结构</strong></p><p>URLContext 提供了与当前打开的具体的文件协议（URL）相关数据的描述，在该结构中定义了指定当前 URL（即 filename 项）所要用到的具体的 URLProtocol，即：提供了一个在 URLprotocol 链表中找到具体项的依据，此外还有一些其它的标志性的信息，如 flags， is_streamed 等。它可以看成某一种协议的载体。其结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLContext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class; <span class="comment">///&lt; information for av_log(). Set by url_open().</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> *<span class="title">prot</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> is_streamed; <span class="comment">/**&lt; true if streamed (no seek possible)， default = false */</span></span><br><span class="line">    <span class="keyword">int</span> max_packet_size; <span class="keyword">void</span> *priv_data;</span><br><span class="line">    <span class="keyword">char</span> *filename; <span class="comment">/**&lt; specified URL */</span></span><br><span class="line">    <span class="keyword">int</span> is_connected;</span><br><span class="line">&#125; URLContext;</span><br></pre></td></tr></table></figure><p>那么 ffmpeg 依据什么信息初始化 URLContext？然后又是如何初始化 URLContext的呢？</p><p>在打开一个 URL 时，全局函数 ffurl_open 会根据 filename 的前缀信息来确定 URL所使用的具体协议，并为该协议分配好资源，再调用 ffurl_connect 函数打开具体协议，即调用协议的 url_open，调用关系如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_open_input_file</span><span class="params">(AVFormatContext **ic_ptr， <span class="keyword">const</span> <span class="keyword">char</span> *filename，</span></span></span><br><span class="line"><span class="function"><span class="params"> AVInputFormat *fmt，<span class="keyword">int</span> buf_size，AVFormatParameters *ap)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps ， <span class="keyword">const</span> <span class="keyword">char</span> *filename ，</span></span></span><br><span class="line"><span class="function"><span class="params">AVInputFormat *fmt， AVDictionary **options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_input</span><span class="params">(AVFormatContext *s， <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avio_open</span><span class="params">(AVIOContext **s， <span class="keyword">const</span> <span class="keyword">char</span> *filename， <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffurl_open</span><span class="params">(URLContext **puc， <span class="keyword">const</span> <span class="keyword">char</span> *filename， <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffurl_alloc</span><span class="params">(URLContext **puc， <span class="keyword">const</span> <span class="keyword">char</span> *filename， <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">url_alloc_for_protocol</span><span class="params">(URLContext **puc， struct URLProtocol *up，</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *filename， <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure><p>浅蓝色部分的函数完成了 URLContext 函数的初始化，URLContext 使 ffmpeg 外所暴露的接口是统一的，而不是对于不同的协议用不同的函数，这也是面向对象思维的体现。在此结构中还有一个值得说的是 priv_data 项，这是结构的一个可扩展项，具体协议可以根据需要添加相应的结构，将指针保存在这就行。</p><p><strong>3、AVIOContext 结构</strong></p><p>AVIOContext（即：ByteIOContext）是由 URLProtocol 和 URLContext 结构扩展而来，也是 ffmpeg 提供给用户的接口，它将以上两种不带缓冲的读取文件抽象为带缓冲的读取和写入，为用户提供带缓冲的读取和写入操作。数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer; <span class="comment">/**&lt; Start of the buffer. */</span></span><br><span class="line">    <span class="keyword">int</span> buffer_size; <span class="comment">/**&lt; Maximum buffer size */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_ptr; <span class="comment">/**&lt; Current position in the buffer */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_end;</span><br><span class="line">    <span class="keyword">void</span> *opaque; <span class="comment">//关联 URLContext</span></span><br><span class="line">    <span class="keyword">int</span> (*read_packet)(<span class="keyword">void</span> *opaque， <span class="keyword">uint8_t</span> *buf， <span class="keyword">int</span> buf_size);</span><br><span class="line">    <span class="keyword">int</span> (*write_packet)(<span class="keyword">void</span> *opaque， <span class="keyword">uint8_t</span> *buf， <span class="keyword">int</span> buf_size);</span><br><span class="line">    <span class="keyword">int64_t</span> (*seek)(<span class="keyword">void</span> *opaque， <span class="keyword">int64_t</span> offset， <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int64_t</span> pos;</span><br><span class="line">    <span class="keyword">int</span> must_flush;</span><br><span class="line">    <span class="keyword">int</span> eof_reached; <span class="comment">/**&lt; true if eof reached */</span></span><br><span class="line">    <span class="keyword">int</span> write_flag; <span class="comment">/**&lt; true if open for writing */</span></span><br><span class="line">    <span class="keyword">int</span> max_packet_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> checksum;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *checksum_ptr;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*update_checksum)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> checksum， <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf，</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> (*read_pause)(<span class="keyword">void</span> *opaque， <span class="keyword">int</span> pause);</span><br><span class="line">  <span class="keyword">int64_t</span> (*read_seek)(<span class="keyword">void</span> *opaque， <span class="keyword">int</span> stream_index，<span class="keyword">int64_t</span> timestamp，<span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> seekable;</span><br><span class="line">&#125; AVIOContext;</span><br></pre></td></tr></table></figure><p>结构简单的为用户提供读写容易实现的四个操作，read_packet write_packet read_pause read_seek，极大的方便了文件的读取，四个函数在加了缓冲机制后被中转到，URLContext 指向的实际的文件协议读写函数中。</p><p>下面给出 0.8 版本中是如何将 AVIOContext 的读写操作中转到实际文件中的。</p><p>在 avio_open（）函数中调用了 ffio_fdopen（）函数完成了对 AVIOContex 的初始化，其调用过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avio_open</span><span class="params">(AVIOContext **s， <span class="keyword">const</span> <span class="keyword">char</span> *filename， <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="title">ffio_fdopen</span><span class="params">(s， h)</span></span>; <span class="comment">//h 是 URLContext 指针</span></span><br><span class="line">ffio_init_context(*s， buffer， buffer_size，h-&gt;flags &amp; AVIO_FLAG_WRITE， h，</span><br><span class="line">(<span class="keyword">void</span>*)ffurl_read，(<span class="keyword">void</span>*)ffurl_write，(<span class="keyword">void</span>*)ffurl_seek)</span><br></pre></td></tr></table></figure><p>函数调用完成了对 AVIOContext 的初始化，在初始化的过程中，将AVIOContext 的 read_packet 、 write_packet 、 seek 分别初始化为： ffurl_read ffurl_write ffurl_seek ， 而这三个函数又将具体的读写操作中转为：</p><p><code>h-&gt;prot-&gt;url_read、h-&gt;prot-&gt;url_write、h-&gt;prot-&gt;url_seek</code>，另外两个变量初始化时也被相应的中转，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*s)-&gt;read_pause = (<span class="keyword">int</span> (*)(<span class="keyword">void</span> *， <span class="keyword">int</span>))h-&gt;prot-&gt;url_read_pause;</span><br><span class="line">(*s)-&gt;read_seek = (<span class="keyword">int64_t</span> (*)(<span class="keyword">void</span> *， <span class="keyword">int</span>， <span class="keyword">int64_t</span>， <span class="keyword">int</span>))h-&gt;prot-&gt;url_read_seek;</span><br></pre></td></tr></table></figure><p>所以，可以简要的描述为：AVIOContext 的接口口是加了缓冲后的 URLProtocol 的函数接口。</p><p>在 aviobuf.c 中定义了一系列关于 ByteIOContext 这个结构体的函数，如下</p><p><strong>put_xxx 系列：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_byte</span><span class="params">(ByteIOContext *s， <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_buffer</span><span class="params">(ByteIOContext *s， <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf， <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_le64</span><span class="params">(ByteIOContext *s， <span class="keyword">uint64_t</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_be64</span><span class="params">(ByteIOContext *s， <span class="keyword">uint64_t</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_le32</span><span class="params">(ByteIOContext *s， <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_be32</span><span class="params">(ByteIOContext *s， <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_le24</span><span class="params">(ByteIOContext *s， <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_be24</span><span class="params">(ByteIOContext *s， <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_le16</span><span class="params">(ByteIOContext *s， <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_be16</span><span class="params">(ByteIOContext *s， <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_tag</span><span class="params">(ByteIOContext *s， <span class="keyword">const</span> <span class="keyword">char</span> *tag)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>get_xxx 系列：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_buffer</span><span class="params">(ByteIOContext *s， <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf， <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_partial_buffer</span><span class="params">(ByteIOContext *s， <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf， <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_byte</span><span class="params">(ByteIOContext *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_le24</span><span class="params">(ByteIOContext *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_le32</span><span class="params">(ByteIOContext *s)</span></span>;</span><br><span class="line"><span class="keyword">uint64_t</span> get_le64(ByteIOContext *s);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_le16</span><span class="params">(ByteIOContext *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_strz</span><span class="params">(ByteIOContext *s， <span class="keyword">char</span> *buf， <span class="keyword">int</span> maxlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_be16</span><span class="params">(ByteIOContext *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_be24</span><span class="params">(ByteIOContext *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_be32</span><span class="params">(ByteIOContext *s)</span></span>;</span><br><span class="line"><span class="keyword">uint64_t</span> get_be64(ByteIOContext *s);</span><br></pre></td></tr></table></figure><p>这些 put_xxx 及 get_xxx 函数是用于从缓冲区 buffer 中写入或者读取若干个字节，对于读写整型数据，分别实现了大端和小端字节序的版本。而缓冲区 buffer 中的数据又是从何而来呢，有一个 fill_buffer 的函数，在 fill_buffer 函数中调用了ByteIOContext 结构的 read_packet 接口。在调用 put_xxx 函数时，并没有直接进行真<br>正写入操作，而是先缓存起来，直到缓存达到最大限制或调用 flush_buffer 函数对缓冲区进行刷新，才使用 write_packet 函数进行写入操作。</p><h2 id="Demuxer-和-muxer-模块分析"><a href="#Demuxer-和-muxer-模块分析" class="headerlink" title="Demuxer 和 muxer 模块分析"></a>Demuxer 和 muxer 模块分析</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>ffmpeg 的 demuxer 和 muxer 接口分别在 AVInputFormat 和 AVOutputFormat 两个结构体中实现，在 av_register_all()函数中将两个结构分别静态初始化为两个链表，保存在全局变量：first_iformat 和 first_oformat 两个变量中。在 FFmpeg 的文件转换或者打开过程中，首先要做的就是根据传入文件和传出文件的后缀名匹配合适的 demuxer和 muxer，得到合适的信息后保存在 AVFormatContext 中。</p><h3 id="相关数据结构介绍-1"><a href="#相关数据结构介绍-1" class="headerlink" title="相关数据结构介绍"></a>相关数据结构介绍</h3><p><strong>1、AVInputFormat</strong></p><p>该结构被称为 demuxer，是音视频文件的一个解封装器，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *long_name;</span><br><span class="line">    <span class="keyword">int</span> priv_data_size; <span class="comment">//具体文件容器格式对应的 Context 的大小，如：avicontext</span></span><br><span class="line">    <span class="keyword">int</span> (*read_probe)(AVProbeData *);</span><br><span class="line">    <span class="keyword">int</span> (*read_header)(struct AVFormatContext *，AVFormatParameters *ap);</span><br><span class="line">    <span class="keyword">int</span> (*read_packet)(struct AVFormatContext *， AVPacket *pkt);</span><br><span class="line">    <span class="keyword">int</span> (*read_close)(struct AVFormatContext *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_READ_SEEK</span></span><br><span class="line">    <span class="function">attribute_deprecated <span class="title">int</span> <span class="params">(*read_seek)</span><span class="params">(struct AVFormatContext *，</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> stream_index，<span class="keyword">int64_t</span> timestamp，<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int64_t</span> (*read_timestamp)(struct AVFormatContext *s， <span class="keyword">int</span> stream_index，</span><br><span class="line">                              <span class="keyword">int64_t</span> *pos， <span class="keyword">int64_t</span> pos_limit);</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *extensions;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> (*read_play)(struct AVFormatContext *);</span><br><span class="line">    <span class="keyword">int</span> (*read_pause)(struct AVFormatContext *);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodecTag</span> * <span class="title">const</span> *<span class="title">codec_tag</span>;</span></span><br><span class="line">    <span class="keyword">int</span> (*read_seek2)(struct AVFormatContext *s， <span class="keyword">int</span> stream_index， <span class="keyword">int64_t</span> min_ts，</span><br><span class="line">                      <span class="keyword">int64_t</span> ts， <span class="keyword">int64_t</span> max_ts， <span class="keyword">int</span> flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_OLD_METADATA2</span></span><br><span class="line">    <span class="keyword">const</span> AVMetadataConv *metadata_conv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_class; <span class="comment">///&lt; AVClass for the private context</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; AVInputFormat;</span><br></pre></td></tr></table></figure><p>对于不同的文件格式要实现相应的函数接口，这样每一种格式都有一个对应的demuxer，所有的 demuxer 都保存在全局变量 first_iformat 中。红色表示提供的接口。</p><p><strong>2、AVOutputFormat</strong></p><p>该结构与 AVInputFormat 类似也是在编译时静态初始化，组织为一个链表结构，提供了多个 muxer 的函数接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*write_header)(struct AVFormatContext *);</span><br><span class="line"><span class="keyword">int</span> (*write_packet)(struct AVFormatContext *， AVPacket *pkt);</span><br><span class="line"><span class="keyword">int</span> (*write_trailer)(struct AVFormatContext *);</span><br></pre></td></tr></table></figure><p>对于不同的文件格式要实现相应的函数接口，这样每一种格式都有一个对应的 muxer，所有的 muxer 都保存在全局变量 first_oformat 中。</p><p><strong>3、AVFormatContext</strong></p><p>该结构表示与程序当前运行的文件容器格式使用的上下文，着重于所有文件容器共有的属性，在运行时动态的确定其值，是 AVInputFormat 和 AVOutputFormat 的载体，但同一个结构对象只能使 AVInputFormat 和 AVOutputFormat 中的某一个有效。每一个输入和输出文件，都在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AVFormatContext *output_files[MAX_FILES] 和</span><br><span class="line"><span class="keyword">static</span> AVFormatContext *input_files[MAX_FILES];</span><br></pre></td></tr></table></figure><p>定义的指针数组全局变量中有对应的实体。对于输入和输出，因为共用的是同一个结构体，所以需要分别对该结构中如下定义的 iformat 或 oformat 成员赋值。在转码时读写数据是通过 AVFormatContext 结构进行的。定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFormatContext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span> *<span class="title">iformat</span>;</span> <span class="comment">//指向具体的 demuxer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVOutputFormat</span> *<span class="title">oformat</span>;</span> <span class="comment">//指向具体的 muxer</span></span><br><span class="line">    <span class="keyword">void</span> *priv_data; <span class="comment">//具体文件容器格式的 Context 如：avicontext</span></span><br><span class="line">    AVIOContext *pb; <span class="comment">//广义的输入输出；</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_streams; <span class="comment">//本次打开的文件容器中流的数量</span></span><br><span class="line">    AVStream **streams; <span class="comment">//每个流的相关描述</span></span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">1024</span>]; <span class="comment">// input or output filename */</span></span><br><span class="line">    <span class="keyword">int64_t</span> timestamp;</span><br><span class="line">    <span class="keyword">int</span> ctx_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVPacketList</span> *<span class="title">packet_buffer</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">enum</span> CodecID video_codec_id;</span><br><span class="line">    <span class="keyword">enum</span> CodecID audio_codec_id;</span><br><span class="line">    <span class="keyword">enum</span> CodecID subtitle_codec_id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_index_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_picture_buffer;</span><br><span class="line">    ......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVPacketList</span> *<span class="title">raw_packet_buffer</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVPacketList</span> *<span class="title">raw_packet_buffer_end</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVPacketList</span> *<span class="title">packet_buffer_end</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125; AVFormatContext;</span><br></pre></td></tr></table></figure><p>注释部分的成员是 AVFormatContext 中最为重要的成员变量，这些变量的初始化是ffmpeg 能正常工作的必要条件，那么，AVFormatContext 是如何被初始化的呢？文件的格式是如何被探测到的呢？</p><p>首先我们来探讨：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span> *<span class="title">iformat</span>;</span> <span class="comment">//指向具体的 demuxer</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVOutputFormat</span> *<span class="title">oformat</span>;</span> <span class="comment">//指向具体的 muxer</span></span><br><span class="line"><span class="keyword">void</span> *priv_data; <span class="comment">//具体文件容器格式的 Context 如：avicontext</span></span><br></pre></td></tr></table></figure><p>三个成员的初始化。</p><p>在 avformat_open_input() 函数中调用了 init_input() 函数，然后用调用了av_probe_input_format（）函数实现了对 AVFormatContext 的初始化。其调用关系如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_open_input_file</span><span class="params">(AVFormatContext **ic_ptr， <span class="keyword">const</span> <span class="keyword">char</span> *filename，</span></span></span><br><span class="line">AVInputFormat *fmt，int buf_size，AVFormatParameters *ap)；</span><br><span class="line">int avformat_open_input(ic_ptr， filename， fmt， &amp;opts)；</span><br><span class="line">static int init_input(s， filename)；</span><br><span class="line">av_probe_input_format(&amp;pd， <span class="number">0</span>)；</span><br><span class="line">av_probe_input_format (AVProbeData *pd， <span class="keyword">int</span> is_opened， <span class="keyword">int</span> *score_max)</span><br></pre></td></tr></table></figure><p>函数用途是根据传入的 probe data 数据，依次调用每个 demuxer 的 read_probe 接口，来进行该 demuxer 是否和传入的文件内容匹配的判断。与 demuxer 的匹配不同，muxer的匹配是调用 guess_format 函数，根据 main( ) 函数的 argv 里的输出文件后缀名来进行的。至此完成了前三个重要成员的初始化，具体的做法就不在深入分析。</p><p>下面分别给出 av_read_frame 函数以及 av_write_frame 函数的基本流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s， AVPacket *pkt)</span></span>;</span><br><span class="line">-&gt; av_read_frame_internel</span><br><span class="line">-&gt; av_read_packet</span><br><span class="line">-&gt; iformat-&gt;read_packet（在实现中会丢弃多余信息）</span><br><span class="line">-&gt; av_get_packet</span><br><span class="line">-&gt; get_xxx</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_write_frame</span><span class="params">(AVFormatContext *s， AVPacket *pkt)</span></span>;</span><br><span class="line">-&gt; oformat-&gt;write_packet</span><br><span class="line">-&gt; put_xxx</span><br></pre></td></tr></table></figure><p>由上可见，对 AVFormatContext 的读写操作最终是通过 ByteIOContext 来实现的，这样，AVFormatContext 与 URLContext 就由 ByteIOContext 结构联系到一起了。在AVFormat 结构体中有一个 packet 的缓冲区 raw_packet_buffer，是 AVPackList 的指针类型，av_read_packet 函数将读到的包添加至 raw_packet_buffer 链表末尾。</p><h2 id="Decoder-Encoder-模块"><a href="#Decoder-Encoder-模块" class="headerlink" title="Decoder/Encoder 模块"></a>Decoder/Encoder 模块</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>编解码模块主要包含的数据结构为：AVCodec、AVCodecContext 每一个解码类型都会有自己的 Codec 静态对像，Codec 的 int priv_data_size 记录该解码器上下文的结构大小，如 MsrleContext 。这些都是编译时确定的，程序运行时通过avcodec_register_all()将所有的解码器注册成一个链表。在 av_open_input_stream()函数中调用 AVInputFormat 的 read_header()中读文件头信息时，会读出数据流的CodecID，即确定了他的解码器 Codec。</p><p>在 main()函数中除了解析传入参数并初始化 demuxer 与 muxer 的 parse_options( )函数以外，其他的功能都是在 av_encode( )函数里完成的。在 libavcodec\utils.c 中有如下二个函数 : <code>AVCodec *avcodec_find_encoder(enum CodecID id)</code> 和 <code>AVCodec *avcodec_find_decoder(enum CodecID id)</code> 他们的功能就是根据传入的 CodecID，找到匹配的 encoder 和 decoder。在 av_encode( )函数的开头，首先初始化各个 AVInputStream和 AVOutputStream，然后分别调用上述二个函数，并将匹配上的 encoder 与 decoder 分<br>别保存在:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVInputStream-&gt;AVStream *st-&gt;AVCodecContext *codec-&gt;<span class="class"><span class="keyword">struct</span> <span class="title">AVCodec</span> *<span class="title">codec</span></span></span><br><span class="line"><span class="class">与 <span class="title">AVOutputStream</span>-&gt;<span class="title">AVStream</span> *<span class="title">st</span>-&gt;<span class="title">AVCodecContext</span> *<span class="title">codec</span>-&gt;<span class="title">struct</span> <span class="title">AVCodec</span> *<span class="title">codec</span> 变量。</span></span><br></pre></td></tr></table></figure><h3 id="相关数据结构的初始化"><a href="#相关数据结构的初始化" class="headerlink" title="相关数据结构的初始化"></a>相关数据结构的初始化</h3><p>AVCodecContext 结构</p><p>AVCodecContext 保存 AVCodec 指针和与 codec 相关数据，如 video 的 width、height，audio 的 sample rate 等。</p><p>AVCodecContext 中的 codec_type，codec_id 二个变量对于 encoder/decoder 的匹配来说，最为重要。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CodecType codec_type; <span class="comment">/* see CODEC_TYPE_xxx */</span></span><br><span class="line"><span class="keyword">enum</span> CodecID codec_id; <span class="comment">/* see CODEC_ID_xxx */</span></span><br></pre></td></tr></table></figure><p>如上所示，codec_type 保存的是 CODEC_TYPE_VIDEO，CODEC_TYPE_AUDIO 等媒体类型，codec_id 保存的是 CODEC_ID_FLV1，CODEC_ID_VP6F 等编码方式。</p><p>以支持 flv 格式为例，在前述的 av_open_input_file(…… ) 函数中，匹配到正确的 AVInputFormat demuxer 后，通过 av_open_input_stream( )函数中调用 AVInputFormat的 read_header 接口来执行 flvdec.c 中的 flv_read_header( )函数。flv_read_header( )函数内，根据文件头中的数据，创建相应的视频或音频 AVStream，并设置 AVStream 中AVCodecContext 的正确的 codec_type 值。codec_id 值是在解码过程。flv_read_packet( )<br>函数执行时根据每一个 packet 头中的数据来设置的。</p><p>以 avidec 为例 有如下初始化，我们主要知道的就是 code_id 和 code_type 该字段关联具体的解码器，和解码类型（音视频或 subtitle）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st-&gt;codec-&gt;stream_codec_tag == AV_RL32(<span class="string">"Axan"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    st-&gt;codec-&gt;codec_id = CODEC_ID_XAN_DPCM;</span><br><span class="line">    st-&gt;codec-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (amv_file_format)</span><br><span class="line">&#123;</span><br><span class="line">    st-&gt;codec-&gt;codec_id = CODEC_ID_ADPCM_IMA_AMV;</span><br><span class="line">    ast-&gt;dshow_block_align = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">        st-&gt;codec-&gt;codec_type = AVMEDIA_TYPE_SUBTITLE;</span><br><span class="line">        st-&gt;request_probe= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        st-&gt;codec-&gt;codec_type = AVMEDIA_TYPE_DATA;</span><br><span class="line">        st-&gt;codec-&gt;codec_id= CODEC_ID_NONE;</span><br><span class="line">        st-&gt;codec-&gt;codec_tag= <span class="number">0</span>;</span><br><span class="line">        avio_skip(pb， size);</span><br></pre></td></tr></table></figure><h2 id="其他重要数据结构的初始化"><a href="#其他重要数据结构的初始化" class="headerlink" title="其他重要数据结构的初始化"></a>其他重要数据结构的初始化</h2><h3 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h3><p>AVStream 结构保存与数据流相关的编解码器，数据段等信息。比较重要的有如下二个成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *codec; <span class="comment">/**&lt; codec context */</span></span><br><span class="line"><span class="keyword">void</span> *priv_data;</span><br></pre></td></tr></table></figure><p>其中 codec 指针保存的就是上节所述的 encoder 或 decoder 结构。priv_data 指针保存的是和具体编解码流相关的数据，如下代码所示，在 ASF 的解码过程中，priv_data保存的就是 ASFStream 结构的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVStream *st;</span><br><span class="line">ASFStream *asf_st;</span><br><span class="line">......</span><br><span class="line">st-&gt;priv_data = asf_st;</span><br></pre></td></tr></table></figure><h3 id="AVInputStream-AVOutputStream"><a href="#AVInputStream-AVOutputStream" class="headerlink" title="AVInputStream/ AVOutputStream"></a>AVInputStream/ AVOutputStream</h3><p>根据输入和输出流的不同，前述的 AVStream 结构都是封装在 AVInputStream 和AVOutputStream 结构中，在 av_encode( )函数中使用。AVInputStream 中还保存的有与时间有关的信息。AVOutputStream 中还保存有与音视频同步等相关的信息。</p><h3 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h3><p>AVPacket 结构定义如下，其是用于保存读取的 packet 数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVPacket</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts; <span class="comment">///&lt; presentation time stamp in time_base units</span></span><br><span class="line">    <span class="keyword">int64_t</span> dts; <span class="comment">///&lt; decompression time stamp in time_base units</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> stream_index;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> duration; <span class="comment">///&lt; presentation duration in time_base units</span></span><br><span class="line">    <span class="keyword">void</span> (*destruct)(struct AVPacket *);</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">    <span class="keyword">int64_t</span> pos; <span class="comment">///&lt; byte position in stream， -1 if unknown</span></span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure><p>在 av_encode() 函数中，调用 AVInputFormat 的 <code>(*read_packet)(struct AVFormatContext *， AVPacket *pkt)</code> 接口，读取输入文件的一帧数据保存在当前输入 AVFormatContext 的 AVPacket 成员中。</p><h1 id="FFmpeg-裁剪说明"><a href="#FFmpeg-裁剪说明" class="headerlink" title="FFmpeg 裁剪说明"></a>FFmpeg 裁剪说明</h1><p>本文对 ffmpeg 进行裁剪采用的是配置所需的接口，不需要的不配置，而不是采用修改源代码的方式。</p><h2 id="configure-参数"><a href="#configure-参数" class="headerlink" title="configure 参数"></a>configure 参数</h2><h3 id="通用选项-1"><a href="#通用选项-1" class="headerlink" title="通用选项"></a>通用选项</h3><p>在 linux 下进入终端，找到 ffmpeg 解压位置，输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure –<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><p>得到 configure 的基本选项参数，其并没有中文解释。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">--help 显示此帮助信息|print this message</span><br><span class="line">--log[=FILE|yes|no] 记录测试并输出到 config.err 文件|log tests and output to FILE [config.err]</span><br><span class="line">--prefix=PREFIX 安装程序到指定目录（默认/usr/local）|install in PREFIX [/usr/local]</span><br><span class="line">--libdir=DIR 安装库到指定目录（默认 prefix/lib）|install libs in DIR [PREFIX/lib]</span><br><span class="line">--shlibdir=DIR 指定共享库路径（默认 prefix/lib）|install shared libs in DIR [PREFIX/lib]</span><br><span class="line">--incdir=DIR 指定 includes 路径（默认 prefix/include/ffmpeg）|install includes in DIR[PREFIX/include/ffmpeg]</span><br><span class="line">--mandir=DIR 指定 man page 路径（默认 prefix/man）install man page in DIR [PREFIX/man]</span><br><span class="line">--enable-mp3lame 启用 mp3 编码 libmp3lame（默认关闭）enable MP3 encoding via libmp3lame[default=no]</span><br><span class="line">--enable-libogg 启用 ogg 支持 libogg（默认关闭）enable Ogg support via libogg [default=no]</span><br><span class="line">--enable-vorbis 启用 Vorbis 支持 libvorbis（默认关闭）enable Vorbis support via libvorbis [default=no]</span><br><span class="line">--enable-faad 启用 faad 支持 libfaad（默认关闭）enable FAAD support via libfaad [default=no]</span><br><span class="line">--enable-faadbin 启用 faad 运行时链接支持（默认关闭）build FAAD support with runtime linking[default=no]</span><br><span class="line">--enable-faac 启用 faac 支持 libfaac（默认关闭）enable FAAC support via libfaac [default=no]</span><br><span class="line">--enable-libgsm 启用 GSM 支持 libgsm（默认关闭）enable GSM support via libgsm [default=no]</span><br><span class="line">--enable-xvid 启用 xvid 支持 xvidcore（默认关闭）enable XviD support via xvidcore [default=no]</span><br><span class="line">--enable-x264 启 用 H.264 编码（默认关闭） enable H.264 encoding via x264 [default=no]</span><br><span class="line">--enable-mingw32 启用 MinGW 本地/交叉 win 环境编译|enable MinGW native/cross Windows compile</span><br><span class="line">--enable-mingwce 启用 MinGW 本地/交叉 winCE 环境编译 enable MinGW native/cross WinCE compile</span><br><span class="line">--enable-a52 启用 A52 支持（默认关闭）enable GPLed A52 support [default=no]</span><br><span class="line">--enable-a52bin 启用运行时打开 liba52.so.0（默认关闭）open liba52.so.0 at runtime [default=no]</span><br><span class="line">--enable-dts 启用 DTS 支持（默认关闭）enable GPLed DTS support [default=no]</span><br><span class="line">--enable-pp 启用后加工支持（默认关闭）enable GPLed postprocessing support [default=no]</span><br><span class="line">--enable-static 构建静态库（默认启用）build static libraries [default=yes]</span><br><span class="line">--disable-static 禁止构建静态库（默认关闭）do not build static libraries [default=no]</span><br><span class="line">--enable-shared 构建共享库（默认关闭）build shared libraries [default=no]</span><br><span class="line">--disable-shared 禁止构建共享库（默认启用）do not build shared libraries [default=yes]</span><br><span class="line">--enable-amr_nb 启用 amr_nb float 音频编解码器|enable amr_nb float audio codec</span><br><span class="line">--enable-amr_nb-fixed 启用 fixed amr_nb codec | use fixed point for amr-nb codec</span><br><span class="line">--enable-amr_wb 启用 amr_wb float 音频编解码器|enable amr_wb float audio codec</span><br><span class="line">--enable-amr_if2 启用 amr_wb IF2 音频编解码器|enable amr_wb IF2 audio codec</span><br><span class="line">--enable-sunmlib 启用 Sun medialib（默认关闭） | use Sun medialib [default=no]</span><br><span class="line">--enable-pthreads 启用 pthreads（多线程）（默认关闭）use pthreads [default=no]</span><br><span class="line">--enable-dc1394 启用 libdc1394、libraw1394 抓取 IIDC-1394（默认关闭）enable IIDC-1394 grabbing using libdc1394 and libraw1394 [default=no]</span><br><span class="line">--enable-swscaler 启用计数器支持？（默认关闭）software scaler support [default=no]</span><br><span class="line">--enable-avisynth 允许读取 AVISynth 脚本本件（默认关闭）allow reading AVISynth script files [default=no]</span><br><span class="line">--enable-gpl 允许使用 GPL（默认关闭）allow use of GPL code， the resulting libav* and ffmpeg will be under GPL [default=no] Advanced options (experts only): 高级选项参数（供专业人员使用）</span><br><span class="line">--source-path=PATH 源码的路径（当前为/root/flv/ffmpeg）| path to source code [/root/flv/ffmpeg]</span><br><span class="line">--cross-prefix=PREFIX 为编译工具指定路径 | use PREFIX for compilation tools []</span><br><span class="line">--cross-compile 假定使用了交叉编译 | assume a cross-compiler is used</span><br><span class="line">--cc=CC 指定使用何种 C 编译器（默认 gcc）use C compiler CC [gcc]</span><br><span class="line">--make=MAKE 使用特定的 make | use specified make [make]</span><br><span class="line">--extra-cflags=ECFLAGS 添加 ECFLAGS 到 CFLAGS | add ECFLAGS to CFLAGS []</span><br><span class="line">--extra-ldflags=ELDFLAGS 添加 ELDFLAGS 到 LDFLAGS（默认-Wl，--as-needed）| add ELDFLAGS to LDFLAGS [ -Wl，--as-needed]</span><br><span class="line">--extra-libs=ELIBS 添加 ELIBS | add ELIBS []</span><br><span class="line">--build-suffix=SUFFIX 为专用程序添加后缀 | suffix for application specific build []</span><br><span class="line">--arch=ARCH 选择机器架构（默认 x86）select architecture [x86]</span><br><span class="line">--cpu=CPU 选用最低的 cpu（影响指令的选择，可以在老 CPU 上出错）</span><br><span class="line">| selects the minimum cpu required (affects instruction selection， may crash on older CPUs)</span><br><span class="line">--powerpc-perf-enable 启用 PPC 上面的性能报告（需要启用 PMC）enable performance report on PPC (requires enabling PMC)</span><br><span class="line">--disable-mmx 禁用 MMX | disable MMX usage</span><br><span class="line">--disable-armv5te 禁用 armv5te | disable armv5te usage</span><br><span class="line">--disable-iwmmxt 禁用 iwmmxt | disable iwmmxt usage</span><br><span class="line">--disable-altivec 禁用 AltiVec | disable AltiVec usage</span><br><span class="line">--disable-audio-oss 禁用 OSS 音频支持（默认启用）disable OSS audio support [default=no]</span><br><span class="line">--disable-audio-beos 禁用 BeOS 音频支持（默认启用）disable BeOS audio support [default=no]</span><br><span class="line">--disable-v4l 禁用 video4linux 提取（默认启用）disable video4linux grabbing [default=no]</span><br><span class="line">--disable-v4l2 禁用 video4linux2 提取（默认启用）disable video4linux2 grabbing [default=no]</span><br><span class="line">--disable-bktr 禁用 bktr 视频提取（默认启用）disable bktr video grabbing [default=no]</span><br><span class="line">--disable-dv1394 禁用 DV1394 提取（默认启用）disable DV1394 grabbing [default=no]</span><br><span class="line">--disable-network 禁用网络支持（默认支持）disable network support [default=no]</span><br><span class="line">--disable-ipv6 禁用 ipv6 支持（默认支持）disable ipv6 support [default=no]</span><br><span class="line">--disable-zlib 禁用 zlib（默认支持）disable zlib [default=no]</span><br><span class="line">--disable-simple_idct 禁用 simple IDCT 例程（默认启用）disable simple IDCT routines [default=no]</span><br><span class="line">--disable-vhook 禁用 video hooking 支持 | disable video hooking support</span><br><span class="line">--enable-gprof enable profiling with gprof [no]</span><br><span class="line">--disable-debug 禁用调试符号 | disable debugging symbols</span><br><span class="line">--disable-opts 禁用编译器最优化 | disable compiler optimizations</span><br><span class="line">--disable-mpegaudio-hp 启用更快的解码 MPEG 音频（但精确度较低）（默认禁用）faster (but less accurate) MPEG audio decoding [default=no]</span><br><span class="line">--disable-protocols 禁用 I/O 协议支持（默认启用）disable I/O protocols support [default=no]</span><br><span class="line">--disable-ffserver 禁用生成 ffserver | disable ffserver build</span><br><span class="line">--disable-ffplay 禁用生成 ffplay | disable ffplay build</span><br><span class="line">--enable-small 启用优化文件尺寸大小（牺牲速度）optimize for size instead of speed</span><br><span class="line">--enable-memalign-hack 启用模拟内存排列，由内存调试器干涉？ | emulate memalign，interferes with memory debuggers</span><br><span class="line">--disable-strip 禁用剥离可执行程序和共享库 | disable stripping of executables and shared libraries</span><br><span class="line">--disable-encoder=NAME 禁用 XX 编码器 | disables encoder NAME</span><br><span class="line">--enable-encoder=NAME 启用 XX 编码器 | enables encoder NAME</span><br><span class="line">--disable-decoder=NAME 禁用 XX 解码器 | disables decoder NAME</span><br><span class="line">--enable-decoder=NAME 启用 XX 解码器 | enables decoder NAME</span><br><span class="line">--disable-encoders 禁用所有编码器 | disables all encoders</span><br><span class="line">--disable-decoders 禁用所有解码器 | disables all decoders</span><br><span class="line">--disable-muxer=NAME 禁用 XX 混音器 | disables muxer NAME</span><br><span class="line">--enable-muxer=NAME 启用 XX 混音器 | enables muxer NAME</span><br><span class="line">--disable-muxers 禁用所有混音器 | disables all muxers</span><br><span class="line">--disable-demuxer=NAME 禁用 XX 解轨器 | disables demuxer NAME</span><br><span class="line">--enable-demuxer=NAME 启用 XX 解轨器 | enables demuxer NAME</span><br><span class="line">--disable-demuxers 禁用所有解轨器 | disables all demuxers</span><br><span class="line">--enable-parser=NAME 启用 XX 剖析器 | enables parser NAME</span><br><span class="line">--disable-parser=NAME 禁用 XX 剖析器 | disables parser NAME</span><br><span class="line">--disable-parsers 禁用所有剖析器 | disables all parsers</span><br></pre></td></tr></table></figure><h3 id="基本选项介绍"><a href="#基本选项介绍" class="headerlink" title="基本选项介绍"></a>基本选项介绍</h3><p>以下为配置 ffmpeg 的基本选项，其含义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--cache-file=FILE</span><br></pre></td></tr></table></figure><p>configure 会在你的系统上测试存在的特性(或者 bug!)。为了加速随后进行的配置，测试的结果会存储在一个 cache file 里。当 configure 到每个子树里都有 configure 脚本的复杂的源码树时，一个很好的 cache file 的存在会有很大帮助。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br></pre></td></tr></table></figure><p>输出帮助信息。即使是有经验的用户也偶尔需要使用使用 <code>--help</code> 选项，因为一个复杂的项目会包含附加的选项。例如，GCC 包里的 configure 脚本就包含了允许你控制是否生成和在 GCC 中使用 GNU 汇编器的选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--no-create</span><br></pre></td></tr></table></figure><p>configure 中的一个主要函数会制作输出文件。此选项阻止 configure 生成这个文件。你可以认为这是一种演习(dry run)，尽管缓存(cache)仍然被改写了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--quiet</span><br><span class="line">--silent</span><br></pre></td></tr></table></figure><p>当 configure 进行他的测试时，会输出简要的信息来告诉用户正在作什么。这样做是因为 configure 可能会比较慢，没有这种输出的话用户将会被扔在一旁疑惑正在发生什么。使用这两个选项中的任何一个都会把你扔到一旁。(译注：这两句话比较有意思，原文是这样的：If there was no such output， the user would be left wondering what is happening. By using this option， you too can be left wondering!)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--version</span><br></pre></td></tr></table></figure><p>打印用来产生 ‘configure’ 脚本的 Autoconf 的版本号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--prefix=PEWFIX</span><br></pre></td></tr></table></figure><p><code>--prefix</code> 是最常用的选项。制作出的 Makefile 会查看随此选项传递的参数，当一个包在安装时可以彻底的重新安置他的结构独立部分。举一个例子，当安装一个包，例如说Emacs，下面的命令将会使 Emacs Lisp file 被安装到”/opt/gnu/share”：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/opt/gnu</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--exec-prefix=EPREFIX</span><br></pre></td></tr></table></figure><p>与 <code>--prefix</code> 选项类似，但是他是用来设置结构倚赖的文件的安装位置。编译好的 emacs 二进制文件就是这样一个问件。如果没有设置这个选项的话，默认使用的选项值将被设为和 <code>--prefix</code> 选项值一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--bindir=DIR</span><br></pre></td></tr></table></figure><p>指定二进制文件的安装位置。这里的二进制文件定义为可以被用户直接执行的程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--sbindir=DIR</span><br></pre></td></tr></table></figure><p>指定超级二进制文件的安装位置。这是一些通常只能由超级用户执行的程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--libexecdir=DIR</span><br></pre></td></tr></table></figure><p>指定可执行支持文件的安装位置。与二进制文件相反，这些文件从来不直接由用户执行，但是可以被上面提到的二进制文件所执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--datadir=DIR</span><br></pre></td></tr></table></figure><p>指定通用数据文件的安装位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--sysconfdir=DIR</span><br></pre></td></tr></table></figure><p>指定在单个机器上使用的只读数据的安装位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--sharedstatedir=DIR</span><br></pre></td></tr></table></figure><p>指定可以在多个机器上共享的可写数据的安装位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--localstatedir=DIR</span><br></pre></td></tr></table></figure><p>指定只能单机使用的可写数据的安装位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--libdir=DIR</span><br></pre></td></tr></table></figure><p>指定库文件的安装位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--includedir=DIR</span><br></pre></td></tr></table></figure><p>指定 C 头文件的安装位置。其他语言如 C++的头文件也可以使用此选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--oldincludedir=DIR</span><br></pre></td></tr></table></figure><p>指定为除 GCC 外编译器安装的 C 头文件的安装位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--infodir=DIR</span><br></pre></td></tr></table></figure><p>指定 Info 格式文档的安装位置。Info 是被 GNU 工程所使用的文档格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mandir=DIR</span><br></pre></td></tr></table></figure><p>指定手册页的安装位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--srcdir=DIR</span><br></pre></td></tr></table></figure><p>这个选项对安装没有作用。他会告诉 configure 源码的位置。一般来说不用指定此选项，因为 configure 脚本一般和源码文件在同一个目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--program-prefix=PREFIX</span><br></pre></td></tr></table></figure><p>指定将被加到所安装程序的名字上的前缀。例如，使用 <code>--program-prefix=g</code> 来 configure一个名为 tar 的程序将会使安装的程序被命名为 gtar。当和其他的安装选项一起使用时，这个选项只有当他被 Makefile.in 文件使用时才会工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--program-suffix=SUFFIX</span><br></pre></td></tr></table></figure><p>指定将被加到所安装程序的名字上的后缀。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--program-transform-name=PROGRAM</span><br></pre></td></tr></table></figure><p>这里的 PROGRAM 是一个 sed 脚本。当一个程序被安装时，他的名字将经过 <code>sed -e PROGRAM</code> 来产生安装的名字。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--build=BUILD</span><br></pre></td></tr></table></figure><p>指定软件包安装的系统平台。如果没有指定，默认值将是 <code>--host</code> 选项的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--host=HOST</span><br></pre></td></tr></table></figure><p>指定软件运行的系统平台。如果没有指定，将会运行 config.guess 来检测。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--target=GARGET</span><br></pre></td></tr></table></figure><p>指定软件面向(target to)的系统平台。这主要在程序语言工具如编译器和汇编器上下文中起作用。如果没有指定，默认将使用 <code>--host</code> 选项的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--disable-FEATURE</span><br></pre></td></tr></table></figure><p>一些软件包可以选择这个选项来提供为大型选项的编译时配置，例如使用 Kerberos认证系统或者一个实验性的编译器最优配置。如果默认是提供这些特性，可以使用 <code>--disable-FEATURE</code> 来禁用它，这里 FEATURE 是特性的名字。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure --<span class="built_in">disable</span>-gui</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-FEATURE[=ARG]</span><br></pre></td></tr></table></figure><p>相反的，一些软件包可能提供了一些默认被禁止的特性，可以使用 <code>--enable-FEATURE</code> 来起用它。这里 FEATURE 是特性的名字。一个特性可能会接受一个可选的参数。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure --<span class="built_in">enable</span>-buffers=128</span></span><br></pre></td></tr></table></figure><p><code>--enable-FEATURE=no</code> 与上面提到的 <code>--disable-FEATURE</code> 是同义的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--with-PACKAGE[=ARG]</span><br></pre></td></tr></table></figure><p>在自由软件社区里，有使用已有软件包和库的优秀传统。当用 configure 来配置一个源码树时，可以提供其他已经安装的软件包的信息。例如，倚赖于 Tcl 和 Tk 的 BLT 器件工具包。要配置 BLT，可能需要给 configure 提供一些关于我们把 Tcl 和 Tk 装的何处的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure --with-tcl=/usr/<span class="built_in">local</span> --with-tk=/usr/<span class="built_in">local</span></span></span><br></pre></td></tr></table></figure><p><code>--with-PACKAGE=no</code> 与下面将提到的 <code>--without-PACKAGE</code> 是同义的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--without-PACKAGE</span><br></pre></td></tr></table></figure><p>有时候你可能不想让你的软件包与系统已有的软件包交互。例如，你可能不想让你的新编译器使用 GNU ld。通过使用这个选项可以做到这一点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure --without-gnu-ld</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--x-includes=DIR</span><br></pre></td></tr></table></figure><p>这个选项是 <code>--with-PACKAGE</code> 选项的一个特例。在 Autoconf 最初被开发出来时，流行使用 configure 来作为 Imake 的一个变通方法来制作运行于 X 的软件。–x-includes 选项提供了向 configure 脚本指明包含 X11 头文件的目录的方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--x-libraries=DIR</span><br></pre></td></tr></table></figure><p>类似的，<code>--x-libraries</code> 选项提供了向 configure 脚本指明包含 X11 库的目录的方法。</p><h2 id="FFmpeg-裁剪优化实例"><a href="#FFmpeg-裁剪优化实例" class="headerlink" title="FFmpeg 裁剪优化实例"></a>FFmpeg 裁剪优化实例</h2><p>对 ffmpeg 的裁剪优化主要是对 ffplay 的裁剪优化，我们制定的需求是能播放测试文件（视频为 mpeg4 编码、音频为 mp2 编码，且为 AVI 复用），根据需求，找到相应的选项，或禁用或启用，最后的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure --<span class="built_in">disable</span>-yasm --<span class="built_in">disable</span>-parsers --<span class="built_in">disable</span>-decoders</span></span><br><span class="line">--disable-encoders --enable-decoder=mpeg4 --disable-muxers</span><br><span class="line">--disable-demuxers --enable-demuxer=avi --enable-decoder=mp2</span><br><span class="line">--disable-protocols --enable-protocol=file --disable-filters --disable-bsfs</span><br></pre></td></tr></table></figure><p>其中针对需求，</p><ul><li><p><code>--disable-parsers</code> 为禁用所有解析器，</p></li><li><p><code>--disable-decoders</code> 为禁用所有解码器，</p></li><li><p><code>--disable-encoders</code> 为禁用所有编码器，</p></li><li><p><code>--enable-decoder=mpeg4</code> 为启用 mpeg4 的编码器 ， </p></li><li><p><code>--disable-muxers</code> 为禁用所有复用， </p></li><li><p><code>--disable-demuxers</code> 为禁用所有解复用，</p></li><li><p><code>--enable-demuxer=avi</code> 为启用 AVI 复用，</p></li><li><p><code>--enable-decoder=mp2</code> 为启用 mp2 编码，</p></li><li><p><code>--disable-protocols</code> 为禁用所有协议， </p></li><li><p><code>--enable-protocol=file</code> 为启用文件协议，</p></li><li><p><code>--disable-filters</code> 为禁用所有过滤器，</p></li><li><p><code>--disable-bsfs</code> 为禁用所有码流过滤器。</p></li></ul><p>通过以上配置之后，编译，安装，就生成了我们要求的 ffplay，其大小为 1.8M（1864012 字节）。此次是在 linux 环境下进行的，在以后的配置中，如果需要其他的什么编码器或什么的，按照选项要求进行配置即可。</p><h2 id="裁剪优化前后文件比较"><a href="#裁剪优化前后文件比较" class="headerlink" title="裁剪优化前后文件比较"></a>裁剪优化前后文件比较</h2><p>前面已经提到本次裁剪优化的内容。经过裁剪优化之后，对其文件夹进行比较，主要有 3 个地方不同，分别是 config.fate、config.h 和 config.mak。在 config.fate 中，其记录的是配置命令，由于前后两次配置命令不同，故相应内容也不同。在config.h 中，其主要是根据配置命令来改变相应预定义的值，达到裁剪优化之效果。在 config.mak 中，改变的也是配置命令中需要改变的选项。</p><h1 id="FFmpeg-SDK"><a href="#FFmpeg-SDK" class="headerlink" title="FFmpeg SDK"></a>FFmpeg SDK</h1><p>FFMpeg 中比较重要的函数以及数据结构如下：</p><p><strong>1、数据结构：</strong></p><p><strong>(1) AVFormatContext</strong></p><p><strong>(2) AVOutputFormat</strong></p><p><strong>(3) AVInputFormat</strong></p><p><strong>(4) AVCodecContext</strong></p><p><strong>(5) AVCodec</strong></p><p><strong>(6) AVFrame</strong></p><p><strong>(7) AVPacket</strong></p><p><strong>(8) AVPicture</strong></p><p>(9) AVStream</p><p><strong>2、初始化函数：</strong></p><p>(1) av_register_all()</p><p>(2) avcodec_open()</p><p>(3) avcodec_close()</p><p>(4) av_open_input_file()</p><p>(5) av_find_input_format()</p><p>(6) av_find_stream_info()</p><p>(7) av_close_input_file()</p><p><strong>3、音视频编解码函数：</strong></p><p>(1) avcodec_find_decoder()</p><p>(2) avcodec_alloc_frame()</p><p>(3) avpicture_get_size()</p><p>(4) avpicture_fill()</p><p>(5) img_convert()</p><p>(6) avcodec_alloc_context()</p><p>(7) avcodec_decode_video()</p><p>(8) av_free_packet()</p><p>(9) av_free()</p><p><strong>4、文件操作：</strong></p><p>(1) avnew_steam()</p><p>(2) av_read_frame()</p><p>(3) av_write_frame()</p><p>(4) dump_format()</p><p><strong>5、其他函数：</strong></p><p>(1) avpicture_deinterlace()</p><p>(2) ImgReSampleContext() </p><h1 id="FFmpeg-编译"><a href="#FFmpeg-编译" class="headerlink" title="FFmpeg 编译"></a>FFmpeg 编译</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> http://source.ffmpeg.org/git/ffmpeg.git ffmpeg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ffmpeg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=./install --<span class="built_in">enable</span>-gpl --<span class="built_in">enable</span>-nonfree \</span></span><br><span class="line">--enable-libass --enable-libfdk-aac --enable-libfreetype \</span><br><span class="line">--enable-libmp3lame --enable-libopus --enable-libtheora \</span><br><span class="line">--enable-libvorbis --enable-libvpx --enable-libx264 --enable-libxvid \</span><br><span class="line">--enable-shared --enable-static</span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; sudo make install</span></span><br></pre></td></tr></table></figure><p>注意：在执行各自的 configure 创建编译配置文件时，最好都强制带上 –enable-static 和 –enable-shared 参数以确保生成静态库和动态库。另外因为是在 Mac OS X 环境下编译，因此在各自编译完后，都要执行 sudo make install，安装到默认的 /usr/local 目录下相应位置（Mac OS X 下不推荐 /usr），因此不要在 configure 时指定 –prefix，就用默认的 /usr/local 目录前缀即可。完成编译安装后，FFmpeg 的头文件将会复制到 /usr/local/include 下面相应位置，静态库及动态库会被复制到 /usr/local/lib 目录下，FFmpeg 的可执行程序（ffmpeg、ffprobe、ffserver）会被复制到 /usr/local/bin 目录下，这样 FFmpeg 的开发环境就构建好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文以文档的形式来描述FFmpeg怎么入门，这也是为以后写文档做的一个大题框架格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;文档介绍&quot;&gt;&lt;a href=&quot;#文档介绍&quot; class=&quot;headerlink&quot; title=&quot;文档介绍&quot;&gt;&lt;/a&gt;文档介绍&lt;/h1&gt;&lt;h2 id=&quot;文档目的&quot;&gt;&lt;a href=&quot;#文档目的&quot; class=&quot;headerlink&quot; title=&quot;文档目的&quot;&gt;&lt;/a&gt;文档目的&lt;/h2&gt;&lt;p&gt;整理出开源代码 ffmpeg 的资料，方便公司同事后续使用。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>值得推荐的C/C++框架和库</title>
    <link href="http://miaopei.github.io/2018/06/08/Program-C/c-open-project/"/>
    <id>http://miaopei.github.io/2018/06/08/Program-C/c-open-project/</id>
    <published>2018-06-08T02:14:50.000Z</published>
    <updated>2019-06-14T09:55:56.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="值得学习的C语言开源项目"><a href="#值得学习的C语言开源项目" class="headerlink" title="值得学习的C语言开源项目"></a>值得学习的C语言开源项目</h2><p><strong>Libev</strong></p><p>libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。</p><p>下载链接：<span class="exturl" data-url="aHR0cDovL3NvZnR3YXJlLnNjaG1vcnAuZGUvcGtnL2xpYmV2Lmh0bWw=" title="http://software.schmorp.de/pkg/libev.html">http://software.schmorp.de/pkg/libev.html<i class="fa fa-external-link"></i></span></p><p><strong>Memcached</strong></p><p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL21lbWNhY2hlZC5vcmcv" title="http://memcached.org/">http://memcached.org/<i class="fa fa-external-link"></i></span></p><p><strong>Redis</strong></p><p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。Redis支持的操作和数据类型比Memcached要多，现在主要用于缓存，支持主从同步机制，Redis的学习可以参考&lt;&lt;Redis设计与实现&gt;&gt;一书。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL3JlZGlzLmlvLw==" title="http://redis.io/">http://redis.io/<i class="fa fa-external-link"></i></span></p><p><strong>Webbench</strong></p><p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。</p><p>下载链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL1dlYkJlbmNo" title="https://github.com/LippiOuYang/WebBench">https://github.com/LippiOuYang/WebBenchl<i class="fa fa-external-link"></i></span></p><p><strong>APR（Apache Portable Runtime）</strong></p><p>这是由 Apache 社区维护的 C 开源库，主要提供操作系统相关的功能（文件系统、进程、线程、用户、IPC）。此外还提供了一些网络相关的功能。</p><p>APR 原先是 Apache Web 服务器的一个组成部分，后来独立出来，成为一个单独的开源项目。<br>主页：<span class="exturl" data-url="aHR0cHM6Ly9hcHIuYXBhY2hlLm9yZy8=" title="https://apr.apache.org/">https://apr.apache.org<i class="fa fa-external-link"></i></span></p><p><strong>Tinyhttpd</strong></p><p>tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。</p><p>下载链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL1RpbnlodHRwZA==" title="https://github.com/LippiOuYang/Tinyhttpd">https://github.com/LippiOuYang/Tinyhttpd<i class="fa fa-external-link"></i></span></p><p><strong>cJSON</strong></p><p>cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。</p><p>cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。</p><p>项目主页:<span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy9janNvbi8=" title="http://sourceforge.net/projects/cjson/">http://sourceforge.net/projects/cjson/<i class="fa fa-external-link"></i></span></p><p><strong>CMockery</strong></p><p>cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。</p><p>主要特点：</p><ul><li>免费且开源，google提供技术支持；</li><li>轻量级的框架，使测试更加快速简单；</li><li>避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;</li><li>并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用</li></ul><p>下载链接：<span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2Ntb2NrZXJ5L2Rvd25sb2Fkcy9saXN0" title="http://code.google.com/p/cmockery/downloads/list">http://code.google.com/p/cmockery/downloads/list<i class="fa fa-external-link"></i></span></p><p><strong>Lua</strong></p><p>Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。</p><p>让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL3d3dy5sdWEub3JnLw==" title="http://www.lua.org/">http://www.lua.org/<i class="fa fa-external-link"></i></span></p><p><strong>SQLite</strong></p><p>SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。</p><p> 下载地址：<span class="exturl" data-url="aHR0cDovL3d3dy5zcWxpdGUub3JnLw==" title="http://www.sqlite.org/">http://www.sqlite.org/<i class="fa fa-external-link"></i></span> 。</p><p><strong>UNIX v6</strong></p><p>UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？</p><p>另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL21pbm5pZS50dWhzLm9yZy9jZ2ktYmluL3V0cmVlLnBsP2ZpbGU9VjY=" title="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6">http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6<i class="fa fa-external-link"></i></span></p><p><strong>NETBSD</strong></p><p>NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。</p><p>下载地址：<span class="exturl" data-url="aHR0cDovL3d3dy5uZXRic2Qub3JnLw==" title="http://www.netbsd.org/">http://www.netbsd.org/<i class="fa fa-external-link"></i></span></p><h2 id="C-资源大全"><a href="#C-资源大全" class="headerlink" title="C++ 资源大全"></a>C++ 资源大全</h2><p>关于 C++ 框架、库和资源的一些汇总列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。</p><p>&nbsp;</p><h3>标准库</h3><p>C++标准库，包括了STL容器，算法和函数等。</p><ul><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DJTJCJTJCX1N0YW5kYXJkX0xpYnJhcnk=" title="http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library">C++ Standard Library<i class="fa fa-external-link"></i></span>：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。</li><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9UZW1wbGF0ZV9MaWJyYXJ5" title="http://en.wikipedia.org/wiki/Standard_Template_Library">Standard Template Library<i class="fa fa-external-link"></i></span>：标准模板库</li><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DX1BPU0lYX2xpYnJhcnk=" title="http://en.wikipedia.org/wiki/C_POSIX_library">C POSIX library<i class="fa fa-external-link"></i></span> ： POSIX系统的C标准库规范</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NwbHVzcGx1cw==" title="https://github.com/cplusplus">ISO C++ Standards Committee<i class="fa fa-external-link"></i></span> ：C++标准委员会</li></ul><p>&nbsp;</p><h3>框架</h3><p>C++通用框架和库</p><ul><li><span class="exturl" data-url="aHR0cDovL3N0ZGN4eC5hcGFjaGUub3JnLw==" title="http://stdcxx.apache.org/">Apache C++ Standard Library<i class="fa fa-external-link"></i></span>：是一系列算法，容器，迭代器和其他基本组件的集合</li><li><span class="exturl" data-url="aHR0cDovL3N0bGFiLmFkb2JlLmNvbS8=" title="http://stlab.adobe.com/">ASL<i class="fa fa-external-link"></i></span> ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jvb3N0b3Jn" title="https://github.com/boostorg">Boost<i class="fa fa-external-link"></i></span> ：大量通用C++库的集合。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jsb29tYmVyZy9iZGU=" title="https://github.com/bloomberg/bde">BDE<i class="fa fa-external-link"></i></span> ：来自于彭博资讯实验室的开发环境。</li><li><span class="exturl" data-url="aHR0cDovL2xpYmNpbmRlci5vcmcv" title="http://libcinder.org/">Cinder<i class="fa fa-external-link"></i></span>：提供专业品质创造性编码的开源开发社区。</li><li><span class="exturl" data-url="aHR0cDovL3J5YW4uZ3VsaXguY2wvZm9zc2lsLmNnaS9jeHhvbWZvcnQv" title="http://ryan.gulix.cl/fossil.cgi/cxxomfort/">Cxxomfort<i class="fa fa-external-link"></i></span>：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。</li><li><span class="exturl" data-url="aHR0cDovL2RsaWIubmV0Lw==" title="http://dlib.net/">Dlib<i class="fa fa-external-link"></i></span>：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhdWxob2RnZS9FQVNUTA==" title="https://github.com/paulhodge/EASTL">EASTL<i class="fa fa-external-link"></i></span> ：EA-STL公共部分</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N1bWVldGNoaGV0cmkvZmZlYWQtY3Bw" title="https://github.com/sumeetchhetri/ffead-cpp">ffead-cpp<i class="fa fa-external-link"></i></span> ：企业应用程序开发框架</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZvbGx5" title="https://github.com/facebook/folly">Folly<i class="fa fa-external-link"></i></span>：由Facebook开发和使用的开源C++库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1bGlhbnN0b3Jlci9KVUNF" title="https://github.com/julianstorer/JUCE">JUCE<i class="fa fa-external-link"></i></span> ：包罗万象的C++类库，用于开发跨平台软件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2xpYnBoZW5vbQ==" title="https://github.com/facebook/libphenom">libPhenom<i class="fa fa-external-link"></i></span>：用于构建高性能和高度可扩展性系统的事件框架。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvdXJjZXkvbGlic291cmNleQ==" title="https://github.com/sourcey/libsourcey">LibSourcey<i class="fa fa-external-link"></i></span> ：用于实时的视频流和高性能网络应用程序的C++11 evented IO</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tvYW5sb2dpYy9saWJ1" title="https://github.com/koanlogic/libu">LibU<i class="fa fa-external-link"></i></span> ： C语言写的多平台工具库</li><li><span class="exturl" data-url="aHR0cDovL2xva2ktbGliLnNvdXJjZWZvcmdlLm5ldC8=" title="http://loki-lib.sourceforge.net/">Loki<i class="fa fa-external-link"></i></span> ：C++库的设计，包括常见的设计模式和习语的实现。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9taWxpLw==" title="https://code.google.com/p/mili/">MiLi<i class="fa fa-external-link"></i></span> ：只含头文件的小型C++库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZnJhbWV3b3Jrcy5jYy8=" title="http://www.openframeworks.cc/">openFrameworks<i class="fa fa-external-link"></i></span> ：开发C++工具包，用于创意性编码。</li><li><span class="exturl" data-url="aHR0cDovL3F0LXByb2plY3Qub3JnLw==" title="http://qt-project.org/">Qt<i class="fa fa-external-link"></i></span> ：跨平台的应用程序和用户界面框架</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3JlYXNvbi8=" title="http://code.google.com/p/reason/">Reason<i class="fa fa-external-link"></i></span> ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。</li><li><span class="exturl" data-url="aHR0cDovL3Jvb3QuY2Vybi5jaC8=" title="http://root.cern.ch/">ROOT<i class="fa fa-external-link"></i></span> ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdGxwb3J0Lm9yZy8=" title="http://www.stlport.org/">STLport<i class="fa fa-external-link"></i></span>：是STL具有代表性的版本</li><li><span class="exturl" data-url="aHR0cDovL3N0eHhsLnNvdXJjZWZvcmdlLm5ldC8=" title="http://stxxl.sourceforge.net/">STXXL<i class="fa fa-external-link"></i></span>：用于额外的大型数据集的标准模板库。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy51bHRpbWF0ZXBwLm9yZy8=" title="http://www.ultimatepp.org/">Ultimate++<i class="fa fa-external-link"></i></span> ：C++跨平台快速应用程序开发框架</li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy93dGwv" title="http://sourceforge.net/projects/wtl/">Windows Template Library<i class="fa fa-external-link"></i></span>：用于开发Windows应用程序和UI组件的C++库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2psbDYzL3lvbW0xMQ==" title="https://github.com/jll63/yomm11">Yomm11<i class="fa fa-external-link"></i></span> ：C++11的开放multi-methods.</li></ul><p>&nbsp;</p><h3>人工智能</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FpZ2FtZWRldi9idHNr" title="https://github.com/aigamedev/btsk">btsk<i class="fa fa-external-link"></i></span> ：游戏行为树启动器工具</li><li><span class="exturl" data-url="aHR0cDovL2VvZGV2LnNvdXJjZWZvcmdlLm5ldC8=" title="http://eodev.sourceforge.net/">Evolving Objects<i class="fa fa-external-link"></i></span>：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuZHJvbWV0YS9uZXU=" title="https://github.com/andrometa/neu">Neu<i class="fa fa-external-link"></i></span>：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。</li></ul><p>&nbsp;</p><h3>异步事件循环</h3><ul><li><span class="exturl" data-url="aHR0cDovL3RoaW5rLWFzeW5jLmNvbS8=" title="http://think-async.com/">Boost.Asio<i class="fa fa-external-link"></i></span>：用于网络和底层I/O编程的跨平台的C++库。</li><li><span class="exturl" data-url="aHR0cDovL2xpYmV2LnNjaG1vcnAuZGUv" title="http://libev.schmorp.de/">libev<i class="fa fa-external-link"></i></span> ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。</li><li><span class="exturl" data-url="aHR0cDovL2xpYmV2ZW50Lm9yZy8=" title="http://libevent.org/">libevent<i class="fa fa-external-link"></i></span> ：事件通知库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9saWJ1dg==" title="https://github.com/joyent/libuv">libuv<i class="fa fa-external-link"></i></span> ：跨平台异步I/O。</li></ul><p>&nbsp;</p><h3>音频</h3><p>音频，声音，音乐，数字化音乐库</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5mbW9kLm9yZy8=" title="http://www.fmod.org/">FMOD<i class="fa fa-external-link"></i></span> ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY2tub2lzZS9NYXhpbWlsaWFu" title="https://github.com/micknoise/Maximilian">Maximilian<i class="fa fa-external-link"></i></span> ：C++音频和音乐数字信号处理库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuYWwub3JnLw==" title="http://www.openal.org/">OpenAL<i class="fa fa-external-link"></i></span> ：开源音频库&#8212;跨平台的音频API</li><li><span class="exturl" data-url="aHR0cDovL29wdXMtY29kZWMub3JnLw==" title="http://opus-codec.org/">Opus<i class="fa fa-external-link"></i></span>：一个完全开放的，免版税的，高度通用的音频编解码器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zcGVleC5vcmcv" title="http://www.speex.org/">Speex<i class="fa fa-external-link"></i></span>：免费编解码器，为Opus所废弃</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RvbmljQXVkaW8vVG9uaWM=" title="https://github.com/TonicAudio/Tonic">Tonic<i class="fa fa-external-link"></i></span>： C++易用和高效的音频合成</li><li><span class="exturl" data-url="aHR0cDovL3hpcGgub3JnL3ZvcmJpcy8=" title="http://xiph.org/vorbis/">Vorbis<i class="fa fa-external-link"></i></span>： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。</li></ul><p>&nbsp;</p><h3>生态学</h3><p>生物信息，基因组学和生物技术</p><ul><li><span class="exturl" data-url="aHR0cDovL21vbHBvcGdlbi5naXRodWIuaW8vbGlic2VxdWVuY2Uv" title="http://molpopgen.github.io/libsequence/">libsequence<i class="fa fa-external-link"></i></span>：用于表示和分析群体遗传学数据的C++库。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zZXFhbi5kZS8=" title="http://www.seqan.de/">SeqAn<i class="fa fa-external-link"></i></span>：专注于生物数据序列分析的算法和数据结构。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VrZy92Y2ZsaWI=" title="https://github.com/ekg/vcflib">Vcflib<i class="fa fa-external-link"></i></span> ：用于解析和处理VCF文件的C++库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pld21hbmNodWUvd2hhbQ==" title="https://github.com/jewmanchue/wham">Wham<i class="fa fa-external-link"></i></span>：直接把联想测试应用到BAM文件的基因结构变异。</li></ul><p>&nbsp;</p><h3>压缩</h3><p>压缩和归档库</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5iemlwLm9yZy8=" title="http://www.bzip.org/">bzip2<i class="fa fa-external-link"></i></span>：一个完全免费，免费专利和高质量的数据压缩</li><li><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL2F0dGlsYV9hZnJhL2RvYm96L292ZXJ2aWV3" title="https://bitbucket.org/attila_afra/doboz/overview">doboz<i class="fa fa-external-link"></i></span>：能够快速解压缩的压缩库</li><li><span class="exturl" data-url="aHR0cHM6Ly9pY2N1bHVzLm9yZy9waHlzZnMv" title="https://icculus.org/physfs/">PhysicsFS<i class="fa fa-external-link"></i></span>：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。</li><li><span class="exturl" data-url="aHR0cHM6Ly9wcm9qZWN0cy5rZGUub3JnL3Byb2plY3RzL2ZyYW1ld29ya3Mva2FyY2hpdmU=" title="https://projects.kde.org/projects/frameworks/karchive">KArchive<i class="fa fa-external-link"></i></span>：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9sejQv" title="https://code.google.com/p/lz4/">LZ4<i class="fa fa-external-link"></i></span> ：非常快速的压缩算法</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9semhhbS8=" title="https://code.google.com/p/lzham/">LZHAM<i class="fa fa-external-link"></i></span> ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy43LXppcC5vcmcvc2RrLmh0bWw=" title="http://www.7-zip.org/sdk.html">LZMA<i class="fa fa-external-link"></i></span> ：7z格式默认和通用的压缩方法。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tYXRjb2RlLmNvbS9sem1hdC5odG0=" title="http://www.matcode.com/lzmat.htm">LZMAT<i class="fa fa-external-link"></i></span> ：及其快速的实时无损数据压缩库</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9taW5pei8=" title="https://code.google.com/p/miniz/">miniz<i class="fa fa-external-link"></i></span>：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25tb2ludmF6L21pbml6aXA=" title="https://github.com/nmoinvaz/minizip">Minizip<i class="fa fa-external-link"></i></span>：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9zbmFwcHkv" title="https://code.google.com/p/snappy/">Snappy<i class="fa fa-external-link"></i></span> ：快速压缩和解压缩</li><li><span class="exturl" data-url="aHR0cDovL3psaWIubmV0Lw==" title="http://zlib.net/">ZLib<i class="fa fa-external-link"></i></span> ：非常紧凑的数据流压缩库</li><li><span class="exturl" data-url="aHR0cDovL3p6aXBsaWIuc291cmNlZm9yZ2UubmV0Lw==" title="http://zziplib.sourceforge.net/">ZZIPlib<i class="fa fa-external-link"></i></span>：提供ZIP归档的读权限。</li></ul><p>&nbsp;</p><h3>并发性</h3><p>并发执行和多线程</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t5bGVsdXR6L2NvbXB1dGU=" title="https://github.com/kylelutz/compute">Boost.Compute<i class="fa fa-external-link"></i></span> ：用于OpenCL的C++GPU计算库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hTQS1MaWJyYXJpZXMvQm9sdA==" title="https://github.com/HSA-Libraries/Bolt">Bolt<i class="fa fa-external-link"></i></span> ：针对GPU进行优化的C++模板库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaGxhbmdzdGVyL2NwcC5yZWFjdA==" title="https://github.com/schlangster/cpp.react">C++React<i class="fa fa-external-link"></i></span> ：用于C++11的反应性编程库</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGhyZWFkaW5nYnVpbGRpbmdibG9ja3Mub3JnLw==" title="https://www.threadingbuildingblocks.org/">Intel TBB<i class="fa fa-external-link"></i></span> ：Intel线程构件块</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYmNsc3BoL2xpYmNsc3Bo" title="https://github.com/libclsph/libclsph">Libclsph<i class="fa fa-external-link"></i></span>：基于OpenCL的GPU加速SPH流体仿真库</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmNsLw==" title="https://www.khronos.org/opencl/">OpenCL<i class="fa fa-external-link"></i></span> ：并行编程的异构系统的开放标准</li><li><span class="exturl" data-url="aHR0cDovL29wZW5tcC5vcmcv" title="http://openmp.org/">OpenMP<i class="fa fa-external-link"></i></span>：OpenMP API</li><li><span class="exturl" data-url="aHR0cDovL3RocnVzdC5naXRodWIuaW8v" title="http://thrust.github.io/">Thrust<i class="fa fa-external-link"></i></span> ：类似于C++标准模板库的并行算法库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NURWxsQVItR1JPVVAvaHB4Lw==" title="https://github.com/STEllAR-GROUP/hpx/">HPX<i class="fa fa-external-link"></i></span> ：用于任何规模的并行和分布式应用程序的通用C++运行时系统</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RkZW1pZG92L3ZleGNs" title="https://github.com/ddemidov/vexcl">VexCL<i class="fa fa-external-link"></i></span> ：用于OpenCL/CUDA 的C++向量表达式模板库。</li></ul><p>&nbsp;</p><h3>容器</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcHAtYnRyZWUv" title="https://code.google.com/p/cpp-btree/">C++ B-tree<i class="fa fa-external-link"></i></span> ：基于B树数据结构，实现命令内存容器的模板库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb3NzYWVydC9oYXNobWFw" title="https://github.com/goossaert/hashmap">Hashmaps<i class="fa fa-external-link"></i></span>： C++中开放寻址哈希表算法的实现</li></ul><p>&nbsp;</p><h3>密码学</h3><ul><li><span class="exturl" data-url="aHR0cDovL2JjcnlwdC5zb3VyY2Vmb3JnZS5uZXQv" title="http://bcrypt.sourceforge.net/">Bcrypt<i class="fa fa-external-link"></i></span> ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZmZmFyYXovYXdlc29tZS1jcHAvYmxvYi9tYXN0ZXI=" title="https://github.com/fffaraz/awesome-cpp/blob/master">BeeCrypt<i class="fa fa-external-link"></i></span>：</li><li><span class="exturl" data-url="aHR0cDovL2JvdGFuLnJhbmRvbWJpdC5uZXQv" title="http://botan.randombit.net/">Botan<i class="fa fa-external-link"></i></span>： C++加密库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcnlwdG9wcC5jb20v" title="http://www.cryptopp.com/">Crypto++<i class="fa fa-external-link"></i></span>：一个有关加密方案的免费的C++库</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ251cGcub3JnLw==" title="https://www.gnupg.org/">GnuPG<i class="fa fa-external-link"></i></span>： OpenPGP标准的完整实现</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnV0bHMub3JnLw==" title="http://www.gnutls.org/">GnuTLS<i class="fa fa-external-link"></i></span> ：实现了SSL，TLS和DTLS协议的安全通信库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2xpYmdjcnlwdC8=" title="http://www.gnu.org/software/libgcrypt/">Libgcrypt<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZmZmFyYXovYXdlc29tZS1jcHAvYmxvYi9tYXN0ZXI=" title="https://github.com/fffaraz/awesome-cpp/blob/master">libmcrypt<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWJyZXNzbC5vcmcv" title="http://www.libressl.org/">LibreSSL<i class="fa fa-external-link"></i></span>：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYnRvbS9saWJ0b21jcnlwdA==" title="https://github.com/libtom/libtomcrypt">LibTomCrypt<i class="fa fa-external-link"></i></span>：一个非常全面的，模块化的，可移植的加密工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plZGlzY3QxL2xpYnNvZGl1bQ==" title="https://github.com/jedisct1/libsodium">libsodium<i class="fa fa-external-link"></i></span>：基于NaCI的加密库，固执己见，容易使用</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5seXNhdG9yLmxpdS5zZS9+bmlzc2UvbmV0dGxlLw==" title="http://www.lysator.liu.se/~nisse/nettle/">Nettle<i class="fa fa-external-link"></i></span> 底层的加密库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuc3NsLm9yZy8=" title="http://www.openssl.org/">OpenSSL<i class="fa fa-external-link"></i></span> ： 一个强大的，商用的，功能齐全的，开放源代码的加密库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tva2tlL3RpbnktQUVTMTI4LUM=" title="https://github.com/kokke/tiny-AES128-C">Tiny AES128 in C<i class="fa fa-external-link"></i></span> ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法</li></ul><p>&nbsp;</p><h3>数据库</h3><p>数据库，SQL服务器，ODBC驱动程序和工具</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhdWxmdHcvaGliZXJsaXRl" title="https://github.com/paulftw/hiberlite">hiberlite<i class="fa fa-external-link"></i></span> ：用于Sqlite3的C++对象关系映射</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZGlzL2hpcmVkaXM=" title="https://github.com/redis/hiredis">Hiredis<i class="fa fa-external-link"></i></span>： 用于Redis数据库的很简单的C客户端库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://github.com/google/leveldb">LevelDB<i class="fa fa-external-link"></i></span>： 快速键值存储库</li><li><span class="exturl" data-url="aHR0cDovL3N5bWFzLmNvbS9tZGIv" title="http://symas.com/mdb/">LMDB<i class="fa fa-external-link"></i></span>：符合数据库四大基本元素的嵌入键值存储</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50YW5nZW50c29mdC5uZXQvbXlzcWwrKy8=" title="http://www.tangentsoft.net/mysql++/">MySQL++<i class="fa fa-external-link"></i></span>：封装了MySql的C API的C++ 包装器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGI=" title="https://github.com/facebook/rocksdb">RocksDB<i class="fa fa-external-link"></i></span>：来自Facebook的嵌入键值的快速存储</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zcWxpdGUub3JnLw==" title="http://www.sqlite.org/">SQLite<i class="fa fa-external-link"></i></span>：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。</li></ul><p>&nbsp;</p><h3>调试</h3><p>调试库， 内存和资源泄露检测，单元测试</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ib29zdC5vcmcvZG9jL2xpYnMvbWFzdGVyL2xpYnMvdGVzdC9kb2MvaHRtbC9pbmRleC5odG1s" title="http://www.boost.org/doc/libs/master/libs/test/doc/html/index.html">Boost.Test<i class="fa fa-external-link"></i></span>：Boost测试库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BoaWxzcXVhcmVkL0NhdGNo" title="https://github.com/philsquared/Catch">Catch<i class="fa fa-external-link"></i></span>：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5mcmVlZGVza3RvcC5vcmcvd2lraS9Tb2Z0d2FyZS9jcHB1bml0Lw==" title="http://www.freedesktop.org/wiki/Software/cppunit/">CppUnit<i class="fa fa-external-link"></i></span>：由JUnit移植过来的C++测试框架</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbWFrZS5vcmcvY21ha2UvaGVscC92Mi44LjgvY3Rlc3QuaHRtbA==" title="http://www.cmake.org/cmake/help/v2.8.8/ctest.html">CTest<i class="fa fa-external-link"></i></span>：CMake测试驱动程序</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZXRlc3Qv" title="http://code.google.com/p/googletest/">googletest<i class="fa fa-external-link"></i></span>：谷歌C++测试框架</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RlcGxpbmVub2lzZS9pZy1kZWJ1Z2hlYXA=" title="https://github.com/deplinenoise/ig-debugheap">ig-debugheap<i class="fa fa-external-link"></i></span>：用于跟踪内存错误的多平台调试堆</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pvcmduYXgvbGlidGFw" title="https://github.com/zorgnax/libtap">libtap<i class="fa fa-external-link"></i></span>：用C语言编写测试</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5hbG1vc3RpbmZpbml0ZS5jb20vbWVtdHJhY2suaHRtbA==" title="http://www.almostinfinite.com/memtrack.html">MemTrack<i class="fa fa-external-link"></i></span> —用于C++跟踪内存分配</li><li><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL2pvbmFzbWV5ZXIvbWljcm9wcm9maWxlL292ZXJ2aWV3" title="https://bitbucket.org/jonasmeyer/microprofile/overview">microprofile<i class="fa fa-external-link"></i></span>- 跨平台的网络试图分析器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5qZXJhLmNvbS90ZWNoaW5mby9qdG5zL2p0bjAwMi5odG1s" title="http://www.jera.com/techinfo/jtns/jtn002.html">minUnit<i class="fa fa-external-link"></i></span> ：使用C写的迷你单元测试框架，只使用了两个宏</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NlbHRveXMvUmVtb3Rlcnk=" title="https://github.com/Celtoys/Remotery">Remotery<i class="fa fa-external-link"></i></span>：用于web视图的单一C文件分析器</li><li><span class="exturl" data-url="aHR0cDovL3VuaXR0ZXN0LWNwcC5zb3VyY2Vmb3JnZS5uZXQv" title="http://unittest-cpp.sourceforge.net/">UnitTest++<i class="fa fa-external-link"></i></span>：轻量级的C++单元测试框架</li></ul><p>&nbsp;</p><h3>游戏引擎</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2NvczJkLXgub3JnLw==" title="http://www.cocos2d-x.org/">Cocos2d-x<i class="fa fa-external-link"></i></span> ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。</li><li><span class="exturl" data-url="aHR0cDovL2dyaXRlbmdpbmUuY29tLw==" title="http://gritengine.com/">Grit<i class="fa fa-external-link"></i></span> ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。</li><li><span class="exturl" data-url="aHR0cDovL2lycmxpY2h0LnNvdXJjZWZvcmdlLm5ldC8=" title="http://irrlicht.sourceforge.net/">Irrlicht<i class="fa fa-external-link"></i></span> ：C++语言编写的开源高性能的实时#D引擎</li><li><span class="exturl" data-url="aHR0cDovL3BvbHljb2RlLm9yZy8=" title="http://polycode.org/">Polycode<i class="fa fa-external-link"></i></span>：C++实现的用于创建游戏的开源框架（与Lua绑定）。</li></ul><p>&nbsp;</p><h3>图形用户界面</h3><ul><li><span class="exturl" data-url="aHR0cDovL2NlZ3VpLm9yZy51ay8=" title="http://cegui.org.uk/">CEGUI<i class="fa fa-external-link"></i></span> ： 很灵活的跨平台GUI库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5mbHRrLm9yZy9pbmRleC5waHA=" title="http://www.fltk.org/index.php">FLTK<i class="fa fa-external-link"></i></span> ：快速，轻量级的跨平台的C++GUI工具包。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ndGsub3JnLw==" title="http://www.gtk.org/">GTK+<i class="fa fa-external-link"></i></span>： 用于创建图形用户界面的跨平台工具包</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ndGttbS5vcmcvZW4v" title="http://www.gtkmm.org/en/">gtkmm<i class="fa fa-external-link"></i></span> ：用于受欢迎的GUI库GTK+的官方C++接口。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29jb3JudXQvaW1ndWk=" title="https://github.com/ocornut/imgui">imgui<i class="fa fa-external-link"></i></span>：拥有最小依赖关系的立即模式图形用户界面</li><li><span class="exturl" data-url="aHR0cDovL2xpYnJvY2tldC5jb20v" title="http://librocket.com/">libRocket<i class="fa fa-external-link"></i></span> ：<span class="exturl" data-url="aHR0cDovL2xpYnJvY2tldC5jb20v" title="http://librocket.com/">libRocket<i class="fa fa-external-link"></i></span> 是一个C++ HTML/CSS 游戏接口中间件</li><li><span class="exturl" data-url="aHR0cDovL215Z3VpLmluZm8v" title="http://mygui.info/">MyGUI<i class="fa fa-external-link"></i></span> ：快速，灵活，简单的GUI</li><li><span class="exturl" data-url="aHR0cDovL2ludmlzaWJsZS1pc2xhbmQubmV0L25jdXJzZXMv" title="http://invisible-island.net/ncurses/">Ncurses<i class="fa fa-external-link"></i></span>：终端用户界面</li><li><span class="exturl" data-url="aHR0cDovL3FjdXN0b21wbG90LmNvbS8=" title="http://qcustomplot.com/">QCustomPlot<i class="fa fa-external-link"></i></span> ：没有更多依赖关系的Qt绘图控件</li><li><span class="exturl" data-url="aHR0cDovL3F3dC5zb3VyY2Vmb3JnZS5uZXQv" title="http://qwt.sourceforge.net/">Qwt<i class="fa fa-external-link"></i></span> ：用户与技术应用的Qt 控件</li><li><span class="exturl" data-url="aHR0cDovL3F3dHBsb3QzZC5zb3VyY2Vmb3JnZS5uZXQv" title="http://qwtplot3d.sourceforge.net/">QwtPlot3D<i class="fa fa-external-link"></i></span> ：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R3b2xld2lzL090dGVyVUk=" title="https://github.com/Twolewis/OtterUI">OtterUI<i class="fa fa-external-link"></i></span> ：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R3b2xld2lzL090dGVyVUk=" title="https://github.com/Twolewis/OtterUI">OtterUI<i class="fa fa-external-link"></i></span> 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案</li><li><span class="exturl" data-url="aHR0cDovL3BkY3Vyc2VzLnNvdXJjZWZvcmdlLm5ldC8=" title="http://pdcurses.sourceforge.net/">PDCurses<i class="fa fa-external-link"></i></span> 包含源代码和预编译库的公共图形函数库</li><li><span class="exturl" data-url="aHR0cDovL3d4d2lkZ2V0cy5vcmcv" title="http://wxwidgets.org/">wxWidgets<i class="fa fa-external-link"></i></span> C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序</li></ul><p>&nbsp;</p><h3>图形</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JrYXJhZHppYy9iZ2Z4" title="https://github.com/bkaradzic/bgfx">bgfx<i class="fa fa-external-link"></i></span>：跨平台的渲染库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jYWlyb2dyYXBoaWNzLm9yZy8=" title="http://www.cairographics.org/">Cairo<i class="fa fa-external-link"></i></span>：支持多种输出设备的2D图形库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvcmRlM2QvSG9yZGUzRA==" title="https://github.com/horde3d/Horde3D">Horde3D<i class="fa fa-external-link"></i></span> 一个小型的3D渲染和动画引擎</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vc3JhL21hZ251bQ==" title="https://github.com/mosra/magnum">magnum<i class="fa fa-external-link"></i></span> C++11和OpenGL 2D/3D 图形引擎</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vZ3JlM2Qub3JnLw==" title="http://www.ogre3d.org/">Ogre 3D<i class="fa fa-external-link"></i></span> 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuc2NlbmVncmFwaC5vcmcv" title="http://www.openscenegraph.org/">OpenSceneGraph<i class="fa fa-external-link"></i></span> 具有高性能的开源3D图形工具包</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5wYW5kYTNkLm9yZy8=" title="http://www.panda3d.org/">Panda3D<i class="fa fa-external-link"></i></span> 用于3D渲染和游戏开发的框架，用Python和C++编写。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9za2lh" title="https://github.com/google/skia">Skia<i class="fa fa-external-link"></i></span> 用于绘制文字，图形和图像的完整的2D图形库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VyaG8zZC9VcmhvM0Q=" title="https://github.com/urho3d/Urho3D">urho3d<i class="fa fa-external-link"></i></span> 跨平台的渲染和游戏引擎。</li></ul><p>&nbsp;</p><h3>图像处理</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ib29zdC5vcmcvZG9jL2xpYnMvMV81Nl8wL2xpYnMvZ2lsL2RvYy9pbmRleC5odG1s" title="http://www.boost.org/doc/libs/1_56_0/libs/gil/doc/index.html">Boost.GIL<i class="fa fa-external-link"></i></span>：通用图像库</li><li><span class="exturl" data-url="aHR0cDovL2NpbWcuc291cmNlZm9yZ2UubmV0Lw==" title="http://cimg.sourceforge.net/">CImg<i class="fa fa-external-link"></i></span> ：用于图像处理的小型开源C++工具包</li><li><span class="exturl" data-url="aHR0cDovL3d3dy54ZHAuaXQvY3hpbWFnZS5odG0=" title="http://www.xdp.it/cximage.htm">CxImage<i class="fa fa-external-link"></i></span> ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。</li><li><span class="exturl" data-url="aHR0cDovL2ZyZWVpbWFnZS5zb3VyY2Vmb3JnZS5uZXQv" title="http://freeimage.sourceforge.net/">FreeImage<i class="fa fa-external-link"></i></span> ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。</li><li><span class="exturl" data-url="aHR0cDovL2dkY20uc291cmNlZm9yZ2UubmV0L3dpa2kvaW5kZXgucGhwL01haW5fUGFnZQ==" title="http://gdcm.sourceforge.net/wiki/index.php/Main_Page">GDCM<i class="fa fa-external-link"></i></span>：Grassroots DICOM 库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pdGsub3JnLw==" title="http://www.itk.org/">ITK<i class="fa fa-external-link"></i></span>：跨平台的开源图像分析系统</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmcvc2NyaXB0L2FwaS5waHA=" title="http://www.imagemagick.org/script/api.php">Magick++<i class="fa fa-external-link"></i></span>：ImageMagick程序的C++接口</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmcvc2NyaXB0L2FwaS5waHA=" title="http://www.imagemagick.org/script/api.php">MagickWnd<i class="fa fa-external-link"></i></span>：ImageMagick程序的C++接口</li><li><span class="exturl" data-url="aHR0cDovL29wZW5jdi5vcmcv" title="http://opencv.org/">OpenCV<i class="fa fa-external-link"></i></span> ： 开源计算机视觉类库</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC90ZXNzZXJhY3Qtb2NyLw==" title="https://code.google.com/p/tesseract-ocr/">tesseract-ocr<i class="fa fa-external-link"></i></span>：OCR引擎</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Vrb2V0aGUvdmlncmE=" title="https://github.com/ukoethe/vigra">VIGRA<i class="fa fa-external-link"></i></span> ：用于图像分析通用C++计算机视觉库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy52dGsub3JnLw==" title="http://www.vtk.org/">VTK<i class="fa fa-external-link"></i></span> ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</li></ul><p>&nbsp;</p><h3>国际化</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2dldHRleHQv" title="http://www.gnu.org/software/gettext/">gettext<i class="fa fa-external-link"></i></span> ：GNU `gettext&#8217;</li><li><span class="exturl" data-url="aHR0cDovL3NpdGUuaWN1LXByb2plY3Qub3JnLw==" title="http://site.icu-project.org/">IBM ICU<i class="fa fa-external-link"></i></span>：提供Unicode 和全球化支持的C、C++ 和Java库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2xpYmljb252Lw==" title="http://www.gnu.org/software/libiconv/">libiconv<i class="fa fa-external-link"></i></span> ：用于不同字符编码之间的编码转换库</li></ul><p>&nbsp;</p><h3>Jason</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvZnJvemVu" title="https://github.com/cesanta/frozen">frozen<i class="fa fa-external-link"></i></span> ： C/C++的Jason解析生成器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FraGVyb24vamFuc3Nvbg==" title="https://github.com/akheron/jansson">Jansson<i class="fa fa-external-link"></i></span> ：进行编解码和处理Jason数据的C语言库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NocmlzbWFubmluZy9qYnNvbg==" title="https://github.com/chrismanning/jbson">jbson<i class="fa fa-external-link"></i></span> ：C++14中构建和迭代BSON data,和Json 文档的库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plYXllL2plYXllc29u" title="https://github.com/jeaye/jeayeson">JeayeSON<i class="fa fa-external-link"></i></span>：非常健全的C++ JSON库，只包含头文件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hqaWFuZy9qc29ueHg=" title="https://github.com/hjiang/jsonxx">JSON++<i class="fa fa-external-link"></i></span> ： C++ JSON 解析器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VkcC9qc29uLXBhcnNlcg==" title="https://github.com/udp/json-parser">json-parser<i class="fa fa-external-link"></i></span>：用可移植的ANSI C编写的JSON解析器，占用内存非常少</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Ryb3Bib3gvanNvbjEx" title="https://github.com/dropbox/json11">json11<i class="fa fa-external-link"></i></span> ：一个迷你的C++11 JSON库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtaXItcy9qdXRl" title="https://github.com/amir-s/jute">jute<i class="fa fa-external-link"></i></span> ：非常简单的C++ JSON解析器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZpbmNlbnRoei9saWJqc29u" title="https://github.com/vincenthz/libjson">ibjson<i class="fa fa-external-link"></i></span>：C语言中的JSON解析和打印库，很容易和任何模型集成。</li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy9saWJqc29uLw==" title="http://sourceforge.net/projects/libjson/">libjson<i class="fa fa-external-link"></i></span>：轻量级的JSON库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2thenVoby9waWNvanNvbg==" title="https://github.com/kazuho/picojson">PicoJSON<i class="fa fa-external-link"></i></span>：C++中JSON解析序列化，只包含头文件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dhdWRlY2tlci9xdC1qc29u" title="https://github.com/gaudecker/qt-json">qt-json<i class="fa fa-external-link"></i></span> ：用于JSON数据和 QVariant层次间的相互解析的简单类</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsYXZpby9xanNvbg==" title="https://github.com/flavio/qjson">QJson<i class="fa fa-external-link"></i></span>：将JSON数据映射到QVariant对象的基于Qt的库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pbG95aXAvcmFwaWRqc29u" title="https://github.com/miloyip/rapidjson">RapidJSON<i class="fa fa-external-link"></i></span>： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xsb3lkL3lhamw=" title="https://github.com/lloyd/yajl">YAJL<i class="fa fa-external-link"></i></span> ：C语言中快速流JSON解析库</li></ul><p>&nbsp;</p><h3>日志</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ib29zdC5vcmcvZG9jL2xpYnMvMV81Nl8wL2xpYnMvbG9nL2RvYy9odG1sL2luZGV4Lmh0bWw=" title="http://www.boost.org/doc/libs/1_56_0/libs/log/doc/html/index.html">Boost.Log<i class="fa fa-external-link"></i></span> ：设计非常模块化，并且具有扩展性</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Vhc3lsb2dnaW5nL2Vhc3lsb2dnaW5ncHA=" title="https://github.com/easylogging/easyloggingpp">easyloggingpp<i class="fa fa-external-link"></i></span>：C++日志库，只包含单一的头文件。</li><li><span class="exturl" data-url="aHR0cDovL2xvZzRjcHAuc291cmNlZm9yZ2UubmV0Lw==" title="http://log4cpp.sourceforge.net/">Log4cpp<i class="fa fa-external-link"></i></span> ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50ZW1wbG9nLm9yZy8=" title="http://www.templog.org/">templog<i class="fa fa-external-link"></i></span>：轻量级C++库，可以添加日志到你的C++应用程序中</li></ul><p>&nbsp;</p><h3>机器学习</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JWTEMvY2FmZmU=" title="https://github.com/BVLC/caffe">Caffe<i class="fa fa-external-link"></i></span> ：快速的神经网络框架</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdWxpdS9jY3Y=" title="https://github.com/liuliu/ccv">CCV<i class="fa fa-external-link"></i></span> ：以C语言为核心的现代计算机视觉库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tbHBhY2sub3JnLw==" title="http://www.mlpack.org/">mlpack<i class="fa fa-external-link"></i></span> ：可扩展的C++机器学习库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0l0c2Vlei9vcGVuY3Y=" title="https://github.com/Itseez/opencv">OpenCV<i class="fa fa-external-link"></i></span>：开源计算机视觉库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dIYW1yb3VuaS9SZWNvbW1lbmRlcg==" title="https://github.com/GHamrouni/Recommender">Recommender<i class="fa fa-external-link"></i></span>：使用协同过滤进行产品推荐/建议的C语言库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nob2d1bi10b29sYm94L3Nob2d1bg==" title="https://github.com/shogun-toolbox/shogun">SHOGUN<i class="fa fa-external-link"></i></span>：Shogun 机器学习工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9zb2ZpYS1tbC8=" title="https://code.google.com/p/sofia-ml/">sofia-ml<i class="fa fa-external-link"></i></span> ：用于机器学习的快速增量算法套件</li></ul><p>&nbsp;</p><h3>数学</h3><ul><li><span class="exturl" data-url="aHR0cDovL2FybWEuc291cmNlZm9yZ2UubmV0Lw==" title="http://arma.sourceforge.net/">Armadillo<i class="fa fa-external-link"></i></span> ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9ibGF6ZS1saWIv" title="https://code.google.com/p/blaze-lib/">blaze<i class="fa fa-external-link"></i></span>：高性能的C++数学库，用于密集和稀疏算法。</li><li><span class="exturl" data-url="aHR0cDovL2NlcmVzLXNvbHZlci5vcmcv" title="http://ceres-solver.org/">ceres-solver<i class="fa fa-external-link"></i></span> ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jZ2FsLm9yZy8=" title="http://www.cgal.org/">CGal<i class="fa fa-external-link"></i></span>： 高效，可靠的集合算法集合</li><li><span class="exturl" data-url="aHR0cDovL2NtbGRldi5uZXQv" title="http://cmldev.net/">cml<i class="fa fa-external-link"></i></span> ：用于游戏和图形的免费C++数学库</li><li><span class="exturl" data-url="aHR0cDovL2VpZ2VuLnR1eGZhbWlseS5vcmcv" title="http://eigen.tuxfamily.org/">Eigen<i class="fa fa-external-link"></i></span> ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。</li><li><span class="exturl" data-url="aHR0cDovL2dndC5zb3VyY2Vmb3JnZS5uZXQv" title="http://ggt.sourceforge.net/">GMTL<i class="fa fa-external-link"></i></span>：数学图形模板库是一组广泛实现基本图形的工具。</li><li><span class="exturl" data-url="aHR0cHM6Ly9nbXBsaWIub3JnLw==" title="https://gmplib.org/">GMP<i class="fa fa-external-link"></i></span>：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。</li></ul><p>&nbsp;</p><h3>多媒体</h3><ul><li><span class="exturl" data-url="aHR0cDovL2dzdHJlYW1lci5mcmVlZGVza3RvcC5vcmcv" title="http://gstreamer.freedesktop.org/">GStreamer<i class="fa fa-external-link"></i></span> ：构建媒体处理组件图形的库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saXZlNTU1LmNvbS9saXZlTWVkaWEv" title="http://www.live555.com/liveMedia/">LIVE555 Streaming Media<i class="fa fa-external-link"></i></span> ：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库</li><li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLnZpZGVvbGFuLm9yZy9MaWJWTEM=" title="https://wiki.videolan.org/LibVLC">libVLC<i class="fa fa-external-link"></i></span> ：libVLC (VLC SDK)媒体框架</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmctYmluL1F0QVY=" title="https://github.com/wang-bin/QtAV">QtAv<i class="fa fa-external-link"></i></span>：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWJzZGwub3JnLw==" title="http://www.libsdl.org/">SDL<i class="fa fa-external-link"></i></span> ：简单直控媒体层</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zZm1sLWRldi5vcmcv" title="http://www.sfml-dev.org/">SFML<i class="fa fa-external-link"></i></span> ：快速，简单的多媒体库</li></ul><p>&nbsp;</p><h3>网络</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcy53dXN0bC5lZHUvfnNjaG1pZHQvQUNFLmh0bWw=" title="http://www.cs.wustl.edu/~schmidt/ACE.html">ACE<i class="fa fa-external-link"></i></span>：C++面向对象网络变成工具包</li><li><span class="exturl" data-url="aHR0cDovL3RoaW5rLWFzeW5jLmNvbS8=" title="http://think-async.com/">Boost.Asio<i class="fa fa-external-link"></i></span>：用于网络和底层I/O编程的跨平台的C++库</li><li><span class="exturl" data-url="aHR0cDovL2Nhc2FibGFuY2EuY29kZXBsZXguY29tLw==" title="http://casablanca.codeplex.com/">Casablanca<i class="fa fa-external-link"></i></span>：C++ REST SDK</li><li><span class="exturl" data-url="aHR0cDovL2NwcC1uZXRsaWIub3JnLw==" title="http://cpp-netlib.org/">cpp-netlib<i class="fa fa-external-link"></i></span>：高级网络编程的开源库集合</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J4aS9keWFk" title="https://github.com/rxi/dyad">Dyad.c<i class="fa fa-external-link"></i></span>：C语言的异步网络</li><li><span class="exturl" data-url="aHR0cDovL2N1cmwuaGF4eC5zZS9saWJjdXJsLw==" title="http://curl.haxx.se/libcurl/">libcurl<i class="fa fa-external-link"></i></span> :多协议文件传输库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvbW9uZ29vc2U=" title="https://github.com/cesanta/mongoose">Mongoose<i class="fa fa-external-link"></i></span><span style="text-decoration: underline;">：</span>非常轻量级的网络服务器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZW5zaHVvL211ZHVv" title="https://github.com/chenshuo/muduo">Muduo<i class="fa fa-external-link"></i></span> ：用于Linux多线程服务器的C++非阻塞网络库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvbmV0X3NrZWxldG9u" title="https://github.com/cesanta/net_skeleton">net_skeleton<i class="fa fa-external-link"></i></span> ：C/C++的TCP 客户端/服务器库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Jpb2xldC9ub3BlLmM=" title="https://github.com/riolet/nope.c">nope.c<i class="fa fa-external-link"></i></span> ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhdmlkbW9yZW5vL29uaW9u" title="https://github.com/davidmoreno/onion">Onion<i class="fa fa-external-link"></i></span> :C语言HTTP服务器库，其设计为轻量级，易使用。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvY29wcm9qZWN0" title="https://github.com/pocoproject">POCO<i class="fa fa-external-link"></i></span>：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09jdWx1c1ZSL1Jha05ldA==" title="https://github.com/OculusVR/RakNet">RakNet<i class="fa fa-external-link"></i></span>：为游戏开发人员提供的跨平台的开源C++网络引擎。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Zpbmlwc21ha2VyL3R1ZmFv" title="https://github.com/vinipsmaker/tufao">Tuf o<i class="fa fa-external-link"></i></span> ：用于Qt之上的C++构建的异步Web框架。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3phcGhveWQvd2Vic29ja2V0cHA=" title="https://github.com/zaphoyd/websocketpp">WebSocket++<i class="fa fa-external-link"></i></span> ：基于C++/Boost Aiso的websocket 客户端/服务器库</li><li><span class="exturl" data-url="aHR0cDovL3plcm9tcS5vcmcv" title="http://zeromq.org/">ZeroMQ<i class="fa fa-external-link"></i></span> ：高速，模块化的异步通信库</li></ul><p>&nbsp;</p><h3>物理学</h3><p>动力学仿真引擎</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9ib3gyZC8=" title="https://code.google.com/p/box2d/">Box2D<i class="fa fa-external-link"></i></span>：2D的游戏物理引擎。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2J1bGxldHBoeXNpY3MvYnVsbGV0Mw==" title="https://github.com/bulletphysics/bullet3">Bullet<i class="fa fa-external-link"></i></span> ：3D的游戏物理引擎。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NsZW1iY2tlL0NoaXBtdW5rMkQ=" title="https://github.com/slembcke/Chipmunk2D">Chipmunk<i class="fa fa-external-link"></i></span> ：快速，轻量级的2D游戏物理库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9saXF1aWRmdW4=" title="https://github.com/google/liquidfun">LiquidFun<i class="fa fa-external-link"></i></span>：2D的游戏物理引擎</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vZGUub3JnLw==" title="http://www.ode.org/">ODE<i class="fa fa-external-link"></i></span> ：开放动力学引擎-开源，高性能库，模拟刚体动力学。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZhbmRlcmxpbi9vZnhCb3gyZA==" title="https://github.com/vanderlin/ofxBox2d">ofxBox2d<i class="fa fa-external-link"></i></span>：Box2D开源框架包装器。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpbWJvZHkvc2ltYm9keQ==" title="https://github.com/simbody/simbody">Simbody<i class="fa fa-external-link"></i></span> ：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。</li></ul><p>&nbsp;</p><h3>机器人学</h3><ul><li><span class="exturl" data-url="aHR0cDovL21vb3MtaXZwLm9yZy8=" title="http://moos-ivp.org/">MOOS-IvP<i class="fa fa-external-link"></i></span> ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tcnB0Lm9yZy8=" title="http://www.mrpt.org/">MRPT<i class="fa fa-external-link"></i></span>：移动机器人编程工具包</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BvaW50Q2xvdWRMaWJyYXJ5L3BjbA==" title="https://github.com/PointCloudLibrary/pcl">PCL<i class="fa fa-external-link"></i></span> ：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5yb2JvdGljc2xpYnJhcnkub3JnLw==" title="http://www.roboticslibrary.org/">Robotics Library (RL)<i class="fa fa-external-link"></i></span>： 一个独立的C++库，包括机器人动力学，运动规划和控制。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5yb2J3b3JrLmRrL2pyb2J3b3JrLw==" title="http://www.robwork.dk/jrobwork/">RobWork<i class="fa fa-external-link"></i></span>：一组C++库的集合，用于机器人系统的仿真和控制。</li><li><span class="exturl" data-url="aHR0cDovL3dpa2kucm9zLm9yZy8=" title="http://wiki.ros.org/">ROS<i class="fa fa-external-link"></i></span> ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。</li></ul><p>&nbsp;</p><h3>科学计算</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5mZnR3Lm9yZy8=" title="http://www.fftw.org/">FFTW<i class="fa fa-external-link"></i></span> :用一维或者多维计算DFT的C语言库。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2dzbC8=" title="http://www.gnu.org/software/gsl/">GSL<i class="fa fa-external-link"></i></span>：GNU科学库。</li></ul><p>&nbsp;</p><h3>脚本</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NoYWlTY3JpcHQvQ2hhaVNjcmlwdC8=" title="https://github.com/ChaiScript/ChaiScript/">ChaiScript<i class="fa fa-external-link"></i></span> ：用于C++的易于使用的嵌入式脚本语言。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5sdWEub3JnLw==" title="http://www.lua.org/">Lua<i class="fa fa-external-link"></i></span> ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhZnJpdG8vbHVhY3h4" title="https://github.com/dafrito/luacxx">luacxx<i class="fa fa-external-link"></i></span>：用于创建Lua绑定的C++ 11 API</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zd2lnLm9yZy8=" title="http://www.swig.org/">SWIG<i class="fa fa-external-link"></i></span> ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvdjc=" title="https://github.com/cesanta/v7">V7<i class="fa fa-external-link"></i></span>：嵌入式的JavaScript 引擎。</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4Lw==" title="http://code.google.com/p/v8/">V8<i class="fa fa-external-link"></i></span> ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。</li></ul><p>&nbsp;</p><h3>序列化</h3><ul><li><span class="exturl" data-url="aHR0cDovL2tlbnRvbnYuZ2l0aHViLmlvL2NhcG5wcm90by8=" title="http://kentonv.github.io/capnproto/">Cap&#8217;n Proto<i class="fa fa-external-link"></i></span> ：快速数据交换格式和RPC系统。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VTQ2lMYWIvY2VyZWFs" title="https://github.com/USCiLab/cereal">cereal<i class="fa fa-external-link"></i></span> ：C++11 序列化库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9mbGF0YnVmZmVycw==" title="https://github.com/google/flatbuffers">FlatBuffers<i class="fa fa-external-link"></i></span> ：内存高效的序列化库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21zZ3BhY2svbXNncGFjay1j" title="https://github.com/msgpack/msgpack-c">MessagePack<i class="fa fa-external-link"></i></span> ：C/C++的高效二进制序列化库，例如 JSON</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Byb3RvYnVmLw==" title="http://code.google.com/p/protobuf/">protobuf<i class="fa fa-external-link"></i></span> ：协议缓冲，谷歌的数据交换格式。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Byb3RvYnVmLWMvcHJvdG9idWYtYw==" title="https://github.com/protobuf-c/protobuf-c">protobuf-c<i class="fa fa-external-link"></i></span> ：C语言的协议缓冲实现</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlYWwtbG9naWMvc2ltcGxlLWJpbmFyeS1lbmNvZGluZw==" title="https://github.com/real-logic/simple-binary-encoding">SimpleBinaryEncoding<i class="fa fa-external-link"></i></span>：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。</li><li><span class="exturl" data-url="aHR0cHM6Ly90aHJpZnQuYXBhY2hlLm9yZy8=" title="https://thrift.apache.org/">Thrift<i class="fa fa-external-link"></i></span> ：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。</li></ul><p>&nbsp;</p><h3>视频</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy53ZWJtcHJvamVjdC5vcmcvY29kZS8=" title="http://www.webmproject.org/code/">libvpx<i class="fa fa-external-link"></i></span> ：VP8/VP9编码解码SDK</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZmZtcGVnLm9yZy8=" title="https://www.ffmpeg.org/">FFmpeg<i class="fa fa-external-link"></i></span> ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0cnVrdHVyYWcvbGliZGUyNjU=" title="https://github.com/strukturag/libde265">libde265<i class="fa fa-external-link"></i></span> ：开放的h.265视频编解码器的实现。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Npc2NvL29wZW5oMjY0" title="https://github.com/cisco/openh264">OpenH264<i class="fa fa-external-link"></i></span>：开源H.364 编解码器。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50aGVvcmEub3JnLw==" title="http://www.theora.org/">Theora<i class="fa fa-external-link"></i></span> ：免费开源的视频压缩格式。</li></ul><p>&nbsp;</p><h3>虚拟机</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rla2tub2xhZ2kvY2FycA==" title="https://github.com/tekknolagi/carp">CarpVM<i class="fa fa-external-link"></i></span>：C中有趣的VM，让我们一起来看看这个。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3JvcHl0aG9uL21pY3JvcHl0aG9u" title="https://github.com/micropython/micropython">MicroPython<i class="fa fa-external-link"></i></span> ：旨在实现单片机上Python3.x的实现</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pha29ndXQvdGlueXZt" title="https://github.com/jakogut/tinyvm">TinyVM<i class="fa fa-external-link"></i></span>：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。</li></ul><p>&nbsp;</p><h3>Web应用框架</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JlbDIxMjUvY2l2ZXR3ZWI=" title="https://github.com/bel2125/civetweb">Civetweb<i class="fa fa-external-link"></i></span> ：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。</li><li><span class="exturl" data-url="aHR0cDovL2NwcGNtcy5jb20v" title="http://cppcms.com/">CppCMS<i class="fa fa-external-link"></i></span> ：免费高性能的Web开发框架（不是 CMS）.</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lwa24vY3Jvdw==" title="https://github.com/ipkn/crow">Crow<i class="fa fa-external-link"></i></span> ：一个C++微型web框架（灵感来自于Python Flask）</li><li><span class="exturl" data-url="aHR0cHM6Ly9rb3JlLmlvLw==" title="https://kore.io/">Kore<i class="fa fa-external-link"></i></span> :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb3JhbGJpdHMuY29tL2xpYm9uaW9uLw==" title="http://www.coralbits.com/libonion/">libOnion<i class="fa fa-external-link"></i></span>：轻量级的库，帮助你使用C编程语言创建web服务器。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2psYWluZS9xZGphbmdvLw==" title="https://github.com/jlaine/qdjango/">QDjango<i class="fa fa-external-link"></i></span>：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy53ZWJ0b29sa2l0LmV1L3d0" title="http://www.webtoolkit.eu/wt">Wt<i class="fa fa-external-link"></i></span> ：开发Web应用的C++库。</li></ul><p>&nbsp;</p><h3>XML</h3><p>XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWJleHBhdC5vcmcv" title="http://www.libexpat.org/">Expat<i class="fa fa-external-link"></i></span> ：用C语言编写的xml解析库</li><li><span class="exturl" data-url="aHR0cDovL3htbHNvZnQub3JnLw==" title="http://xmlsoft.org/">Libxml2<i class="fa fa-external-link"></i></span> ：Gnome的xml C解析器和工具包</li><li><span class="exturl" data-url="aHR0cDovL2xpYnhtbHBsdXNwbHVzLnNvdXJjZWZvcmdlLm5ldC8=" title="http://libxmlplusplus.sourceforge.net/">libxml++<i class="fa fa-external-link"></i></span> ：C++的xml解析器</li><li><span class="exturl" data-url="aHR0cDovL3B1Z2l4bWwub3JnLw==" title="http://pugixml.org/">PugiXML<i class="fa fa-external-link"></i></span> ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。</li><li><span class="exturl" data-url="aHR0cDovL3JhcGlkeG1sLnNvdXJjZWZvcmdlLm5ldC8=" title="http://rapidxml.sourceforge.net/">RapidXml<i class="fa fa-external-link"></i></span> ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy90aW55eG1sLw==" title="http://sourceforge.net/projects/tinyxml/">TinyXML<i class="fa fa-external-link"></i></span> ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlZXRob21hc29uL3Rpbnl4bWwy" title="https://github.com/leethomason/tinyxml2">TinyXML2<i class="fa fa-external-link"></i></span>：简单快速的C++CML解析器，可以很容易集成到其它项目中。</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC90aWNwcC8=" title="https://code.google.com/p/ticpp/">TinyXML++<i class="fa fa-external-link"></i></span>：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</li><li><span class="exturl" data-url="aHR0cDovL3hlcmNlcy5hcGFjaGUub3JnL3hlcmNlcy1jLw==" title="http://xerces.apache.org/xerces-c/">Xerces-C++<i class="fa fa-external-link"></i></span> ：用可移植的C++的子集编写的XML验证解析器。</li></ul><p>&nbsp;</p><h3>多项混杂</h3><p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NwcGZvcm1hdC9jcHBmb3JtYXQ=" title="https://github.com/cppformat/cppformat">C++ Format<i class="fa fa-external-link"></i></span> ：C++的小型，安全和快速格式化库</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jYXNhY29yZS8=" title="https://code.google.com/p/casacore/">casacore<i class="fa fa-external-link"></i></span> ：从aips++ 派生的一系列C++核心库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xvdWlzZHgvY3h4LXByZXR0eXByaW50" title="https://github.com/louisdx/cxx-prettyprint">cxx-prettyprint<i class="fa fa-external-link"></i></span>：用于C++容器的打印库</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5keW5hZm9ybXMuY29tLw==" title="http://www.dynaforms.com/">DynaPDF<i class="fa fa-external-link"></i></span> ：易于使用的PDF生成库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlYWZzci9nY2MtcG9pc29u" title="https://github.com/leafsr/gcc-poison">gcc-poison<i class="fa fa-external-link"></i></span> ：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。</li><li><span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZW1vY2sv" title="http://code.google.com/p/googlemock/">googlemock<i class="fa fa-external-link"></i></span>：编写和使用C++模拟类的库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9odHRwLXBhcnNlcg==" title="https://github.com/joyent/http-parser">HTTP Parser<i class="fa fa-external-link"></i></span> ：C的http请求/响应解析器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FucmllZmYvbGliY3B1aWQ=" title="https://github.com/anrieff/libcpuid">libcpuid<i class="fa fa-external-link"></i></span> ：用于x86 CPU检测盒特征提取的小型C库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F2YXRpL2xpYmV2aWw=" title="https://github.com/avati/libevil">libevil<i class="fa fa-external-link"></i></span> ：许可证管理器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWJ1c2Iub3JnLw==" title="http://www.libusb.org/">libusb<i class="fa fa-external-link"></i></span>：允许移动访问USB设备的通用USB库</li><li><span class="exturl" data-url="aHR0cDovL3BjcmUub3JnLw==" title="http://pcre.org/">PCRE<i class="fa fa-external-link"></i></span>：正则表达式C库，灵感来自于Perl中正则表达式的功能。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5kZWx0YXZzb2Z0LmNvbS8=" title="http://www.deltavsoft.com/">Remote Call Framework<i class="fa fa-external-link"></i></span> ：C++的进程间通信框架。</li><li><span class="exturl" data-url="aHR0cDovL3NjaW50aWxsYS5vcmcv" title="http://scintilla.org/">Scintilla<i class="fa fa-external-link"></i></span> ：开源的代码编辑控件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dqd3dvb2Qvc2VyaWFs" title="https://github.com/wjwwood/serial">Serial Communication Library<i class="fa fa-external-link"></i></span> ：C++语言编写的跨平台，串口库。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FudGlyZXovc2Rz" title="https://github.com/antirez/sds">SDS<i class="fa fa-external-link"></i></span>：C的简单动态字符串库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvc2xkcg==" title="https://github.com/cesanta/sldr">SLDR<i class="fa fa-external-link"></i></span> ：超轻的DNS解析器</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nlc2FudGEvc2xyZQ==" title="https://github.com/cesanta/slre">SLRE<i class="fa fa-external-link"></i></span>： 超轻的正则表达式库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J0di9TdGFnZQ==" title="https://github.com/rtv/Stage">Stage<i class="fa fa-external-link"></i></span> ：移动机器人模拟器</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92YXJ0eXBlcy8=" title="https://code.google.com/p/vartypes/">VarTypes<i class="fa fa-external-link"></i></span>：C++/Qt4功能丰富，面向对象的管理变量的框架。</li><li><span class="exturl" data-url="aHR0cDovL3piYXIuc291cmNlZm9yZ2UubmV0Lw==" title="http://zbar.sourceforge.net/">ZBar<i class="fa fa-external-link"></i></span>：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZlcmJhbEV4cHJlc3Npb25zL0NwcFZlcmJhbEV4cHJlc3Npb25z" title="https://github.com/VerbalExpressions/CppVerbalExpressions">CppVerbalExpressions<i class="fa fa-external-link"></i></span> ：易于使用的C++正则表达式</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZlcmJhbEV4cHJlc3Npb25zL1F0VmVyYmFsRXhwcmVzc2lvbnM=" title="https://github.com/VerbalExpressions/QtVerbalExpressions">QtVerbalExpressions<i class="fa fa-external-link"></i></span>：基于C++ VerbalExpressions 库的Qt库</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvcGVybmljYU1hcmtldGluZ1NvZnR3YXJlL1BIUC1DUFA=" title="https://github.com/CopernicaMarketingSoftware/PHP-CPP">PHP-CPP<i class="fa fa-external-link"></i></span>：使用C++来构建PHP扩展的库</li><li><span class="exturl" data-url="aHR0cDovL2JzdHJpbmcuc291cmNlZm9yZ2UubmV0Lw==" title="http://bstring.sourceforge.net/">Better String<i class="fa fa-external-link"></i></span> ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。</li></ul><p>&nbsp;</p><h3>软件</h3><p>用于创建开发环境的软件</p><h3>编译器</h3><p>C/C++编译器列表</p><ul><li><span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnLw==" title="http://clang.llvm.org/">Clang<i class="fa fa-external-link"></i></span> :由苹果公司开发的</li><li><span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy8=" title="https://gcc.gnu.org/">GCC<i class="fa fa-external-link"></i></span>：GNU编译器集合</li><li><span class="exturl" data-url="aHR0cHM6Ly9zb2Z0d2FyZS5pbnRlbC5jb20vZW4tdXMvYy1jb21waWxlcnM=" title="https://software.intel.com/en-us/c-compilers">Intel C++ Compiler<i class="fa fa-external-link"></i></span> ：由英特尔公司开发</li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnLw==" title="http://llvm.org/">LLVM<i class="fa fa-external-link"></i></span> ：模块化和可重用编译器和工具链技术的集合</li><li><span class="exturl" data-url="aHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy92c3R1ZGlvL2hoMzg2MzAyLmFzcHg=" title="http://msdn.microsoft.com/en-us/vstudio/hh386302.aspx">Microsoft Visual C++<i class="fa fa-external-link"></i></span> ：MSVC，由微软公司开发</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVud2F0Y29tLm9yZy9pbmRleC5waHAvTWFpbl9QYWdl" title="http://www.openwatcom.org/index.php/Main_Page">Open WatCom<i class="fa fa-external-link"></i></span> ：Watcom，C，C++和Fortran交叉编译器和工具</li><li><span class="exturl" data-url="aHR0cDovL2JlbGxhcmQub3JnL3RjYy8=" title="http://bellard.org/tcc/">TCC<i class="fa fa-external-link"></i></span> ：轻量级的C语言编译器</li></ul><p>&nbsp;</p><h3>在线编译器</h3><p>在线C/C++编译器列表</p><ul><li><span class="exturl" data-url="aHR0cDovL2NvZGVwYWQub3JnLw==" title="http://codepad.org/">codepad<i class="fa fa-external-link"></i></span> ：在线编译器/解释器，一个简单的协作工具</li><li><span class="exturl" data-url="aHR0cDovL2NvZGV0d2lzdC5jb20v" title="http://codetwist.com/">CodeTwist<i class="fa fa-external-link"></i></span>：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果</li><li><span class="exturl" data-url="aHR0cDovL2NvbGlydS5zdGFja2VkLWNyb29rZWQuY29tLw==" title="http://coliru.stacked-crooked.com/">coliru<i class="fa fa-external-link"></i></span> ：在线编译器/shell， 支持各种C++编译器</li><li><span class="exturl" data-url="aHR0cDovL2djYy5nb2Rib2x0Lm9yZy8=" title="http://gcc.godbolt.org/">Compiler Explorer<i class="fa fa-external-link"></i></span>：交互式编译器，可以进行汇编输出</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb21waWxlb25saW5lLmNvbS9jb21waWxlX2NwcDExX29ubGluZS5waHA=" title="http://www.compileonline.com/compile_cpp11_online.php">CompileOnline<i class="fa fa-external-link"></i></span>：Linux上在线编译和执行C++程序</li><li><span class="exturl" data-url="aHR0cDovL2lkZW9uZS5jb20v" title="http://ideone.com/">Ideone<i class="fa fa-external-link"></i></span> ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。</li></ul><p>&nbsp;</p><h3>调试器</h3><p>C/C++调试器列表</p><ul><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21wYXJpc29uX29mX2RlYnVnZ2Vycw==" title="http://en.wikipedia.org/wiki/Comparison_of_debuggers">Comparison of debuggers<i class="fa fa-external-link"></i></span> ：来自维基百科的调试器列表</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9nZGI=" title="https://www.gnu.org/software/gdb">GDB<i class="fa fa-external-link"></i></span> ：GNU调试器</li><li><span class="exturl" data-url="aHR0cDovL3ZhbGdyaW5kLm9yZy8=" title="http://valgrind.org/">Valgrind<i class="fa fa-external-link"></i></span>：内存调试，内存泄露检测，性能分析工具。</li></ul><p>&nbsp;</p><h3>集成开发环境（IDE）</h3><p>C/C++集成开发环境列表</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5qZXRicmFpbnMuY29tL29iamMv" title="http://www.jetbrains.com/objc/">AppCode<i class="fa fa-external-link"></i></span> ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5qZXRicmFpbnMuY29tL2NsaW9uLw==" title="http://www.jetbrains.com/clion/">CLion<i class="fa fa-external-link"></i></span>：来自JetBrains的跨平台的C/C++的集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2RlYmxvY2tzLm9yZy8=" title="http://www.codeblocks.org/">Code::Blocks<i class="fa fa-external-link"></i></span> ：免费C，C++和Fortran的集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL2NvZGVsaXRlLm9yZy8=" title="http://codelite.org/">CodeLite<i class="fa fa-external-link"></i></span> ：另一个跨平台的免费的C/C++集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy9vcndlbGxkZXZjcHAv" title="http://sourceforge.net/projects/orwelldevcpp/">Dev-C++<i class="fa fa-external-link"></i></span>：可移植的C/C++/C++11集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lY2xpcHNlLm9yZy9jZHQv" title="http://www.eclipse.org/cdt/">Eclipse CDT<i class="fa fa-external-link"></i></span>：基于Eclipse平台的功能齐全的C和C++集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nZWFueS5vcmcv" title="http://www.geany.org/">Geany<i class="fa fa-external-link"></i></span> ：轻量级的快速，跨平台的集成开发环境。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy0wMy5pYm0uY29tL3NvZnR3YXJlL3Byb2R1Y3RzL2VuL3Zpc2dlbg==" title="http://www-03.ibm.com/software/products/en/visgen">IBM VisualAge<i class="fa fa-external-link"></i></span> ：来自IBM的家庭计算机集成开发环境。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NhcmNhc20vaXJvbnktbW9kZQ==" title="https://github.com/Sarcasm/irony-mode">Irony-mode<i class="fa fa-external-link"></i></span>：由libclang驱动的用于Emacs的C/C++微模式</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2RldmVsb3Aub3JnLw==" title="https://www.kdevelop.org/">KDevelop<i class="fa fa-external-link"></i></span>：免费开源集成开发环境</li><li><span class="exturl" data-url="aHR0cDovL3d3dy52aXN1YWxzdHVkaW8uY29tLw==" title="http://www.visualstudio.com/">Microsoft Visual Studio<i class="fa fa-external-link"></i></span> ：来自微软的集成开发环境</li><li><span class="exturl" data-url="aHR0cHM6Ly9uZXRiZWFucy5vcmcv" title="https://netbeans.org/">NetBeans<i class="fa fa-external-link"></i></span> ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。</li><li><span class="exturl" data-url="aHR0cDovL3F0LXByb2plY3Qub3JnLw==" title="http://qt-project.org/">Qt Creator<i class="fa fa-external-link"></i></span>：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FuZGVyc2Jha2tlbi9ydGFncw==" title="https://github.com/Andersbakken/rtags">rtags<i class="fa fa-external-link"></i></span>：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成</li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3hjb2RlLw==" title="https://developer.apple.com/xcode/">Xcode<i class="fa fa-external-link"></i></span> ：由苹果公司开发</li><li><span class="exturl" data-url="aHR0cHM6Ly92YWxsb3JpYy5naXRodWIuaW8vWW91Q29tcGxldGVNZS8=" title="https://valloric.github.io/YouCompleteMe/">YouCompleteMe<i class="fa fa-external-link"></i></span>：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</li></ul><p>&nbsp;</p><h3>构建系统</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JpenNvdHRvL0JlYXI=" title="https://github.com/rizsotto/Bear">Bear<i class="fa fa-external-link"></i></span> ：用于为clang工具生成编译数据库的工具</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlpY29kZS5jb20v" title="https://www.biicode.com/">Biicode<i class="fa fa-external-link"></i></span>：基于文件的简单依赖管理器。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbWFrZS5vcmcv" title="http://www.cmake.org/">CMake<i class="fa fa-external-link"></i></span> ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lhdW5zL2NwbQ==" title="https://github.com/iauns/cpm">CPM<i class="fa fa-external-link"></i></span>：基于CMake和Git的C++包管理器</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5mYXN0YnVpbGQub3JnL2RvY3MvaG9tZS5odG1s" title="http://www.fastbuild.org/docs/home.html">FASTBuild<i class="fa fa-external-link"></i></span>：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</li><li><span class="exturl" data-url="aHR0cDovL21hcnRpbmUuZ2l0aHViLmlvL25pbmphLw==" title="http://martine.github.io/ninja/">Ninja<i class="fa fa-external-link"></i></span> ：专注于速度的小型构建系统</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zY29ucy5vcmcv" title="http://www.scons.org/">Scons<i class="fa fa-external-link"></i></span> ：使用Python scipt 配置的软件构建工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RlcGxpbmVub2lzZS90dW5kcmE=" title="https://github.com/deplinenoise/tundra">tundra<i class="fa fa-external-link"></i></span> ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</li><li><span class="exturl" data-url="aHR0cDovL2dpdHR1cC5vcmcvdHVwLw==" title="http://gittup.org/tup/">tup<i class="fa fa-external-link"></i></span>：基于文件的构建系统，用于后台监控变化的文件。</li></ul><p>&nbsp;</p><h3>静态代码分析</h3><p>提高质量，减少瑕疵的代码分析工具列表</p><ul><li><span class="exturl" data-url="aHR0cDovL2NwcGNoZWNrLnNvdXJjZWZvcmdlLm5ldC8=" title="http://cppcheck.sourceforge.net/">Cppcheck<i class="fa fa-external-link"></i></span> ：静态C/C++代码分析工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9pbmNsdWRlLXdoYXQteW91LXVzZS8=" title="https://code.google.com/p/include-what-you-use/">include-what-you-use<i class="fa fa-external-link"></i></span> ：使用clang进行代码分析的工具，可以#include在C和C++文件中。</li><li><span class="exturl" data-url="aHR0cDovL29jbGludC5vcmcv" title="http://oclint.org/">OCLint<i class="fa fa-external-link"></i></span> ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</li><li><span class="exturl" data-url="aHR0cDovL2NsYW5nLWFuYWx5emVyLmxsdm0ub3JnL2luZGV4Lmh0bWw=" title="http://clang-analyzer.llvm.org/index.html">Clang Static Analyzer<i class="fa fa-external-link"></i></span>：查找C，C++和Objective-C程序bug的源代码分析工具</li><li><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX3Rvb2xzX2Zvcl9zdGF0aWNfY29kZV9hbmFseXNpcyNDLjJGQy4yQi4yQg==" title="http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2FC.2B.2B">List of tools for static code analysis<i class="fa fa-external-link"></i></span> ：来自维基百科的静态代码分析工具列表</li></ul><p>感谢平凡之路和fffaraz 的整理，转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>计算机相关技术资料整理</title>
    <link href="http://miaopei.github.io/2018/05/13/practical-programming-books/README/"/>
    <id>http://miaopei.github.io/2018/05/13/practical-programming-books/README/</id>
    <published>2018-05-13T02:14:50.000Z</published>
    <updated>2019-06-24T03:54:17.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VaTGlwcGkvcHJhY3RpY2FsLXByb2dyYW1taW5nLWJvb2tz" title="https://github.com/EZLippi/practical-programming-books">文章来源<i class="fa fa-external-link"></i></span></p></blockquote><p>这里收录比较实用的计算机相关技术书籍，可以在短期之内入门的简单实用教程、一些技术网站以及一些写的比较好的博文，欢迎Fork，你也可以通过Pull Request参与编辑。</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5lemxpcHBpLmNvbS9ibG9nLzIwMTQvMDcvcXVhbGlmaWVkLXByb2dyYW1tZXItc2hvdWxkLXJlYWQtd2hhdC1ib29rcy5odG1s" title="http://www.ezlippi.com/blog/2014/07/qualified-programmer-should-read-what-books.html">程序员必读书籍<i class="fa fa-external-link"></i></span></li></ul><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="#语言相关类">语言相关类</a></p><ul><li><a href="#android">Android</a></li><li><a href="#awk">AWK</a></li><li><a href="#SED">SED</a></li><li><a href="#cc">C/C++</a></li><li><a href="#css">CSS/HTML</a></li><li><a href="#dart">Dart</a></li><li><a href="#erlang">Erlang</a></li><li><a href="#fortran">Fortran</a></li><li><a href="#go">Go</a></li><li><a href="#groovy">Groovy</a></li><li><a href="#haskell">Haskell</a></li><li><a href="#ios">iOS</a></li><li><a href="#java">Java</a></li><li><a href="#javascript">JavaScript</a></li><li><a href="#latex">LaTeX</a></li><li><a href="#lisp">LISP</a></li><li><a href="#lua">Lua</a></li><li><a href="#perl">Perl</a></li><li><a href="#php">PHP</a></li><li><a href="#prolog">Prolog</a></li><li><a href="#python">Python</a></li><li><a href="#r">R</a></li><li><a href="#ruby">Ruby</a></li><li><a href="#scala">Scala</a></li><li><a href="#scheme">Scheme</a></li><li><a href="#shell">Shell</a></li><li><a href="#swift">Swift</a></li><li><a href="#webassembly">WebAssembly</a></li></ul></li><li><p><a href="#语言无关类">语言无关类</a></p><ul><li><a href="#操作系统">操作系统</a></li><li><a href="#版本控制">版本控制</a></li><li><a href="#分布式系统">分布式系统</a></li><li><a href="#编辑器">编辑器</a></li><li><a href="#nosql">NoSQL</a></li><li><a href="#mysql">MySQL</a></li><li><a href="#postgresql">PostgreSQL</a></li><li><a href="#项目相关">项目相关</a></li><li><a href="#设计模式">设计模式</a></li><li><a href="#web">Web</a></li><li><a href="#大数据">大数据</a></li><li><a href="#编程艺术">编程艺术</a></li><li><a href="#函数式编程">函数式编程</a></li><li><a href="#运维监控">运维监控</a></li><li><a href="#web服务器">WEB服务器</a></li></ul></li></ul><h2 id="语言无关类"><a href="#语言无关类" class="headerlink" title="语言无关类"></a>语言无关类</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><span class="exturl" data-url="aHR0cDovL2kubGludXh0b3kub3JnL2RvY3MvZ3VpZGUvaW5kZXguaHRtbA==" title="http://i.linuxtoy.org/docs/guide/index.html">开源世界旅行手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3ZiaXJkLmRpYy5rc3UuZWR1LnR3Lw==" title="http://vbird.dic.ksu.edu.tw/">鸟哥的Linux私房菜<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9hcHBzL3RyYWMvZWxwaS93aWtpL0FMUA==" title="http://sourceforge.net/apps/trac/elpi/wiki/ALP">Linux 系统高级编程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpZHlqaWFuZzgvemVwaHlyLWRvYw==" title="https://github.com/tidyjiang8/zephyr-doc">Zephyr OS 中文文档<i class="fa fa-external-link"></i></span>(v1.6.0)</li><li><span class="exturl" data-url="aHR0cDovL2JpbGxpZTY2LmdpdGh1Yi5pby9UTENML2luZGV4Lmh0bWw=" title="http://billie66.github.io/TLCL/index.html">The Linux Command Line<i class="fa fa-external-link"></i></span> (中英文版)</li><li><span class="exturl" data-url="aHR0cDovL29zcy5vcmcuY24va2VybmVsLWJvb2svbGRkMy9pbmRleC5odG1s" title="http://oss.org.cn/kernel-book/ldd3/index.html">Linux 设备驱动<i class="fa fa-external-link"></i></span> (第三版)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rZXJuZWx0cmF2ZWwubmV0L2tlcm5lbC1ib29rLyVFNiVCNyVCMSVFNSU4NSVBNSVFNSU4OCU4NiVFNiU5RSU5MExpbnV4JUU1JTg2JTg1JUU2JUEwJUI4JUU2JUJBJTkwJUU3JUEwJTgxLmh0bWw=" title="http://www.kerneltravel.net/kernel-book/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81.html">深入分析Linux内核源码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2NiLnZ1L3VuaXh0b29sYm94X3poX0NOLnhodG1s" title="http://cb.vu/unixtoolbox_zh_CN.xhtml">UNIX TOOLBOX<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpZHV1L2NoaW5lc2VfZG9ja2Vy" title="https://github.com/widuu/chinese_docker">Docker中文指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3llYXN5L2RvY2tlcl9wcmFjdGljZQ==" title="https://github.com/yeasy/docker_practice">Docker —— 从入门到实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3l1ZWR1LmJhaWR1LmNvbS9lYm9vay9kODE3OTY3NDE2ZmM3MDBhYmI2OGZjYTE=" title="http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1">Docker入门实战<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dzYXJnZW50L2RvY2tlci1jaGVhdC1zaGVldC90cmVlL21hc3Rlci96aC1jbiNkb2NrZXItY2hlYXQtc2hlZXQ=" title="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn#docker-cheat-sheet">Docker Cheat Sheet<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZyZWVyYWRpdXMuYWthZ2kyMDEub3Jn" title="http://freeradius.akagi201.org">FreeRADIUS新手入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hYWFhYWFzaHUuZ2l0Ym9va3MuaW8vbWFjLWRldi1zZXR1cC9jb250ZW50Lw==" title="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/">Mac 开发配置手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJzZC5vcmcvZG9jL3poX0NOL2Jvb2tzL2hhbmRib29rL2luZGV4Lmh0bWw=" title="https://www.freebsd.org/doc/zh_CN/books/handbook/index.html">FreeBSD 使用手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2JpbGxpZTY2LmdpdGh1Yi5pby9UTENML2Jvb2sv" title="http://billie66.github.io/TLCL/book/">Linux 命令行(中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dvcmtzLmppbmJ1Z3VvLmNvbS9sZnMvbGZzNjIvaW5kZXguaHRtbA==" title="http://works.jinbuguo.com/lfs/lfs62/index.html">Linux 构建指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lMTE1L2xpbnV4dG9vbHNfcnN0" title="https://github.com/me115/linuxtools_rst">Linux工具快速教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay90aW55bGFiL2xpbnV4LWRvYy9kZXRhaWxz" title="https://www.gitbook.com/book/tinylab/linux-doc/details">Linux Documentation (中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay90aW55bGFiL2VsaW51eC9kZXRhaWxz" title="https://www.gitbook.com/book/tinylab/elinux/details">嵌入式 Linux 知识库 (eLinux.org 中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvYmVnaXQzaHViL3VuZGVyc3RhbmRfbGludXhfcHJvY2Vzcw==" title="https://github.com/tobegit3hub/understand_linux_process">理解Linux进程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J5YW56ei9MRlMtc3lzdGVtZC16aF9DTg==" title="https://github.com/ryanzz/LFS-systemd-zh_CN">Linux From Scratch systemd 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjLzMwLW1pbnV0ZXMtdG8tbGVhcm4tcmVnZXgubWQ=" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/30-minutes-to-learn-regex.md">55分钟学会正则表达式<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3VzZS1saW51eC5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/use-linux.md">每个Linux用户都应该知道的命令行技巧<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL21lbW9yeS5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/memory.md">每个程序员都应该了解的内存知识<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2NwdS1jYWNoZS5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/cpu-cache.md">每个程序员都应该了解的CPU缓存知识<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3ZpcnR1YWwtbWVtb3J5Lm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/virtual-memory.md">每个程序员都应该了解的虚拟内存知识<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cDovL2JpbGxpZTY2LmdpdGJvb2tzLmlvL3RsY2wtY24vY29udGVudC8=" title="http://billie66.gitbooks.io/tlcl-cn/content/">shell脚本教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb21tYW5kbGluZWZ1LmNvbS9jb21tYW5kcy9tYXRjaGluZy9scy9iSE09L3NvcnQtYnktdm90ZXM=" title="http://www.commandlinefu.com/commands/matching/ls/bHM=/sort-by-votes">查找命令行的网站<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWJ1bGFyLmNvbS8=" title="http://www.rubular.com/">正则表达式在线测试<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lemxpcHBpLmNvbS9ibG9nLzIwMTcvMDIvc3MtcHJveHktZ3VpZGUuaHRtbA==" title="http://www.ezlippi.com/blog/2017/02/ss-proxy-guide.html">科学上网<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><ul><li><span class="exturl" data-url="aHR0cDovL2RjYW95dWFuLmdpdGh1Yi5pby9wYXBlcnMvcGRmcy9TY2FsYWJpbGl0eS5wZGY=" title="http://dcaoyuan.github.io/papers/pdfs/Scalability.pdf">走向分布式<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1c3RpbnlodWFuZy9GdW5jdGlvbmFsLVByb2dyYW1taW5nLUZvci1UaGUtUmVzdC1vZi1Vcy1Dbg==" title="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn">傻瓜函数编程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><ul><li><span class="exturl" data-url="aHR0cDovL3RlbmdpbmUudGFvYmFvLm9yZy9ib29rL2luZGV4Lmh0bWw=" title="http://tengine.taobao.org/book/index.html">Nginx开发从入门到精通<i class="fa fa-external-link"></i></span> (淘宝团队出品)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50dGxzYS5jb20vbmdpbngvbmdpbngtc3R1LXBkZi8=" title="http://www.ttlsa.com/nginx/nginx-stu-pdf/">Nginx教程从入门到精通<i class="fa fa-external-link"></i></span>(PDF版本，运维生存时间出品)</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9tb29uYmluZ2Jpbmcvb3BlbnJlc3R5LWJlc3QtcHJhY3RpY2VzL2RldGFpbHM=" title="https://www.gitbook.com/book/moonbingbing/openresty-best-practices/details">OpenResty最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dvcmtzLmppbmJ1Z3VvLmNvbS9hcGFjaGUvbWVudTIyL2luZGV4Lmh0bWw=" title="http://works.jinbuguo.com/apache/menu22/index.html">Apache 中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xvb2x5LmdpdGJvb2tzLmlvL2VsYXN0aWNzZWFyY2gtdGhlLWRlZmluaXRpdmUtZ3VpZGUtY24v" title="http://looly.gitbooks.io/elasticsearch-the-definitive-guide-cn/">Elasticsearch权威指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2hvdy1zdGFja292ZXJmbG93LXdvcmtzLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/how-stackoverflow-works.md">25 台服务器是怎样支撑 StackOverflow 的？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3BpY3R1cmUtc2VydmVyLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/picture-server.md">图片服务架构演进（孔凡勇）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2xvZ2dpbmcubWQ=" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/logging.md">最佳日志实践（王健）<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDEzNzM5NTE2MzA1OTI5NjA2ZGQxODM2MTI0ODU3OGM2N2I4MDY3YzhjMDE3YjAwMA==" title="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cDovL3JvZ2VyZHVkbGVyLmdpdGh1Yi5pby9naXQtZ3VpZGUvaW5kZXguemguaHRtbA==" title="http://rogerdudler.github.io/git-guide/index.zh.html">git简易指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2JhY2tsb2d0b29sLmNvbS9naXQtZ3VpZGUvY24v" title="http://backlogtool.com/git-guide/cn/">猴子都能懂的GIT入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpdHJlZi5qdXN0amF2YWMuY29t" title="http://gitref.justjavac.com">Git 参考手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpdC1zY20uY29tL2Jvb2svemgvdjI=" title="http://git-scm.com/book/zh/v2">Pro Git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay8wNTMyL3Byb2dpdC9kZXRhaWxz" title="https://www.gitbook.com/book/0532/progit/details">Pro Git 中文版<i class="fa fa-external-link"></i></span> (整理在gitbook上)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy1jcy1zdHVkZW50cy5zdGFuZm9yZC5lZHUvfmJseW5uL2dpdG1hZ2ljL2ludGwvemhfY24v" title="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Git Magic<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53b3JsZGhlbGxvLm5ldC9nb3RnaXRodWIvaW5kZXguaHRtbA==" title="http://www.worldhello.net/gotgithub/index.html">GotGitHub<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53b3JsZGhlbGxvLm5ldC9nb3RnaXQv" title="http://www.worldhello.net/gotgit/">Git权威指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dpdGJvb2subGl1aHVpOTk4LmNvbS9pbmRleC5odG1s" title="http://gitbook.liuhui998.com/index.html">Git Community Book 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWVyY3VyaWFsLXNjbS5vcmcvd2lraS9DaGluZXNlVHV0b3JpYWw=" title="https://www.mercurial-scm.org/wiki/ChineseTutorial">Mercurial 使用教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2J1Y3VuemFpLm5ldC9oZ2luaXQv" title="http://bucunzai.net/hginit/">HgInit (中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lnaXQubGludXh0b3kub3JnLw==" title="http://igit.linuxtoy.org/">沉浸式学 Git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZseWhpZ2hlcjEzOS9HaXQtQ2hlYXQtU2hlZXQ=" title="https://github.com/flyhigher139/Git-Cheat-Sheet">Git-Cheat-Sheet<i class="fa fa-external-link"></i></span> （感谢 @flyhigher139 翻译了中文版）</li><li><span class="exturl" data-url="aHR0cDovL3Nub3dkcmVhbTg2LmdpdGJvb2tzLmlvL2dpdGh1Yi1jaGVhdC1zaGVldC9jb250ZW50L3poL2luZGV4Lmh0bWw=" title="http://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/index.html">GitHub秘籍<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9naXRodWItaGVscA==" title="https://github.com/waylau/github-help">Github帮助文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RhbmllbGt1bW1lci5naXRodWIuaW8vZ2l0LWZsb3ctY2hlYXRzaGVldC9pbmRleC56aF9DTi5odG1s" title="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git-flow 备忘清单<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3N2bmJvb2sucmVkLWJlYW4uY29tL25pZ2h0bHkvemgvaW5kZXguaHRtbA==" title="http://svnbook.red-bean.com/nightly/zh/index.html">svn 手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Bob2RhbC9naXRodWItcm9hbQ==" title="https://github.com/phodal/github-roam">GitHub漫游指南<i class="fa fa-external-link"></i></span></li></ul><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoeHVhbi92aW1wbHVz" title="https://github.com/chxuan/vimplus">vimplus<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2V4dmltLmdpdGh1Yi5pby9kb2NzLXpoL2ludHJvLw==" title="http://exvim.github.io/docs-zh/intro/">exvim–vim 改良成IDE项目<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xlYXJudmltc2NyaXB0dGhlaGFyZHdheS5vbmVmbG93ZXJvbmV3b3JsZC5jb20v" title="http://learnvimscriptthehardway.onefloweroneworld.com/">笨方法学Vimscript 中译本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZpbWNuL3ZpbWNkb2M=" title="https://github.com/vimcn/vimcdoc">Vim中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhbmd5YW5nd2l0aGdudS91c2VfdmltX2FzX2lkZQ==" title="https://github.com/yangyangwithgnu/use_vim_as_ide">所需即所获：像 IDE 一样使用 vim<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja2VkaXQuaW8vIw==" title="https://stackedit.io/#">在线MarkDown编辑<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3ZpbS5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/vim.md">简明VIM练级攻略<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5waHAxMDAuY29tL21hbnVhbC9NeVNRTC8=" title="http://www.php100.com/manual/MySQL/">MySQL中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3NxbC5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/sql.md">十步完全理解SQL<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9sZW9vMnNrL2FyY2hpdmUvMjAxMS8wNy8xMC9teXNxbC1pbmRleC5odG1s" title="http://www.cnblogs.com/leoo2sk/archive/2011/07/10/mysql-index.html">MySQL索引背后的数据结构及算法原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9tci13aWQvYXJjaGl2ZS8yMDEzLzA1LzA5LzMwNjgyMjkuaHRtbA==" title="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html">21分钟MySQL入门教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><ul><li><span class="exturl" data-url="aHR0cDovL29sZC5zZWJ1Zy5uZXQvcGFwZXIvZGF0YWJhc2VzL25vc3FsL05vc3FsLmh0bWw=" title="http://old.sebug.net/paper/databases/nosql/Nosql.html">NoSQL数据库笔谈<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3JlZGlzYm9vay5jb20v" title="http://redisbook.com/">Redis 设计与实现<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3JlZGlzZG9jLmNvbS8=" title="http://redisdoc.com/">Redis 命令参考<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1YW5nejE5OTAvcmVkaXMtMy4wLWFubm90YXRlZA==" title="https://github.com/huangz1990/redis-3.0-annotated">带有详细注释的 Redis 3.0 代码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1YW5nejE5OTAvYW5ub3RhdGVkX3JlZGlzX3NvdXJjZQ==" title="https://github.com/huangz1990/annotated_redis_source">带有详细注释的 Redis 2.6 代码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1c3RpbnlodWFuZy90aGUtbGl0dGxlLW1vbmdvZGItYm9vay1jbi9ibG9iL21hc3Rlci9tb25nb2RiLm1k" title="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md">The Little MongoDB Book<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phc29uTGFpMjU2L3RoZS1saXR0bGUtcmVkaXMtYm9vay9ibG9iL21hc3Rlci9jbi9yZWRpcy5tZA==" title="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md">The Little Redis Book<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3MubmVvNGoub3JnLmNuLw==" title="http://docs.neo4j.org.cn/">Neo4j 简体中文手册 v1.8<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL25lbzRqLnR3Lw==" title="http://neo4j.tw/">Neo4j .rb 中文資源<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Rpc3F1ZWJvb2suY29t" title="http://disquebook.com">Disque 使用教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0plcnJ5TGVhZC9TcGFya0ludGVybmFscy90cmVlL21hc3Rlci9tYXJrZG93bg==" title="https://github.com/JerryLead/SparkInternals/tree/master/markdown">Apache Spark 设计与实现<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL25vc3FsLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/nosql.md">8种Nosql数据库系统对比<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3><ul><li><span class="exturl" data-url="aHR0cDovL3dvcmtzLmppbmJ1Z3VvLmNvbS9wb3N0Z3Jlc3FsL21lbnU4MjMvaW5kZXguaHRtbA==" title="http://works.jinbuguo.com/postgresql/menu823/index.html">PostgreSQL 8.2.3 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5wb3N0Z3Jlcy5jbi9kb2NzLzkuMy9pbmRleC5odG1s" title="http://www.postgres.cn/docs/9.3/index.html">PostgreSQL 9.3.1 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5wb3N0Z3Jlcy5jbi9kb2NzLzkuNS9pbmRleC5odG1s" title="http://www.postgres.cn/docs/9.5/index.html">PostgreSQL 9.5.3 中文文档<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="运维监控"><a href="#运维监控" class="headerlink" title="运维监控"></a>运维监控</h3><ul><li><span class="exturl" data-url="aHR0cDovL2tpYmFuYS5sb2dzdGFzaC5lcw==" title="http://kibana.logstash.es">ELKstack 中文指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Vkbi55eXVhcC5jb20vZG9jL21hc3RlcmluZy1lbGFzdGljc2VhcmNoLw==" title="http://udn.yyuap.com/doc/mastering-elasticsearch/">Mastering Elasticsearch(中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9mdXhpYW9wYW5nL2xlYXJuZWxhc3RpY3NlYXJjaC9kZXRhaWxz" title="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details">ElasticSearch 权威指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2VzLnhpYW9sZWlsdS5jb20=" title="http://es.xiaoleilu.com">Elasticsearch 权威指南（中文版）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZW5yeW4vbG9nc3Rhc2gtYmVzdC1wcmFjdGljZS1jbg==" title="https://github.com/chenryn/logstash-best-practice-cn">Logstash 最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jicy5rb25vdGVzLm9yZy93b3JrZG9jL3B1cHBldC0yNy8=" title="http://bbs.konotes.org/workdoc/puppet-27/">Puppet 2.7 Cookbook 中文版<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h3><ul><li><span class="exturl" data-url="aHR0cDovL2xpcHBpb3V5YW5nLmdpdGJvb2tzLmlvL2dyYWRsZS1pbi1hY3Rpb24tY24vY29udGVudC8=" title="http://lippiouyang.gitbooks.io/gradle-in-action-cn/content/">Gradle实战<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2FydGljbGUueWVleWFuLm9yZy92aWV3LzIyNTEvOTQ4ODI=" title="http://article.yeeyan.org/view/2251/94882">持续集成（第二版）<i class="fa fa-external-link"></i></span> (译言网)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2phdmEvai1hcC8=" title="http://www.ibm.com/developerworks/cn/java/j-ap/">让开发自动化系列专栏<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2phdmEvai1jcS8=" title="http://www.ibm.com/developerworks/cn/java/j-cq/">追求代码质量<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zvb2wyZmlzaC9zZWxlbml1bS1kb2M=" title="https://github.com/fool2fish/selenium-doc">selenium 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xvY2FsLmpvZWxvbnNvZnR3YXJlLmNvbS93aWtpL0NoaW5lc2VfKFNpbXBsaWZpZWQp" title="http://local.joelonsoftware.com/wiki/Chinese_(Simplified)">Joel谈软件<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xvY2FsLmpvZWxvbnNvZnR3YXJlLmNvbS93aWtpLyVFOSVBNiU5NiVFOSVBMCU4MQ==" title="http://local.joelonsoftware.com/wiki/%E9%A6%96%E9%A0%81">約耳談軟體(Joel on Software)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9HcmFkbGUtMi1Vc2VyLUd1aWRl" title="https://github.com/waylau/Gradle-2-User-Guide">Gradle 2 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS9zcGVj" title="https://github.com/ecomfe/spec">编码规范<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9ib29rLzExNDM=" title="http://www.ituring.com.cn/book/1143">开源软件架构<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3MuaHVpaG9vLmNvbS9nbnUvbGludXgvZ21ha2UuaHRtbA==" title="http://docs.huihoo.com/gnu/linux/gmake.html">GNU make 指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy55YXl1Lm9yZy9ib29rL2dudV9tYWtlLw==" title="http://www.yayu.org/book/gnu_make/">GNU make 中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovLzEyZmFjdG9yLm5ldC96aF9jbi8=" title="http://12factor.net/zh_cn/">The Twelve-Factor App<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lMTE1L2Rlc2lnbl9wYXR0ZXJucw==" title="https://github.com/me115/design_patterns">图说设计模式<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZWxpb24vYXJ0aWNsZS9kZXRhaWxzLzE3NTE3MjEz" title="http://blog.csdn.net/lovelion/article/details/17517213">史上最全设计模式导学目录<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsZnJlZFRoZUJlc3QvRGVzaWduLVBhdHRlcm4=" title="https://github.com/AlfredTheBest/Design-Pattern">design pattern 包教不包会<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9xdWFua2UuZ2l0Ym9va3MuaW8vZGVzaWduLXBhdHRlcm4tamF2YS9jb250ZW50Lw==" title="https://quanke.gitbooks.io/design-pattern-java/content/">设计模式 Java 版<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><ul><li><span class="exturl" data-url="aHR0cDovL2Nvb2xzaGVsbC5pbmZvL2Jsb2cvMjAxNS8wNC93ZWItdHJhbnNtaXNzaW9uLWJhc2lzLmh0bWw=" title="http://coolshell.info/blog/2015/04/web-transmission-basis.html">网络传输基础<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy4yMHRoaW5nc2lsZWFybmVkLmNvbS96aC1DTi9ob21l" title="http://www.20thingsilearned.com/zh-CN/home">关于浏览器和网络的 20 项须知<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2tub3dsZWRnZS5lY29tZmUuY29tLw==" title="http://knowledge.ecomfe.com/">前端知识体系<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ppbmxvbmcuZ2l0aHViLmlvLzIwMTMvMDgvMjkvZGV2dG9vbHNlY3JldHMv" title="http://jinlong.github.io/2013/08/29/devtoolsecrets/">浏览器开发工具的秘密<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NOLUNocm9tZS1EZXZUb29scy9DTi1DaHJvbWUtRGV2VG9vbHM=" title="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools">Chrome 开发者工具中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL29wZW4uY2hyb21lLjM2MC5jbi9leHRlbnNpb25fZGV2L292ZXJ2aWV3Lmh0bWw=" title="http://open.chrome.360.cn/extension_dev/overview.html">Chrome扩展开发文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ncnVudGpzLm9yZy8=" title="http://www.gruntjs.org/">Grunt中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3llb21hbmpzLm9yZy8=" title="http://yeomanjs.org/">Yeoman中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbG95VGVhbS9NYXJz" title="https://github.com/AlloyTeam/Mars">移动Web前端知识库<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RlZXJjaGFvLm5ldC90dXRvcmlhbHMvcmVnZXgvcmVnZXguaHRt" title="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvdWJlci9ibG9nL2lzc3Vlcy8y" title="https://github.com/fouber/blog/issues/2">前端开发体系建设日记<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvb3Npbi9tb2JpbGUtd2ViLWZhdm9yaXRlcw==" title="https://github.com/hoosin/mobile-web-favorites">移动前端开发收藏夹<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhcmN5bGl1L2dvb2dsZS1zdHlsZWd1aWRlL2Jsb2IvbWFzdGVyL0pTT05TdHlsZUd1aWRlLm1k" title="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md">JSON风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvbGFzYmxhY2svaHR0cC1hcGktZ3VpZGU=" title="https://github.com/bolasblack/http-api-guide">HTTP 接口设计指北<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhY2tlMi9oYWNrZTIuZ2l0aHViLmlvL2lzc3Vlcy8x" title="https://github.com/hacke2/hacke2.github.io/issues/1">前端资源分享（一）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhY2tlMi9oYWNrZTIuZ2l0aHViLmlvL2lzc3Vlcy8z" title="https://github.com/hacke2/hacke2.github.io/issues/3">前端资源分享（二）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2NvZGVybG1uLmdpdGh1Yi5pby9jb2RlLXN0YW5kYXJkcy8=" title="http://coderlmn.github.io/code-standards/">前端代码规范 及 最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9kd3FzL2Zyb250ZW5kZGV2aGFuZGJvb2svZGV0YWlscw==" title="https://www.gitbook.com/book/dwqs/frontenddevhandbook/details">前端开发者手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9sZW9oeGovZnJvbnQtZW5kLWRhdGFiYXNlL2RldGFpbHM=" title="https://www.gitbook.com/book/leohxj/front-end-database/details">前端工程师手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpemFyZGZvcmNlbC93M3NjaG9vbA==" title="https://github.com/wizardforcel/w3school">w3school教程整理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL21hbi5sdXBhd29ybGQuY29tL2NvbnRlbnQvbmV0d29yay93aXJlc2hhcmsvaW5kZXguaHRtbA==" title="http://man.lupaworld.com/content/network/wireshark/index.html">Wireshark用户手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkuZW1jLmNvbS90aHJlYWQvMTk0OTAx" title="https://community.emc.com/thread/194901">一站式学习Wireshark<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2hhcHB5cGV0ZXIuZ2l0aHViLmlvL3RlYWxlYWYtaHR0cC8=" title="http://happypeter.github.io/tealeaf-http/">HTTP 下午茶<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3l1ZWR1LmJhaWR1LmNvbS9lYm9vay80NzhkMWE2MjM3NmJhZjFmZmM0ZmFkOTk/cG49MQ==" title="http://yuedu.baidu.com/ebook/478d1a62376baf1ffc4fad99?pn=1">HTTP/2.0 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FiYnNoci9yZmM3NTQwLXRyYW5zbGF0aW9uLXpoX2Nu" title="https://github.com/abbshr/rfc7540-translation-zh_cn">RFC 7540 - HTTP/2 中文翻译版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay95ZTExb3cvaHR0cDItZXhwbGFpbmVkL2RldGFpbHM=" title="https://www.gitbook.com/book/ye11ow/http2-explained/details">http2讲解<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9qdW50YW8vMy13ZWItZGVzaWducy1pbi0zLXdlZWtzL2RldGFpbHM=" title="https://www.gitbook.com/book/juntao/3-web-designs-in-3-weeks/details">3 Web Designs in 3 Weeks<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvcm9ja3kvU2l0ZS1SZWxpYWJpbGl0eS1FbmdpbmVlcmluZw==" title="https://github.com/hellorocky/Site-Reliability-Engineering">站点可靠性工程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Zsb3dlcm93bC9CaWctRGF0YS1SZXNvdXJjZXM=" title="https://github.com/Flowerowl/Big-Data-Resources">大数据/数据挖掘/推荐系统/机器学习相关资源<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppemhhbmcvZ3VpZGV0b2RhdGFtaW5pbmc=" title="https://github.com/jizhang/guidetodatamining">面向程序员的数据挖掘指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmNzZG4ubmV0L0NPREVfVHJhbnNsYXRpb24vc3BhcmtfbWF0ZWlfcGhk" title="https://code.csdn.net/CODE_Translation/spark_matei_phd">大型集群上的快速和通用数据处理架构<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbnlpcXVuL0RhdGFNaW5pbmdBbGdvcml0aG0=" title="https://github.com/linyiqun/DataMiningAlgorithm">数据挖掘中经典的算法实现和详细的注释<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9haXlhbmJvLmdpdGJvb2tzLmlvL3NwYXJrLXByb2dyYW1taW5nLWd1aWRlLXpoLWNuL2NvbnRlbnQv" title="https://aiyanbo.gitbooks.io/spark-programming-guide-zh-cn/content/">Spark 编程指南简体中文版<i class="fa fa-external-link"></i></span></li></ul><hr><h2 id="编程艺术"><a href="#编程艺术" class="headerlink" title="编程艺术"></a>编程艺术</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1bHljb2RpbmcvVGhlLUFydC1PZi1Qcm9ncmFtbWluZy1ieS1KdWx5" title="https://github.com/julycoding/The-Art-Of-Programming-by-July">程序员编程艺术<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vc2NoaW5hLm5ldC90cmFuc2xhdGUvd2hhdC1ldmVyeS1wcm9ncmFtbWVyLXNob3VsZC1rbm93LWFib3V0LW1lbW9yeS1wYXJ0MT9wcmludA==" title="http://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1?print">每个程序员都应该了解的内存知识(译)<i class="fa fa-external-link"></i></span>【第一部分】</li><li><span class="exturl" data-url="aHR0cDovL3JlYWQuZG91YmFuLmNvbS9lYm9vay80OTcyODgzLw==" title="http://read.douban.com/ebook/4972883/">取悦的工序：如何理解游戏<i class="fa fa-external-link"></i></span> (豆瓣阅读，免费书籍)</li><li><span class="exturl" data-url="aHR0cDovL3hpYW9iZWljbi5naXRib29rcy5pby9wcm9ncmFtbWluZy1za2lsbHMtc3VtbWFyeS8=" title="http://xiaobeicn.gitbooks.io/programming-skills-summary/">编程技巧总汇<i class="fa fa-external-link"></i></span></li></ul><hr><h2 id="语言相关类"><a href="#语言相关类" class="headerlink" title="语言相关类"></a>语言相关类</h2><h3 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h3><ul><li><span class="exturl" data-url="aHR0cDovL2F3ay5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0Lw==" title="http://awk.readthedocs.org/en/latest/">awk程序设计语言<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2F3ay5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/awk.md">awk教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="SED"><a href="#SED" class="headerlink" title="SED"></a>SED</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL3NlZC5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/sed.md">sed教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lemxpcHBpLmNvbS9ibG9nLzIwMTcvMDIvc2VkLWludHJvZHVjdGlvbi5odG1s" title="http://www.ezlippi.com/blog/2017/02/sed-introduction.html">SED简明教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9hcGFjaGUtc2hpcm8tMS4yLngtcmVmZXJlbmNl" title="https://github.com/waylau/apache-shiro-1.2.x-reference">Apache Shiro 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9KZXJzZXktMi54LVVzZXItR3VpZGU=" title="https://github.com/waylau/Jersey-2.x-User-Guide">Jersey 2.x 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9zcHJpbmctZnJhbWV3b3JrLTQtcmVmZXJlbmNl" title="https://github.com/waylau/spring-framework-4-reference">Spring Framework 4.x参考文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYmFvZ3VhbmcvU3ByaW5nLUJvb3QtUmVmZXJlbmNlLUd1aWRl" title="https://github.com/qibaoguang/Spring-Boot-Reference-Guide">Spring Boot参考指南<i class="fa fa-external-link"></i></span> (翻译中)</li><li><span class="exturl" data-url="aHR0cDovL215YmF0aXMuZ2l0aHViLmlvL215YmF0aXMtMy96aC9pbmRleC5odG1s" title="http://mybatis.github.io/mybatis-3/zh/index.html">MyBatis中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9SZXN0RGVtbw==" title="https://github.com/waylau/RestDemo">用jersey构建REST服务<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9hY3Rpdml0aS01LngtdXNlci1ndWlkZQ==" title="https://github.com/waylau/activiti-5.x-user-guide">Activiti 5.x 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5oYXdzdGVpbi5jb20vcG9zdHMvZ29vZ2xlLWphdmEtc3R5bGUuaHRtbA==" title="http://www.hawstein.com/posts/google-java-style.html">Google Java编程风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9uZXR0eS00LXVzZXItZ3VpZGU=" title="https://github.com/waylau/netty-4-user-guide">Netty 4.x 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9lc3NlbnRpYWwtbmV0dHktaW4tYWN0aW9u" title="https://github.com/waylau/essential-netty-in-action">Netty 实战(精髓)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9yZXN0LWluLWFjdGlvbg==" title="https://github.com/waylau/rest-in-action">REST 实战<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9qYXZhLWNvZGUtY29udmVudGlvbnM=" title="https://github.com/waylau/java-code-conventions">Java 编码规范<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9hcGFjaGUtbWluYS0yLngtdXNlci1ndWlkZQ==" title="https://github.com/waylau/apache-mina-2.x-user-guide">Apache MINA 2 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2p2bS5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/jvm.md">JVM必备指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2phdmEtc3RyaW5nLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/java-string.md">Java入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2phdmFyZXZpc2l0ZWQuYmxvZ3Nwb3QuY29tLw==" title="http://javarevisited.blogspot.com/">javarevisited博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5qb3VybmFsZGV2LmNvbS8=" title="http://www.journaldev.com/">journaldev教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5hbmRyb2lkZGV2dG9vbHMuY24v" title="http://www.androiddevtools.cn/">开发工具下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2d1aWRlcy5jb2RlcGF0aC5jb20vYW5kcm9pZC9Ib21l" title="http://guides.codepath.com/android/Home">CodePath Android教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5hcGtidXMuY29tL2Rlc2lnbi9pbmRleC5odG1s" title="http://www.apkbus.com/design/index.html">Android Design(中文版)<i class="fa fa-external-link"></i></span></li><li>Google Material Design 正體中文版 (<span class="exturl" data-url="aHR0cDovL3djYzcyMy5naXRib29rcy5pby9nb29nbGVfZGVzaWduX3RyYW5zbGF0ZS9jb250ZW50L3N0eWxlLWljb25zLmh0bWw=" title="http://wcc723.gitbooks.io/google_design_translate/content/style-icons.html">译本一<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzFzdGVycy9tYXRlcmlhbF9kZXNpZ25femg=" title="https://github.com/1sters/material_design_zh">译本二<i class="fa fa-external-link"></i></span>)</li><li><span class="exturl" data-url="aHR0cDovL2h1a2FpLm1lL2FuZHJvaWQtdHJhaW5pbmctY291cnNlLWluLWNoaW5lc2UvaW5kZXguaHRtbA==" title="http://hukai.me/android-training-course-in-chinese/index.html">Google Android官方培训课程中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3N0b3JtemhhbmcuZ2l0aHViLmlvL2FuZHJvaWQvMjAxNC8wNy8wNy9sZWFybi1hbmRyb2lkLWZyb20tcm9va2llLw==" title="http://stormzhang.github.io/android/2014/07/07/learn-android-from-rookie/">Android学习之路<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Rvb2xzLmFuZHJvaWQuY29tL3RlY2gtZG9jcy9uZXctYnVpbGQtc3lzdGVt" title="http://tools.android.com/tech-docs/new-build-system">Android构建工具<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jib3lmZWl5dS9hbmRyb2lkLXRlY2gtZnJvbnRpZXI=" title="https://github.com/bboyfeiyu/android-tech-frontier">Android开发技术前线(android-tech-frontier)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2FuZHJvaWQtbWVtb3J5LXByb2YxLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/android-memory-prof1.md">Android内存优化(上)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2FuZHJvaWQtbWVtb3J5LXByb2YyLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/android-memory-prof2.md">Android内存优化(中)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2FuZHJvaWQtbWVtb3J5LXByb2YzLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/android-memory-prof3.md">Android内存优化(全)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2RvdGEuY29tLw==" title="http://www.codota.com/">查找代码的一个网站<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWFyc2VuYWwuY29tL2ZyZWU=" title="https://android-arsenal.com/free">Android开源库汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2RvdGEuY29tLw==" title="http://www.codota.com/">查找示例代码的网站<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3R1dHNwbHVzLmNvbS8=" title="http://tutsplus.com/">Android SDK使用教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z1dHVyaWNlL2FuZHJvaWQtYmVzdC1wcmFjdGljZXM=" title="https://github.com/futurice/android-best-practices">Android最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dvb2dsZS5naXRodWIuaW8vbWF0ZXJpYWwtZGVzaWduLWljb25zLyNpY29ucy1mb3ItYW5kcm9pZA==" title="http://google.github.io/material-design-icons/#icons-for-android">Android Material icons<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><ul><li><span class="exturl" data-url="aHR0cDovL3poLmNwcHJlZmVyZW5jZS5jb20v" title="http://zh.cppreference.com/">C/C++ 中文参考手册<i class="fa fa-external-link"></i></span> (欢迎大家参与在线翻译和校对)</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay90aW55bGFiL2Nib29rL2RldGFpbHM=" title="https://www.gitbook.com/book/tinylab/cbook/details">C 语言编程透视<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvcmhhcHB5L0NwbHVzcGx1cy1Db25jdXJyZW5jeS1Jbi1QcmFjdGljZQ==" title="https://github.com/forhappy/Cplusplus-Concurrency-In-Practice">C++ 并发编程指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2FrYWVkdS5naXRodWIuaW8vYm9vay8=" title="http://akaedu.github.io/book/">Linux C编程一站式学习<i class="fa fa-external-link"></i></span> (宋劲杉, 北京亚嵌教育研究中心)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlZXlpdy9jZ2RiLW1hbnVhbC1pbi1jaGluZXNl" title="https://github.com/leeyiw/cgdb-manual-in-chinese">CGDB中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvZ2NjLzEwMC1nZGItdGlwcy9ibG9iL21hc3Rlci9zcmMvaW5kZXgubWQ=" title="https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md">100个gdb小技巧<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvZ2NjLzEwMC1nY2MtdGlwcy9ibG9iL21hc3Rlci9zcmMvaW5kZXgubWQ=" title="https://github.com/hellogcc/100-gcc-tips/blob/master/src/index.md">100个gcc小技巧<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvZ2NjLzEwMC1nZGItdGlwcw==" title="https://github.com/hellogcc/100-gdb-tips">学习gdb调试技巧<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuanVrZS96Z3VpZGUtY24=" title="https://github.com/anjuke/zguide-cn">ZMQ 指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9ib29rLzEyMDM=" title="http://www.ituring.com.cn/book/1203">How to Think Like a Computer Scientist<i class="fa fa-external-link"></i></span> (中英文版)</li><li><span class="exturl" data-url="aHR0cDovL3NjYy5xaWJlYnQuY2FzLmNuL2RvY3MvbGludXgvYmFzZS8lQjglRkElQ0UlRDIlRDIlQkIlQzYlRjAlRDAlQjRNYWtlZmlsZS0lQjMlQzIlRjAlQTkucGRm" title="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf">跟我一起写Makefile(PDF)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy55YXl1Lm9yZy9ib29rL2dudV9tYWtlLw==" title="http://www.yayu.org/book/gnu_make/">GNU make中文手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3MuaHVpaG9vLmNvbS9nbnUvbGludXgvZ21ha2UuaHRtbA==" title="http://docs.huihoo.com/gnu/linux/gmake.html">GNU make 指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLWdvb2dsZS1zdHlsZWd1aWRlLnJlYWR0aGVkb2NzLm9yZy9lbi9sYXRlc3QvZ29vZ2xlLWNwcC1zdHlsZWd1aWRlL2NvbnRlbnRzLw==" title="http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/contents/">Google C++ 风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuZHljYWkvY3ByaW1lcg==" title="https://github.com/andycai/cprimer">C/C++ Primer<i class="fa fa-external-link"></i></span> (by @andycai)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2xpYnJhcnlzL2Jvb2tzL2NvbnRlbnRzL2M=" title="http://www.nowamagic.net/librarys/books/contents/c">简单易懂的C魔法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Nld20ucGt1LmVkdS5jbi9zcmMvcGFyYWRpc2UvcmVmZXJlbmNlL0NNYWtlJTIwUHJhY3RpY2UucGRm" title="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf">Cmake 实践<i class="fa fa-external-link"></i></span> (PDF版)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdW5pc3R1ZGlvLmNvbS9jcHBmYXEv" title="http://www.sunistudio.com/cppfaq/">C++ FAQ LITE(中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vb29waHkvQ3BwLVByaW1lcg==" title="https://github.com/Mooophy/Cpp-Primer">C++ Primer 5th Answers<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9jaGVueGlhb3dlaS9jcHBfY29uY3VycmVuY3lfaW5fYWN0aW9uL2RldGFpbHM=" title="https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details">C++ 并发编程(基于C++11)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vcXRkb2N1bWVudC90dXRvcmlhbC5odG1s" title="http://www.kuqin.com/qtdocument/tutorial.html">QT 教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2MxLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/c1.md">C进阶指南（1)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1b2hhaGEvQ2hpbmVzZS11dmJvb2s=" title="https://github.com/luohaha/Chinese-uvbook">libuv中文教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLmhpZ2hzY29yZS5kZS9jcHAvYm9vc3Qv" title="http://zh.highscore.de/cpp/boost/">Boost 库中文教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpemFyZGZvcmNlbC9sY3Rody16aA==" title="https://github.com/wizardforcel/lcthw-zh">笨办法学C<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2MyLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/c2.md">C进阶指南（2)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2MzLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/c3.md">C进阶指南（3)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL2MtZ2xvYmxlLXZhcmlhYmxlLm1k" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/c-globle-variable.md">C语言全局变量那些事儿<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpcHBpT3VZYW5nL3ByYWN0aWNhbC1jb21wdXRlci1za2lsbHMvYmxvYi9tYXN0ZXIvc3JjL21hbGxvYy5tZA==" title="https://github.com/LippiOuYang/practical-computer-skills/blob/master/src/malloc.md">如何实现一个malloc<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lkZW9uZS5jb20v" title="http://ideone.com/">在线编程和调试的网站<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li><span class="exturl" data-url="aHR0cDovL3poLmxlYXJubGF5b3V0LmNvbS8=" title="http://zh.learnlayout.com/">学习CSS布局<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYWRsdW8vQ1NTLUd1aWRlbGluZXMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1k" title="https://github.com/chadluo/CSS-Guidelines/blob/master/README.md">通用 CSS 笔记、建议与指导<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Nzcy5kb3lvZS5jb20v" title="http://css.doyoe.com/">CSS参考手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3lhbnh5ei5naXRodWIuaW8vZW1tZXQtZG9jcy8=" title="http://yanxyz.github.io/emmet-docs/">Emmet 文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2FsbG95dGVhbS5naXRodWIuaW8vY29kZS1ndWlkZS8=" title="http://alloyteam.github.io/code-guide/">前端代码规范<i class="fa fa-external-link"></i></span> (腾讯alloyteam团队)</li><li><span class="exturl" data-url="aHR0cDovL2NvZGVndWlkZS5ib290Y3NzLmNvbS8=" title="http://codeguide.bootcss.com/">HTML和CSS编码规范<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Nhc3MtZ3VpZGVsaW4uZXMvemgv" title="http://sass-guidelin.es/zh/">Sass Guidelines 中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dheWxhdS9jc3MzLXR1dG9yaWFs" title="https://github.com/waylau/css3-tutorial">CSS3 Tutorial 《CSS3 教程》<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTA==" title="https://developer.mozilla.org/zh-CN/docs/Web/HTML">MDN HTML 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NT" title="https://developer.mozilla.org/zh-CN/docs/Web/CSS">MDN CSS 中文文档<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Vua253b24vZ28tZnVuZGFtZW50YWwtcHJvZ3JhbW1pbmc=" title="https://github.com/Unknwon/go-fundamental-programming">Go编程基础<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Vua253b24vdGhlLXdheS10by1nb19aSF9DTg==" title="https://github.com/Unknwon/the-way-to-go_ZH_CN">Go入门指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL21pa2VzcG9vay5jb20vbGVhcm5pbmctZ28v" title="http://mikespook.com/learning-go/">学习Go语言<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cDovL3h4aXl5LnFpbml1ZG4uY29tLyVFNSVBRCVBNiVFNCVCOSVBMCUyMEdvJTIwJUU4JUFGJUFEJUU4JUE4JTgwKEdvbGFuZykucGRmP2Rvd25sb2Fk" title="http://xxiyy.qiniudn.com/%E5%AD%A6%E4%B9%A0%20Go%20%E8%AF%AD%E8%A8%80(Golang).pdf?download">PDF<i class="fa fa-external-link"></i></span>)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FzdGF4aWUvYnVpbGQtd2ViLWFwcGxpY2F0aW9uLXdpdGgtZ29sYW5n" title="https://github.com/astaxie/build-web-application-with-golang">Go Web 编程<i class="fa fa-external-link"></i></span> (此书已经出版，希望开发者们去购买，支持作者的创作)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FzdGF4aWUvR28taW4tQWN0aW9u" title="https://github.com/astaxie/Go-in-Action">Go实战开发<i class="fa fa-external-link"></i></span> (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者<span class="exturl" data-url="aHR0cHM6Ly9tZS5hbGlwYXkuY29tL2FzdGF4aWU=" title="https://me.alipay.com/astaxie">捐赠<i class="fa fa-external-link"></i></span>，以鼓励作者的继续创作)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FzdGF4aWUvTlBXR196aA==" title="https://github.com/astaxie/NPWG_zh">Network programming with Go 中文翻译版本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5oZWxsb2djYy5vcmcvZWZmZWN0aXZlX2dvLmh0bWw=" title="http://www.hellogcc.org/effective_go.html">Effective Go<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L1RoZS1Hb2xhbmctU3RhbmRhcmQtTGlicmFyeS1ieS1FeGFtcGxl" title="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example">Go 语言标准库<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dvZG9jLm1sLw==" title="http://godoc.ml/">Golang标准库文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2dvcmV2ZWwuY24vZG9jcy9tYW51YWwvaW5kZXguaHRtbA==" title="http://gorevel.cn/docs/manual/index.html">Revel 框架手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2L2FydGljbGUvZGV0YWlscy80NjU2NTI0MQ==" title="http://blog.csdn.net/dc_726/article/details/46565241">Java程序员的Golang入门指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h5cGVyLWNhcnJvdC9nb19jb21tYW5kX3R1dG9yaWFs" title="https://github.com/hyper-carrot/go_command_tutorial">Go命令教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FjaHVuL0dvLUJsb2ctSW4tQWN0aW9u" title="https://github.com/achun/Go-Blog-In-Action">Go语言博客实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy1jaGluYS9nb2xhbmdkb2MudHJhbnNsYXRpb25z" title="https://github.com/golang-china/golangdoc.translations">Go 官方文档翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpYW5jYWlhbWFvL2dvLWludGVybmFscw==" title="https://github.com/tiancaiamao/go-internals">深入解析Go<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL2dvbGFuZy1jaGluYS9nb3BsLXpoL3dpa2kvSG9tZQ==" title="https://bitbucket.org/golang-china/gopl-zh/wiki/Home">Go语言圣经(中文版)<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvZ29wbC16aC9kZXRhaWxz" title="https://www.gitbook.com/book/wizardforcel/gopl-zh/details">GitBook<i class="fa fa-external-link"></i></span>)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYWkyMDEwL2FkdmFuY2VkLWdvLXByb2dyYW1taW5nLWJvb2s=" title="https://github.com/chai2010/advanced-go-programming-book">Go语言高级编程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2phdmEvai1wZy8=" title="http://www.ibm.com/developerworks/cn/java/j-pg/">实战 Groovy 系列<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h3><ul><li><span class="exturl" data-url="aHR0cDovL3J3aC5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0Lw==" title="http://rwh.readthedocs.org/en/latest/">Real World Haskell 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZsZXVyZXItbGVlLmNvbS9seWFoLw==" title="http://fleurer-lee.com/lyah/">Haskell趣学指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xlYXJueW91YWhhc2tlbGwuY29tL2NoYXB0ZXJz" title="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!<i class="fa fa-external-link"></i></span>(质量不错的一个网书)</li></ul><hr><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Fpbmp4LzMwbWluX2d1aWRlcy9ibG9iL21hc3Rlci9pb3MubWQ=" title="https://github.com/qinjx/30min_guides/blob/master/ios.md">iOS开发60分钟入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lzdXgudGVuY2VudC5jb20vaW9zLWh1bWFuLWludGVyZmFjZS1ndWlkZWxpbmVzLXVpLWRlc2lnbi1iYXNpY3MtaW9zNy5odG1s" title="http://isux.tencent.com/ios-human-interface-guidelines-ui-design-basics-ios7.html">iOS7人机界面指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLWdvb2dsZS1zdHlsZWd1aWRlLnJlYWR0aGVkb2NzLm9yZy9lbi9sYXRlc3QvZ29vZ2xlLW9iamMtc3R5bGVndWlkZS8=" title="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/">Google Objective-C Style Guide 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dpbGVhbS5jb20vaXBob25lLTYtc2NyZWVuLWNuLw==" title="http://wileam.com/iphone-6-screen-cn/">iPhone 6 屏幕揭秘<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL25pbHN1bi5naXRodWIuaW8vYXBwbGUtd2F0Y2gv" title="http://nilsun.github.io/apple-watch/">Apple Watch开发初探<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvaW9zL3JlZmVyZW5jZWxpYnJhcnkvR2V0dGluZ1N0YXJ0ZWQvUm9hZE1hcGlPU0NoL2luZGV4Lmh0bWw=" title="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/index.html">马上着手开发 iOS 应用程序<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2preWluL1N1YnRpdGxl" title="https://github.com/jkyin/Subtitle">网易斯坦福大学公开课：iOS 7应用开发字幕文件<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul><li><p><span class="exturl" data-url="aHR0cDovL2JxNjkuY29tL2Jsb2cvYXJ0aWNsZXMvc2NyaXB0Lzg2OC9nb29nbGUtamF2YXNjcmlwdC1zdHlsZS1ndWlkZS5odG1s" title="http://bq69.com/blog/articles/script/868/google-javascript-style-guide.html">Google JavaScript 代码风格指南<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhcmN5bGl1L2dvb2dsZS1zdHlsZWd1aWRlL2Jsb2IvbWFzdGVyL0pTT05TdHlsZUd1aWRlLm1k" title="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md">Google JSON 风格指南<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkYW1sdS9qYXZhc2NyaXB0LXN0eWxlLWd1aWRl" title="https://github.com/adamlu/javascript-style-guide">Airbnb JavaScript 规范<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2phdmFzY3JpcHQucnVhbnlpZmVuZy5jb20v" title="http://javascript.ruanyifeng.com/">JavaScript 标准参考教程（alpha）<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL3Bpai5yb2JpbnF1Lm1lLw==" title="http://pij.robinqu.me/">Javascript编程指南<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JvYmluUXUvUHJvZ3JhbWluZy1Jbi1KYXZhc2NyaXB0" title="https://github.com/RobinQu/Programing-In-Javascript">源码<i class="fa fa-external-link"></i></span>)</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1c3RqYXZhYy8xMi1qYXZhc2NyaXB0LXF1aXJrcw==" title="https://github.com/justjavac/12-javascript-quirks">javascript 的 12 个怪癖<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2JvbnNhaWRlbi5naXRodWIuaW8vSmF2YVNjcmlwdC1HYXJkZW4vemgv" title="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2ljb2RlaXQub3JnL2pzY2NwLw==" title="http://icodeit.org/jsccp/">JavaScript核心概念及实践<i class="fa fa-external-link"></i></span> (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者)</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pheWxpL2phdmFzY3JpcHQtcGF0dGVybnM=" title="https://github.com/jayli/javascript-patterns">《JavaScript 模式》<i class="fa fa-external-link"></i></span> “JavaScript patterns”中译本</p></li><li><p><span class="exturl" data-url="aHR0cDovL2p1c3RqYXZhYy5jb20vbmFtZWQtZnVuY3Rpb24tZXhwcmVzc2lvbnMtZGVteXN0aWZpZWQuaHRtbA==" title="http://justjavac.com/named-function-expressions-demystified.html">命名函数表达式探秘<i class="fa fa-external-link"></i></span>  (注:原文由<span class="exturl" data-url="aHR0cDovL3d3dy5jbi1jdWNrb28uY29t" title="http://www.cn-cuckoo.com">为之漫笔<i class="fa fa-external-link"></i></span>翻译，原始地址无法打开，所以此处地址为我博客上的备份)</p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5vc2NoaW5hLm5ldC90cmFuc2xhdGUvbGVhcm5pbmctamF2YXNjcmlwdC1kZXNpZ24tcGF0dGVybnM=" title="http://www.oschina.net/translate/learning-javascript-design-patterns">学用 JavaScript 设计模式<i class="fa fa-external-link"></i></span> (开源中国)</p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9Ub21YdS9hcmNoaXZlLzIwMTEvMTIvMTUvMjI4ODQxMS5odG1s" title="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解JavaScript系列<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=" title="http://es6.ruanyifeng.com/">ECMAScript 6 入门<i class="fa fa-external-link"></i></span> (作者：阮一峰)</p></li><li><p><span class="exturl" data-url="aHR0cDovL2xpdWJpbi5naXRodWIuaW8vcHJvbWlzZXMtYm9vay8=" title="http://liubin.github.io/promises-book/">JavaScript Promise迷你书<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dldGlmeS9Zb3UtRG9udC1Lbm93LUpT" title="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS<i class="fa fa-external-link"></i></span> (深入JavaScript语言核心机制的系列图书)</p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDE0MzQ0NDY2ODk4NjdiMjcxNTdlODk2ZTc0ZDUxYTg5YzI1Y2M4YjQzYmRiMzAwMA==" title="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000">JavaScript 教程<i class="fa fa-external-link"></i></span> 廖雪峰</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdA==" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN JavaScript 中文文档<i class="fa fa-external-link"></i></span></p></li><li><p>jQuery</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbi1jdWNrb28uY29tL2RlY29uc3RydWN0ZWQvanF1ZXJ5Lmh0bWw=" title="http://www.cn-cuckoo.com/deconstructed/jquery.html">jQuery 解构<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2xpYnJhcnlzL2Jvb2tzL2NvbnRlbnRzL2pxdWVyeQ==" title="http://www.nowamagic.net/librarys/books/contents/jquery">简单易懂的JQuery魔法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2k1dGluZy5naXRodWIuaW8vSG93LXRvLXdyaXRlLWpRdWVyeS1wbHVnaW4vYnVpbGQvanF1ZXJ5LnBsdWdpbi5odG1s" title="http://i5ting.github.io/How-to-write-jQuery-plugin/build/jquery.plugin.html">How to write jQuery plugin<i class="fa fa-external-link"></i></span></li></ul></li><li><p>Node.js</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub2RlYmVnaW5uZXIub3JnL2luZGV4LXpoLWNuLmh0bWw=" title="http://www.nodebeginner.org/index-zh-cn.html">Node入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL25xZGVuZy5naXRodWIuaW8vNy1kYXlzLW5vZGVqcy8=" title="http://nqdeng.github.io/7-days-nodejs/">七天学会NodeJS<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy10dy9ub2RlanMtd2lraS1ib29r" title="https://github.com/nodejs-tw/nodejs-wiki-book">Nodejs Wiki Book<i class="fa fa-external-link"></i></span> (繁体中文)</li><li><span class="exturl" data-url="aHR0cDovL2V4cHJlc3Nqcy5qc2VyLnVzLw==" title="http://expressjs.jser.us/">express.js 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1by15dS9rb2EtZ3VpZGU=" title="https://github.com/guo-yu/koa-guide">koa 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jhc2Utbi5naXRodWIuaW8va29hLWdlbmVyYXRvci1leGFtcGxlcy8=" title="http://base-n.github.io/koa-generator-examples/">一起学koa<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25zd2Jtdy9OLWJsb2c=" title="https://github.com/nswbmw/N-blog">使用 Express + MongoDB 搭建多人博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2phdmFzY3JpcHQucnVhbnlpZmVuZy5jb20vbm9kZWpzL2V4cHJlc3MuaHRtbA==" title="http://javascript.ruanyifeng.com/nodejs/express.html">Express框架<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fsc290YW5nL25vZGUtbGVzc29ucw==" title="https://github.com/alsotang/node-lessons">Node.js 包教不包会<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMub3JnL3BhY2thZ2UvbGVhcm55b3Vub2RlLXpoLWNu" title="https://www.npmjs.org/package/learnyounode-zh-cn">Learn You The Node.js For Much Win! (中文版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2k1dGluZy5naXRodWIuaW8vbm9kZS1kZWJ1Zy10dXRvcmlhbC8=" title="http://i5ting.github.io/node-debug-tutorial/">Node debug 三法三例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay8wNTMyL25vZGVqcy9kZXRhaWxz" title="https://www.gitbook.com/book/0532/nodejs/details">nodejs中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpemFyZGZvcmNlbC9vcm0yLWRvYy16aC1jbg==" title="https://github.com/wizardforcel/orm2-doc-zh-cn">orm2 中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li><p>underscore.js</p><ul><li><span class="exturl" data-url="aHR0cDovL2xlYXJuaW5nY24uY29tL3VuZGVyc2NvcmUv" title="http://learningcn.com/underscore/">Underscore.js中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li><p>backbone.js</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL2JhY2tib25lLw==" title="http://www.css88.com/doc/backbone/">backbone.js中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy50aGU1ZmlyZS5jb20vYmFja2JvbmUtanMtdHV0b3JpYWxzLXBkZi1kb3dubG9hZC5odG1s" title="http://www.the5fire.com/backbone-js-tutorials-pdf-download.html">backbone.js入门教程<i class="fa fa-external-link"></i></span> (PDF)</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZTVmaXJlL2JhY2tib25lanMtbGVhcm5pbmctbm90ZQ==" title="https://github.com/the5fire/backbonejs-learning-note">Backbone.js入门教程第二版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZlbGl2aW5nLmdpdGh1Yi5pby9kZXZlbG9waW5nLWJhY2tib25lLWFwcGxpY2F0aW9ucw==" title="http://feliving.github.io/developing-backbone-applications">Developing Backbone.js Applications(中文版)<i class="fa fa-external-link"></i></span></li></ul></li><li><p>AngularJS</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21nZWNoZXYvYW5ndWxhcmpzLXN0eWxlLWd1aWRlL2Jsb2IvbWFzdGVyL1JFQURNRS16aC1jbi5tZA==" title="https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md">AngularJS最佳实践和风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BlaXJhbnN1bi9hbmd1bGFyanMtY24=" title="https://github.com/peiransun/angularjs-cn">AngularJS中译本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbnNoL0FuZ3VsYXJqc1R1dG9yaWFsX2Nu" title="https://github.com/zensh/AngularjsTutorial_cn">AngularJS入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1ZmVpL01ha2UtWW91ci1Pd24tQW5ndWxhckpTL2Jsb2IvbWFzdGVyLzAxLm1k" title="https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md">构建自己的AngularJS<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53YXlsYXUuY29tL2J1aWxkLWFuZ3VsYXJqcy1hcHAtd2l0aC15ZW9tYW4taW4td2luZG93cy8=" title="http://www.waylau.com/build-angularjs-app-with-yeoman-in-windows/">在Windows环境下用Yeoman构建AngularJS项目<i class="fa fa-external-link"></i></span></li></ul></li><li><p>Zepto.js</p><ul><li><span class="exturl" data-url="aHR0cDovL213ZWIuYmFpZHUuY29tL3plcHRvYXBpLw==" title="http://mweb.baidu.com/zeptoapi/">Zepto.js 中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li><p>Sea.js</p><ul><li><span class="exturl" data-url="aHR0cDovL2lzbGFuZDIwNS5naXRodWIuaW8vSGVsbG9TZWEuanMv" title="http://island205.github.io/HelloSea.js/">Hello Sea.js<i class="fa fa-external-link"></i></span></li></ul></li><li><p>React.js</p><ul><li><span class="exturl" data-url="aHR0cDovL3JlYWN0anMuY24v" title="http://reactjs.cn/">React.js 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zha2VmaXNoL3JlYWN0LXdlYnBhY2stY29va2Jvb2s=" title="https://github.com/fakefish/react-webpack-cookbook">React webpack-cookbook<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZyYXNlcnh1Lm1lL2ludHJvLXRvLXJlYWN0Lw==" title="http://fraserxu.me/intro-to-react/">React 入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dpa2kuamlrZXh1ZXl1YW4uY29tL3Byb2plY3QvcmVhY3QtbmF0aXZlLw==" title="http://wiki.jikexueyuan.com/project/react-native/">React Native 中文文档(含最新Android内容)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZUppYW4vYnVpbGQtYS1obi1mcm9udC1wYWdl" title="https://github.com/theJian/build-a-hn-front-page">Learn React &amp; Webpack by building the Hacker News front page<i class="fa fa-external-link"></i></span></li></ul></li><li><p>impress.js</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tva2RlbW8vaW1wcmVzcy5qcy10dXRvcmlhbC1pbi1DaGluZXNl" title="https://github.com/kokdemo/impress.js-tutorial-in-Chinese">impress.js的中文教程<i class="fa fa-external-link"></i></span></li></ul></li><li><p>CoffeeScript</p><ul><li><span class="exturl" data-url="aHR0cDovL2lzbGFuZDIwNS5naXRodWIuaW8vY29mZmVlc2NyaXB0LWNvb2tib29rLmdpdGh1Yi5jb20v" title="http://island205.github.io/coffeescript-cookbook.github.com/">CoffeeScript Cookbook<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lzbGFuZDIwNS5naXRodWIuaW8vdGxib2Mv" title="http://island205.github.io/tlboc/">The Little Book on CoffeeScript中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZWtwbHV4L2NvZmZlZXNjcmlwdC1zdHlsZS1ndWlkZQ==" title="https://github.com/geekplux/coffeescript-style-guide">CoffeeScript 编码风格指南<i class="fa fa-external-link"></i></span></li></ul></li><li><p>TypeScipt</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aG9uZ3NwLmdpdGJvb2tzLmlvL3R5cGVzY3JpcHQtaGFuZGJvb2svY29udGVudC8=" title="https://zhongsp.gitbooks.io/typescript-handbook/content/">TypeScript Handbook<i class="fa fa-external-link"></i></span></li></ul></li><li><p>ExtJS</p><ul><li><span class="exturl" data-url="aHR0cDovL2V4dGpzLWRvYy1jbi5naXRodWIuaW8vZXh0NGFwaS8=" title="http://extjs-doc-cn.github.io/ext4api/">Ext4.1.0 中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li><p>Meteor</p><ul><li><span class="exturl" data-url="aHR0cDovL3poLmRpc2NvdmVybWV0ZW9yLmNvbS8=" title="http://zh.discovermeteor.com/">Discover Meteor<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3MubWV0ZW9yaHViLm9yZy8jL2Jhc2ljLw==" title="http://docs.meteorhub.org/#/basic/">Meteor 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2FuZ3VsYXIubWV0ZW9yaHViLm9yZy8=" title="http://angular.meteorhub.org/">Angular-Meteor 中文教程<i class="fa fa-external-link"></i></span></li></ul></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9taW5pYm9vay85NTA=" title="http://www.ituring.com.cn/minibook/950">Chrome扩展及应用开发<i class="fa fa-external-link"></i></span></p></li></ul><hr><h3 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h3><ul><li><span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lLzIwMTQvMDkvMDgvbGF0ZXgtaW50cm9kdWN0aW9uLw==" title="http://liam0205.me/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tb2h1Lm9yZy9pbmZvL2xzaG9ydC1jbi5wZGY=" title="http://www.mohu.org/info/lshort-cn.pdf">一份不太简短的 LATEX 2ε 介绍<i class="fa fa-external-link"></i></span> （PDF版）</li></ul><hr><h3 id="LISP"><a href="#LISP" class="headerlink" title="LISP"></a>LISP</h3><ul><li>Common Lisp<ul><li><span class="exturl" data-url="aHR0cDovL2FjbC5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0Lw==" title="http://acl.readthedocs.org/en/latest/">ANSI Common Lisp 中文翻譯版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9taW5pYm9vay84NjI=" title="http://www.ituring.com.cn/minibook/862">On Lisp 中文翻译版本<i class="fa fa-external-link"></i></span></li></ul></li><li>Scheme<ul><li><span class="exturl" data-url="aHR0cDovL2RlYXRoa2luZy5naXRodWIuaW8veWFzdC1jbi8=" title="http://deathking.github.io/yast-cn/">Yet Another Scheme Tutorial Scheme入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvbmdqaW5naGUuZ2l0aHViLmlvL1RZUy16aC10cmFuc2xhdGlvbi8=" title="http://songjinghe.github.io/TYS-zh-translation/">Scheme语言简明教程<i class="fa fa-external-link"></i></span></li><li>Racket<ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cmNoZW4vcmFja2V0LWJvb2s=" title="https://github.com/tyrchen/racket-book">Racket book<i class="fa fa-external-link"></i></span></li></ul></li></ul></li></ul><hr><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuZHljYWkvbHVhcHJpbWVy" title="https://github.com/andycai/luaprimer">Lua编程入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2Rpbmdub3cuY29tLzIwMDAvZG93bmxvYWQvbHVhX21hbnVhbC5odG1s" title="http://www.codingnow.com/2000/download/lua_manual.html">Lua 5.1 参考手册 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Nsb3Vkd3UuZ2l0aHViLmlvL2x1YTUzZG9jLw==" title="http://cloudwu.github.io/lua53doc/">Lua 5.3 参考手册 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2Rpbmdub3cuY29tL3RlbXAvcmVhZGluZ2x1YS5wZGY=" title="http://www.codingnow.com/temp/readinglua.pdf">Lua源码欣赏<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvcnVzL21vZGVybl9wZXJsX2Jvb2s=" title="https://github.com/horus/modern_perl_book">Modern Perl 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3BlcmwubGludXh0b3kub3JnLw==" title="http://perl.linuxtoy.org/">Perl 程序员应该知道的事<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><ul><li><span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poLw==" title="http://php.net/manual/zh/">PHP 官方手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5sYXJ1ZW5jZS5jb20vMjAxMC8wNi8yMS8xNjA4Lmh0bWw=" title="http://www.laruence.com/2010/06/21/1608.html">PHP调试技术手册<i class="fa fa-external-link"></i></span>(PDF)</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ibG9na3VuLmNvbS9wcm9qZWN0Lmh0bWw=" title="http://www.blogkun.com/project.html">XDebug 2中文手册(译)<i class="fa fa-external-link"></i></span> (CHM)</li><li><span class="exturl" data-url="aHR0cDovL3d1bGlqdW4uZ2l0aHViLmlvL3BocC10aGUtcmlnaHQtd2F5Lw==" title="http://wulijun.github.io/php-the-right-way/">PHP之道<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1c3RqYXZhYy9QSFAtQmVzdC1QcmFjdGljZXMtemhfQ04=" title="https://github.com/justjavac/PHP-Best-Practices-zh_CN">PHP 最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3J5YW5jYW8uZ2l0Ym9va3MuaW8vcGhwLWRldmVsb3Blci1wcmVwYXJlcy9jb250ZW50Lw==" title="http://ryancao.gitbooks.io/php-developer-prepares/content/">PHP 开发者实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZXplL3RpcGk=" title="https://github.com/reeze/tipi">深入理解PHP内核<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53YWx1LmNjL3BocGJvb2sv" title="http://www.walu.cc/phpbook/">PHP扩展开发及内核应用<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2NvZGVpZ25pdGVyLm9yZy5jbi91c2VyX2d1aWRlL2luZGV4Lmh0bWw=" title="http://codeigniter.org.cn/user_guide/index.html">CodeIgniter 用户指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5nb2xhcmF2ZWwuY29tL2RvY3Mv" title="http://www.golaravel.com/docs/">Laravel4 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1YW5naHVhNTgxL2xhcmF2ZWwtZ2V0dGluZy1zdGFydGVk" title="https://github.com/huanghua581/laravel-getting-started">Laravel 入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3N5bWZvbnktZG9jcy1jaHMucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC8=" title="http://symfony-docs-chs.readthedocs.org/en/latest/">Symfony2中文文档<i class="fa fa-external-link"></i></span> (未译完)</li><li><span class="exturl" data-url="aHR0cDovL3BoYWxjb24uNWl1bml4Lm5ldC8=" title="http://phalcon.5iunix.net/">Phalcon中文文档<i class="fa fa-external-link"></i></span>（翻译进行中）</li><li><span class="exturl" data-url="aHR0cDovL3lpaWJvb2suY29tLy9kb2M=" title="http://yiibook.com//doc">YiiBook几本Yii框架的在线教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5kaWdwYWdlLmNvbS8=" title="http://www.digpage.com/">深入理解 Yii 2.0<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy55aWljaGluYS5jb20v" title="http://www.yiichina.com/">Yii 框架中文文檔<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2xpYnJhcnlzL2Jvb2tzL2NvbnRlbnRzL3BocA==" title="http://www.nowamagic.net/librarys/books/contents/php">简单易懂的PHP魔法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpbmtlZERlc3Rpbnkvc3dvb2xlLWRvYw==" title="https://github.com/LinkedDestiny/swoole-doc">swoole文档及入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5waHBjb21wb3Nlci5jb20=" title="http://www.phpcomposer.com">Composer 中文网<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3MS5taW5pbWVlLm9yZy9waHAvc2xpbQ==" title="http://ww1.minimee.org/php/slim">Slim 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2x1bWVuLmxhcmF2ZWwtY2hpbmEub3JnLw==" title="http://lumen.laravel-china.org/">Lumen 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9waHB1bml0LmRlL21hbnVhbC9jdXJyZW50L3poX2NuL2luc3RhbGxhdGlvbi5odG1s" title="https://phpunit.de/manual/current/zh_cn/installation.html">PHPUnit 中文文档<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Prolog"><a href="#Prolog" class="headerlink" title="Prolog"></a>Prolog</h3><ul><li><span class="exturl" data-url="aHR0cDovL2ZlbmdkaWRpLmdpdGh1Yi5pby9ibG9nLzIwMTEvMTEvMTUvcWlhbi15YW4v" title="http://fengdidi.github.io/blog/2011/11/15/qian-yan/">笨办法学Prolog<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDEzNzQ3MzgxMjUwOTVjOTU1YzFlNmQ4YmI0OTMxODIxMDNmYWM5MjcwNzYyYTAwMA==" title="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000">廖雪峰 Python 2.7 中文教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDE0MzE2MDg5NTU3MjY0YTZiMzQ4OTU4ZjQ0OTk0OWRmNDJhNmQzYTJlNTQyYzAwMA==" title="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰 Python 3 中文教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vYWJ5dGVvZnB5dGhvbl9jbi8=" title="http://www.kuqin.com/abyteofpython_cn/">简明Python教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rYW5jbG91ZC5jbi9rYW5jbG91ZC9weXRob24tYmFzaWM=" title="http://www.kancloud.cn/kancloud/python-basic">零基础学 Python 第一版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rYW5jbG91ZC5jbi9rYW5jbG91ZC9zdGFydGVyLWxlYXJuaW5nLXB5dGhvbg==" title="http://www.kancloud.cn/kancloud/starter-learning-python">零基础学 Python 第二版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xvdmVseXB5dGhvbi5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0Lw==" title="http://lovelypython.readthedocs.org/en/latest/">可爱的 Python<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5weXRob25kb2MuY29tL3B5dGhvbnR1dG9yaWFsMjcvaW5kZXguaHRtbA==" title="http://www.pythondoc.com/pythontutorial27/index.html">Python 2.7 官方教程中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5weXRob25kb2MuY29tL3B5dGhvbnR1dG9yaWFsMy9pbmRleC5odG1s" title="http://www.pythondoc.com/pythontutorial3/index.html">Python 3.3 官方教程中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rYW5jbG91ZC5jbi90aGlua3BocC9weXRob24tY29va2Jvb2s=" title="http://www.kancloud.cn/thinkphp/python-cookbook">Python Cookbook 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lpZGFvNjIwYy9weXRob24zLWNvb2tib29r" title="https://github.com/yidao620c/python3-cookbook">Python3 Cookbook 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vZG9jcy9kaXZlaW50b3B5dGhvbnpoLWNuLTUuNGIvaHRtbC90b2Mv" title="http://www.kuqin.com/docs/diveintopythonzh-cn-5.4b/html/toc/">深入 Python<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL29sZC5zZWJ1Zy5uZXQvcGFwZXIvYm9va3MvZGl2ZS1pbnRvLXB5dGhvbjMv" title="http://old.sebug.net/paper/books/dive-into-python3/">深入 Python 3<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC96aG9uZy13aWtpL3dpa2kvUEVQOA==" title="https://code.google.com/p/zhong-wiki/wiki/PEP8">PEP8 Python代码风格规范<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLWdvb2dsZS1zdHlsZWd1aWRlLnJlYWR0aGVkb2NzLm9yZy9lbi9sYXRlc3QvZ29vZ2xlLXB5dGhvbi1zdHlsZWd1aWRlLw==" title="http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/">Google Python 风格指南 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lLzIwMTMvMTEvMDIvUHl0aG9uLXR1dG9yaWFsLXpoX2NuLw==" title="http://liam0205.me/2013/11/02/Python-tutorial-zh_cn/">Python入门教程<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lL2F0dGFjaG1lbnQvUHl0aG9uL1RoZV9QeXRob25fVHV0b3JpYWxfemgtY24ucGRm" title="http://liam0205.me/attachment/Python/The_Python_Tutorial_zh-cn.pdf">PDF<i class="fa fa-external-link"></i></span>)</li><li><span class="exturl" data-url="aHR0cDovL2FydGljbGUueWVleWFuLm9yZy92aWV3LzMxMTUyNy8yODc3MDY=" title="http://article.yeeyan.org/view/311527/287706">Python的神奇方法指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NlYnVnLm5ldC9wYXBlci9ib29rcy9MZWFyblB5dGhvblRoZUhhcmRXYXkv" title="http://sebug.net/paper/books/LearnPythonTheHardWay/">笨办法学 Python<i class="fa fa-external-link"></i></span> （<span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lL2F0dGFjaG1lbnQvUHl0aG9uL1B5SGFyZFdheS9MZWFybl9QeXRob25fVGhlX0hhcmRfV2F5X3poLWNuLnBkZg==" title="http://liam0205.me/attachment/Python/PyHardWay/Learn_Python_The_Hard_Way_zh-cn.pdf">PDF<i class="fa fa-external-link"></i></span>版下载）</li><li><span class="exturl" data-url="aHR0cDovL2RqYW5nb2Jvb2sucHkzay5jbi8yLjAv" title="http://djangobook.py3k.cn/2.0/">The Django Book 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlYnB5Lm9yZy90dXRvcmlhbDMuemgtY24=" title="http://webpy.org/tutorial3.zh-cn">web.py 0.3 新手指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlYnB5Lm9yZy9jb29rYm9vay9pbmRleC56aC1jbg==" title="http://webpy.org/cookbook/index.zh-cn">Web.py Cookbook 简体中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dvb2RwZWNrZXIub3JnLmNuL2RpdmVpbnRvcHl0aG9uLw==" title="http://woodpecker.org.cn/diveintopython/">Dive Into Python 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hc3NvY2lhdGVzLmFtYXpvbi5jbi9ncC9hc3NvY2lhdGVzL25ldHdvcmsvbWFpbi5odG1s" title="https://associates.amazon.cn/gp/associates/network/main.html">Bottle 文档中文版<i class="fa fa-external-link"></i></span> (需翻墙)</li><li><span class="exturl" data-url="aHR0cDovL2RvY3Muamlua2FuLm9yZy9kb2NzL2ZsYXNrLw==" title="http://docs.jinkan.org/docs/flask/">Flask 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3Muamlua2FuLm9yZy9kb2NzL2ppbmphMi8=" title="http://docs.jinkan.org/docs/jinja2/">Jinja2 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlcmt6ZXVnLWRvY3MtY24ucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://werkzeug-docs-cn.readthedocs.org/zh_CN/latest/">Werkzeug 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NwYWNld2FuZGVyLmdpdGh1Yi5pby9leHBsb3JlLWZsYXNrLXpo" title="http://spacewander.github.io/explore-flask-zh">Flask之旅<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RlbW8ucHl0aG9uZXIuY29tL2l0dDJ6aC9pbmRleC5odG1s" title="http://demo.pythoner.com/itt2zh/index.html">Introduction to Tornado 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Bhbi5iYWlkdS5jb20vcy8xcVc0cHZuWQ==" title="http://pan.baidu.com/s/1qW4pvnY">Python自然语言处理中文版<i class="fa fa-external-link"></i></span> （感谢陈涛同学的翻译，也谢谢 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nod2xleQ==" title="https://github.com/shwley">@shwley<i class="fa fa-external-link"></i></span> 联系了作者）</li><li><span class="exturl" data-url="aHR0cDovL2xpYW0wMjA1Lm1lLzIwMTQvMDkvMTEvbWF0cGxvdGxpYi10dXRvcmlhbC16aC1jbi8=" title="http://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/">Python 绘图库 matplotlib 官方指南中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NjcmFweS1jaHMucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://scrapy-chs.readthedocs.org/zh_CN/latest/">Scrapy 0.25 文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NhcmZseS90aGlua3B5dGhvbi1jbg==" title="https://github.com/carfly/thinkpython-cn">ThinkPython<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS92YW1laS9hcmNoaXZlLzIwMTIvMDkvMTMvMjY4Mjc3OC5odG1s" title="http://www.cnblogs.com/vamei/archive/2012/09/13/2682778.html">Python快速教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dpa2kudWJ1bnR1Lm9yZy5jbi9QeXRob27mraPliJnooajovr7lvI/mk43kvZzmjIfljZc=" title="http://wiki.ubuntu.org.cn/Python正则表达式操作指南">Python 正则表达式操作指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcmlmYW4uY29tL2ZpbGVzL2RvYy9kb2Nib29rL3B5dGhvbl9iZWdpbm5lcl90dXRvcmlhbC9yZWxlYXNlL2h0bWwvcHl0aG9uX2JlZ2lubmVyX3R1dG9yaWFsLmh0bWw=" title="http://www.crifan.com/files/doc/docbook/python_beginner_tutorial/release/html/python_beginner_tutorial.html">python初级教程：入门详解<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3B5dGhvbjMtY29va2Jvb2sucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://python3-cookbook.readthedocs.org/zh_CN/latest/">Python Cookbook 第3版 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xpa2ViZXRhLmdpdGJvb2tzLmlvL3R3aXN0ZWQtaW50cm8tY24v" title="http://likebeta.gitbooks.io/twisted-intro-cn/">Twisted 与异步编程入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3RleHRncm9jZXJ5LnJlYWR0aGVkb2NzLm9yZy96aC9sYXRlc3QvaW5kZXguaHRtbA==" title="http://textgrocery.readthedocs.org/zh/latest/index.html">TextGrocery 中文 API<i class="fa fa-external-link"></i></span> ( 基于svm算法的一个短文本分类 Python 库 )</li><li><span class="exturl" data-url="aHR0cDovL3JlcXVlc3RzLWRvY3MtY24ucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://requests-docs-cn.readthedocs.org/zh_CN/latest/">Requests: HTTP for Humans<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3BpbGxvdy1jbi5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0LyM=" title="http://pillow-cn.readthedocs.org/en/latest/#">Pillow 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3B5bW90d2NuLnJlYWR0aGVkb2NzLm9yZy9lbi9sYXRlc3QvaW5kZXguaHRtbA==" title="http://pymotwcn.readthedocs.org/en/latest/index.html">PyMOTW 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RhdGEuZGlnaXRzZXIubmV0L3poLUNOL3B5dGhvbl9pbmRleC5odG1s" title="http://data.digitser.net/zh-CN/python_index.html">Python 官方文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2ZhYnJpYy1jaHMucmVhZHRoZWRvY3Mub3Jn" title="http://fabric-chs.readthedocs.org">Fabric 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2JlYXV0aWZ1bHNvdXAucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://beautifulsoup.readthedocs.org/zh_CN/latest/">Beautiful Soup 4.2.0 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL29sZC5zZWJ1Zy5uZXQvcGFwZXIvYm9va3Mvc2NpcHlkb2M=" title="http://old.sebug.net/paper/books/scipydoc">用Python做科学计算<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5weXRob25kb2MuY29tL3NwaGlueC9pbmRleC5odG1s" title="http://www.pythondoc.com/sphinx/index.html">Sphinx 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1bmRpL01hc3RlcmluZy5QeXRob24uRGVzaWduLlBhdHRlcm5z" title="https://github.com/cundi/Mastering.Python.Design.Patterns">精通 Python 设计模式<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYXJ0Rmxhc2gvcHlTZWN1cml0eQ==" title="https://github.com/smartFlash/pySecurity">python 安全编程教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvc2p0dS1jczkwMi1jb3Vyc2V3YXJlL2RldGFpbHM=" title="https://www.gitbook.com/book/wizardforcel/sjtu-cs902-courseware/details">程序设计思想与方法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9yZWFkLmRvdWJhbi5jb20vZWJvb2svMTY2OTE4NDkv" title="https://read.douban.com/ebook/16691849/">知乎周刊·编程小白学Python<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb2dhL3NjaXB5LWxlY3R1cmUtbm90ZXNfY24=" title="https://github.com/cloga/scipy-lecture-notes_cn">Scipy 讲义<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vZG9jcy9weXRob25iYXNpYy5odG1s" title="http://www.kuqin.com/docs/pythonbasic.html">Python 学习笔记 基础篇<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rdXFpbi5jb20vZG9jcy9weXRob25tb2R1bGUuaHRtbA==" title="http://www.kuqin.com/docs/pythonmodule.html">Python 学习笔记 模块篇<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL29sZC5zZWJ1Zy5uZXQvcGFwZXIvYm9va3MvcHl0aG9uLyVFMyU4MCU4QVB5dGhvbiVFNiVBMCU4NyVFNSU4NyU4NiVFNSVCQSU5MyVFMyU4MCU4QiVFNCVCOCVBRCVFNiU5NiU4NyVFNyU4OSU4OC5wZGY=" title="http://old.sebug.net/paper/books/python/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B%E4%B8%AD%E6%96%87%E7%89%88.pdf">Python 标准库 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9lYXN0bGFrZXNpZGUvaW50ZXJweS16aC9kZXRhaWxz" title="https://www.gitbook.com/book/eastlakeside/interpy-zh/details">Python进阶<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vY29yZS1weXRob24tMmUvY29udGVudC8=" title="https://wizardforcel.gitbooks.io/core-python-2e/content/">Python 核心编程 第二版<i class="fa fa-external-link"></i></span> CPyUG译</li><li><span class="exturl" data-url="aHR0cDovL3B5dGhvbmd1aWRlY24ucmVhZHRoZWRvY3MuaW8vemgvbGF0ZXN0Lw==" title="http://pythonguidecn.readthedocs.io/zh/latest/">Python最佳实践指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvcHl0aG9uLWVzc2VudGlhbC10dXRvcmlhbC9kZXRhaWxz" title="https://www.gitbook.com/book/wizardforcel/python-essential-tutorial/details">Python 精要教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvcHl0aG9uLXF1YW50LXVxZXIvZGV0YWlscw==" title="https://www.gitbook.com/book/wizardforcel/python-quant-uqer/details">Python 量化交易教程<i class="fa fa-external-link"></i></span></li><li>Django<ul><li><span class="exturl" data-url="aHR0cDovL2RqYW5nby1jaGluZXNlLWRvY3MucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC8=" title="http://django-chinese-docs.readthedocs.org/en/latest/">Django 1.5 文档中文版<i class="fa fa-external-link"></i></span> 正在翻译中</li><li><span class="exturl" data-url="aHR0cDovL2RqYW5nby0xLTctZG9jLmNvZGluZy5pby8=" title="http://django-1-7-doc.coding.io/">Diango 1.7 文档中文版<i class="fa fa-external-link"></i></span>  正在翻译中，目前只翻译了目录</li><li><span class="exturl" data-url="aHR0cDovL3B5dGhvbi51c3lpeWkuY24vZGphbmdvL2luZGV4Lmh0bWw=" title="http://python.usyiyi.cn/django/index.html">Django 1.8.2 文档中文版<i class="fa fa-external-link"></i></span><br>正在翻译中</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhbmd5dWJvL3poLWRqYW5nby1iZXN0LXByYWN0aWNlcw==" title="https://github.com/yangyubo/zh-django-best-practices">Django 最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9hbmRyZXctbGl1L2RqYW5nby1ibG9nL2RldGFpbHM=" title="https://www.gitbook.com/book/andrew-liu/django-blog/details">Django搭建简易博客教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RqYW5nb2Jvb2sucHkzay5jbi8yLjAv" title="http://djangobook.py3k.cn/2.0/">The Django Book 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1bmRpL0RqYW5nby1EZXNpZ24tUGF0dGVybnMtYW5kLUJlc3QtUHJhY3RpY2Vz" title="https://github.com/cundi/Django-Design-Patterns-and-Best-Practices">Django 设计模式与最佳实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1bmRpL1dlYi5EZXZlbG9wbWVudC53aXRoLkRqYW5nby5Db29rYm9vaw==" title="https://github.com/cundi/Web.Development.with.Django.Cookbook">Django 网站开发 Cookbook<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9kamFuZ29naXJsc3RhaXBlaS9kamFuZ28tZ2lybHMtdGFpcGVpLXR1dG9yaWFsL2RldGFpbHM=" title="https://www.gitbook.com/book/djangogirlstaipei/django-girls-taipei-tutorial/details">Django Girls 學習指南<i class="fa fa-external-link"></i></span></li></ul></li><li>Flask<ul><li><span class="exturl" data-url="aHR0cDovL2RvY3Muamlua2FuLm9yZy9kb2NzL2ZsYXNrLw==" title="http://docs.jinkan.org/docs/flask/">Flask 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3Muamlua2FuLm9yZy9kb2NzL2ppbmphMi8=" title="http://docs.jinkan.org/docs/jinja2/">Jinja2 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlcmt6ZXVnLWRvY3MtY24ucmVhZHRoZWRvY3Mub3JnL3poX0NOL2xhdGVzdC8=" title="http://werkzeug-docs-cn.readthedocs.org/zh_CN/latest/">Werkzeug 文档中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NwYWNld2FuZGVyLmdpdGh1Yi5pby9leHBsb3JlLWZsYXNrLXpoLw==" title="http://spacewander.github.io/explore-flask-zh/">Flask之旅<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay93aXphcmRmb3JjZWwvZmxhc2stZXh0ZW5zaW9uLWRvY3MvZGV0YWlscw==" title="https://www.gitbook.com/book/wizardforcel/flask-extension-docs/details">Flask 扩展文档汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5weXRob25kb2MuY29tL2ZsYXNrLW1lZ2EtdHV0b3JpYWwvaW5kZXguaHRtbA==" title="http://www.pythondoc.com/flask-mega-tutorial/index.html">Flask 大型教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpeHUwNTIwMjAwNC9zcWxhbGNoZW15LWRvY3MtY24=" title="https://github.com/sixu05202004/sqlalchemy-docs-cn">SQLAlchemy 中文文档<i class="fa fa-external-link"></i></span></li></ul></li><li>web.py<ul><li><span class="exturl" data-url="aHR0cDovL3dlYnB5Lm9yZy90dXRvcmlhbDMuemgtY24=" title="http://webpy.org/tutorial3.zh-cn">web.py 0.3 新手指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlYnB5Lm9yZy9jb29rYm9vay9pbmRleC56aC1jbg==" title="http://webpy.org/cookbook/index.zh-cn">Web.py Cookbook 简体中文版<i class="fa fa-external-link"></i></span></li></ul></li><li>Tornado<ul><li><span class="exturl" data-url="aHR0cDovL2RlbW8ucHl0aG9uZXIuY29tL2l0dDJ6aC9pbmRleC5odG1s" title="http://demo.pythoner.com/itt2zh/index.html">Introduction to Tornado 中文翻译<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2FjYWRlbXkvZGV0YWlsLzEzMzIxMDAy" title="http://www.nowamagic.net/academy/detail/13321002">Tornado源码解析<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90b3JuYWRvLXpoLnJlYWR0aGVkb2NzLm9yZy96aC9sYXRlc3Qv" title="https://tornado-zh.readthedocs.org/zh/latest/">Tornado 4.3 文档中文版<i class="fa fa-external-link"></i></span></li></ul></li></ul><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lpaHVpL3ItbmluamE=" title="https://github.com/yihui/r-ninja">R语言忍者秘笈<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0p1YW5pdG9GYXRhcy9ydWJ5LXN0eWxlLWd1aWRlL2Jsb2IvbWFzdGVyL1JFQURNRS16aENOLm1k" title="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md">Ruby 风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0p1YW5pdG9GYXRhcy9yYWlscy1zdHlsZS1ndWlkZS9ibG9iL21hc3Rlci9SRUFETUUtemhDTi5tZA==" title="https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md">Rails 风格指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xydGh3LmdpdGh1Yi5pby8=" title="http://lrthw.github.io/">笨方法學 Ruby<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2d1aWRlcy5ydWJ5LWNoaW5hLm9yZy8=" title="http://guides.ruby-china.org/">Ruby on Rails 指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lob3dlci50dy9yYWlsczQvaW5kZXguaHRtbA==" title="http://ihower.tw/rails4/index.html">Ruby on Rails 實戰聖經<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3JhaWxzdHV0b3JpYWwtY2hpbmEub3JnLw==" title="http://railstutorial-china.org/">Ruby on Rails Tutorial 原书第 3 版<i class="fa fa-external-link"></i></span> (本书网页版免费提供，电子版以 PDF、EPub 和 Mobi 格式提供购买，仅售 9.9 美元)</li><li><span class="exturl" data-url="aHR0cDovL3JhaWxzLXByYWN0aWNlLmNvbS9jb250ZW50L2luZGV4Lmh0bWw=" title="http://rails-practice.com/content/index.html">Rails 实践<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9rZWxieS9yYWlscy1iZWdpbm5lci1zLWd1aWRlL2RldGFpbHM=" title="https://www.gitbook.com/book/kelby/rails-beginner-s-guide/details">Rails 5 开发进阶(Beta)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9yb2NvZGV2L3JhaWxzLTEwMi9kZXRhaWxz" title="https://www.gitbook.com/book/rocodev/rails-102/details">Rails 102<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93dXN1b3B1LmdpdGJvb2tzLmlvL3dyaXRlLXJ1YnktZXh0ZW5zaW9uLXdpdGgtYy9jb250ZW50Lw==" title="https://wusuopu.gitbooks.io/write-ruby-extension-with-c/content/">编写Ruby的C拓展<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ydWJ5LWNoaW5hLm9yZy90b3BpY3MvMjIzODY=" title="https://ruby-china.org/topics/22386">Ruby 源码解读<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RlYXRoa2luZy5naXRodWIuaW8vbWV0YXByb2dyYW1taW5nLWluLXJ1Ynkv" title="http://deathking.github.io/metaprogramming-in-ruby/">Ruby中的元编程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><ul><li><span class="exturl" data-url="aHR0cDovL3R3aXR0ZXIuZ2l0aHViLmlvL3NjYWxhX3NjaG9vbC96aF9jbi9pbmRleC5odG1s" title="http://twitter.github.io/scala_school/zh_cn/index.html">Scala课堂<i class="fa fa-external-link"></i></span> (Twitter的Scala中文教程)</li><li><span class="exturl" data-url="aHR0cDovL3R3aXR0ZXIuZ2l0aHViLmlvL2VmZmVjdGl2ZXNjYWxhL2luZGV4LWNuLmh0bWw=" title="http://twitter.github.io/effectivescala/index-cn.html">Effective Scala<i class="fa fa-external-link"></i></span>(Twitter的Scala最佳实践的中文翻译)</li><li><span class="exturl" data-url="aHR0cDovL3poLnNjYWxhLXRvdXIuY29tLw==" title="http://zh.scala-tour.com/">Scala指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9TY2FsYS1JbXBhdGllbnQtMm5kLUNheS1Ib3JzdG1hbm4vZHAvMDEzNDU0MDU2NQ==" title="https://www.amazon.com/Scala-Impatient-2nd-Cay-Horstmann/dp/0134540565">Scala-for-the-impatient-2nd<i class="fa fa-external-link"></i></span>(自行购买或pdf)</li><li><span class="exturl" data-url="aHR0cDovL2hvbmdqaWFuZy5pbmZvL3NjYWxhLw==" title="http://hongjiang.info/scala/">Scala|写点什么<i class="fa fa-external-link"></i></span>(国人的一个很好的关于Scala的博客)</li></ul><hr><h3 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h3><ul><li><span class="exturl" data-url="aHR0cDovL2RlYXRoa2luZy5naXRodWIuaW8veWFzdC1jbi8=" title="http://deathking.github.io/yast-cn/">Yet Another Scheme Tutorial Scheme入门教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvbmdqaW5naGUuZ2l0aHViLmlvL1RZUy16aC10cmFuc2xhdGlvbi8=" title="http://songjinghe.github.io/TYS-zh-translation/">Scheme语言简明教程<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Fpbmp4LzMwbWluX2d1aWRlcy9ibG9iL21hc3Rlci9zaGVsbC5tZA==" title="https://github.com/qinjx/30min_guides/blob/master/shell.md">Shell脚本编程30分钟入门<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2FlLnNpbmEuY29tLmNuL2FyY2hpdmVzLzM2MDY=" title="http://blog.sae.sina.com.cn/archives/3606">Bash脚本15分钟进阶教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lMTE1L2xpbnV4dG9vbHNfcnN0" title="https://github.com/me115/linuxtools_rst">Linux工具快速教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d6YjU2LzEzX3F1ZXN0aW9uc19vZl9zaGVsbA==" title="https://github.com/wzb56/13_questions_of_shell">shell十三问<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><ul><li><span class="exturl" data-url="aHR0cDovL251bWJiYmJiLmdpdGh1Yi5pby90aGUtc3dpZnQtcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtaW4tY2hpbmVzZS8=" title="http://numbbbbb.github.io/the-swift-programming-language-in-chinese/">The Swift Programming Language 中文版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Rldi5zd2lmdGd1aWRlLmNu" title="http://dev.swiftguide.cn">Swift 语言指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3gxNDB5dS9EZXZlbG9waW5nX2lPU184X0FwcHNfV2l0aF9Td2lmdA==" title="https://github.com/x140yu/Developing_iOS_8_Apps_With_Swift">Stanford 公开课，Developing iOS 8 Apps with Swift 字幕翻译文件<i class="fa fa-external-link"></i></span></li></ul><hr><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzNkZ2VuL2NwcHdhc20tYm9vaw==" title="https://github.com/3dgen/cppwasm-book">C/C++面向WebAssembly编程<i class="fa fa-external-link"></i></span></li></ul><hr><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2MjEzNzY4Mzkv" title="https://www.bilibili.com/video/av21376839/">视频地址<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzFjNy9jcmFzaC1jb3Vyc2UtY29tcHV0ZXItc2NpZW5jZS1jaGluZXNl" title="https://github.com/1c7/crash-course-computer-science-chinese">Github地址<i class="fa fa-external-link"></i></span></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL0VaTGlwcGkvcHJhY3RpY2FsLXByb2dyYW1taW5nLWJvb2tz&quot; title=&quot;https://github.com/EZLippi/practical-programming-books&quot;&gt;文章来源&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里收录比较实用的计算机相关技术书籍，可以在短期之内入门的简单实用教程、一些技术网站以及一些写的比较好的博文，欢迎Fork，你也可以通过Pull Request参与编辑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5lemxpcHBpLmNvbS9ibG9nLzIwMTQvMDcvcXVhbGlmaWVkLXByb2dyYW1tZXItc2hvdWxkLXJlYWQtd2hhdC1ib29rcy5odG1s&quot; title=&quot;http://www.ezlippi.com/blog/2014/07/qualified-programmer-should-read-what-books.html&quot;&gt;程序员必读书籍&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机相关技术资料整理" scheme="http://miaopei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
    
      <category term="计算机相关技术资料整理" scheme="http://miaopei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>VIM 编程相关的常用快捷键</title>
    <link href="http://miaopei.github.io/2018/03/23/vimProgramHotKey/"/>
    <id>http://miaopei.github.io/2018/03/23/vimProgramHotKey/</id>
    <published>2018-03-23T08:53:46.000Z</published>
    <updated>2019-06-18T03:35:40.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoeHVhbi92aW1wbHVz" title="https://github.com/chxuan/vimplus">vimplus github<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="插件相关"><a href="#插件相关" class="headerlink" title="插件相关"></a>插件相关</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>,</code></td><td>Leader Key</td></tr><tr><td><code>&lt;leader&gt;n</code></td><td>打开/关闭代码资源管理器</td></tr><tr><td><code>&lt;leader&gt;t</code></td><td>打开/关闭函数列表</td></tr><tr><td><code>&lt;leader&gt;a</code></td><td>.h .cpp 文件切换</td></tr><tr><td><code>&lt;leader&gt;u</code></td><td>转到函数声明</td></tr><tr><td><code>&lt;leader&gt;U</code></td><td>转到函数实现</td></tr><tr><td><code>&lt;leader&gt;o</code></td><td>打开include文件</td></tr><tr><td><code>&lt;leader&gt;y</code></td><td>拷贝函数声明</td></tr><tr><td><code>&lt;leader&gt;p</code></td><td>生成函数实现</td></tr><tr><td><code>&lt;leader&gt;w</code></td><td>单词跳转</td></tr><tr><td><code>&lt;leader&gt;f</code></td><td>搜索~目录下的文件</td></tr><tr><td><code>&lt;leader&gt;F</code></td><td>搜索当前目录下的文本</td></tr><tr><td><code>&lt;leader&gt;g</code></td><td>显示git仓库提交记录</td></tr><tr><td><code>&lt;leader&gt;G</code></td><td>显示当前文件提交记录</td></tr><tr><td><code>&lt;leader&gt;gg</code></td><td>显示当前文件在某个commit下的完整内容</td></tr><tr><td><code>&lt;leader&gt;ff</code></td><td>语法错误自动修复(FixIt)</td></tr><tr><td><code>&lt;c-p&gt;</code></td><td>切换到上一个buffer</td></tr><tr><td><code>&lt;c-n&gt;</code></td><td>切换到下一个buffer</td></tr><tr><td><code>&lt;leader&gt;d</code></td><td>删除当前buffer</td></tr><tr><td><code>&lt;leader&gt;D</code></td><td>删除当前buffer外的所有buffer</td></tr><tr><td><code>Ya</code></td><td>复制行文本到字母a</td></tr><tr><td><code>Da</code></td><td>剪切行文本到字母a</td></tr><tr><td><code>Ca</code></td><td>改写行文本到字母a</td></tr><tr><td><code>rr</code></td><td>替换文本</td></tr><tr><td><code>&lt;leader&gt;r</code></td><td>全局替换，目前只支持单个文件</td></tr><tr><td><code>gcc</code></td><td>注释代码</td></tr><tr><td><code>gcap</code></td><td>注释段落</td></tr><tr><td><code>vif</code></td><td>选中函数内容</td></tr><tr><td><code>dif</code></td><td>删除函数内容</td></tr><tr><td><code>cif</code></td><td>改写函数内容</td></tr><tr><td><code>vaf</code></td><td>选中函数内容（包括函数名 花括号）</td></tr><tr><td><code>daf</code></td><td>删除函数内容（包括函数名 花括号）</td></tr><tr><td><code>caf</code></td><td>改写函数内容（包括函数名 花括号）</td></tr><tr><td><code>fa</code></td><td>查找字母a，然后再按f键查找下一个</td></tr></tbody></table><h2 id="折叠代码"><a href="#折叠代码" class="headerlink" title="折叠代码"></a>折叠代码</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>za</code></td><td>打开或关闭当前折叠</td></tr><tr><td><code>zM</code></td><td>关闭所有折叠</td></tr><tr><td><code>zR</code></td><td>打开所有折叠</td></tr></tbody></table><h2 id="声明-定义跳转"><a href="#声明-定义跳转" class="headerlink" title="声明/定义跳转"></a>声明/定义跳转</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>g]</code></td><td>声明/定义跳转</td></tr></tbody></table><h2 id="缓存操作"><a href="#缓存操作" class="headerlink" title="缓存操作"></a>缓存操作</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>:e &lt;filename&gt;</code></td><td>新建buffer打开文件</td></tr><tr><td><code>:bp</code></td><td>切换到上一个buffer</td></tr><tr><td><code>:bn</code></td><td>切换到下一个buffer</td></tr><tr><td><code>:bd</code></td><td>删除当前buffer</td></tr></tbody></table><h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>:sp &lt;filename&gt;</code></td><td>横向切分窗口并打开文件</td></tr><tr><td><code>:vsp &lt;filename&gt;</code></td><td>竖向切分窗口并打开文件</td></tr><tr><td><code>&lt;c-w&gt;h</code></td><td>跳到左边的窗口</td></tr><tr><td><code>&lt;c-w&gt;j</code></td><td>跳到下边的窗口</td></tr><tr><td><code>&lt;c-w&gt;k</code></td><td>跳到上边的窗口</td></tr><tr><td><code>&lt;c-w&gt;l</code></td><td>跳到右边的窗口</td></tr><tr><td><code>&lt;c-w&gt;c</code></td><td>关闭当前窗口</td></tr><tr><td><code>&lt;c-w&gt;o</code></td><td>关闭其他窗口</td></tr><tr><td><code>:only</code></td><td>关闭其他窗口</td></tr></tbody></table><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>h</code></td><td>上下左右移动</td></tr><tr><td><code>j</code></td><td>上下左右移动</td></tr><tr><td><code>k</code></td><td>上下左右移动</td></tr><tr><td><code>l</code></td><td>上下左右移动</td></tr><tr><td><code>0</code></td><td>光标移动到行首</td></tr><tr><td><code>^</code></td><td>跳到从行首开始第一个非空白字符</td></tr><tr><td><code>$</code></td><td>光标移动到行尾</td></tr><tr><td><code>&lt;c-o&gt;</code></td><td>跳到上一个位置</td></tr><tr><td><code>&lt;c-i&gt;</code></td><td>跳到下一个位置</td></tr><tr><td><code>&lt;c-b&gt;</code></td><td>上一页</td></tr><tr><td><code>&lt;c-f&gt;</code></td><td>下一页</td></tr><tr><td><code>&lt;c-u&gt;</code></td><td>上移半屏</td></tr><tr><td><code>&lt;c-d&gt;</code></td><td>下移半屏</td></tr><tr><td><code>H</code></td><td>调到屏幕顶上</td></tr><tr><td><code>M</code></td><td>调到屏幕中间</td></tr><tr><td><code>L</code></td><td>调到屏幕下方</td></tr><tr><td><code>:n</code></td><td>跳到第n行</td></tr><tr><td><code>w</code></td><td>跳到下一个单词开头(标点或空格分隔的单词)</td></tr><tr><td><code>W</code></td><td>跳到下一个单词开头(空格分隔的单词)</td></tr><tr><td><code>e</code></td><td>跳到下一个单词尾部(标点或空格分隔的单词)</td></tr><tr><td><code>E</code></td><td>跳到下一个单词尾部(空格分隔的单词)</td></tr><tr><td><code>b</code></td><td>上一个单词头(标点或空格分隔的单词)</td></tr><tr><td><code>B</code></td><td>上一个单词头(空格分隔的单词)</td></tr><tr><td><code>ge</code></td><td>上一个单词尾</td></tr><tr><td><code>%</code></td><td>在配对符间移动, 可用于()、{}、[]</td></tr><tr><td><code>gg</code></td><td>到文件首</td></tr><tr><td><code>G</code></td><td>到文件尾</td></tr><tr><td><code>fx</code></td><td>跳转到下一个为x的字符</td></tr><tr><td><code>Fx</code></td><td>跳转到上一个为x的字符</td></tr><tr><td><code>tx</code></td><td>跳转到下一个为x的字符前</td></tr><tr><td><code>Tx</code></td><td>跳转到上一个为x的字符前</td></tr><tr><td><code>;</code></td><td>跳到下一个搜索的结果</td></tr><tr><td><code>[[</code></td><td>跳转到函数开头</td></tr><tr><td><code>]]</code></td><td>跳转到函数结尾</td></tr></tbody></table><h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>r</code></td><td>替换当前字符</td></tr><tr><td><code>R</code></td><td>进入替换模式，直至 ESC 离开</td></tr><tr><td><code>s</code></td><td>替换字符（删除光标处字符，并进入插入模式，前可接数量）</td></tr><tr><td><code>S</code></td><td>替换行（删除当前行，并进入插入模式，前可接数量）</td></tr><tr><td><code>cc</code></td><td>改写当前行（删除当前行并进入插入模式），同 S</td></tr><tr><td><code>cw</code></td><td>改写光标开始处的当前单词</td></tr><tr><td><code>ciw</code></td><td>改写光标所处的单词</td></tr><tr><td><code>caw</code></td><td>改写光标所处的单词，并且包括前后空格（如果有的话）</td></tr><tr><td><code>ct,</code></td><td>改写到逗号</td></tr><tr><td><code>c0</code></td><td>改写到行首</td></tr><tr><td><code>c^</code></td><td>改写到行首（第一个非零字符）</td></tr><tr><td><code>c$</code></td><td>改写到行末</td></tr><tr><td><code>C</code></td><td>改写到行末（同 c$）</td></tr><tr><td><code>ci&quot;</code></td><td>改写双引号中的内容</td></tr><tr><td><code>ci&#39;</code></td><td>改写单引号中的内容</td></tr><tr><td><code>ci)</code></td><td>改写小括号中的内容</td></tr><tr><td><code>ci]</code></td><td>改写中括号中内容</td></tr><tr><td><code>ci}</code></td><td>改写大括号中内容</td></tr><tr><td><code>cit</code></td><td>改写 xml tag 中的内容</td></tr><tr><td><code>cis</code></td><td>改写当前句子</td></tr><tr><td><code>ciB</code></td><td>改写’{}’中的内容</td></tr><tr><td><code>c2w</code></td><td>改写下两个单词</td></tr><tr><td><code>ct(</code></td><td>改写到小括号前</td></tr><tr><td><code>x</code></td><td>删除当前字符，前面可以接数字，3x代表删除三个字符</td></tr><tr><td><code>X</code></td><td>向前删除字符</td></tr><tr><td><code>dd</code></td><td>删除当前行</td></tr><tr><td><code>d0</code></td><td>删除到行首</td></tr><tr><td><code>d^</code></td><td>删除到行首（第一个非零字符）</td></tr><tr><td><code>d$</code></td><td>删除到行末</td></tr><tr><td><code>D</code></td><td>删除到行末（同 d$）</td></tr><tr><td><code>dw</code></td><td>删除当前单词</td></tr><tr><td><code>dt,</code></td><td>删除到逗号</td></tr><tr><td><code>diw</code></td><td>删除光标所处的单词</td></tr><tr><td><code>daw</code></td><td>删除光标所处的单词，并包含前后空格（如果有的话）</td></tr><tr><td><code>di&quot;</code></td><td>删除双引号中的内容</td></tr><tr><td><code>di&#39;</code></td><td>删除单引号中的内容</td></tr><tr><td><code>di)</code></td><td>删除小括号中的内容</td></tr><tr><td><code>di]</code></td><td>删除中括号中内容</td></tr><tr><td><code>di}</code></td><td>删除大括号中内容</td></tr><tr><td><code>diB</code></td><td>删除’{}’中的内容</td></tr><tr><td><code>dit</code></td><td>删除 xml tag 中的内容</td></tr><tr><td><code>dis</code></td><td>删除当前句子</td></tr><tr><td><code>d2w</code></td><td>删除下两个单词</td></tr><tr><td><code>dt(</code></td><td>删除到小括号前</td></tr><tr><td><code>dgg</code></td><td>删除到文件头部</td></tr><tr><td><code>dG</code></td><td>删除到文件尾部</td></tr><tr><td><code>d}</code></td><td>删除下一段</td></tr><tr><td><code>d{</code></td><td>删除上一段</td></tr><tr><td><code>u</code></td><td>撤销</td></tr><tr><td><code>U</code></td><td>撤销整行操作</td></tr><tr><td><code>CTRL-R</code></td><td>撤销上一次 u 命令</td></tr><tr><td><code>J</code></td><td>连接若干行</td></tr><tr><td><code>gJ</code></td><td>连接若干行，删除空白字符</td></tr><tr><td><code>.</code></td><td>重复上一次操作</td></tr><tr><td><code>~</code></td><td>交换大小写</td></tr><tr><td><code>g~iw</code></td><td>替换当前单词的大小写</td></tr><tr><td><code>gUiw</code></td><td>将单词转成大写</td></tr><tr><td><code>guiw</code></td><td>将当前单词转成小写</td></tr><tr><td><code>guu</code></td><td>全行转为小写</td></tr><tr><td><code>gUU</code></td><td>全行转为大写</td></tr><tr><td><code>gg=G</code></td><td>缩进整个文件</td></tr><tr><td><code>=a{</code></td><td>缩进光标所在代码块</td></tr><tr><td><code>=i{</code></td><td>缩进光标所在代码块，不缩进”{“</td></tr><tr><td><code>&lt;&lt;</code></td><td>减少缩进</td></tr><tr><td><code>&gt;&gt;</code></td><td>增加缩进</td></tr><tr><td><code>==</code></td><td>自动缩进</td></tr><tr><td><code>CTRL-A</code></td><td>增加数字</td></tr><tr><td><code>CTRL-X</code></td><td>减少数字</td></tr><tr><td><code>p</code></td><td>粘贴到光标后</td></tr><tr><td><code>P</code></td><td>粘贴到光标前</td></tr><tr><td><code>v</code></td><td>开始标记</td></tr><tr><td><code>y</code></td><td>复制标记内容</td></tr><tr><td><code>V</code></td><td>开始按行标记</td></tr><tr><td><code>CTRL-V</code></td><td>开始列标记</td></tr><tr><td><code>y$</code></td><td>复制当前位置到本行结束的内容</td></tr><tr><td><code>yy</code></td><td>复制当前行</td></tr><tr><td><code>Y</code></td><td>复制当前行，同 yy</td></tr><tr><td><code>yt,</code></td><td>复制到逗号</td></tr><tr><td><code>yiw</code></td><td>复制当前单词</td></tr><tr><td><code>3yy</code></td><td>复制光标下三行内容</td></tr><tr><td><code>v0</code></td><td>选中当前位置到行首</td></tr><tr><td><code>v$</code></td><td>选中当前位置到行末</td></tr><tr><td><code>vt,</code></td><td>选中到逗号</td></tr><tr><td><code>viw</code></td><td>选中当前单词</td></tr><tr><td><code>vi)</code></td><td>选中小括号内的东西</td></tr><tr><td><code>vi]</code></td><td>选中中括号内的东西</td></tr><tr><td><code>viB</code></td><td>选中’{}’中的内容</td></tr><tr><td><code>vis</code></td><td>选中句子中的东西</td></tr><tr><td><code>gv</code></td><td>重新选择上一次选中的文字</td></tr><tr><td><code>:set paste</code></td><td>允许粘贴模式（避免粘贴时自动缩进影响格式）</td></tr><tr><td><code>:set nopaste</code></td><td>禁止粘贴模式</td></tr><tr><td><code>&quot;?yy</code></td><td>复制当前行到寄存器 ? ，问号代表 0-9 的寄存器名称</td></tr><tr><td><code>&quot;?p</code></td><td>将寄存器 ? 的内容粘贴到光标后</td></tr><tr><td><code>&quot;?P</code></td><td>将寄存器 ? 的内容粘贴到光标前</td></tr><tr><td><code>:registers</code></td><td>显示所有寄存器内容</td></tr><tr><td><code>:[range]y</code></td><td>复制范围，比如 :20,30y 是复制20到30行，:10y 是复制第十行</td></tr><tr><td><code>:[range]d</code></td><td>删除范围，比如 :20,30d 是删除20到30行，:10d 是删除第十行</td></tr><tr><td><code>ddp</code></td><td>交换两行内容：先删除当前行复制到寄存器，并粘贴</td></tr></tbody></table><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>:e &lt;filename&gt;</code></td><td>打开文件并编辑</td></tr><tr><td><code>:saveas &lt;filename&gt;</code></td><td>另存为文件</td></tr><tr><td><code>:close</code></td><td>关闭文件</td></tr><tr><td><code>:wa</code></td><td>保存所有文件</td></tr><tr><td><code>:new</code></td><td>打开一个新的窗口编辑新文件</td></tr><tr><td><code>:enew</code></td><td>在当前窗口创建新文件</td></tr><tr><td><code>:vnew</code></td><td>在左右切分的新窗口中编辑新文件</td></tr><tr><td><code>:tabnew</code></td><td>在新的标签页中编辑新文件</td></tr></tbody></table><h2 id="使用外部程序"><a href="#使用外部程序" class="headerlink" title="使用外部程序"></a>使用外部程序</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>!</code></td><td>告诉vim正在执行一个过滤操作</td></tr><tr><td><code>!5Gsort&lt;Enter&gt;</code></td><td>使用外部sort命令对1-5行文本排序</td></tr><tr><td><code>!!</code></td><td>对当前行执行过滤命令</td></tr><tr><td><code>!!date&lt;Enter&gt;</code></td><td>用”date”的输出代替当前行</td></tr></tbody></table><h2 id="宏录制"><a href="#宏录制" class="headerlink" title="宏录制"></a>宏录制</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>qa</code></td><td>开始录制名字为a的宏</td></tr><tr><td><code>q</code></td><td>结束录制宏</td></tr><tr><td><code>@a</code></td><td>播放名字为a的宏</td></tr><tr><td><code>100@a</code></td><td>播放名字为a的宏100次</td></tr><tr><td><code>:normal@a</code></td><td>播放名字为a的宏直到自动结束</td></tr></tbody></table><h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>/pattern</code></td><td>从光标处向文件尾搜索 pattern</td></tr><tr><td><code>?pattern</code></td><td>从光标处向文件头搜索 pattern</td></tr><tr><td><code>n</code></td><td>向同一方向执行上一次搜索</td></tr><tr><td><code>N</code></td><td>向相反方向执行上一次搜索</td></tr><tr><td><code>*</code></td><td>向前搜索光标下的单词</td></tr><tr><td><code>#</code></td><td>向后搜索光标下的单词</td></tr><tr><td><code>:s/p1/p2/g</code></td><td>替换当前行的p1为p2</td></tr><tr><td><code>:%s/p1/p2/g</code></td><td>替换当前文件中的p1为p2</td></tr><tr><td><code>:%s/&lt;p1&gt;/p2/g</code></td><td>替换当前文件中的p1单词为p2</td></tr><tr><td><code>:%s/p1/p2/gc</code></td><td>替换当前文件中的p1为p2，并且每处询问你是否替换</td></tr><tr><td><code>:10,20s/p1/p2/g</code></td><td>将第10到20行中所有p1替换为p2</td></tr><tr><td><code>:%s/1\\2\/3/123/g</code></td><td>将“1\2/3” 替换为 “123”（特殊字符使用反斜杠标注）</td></tr><tr><td><code>:%s/\r//g</code></td><td>删除 DOS 换行符 ^M</td></tr><tr><td><code>:g/^\s*$/d</code></td><td>删除空行</td></tr><tr><td><code>:g/test/d</code></td><td>删除所有包含 test 的行</td></tr><tr><td><code>:v/test/d</code></td><td>删除所有不包含 test 的行</td></tr><tr><td><code>:%s/^/test/</code></td><td>在行首加入特定字符(也可以用宏录制来添加)</td></tr><tr><td><code>:%s/$/test/</code></td><td>在行尾加入特定字符(也可以用宏录制来添加)</td></tr><tr><td><code>:sort</code></td><td>排序</td></tr><tr><td><code>:g/^\(.\+\)$\n\1/d</code></td><td>去除重复行(先排序)</td></tr><tr><td><code>:%s/^.\{10\}//</code></td><td>删除每行前10个字符</td></tr><tr><td><code>:%s/.\{10\}$//</code></td><td>删除每行尾10个字符</td></tr></tbody></table><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>h tutor</code></td><td>入门文档</td></tr><tr><td><code>h quickref</code></td><td>快速帮助</td></tr><tr><td><code>h index</code></td><td>查询Vim所有键盘命令定义</td></tr><tr><td><code>h summary</code></td><td>帮助你更好的使用内置帮助系统</td></tr><tr><td><code>h pattern.txt</code></td><td>正则表达式帮助</td></tr><tr><td><code>h eval</code></td><td>脚本编写帮助</td></tr><tr><td><code>h function-list</code></td><td>查看VimScript的函数列表</td></tr><tr><td><code>h windows.txt</code></td><td>窗口使用帮助</td></tr><tr><td><code>h tabpage.txt</code></td><td>标签页使用帮助</td></tr><tr><td><code>h tips</code></td><td>查看Vim内置的常用技巧文档</td></tr><tr><td><code>h quote</code></td><td>寄存器</td></tr><tr><td><code>h autocommand-events</code></td><td>所有可能事件</td></tr><tr><td><code>h write-plugin</code></td><td>编写插件</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>vim -u NONE -N</code></td><td>开启vim时不加载vimrc文件</td></tr><tr><td><code>vimdiff file1 file2</code></td><td>显示文件差异</td></tr><tr><td><code>&lt;leader&gt;e</code></td><td>快速编辑vimrc文件</td></tr><tr><td><code>&lt;leader&gt;s</code></td><td>重新加载vimrc文件</td></tr><tr><td><code>&lt;leader&gt;h</code></td><td>打开vimplus帮助文档</td></tr><tr><td><code>&lt;leader&gt;H</code></td><td>打开当前光标所在单词的vim帮助文档</td></tr><tr><td><code>&lt;leader&gt;&lt;leader&gt;i</code></td><td>安装插件</td></tr><tr><td><code>&lt;leader&gt;&lt;leader&gt;u</code></td><td>更新插件</td></tr><tr><td><code>&lt;leader&gt;&lt;leader&gt;c</code></td><td>删除插件</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2NoeHVhbi92aW1wbHVz&quot; title=&quot;https://github.com/chxuan/vimplus&quot;&gt;vimpl
      
    
    </summary>
    
      <category term="Vim" scheme="http://miaopei.github.io/categories/Vim/"/>
    
    
      <category term="vim" scheme="http://miaopei.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Vim 快捷键</title>
    <link href="http://miaopei.github.io/2018/03/20/vimHotKey/"/>
    <id>http://miaopei.github.io/2018/03/20/vimHotKey/</id>
    <published>2018-03-20T08:53:46.000Z</published>
    <updated>2019-06-17T11:05:43.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoeHVhbi92aW1wbHVz" title="https://github.com/chxuan/vimplus">vimplus github<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamlxaW5nd3UvYXJjaGl2ZS8yMDEyLzA2LzE0L3ZpbV9ub3Rlcy5odG1s" title="https://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html">Vim使用笔记<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucm9iaW5qaW4uY29tL3RlY2gvP3A9NjA1" title="https://www.robinjin.com/tech/?p=605">利用ctags+cscope+taglist+nerdree+srcexpl+trinity 将 VIM 变成 source insight<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-文档操作"><a href="#1-文档操作" class="headerlink" title="1. 文档操作"></a>1. 文档操作</h2><ul><li><code>:e</code> – 重新加载当前文档。</li><li><code>:e!</code> – 重新加载当前文档，并丢弃已做的改动。</li><li><code>:e file</code> – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。</li><li><code>:e! file</code> – 放弃对当前文件的修改，编辑新的文件。</li><li><code>:e# 或 ctrl+^</code> – 回到刚才编辑的文件，很实用。</li><li><code>gf</code> – 打开以光标所在字符串为文件名的文件。</li><li><code>:saveas newfilename</code> – 另存为</li></ul><a id="more"></a><h2 id="2-光标的移动"><a href="#2-光标的移动" class="headerlink" title="2. 光标的移动"></a>2. 光标的移动</h2><ul><li><code>gj</code> : 移动到一段内的下一行；</li><li><code>gk</code> : 移动到一段内的上一行；</li><li><code>w</code> : 前移一个单词，光标停在下一个单词开头；</li><li><code>b</code> : 后移一个单词，光标停在上一个单词开头；</li><li><code>(</code> : 前移1句。</li><li><code>)</code> : 后移1句。</li><li><code>{</code> : 前移1段。</li><li><code>}</code> : 后移1段。</li><li><code>fc</code> : 把光标移到同一行的下一个 c 字符处</li><li><code>Fc</code> : 把光标移到同一行的上一个 c 字符处</li><li><code>tc</code> : 把光标移到同一行的下一个 c 字符前</li><li><code>Tc</code> : 把光标移到同一行的上一个 c 字符后</li><li><code>;</code> : 配合 <code>f &amp; t</code> 使用，重复一次</li><li><code>,</code> : 配合 <code>f &amp; t</code> 使用，反向重复一次</li></ul><p>上面的操作都可以配合 n 使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动 3 个字符。</p><ul><li><code>0</code> : 移动到行首。</li><li><code>g0</code> : 移到光标所在屏幕行行首。</li><li><code>^</code> : 移动到本行第一个非空白字符。</li><li><code>g^</code>: 同 <code>^</code> ，但是移动到当前屏幕行第一个非空字符处。</li><li><code>$</code> : 移动到行尾。</li><li><code>g$</code> : 移动光标所在屏幕行行尾。</li><li><code>n|</code> : 把光标移到递 n 列上。</li><li><code>nG</code> : 到文件第 n 行。</li><li><code>:n&lt;cr&gt;</code> : 移动到第 n 行。</li><li><code>:$&lt;cr&gt;</code> : 移动到最后一行。</li><li><code>H</code> : 把光标移到屏幕最顶端一行。</li><li><code>M</code> : 把光标移到屏幕中间一行。</li><li><code>L</code> : 把光标移到屏幕最底端一行。</li><li><code>gg</code> : 到文件头部。</li><li><code>G</code> : 到文件尾部。</li></ul><h3 id="2-1-翻屏"><a href="#2-1-翻屏" class="headerlink" title="2.1 翻屏"></a>2.1 翻屏</h3><ul><li><code>ctrl+f</code> : 下翻一屏。</li><li><code>ctrl+b</code> : 上翻一屏。</li><li><code>ctrl+d</code> : 下翻半屏。</li><li><code>ctrl+u</code> : 上翻半屏。</li><li><code>ctrl+e</code> : 向下滚动一行。</li><li><code>ctrl+y</code> : 向上滚动一行。</li><li><code>n%</code> : 到文件 <code>n%</code> 的位置。</li><li><code>zz</code> : 将当前行移动到屏幕中央。</li><li><code>zt</code> : 将当前行移动到屏幕顶端。</li><li><code>zb</code> : 将当前行移动到屏幕底端。</li></ul><h3 id="2-2-标记"><a href="#2-2-标记" class="headerlink" title="2.2 标记"></a>2.2 标记</h3><p>使用标记可以快速移动。到达标记后，可以用 <code>Ctrl+o</code> 返回原来的位置。 <code>Ctrl+o</code> 和 <code>Ctrl+i</code> 很像浏览器上的 <em>后退</em> 和 <em>前进</em> 。</p><ul><li><code>m{a-z}</code> : 标记光标所在位置，局部标记，只用于当前文件。</li><li><code>m{A-Z}</code> : 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li><li>``{a-z}` : 移动到标记位置。</li><li><code>&#39;{a-z}</code> : 移动到标记行的行首。</li><li>``{0-9}` ：回到上[2-10]次关闭vim时最后离开的位置。</li><li>``: 移动到上次编辑的位置。’’ 也可以，不过``精确到列，而 ‘’ 精确到行 。如果想跳转到更老的位置，可以按 C-o，跳转到更新的位置用 C-i。</li><li>`” : 移动到上次离开的地方。</li><li>`. : 移动到最后改动的地方。</li><li><code>:marks</code> – 显示所有标记。</li><li><code>:delmarks a b</code> – 删除标记 a 和 b。</li><li><code>:delmarks a-c</code> – 删除标记 a、b 和 c。</li><li><code>:delmarks a c-f</code> – 删除标记 a、c、d、e、f。</li><li><code>:delmarks!</code> – 删除当前缓冲区的所有标记。</li><li><code>:help mark-motions</code>  – 查看更多关于 mark 的知识。</li></ul><h2 id="3-插入文本"><a href="#3-插入文本" class="headerlink" title="3. 插入文本"></a>3. 插入文本</h2><h3 id="3-1-基本插入"><a href="#3-1-基本插入" class="headerlink" title="3.1 基本插入"></a>3.1 基本插入</h3><ul><li><code>i</code> : 在光标前插入；一个小技巧：按 8，再按 <code>i</code>，进入插入模式，输入 <code>=</code>， 按 <code>esc</code> 进入命令模式，就会出现 8 个 <code>=</code> 。 这在插入分割线时非常有用，如<code>30i+&lt;esc&gt;</code> 就插入了 36 个 <code>+</code> 组成的分割线。</li><li><code>:r filename</code> : 在当前位置插入另一个文件的内容。</li><li><code>:r !date</code> :  在光标处插入当前日期与时间。同理，<code>:r !command</code> 可以将其它 shell 命令的输出插入当前文档。</li></ul><h3 id="3-2-改写插入"><a href="#3-2-改写插入" class="headerlink" title="3.2 改写插入"></a>3.2 改写插入</h3><ul><li><code>c[n]w</code> : 改写光标后 1(n) 个词。</li><li><code>c[n]l</code> : 改写光标后 n 个字母。</li><li><code>c[n]h</code> : 改写光标前 n 个字母。</li><li><code>[n]cc</code> : 修改当前 [n] 行。</li><li><code>[n]s</code> : 以输入的文本替代光标之后 1(n) 个字符，相当于 <code>c[n]l</code>。</li><li><code>[n]S</code> : 删除指定数目的行，并以所输入文本代替之。</li></ul><p>注意，类似 <code>cnw,dnw,ynw</code> 的形式同样可以写为 <code>ncw,ndw,nyw</code>。</p><h2 id="4-剪切复制和寄存器"><a href="#4-剪切复制和寄存器" class="headerlink" title="4. 剪切复制和寄存器"></a>4. 剪切复制和寄存器</h2><h3 id="4-1-剪切和复制、粘贴"><a href="#4-1-剪切和复制、粘贴" class="headerlink" title="4.1 剪切和复制、粘贴"></a>4.1 剪切和复制、粘贴</h3><ul><li><code>[n]x</code> : 剪切光标右边 n 个字符，相当于 <code>d[n]l</code>。</li><li><code>[n]X</code> : 剪切光标左边 n 个字符，相当于 <code>d[n]h</code>。</li><li><code>y</code> : 复制在可视模式下选中的文本。</li><li><code>yy or Y</code> : 复制整行文本。</li><li><code>y[n]w</code> : 复制一 (n) 个词。</li><li><code>y[n]l</code> : 复制光标右边 1(n) 个字符。</li><li><code>y[n]h</code> : 复制光标左边 1(n) 个字符。</li><li><code>y$</code> : 从光标当前位置复制到行尾。</li><li><code>y0</code> : 从光标当前位置复制到行首。</li><li><code>:m,ny&lt;cr&gt;</code> : 复制 m 行到 n 行的内容。</li><li><code>y1G 或 ygg</code> : 复制光标以上的所有行。</li><li><code>yG</code> : 复制光标以下的所有行。</li><li><code>yaw 和 yas</code>：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</li><li><code>d</code> : 删除（剪切）在可视模式下选中的文本。</li><li><code>d$ or D</code> : 删除（剪切）当前位置到行尾的内容。</li><li><code>d[n]w</code>: 删除（剪切）1(n)个单词</li><li><code>d[n]l</code>: 删除（剪切）光标右边 1(n) 个字符。</li><li><code>d[n]h</code>: 删除（剪切）光标左边 1(n) 个字符。</li><li><code>d0</code>: 删除（剪切）当前位置到行首的内容</li><li><code>[n] dd</code>: 删除（剪切）1(n) 行。</li><li><code>:m,nd&lt;cr&gt;</code> : 剪切 m 行到 n 行的内容。</li><li><code>d1G 或 dgg</code> : 剪切光标以上的所有行。</li><li><code>dG</code> : 剪切光标以下的所有行。</li><li><code>daw 和 das</code>：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li><li><code>d/f&lt;cr&gt;</code>：这是一个比较高级的组合命令，它将删除当前位置 到下一个 f 之间的内容。</li><li><code>p</code>: 在光标之后粘贴。</li><li><code>P</code> : 在光标之前粘贴。</li></ul><h3 id="4-2-文本对象"><a href="#4-2-文本对象" class="headerlink" title="4.2 文本对象"></a>4.2 文本对象</h3><ul><li><code>aw</code>：一个词</li><li><code>as</code>：一句。</li><li><code>ap</code>：一段。</li><li><code>ab</code>：一块（包含在圆括号中的）。</li></ul><p><code>y, d, c, v</code> 都可以跟文本对象。</p><h3 id="4-3-寄存器"><a href="#4-3-寄存器" class="headerlink" title="4.3 寄存器"></a>4.3 寄存器</h3><ul><li><code>a-z</code>：都可以用作寄存器名。<code>&quot;ayy</code> 把当前行的内容放入 a 寄存器。</li><li><code>A-Z</code>：用大写字母索引寄存器，可以在寄存器中追加内容。 如 <code>&quot;Ayy</code> 把当前行的内容追加到 a 寄存器中。</li><li><code>:reg</code> : 显示所有寄存器的内容。</li><li><code>&quot;&quot;</code>：不加寄存器索引时，默认使用的寄存器。</li><li><code>&quot;*</code>：当前选择缓冲区，<code>&quot;*yy</code> 把当前行的内容放入当前选择缓冲区。</li><li><code>&quot;+</code>：系统剪贴板。<code>&quot;+yy</code> 把当前行的内容放入系统剪贴板。</li></ul><h2 id="5-查找与替换"><a href="#5-查找与替换" class="headerlink" title="5. 查找与替换"></a>5. 查找与替换</h2><h3 id="5-1-查找"><a href="#5-1-查找" class="headerlink" title="5.1 查找"></a>5.1 查找</h3><ul><li><code>/something</code> : 在后面的文本中查找 something。</li><li><code>?something</code> : 在前面的文本中查找 something。</li><li><code>/pattern/+number</code> : 将光标停在包含 pattern 的行后面第 number 行上。</li><li><code>/pattern/-number</code> : 将光标停在包含 pattern 的行前面第 number 行上。</li><li><code>n</code> : 向后查找下一个。</li><li><code>N</code> : 向前查找下一个。</li></ul><p>可以用 grep 或 vimgrep 查找一个模式都在哪些地方出现过，其中 <code>:grep</code> 是调用外部的 grep 程序，而 <code>:vimgrep</code> 是 vim 自己的查找算法。</p><p>用法为： <code>:vim[grep]/pattern/[g] [j] files</code></p><ul><li><p><code>g</code> 的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p></li><li><p><code>j</code> 的含义是 grep 结束后，结果停在第 j 项，默认是停在第一项。</p></li></ul><p>vimgrep 前面可以加数字限定搜索结果的上限，如 <code>:1vim/pattern/ %</code> 只查找那个模式在本文件中的第一个出现。</p><p>其实 vimgrep 在读纯文本电子书时特别有用，可以生成导航的目录。</p><p>比如电子书中每一节的标题形式为：<code>n. xxxx</code>。你就可以这样：<code>:vim/^d{1,}./ %</code> 然后用 <code>:cw</code> 或 <code>:copen</code> 查看结果，可以用 <code>C-w H</code> 把 quickfix 窗口移到左侧，就更像个目录了。</p><h3 id="5-2-替换"><a href="#5-2-替换" class="headerlink" title="5.2 替换"></a>5.2 替换</h3><ul><li><code>:s/old/new</code> – 用 new 替换当前行第一个 old。</li><li><code>:s/old/new/g</code> – 用 new 替换当前行所有的 old。</li><li><code>:n1,n2s/old/new/g</code> – 用 new 替换文件 n1 行到 n2 行所有的 old。</li><li><code>:%s/old/new/g</code> – 用 new 替换文件中所有的 old。</li><li><code>:%s/^/xxx/g</code> – 在每一行的行首插入 xxx，<code>^</code> 表示行首。</li><li><code>:%s/$/xxx/g</code> – 在每一行的行尾插入 xxx，<code>$</code> 表示行尾。</li><li>所有替换命令末尾加上 c，每个替换都将需要用户确认。 如：<code>%s/old/new/gc</code>，加上i则忽略大小写(ignore)。</li></ul><p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p><p>语法为 <code>:[range]g/pattern/command</code></p><p>例如 <code>: %g/^ xyz/normal dd</code>。</p><p>表示对于以一个空格和 xyz 开头的行执行 normal 模式下的 dd 命令。</p><p>关于 range 的规定为：</p><ul><li>如果不指定 range，则表示当前行。</li><li><code>m,n</code> : 从 m 行到 n 行。</li><li><code>0</code> : 最开始一行（可能是这样）。</li><li><code>$</code> : 最后一行</li><li><code>.</code> : 当前行</li><li><code>%</code> : 所有行</li></ul><h3 id="5-3-正则表达式"><a href="#5-3-正则表达式" class="headerlink" title="5.3 正则表达式"></a>5.3 正则表达式</h3><p>高级的查找替换就要用到正则表达式。</p><ul><li><code>\d</code> : 表示十进制数（我猜的）</li><li><code>\s</code> : 表示空格</li><li><code>\S</code> : 非空字符</li><li><code>\a</code> : 英文字母</li><li><code>\|</code> : 表示 或</li><li><code>\.</code> : 表示.</li><li><code>{m,n}</code> : 表示 m 到 n 个字符。这要和 <code>\s</code> 与 <code>\a</code> 等连用，如 <code>\a\{m,n}</code> 表示 m 到 n 个英文字母。</li><li><code>{m,}</code>: 表示 m 到无限多个字符。</li><li><code>**</code>: 当前目录下的所有子目录。</li></ul><p><code>:help pattern</code> 得到更多帮助。</p><h2 id="6-编辑多个文件"><a href="#6-编辑多个文件" class="headerlink" title="6. 编辑多个文件"></a>6. 编辑多个文件</h2><h3 id="6-1-一次编辑多个文件"><a href="#6-1-一次编辑多个文件" class="headerlink" title="6.1 一次编辑多个文件"></a>6.1 一次编辑多个文件</h3><p>我们可以一次打开多个文件，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi a.txt b.txt c.txt</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>:next(:n)</code> 编辑下一个文件。</li><li><code>:2n</code> 编辑下 2 个文件。</li><li>使用 <code>:previous或:N</code> 编辑上一个文件。</li><li>使用 <code>:wnext</code>，保存当前文件，并编辑下一个文件。</li><li>使用 <code>:wprevious</code>，保存当前文件，并编辑上一个文件。</li><li>使用 <code>:args</code> 显示文件列表。</li><li><code>:n filenames 或 :args filenames</code> 指定新的文件列表。</li><li><code>vi -o filenames</code> 在水平分割的多个窗口中编辑多个文件。</li><li><code>vi -O filenames</code> 在垂直分割的多个窗口中编辑多个文件。</li></ul><h3 id="6-2-多标签编辑"><a href="#6-2-多标签编辑" class="headerlink" title="6.2 多标签编辑"></a>6.2 多标签编辑</h3><ul><li><code>vim -p files</code> : 打开多个文件，每个文件占用一个标签页。</li><li><code>:tabe, tabnew</code> – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li><li><code>^w gf</code> – 在新的标签页里打开光标下路径指定的文件。</li><li><code>:tabn</code> – 切换到下一个标签。<code>Control + PageDown</code>，也可以。</li><li><code>:tabp</code> – 切换到上一个标签。<code>Control + PageUp</code>，也可以。</li><li><code>[n] gt</code> – 切换到下一个标签。如果前面加了 n ， 就切换到第 n 个标签。第一个标签的序号就是 1。</li><li><code>:tab split</code> – 将当前缓冲区的内容在新页签中打开。</li><li><code>:tabc[lose]</code> – 关闭当前的标签页。</li><li><code>:tabo[nly]</code> – 关闭其它的标签页。</li><li><code>:tabs</code> – 列出所有的标签页和它们包含的窗口。</li><li><code>:tabm[ove] [N]</code> – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li></ul><h3 id="6-3-缓冲区"><a href="#6-3-缓冲区" class="headerlink" title="6.3 缓冲区"></a>6.3 缓冲区</h3><ul><li><code>:buffers 或 :ls 或 :files</code> 显示缓冲区列表。</li><li><code>ctrl+^</code>：在最近两个缓冲区间切换。</li><li><code>:bn</code> – 下一个缓冲区。</li><li><code>:bp</code> – 上一个缓冲区。</li><li><code>:bl</code> – 最后一个缓冲区。</li><li><code>:b[n] 或 :[n]b</code> – 切换到第 n 个缓冲区。</li><li><code>:nbw(ipeout)</code> – 彻底删除第 n 个缓冲区。</li><li><code>:nbd(elete)</code> – 删除第 n 个缓冲区，并未真正删除，还在 unlisted 列表中。</li><li><code>:ba[ll]</code> – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li></ul><h2 id="7-分屏编辑"><a href="#7-分屏编辑" class="headerlink" title="7. 分屏编辑"></a>7. 分屏编辑</h2><ul><li><code>vim -o file1 file2</code> : 水平分割窗口，同时打开 file1 和 file2</li><li><code>vim -O file1 file2</code> : 垂直分割窗口，同时打开 file1 和 file2</li></ul><h3 id="7-1-水平分割"><a href="#7-1-水平分割" class="headerlink" title="7.1 水平分割"></a>7.1 水平分割</h3><ul><li><code>:split(:sp)</code> – 把当前窗水平分割成两个窗口。(<code>CTRL-W s</code> 或 <code>CTRL-W CTRL-S</code>) 注意如果在终端下，<code>CTRL-S</code> 可能会冻结终端，请按 <code>CTRL-Q</code> 继续。</li><li><code>:split filename</code> – 水平分割窗口，并在新窗口中显示另一个文件。</li><li><code>:nsplit(:nsp)</code> – 水平分割出一个 n 行高的窗口。</li><li><code>:[N]new</code> – 水平分割出一个N行高的窗口，并编辑一个新文件。 ( <code>CTRL-W n</code> 或  <code>CTRL-W CTRL-N</code>)</li><li><code>ctrl+w f</code> –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li><li><code>C-w C-^</code> – 水平分割一个窗口，打开刚才编辑的文件。</li></ul><h3 id="7-2-垂直分割"><a href="#7-2-垂直分割" class="headerlink" title="7.2 垂直分割"></a>7.2 垂直分割</h3><ul><li><code>:vsplit(:vsp)</code> – 把当前窗口分割成水平分布的两个窗口。 (<code>CTRL-W v</code> 或 <code>CTRL CTRL-V</code>)</li><li><code>:[N]vne[w]</code> – 垂直分割出一个新窗口。</li><li><code>:vertical 水平分割的命令</code>： 相应的垂直分割。</li></ul><h3 id="7-3-关闭子窗口"><a href="#7-3-关闭子窗口" class="headerlink" title="7.3 关闭子窗口"></a>7.3 关闭子窗口</h3><ul><li><code>:qall</code> – 关闭所有窗口，退出 vim。</li><li><code>:wall</code> – 保存所有修改过的窗口。</li><li><code>:only</code> – 只保留当前窗口，关闭其它窗口。(<code>CTRL-W o</code>)</li><li><code>:close</code> – 关闭当前窗口，<code>CTRL-W c</code>能实现同样的功能。 (象 <code>:q :x</code> 同样工作 )</li></ul><h3 id="7-4-调整窗口大小"><a href="#7-4-调整窗口大小" class="headerlink" title="7.4 调整窗口大小"></a>7.4 调整窗口大小</h3><ul><li><code>ctrl+w +</code> –当前窗口增高一行。也可以用 n 增高 n 行。</li><li><code>ctrl+w -</code> –当前窗口减小一行。也可以用 n 减小 n 行。</li><li><code>ctrl+w _</code> –当前窗口扩展到尽可能的大。也可以用 n 设定行数。</li><li><code>:resize n</code> – 当前窗口 n 行高。</li><li><code>ctrl+w =</code> – 所有窗口同样高度。</li><li><code>n ctrl+w _</code> – 当前窗口的高度设定为 n 行。</li><li><code>ctrl+w &lt;</code> –当前窗口减少一列。也可以用 n 减少 n 列。</li><li><code>ctrl+w &gt;</code> –当前窗口增宽一列。也可以用 n 增宽 n 列。</li><li><code>ctrl+w |</code> –当前窗口尽可能的宽。也可以用 n 设定列数。</li></ul><h3 id="7-5-切换和移动窗口"><a href="#7-5-切换和移动窗口" class="headerlink" title="7.5 切换和移动窗口"></a>7.5 切换和移动窗口</h3><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p><ul><li><code>ctrl+w ctrl+w</code> : 切换到下一个窗口。或者是 <code>ctrl+w w</code>。</li><li><code>ctrl+w p</code> : 切换到前一个窗口。</li><li><code>ctrl+w h(l,j,k)</code> :切换到左（右，下，上）的窗口。</li><li><code>ctrl+w t(b)</code> :切换到最上（下）面的窗口。</li><li><code>ctrl+w H(L,K,J)</code> : 将当前窗口移动到最左（右、上、下）面。</li><li><code>ctrl+w r</code>：旋转窗口的位置。</li><li><code>ctrl+w T</code> : 将当前的窗口移动到新的标签页上。</li></ul><h2 id="8-快速编辑"><a href="#8-快速编辑" class="headerlink" title="8. 快速编辑"></a>8. 快速编辑</h2><h3 id="8-1-改变大小写"><a href="#8-1-改变大小写" class="headerlink" title="8.1 改变大小写"></a>8.1 改变大小写</h3><ul><li><code>~</code> : 反转光标所在字符的大小写。</li><li>可视模式下的 U 或 u：把选中的文本变为大写或小写。</li><li><code>gu(U)</code> 接范围（如<code>$</code>，或 <code>G</code>），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如<code>ggguG</code>，就是把开头到最后一行之间的字母全部变为小 写。再如 <code>gu5j</code>，把当前行和下面四行全部变成小写。</li></ul><h3 id="8-2-替换（normal模式）"><a href="#8-2-替换（normal模式）" class="headerlink" title="8.2 替换（normal模式）"></a>8.2 替换（normal模式）</h3><ul><li><code>r</code> : 替换光标处的字符，同样支持汉字。</li><li><code>R</code> : 进入替换模式，按 <code>esc</code> 回到正常模式。</li></ul><h3 id="8-3-撤消与重做（normal模式）"><a href="#8-3-撤消与重做（normal模式）" class="headerlink" title="8.3 撤消与重做（normal模式）"></a>8.3 撤消与重做（normal模式）</h3><ul><li><code>[n] u</code> : 取消一(n)个改动。</li><li><code>:undo 5</code> – 撤销 5 个改变。</li><li><code>:undolist</code> – 你的撤销历史。</li><li><code>ctrl + r</code> : 重做最后的改动。</li><li><code>U</code> : 取消当前行中所有的改动。</li><li><code>:earlier 4m</code> – 回到 4 分钟前</li><li><code>:later 55s</code> – 前进 55 秒</li></ul><h3 id="8-4-宏"><a href="#8-4-宏" class="headerlink" title="8.4 宏"></a>8.4 宏</h3><ul><li><code>.</code> –重复上一个编辑动作</li><li><code>qa</code>：开始录制宏 a（键盘操作记录）</li><li><code>q</code>：停止录制</li><li><code>@a</code>：播放宏 a</li></ul><h2 id="9-编辑特殊文件"><a href="#9-编辑特殊文件" class="headerlink" title="9. 编辑特殊文件"></a>9. 编辑特殊文件</h2><h3 id="9-1-文件加解密"><a href="#9-1-文件加解密" class="headerlink" title="9.1 文件加解密"></a>9.1 文件加解密</h3><ul><li><code>vim -x file</code> : 开始编辑一个加密的文件。</li><li><code>:X</code> – 为当前文件设置密码。</li><li><code>:set key=</code> – 去除文件的密码。</li></ul><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hZG1pbi92aW0tcXVpY2stZWRpdC5odG1s" title="http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html">这里是<i class="fa fa-external-link"></i></span> 滇狐总结的比较高级的 vi 技巧。</p><h3 id="9-2-文件的编码"><a href="#9-2-文件的编码" class="headerlink" title="9.2 文件的编码"></a>9.2 文件的编码</h3><ul><li><code>:e ++enc=utf8 filename</code>, 让 vim 用 utf-8 的编码打开这个文件。</li><li><code>:w ++enc=gbk</code>，不管当前文件什么编码，把它转存成 gbk 编码。</li><li><code>:set fenc 或 :set fileencoding</code>，查看当前文件的编码。</li><li>在 vimrc 中添加 <code>set fileencoding=ucs-bom,utf-8,cp936</code>，vim 会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936 对应于 gbk 编码。 ucs-bom 对应于 windows 下的文件格式。</li></ul><p>让 vim 正确处理文件格式和文件编码，有赖于 <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hZG1pbi92aW1yYy5odG1s" title="http://www.cnblogs.com/jiqingwu/admin/vimrc.html">~/.vimrc的正确配置<i class="fa fa-external-link"></i></span></p><h3 id="9-3-文件格式"><a href="#9-3-文件格式" class="headerlink" title="9.3 文件格式"></a>9.3 文件格式</h3><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p><ul><li><code>:e ++ff=dos filename</code>, 让 vim 用 dos 格式打开这个文件。</li><li><code>:w ++ff=mac filename</code>, 以 mac 格式存储这个文件。</li><li><code>:set ff</code>，显示当前文件的格式。</li><li>在 vimrc 中添加 <code>set fileformats=unix,dos,mac</code>，让 vim 自动识别文件格式。</li></ul><h2 id="10-编程辅助"><a href="#10-编程辅助" class="headerlink" title="10. 编程辅助"></a>10. 编程辅助</h2><h3 id="10-1-一些按键"><a href="#10-1-一些按键" class="headerlink" title="10.1 一些按键"></a>10.1 一些按键</h3><ul><li><code>gd</code> : 跳转到局部变量的定义处；</li><li><code>gD</code> : 跳转到全局变量的定义处，从当前文件开头开始搜索；</li><li><code>g;</code> : 上一个修改过的地方；</li><li><code>g,</code> : 下一个修改过的地方；</li><li><code>[[</code> : 跳转到上一个函数块开始，需要有单独一行的 {。</li><li><code>]]</code> : 跳转到下一个函数块开始，需要有单独一行的 {。</li><li><code>[]</code> : 跳转到上一个函数块结束，需要有单独一行的 }。</li><li><code>][</code> : 跳转到下一个函数块结束，需要有单独一行的 }。</li><li><code>[{</code> : 跳转到当前块开始处；</li><li><code>]}</code> : 跳转到当前块结束处；</li><li><code>[/</code> : 跳转到当前注释块开始处；</li><li><code>]/</code> : 跳转到当前注释块结束处；</li><li><code>%</code> : 不仅能移动到匹配的 <code>(),{} 或 []</code>上，而且能在 <code>#if，#else， #endif</code> 之间跳跃。</li></ul><p>下面的括号匹配对编程很实用的。</p><ul><li><code>ci&#39;, di&#39;, yi&#39;</code>：修改、剪切或复制 <code>&#39;</code> 之间的内容。</li><li><code>ca&#39;, da&#39;, ya&#39;</code>：修改、剪切或复制 <code>&#39;</code> 之间的内容，包含 <code>&#39;</code>。</li><li><code>ci&quot;, di&quot;, yi&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容。</li><li><code>ca&quot;, da&quot;, ya&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容，包含 <code>&quot;</code>。</li><li><code>ci(, di(, yi(</code>：修改、剪切或复制 <code>()</code>之间的内容。</li><li><code>ca(, da(, ya(</code>：修改、剪切或复制 <code>()</code> 之间的内容，包含 <code>()</code>。</li><li><code>ci[, di[, yi[</code>：修改、剪切或复制 <code>[]</code> 之间的内容。</li><li><code>ca[, da[, ya[</code>：修改、剪切或复制 <code>[]</code>之间的内容，包含 <code>[]</code>。</li><li><code>ci{, di{, yi{</code>：修改、剪切或复制 <code>{}</code> 之间的内容。</li><li><code>ca{, da{, ya{</code>：修改、剪切或复制 <code>{}</code> 之间的内容，包含 <code>{}</code>。</li><li><code>ci&lt;, di&lt;, yi&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容。</li><li><code>ca&lt;, da&lt;, ya&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容，包含<code>&lt;&gt;</code>。</li></ul><h3 id="10-2-ctags"><a href="#10-2-ctags" class="headerlink" title="10.2 ctags"></a>10.2 ctags</h3><table><thead><tr><th align="left"><code>Ctrl + ]</code></th><th>找到光标所在位置的标签定义的地方</th></tr></thead><tbody><tr><td align="left"><code>Ctrl + t</code></td><td>回到跳转之前的标签处</td></tr><tr><td align="left"><code>Ctrl + o</code></td><td>退回原来的地方</td></tr><tr><td align="left"><code>[I</code></td><td>查找全局标识符. Vim会列出它所找出的匹配行，<br>不仅在当前文件内查找，还会在所有的包含文件中查找</td></tr><tr><td align="left"><code>[i</code></td><td>从当前文件起始位置开始查找第一处包含光标所指关键字的位置</td></tr><tr><td align="left"><code>]i</code></td><td>类似上面的 <code>[i</code>，但这里是从光标当前位置开始往下搜索</td></tr><tr><td align="left"><code>[{</code></td><td>转到上一个位于第一列的”{“。（前提是 “{” 和 “}” 都在第一列。）</td></tr><tr><td align="left"><code>]}</code></td><td>转到下一个位于第一列的”}”</td></tr><tr><td align="left"><code>Ctrl+＼+ s</code></td><td>会出现所有调用、定义该函数的地方，输入索引号，回车即可</td></tr><tr><td align="left"><code>[ + ctrl + i</code></td><td>跳转到函数、变量和 <code>#define</code>   用 <code>ctrl+o</code> 返回</td></tr><tr><td align="left"><code>[ + ctrl + d</code></td><td>跳转到 <code>#define</code> 处用 <code>ctrl+o</code> 返回</td></tr></tbody></table><ul><li><code>ctags -R</code> : 生成 tag 文件，<code>-R</code> 表示也为子目录中的文件生成 tags</li><li><code>:set tags=path/tags</code> – 告诉 ctags 使用哪个 tag 文件</li><li><code>:tag xyz</code> – 跳到 xyz 的定义处，或者将光标放在 xyz 上按 <code>C-]</code>，返回用 <code>C-t</code></li><li><code>:stag xyz</code> – 用分割的窗口显示 xyz 的定义，或者 <code>C-w ]</code>， 如果用 <code>C-w n ]</code>，就会打开一个 n 行高的窗口</li><li><code>:ptag xyz</code> – 在预览窗口中打开 xyz 的定义，热键是 <code>C-w }</code>。</li><li><code>:pclose</code> – 关闭预览窗口。热键是 <code>C-w z</code>。</li><li><code>:pedit abc.h</code> – 在预览窗口中编辑 abc.h</li><li><code>:psearch abc</code> – 搜索当前文件和当前文件 include 的文件，显示包含 abc 的行。</li></ul><p>有时一个 tag 可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p><ul><li><code>:[n]tnext</code> – 下一 <code>[n]</code> 个匹配。</li><li><code>:[n]tprev</code> – 上一 <code>[n]</code>个匹配。</li><li><code>:tfirst</code> – 第一个匹配</li><li><code>:tlast</code> – 最后一个匹配</li><li><code>:tselect tagname</code> – 打开选择列表</li></ul><p>tab 键补齐</p><ul><li><code>:tag xyz&lt;tab&gt;</code> – 补齐以 xyz 开头的 tag 名，继续按 tab 键，会显示其他的。</li><li><code>:tag /xyz&lt;tab&gt;</code> – 会用名字中含有 xyz 的 tag 名补全。</li></ul><p><strong>ctags 对 c++ 生成 tags</strong> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q</span><br></pre></td></tr></table></figure><p>每个参数解释如下：</p><ul><li><p><code>-R</code> : ctags 循环生成子目录的 tags</p></li><li><p><code>--c++-kinds=+px</code> : ctags 记录 c++ 文件中的函数声明和各种外部和前向声明</p></li><li><p><code>--fields=+iaS</code> : ctags 要求描述的信息</p><ul><li>其中 <code>i</code> 表示如果有继承，则标识出父类；</li><li><code>a</code> 表示如果元素是类成员的话，要标明其调用权限（即是 public 还是 private）；</li><li><code>S</code> 表示如果是函数，则标识函数的 signature。</li></ul></li><li><p><code>--extra=+q</code> : 强制要求 ctags 做如下操作—如果某个语法元素是类的一个成员，ctags 默认会给其记录一行，可以要求 ctags 对同一个语法元斯屹记一行，这样可以保证在 VIM 中多个同名函数可以通过路径不同来区分。</p></li></ul><h3 id="10-3-cscope"><a href="#10-3-cscope" class="headerlink" title="10.3 cscope"></a>10.3 cscope</h3><p>查看阅读 c++ 代码</p><p>cscope 缺省只解析 C 文件 (<code>.c</code> 和 <code>.h</code>)、lex 文件( <code>.l</code> )和 yacc 文件( <code>.y</code> )，虽然它也可以支持 C++ 以及 Java，但它在扫描目录时会跳过 C++ 及  Java 后缀的文件。如果希望 <code>cscope</code> 解析 C++ 或 Java 文件，需要把这些文件的名字和路径保存在一个名为 cscope.files 的文件。当 cscope 发现在当前目录中存在 cscope.files 时，就会为 cscope.files 中列出的所有文件生成索引数据库。</p><p>下面的命令会查找当前目录及子目录中所有后缀名为 <code>&quot;.h&quot;, &quot;.c&quot;, &quot;cc&quot;</code> 和 <code>&quot;.cpp&quot;</code> 的文件，并把查找结果重定向到文件 cscope.files 中。然后 cscope 根据 cscope.files 中的所有文件，生成符号索引文件。最后一条命令使用 ctags 命令，生成一个 tags 文件，在 vim 中执行 <code>&quot;:help tags&quot;</code> 命令查询它的用法。它可以和 cscope 一起使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"*.h"</span> -o -name <span class="string">"*.c"</span> -o -name <span class="string">"*.cc"</span> -o <span class="string">"*.cpp"</span> &gt; cscope.files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cscope -bkq -i cscope.files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ctags -R</span></span><br></pre></td></tr></table></figure><ul><li><code>cscope -Rbq</code> : 生成 cscope.out 文件</li><li><code>:cs add /path/to/cscope.out /your/work/dir</code></li><li><code>:cs find c func</code> – 查找 func 在哪些地方被调用<ul><li>s: 查找 C 语言符号，即查找函数名、宏、枚举值等出现的地方</li><li>g: 查找函数、宏、枚举等定义的位置，类似 ctags 所提供的功能</li><li>d: 查找本函数调用的函数</li><li>c: 查找调用本函数的函数</li><li>t: 查找指定的字符串</li><li>e: 查找 egrep 模式，相当于 egrep 功能，但查找速度快多了</li><li>f: 查找并打开文件，类似 vim 的 find 功能</li><li>i: 查找包含本文件的文件</li></ul></li><li><code>:cw</code> – 打开 quickfix 窗口查看结果</li></ul><h3 id="10-4-gtags"><a href="#10-4-gtags" class="headerlink" title="10.4 gtags"></a>10.4 gtags</h3><p>Gtags 综合了 ctags 和 cscope 的功能。 使用 Gtags 之前，你需要安装 GNU Gtags。 然后在工程目录运行 gtags 。</p><ul><li><code>:Gtags funcname</code> 定位到 funcname 的定义处。</li><li><code>:Gtags -r funcname</code> 查询 funcname被引用的地方。</li><li><code>:Gtags -s symbol</code> 定位 symbol 出现的地方。</li><li><code>:Gtags -g string</code> Goto string 出现的地方。 <code>:Gtags -gi string</code> 忽略大小写。</li><li><code>:Gtags -f filename</code> 显示 filename 中的函数列表。 你可以用 <code>:Gtags -f %</code> 显示当前文件。</li><li><code>:Gtags -P pattern</code> 显示路径中包含特定模式的文件。 如 <code>:Gtags -P .h$</code> 显示所有头文件， <code>:Gtags -P /vm/</code> 显示 vm 目录下的文件。</li></ul><h3 id="10-5-编译"><a href="#10-5-编译" class="headerlink" title="10.5 编译"></a>10.5 编译</h3><p>vim 提供了 <code>:make</code> 来编译程序，默认调用的是 make， 如果你当前目录下有 makefile，简单地 <code>:make</code> 即可。</p><p>如果你没有 make 程序，你可以通过配置 makeprg 选项来更改 make 调用的程序。 如果你只有一个 abc.java 文件，你可以这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set makeprg=javac\ abc.java</span><br></pre></td></tr></table></figure><p>然后 <code>:make</code> 即可。如果程序有错，可以通过 quickfix 窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让 vim 识别错误信息。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure><p><code>%f</code> 表示文件名，<code>%l</code> 表示行号， <code>%m</code> 表示错误信息，其它的还不能理解。 请参考 <code>:help errorformat</code>。</p><h3 id="10-6-快速修改窗口"><a href="#10-6-快速修改窗口" class="headerlink" title="10.6 快速修改窗口"></a>10.6 快速修改窗口</h3><p>其实是 quickfix 插件提供的功能， 对编译调试程序非常有用 </p><ul><li><code>:copen</code> – 打开快速修改窗口。</li><li><code>:cclose</code> – 关闭快速修改窗口。</li></ul><p>快速修改窗口在 make 程序时非常有用，当 make 之后：</p><ul><li><code>:cl</code> – 在快速修改窗口中列出错误。</li><li><code>:cn</code> – 定位到下一个错误。</li><li><code>:cp</code> – 定位到上一个错误。</li><li><code>:cr</code> – 定位到第一个错误。</li></ul><h3 id="10-7-自动补全"><a href="#10-7-自动补全" class="headerlink" title="10.7 自动补全"></a>10.7 自动补全</h3><ul><li><code>C-x C-s</code> – 拼写建议。</li><li><code>C-x C-v</code> – 补全 vim 选项和命令。</li><li><code>C-x C-l</code> – 整行补全。</li><li><code>C-x C-f</code> – 自动补全文件路径。弹出菜单后，按 <code>C-f</code> 循环选择，当然也可以按 <code>C-n 和 C-p</code>。</li><li><code>C-x C-p 和C-x C-n</code> – 用文档中出现过的单词补全当前的词。 直接按 <code>C-p 和 C-n</code>也可以。</li><li><code>C-x C-o</code> – 编程时可以补全关键字和函数名啊。</li><li><code>C-x C-i</code> – 根据头文件内关键字补全。</li><li><code>C-x C-d</code> – 补全宏定义。</li><li><code>C-x C-n</code> – 按缓冲区中出现过的关键字补全。 直接按 <code>C-n 或 C-p</code> 即可。</li></ul><p>当弹出补全菜单后：</p><ul><li><code>C-p</code> 向前切换成员；</li><li><code>C-n</code> 向后切换成员；</li><li><code>C-e</code> 退出下拉菜单，并退回到原来录入的文字；</li><li><code>C-y</code> 退出下拉菜单，并接受当前选项。</li></ul><h3 id="10-8-多行缩进缩出"><a href="#10-8-多行缩进缩出" class="headerlink" title="10.8 多行缩进缩出"></a>10.8 多行缩进缩出</h3><ul><li>正常模式下，按两下 <code>&gt;;</code> 光标所在行会缩进。</li><li>如果先按了 n，再按两下 <code>&gt;;</code>，光标以下的 n 行会缩进。</li><li>对应的，按两下 <code>&lt;;</code>，光标所在行会缩出。</li><li>如果在编辑代码文件，可以用 <code>=</code> 进行调整。</li><li>在可视模式下，选择要调整的代码块，按 <code>=</code>，代码会按书写规则缩排好。</li><li>或者 <code>n =</code>，调整 n 行代码的缩排。</li></ul><h3 id="10-9-折叠"><a href="#10-9-折叠" class="headerlink" title="10.9 折叠"></a>10.9 折叠</h3><ul><li><code>zf</code> – 创建折叠的命令，可以在一个可视区域上使用该命令；</li><li><code>zd</code> – 删除当前行的折叠；</li><li><code>zD</code> – 删除当前行的折叠；</li><li><code>zfap</code> – 折叠光标所在的段；</li><li><code>zo</code> – 打开折叠的文本；</li><li><code>zc</code> – 收起折叠；</li><li><code>za</code> – 打开/关闭当前折叠；</li><li><code>zr</code> – 打开嵌套的折行；</li><li><code>zm</code> – 收起嵌套的折行；</li><li><code>zR (zO)</code> – 打开所有折行；</li><li><code>zM (zC)</code> – 收起所有折行；</li><li><code>zj</code> – 跳到下一个折叠处；</li><li><code>zk</code> – 跳到上一个折叠处；</li><li><code>zi -- enable/disable fold</code>;</li></ul><h3 id="10-10-zshrc配置脚本"><a href="#10-10-zshrc配置脚本" class="headerlink" title="10.10 zshrc配置脚本"></a>10.10 zshrc配置脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi ~/.zshrc</span></span><br><span class="line">ctags_fun()</span><br><span class="line">&#123;</span><br><span class="line">    ctags -R</span><br><span class="line">    cscope -Rbqk</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line">alias mctags=ctags_fun  # define mctags</span><br><span class="line"></span><br><span class="line">ctags_cplus_fun()</span><br><span class="line">&#123;</span><br><span class="line">    find . -name "*.h" -o -name "*.c" -o -name "*.cc" -o -name "*.cpp" &gt; cscope.files</span><br><span class="line">    cscope -bkq -i cscope.files</span><br><span class="line">    ctags -R --c++-kinds=+p --fields=+iaS --extra=+q</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line">alias cplusctags=ctags_cplus_fun  # define mctags</span><br></pre></td></tr></table></figure><h2 id="11-其它"><a href="#11-其它" class="headerlink" title="11. 其它"></a>11. 其它</h2><h3 id="11-1-工作目录"><a href="#11-1-工作目录" class="headerlink" title="11.1 工作目录"></a>11.1 工作目录</h3><ul><li><code>:pwd</code> 显示vim的工作目录。</li><li><code>:cd path</code> 改变 vim 的工作目录。</li><li><code>:set autochdir</code>  可以让 vim 根据编辑的文件自动切换工作目录。</li></ul><h3 id="11-2-一些快捷键（收集中）"><a href="#11-2-一些快捷键（收集中）" class="headerlink" title="11.2 一些快捷键（收集中）"></a>11.2 一些快捷键（收集中）</h3><ul><li><code>K</code> : 打开光标所在词的 manpage。</li><li><code>*</code> : 向下搜索光标所在词。</li><li><code>g*</code> : 同上，但部分符合即可。</li><li><code>\#</code> : 向上搜索光标所在词。</li><li><code>g#</code> : 同上，但部分符合即可。</li><li><code>g C-g</code> : 统计全文或统计部分的字数。</li></ul><h3 id="11-3-在线帮助"><a href="#11-3-在线帮助" class="headerlink" title="11.3 在线帮助"></a>11.3 在线帮助</h3><ul><li><code>:h(elp) 或 F1</code> 打开总的帮助。</li><li><code>:help user-manual</code> 打开用户手册。</li><li>命令帮助的格式为<code>：</code>第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li><li><code>:helptags somepath</code> 为 somepath 中的文档生成索引。</li><li><code>:helpgrep</code> 可以搜索整个帮助文档，匹配的列表显示在 quickfix 窗口中。</li><li><code>Ctrl+]</code> 跳转到 tag 主题，<code>Ctrl+t</code> 跳回。</li><li><code>:ver</code> 显示版本信息。</li></ul><p>高亮所有搜索模式匹配</p><ul><li><p><code>shift + *</code> 向后搜索光标所在位置的单词</p></li><li><p><code>shift + #</code> 向前搜索光标所在位置的单词</p></li><li><p>n 和 N 可以继续向后或者向前搜索匹配的字符串</p></li><li><p><code>:set hlsearch</code>  高亮所有匹配的字符串</p></li><li><p><code>:nohlsearch</code> 临时关闭</p></li><li><p><code>:set nohlsearch</code> 彻底关闭，只有重新 <code>:set hlsearch</code> 才可以高亮搜索</p></li><li><p>vim 高亮显示光标所在的单词，在单词的地方输入 <code>gd</code></p></li></ul><p>语法高亮</p><ul><li><p>syntax on</p></li><li><p>syntax off</p></li></ul><p>vim自动补全</p><ul><li><code>ctrl + n</code> 或者 <code>ctrl + p</code></li></ul><p>复制 vim 文件中所有内容</p><ul><li><p><code>gg</code> 回到文件首</p></li><li><p><code>shift + v</code> 进入 VISUAL LINE 模式</p></li><li><p><code>shift + g</code>  全选所有内容</p></li><li><p><code>ctrl + insert</code> 复制所选的内容</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2NoeHVhbi92aW1wbHVz&quot; title=&quot;https://github.com/chxuan/vimplus&quot;&gt;vimplus github&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamlxaW5nd3UvYXJjaGl2ZS8yMDEyLzA2LzE0L3ZpbV9ub3Rlcy5odG1s&quot; title=&quot;https://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html&quot;&gt;Vim使用笔记&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cucm9iaW5qaW4uY29tL3RlY2gvP3A9NjA1&quot; title=&quot;https://www.robinjin.com/tech/?p=605&quot;&gt;利用ctags+cscope+taglist+nerdree+srcexpl+trinity 将 VIM 变成 source insight&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-文档操作&quot;&gt;&lt;a href=&quot;#1-文档操作&quot; class=&quot;headerlink&quot; title=&quot;1. 文档操作&quot;&gt;&lt;/a&gt;1. 文档操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:e&lt;/code&gt; – 重新加载当前文档。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e!&lt;/code&gt; – 重新加载当前文档，并丢弃已做的改动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e file&lt;/code&gt; – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e! file&lt;/code&gt; – 放弃对当前文件的修改，编辑新的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e# 或 ctrl+^&lt;/code&gt; – 回到刚才编辑的文件，很实用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gf&lt;/code&gt; – 打开以光标所在字符串为文件名的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:saveas newfilename&lt;/code&gt; – 另存为&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://miaopei.github.io/categories/Vim/"/>
    
    
      <category term="vim" scheme="http://miaopei.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>网络传输基础</title>
    <link href="http://miaopei.github.io/2018/03/16/web-transmission-basis/"/>
    <id>http://miaopei.github.io/2018/03/16/web-transmission-basis/</id>
    <published>2018-03-16T10:02:52.000Z</published>
    <updated>2019-06-14T09:24:46.793Z</updated>
    
    <content type="html"><![CDATA[<p>示例：Web服务器向Http客户端传送数据的过程:</p><p>在详细阐述网络传输过程之前，先来看一个最常见的例子，下图显示了一个网络服务器向客户端传送数据的完整过程：</p><a id="more"></a><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90202/image002.jpg" alt></p><ol><li>需要传送的数据是网络服务器的HTML页面。</li><li>应用协议HTTP报文首部添加到HTML数据之前。报文头信息包括：服务器所使用的HTTP版本（1.0/1.1），以及表明它包含发给网络客户端信息的状态编码（比如200表示Ok）。</li><li>HTTP应用层协议将HTML格式的网页数据发送给传输层，传输层添加TCP首部信息。TCP传输层用于管理网络服务器和客户端之间的会话，TCP是面向连接的，通过拥赛控制、滑动窗口、超时重传等机制保证数据有效的传输给客户端。</li><li>IP首部添加到TCP首部之前。IP层指定适当的源和目的IP地址。这些信息就构成了IP报文（IP Packet）。</li><li>以太网协议首部添加到IP报文的两端之后，就形成了数据链路帧(frame)。上述帧发送至通向网络客户端的路径上的最近一个路由器（默认网关）。每经过一个路由器会移除以太网信息，观察IP报文，判定最佳路径，将报文插入一个新的帧（下一个路由器的MAC地址），并发送至目标路径上下一个相邻路由器。每一个路由器在转发之前都移除并添加新的数据链路层信息。</li><li>数据通过互联网络传输，互联网络包含媒介和中间设备。</li><li>客户端接收到包含数据的数据链路帧，处理各层协议头，之后以与添加时相反的顺序移除协议头。首先处理并移除以太网信息，之后是IP协议信息，接下来TCP信息，最后是HTTP信息。</li><li>之后，将网页信息传递给客户端网页浏览器，浏览器把HTML网页渲染呈现给用户。</li></ol><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装:"></a>数据封装:</h3><p>消息要在网络中传输，必须对它进行编码，以特定的格式进行封装，同时需要适当地封装以足够的控制和地址信息，以使它能够从发送方移动到接收方。</p><p><strong>消息大小</strong></p><p>理论上，视频或邮件信息是能够以大块非中断型流从网络源地址传送到目的地址，但这也意味着同一时刻同一网络其他设备就无法收发消息。这种大型数据流会造成显著延时。并且，如果传输过程中连接断开，整个数据流都会丢失需要全部重传。因此更好的方法是将数据流分割（segmentation）为较小的，便于管理的片段，能够带来两点好处：</p><ul><li>发送较小片段，网络上同时可有多个会话交错进行。这种在网络上将不同会话片段交错进行的过程称为多路传输（multiplexing）。</li><li>分割可提高网络通讯的可靠性。各消息片段从源地址到目的地址无需经过相同路径，如果一条路径被堵塞或断开，其余消息可从替换路径到达目的地址。如果部分消息到不了目的地址，那只需重传丢失部分。</li></ul><p>通过对片段打上标签的方式来保证顺序以及在接收时重组。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90202/image003.jpg" alt></p><p><strong>协议数据单元（Protocol Data Unit, PDU）</strong></p><p>应用层数据在传输过程中沿着协议栈向下传递，每一层协议都会向其中添加首部信息，TCP首部和IP首部都是20字节的长度。这就是封装的过程。<br>数据片段在各层网络结构中采用的形式就称为协议数据单元（PDU）。封装过程中，下一层对从上一层收到的PDU进行封装。在处理的每一个阶段PDU都有不同的名字来反应它的功能。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90203/image004.jpg" alt></p><p>PDU按照TCP/IP协议的命名规范：</p><ul><li>数据（Data）：应用层PDU的常用术语</li><li>分段（Segment）：传输层PDU</li><li>数据报(Packet): 网络成PDU</li><li>以太网帧（Frame）：链路层PDU</li><li>比特（Bits）：在介质上物理传输数据所使用的PDU。</li></ul><p><strong>封装</strong></p><p>封装是指在传输之前为数据添加额外的协议头信息的过程。在绝大多数数据通信过程中，源数据在传输前都会封装以数层协议。在网络上发送消息时，主机上的协议栈从上至下进行操作。</p><p>以网络服务器为例，HTTP应用层协议发送HTML格式网页数据到传输层，应用层数据被分成TCP分段。各TCP分段被打上标签（主要是端口号，HTTP默认端口为80），称为首部（header），表明接收方哪一个进程应当接收此消息。同时也包含使得接收方能够按照原有的格式来重组数据的信息。</p><p>传输层将网页HTML数据封装成分段并发送至网络层，执行IP层协议。整个TCP分段封装成IP报文，也就是再添上IP首部。IP首部包括源和目的IP地址，以及发送报文到目的地址所必须的信息，包括一些控制字段。</p><p>之后，IP报文发送到链路层，封装以帧头和帧尾。每个帧头都包含源和目的物理地址。物理地址唯一指定了本地网络上的设备。帧尾包含差错校正信息。最后，由服务器网卡将比特编码传输给介质。  </p><p><strong>解封装</strong></p><p>接收主机以相反的方式（从下至上）进行操作称为解封装。解封装是接收设备移除一层或多层协议头的过程。数据在协议栈中向上移动直到终端应用层伴随着解封装。</p><h3 id="访问本地资源："><a href="#访问本地资源：" class="headerlink" title="访问本地资源："></a>访问本地资源：</h3><p>访问本地网络资源需要两种类型的地址：网络层地址和数据链路层地址。网络层和数据链路层负责将数据从发送设备传输至接收设备。两层协议都有源和目的地址，但两种地址的目的不同。</p><p>示例：客户端PC1与FTP在同一IP网络的通信</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90204/image005.jpg" alt></p><p><strong>网络地址</strong></p><p>网络层地址或IP地址包含两个部分：网络号和主机号。路由器使用网络前缀部分将报文转发给适当的网络。最后一个路由器使用主机部分将报文发送给目标设备。同一本地网络中，网络前缀部分是相同的，只有主机设备地址部分不同。</p><p>源IP地址：发送设备，即客户端PC1的IP地址：192.168.1.110</p><p>目的IP地址：接收设备，即FTP服务器：192.168.1.9</p><p><strong>数据链路地址</strong></p><p>数据链路地址（MAC）的目的是在<strong>同一网络中</strong>将数据链路帧从一个网络接口发送至另一个网络接口。以太网LAN和无线网LAN是两种不同物理介质的网络示例，分别有自己的数据链路协议。</p><p>当IP报文的发送方和接收方位于同一网络，数据链路帧直接发送到接收设备（通过ARP来获取目的IP的MAC地址）。以太网上数据链路地址就是以太网MAC地址。MAC地址是物理植入网卡的48比特地址。<br>源MAC地址：发送IP报文的PC1以太网卡MAC地址，AA-AA-AA-AA-AA-AA。</p><p>目的MAC地址：当发送设备与接收设备位于同一网络，即为接收设备的数据链路地址。本例中，FTP MAC地址：CC-CC-CC-CC-CC-CC。</p><p>源和目的MAC地址添加到以太网帧中。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90205/image006.jpg" alt></p><p><strong>MAC与IP地址</strong></p><p>发送方必须知道接收方的物理和逻辑地址。发送方主机能够以多种方式学习到接收方的IP地址：比如浏览器缓存、getHostByName系统调用、域名系统（Domain Name System, DNS），或通过应用手动输入，如用户指定FTP地址。</p><p>以太网MAC地址是怎么识别的呢？发送方主机使用地址解析协议（Address Resolution Protocol, ARP）以检测本地网络的所有MAC地址。如下图所示，发送主机在整个LAN发送ARP请求消息，这是一条广播消息。ARP请求包含目标设备的IP地址，LAN上的每一个设备都会检查该ARP请求，看看是否包含它自身的IP地址。只有符合该IP地址的设备才会发送ARP响应。ARP响应包含ARP请求中IP地址相对应的MAC地址。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90206/670-270/image007.jpg" alt></p><p><strong>访问远程资源：</strong></p><p><strong>默认网关</strong></p><p>当主机发送消息到远端网络，必须使用路由器，也称为默认网关。默认网关就是位于发送主机同一网络上的路由器的接口IP地址。有一点很重要：本地网络上的所有主机都能够配置自己的默认网关地址。如果该主机的TCP/IP设置中没有配置默认网关地址，或指定了错误的默认网关地址，则远端网络消息无法被送达。</p><p>如下图所示，LAN上的主机PC 1使用IP地址为192.168.1.1的R1作为默认网关，如果PDU的目的地址位于另一个网络，则主机将PDU发送至路由器上的默认网关。</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90207/image008.jpg" alt></p><p><strong>与远端网络设备通讯</strong></p><p>下图显示了客户端主机PC 1与远端IP网络服务器进行通讯的网络层地址与数据链路层地址：</p><p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90208/image009.jpg" alt></p><p><strong>网络地址</strong></p><p>当报文的发送方与接收方位于不同网络，源和目的IP地址将会代表不同网络上的主机。</p><p>源IP地址：发送设备即客户端主机PC 1的IP地址：192.168.1.110。</p><p>目的IP地址：接收设备即网络服务器的IP地址：172.16.1.99。</p><p><strong>数据链路地址</strong></p><p>当报文的发送方与接收方位于不同网络，以太网数据链路帧无法直接被发送到目的主机。以太网帧必须先发送给路由器或默认网关。本例中，默认网关是R1，R1的接口IP地址与PC 1属于同一网络，因此PC 1能够直接达到路由器。</p><p>源MAC地址：发送设备即PC 1的MAC地址，PC1的以太网接口MAC地址为：AA-AA-AA-AA-AA-AA。</p><p>目的MAC地址：当报文的发送方与接收方位于不同网络，这一值为路由器或默认网关的以太网MAC地址。本例中，即R1的以太网接口MAC地址，即：11-11-11-11-11-11。</p><p>IP报文封装成的以太网帧先被传输至R1，R1再转发给目的地址即网络服务器。R1可以转发给另一个路由器，如果目的服务器所在网路连接至R1，则直接发送给服务器。</p><p>发送设备如何确定路由器的MAC地址？每一个设备通过自己的TCP/IP设置中的默认网关地址得知路由器的IP地址。之后，它通过ARP来得知默认网关的MAC地址，该MAC地址随后添加到帧中。</p>]]></content>
    
    <summary type="html">
    
      理论上，视频或邮件信息是能够以大块非中断型流从网络源地址传送到目的地址，但这也意味着同一时刻同一网络其他设备就无法收发消息。这种大型数据流会造成显著延时。并且，如果传输过程中连接断开，整个数据流都会丢失需要全部重传。因此更好的方法是将数据流分割
    
    </summary>
    
      <category term="other" scheme="http://miaopei.github.io/categories/other/"/>
    
    
      <category term="other" scheme="http://miaopei.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法--图算法介绍</title>
    <link href="http://miaopei.github.io/2018/03/08/graph/"/>
    <id>http://miaopei.github.io/2018/03/08/graph/</id>
    <published>2018-03-08T10:02:52.000Z</published>
    <updated>2019-06-28T01:45:39.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的定义："><a href="#图的定义：" class="headerlink" title="图的定义："></a>图的定义：</h2><p>图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。</p><p>图的种类：地图，电路图，调度图，事物，网络，程序结构</p><p>图的属性：有V个顶点的图最多有V*（V-1）/2条边</p><a id="more"></a><p><img src="/images/imageGraph/graph1.jpg" alt></p><p><img src="/images/imageGraph/graph2.jpg" alt></p><h3 id="邻接矩阵："><a href="#邻接矩阵：" class="headerlink" title="邻接矩阵："></a>邻接矩阵：</h3><p>邻接矩阵是一个元素为bool值的V<em>V矩阵，若图中存在一条连接顶点V和W的边，折矩阵adj[v][w]=1,否则为0。占用的空间为V</em>V，当图是稠密时，邻接矩阵是比较合适的表达方法。</p><p><img src="/images/imageGraph/graph3.jpg" alt></p><h3 id="邻接表的表示"><a href="#邻接表的表示" class="headerlink" title="邻接表的表示"></a>邻接表的表示</h3><p>对于非稠密的图，使用邻接矩阵有点浪费存储空间，可以使用邻接表，我们维护一个链表向量，给定一个顶点时，可以立即访问其链表,占用的空间为O(V+E)。</p><p><img src="/images/imageGraph/graph4.jpg" alt></p><hr><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="深度优先搜索介绍"><a href="#深度优先搜索介绍" class="headerlink" title="深度优先搜索介绍"></a>深度优先搜索介绍</h3><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h3 id="深度优先搜索图解"><a href="#深度优先搜索图解" class="headerlink" title="深度优先搜索图解"></a>深度优先搜索图解</h3><h4 id="无向图的深度优先搜索"><a href="#无向图的深度优先搜索" class="headerlink" title="无向图的深度优先搜索"></a>无向图的深度优先搜索</h4><p>下面以”无向图”为例，来对深度优先搜索进行演示。</p><p><img src="/images/imageGraph/graph5.jpg" alt></p><p>对上面的图G1进行深度优先遍历，从顶点A开始。</p><p><img src="/images/imageGraph/graph6.jpg" alt></p><ul><li><p>第1步：访问A。</p></li><li><p>第2步：访问(A的邻接点)C。</p><p> 在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。 </p></li><li><p>第3步：访问(C的邻接点)B。</p><p> 在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 </p></li><li><p>第4步：访问(C的邻接点)D。</p><p> 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 </p></li><li><p>第5步：访问(A的邻接点)F。</p><p> 前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。 </p></li><li><p>第6步：访问(F的邻接点)G。</p></li><li><p>第7步：访问(G的邻接点)E。</p></li></ul><p>因此访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</p><h4 id="有向图的深度优先搜索"><a href="#有向图的深度优先搜索" class="headerlink" title="有向图的深度优先搜索"></a>有向图的深度优先搜索</h4><p>下面以”有向图”为例，来对深度优先搜索进行演示。</p><p><img src="/images/imageGraph/graph7.jpg" alt></p><p>对上面的图G2进行深度优先遍历，从顶点A开始。</p><p><img src="/images/imageGraph/graph8.jpg" alt></p><ul><li><p>第1步：访问A。</p></li><li><p>第2步：访问B。</p><p> 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 </p></li><li><p>第3步：访问C。</p><p> 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 </p></li><li><p>第4步：访问E。</p><p> 接下来访问C的出边的另一个顶点，即顶点E。 </p></li><li><p>第5步：访问D。</p><p> 接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 </p></li><li><p>第6步：访问F。</p><p> 接下应该回溯”访问A的出边的另一个顶点F”。 </p></li><li><p>第7步：访问G。</p></li></ul><p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</p><hr><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="广度优先搜索介绍"><a href="#广度优先搜索介绍" class="headerlink" title="广度优先搜索介绍"></a>广度优先搜索介绍</h3><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p><h3 id="广度优先搜索图解"><a href="#广度优先搜索图解" class="headerlink" title="广度优先搜索图解"></a>广度优先搜索图解</h3><h4 id="无向图的广度优先搜索"><a href="#无向图的广度优先搜索" class="headerlink" title="无向图的广度优先搜索"></a>无向图的广度优先搜索</h4><p>下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。</p><p><img src="/images/imageGraph/graph9.jpg" alt></p><ul><li><p>第1步：访问A。</p></li><li><p>第2步：依次访问C,D,F。</p><p> 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 </p></li><li><p>第3步：依次访问B,G。</p><p> 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 </p></li><li><p>第4步：访问E。</p><p> 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p></li></ul><p>因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</p><h4 id="有向图的广度优先搜索"><a href="#有向图的广度优先搜索" class="headerlink" title="有向图的广度优先搜索"></a>有向图的广度优先搜索</h4><p>下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。</p><p><img src="/images/imageGraph/graph10.jpg" alt></p><ul><li><p>第1步：访问A。</p></li><li><p>第2步：访问B。</p></li><li><p>第3步：依次访问C,E,F。</p><p>在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 </p></li><li><p>第4步：依次访问D,G。</p><p> 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p></li></ul><p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</p><h2 id="搜索算法的源码"><a href="#搜索算法的源码" class="headerlink" title="搜索算法的源码"></a>搜索算法的源码</h2><details><summary>1. 邻接矩阵表示的"无向图</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* C++: 邻接矩阵表示的"无向图(Matrix Undirected Graph)"</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @author LippiOuYang</span></span><br><span class="line"><span class="comment">* @date 2013/04/19</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MatrixUDG</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> mVexs[MAX];    <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="keyword">int</span> mVexNum;             <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">int</span> mEdgNum;             <span class="comment">// 边数</span></span><br><span class="line">    <span class="keyword">int</span> mMatrix[MAX][MAX];   <span class="comment">// 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建图(自己输入数据)</span></span><br><span class="line">    MatrixUDG();</span><br><span class="line">    <span class="comment">// 创建图(用已提供的矩阵)</span></span><br><span class="line">    MatrixUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen);</span><br><span class="line">    ~MatrixUDG();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索遍历图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 广度优先搜索（类似于树的层次遍历）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 打印矩阵队列图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 读取一个输入字符</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回ch在mMatrix矩阵中的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line">    <span class="comment">// 返回顶点v的第一个邻接顶点的索引，失败则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstVertex</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">    <span class="comment">// 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextVertex</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line">    <span class="comment">// 深度优先搜索遍历图的递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 创建图(自己输入数据)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MatrixUDG::MatrixUDG()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">int</span> i, p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入"顶点数"和"边数"</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input vertex number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mVexNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input edge number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mEdgNum;</span><br><span class="line">    <span class="keyword">if</span> ( mVexNum &lt; <span class="number">1</span> || mEdgNum &lt; <span class="number">1</span> || (mEdgNum &gt; (mVexNum * (mVexNum<span class="number">-1</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"input error: invalid parameters!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"顶点"</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"vertex("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        mVexs[i] = readChar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"边"</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mEdgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"edge("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        c1 = readChar();</span><br><span class="line">        c2 = readChar();</span><br><span class="line"></span><br><span class="line">        p1 = getPosition(c1);</span><br><span class="line">        p2 = getPosition(c2);</span><br><span class="line">        <span class="keyword">if</span> (p1==<span class="number">-1</span> || p2==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"input error: invalid edge!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mMatrix[p1][p2] = <span class="number">1</span>;</span><br><span class="line">        mMatrix[p2][p1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建图(用已提供的矩阵)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     vexs  -- 顶点数组</span></span><br><span class="line"><span class="comment"> *     vlen  -- 顶点数组的长度</span></span><br><span class="line"><span class="comment"> *     edges -- 边数组</span></span><br><span class="line"><span class="comment"> *     elen  -- 边数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MatrixUDG::MatrixUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"顶点数"和"边数"</span></span><br><span class="line">    mVexNum = vlen;</span><br><span class="line">    mEdgNum = elen;</span><br><span class="line">    <span class="comment">// 初始化"顶点"</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        mVexs[i] = vexs[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"边"</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mEdgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">        p1 = getPosition(edges[i][<span class="number">0</span>]);</span><br><span class="line">        p2 = getPosition(edges[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        mMatrix[p1][p2] = <span class="number">1</span>;</span><br><span class="line">        mMatrix[p2][p1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MatrixUDG::~MatrixUDG() </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回ch在mMatrix矩阵中的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> MatrixUDG::getPosition(<span class="keyword">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</span><br><span class="line">        <span class="keyword">if</span>(mVexs[i]==ch)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取一个输入字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> MatrixUDG::readChar()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!((ch&gt;=<span class="string">'a'</span>&amp;&amp;ch&lt;=<span class="string">'z'</span>) || (ch&gt;=<span class="string">'A'</span>&amp;&amp;ch&lt;=<span class="string">'Z'</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回顶点v的第一个邻接顶点的索引，失败则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> MatrixUDG::firstVertex(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (v&lt;<span class="number">0</span> || v&gt;(mVexNum<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        <span class="keyword">if</span> (mMatrix[v][i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> MatrixUDG::nextVertex(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (v&lt;<span class="number">0</span> || v&gt;(mVexNum<span class="number">-1</span>) || w&lt;<span class="number">0</span> || w&gt;(mVexNum<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = w + <span class="number">1</span>; i &lt; mVexNum; i++)</span><br><span class="line">        <span class="keyword">if</span> (mMatrix[v][i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度优先搜索遍历图的递归实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> MatrixUDG::DFS(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    visited[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mVexs[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走</span></span><br><span class="line">    <span class="keyword">for</span> (w = firstVertex(i); w &gt;= <span class="number">0</span>; w = nextVertex(i, w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            DFS(w, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度优先搜索遍历图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> MatrixUDG::DFS()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> visited[MAX];       <span class="comment">// 顶点访问标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有顶点都没有被访问</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++) &#123;</span><br><span class="line">        <span class="comment">//printf("\n== LOOP(%d)\n", i);</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[i])</span><br><span class="line">            DFS(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 广度优先搜索（类似于树的层次遍历）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> MatrixUDG::BFS()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[MAX];     <span class="comment">// 辅组队列</span></span><br><span class="line">    <span class="keyword">int</span> visited[MAX];   <span class="comment">// 顶点访问标记</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"BFS: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mVexs[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="built_in">queue</span>[rear++] = i;  <span class="comment">// 入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head != rear)  &#123;</span><br><span class="line">            j = <span class="built_in">queue</span>[head++];  <span class="comment">// 出队列</span></span><br><span class="line">            <span class="keyword">for</span> (k = firstVertex(j); k &gt;= <span class="number">0</span>; k = nextVertex(j, k)) &#123; <span class="comment">//k是为访问的邻接顶点</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[k]) &#123;</span><br><span class="line">                    visited[k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; mVexs[k] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                    <span class="built_in">queue</span>[rear++] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印矩阵队列图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> MatrixUDG::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Martix Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; mVexNum; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mMatrix[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> vexs[] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> edges[][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'D'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'F'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'C'</span>, <span class="string">'D'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'E'</span>, <span class="string">'G'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'F'</span>, <span class="string">'G'</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> vlen = <span class="keyword">sizeof</span>(vexs)/<span class="keyword">sizeof</span>(vexs[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> elen = <span class="keyword">sizeof</span>(edges)/<span class="keyword">sizeof</span>(edges[<span class="number">0</span>]);</span><br><span class="line">    MatrixUDG* pG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义"图"(输入矩阵队列)</span></span><br><span class="line">    <span class="comment">// pG = new MatrixUDG();</span></span><br><span class="line">    <span class="comment">// 采用已有的"图"</span></span><br><span class="line">    pG = <span class="keyword">new</span> MatrixUDG(vexs, vlen, edges, elen);</span><br><span class="line">    pG-&gt;print();   <span class="comment">// 打印图</span></span><br><span class="line">    pG-&gt;DFS();     <span class="comment">// 深度优先遍历</span></span><br><span class="line">    pG-&gt;BFS();     <span class="comment">// 广度优先遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </details><details><summary>2. 邻接表表示的"无向图</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++: 邻接表表示的"无向图(List Undirected Graph)"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author LippiOuYang</span></span><br><span class="line"><span class="comment"> * @date 2013/04/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListUDG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 内部类</span></span><br><span class="line">    <span class="comment">// 邻接表中表对应的链表的顶点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ENode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> ivex;           <span class="comment">// 该边所指向的顶点的位置</span></span><br><span class="line">        ENode *nextEdge;    <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邻接表中表的顶点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">char</span> data;          <span class="comment">// 顶点信息</span></span><br><span class="line">        ENode *firstEdge;   <span class="comment">// 指向第一条依附该顶点的弧</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有成员</span></span><br><span class="line">    <span class="keyword">int</span> mVexNum;             <span class="comment">// 图的顶点的数目</span></span><br><span class="line">    <span class="keyword">int</span> mEdgNum;             <span class="comment">// 图的边的数目</span></span><br><span class="line">    VNode mVexs[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建邻接表对应的图(自己输入)</span></span><br><span class="line">    ListUDG();</span><br><span class="line">    <span class="comment">// 创建邻接表对应的图(用已提供的数据)</span></span><br><span class="line">    ListUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen);</span><br><span class="line">    ~ListUDG();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索遍历图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 广度优先搜索（类似于树的层次遍历）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 打印邻接表图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 读取一个输入字符</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回ch的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line">    <span class="comment">// 深度优先搜索遍历图的递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span></span>;</span><br><span class="line">    <span class="comment">// 将node节点链接到list的最后</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(ENode *<span class="built_in">list</span>, ENode *node)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建邻接表对应的图(自己输入)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ListUDG::ListUDG()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">int</span> v, e;</span><br><span class="line">    <span class="keyword">int</span> i, p1, p2;</span><br><span class="line">    ENode *node1, *node2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入"顶点数"和"边数"</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input vertex number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mVexNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input edge number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mEdgNum;</span><br><span class="line">    <span class="keyword">if</span> ( mVexNum &lt; <span class="number">1</span> || mEdgNum &lt; <span class="number">1</span> || (mEdgNum &gt; (mVexNum * (mVexNum<span class="number">-1</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"input error: invalid parameters!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"邻接表"的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"vertex("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        mVexs[i].data = readChar();</span><br><span class="line">        mVexs[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"邻接表"的边</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mEdgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"edge("</span> &lt;&lt; i &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        c1 = readChar();</span><br><span class="line">        c2 = readChar();</span><br><span class="line"></span><br><span class="line">        p1 = getPosition(c1);</span><br><span class="line">        p2 = getPosition(c2);</span><br><span class="line">        <span class="comment">// 初始化node1</span></span><br><span class="line">        node1 = <span class="keyword">new</span> ENode();</span><br><span class="line">        node1-&gt;ivex = p2;</span><br><span class="line">        <span class="comment">// 将node1链接到"p1所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span>(mVexs[p1].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            mVexs[p1].firstEdge = node1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkLast(mVexs[p1].firstEdge, node1);</span><br><span class="line">        <span class="comment">// 初始化node2</span></span><br><span class="line">        node2 = <span class="keyword">new</span> ENode();</span><br><span class="line">        node2-&gt;ivex = p1;</span><br><span class="line">        <span class="comment">// 将node2链接到"p2所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span>(mVexs[p2].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            mVexs[p2].firstEdge = node2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkLast(mVexs[p2].firstEdge, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建邻接表对应的图(用已提供的数据)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ListUDG::ListUDG(<span class="keyword">char</span> vexs[], <span class="keyword">int</span> vlen, <span class="keyword">char</span> edges[][<span class="number">2</span>], <span class="keyword">int</span> elen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">int</span> i, p1, p2;</span><br><span class="line">    ENode *node1, *node2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"顶点数"和"边数"</span></span><br><span class="line">    mVexNum = vlen;</span><br><span class="line">    mEdgNum = elen;</span><br><span class="line">    <span class="comment">// 初始化"邻接表"的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mVexs[i].data = vexs[i];</span><br><span class="line">        mVexs[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化"邻接表"的边</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mEdgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">        c1 = edges[i][<span class="number">0</span>];</span><br><span class="line">        c2 = edges[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        p1 = getPosition(c1);</span><br><span class="line">        p2 = getPosition(c2);</span><br><span class="line">        <span class="comment">// 初始化node1</span></span><br><span class="line">        node1 = <span class="keyword">new</span> ENode();</span><br><span class="line">        node1-&gt;ivex = p2;</span><br><span class="line">        <span class="comment">// 将node1链接到"p1所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span>(mVexs[p1].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            mVexs[p1].firstEdge = node1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkLast(mVexs[p1].firstEdge, node1);</span><br><span class="line">        <span class="comment">// 初始化node2</span></span><br><span class="line">        node2 = <span class="keyword">new</span> ENode();</span><br><span class="line">        node2-&gt;ivex = p1;</span><br><span class="line">        <span class="comment">// 将node2链接到"p2所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span>(mVexs[p2].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            mVexs[p2].firstEdge = node2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkLast(mVexs[p2].firstEdge, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ListUDG::~ListUDG() </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将node节点链接到list的最后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::linkLast(ENode *<span class="built_in">list</span>, ENode *node)</span><br><span class="line">&#123;</span><br><span class="line">    ENode *p = <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;nextEdge)</span><br><span class="line">        p = p-&gt;nextEdge;</span><br><span class="line">    p-&gt;nextEdge = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回ch的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ListUDG::getPosition(<span class="keyword">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;mVexNum; i++)</span><br><span class="line">        <span class="keyword">if</span>(mVexs[i].data==ch)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取一个输入字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> ListUDG::readChar()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!((ch&gt;=<span class="string">'a'</span>&amp;&amp;ch&lt;=<span class="string">'z'</span>) || (ch&gt;=<span class="string">'A'</span>&amp;&amp;ch&lt;=<span class="string">'Z'</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度优先搜索遍历图的递归实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::DFS(<span class="keyword">int</span> i, <span class="keyword">int</span> *visited)</span><br><span class="line">&#123;</span><br><span class="line">    ENode *node;</span><br><span class="line"></span><br><span class="line">    visited[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    node = mVexs[i].firstEdge;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[node-&gt;ivex])</span><br><span class="line">            DFS(node-&gt;ivex, visited);</span><br><span class="line">        node = node-&gt;nextEdge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度优先搜索遍历图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::DFS()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> visited[MAX];       <span class="comment">// 顶点访问标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有顶点都没有被访问</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i])</span><br><span class="line">            DFS(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 广度优先搜索（类似于树的层次遍历）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::BFS()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[MAX];     <span class="comment">// 辅组队列</span></span><br><span class="line">    <span class="keyword">int</span> visited[MAX];   <span class="comment">// 顶点访问标记</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    ENode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"BFS: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="built_in">queue</span>[rear++] = i;  <span class="comment">// 入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head != rear) </span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="built_in">queue</span>[head++];  <span class="comment">// 出队列</span></span><br><span class="line">            node = mVexs[j].firstEdge;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k = node-&gt;ivex;</span><br><span class="line">                <span class="keyword">if</span> (!visited[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; mVexs[k].data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                    <span class="built_in">queue</span>[rear++] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node-&gt;nextEdge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印邻接表图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ListUDG::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    ENode *node;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"List Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mVexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"("</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">        node = mVexs[i].firstEdge;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node-&gt;ivex &lt;&lt; <span class="string">"("</span> &lt;&lt; mVexs[node-&gt;ivex].data &lt;&lt; <span class="string">") "</span>;</span><br><span class="line">            node = node-&gt;nextEdge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> vexs[] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> edges[][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'D'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'A'</span>, <span class="string">'F'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'C'</span>, <span class="string">'D'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'E'</span>, <span class="string">'G'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'F'</span>, <span class="string">'G'</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> vlen = <span class="keyword">sizeof</span>(vexs)/<span class="keyword">sizeof</span>(vexs[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> elen = <span class="keyword">sizeof</span>(edges)/<span class="keyword">sizeof</span>(edges[<span class="number">0</span>]);</span><br><span class="line">    ListUDG* pG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义"图"(输入矩阵队列)</span></span><br><span class="line">    <span class="comment">//pG = new ListUDG();</span></span><br><span class="line">    <span class="comment">// 采用已有的"图"</span></span><br><span class="line">    pG = <span class="keyword">new</span> ListUDG(vexs, vlen, edges, elen);</span><br><span class="line"></span><br><span class="line">    pG-&gt;print();   <span class="comment">// 打印图</span></span><br><span class="line">    pG-&gt;DFS();     <span class="comment">// 深度优先遍历</span></span><br><span class="line">    pG-&gt;BFS();     <span class="comment">// 广度优先遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><hr><h2 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h2><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p><p>此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p><p>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul><li><p>(1)</p><p>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</p></li><li><p>(2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</p></li><li><p>(3)</p><p>更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</p></li><li><p>(4) 重复步骤(2)和(3)，直到遍历完所有顶点。</p></li></ul><p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><p>5.3迪杰斯特拉算法图解</p><p><img src="/images/imageGraph/graph11.jpg" alt></p><p>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。</p><p><img src="/images/imageGraph/graph12.jpg" alt></p><ul><li><p>初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！</p></li><li><p>第1步：将顶点D加入到S中。</p><p> 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。     注:C(3)表示C到起点D的距离是3。</p></li><li><p>第2步：将顶点C加入到S中。</p><p> 上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。<br> 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。</p></li><li><p>第3步：将顶点E加入到S中。</p><p> 上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 </p><p> 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。</p></li><li><p>第4步：将顶点F加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</p></li><li><p>第5步：将顶点G加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p></li><li><p>第6步：将顶点B加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p></li><li><p>第7步：将顶点A加入到S中。</p><p> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p></li></ul><p>此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>本文以”邻接矩阵”为例对迪杰斯特拉算法进行说明，</p><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> vexs[MAX];       <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="keyword">int</span> vexnum;           <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">int</span> edgnum;           <span class="comment">// 边数</span></span><br><span class="line">    <span class="keyword">int</span> matrix[MAX][MAX]; <span class="comment">// 邻接矩阵</span></span><br><span class="line">&#125;Graph, *PGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EdgeData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> start; <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="keyword">char</span> end;   <span class="comment">// 边的终点</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">// 边的权重</span></span><br><span class="line">&#125;EData;</span><br></pre></td></tr></table></figure><p>Graph是邻接矩阵对应的结构体。 </p><p>vexs用于保存顶点，vexnum是顶点数，edgnum是边数；matrix则是用于保存矩阵信息的二维数组。例如，matrix[i][j]=1，则表示”顶点i(即vexs[i])”和”顶点j(即vexs[j])”是邻接点；matrix[i][j]=0，则表示它们不是邻接点。 </p><p>EData是邻接矩阵边对应的结构体。</p><h4 id="迪杰斯特拉算法-1"><a href="#迪杰斯特拉算法-1" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h4><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dijkstra最短路径。</span></span><br><span class="line"><span class="comment"> * 即，统计图(G)中"顶点vs"到其它各个顶点的最短路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     G -- 图</span></span><br><span class="line"><span class="comment"> *     vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。</span></span><br><span class="line"><span class="comment"> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。</span></span><br><span class="line"><span class="comment"> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Graph G, <span class="keyword">int</span> vs, <span class="keyword">int</span> prev[], <span class="keyword">int</span> dist[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> flag[MAX];      <span class="comment">// flag[i]=1表示"顶点vs"到"顶点i"的最短路径已成功获取。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[i] = <span class="number">0</span>;              <span class="comment">// 顶点i的最短路径还没获取到。</span></span><br><span class="line">        prev[i] = <span class="number">0</span>;              <span class="comment">// 顶点i的前驱顶点为0。</span></span><br><span class="line">        dist[i] = G.matrix[vs][i];<span class="comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对"顶点vs"自身进行</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    flag[vs] = <span class="number">1</span>;</span><br><span class="line">    dist[vs] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历G.vexnum-1次；每次找出一个顶点的最短路径。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 寻找当前最小的路径；</span></span><br><span class="line">        <span class="comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span></span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[j]==<span class="number">0</span> &amp;&amp; dist[j]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记"顶点k"为已经获取到最短路径</span></span><br><span class="line">        flag[k] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修正当前最短路径和前驱顶点</span></span><br><span class="line">        <span class="comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = (G.matrix[k][j]==INF ? INF : (min + G.matrix[k][j])); <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="number">0</span> &amp;&amp; (tmp  &lt; dist[j]) )</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = tmp;</span><br><span class="line">                prev[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印dijkstra最短路径的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dijkstra(%c): \n"</span>, G.vexs[vs]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  shortest(%c, %c)=%d\n"</span>, G.vexs[vs], G.vexs[i], dist[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的定义：&quot;&gt;&lt;a href=&quot;#图的定义：&quot; class=&quot;headerlink&quot; title=&quot;图的定义：&quot;&gt;&lt;/a&gt;图的定义：&lt;/h2&gt;&lt;p&gt;图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。&lt;/p&gt;
&lt;p&gt;图的种类：地图，电路图，调度图，事物，网络，程序结构&lt;/p&gt;
&lt;p&gt;图的属性：有V个顶点的图最多有V*（V-1）/2条边&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://miaopei.github.io/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://miaopei.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Git操作手册|命令速查表</title>
    <link href="http://miaopei.github.io/2018/02/27/git-guide/"/>
    <id>http://miaopei.github.io/2018/02/27/git-guide/</id>
    <published>2018-02-27T10:02:52.000Z</published>
    <updated>2019-06-14T08:26:36.372Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。<br>本文分为以下几个部分：</p><ol><li>Git与SVN差异</li><li>Git常用命令</li><li>Git进阶指南</li></ol><a id="more"></a><h2 id="Git与SVN差异"><a href="#Git与SVN差异" class="headerlink" title="Git与SVN差异"></a>Git与SVN差异</h2><p>Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。</p><p>Git 和 SVN 思想最大的差别有四个：</p><ul><li>去中心化</li><li>直接记录快照，而非差异</li><li>不一样的分支概念</li><li>三个文件状态</li></ul><p><strong>去中心化</strong></p><p>Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西 ， 所有的数据都在本地，不存在谁是中心</p><p><img src="/images/images/git.gif" alt></p><p>图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。</p><p><strong>直接记录快照，而非差异</strong></p><p>Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉：</p><p>SVN：</p><p><img src="/images/images/svn.png" alt></p><p>Git:</p><p><img src="/images/images/gitgit.png" alt></p><p>Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。</p><p><strong>不一样的分支概念</strong></p><p>Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。</p><p><strong>三个文件状态</strong></p><p>在Git中文件有三种状态：</p><ul><li>已提交（committed）：该文件被安全地保存在了本地数据库</li><li>已修改（modified）：修改了某个文件，但还没有保存</li><li>已暂存（staged）：把已修改的文件放下下次保存的清单中</li></ul><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>复制一个已创建的仓库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span></span><br></pre></td></tr></table></figure><p>创建一个新的本地仓库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><h3 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h3><p>显示工作路径下已修改的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p>显示与上次提交版本文件的不同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><p>把当前所有修改添加到下次提交中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add</span></span><br></pre></td></tr></table></figure><p>把对某个文件的修改添加到下次提交中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>提交本地的所有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br></pre></td></tr></table></figure><p>提交之前已标记的变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit</span></span><br></pre></td></tr></table></figure><p>附加消息提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'message here'</span></span></span><br></pre></td></tr></table></figure><p>提交，并将提交时间设置为之前的某个日期:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --date=<span class="string">"`date --date='n day ago'`"</span> -am <span class="string">"Commit Message"</span></span></span><br></pre></td></tr></table></figure><h3 id="修改上次提交"><a href="#修改上次提交" class="headerlink" title="修改上次提交"></a>修改上次提交</h3><p>请勿修改已发布的提交记录!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><p>把当前分支中未提交的修改移动到其他分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout branch2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>从当前目录的所有文件中查找文本内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git grep <span class="string">"Hello"</span></span></span><br></pre></td></tr></table></figure><p>在某一版本中搜索文本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git grep <span class="string">"Hello"</span> v2.5</span></span><br></pre></td></tr></table></figure><h3 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h3><p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>显示所有提交（仅显示提交的hash和message）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --oneline</span></span><br></pre></td></tr></table></figure><p>显示某个用户的所有提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --author=<span class="string">"username"</span></span></span><br></pre></td></tr></table></figure><p>显示某个文件的所有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>谁，在什么时间，修改了文件的什么内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><p>列出所有的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure><p>切换分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>创建并切换到新分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>基于当前分支创建新分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;new-branch&gt;</span></span><br></pre></td></tr></table></figure><p>基于远程分支创建新的可追溯的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</span></span><br></pre></td></tr></table></figure><p>删除本地分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>给当前版本打标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h3><p>列出当前配置的远程端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><p>显示远程端的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><p>添加新的远程端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;remote&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><p>下载远程端版本，但不合并到HEAD中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><p>下载远程端版本，并自动与HEAD版本合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote pull &lt;remote&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><p>将远程端版本合并到本地版本中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master</span></span><br></pre></td></tr></table></figure><p>将本地版本发布到远程端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push remote &lt;remote&gt; &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>删除远程端分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</span></span><br><span class="line">或</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</span></span><br></pre></td></tr></table></figure><p>发布标签:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><h3 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h3><p>将分支合并到当前HEAD中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>将当前HEAD版本重置到分支中:<br>请勿重置已发布的提交!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>退出重置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --abort</span></span><br></pre></td></tr></table></figure><p>解决冲突后继续重置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure><p>使用配置好的merge tool 解决冲突：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mergetool</span></span><br></pre></td></tr></table></figure><p>在编辑器中手动解决冲突后，标记文件为已解决冲突</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;resolved-file&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;resolved-file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>放弃工作目录下的所有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD</span></span><br></pre></td></tr></table></figure><p>移除缓存区的所有文件（i.e. 撤销上次git add）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD</span></span><br></pre></td></tr></table></figure><p>放弃某个文件的所有本地修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>重置一个提交（通过创建一个截然不同的新提交）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><p>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Git进阶指南"><a href="#Git进阶指南" class="headerlink" title="Git进阶指南"></a>Git进阶指南</h2><h3 id="问：如何修改-origin-仓库信息？"><a href="#问：如何修改-origin-仓库信息？" class="headerlink" title="问：如何修改 origin 仓库信息？"></a>问：如何修改 origin 仓库信息？</h3><h4 id="1、添加-origin-仓库信息"><a href="#1、添加-origin-仓库信息" class="headerlink" title="1、添加 origin 仓库信息"></a>1、添加 origin 仓库信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin &lt;git仓库地址&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、查看-origin-仓库信息"><a href="#2、查看-origin-仓库信息" class="headerlink" title="2、查看 origin 仓库信息"></a>2、查看 origin 仓库信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下三种方式均可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config get --remote.origin.url</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br></pre></td></tr></table></figure><h4 id="3、删除-origin-仓库信息"><a href="#3、删除-origin-仓库信息" class="headerlink" title="3、删除 origin 仓库信息"></a>3、删除 origin 仓库信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm origin</span></span><br></pre></td></tr></table></figure><h3 id="问：如何配置-git-ssh-keys-？"><a href="#问：如何配置-git-ssh-keys-？" class="headerlink" title="问：如何配置 git ssh keys ？"></a>问：如何配置 git ssh keys ？</h3><p>在本地生成 ssh 私钥 / 公钥 文件</p><p>将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台</p><p>测试 git ssh 连接是否成功</p><p>接下来以添加 github ssh keys 为例，请注意替换 github 文件名。</p><p>注：如果对密钥机制不熟悉，建议不要指定 <code>-f</code> 参数，直接使用默认的 id_rsa 文件名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行以下命令，一直回车，文件名可随意指定</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -b 4096 -C <span class="string">"kaiye@macbook"</span> -f ~/.ssh/github</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychain</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add -K ~/.ssh/github</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 pub 公钥的内容粘贴到线上网站的后台</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/github.pub</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试 git ssh 是否连接成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br></pre></td></tr></table></figure><h3 id="问：如何撤销修改？"><a href="#问：如何撤销修改？" class="headerlink" title="问：如何撤销修改？"></a>问：如何撤销修改？</h3><p>修改包含四种情况，需单独区分。</p><h4 id="1、新建的文件和目录，且从未提交至版本库"><a href="#1、新建的文件和目录，且从未提交至版本库" class="headerlink" title="1、新建的文件和目录，且从未提交至版本库"></a>1、新建的文件和目录，且从未提交至版本库</h4><p>此类文件的状态为 Untracked files ，撤销方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git clean -fd .</span></span><br></pre></td></tr></table></figure><p>其中，. 表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。</p><h4 id="2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）"><a href="#2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）" class="headerlink" title="2、提交过版本库，但未提交至暂存区的文件（未执行 git add）"></a>2、提交过版本库，但未提交至暂存区的文件（未执行 git add）</h4><p>此类文件的状态为<code>Changes not staged for commit</code>，撤销方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br></pre></td></tr></table></figure><h4 id="3、已提交至暂存区的文件"><a href="#3、已提交至暂存区的文件" class="headerlink" title="3、已提交至暂存区的文件"></a>3、已提交至暂存区的文件</h4><p>此类文件的状态为 Changes to be committed，撤销方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset .</span></span><br></pre></td></tr></table></figure><p>执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。</p><h4 id="4、已提交至版本库（执行了-git-commit）"><a href="#4、已提交至版本库（执行了-git-commit）" class="headerlink" title="4、已提交至版本库（执行了 git commit）"></a>4、已提交至版本库（执行了 git commit）</h4><p>每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;版本号&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要「回滚至上一次提交」，可直接使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset head~1</span></span><br></pre></td></tr></table></figure><p>执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。</p><h4 id="5、如果回滚了之后又不想回滚了怎么办？"><a href="#5、如果回滚了之后又不想回滚了怎么办？" class="headerlink" title="5、如果回滚了之后又不想回滚了怎么办？"></a>5、如果回滚了之后又不想回滚了怎么办？</h4><p>如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。</p><p>如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &lt;版本号&gt; 。</p><h3 id="问：遇到冲突了怎么解决？"><a href="#问：遇到冲突了怎么解决？" class="headerlink" title="问：遇到冲突了怎么解决？"></a>问：遇到冲突了怎么解决？</h3><p>两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。</p><h4 id="1、最快的办法"><a href="#1、最快的办法" class="headerlink" title="1、最快的办法"></a>1、最快的办法</h4><p>大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用当前分支 HEAD 版本，通常是冲突源文件的 &lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记部分，======= 的上方</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout --ours &lt;文件名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用合并分支版本，通常是源冲突文件的 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记部分</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout --theirs &lt;文件名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 标记为解决状态加入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;文件名&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、最通用的办法"><a href="#2、最通用的办法" class="headerlink" title="2、最通用的办法"></a>2、最通用的办法</h4><p>用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。</p><p>在 Mac 系统下，运行 git mergetool &lt;文件名&gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。</p><h4 id="3、最好的习惯"><a href="#3、最好的习惯" class="headerlink" title="3、最好的习惯"></a>3、最好的习惯</h4><p>有三个好的习惯，可以减少代码的冲突：</p><p>在开始修改代码前先 git pull 一下；</p><p>将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件；</p><p>通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性。</p><h4 id="4、最复杂的情况"><a href="#4、最复杂的情况" class="headerlink" title="4、最复杂的情况"></a>4、最复杂的情况</h4><p>如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。</p><p>它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。</p><p>rebase 大概的操作步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将当前分支的版本追加到从远程 pull 回来的节点之后</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull --rebase</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若发生冲突，则按以上其他方法进行解决，解决后继续</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase --<span class="built_in">continue</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直到所有冲突得以解决，待项目最后上线前再执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase --skip</span></span><br></pre></td></tr></table></figure><h3 id="问：如何在不提交修改的前提下，执行-pull-merge-等操作？"><a href="#问：如何在不提交修改的前提下，执行-pull-merge-等操作？" class="headerlink" title="问：如何在不提交修改的前提下，执行 pull / merge 等操作？"></a>问：如何在不提交修改的前提下，执行 pull / merge 等操作？</h3><p>有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。</p><p>这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。</p><p>以下是 git stash 常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 stash 队列中已暂存了多少 WIP</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复上一次的 WIP 状态，并从队列中移除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复指定编号的 WIP，同时从队列中移除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop stash@&#123;num&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复指定编号的 WIP，但不从队列中移除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash apply stash@&#123;num&#125;</span></span><br></pre></td></tr></table></figure><h3 id="问：如何在-git-log-中查看修改的文件列表？"><a href="#问：如何在-git-log-中查看修改的文件列表？" class="headerlink" title="问：如何在 git log 中查看修改的文件列表？"></a>问：如何在 git log 中查看修改的文件列表？</h3><p>默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --name-status --oneline</span></span><br></pre></td></tr></table></figure><p>每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.ls <span class="string">'log --name-status --oneline --graph'</span></span></span><br></pre></td></tr></table></figure><p>运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.st <span class="string">'status --porcelain'</span></span></span><br></pre></td></tr></table></figure><p>更多 git log 参数，可通过 git help log 查看手册。</p><p>如果是看上一次提交的版本日志，直接运行 git show 即可。</p><p>此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。</p><h3 id="问：git-submodule-update-时出错怎么解决？"><a href="#问：git-submodule-update-时出错怎么解决？" class="headerlink" title="问：git submodule update 时出错怎么解决？"></a>问：git submodule update 时出错怎么解决？</h3><p>例如，在执行 git submodule update 时有以下错误信息：</p><blockquote><p>fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5<br>Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’</p></blockquote><p>在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit 了新的版本 「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。</p><p>解决方法，在电脑 A 上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 <code>-u</code> 参数即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master -u</span></span><br></pre></td></tr></table></figure><p>支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config core.quotepath off</span></span><br></pre></td></tr></table></figure><p>常用的打 tag 操作，更多请查看《Git 基础 - 打标签》</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地 tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地新增一个 tag，推送至 origin 服务器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.0.0 -m <span class="string">'tag description'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地与 origin tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.0.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete v1.0.0</span></span><br></pre></td></tr></table></figure><p>使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &lt;分支名&gt;，以下是常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建分支 branch1，并切换过去</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b branch1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有本地与远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改完成后，切换回 master 分支，将 branch1 分支合并进来</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge branch1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已完成合并的分支 branch1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d branch1</span></span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>Pro Git 简体中文版</li><li>Git权威指南</li><li>命令行man手册</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。&lt;br&gt;本文分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Git与SVN差异&lt;/li&gt;
&lt;li&gt;Git常用命令&lt;/li&gt;
&lt;li&gt;Git进阶指南&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Dogs vs Cats (猫狗大战)</title>
    <link href="http://miaopei.github.io/2018/01/03/DeepLearning/DogsVsCats/"/>
    <id>http://miaopei.github.io/2018/01/03/DeepLearning/DogsVsCats/</id>
    <published>2018-01-03T02:14:50.000Z</published>
    <updated>2019-06-13T07:58:02.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>GitHub 项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pYW9wZWkvY2F0X3ZzX2RvZw==" title="https://github.com/miaopei/cat_vs_dog">Dogs vs Cats (猫狗大战)<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><p>本项目是优达学城的一个毕业项目。项目要求使用深度学习方法识别一张图片是猫还是狗</p><ul><li>输入：一张彩色图片</li><li>输出：是猫还是狗</li></ul><a id="more"></a><h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><p>项目使用Anaconda搭建环境。可是使用environment目录下的yml进行环境安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda env create -f environment.yml</span></span><br></pre></td></tr></table></figure><h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>数据集来自 kaggle 上的一个竞赛：<span class="exturl" data-url="aHR0cHM6Ly93d3cua2FnZ2xlLmNvbS9jL2RvZ3MtdnMtY2F0cy1yZWR1eC1rZXJuZWxzLWVkaXRpb24vZGF0YQ==" title="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition/data">Dogs vs. Cats Redux: Kernels Edition<i class="fa fa-external-link"></i></span>。</p><p>下载kaggle猫狗数据集解压后分为 3 个文件 train.zip、 test.zip 和 sample_submission.csv。</p><p>train 训练集包含了 25000 张猫狗的图片， 每张图片包含图片本身和图片名。命名规则根据“type.num.jpg”方式命名。</p><p>test 测试集包含了 12500 张猫狗的图片， 每张图片命名规则根据“num.jpg”，需要注意的是测试集编号从 1 开始， 而训练集的编号从 0 开始。</p><p>sample_submission.csv 需要将最终测试集的测试结果写入.csv 文件中，上传至 kaggle 进行打分。</p><h2 id="基准模型"><a href="#基准模型" class="headerlink" title="基准模型"></a>基准模型</h2><p>项目使用ResNet50, Xception, Inception V3 这三个模型完成。本项目的最低要求是 kaggle Public Leaderboard 前10%。在kaggle上，总共有1314只队伍参加了比赛，所以需要最终的结果排在131位之前，131位的得分是0.06127，所以目标是模型预测结果要小于0.06127。</p><h2 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h2><p>kaggle 官方的评估标准是 LogLoss，下面的表达式就是二分类问题的 LogLoss 定义。</p><div align="center"><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PUxvZ0xvc3Mmc3BhY2U7PSZzcGFjZTstXGZyYWN7MX17bn1cc3VtX3tpPTF9Xm4mc3BhY2U7W3lfaWxvZyhcaGF0e3l9X2kpJnBsdXM7KDEteV9pKWxvZygxLSZzcGFjZTtcaGF0e3l9X2kpXQ==" title="https://www.codecogs.com/eqnedit.php?latex=LogLoss&space;=&space;-\frac{1}{n}\sum_{i=1}^n&space;[y_ilog(\hat{y}_i)&plus;(1-y_i)log(1-&space;\hat{y}_i)]"><img src="https://latex.codecogs.com/gif.latex?LogLoss&space;=&space;-\frac{1}{n}\sum_{i=1}^n&space;[y_ilog(\hat{y}_i)&plus;(1-y_i)log(1-&space;\hat{y}_i)]" title="LogLoss = -\frac{1}{n}\sum_{i=1}^n [y_ilog(\hat{y}_i)+(1-y_i)log(1- \hat{y}_i)]"><i class="fa fa-external-link"></i></span></div><p>其中：</p><ul><li><p>n 是测试集中图片数量</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PVxoYXR7eX1faQ==" title="https://www.codecogs.com/eqnedit.php?latex=\hat{y}_i"><img src="https://latex.codecogs.com/gif.latex?\hat{y}_i" title="\hat{y}_i"><i class="fa fa-external-link"></i></span> 是图片预测为狗的概率</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PXlfaQ==" title="https://www.codecogs.com/eqnedit.php?latex=y_i"><img src="https://latex.codecogs.com/gif.latex?y_i" title="y_i"><i class="fa fa-external-link"></i></span> 如果图像是狗，则为1，如果是猫，则为0</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PWxvZygp" title="https://www.codecogs.com/eqnedit.php?latex=log()"><img src="https://latex.codecogs.com/gif.latex?log()" title="log()"><i class="fa fa-external-link"></i></span> 是自然（基数 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PWU=" title="https://www.codecogs.com/eqnedit.php?latex=e"><img src="https://latex.codecogs.com/gif.latex?e" title="e"><i class="fa fa-external-link"></i></span>）对数</p></li></ul><p>对数损失越小，代表模型的性能越好。上述评估指标可用于评估该项目的解决方案以及基准模型。</p><h2 id="设计大纲"><a href="#设计大纲" class="headerlink" title="设计大纲"></a>设计大纲</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> model_graphviz/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><img src="/images/imageDeepLearning/model.png"><p>整个模型是在本地训练的，训练了三天才完成。建议使用云端 GPU 训练复现实验过程。</p><p><strong>1. 数据预处理</strong></p><ul><li>从kaggle下载好图片</li><li>将猫和狗的图片放在不同的文件夹以示分类，使用创建符号链接的方法</li><li>对图片进行resize，保持输入图片信息大小一致</li></ul><p><strong>2. 模型搭建</strong></p><p>Kera的应用模块Application提供了带有预训练权重的Keras模型，这些模型可以用来进行预测、特征提取和微调整和。</p><ul><li>Xception 默认输入图片大小是 <code>299*299*3</code></li><li>InceptionV3 默认输入图片大小是 <code>299*299*3</code></li><li>ResNet50 默认输入图片大小是 <code>224*224*3</code></li></ul><p>在Keras中载入模型并进行全局平均池化，只需要在载入模型的时候，设置<code>include_top=False</code>, <code>pooling=&#39;avg&#39;</code>. 每个模型都将图片处理成一个<code>1*2048</code>的行向量，将这三个行向量进行拼接，得到一个<code>1*6144</code>的行向量， 作为数据预处理的结果。</p><p><strong>3. 模型训练&amp;模型调参</strong></p><p>载入预处理的数据之后，先进行一次概率为0.5的dropout，然后直接连接输出层，激活函数为Sigmoid，优化器为Adam，输出一个零维张量，表示某张图片中有狗的概率。</p><p><strong>4. 模型评估</strong></p><ul><li>使用$Logloss$进行模型评估,上传Kaggle判断是否符合标准</li></ul><p><strong>5. 可视化</strong></p><ul><li>进行数据探索并且可视化原始数据</li><li>可视化模型训练过程的准确率曲线，损失函数曲线等</li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>项目使用 Keras 和 Flask 搭建部署一个简单易用的深度学习图像网页应用，可以通过网页导入一张彩色猫或者狗的图片预测是猫或者狗的概率。</p><p>项目目录结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── ResNet50_image_predict.ipynb</span><br><span class="line">├── app.py</span><br><span class="line">├── environmert.yml</span><br><span class="line">├── static</span><br><span class="line">│   ├── css</span><br><span class="line">│   │   └── main.css</span><br><span class="line">│   └── js</span><br><span class="line">│       └── main.js</span><br><span class="line">├── templates</span><br><span class="line">│   ├── base.html</span><br><span class="line">│   └── index.html</span><br><span class="line">├── models</span><br><span class="line">│   └── ResNet50_catdog_model.h5</span><br><span class="line">├── uploads</span><br><span class="line">│   ├── test01.jpg</span><br><span class="line">│   └── test02.jpg</span><br><span class="line">└── webapp_image_predict.ipynb</span><br></pre></td></tr></table></figure><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda env create -f environmert.yml</span></span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python app.py</span></span><br></pre></td></tr></table></figure><p>这时候用浏览器打开 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAwLw==" title="http://localhost:5000/">http://localhost:5000/<i class="fa fa-external-link"></i></span> 就可以进行网页导入图片预测图片是狗的概率了。</p><h3 id="快速复现webapp预测结果"><a href="#快速复现webapp预测结果" class="headerlink" title="快速复现webapp预测结果"></a>快速复现webapp预测结果</h3><p>如果不想搭建环境复现实验结果，可以按照以下操作分分钟复现实验结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull miaowmiaow/webapp:1.1.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 5000:5000 miaowmiaow/webapp:1.1.0</span></span><br></pre></td></tr></table></figure><p>到此就可以在浏览器中输入 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAw" title="http://localhost:5000">http://localhost:5000<i class="fa fa-external-link"></i></span> 就可以使用网页对导入的猫狗图片做预测了。</p><p>下图为预测的效果图：</p><img src="/images/imageDeepLearning/webapp.gif">]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;GitHub 项目地址：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL21pYW9wZWkvY2F0X3ZzX2RvZw==&quot; title=&quot;https://github.com/miaopei/cat_vs_dog&quot;&gt;Dogs vs Cats (猫狗大战)&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;项目说明&quot;&gt;&lt;a href=&quot;#项目说明&quot; class=&quot;headerlink&quot; title=&quot;项目说明&quot;&gt;&lt;/a&gt;项目说明&lt;/h2&gt;&lt;p&gt;本项目是优达学城的一个毕业项目。项目要求使用深度学习方法识别一张图片是猫还是狗&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：一张彩色图片&lt;/li&gt;
&lt;li&gt;输出：是猫还是狗&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="http://miaopei.github.io/categories/DeepLearning/"/>
    
    
      <category term="DeepLearning" scheme="http://miaopei.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>关于知识付费的看法</title>
    <link href="http://miaopei.github.io/2017/10/20/%E5%85%B3%E4%BA%8E%E7%9F%A5%E8%AF%86%E4%BB%98%E8%B4%B9%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://miaopei.github.io/2017/10/20/关于知识付费的理解/</id>
    <published>2017-10-20T02:14:50.000Z</published>
    <updated>2019-06-17T07:26:21.295Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzYyODM2NDc0" title="https://www.zhihu.com/question/62836474">知乎 - 关于知识付费的看法<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzYyODM2NDc0&quot; title=&quot;https://www.zhihu.com/question/62836474&quot;&gt;知乎 -
      
    
    </summary>
    
      <category term="other" scheme="http://miaopei.github.io/categories/other/"/>
    
    
      <category term="other" scheme="http://miaopei.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket教程</title>
    <link href="http://miaopei.github.io/2017/05/16/WebSocket%E6%95%99%E7%A8%8B/"/>
    <id>http://miaopei.github.io/2017/05/16/WebSocket教程/</id>
    <published>2017-05-16T06:15:08.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<p>转自<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDUvd2Vic29ja2V0Lmh0bWw=" title="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰网络编程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3dlYnNvY2tldC5vcmcv" title="http://websocket.org/">WebSocket<i class="fa fa-external-link"></i></span> 是一种网络通信协议，很多高级功能都需要它。</p><h2 id="为什么需要-WebSocker"><a href="#为什么需要-WebSocker" class="headerlink" title="为什么需要 WebSocker"></a>为什么需要 WebSocker</h2><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><a id="more"></a><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p><img src="http://i.imgur.com/5mUfWtm.jpg" alt></p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<span class="exturl" data-url="aHR0cHM6Ly93d3cucHVibnViLmNvbS9ibG9nLzIwMTQtMTItMDEtaHR0cC1sb25nLXBvbGxpbmcv" title="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”<i class="fa fa-external-link"></i></span>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVzaF90ZWNobm9sb2d5" title="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术<i class="fa fa-external-link"></i></span>的一种。</p><p><img src="http://i.imgur.com/Qutxs2j.png" alt></p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是 <code>ws</code>（如果加密，则为 <code>wss</code> ），服务器网址就是 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/UWC2xr3.jpg" alt></p><h2 id="客户端的简单示例"><a href="#客户端的简单示例" class="headerlink" title="客户端的简单示例"></a>客户端的简单示例</h2><p>WebSocket 的用法相当简单。</p><p>下面是一个网页脚本的例子（点击<span class="exturl" data-url="aHR0cDovL2pzYmluLmNvbS9tdXFhbWlxaW11L2VkaXQ/anMsY29uc29sZQ==" title="http://jsbin.com/muqamiqimu/edit?js,console">这里<i class="fa fa-external-link"></i></span>看运行结果），基本上一眼就能明白。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>); </span><br><span class="line">  ws.send(<span class="string">"Hello WebSockets!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"Received Message: "</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="客户端的-API"><a href="#客户端的-API" class="headerlink" title="客户端的 API"></a>客户端的 API</h2><p>WebSocket 客户端的 API 如下。</p><h3 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。</p><p>实例对象的所有属性和方法清单，参见<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldA==" title="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">这里<i class="fa fa-external-link"></i></span>。</p><h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p><code>readyState</code> 属性返回实例对象的当前状态，共有四种。</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><p>下面是一个示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的 <code>onopen</code> 属性，用于指定连接成功后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要指定多个回调函数，可以使用addEventListener`方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h3><p>实例对象的 <code>onmessage</code> 属性，用于指定收到服务器数据后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，服务器数据可能是文本，也可能是二进制数据（ <code>blob</code> 对象或 <code>Arraybuffer</code> 对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received data string"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received arraybuffer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"blob"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send( )"></a>webSocket.send( )</h3><p>实例对象的 <code>send( )</code> 方法用于向服务器发送数据。</p><p>发送文本的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">'your message'</span>);</span><br></pre></td></tr></table></figure><p>发送 Blob 对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">'input[type="file"]'</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure><p>发送 ArrayBuffer 对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure><h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的 <code>bufferedAmount</code> 属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>WebSocket 服务器的实现，可以查看维基百科的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcGFyaXNvbl9vZl9XZWJTb2NrZXRfaW1wbGVtZW50YXRpb25z" title="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">列表<i class="fa fa-external-link"></i></span>。</p><p>常用的 Node 实现有以下三种。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VXZWJTb2NrZXRzL3VXZWJTb2NrZXRz" title="https://github.com/uWebSockets/uWebSockets">µWebSockets<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvY2tldC5pby8=" title="http://socket.io/">Socket.IO<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2Rl" title="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node<i class="fa fa-external-link"></i></span></li></ul><p>具体的用法请查看它们的文档，这里不详细介绍了。</p><h2 id="WebSocketd"><a href="#WebSocketd" class="headerlink" title="WebSocketd"></a>WebSocketd</h2><p>下面，我要推荐一款非常特别的 WebSocket 服务器：<span class="exturl" data-url="aHR0cDovL3dlYnNvY2tldGQuY29tLw==" title="http://websocketd.com/">Websocketd<i class="fa fa-external-link"></i></span>。</p><p>它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。</p><p><img src="http://i.imgur.com/a51CR69.png" alt></p><p>举例来说，下面是一个 Bash 脚本 <code>counter.sh</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 2</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 3</span><br></pre></td></tr></table></figure><p>命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bash ./counter.sh</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>现在，启动<code>websocketd</code>，指定这个脚本作为服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 bash ./counter.sh</span><br></pre></td></tr></table></figure><p>上面的命令会启动一个 WebSocket 服务器，端口是 <code>8080</code> 。每当客户端连接这个服务器，就会执行 <code>counter.sh</code> 脚本，并将它的输出推送给客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/'</span>);</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。</p><p>有了它，就可以很方便地将命令行的输出，发给浏览器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 ls</span><br></pre></td></tr></table></figure><p>上面的命令会执行<code>ls</code>命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWItdm1zdGF0cw==" title="https://github.com/joewalnes/web-vmstats">代码<i class="fa fa-external-link"></i></span>）。</p><p><img src="http://i.imgur.com/WMUStsh.jpg" alt></p><p>更多的用法可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL3RyZWUvbWFzdGVyL2V4YW1wbGVzL2Jhc2g=" title="https://github.com/joewalnes/websocketd/tree/master/examples/bash">官方示例<i class="fa fa-external-link"></i></span>。</p><ul><li>Bash 脚本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2Jhc2gvZ3JlZXRlci5zaA==" title="https://github.com/joewalnes/websocketd/blob/master/examples/bash/greeter.sh">读取客户端输入<i class="fa fa-external-link"></i></span>的例子</li><li>五行代码实现一个最简单的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2Jhc2gvY2hhdC5zaA==" title="https://github.com/joewalnes/websocketd/blob/master/examples/bash/chat.sh">聊天服务器<i class="fa fa-external-link"></i></span></li></ul><p><img src="http://i.imgur.com/KfZKSmD.png" alt></p><p>websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL25vZGVqcy9ncmVldGVyLmpz" title="https://github.com/joewalnes/websocketd/blob/master/examples/nodejs/greeter.js"><code>greeter.js</code><i class="fa fa-external-link"></i></span>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">'data: '</span> + chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动这个脚本的命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 node ./greeter.js</span><br></pre></td></tr></table></figure><p>官方仓库还有其他<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL3RyZWUvbWFzdGVyL2V4YW1wbGVz" title="https://github.com/joewalnes/websocketd/tree/master/examples">各种语言<i class="fa fa-external-link"></i></span>的例子。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><span class="exturl" data-url="aHR0cDovL2NqaWhyaWcuY29tL2Jsb2cvaG93LXRvLXVzZS13ZWJzb2NrZXRzLw==" title="http://cjihrig.com/blog/how-to-use-websockets/">How to Use WebSockets<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL3dlYnNvY2tldHMvd2Vic29ja2V0c19zZW5kX3JlY2VpdmVfbWVzc2FnZXMuaHRt" title="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">WebSockets - Send &amp; Receive Messages<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL3dlYnNvY2tldHMvYmFzaWNzLw==" title="https://www.html5rocks.com/en/tutorials/websockets/basics/">Introducing WebSockets: Bringing Sockets to the Web<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDUvd2Vic29ja2V0Lmh0bWw=&quot; title=&quot;http://www.ruanyifeng.com/blog/2017/05/websocket.html&quot;&gt;阮一峰网络编程&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3dlYnNvY2tldC5vcmcv&quot; title=&quot;http://websocket.org/&quot;&gt;WebSocket&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt; 是一种网络通信协议，很多高级功能都需要它。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要-WebSocker&quot;&gt;&lt;a href=&quot;#为什么需要-WebSocker&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 WebSocker&quot;&gt;&lt;/a&gt;为什么需要 WebSocker&lt;/h2&gt;&lt;p&gt;初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://miaopei.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="WebSocket" scheme="http://miaopei.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>定制支持串口安装的ubuntu系统镜像</title>
    <link href="http://miaopei.github.io/2017/05/15/%E5%AE%9A%E5%88%B6%E6%94%AF%E6%8C%81%E4%B8%B2%E5%8F%A3%E5%AE%89%E8%A3%85%E7%9A%84ubuntu%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/"/>
    <id>http://miaopei.github.io/2017/05/15/定制支持串口安装的ubuntu系统镜像/</id>
    <published>2017-05-15T07:48:06.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、所需环境："><a href="#1、所需环境：" class="headerlink" title="1、所需环境："></a>1、所需环境：</h2><p><strong>硬件环境：</strong></p><ul><li>笔记本</li><li>串口调试线缆</li><li>光盘</li><li>显示器</li><li>FWA产品的任一机型（此次使用的是FWA-4210）</li><li>SATA或者USB光驱×1</li></ul><a id="more"></a><p><strong>软件环境：</strong></p><ul><li>带有genisoimage(旧版是mkisofs)的linux发行版（此次使用的是Ubuntu 16.04 server版）</li><li>Ubuntu官网通用镜像ISO文件</li></ul><h2 id="2、操作过程："><a href="#2、操作过程：" class="headerlink" title="2、操作过程："></a>2、操作过程：</h2><h3 id="2-1-开机进入系统，将光盘挂载到Ubuntu系统"><a href="#2-1-开机进入系统，将光盘挂载到Ubuntu系统" class="headerlink" title="2.1 开机进入系统，将光盘挂载到Ubuntu系统"></a>2.1 开机进入系统，将光盘挂载到Ubuntu系统</h3><p>CLI命令如下；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -o loop ubuntu-16.04.2-server-amd64.iso /mnt/temp</span><br></pre></td></tr></table></figure><h3 id="2-2-更改配置"><a href="#2-2-更改配置" class="headerlink" title="2.2 更改配置"></a>2.2 更改配置</h3><p>相关配置文件（menu.cfg、txt.cfg、isolinux.cfg此文件不是必须要修改，具体见下边解释）。将光盘文件，拷贝到临时目录（家目录或者自己新建目录均可，但建议拷贝到/var或/temp目录下），具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -rf /mnt/temp/ /var/mycdrom</span><br></pre></td></tr></table></figure><p>因为 <code>/mnt</code> 目录的默认权限是 <code>333</code> ，所以在此使用 <code>-r</code> 和 <code>-f</code> 参数，<code>-r</code> 代表递归，即文件夹下所有文件都拷贝，<code>-f</code> 代表强制执行；</p><p>更改 <code>menu.cfg</code> 文件，如下图，主要是注释掉标准安装的配置文件，以便可以定制安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/mycdrom/temp/isolinux</span><br><span class="line"></span><br><span class="line">$ vi menu.cfg</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><blockquote><p>vi有三种模式，普通模式、编辑模式、命令行模式；</p><p>I o a进入编辑模式，</p><p>普通模式下数字+yy复制</p><p>P黏贴</p><p>命令行模式：w写入，q离开，！强制执行</p></blockquote><p>注释 <code>menu.cfg</code> 内容如下红框所示：</p><p><img src="http://i.imgur.com/JM99sFZ.png" alt></p><p>更改 <code>txt.cfg</code> 文件，主要用于定制串口安装（如下图）：</p><p><img src="http://i.imgur.com/pA7ruhP.png" alt></p><p>更改 <code>isolinux.cfg</code> 文件，主要修改grub菜单等待时间（如下图），也可不修改；</p><p><img src="http://i.imgur.com/jE4zoMG.png" alt></p><h3 id="2-3-重新打包ISO文件"><a href="#2-3-重新打包ISO文件" class="headerlink" title="2.3 重新打包ISO文件"></a>2.3 重新打包ISO文件</h3><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ genisoimage -o ubuntu-16.04.2-server-adm64-console_115200.iso -r -J -no-emul-boot -boot-load-size 4 -boot-info-table -b isolinux/isolinux.bin -c isolinux/boot.cat /var/mycdrom/temp</span><br></pre></td></tr></table></figure><p><code>genisoimage</code> 是linux各大发行版制作ISO镜像比较流行的工具，若要定制系统，最好在linux下更改相关配置，并使用此工具重新打包；若在Windows平台使用UltraISO等工具解压更改重新打包会出现不稳定的情况（无法找到镜像，无法找到安装源等）。</p><ul><li><code>-o</code> ：是output缩写，用来指定输出镜像名称</li><li><code>-r</code> ： 即rational-rock，用来开放ISO文件所有权限（r、w、x） </li><li><code>-J</code> ： 即Joliet，一种ISO9600扩展格式，用来增加兼容性，最好加上</li><li><code>-no-emul-boot</code>  <code>-boot-load-size 4</code>  <code>-boot-info-table</code> ：指定兼容模式下虚拟扇区的数量，若不指定，有些BISO会出现一些问题</li><li><code>-b</code> ：指定开机映像文件</li><li><code>-c</code> ：具体开机配置文件</li><li>最后加上输出目录</li></ul><p>Reboot系统U盘启动，即可安装系统。</p><h2 id="3、文本安装系统注意事项"><a href="#3、文本安装系统注意事项" class="headerlink" title="3、文本安装系统注意事项"></a>3、文本安装系统注意事项</h2><h3 id="3-1-进入安装模式"><a href="#3-1-进入安装模式" class="headerlink" title="3.1 进入安装模式"></a>3.1 进入安装模式</h3><p>关闭系统插入U盘，启动系统，看到如下提示按F12进入安装系统模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Press  F12  for  boot  menu..</span><br></pre></td></tr></table></figure><p>选择U盘所在的选项。</p><h3 id="3-2-分区"><a href="#3-2-分区" class="headerlink" title="3.2 分区"></a>3.2 分区</h3><p>若是硬盘已有linux发行版系统，那在如下界面，必须umount分区，才能将更改写入分区表</p><h3 id="3-3-自动更新"><a href="#3-3-自动更新" class="headerlink" title="3.3 自动更新"></a>3.3 自动更新</h3><p>如下界面，若有特许需求（需要安装一些特许软件apache、weblogic等）可以选择自动更新（需要联网），一般情况不选则自动更新</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、所需环境：&quot;&gt;&lt;a href=&quot;#1、所需环境：&quot; class=&quot;headerlink&quot; title=&quot;1、所需环境：&quot;&gt;&lt;/a&gt;1、所需环境：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;硬件环境：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;笔记本&lt;/li&gt;
&lt;li&gt;串口调试线缆&lt;/li&gt;
&lt;li&gt;光盘&lt;/li&gt;
&lt;li&gt;显示器&lt;/li&gt;
&lt;li&gt;FWA产品的任一机型（此次使用的是FWA-4210）&lt;/li&gt;
&lt;li&gt;SATA或者USB光驱×1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="http://miaopei.github.io/categories/Ubuntu/"/>
    
    
      <category term="ubuntu" scheme="http://miaopei.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本攻略笔记</title>
    <link href="http://miaopei.github.io/2017/05/15/Shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://miaopei.github.io/2017/05/15/Shell脚本攻略笔记/</id>
    <published>2017-05-15T07:40:41.000Z</published>
    <updated>2019-06-03T08:50:47.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><h3 id="1-1-shell-格式输出"><a href="#1-1-shell-格式输出" class="headerlink" title="1.1 shell 格式输出"></a>1.1 shell 格式输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'Hello world !'</span></span><br><span class="line">-n<span class="comment"># 忽略结尾的换行符</span></span><br><span class="line">-e<span class="comment"># 激活转义字符</span></span><br><span class="line">-E<span class="comment"># disable转义字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>打印彩色输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 彩色文本</span></span><br><span class="line"><span class="comment"># 重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;31m This is red text \e[0m"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 彩色背景</span></span><br><span class="line"><span class="comment"># 重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;42m Green Background \e[0m"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4s\n"</span> No Name Mark</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p><code>%-5s</code> 指明了一个格式为左对齐且宽度为5的字符串替换（ <code>-</code>表示左对齐）。如果不用 <code>-</code> 指定对齐方式，字符串就采用右对齐形式。</p><p><code>%s</code> 、 <code>%c</code> 、<code>%d</code> 和 <code>%f</code> 都是格式替换符（format substitution character），其所对应的参数可以置于带引号的格式字符串之后。 </p><h3 id="1-2-替换命令-tr"><a href="#1-2-替换命令-tr" class="headerlink" title="1.2 替换命令 tr"></a>1.2 替换命令 tr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tr 是 translate的简写</span></span><br><span class="line">$ tr <span class="string">'\0'</span> <span class="string">'\n'</span><span class="comment"># 将 \0 替换成 \n</span></span><br><span class="line">$ tr [选项]… 集合1 [集合2]</span><br><span class="line">选项说明：</span><br><span class="line">-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。</span><br><span class="line">-d, –delete 删除集合1中的字符而不是转换</span><br><span class="line">-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。</span><br><span class="line">-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符</span><br><span class="line"></span><br><span class="line">字符集合的范围：</span><br><span class="line">\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)</span><br><span class="line">\\ 反斜杠</span><br><span class="line">\a Ctrl-G 铃声</span><br><span class="line">\b Ctrl-H 退格符</span><br><span class="line">\f Ctrl-L 走行换页</span><br><span class="line">\n Ctrl-J 新行</span><br><span class="line">\r Ctrl-M 回车</span><br><span class="line">\t Ctrl-I tab键</span><br><span class="line">\v Ctrl-X 水平制表符</span><br><span class="line">CHAR1-CHAR2 从CHAR1 到 CHAR2的所有字符按照ASCII字符的顺序</span><br><span class="line">[CHAR*] <span class="keyword">in</span> SET2, copies of CHAR until length of SET1</span><br><span class="line">[CHAR*REPEAT] REPEAT copies of CHAR, REPEAT octal <span class="keyword">if</span> starting with 0</span><br><span class="line">[:alnum:] 所有的字母和数字</span><br><span class="line">[:alpha:] 所有字母</span><br><span class="line">[:blank:] 水平制表符，空白等</span><br><span class="line">[:cntrl:] 所有控制字符</span><br><span class="line">[:digit:] 所有的数字</span><br><span class="line">[:graph:] 所有可打印字符，不包括空格</span><br><span class="line">[:lower:] 所有的小写字符</span><br><span class="line">[:<span class="built_in">print</span>:] 所有可打印字符，包括空格</span><br><span class="line">[:punct:] 所有的标点字符</span><br><span class="line">[:space:] 所有的横向或纵向的空白</span><br><span class="line">[:upper:] 所有大写字母</span><br></pre></td></tr></table></figure><h3 id="1-3-打印变量"><a href="#1-3-打印变量" class="headerlink" title="1.3 打印变量"></a>1.3 打印变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ var=<span class="string">"value"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">或者</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-设置环境变量"><a href="#1-4-设置环境变量" class="headerlink" title="1.4 设置环境变量"></a>1.4 设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在PATH中添加一条新路径</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:/home/user/bin"</span></span><br><span class="line">也可以使用：</span><br><span class="line">$ PATH=<span class="string">"<span class="variable">$PATH</span>:/home/user/bin"</span></span><br><span class="line">$ <span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure><h3 id="1-5-Shell中三种引号的用法"><a href="#1-5-Shell中三种引号的用法" class="headerlink" title="1.5 Shell中三种引号的用法"></a>1.5 Shell中三种引号的用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="comment"># 使用单引号时，变量不会被扩展（expand），将依照原样显示。</span></span><br><span class="line">$ var=<span class="string">"123"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'$var'</span> will <span class="built_in">print</span> <span class="variable">$var</span></span><br><span class="line">结果为：<span class="string">'$var'</span> will <span class="built_in">print</span> 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="comment"># 输出引号中的内容，若存在命令、变量等，会先执行命令解析出结果再输出</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span> will <span class="built_in">print</span> <span class="variable">$var</span></span><br><span class="line">结果为：123 will <span class="built_in">print</span> 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反引号</span></span><br><span class="line"><span class="comment"># 命令替换</span></span><br><span class="line">$ var=`whoami`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">结果为：root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备注：反引号和$()作用相同</span></span><br></pre></td></tr></table></figure><h3 id="1-6-获得字符串的长度"><a href="#1-6-获得字符串的长度" class="headerlink" title="1.6 获得字符串的长度"></a>1.6 获得字符串的长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法</span></span><br><span class="line">$ length=<span class="variable">$&#123;#var&#125;</span></span><br><span class="line"></span><br><span class="line">$ var=12345678901234567890</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="1-7-识别当前shell"><a href="#1-7-识别当前shell" class="headerlink" title="1.7 识别当前shell"></a>1.7 识别当前shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">也可以使用：</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br></pre></td></tr></table></figure><h3 id="1-8-使用shell进行数学运算"><a href="#1-8-使用shell进行数学运算" class="headerlink" title="1.8 使用shell进行数学运算"></a>1.8 使用shell进行数学运算</h3><p>在Bash shell环境中，可以利用 <code>let</code>、<code>(( ))</code> 和<code>[]</code> 执行基本的算术操作。而在进行高级操作时，<code>expr</code> 和 <code>bc</code> 这两个工具也会非常有用。</p><p>使用 <code>let</code> 时，变量名之前不需要再添加 <code>$</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ no1=4</span><br><span class="line">$ <span class="built_in">let</span> no1++</span><br><span class="line">$ <span class="built_in">let</span> no1+=6<span class="comment"># 等同于let no=no+6</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 操作符[]的使用方法和let命令类似</span></span><br><span class="line">$ result=$[ no1 + no2 ]</span><br><span class="line"><span class="comment"># 在[]中也可以使用$前缀</span></span><br><span class="line">$ result=$[ <span class="variable">$no1</span> + 5 ]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用(())时，变量名之前需要加上$</span></span><br><span class="line">$ result=$(( no1 + 50 ))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># expr同样可以用于基本算术操作</span></span><br><span class="line">$ result=`expr 3 + 4`</span><br><span class="line">$ result=$(expr <span class="variable">$no1</span> + 5)</span><br></pre></td></tr></table></figure><p>bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项 。此处不多介绍。</p><h3 id="1-9-shell中各种括号的作用-、-、-、-、"><a href="#1-9-shell中各种括号的作用-、-、-、-、" class="headerlink" title="1.9 shell中各种括号的作用()、(())、[]、[[]]、{}"></a>1.9 shell中各种括号的作用()、(())、[]、[[]]、{}</h3><h4 id="1-9-1-小括号，圆括号（）"><a href="#1-9-1-小括号，圆括号（）" class="headerlink" title="1.9.1 小括号，圆括号（）"></a>1.9.1 小括号，圆括号（）</h4><p>1、单小括号 ( )</p><ul><li><strong>命令组。</strong>括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。</li><li><strong>命令替换。</strong>等同于<code>cmd</code>，shell扫描一遍命令行，发现了<code>$(cmd)结构</code> ，便将 <code>$(cmd)</code> 中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</li><li><strong>用于初始化数组。</strong>如：array=(a b c d)。</li></ul><p>2、双小括号 (( ))</p><ul><li><strong>整数扩展。</strong>这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。</li><li><strong>只要括号中的运算符、表达式符合C语言运算规则，都可用在 <code>$((exp))</code>中，甚至是三目运算符</strong>。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)。</li><li><strong>单纯用 (( )) 也可重定义变量值</strong>，比如 a=5; ((a++)) 可将 $a 重定义为6。</li><li><strong>常用于算术运算比较，双括号中的变量可以不使用<code>$</code> 符号前缀</strong>。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i&lt;5;i++)), 如果不使用双括号, 则为for i in <code>seq 0 4</code>或者for i in {0..4}。再如可以直接使用 <code>if (($i&lt;5))</code> , 如果不使用双括号, 则为 <code>if [ $i -lt 5 ]</code> 。</li></ul><h4 id="1-9-2-中括号，方括号"><a href="#1-9-2-中括号，方括号" class="headerlink" title="1.9.2 中括号，方括号[]"></a>1.9.2 中括号，方括号[]</h4><p>1、单中括号 []</p><ul><li>bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</li><li>Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</li><li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</li><li>在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</li></ul><p>2、双中括号 [[ ]]</p><ul><li>[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</li><li>支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</li><li>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用 <code>if [[ $a != 1 &amp;&amp; $a != 2 ]]</code> , 如果不适用双括号, 则为 <code>if [ $a -ne 1] &amp;&amp; [ $a != 2 ]</code>或者 <code>if [ $a -ne 1 -a $a != 2 ]</code> 。</li><li>bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</li></ul><h4 id="1-9-3-大括号、花括号"><a href="#1-9-3-大括号、花括号" class="headerlink" title="1.9.3 大括号、花括号 {}"></a>1.9.3 大括号、花括号 {}</h4><p>1）常规用法</p><ul><li>大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt</li><li>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</li></ul><p>2）几种特殊的替换结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var:-string&#125;</span>,<span class="variable">$&#123;var:+string&#125;</span>,<span class="variable">$&#123;var:=string&#125;</span>,<span class="variable">$&#123;var:?string&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>${var:-string}</code> 和 <code>${var:=string}:</code> 若变量var为空，则用在命令行中用string来替换 <code>${var:-string}</code>，否则变量var不为空时，则用变量var的值来替换 <code>${var:-string}</code> ；对于 <code>${var:=string}</code> 的替换规则和 <code>${var:-string}</code> 是一样的，所不同之处是 <code>${var:=string}</code> 若var为空时，用string替换 <code>${var:=string}</code> 的同时，把string赋给变量 <code>var： ${var:=string}</code> 很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</li><li><code>${var:+string}</code> 的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 。</li><li><code>${var:?string}</code> 替换规则为：若变量var不为空，则用变量var的值来替换 <code>${var:?string}</code> ；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。</li></ul><p>补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p><p>3）四种模式匹配替换结构</p><p>模式匹配记忆方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 是去掉左边(在键盘上#在$之左边)</span><br><span class="line">% 是去掉右边(在键盘上%在$之右边)</span><br><span class="line">#和%中的单一符号是最小匹配，两个相同符号是最大匹配。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var%pattern&#125;</span>,<span class="variable">$&#123;var%%pattern&#125;</span>,<span class="variable">$&#123;var#pattern&#125;</span>,<span class="variable">$&#123;var##pattern&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第一种模式：<code>${variable%pattern}</code> ，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式</li></ul><ul><li>第二种模式：<code>${variable%%pattern}</code>，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</li><li>第三种模式：<code>${variable#pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式</li><li>第四种模式：<code>${variable##pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</li></ul><p>这四种模式中都不会改变variable的值，其中，只有在pattern中使用了匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。</p><p>4）字符串提取和替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var:num&#125;</span>,<span class="variable">$&#123;var:num1:num2&#125;</span>,<span class="variable">$&#123;var/pattern/pattern&#125;</span>,<span class="variable">$&#123;var//pattern/pattern&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第一种模式：<code>${var:num}</code> ，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如 <code>${var: -2}</code> 、<code>${var:1-3}</code> 或 <code>${var:(-2)}</code>。         </li><li>第二种模式：<code>${var:num1:num2}</code>，num1是位置，num2是长度。表示从 <code>$var字符串的第$num1</code> 个位置开始提取长度为$num2的子串。不能为负数。</li><li>第三种模式：<code>${var/pattern/pattern}</code>表示将var字符串的第一个匹配的pattern替换为另一个pattern。。         </li><li>第四种模式：<code>${var//pattern/pattern}</code> 表示将var字符串中的所有能匹配的pattern替换为另一个pattern。</li></ul><h4 id="1-9-4-符号-后的括号"><a href="#1-9-4-符号-后的括号" class="headerlink" title="1.9.4 符号$后的括号"></a>1.9.4 符号$后的括号</h4><ul><li><code>${a}</code> 变量a的值, 在不引起歧义的情况下可以省略大括号。</li><li><code>$(cmd)</code>  命令替换，和<code>cmd</code>效果相同，结果为shell命令cmd的输，过某些Shell版本不支持 <code>$()</code> 形式的命令替换, 如tcsh。</li><li><code>$((expression))</code> 和<code>exprexpression</code>效果相同, 计算数学表达式exp的数值, 其中exp只要符合<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2M=" title="http://lib.csdn.net/base/c">C语言<i class="fa fa-external-link"></i></span>的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。</li></ul><h4 id="1-9-5-多条命令执行"><a href="#1-9-5-多条命令执行" class="headerlink" title="1.9.5 多条命令执行"></a>1.9.5 多条命令执行</h4><ul><li>单小括号，<code>(cmd1;cmd2;cmd3)</code>  新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。</li><li>单大括号，<code>{ cmd1;cmd2;cmd3;}</code>  在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。</li></ul><p>对 <code>{}</code> 和 <code>()</code> 而言, 括号中的重定向符只影响该条命令，而括号外的重定向符影响到括号中的所有命令。</p><h3 id="1-10-Shell特殊变量-0-和命令行参数"><a href="#1-10-Shell特殊变量-0-和命令行参数" class="headerlink" title="1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数"></a>1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数</h3><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名。</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n是一个数字，表示几个参数。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有采纳数。被双引号(“ “)包含是，与$* 稍有不同。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前shell进程ID。对于shell脚本，就是这个脚本所在的进程ID。</td></tr></tbody></table><h4 id="1-10-1-命令行参数"><a href="#1-10-1-命令行参数" class="headerlink" title="1.10.1 命令行参数"></a>1.10.1 命令行参数</h4><p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 <code>$n</code> 表示，例如，<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数，依次类推。</p><h4 id="1-10-2-和-的区别"><a href="#1-10-2-和-的区别" class="headerlink" title="1.10.2 $* 和 $@ 的区别"></a>1.10.2 <code>$*</code> 和 <code>$@</code> 的区别</h4><p><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</p><p>但是当它们被双引号(“ “)包含时，<code>&quot;$*&quot;</code> 会将所有的参数作为一个整体，以<code>&quot;$1 $2 … $n&quot;</code> 的形式输出所有参数；<code>&quot;$@&quot;</code> 会将各个参数分开，以 <code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code>的形式输出所有参数。</p><h4 id="1-10-3-退出状态"><a href="#1-10-3-退出状态" class="headerlink" title="1.10.3 退出状态"></a>1.10.3 退出状态</h4><p><code>$?</code> 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。</p><p>退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</p><p>不过，也有一些命令返回其他值，表示不同类型的错误。</p><p><code>$?</code> 也可以表示函数的返回值，此处不展开。</p><h3 id="1-11-Shell重定向"><a href="#1-11-Shell重定向" class="headerlink" title="1.11 Shell重定向"></a>1.11 Shell重定向</h3><p>1、重定向符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;               输出重定向到一个文件或设备 覆盖原来的文件</span><br><span class="line">&gt;!              输出重定向到一个文件或设备 强制覆盖原来的文件</span><br><span class="line">&gt;&gt;              输出重定向到一个文件或设备 追加原来的文件</span><br><span class="line">&lt;               输入重定向到一个程序</span><br></pre></td></tr></table></figure><p>2、标准输入刷出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 bash 命令执行的过程中，主要有三种输出入的状况，分别是：</span><br><span class="line">1. 标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt;</span><br><span class="line">2. 标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt;</span><br><span class="line">3. 错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt;</span><br></pre></td></tr></table></figure><p>3、使用实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。</span></span><br><span class="line"><span class="comment"># 1&gt;&amp;2 意思是把标准输出重定向到标准错误.</span></span><br><span class="line"><span class="comment"># 2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。</span></span><br><span class="line"><span class="comment"># &amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中</span></span><br><span class="line"></span><br><span class="line">$ cmd &lt;&gt; file<span class="comment"># 以读写方式打开文件 file</span></span><br><span class="line">$ cmd &gt;&amp;n<span class="comment"># 将 cmd 的输出发送到文件描述符 n</span></span><br><span class="line">$ cmd m&gt;&amp;n<span class="comment"># 将本该输出到文件描述符 m 的内容, 发送到文件描述符 n</span></span><br><span class="line">$ cmd m&lt;&amp;n <span class="comment"># 除了本该从文件描述符 m 处获取输入，改为从文件描述符 n 处获取</span></span><br><span class="line">$ cmd &gt;&amp;-<span class="comment"># 关闭标准输出</span></span><br><span class="line">$ cmd &lt;&amp;-<span class="comment"># 关闭标准输入</span></span><br><span class="line">$ cmd  &gt;&amp; file<span class="comment"># 将标准输出和标准错误都发送到文件 file </span></span><br><span class="line">$ cmd  &amp;&gt; file<span class="comment"># 作用同上, 更好的格式</span></span><br></pre></td></tr></table></figure><p>要在终端中打印stdout，同时将它重定向到一个文件中，那么可以这样使用tee 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法：command | tee FILE1 FILE2</span></span><br><span class="line">$ cat a* | tee out.txt | cat -n</span><br><span class="line"><span class="comment"># 默认情况下， tee命令会将文件覆盖，但它提供了一个-a选项，用于追加内容</span></span><br><span class="line">$ cat a* | tee -a out.txt | cat –n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以使用stdin作为命令参数。只需要将-作为命令的文件名参数即可</span></span><br><span class="line"><span class="comment"># 用法：$ cmd1 | cmd2 | cmd -</span></span><br><span class="line">$ <span class="built_in">echo</span> who is this | tee -</span><br></pre></td></tr></table></figure><h3 id="1-12-Shell数组和关联数组"><a href="#1-12-Shell数组和关联数组" class="headerlink" title="1.12 Shell数组和关联数组"></a>1.12 Shell数组和关联数组</h3><h4 id="1-12-1-简介"><a href="#1-12-1-简介" class="headerlink" title="1.12.1 简介"></a>1.12.1 简介</h4><p>数组是Shell脚本非常重要的组成部分，它借助索引将多个独立的独立的数据存储为一个集合。普通数组只能使用整数作为数组索引，关联数组不仅可以使用整数作为索引，也可以使用字符串作为索引。通常情况下，使用字符串做索引更容易被人们理解。Bash从4.0之后开始引入关联数组。</p><h4 id="1-12-2-定义打印普通数组"><a href="#1-12-2-定义打印普通数组" class="headerlink" title="1.12.2 定义打印普通数组"></a>1.12.2 定义打印普通数组</h4><p>数组的方法有如下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在一行上列出所有元素</span></span><br><span class="line">$ array_var=(1 2 3 4 5 6)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以“索引-值”的形式一一列出</span></span><br><span class="line">$ array_var[0]=<span class="string">"test1"</span></span><br><span class="line">$ array_var[1]=<span class="string">"test2"</span></span><br><span class="line">$ array_var[2]=<span class="string">"test3"</span></span><br></pre></td></tr></table></figure><p>注意：第一种方法要使用圆括号，否则后面会报错。</p><p>数组元素的方法有如下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[0]&#125;</span>         <span class="comment">#输出结果为 test1</span></span><br><span class="line">$ index=2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[$index]&#125;</span>    <span class="comment">#输出结果为 test3</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[*]&#125;</span>         <span class="comment">#输出所有数组元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[@]&#125;</span>         <span class="comment">#输出所有数组元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#array_var[*]&#125;</span>        <span class="comment">#输出值为 3</span></span><br></pre></td></tr></table></figure><p>注意：在ubuntu 14.04中，shell脚本要以#!/bin/bash开头，且执行脚本的方式为 bash test.sh。</p><h4 id="1-12-3-定义打印关联数组"><a href="#1-12-3-定义打印关联数组" class="headerlink" title="1.12.3 定义打印关联数组"></a>1.12.3 定义打印关联数组</h4><p>定义关联数组<br>在关联数组中，可以使用任何文本作为数组索引。定义关联数组时，首先需要使用声明语句将一个变量声明为关联数组，然后才可以在数组中添加元素，过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -A ass_array                           <span class="comment">#声明一个关联数组</span></span><br><span class="line">$ ass_array=([<span class="string">"index1"</span>]=index1 [<span class="string">"index2"</span>]=index2)<span class="comment">#内嵌“索引-值”列表法</span></span><br><span class="line">$ ass_array[<span class="string">"index3"</span>]=index3</span><br><span class="line">$ ass_array[<span class="string">"index4"</span>]=index4</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;ass_array["index1"]&#125;</span>                    <span class="comment">#输出为index1</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;ass_array["index4"]&#125;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[*]&#125;</span>                          <span class="comment">#输出索引列表</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[@]&#125;</span>                          <span class="comment">#输出索引列表</span></span><br></pre></td></tr></table></figure><p>注意：对于普通数组，使用上面的方法依然可以列出索引列表，在声明关联数组以及添加数组元素时，都不能在前面添加美元符$。</p><h3 id="1-13-使用别名"><a href="#1-13-使用别名" class="headerlink" title="1.13 使用别名"></a>1.13 使用别名</h3><p>alias命令的作用只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名设置一直保持作用，可以将它放入~/.bashrc文件中。因为每当一个新的shell进程生成时，都会执行 ~/.bashrc中的命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> install=<span class="string">'sudo apt-get install'</span></span><br></pre></td></tr></table></figure><h3 id="1-14-获取、设置日期和延时"><a href="#1-14-获取、设置日期和延时" class="headerlink" title="1.14 获取、设置日期和延时"></a>1.14 获取、设置日期和延时</h3><p>时间方面 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% : 印出</span><br><span class="line">% %n : 下一行</span><br><span class="line">%t : 跳格</span><br><span class="line">%H : 小时(00..23)</span><br><span class="line">%I : 小时(01..12)</span><br><span class="line">%k : 小时(0..23)</span><br><span class="line">%l : 小时(1..12)</span><br><span class="line">%M : 分钟(00..59)</span><br><span class="line">%p : 显示本地 AM 或 PM</span><br><span class="line">%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</span><br><span class="line">%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数 %S : 秒(00..61)</span><br><span class="line">%T : 直接显示时间 (24 小时制)</span><br><span class="line">%X : 相当于 %H:%M:%S</span><br><span class="line">%Z : 显示时区</span><br></pre></td></tr></table></figure><p>日期方面 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%a : 星期几 (Sun..Sat)</span><br><span class="line">%A : 星期几 (Sunday..Saturday)</span><br><span class="line"></span><br><span class="line">%b : 月份 (Jan..Dec)</span><br><span class="line">%B : 月份 (January..December)</span><br><span class="line"></span><br><span class="line">%y : 年份的最后两位数字 (00.99)</span><br><span class="line">%Y : 完整年份 (0000..9999)</span><br><span class="line"></span><br><span class="line">%c : 直接显示日期与时间</span><br><span class="line">%d : 日 (01..31)</span><br><span class="line">%D : 直接显示日期 (mm/dd/yy)</span><br><span class="line">%h : 同 %b</span><br><span class="line">%j : 一年中的第几天 (001..366)</span><br><span class="line">%m : 月份 (01..12)</span><br><span class="line">%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)</span><br><span class="line">%w : 一周中的第几天 (0..6)</span><br><span class="line">%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)</span><br><span class="line">%x : 直接显示日期 (mm/dd/yy)</span><br></pre></td></tr></table></figure><p>若是不以加号作为开头，则表示要设定时间，而时间格式为 <code>MMDDhhmm[[CC]YY][.ss]</code>，其中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MM 为月份，</span><br><span class="line">DD 为日，</span><br><span class="line">hh 为小时，</span><br><span class="line">mm 为分钟，</span><br><span class="line">CC 为年份前两位数字，</span><br><span class="line">YY 为年份后两位数字，</span><br><span class="line">ss 为秒数</span><br></pre></td></tr></table></figure><p>参数 :</p><p>-d datestr : 显示 datestr 中所设定的时间 (非系统时间)</p><p>–help : 显示辅助讯息</p><p>-s datestr : 将系统时间设为 datestr 中所设定的时间</p><p>-u : 显示目前的格林威治时间</p><p>–version : 显示版本编号</p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ date<span class="comment"># 获取日期</span></span><br><span class="line">$ date +%s<span class="comment"># 打印纪元时</span></span><br><span class="line">$ date <span class="string">"+%d %B %Y"</span><span class="comment"># 用格式串结合 + 作为date命令的参数，可以按照你的选择打印出对应格式的日期</span></span><br><span class="line">20 May 2010</span><br><span class="line">$ date -s <span class="string">"21 June 2009 11:01:22"</span> <span class="comment"># 设置日期和时间</span></span><br></pre></td></tr></table></figure><h3 id="1-15-脚本调试"><a href="#1-15-脚本调试" class="headerlink" title="1.15 脚本调试"></a>1.15 脚本调试</h3><h4 id="1-15-1使用选项–x，启用shell脚本的跟踪调试功能"><a href="#1-15-1使用选项–x，启用shell脚本的跟踪调试功能" class="headerlink" title="1.15.1使用选项–x，启用shell脚本的跟踪调试功能"></a>1.15.1使用选项–x，启用shell脚本的跟踪调试功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash -x script.sh</span><br></pre></td></tr></table></figure><h4 id="1-15-2-使用set-x和set-x对脚本进行部分调试"><a href="#1-15-2-使用set-x和set-x对脚本进行部分调试" class="headerlink" title="1.15.2 使用set -x和set +x对脚本进行部分调试"></a>1.15.2 使用set -x和set +x对脚本进行部分调试</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#文件名: debug.sh</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.6</span>&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">set</span> -x</span><br><span class="line">echo $i</span><br><span class="line"><span class="keyword">set</span> +x</span><br><span class="line">done</span><br><span class="line">echo <span class="string">"Script executed"</span></span><br></pre></td></tr></table></figure><ul><li>set –x：在执行时显示参数和命令。 </li><li>set +x：禁止调试。 </li><li>set –v：当命令进行读取时显示输入。 </li><li>set +v：禁止打印输入。 </li></ul><h4 id="1-15-3-通过传递-DEBUG环境变量调试"><a href="#1-15-3-通过传递-DEBUG环境变量调试" class="headerlink" title="1.15.3 通过传递 _DEBUG环境变量调试"></a>1.15.3 通过传递 _DEBUG环境变量调试</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DEBUG</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">[ <span class="string">"$_DEBUG"</span> == <span class="string">"on"</span> ] &amp;&amp; $@ || :</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.10</span>&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">DEBUG echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>可以将调试功能置为”on”来运行上面的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ _DEBUG=on ./script.sh</span><br></pre></td></tr></table></figure><p>我们在每一个需要打印调试信息的语句前加上DEBUG。如果没有把 _DEBUG=on传递给脚本，那么调试信息就不会打印出来。在Bash中，命令 <code>:</code> 告诉shell不要进行任何操作。 </p><h4 id="1-15-4-利用shebang来进行调试"><a href="#1-15-4-利用shebang来进行调试" class="headerlink" title="1.15.4 利用shebang来进行调试"></a>1.15.4 利用shebang来进行调试</h4><p>shebang的妙用<br>把shebang从 <code>#!/bin/bash</code> 改成 <code>#!/bin/bash -xv</code>，这样一来，不用任何其他选项就可以启用调试功能了。 </p><h3 id="1-16-函数参数"><a href="#1-16-函数参数" class="headerlink" title="1.16 函数参数"></a>1.16 函数参数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$<span class="number">0</span> # 脚本名</span><br><span class="line">$<span class="number">1</span># 第一个参数</span><br><span class="line">$<span class="number">2</span># 第二个参数</span><br><span class="line">$n# 第n个参数</span><br><span class="line"><span class="string">"$@"</span># 被扩展成 <span class="string">"$1"</span> <span class="string">"$2"</span> <span class="string">"$3"</span>等</span><br><span class="line"><span class="string">"$*"</span># 被扩展成 <span class="string">"$1c$2c$3"</span>，其中c是IFS的第一个字符</span><br><span class="line"><span class="string">"$@"</span> 要比<span class="string">"$*"</span>用得多。由于 <span class="string">"$*"</span>将所有的参数当做单个字符串，因此它很少被使用。</span><br></pre></td></tr></table></figure><p><strong>导出函数：</strong></p><p>函数也能像环境变量一样用export导出，如此一来，函数的作用域就可以扩展到子进程中，例如： </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> -f fname</span><br></pre></td></tr></table></figure><h3 id="1-17-read命令"><a href="#1-17-read命令" class="headerlink" title="1.17 read命令"></a>1.17 read命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从输入中读取n个字符并存入变量</span></span><br><span class="line">$ <span class="built_in">read</span> -n 2 var</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用无回显的方式读取密码</span></span><br><span class="line">$ <span class="built_in">read</span> -s var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示提示信息</span></span><br><span class="line">$ <span class="built_in">read</span> -p <span class="string">"Enter input:"</span> var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在特定时(秒)限内读取输入</span></span><br><span class="line">$ <span class="built_in">read</span> -t timeout var</span><br></pre></td></tr></table></figure><h3 id="1-18-条件比较与测试"><a href="#1-18-条件比较与测试" class="headerlink" title="1.18 条件比较与测试"></a>1.18 条件比较与测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if条件</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># else if和else</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> condition <span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>if的条件判断部分可能会变得很长，但可以用逻辑运算符将它变得简洁一些： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition ] &amp;&amp; action <span class="comment"># 如果condition为真，则执行action</span></span><br><span class="line">[ condition ] || action <span class="comment"># 如果condition为假，则执行action</span></span><br></pre></td></tr></table></figure><p><code>&amp;&amp;</code> 是逻辑与运算符， <code>||</code> 是逻辑或运算符。编写Bash脚本时，这是一个很有用的技巧。现在来了解一下条件和比较操作。 </p><p>算术比较：</p><ul><li><code>-gt</code> ：大于。 </li><li><code>-lt</code> ：小于。 </li><li><code>-ge</code> ：大于或等于。 </li><li><code>-le</code> ：小于或等于。 </li></ul><p>可以按照下面的方法结合多个条件进行测试： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="variable">$var1</span> -ne 0 -a <span class="variable">$var2</span> -gt 2 ] <span class="comment">#使用逻辑与-a</span></span><br><span class="line">[ <span class="variable">$var1</span> -ne 0 -o var2 -gt 2 ] <span class="comment">#逻辑或 -o</span></span><br></pre></td></tr></table></figure><p>文件系统相关测试：</p><p>我们可以使用不同的条件标志测试不同的文件系统相关的属性。 </p><ul><li><code>[ -f $file_var ]</code> ：如果给定的变量包含正常的文件路径或文件名，则返回真。 </li><li><code>[ -x $var ]</code> ：如果给定的变量包含的文件可执行，则返回真。 </li><li><code>[ -d $var ]</code> ：如果给定的变量包含的是目录，则返回真。 </li><li><code>[ -e $var ]</code> ：如果给定的变量包含的文件存在，则返回真。 </li><li><code>[ -c $var ]</code> ：如果给定的变量包含的是一个字符设备文件的路径，则返回真。 </li><li><code>[ -b $var ]</code> ：如果给定的变量包含的是一个块设备文件的路径，则返回真。 </li><li><code>[ -w $var ]</code> ：如果给定的变量包含的文件可写，则返回真。 </li><li><code>[ -r $var ]</code> ：如果给定的变量包含的文件可读，则返回真。 </li><li><code>[ -L $var ]</code> ：如果给定的变量包含的是一个符号链接，则返回真。 </li></ul><p>字符串比较：</p><p style="color: red;">使用字符串比较时，最好用双中括号，因为有时候采用单个中括号会产生错误，所以最好避开它们。 </p><p>可以用下面的方法检查两个字符串，看看它们是否相同。 </p><ul><li><code>[[ $str1 = $str2 ]]</code>：当str1等于str2时，返回真。也就是说， str1和str2包含<br>的文本是一模一样的。 </li><li><code>[[ $str1 == $str2 ]]</code> ：这是检查字符串是否相等的另一种写法。 </li></ul><p>也可以检查两个字符串是否不同。 </p><ul><li><code>[[ $str1 != $str2 ]]</code> ：如果str1和str2不相同，则返回真。 </li></ul><p>我们还可以检查字符串的字母序情况，具体如下所示。 </p><ul><li><code>[[ $str1 &gt; $str2 ]]</code> ：如果str1的字母序比str2大，则返回真。 </li><li><code>[[ $str1 &lt; $str2 ]]</code> ：如果str1的字母序比str2小，则返回真。 </li><li><code>[[ -z $str1 ]]</code> ：如果str1包含的是空字符串，则返回真。 </li><li><code>[[ -n $str1 ]]</code> ：如果str1包含的是非空字符串，则返回真。 </li></ul><p>使用逻辑运算符 &amp;&amp; 和 || 能够很容易地将多个条件组合起来： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$str1</span> ]] &amp;&amp; [[ -z <span class="variable">$str2</span> ]] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>test命令可以用来执行条件检测。用test可以避免使用过多的括号。之前讲过的[]中的测试条件同样可以用于test命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> -eq 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"True"</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 也可以写成：</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$var</span> -eq 0 ; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"True"</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><h4 id="1-利用子shell生成一个独立的进程"><a href="#1-利用子shell生成一个独立的进程" class="headerlink" title="1. 利用子shell生成一个独立的进程"></a>1. 利用子shell生成一个独立的进程</h4><p>子shell本身就是独立的进程。可以使用 <code>( )</code>操作符来定义一个子shell ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd;</span><br><span class="line">(cd /bin; ls);</span><br><span class="line">pwd;</span><br></pre></td></tr></table></figure><h4 id="2-无限循环的实例"><a href="#2-无限循环的实例" class="headerlink" title="2. 无限循环的实例"></a>2. 无限循环的实例</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> $@ &amp;&amp; <span class="keyword">return</span>; done &#125;</span><br></pre></td></tr></table></figure><p>工作原理：</p><p>函数repeat，它包含了一个无限while循环，该循环执行以参数形式（通过 <code>$@</code> 访问）传入函数的命令。如果命令执行成功，则返回，进而退出循环。 </p><p><strong>一种更快的做法 ：</strong></p><p>在大多数现代系统中， <code>true</code> 是作为 <code>/bin</code> 中的一个二进制文件来实现的。</p><p style="color: red;">这就意味着每执行一次while循环， shell就不得不生成一个进程。</p>如果不想这样，可以使用shell内建的 <code>:</code>命令，它总是会返回为0的退出码： <p></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; <span class="keyword">while</span> :; <span class="keyword">do</span> $@ &amp;&amp; <span class="keyword">return</span>; done &#125;</span><br></pre></td></tr></table></figure><p>尽管可读性不高，但是肯定比第一种方法快。 </p><h2 id="2-命令之乐"><a href="#2-命令之乐" class="headerlink" title="2. 命令之乐"></a>2. 命令之乐</h2><h3 id="2-1-cat命令"><a href="#2-1-cat命令" class="headerlink" title="2.1 cat命令"></a>2.1 cat命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摆脱多余的空白行</span></span><br><span class="line">$ cat -s file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示行号</span></span><br><span class="line">$ cat -n file</span><br><span class="line"><span class="comment"># -n甚至会为空白行加上行号。如果你想跳过空白行，那么可以使用选项-b。</span></span><br></pre></td></tr></table></figure><h3 id="2-2-find命令"><a href="#2-2-find命令" class="headerlink" title="2.2 find命令"></a>2.2 find命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录及子目录下所有的文件和文件夹</span></span><br><span class="line">$ find base_path</span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># -print指明打印出匹配文件的文件名（路径）。当使用 -print时， '\n'作为用于对输出的文件名进行分隔。就算你忽略-print， find命令仍会打印出文件名。</span></span><br><span class="line"><span class="comment"># -print0指明使用'\0'作为匹配的文件名之间的定界符。</span></span><br></pre></td></tr></table></figure><p>1、find命令有一个选项 <code>-iname</code>（忽略字母大小写） </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">example.txt EXAMPLE.txt file.txt</span><br><span class="line">$ find . -iname <span class="string">"example*"</span> -<span class="built_in">print</span></span><br><span class="line">./example.txt</span><br><span class="line">./EXAMPLE.txt</span><br></pre></td></tr></table></figure><p>2、如果想匹配多个条件中的一个，可以采用OR条件操作 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">new.txt some.jpg text.pdf</span><br><span class="line">$ find . \( -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span> \) -<span class="built_in">print</span></span><br><span class="line">./text.pdf</span><br><span class="line">./new.txt</span><br></pre></td></tr></table></figure><p>3、选项-path的参数可以使用通配符来匹配文件路径。 <code>-name</code> 总是用给定的文件名进行匹配。<code>-path</code> 则将文件路径作为一个整体进行匹配。例如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find /home/users -path <span class="string">"*/slynux/*"</span> -<span class="built_in">print</span></span><br><span class="line">/home/users/list/slynux.txt</span><br><span class="line">/home/users/slynux/eg.css</span><br></pre></td></tr></table></figure><p>4、选项 <code>-regex</code> 的参数和 <code>-path</code> 的类似，只不过 <code>-regex</code> 是基于正则表达式来匹配文件路径的。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">new.PY next.jpg test.py</span><br><span class="line">$ find . -regex <span class="string">".*\(\.py\|\.sh\)$"</span></span><br><span class="line">./test.py</span><br><span class="line"><span class="comment"># 类似地， -iregex可以让正则表达式忽略大小写。例如：</span></span><br><span class="line">$ find . -iregex <span class="string">".*\(\.py\|\.sh\)$"</span></span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure><p>5、find也可以用“!”否定参数的含义。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">list.txt new.PY new.txt next.jpg test.py</span><br><span class="line">$ find . ! -name <span class="string">"*.txt"</span> -<span class="built_in">print</span></span><br><span class="line">.</span><br><span class="line">./next.jpg</span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure><p>6、基于目录深度的搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 深度选项-maxdepth和 -mindepth来限制find命令遍历的目录深度</span></span><br><span class="line"><span class="comment"># 下列命令将find命令向下的最大深度限制为1:</span></span><br><span class="line">$ find . -maxdepth 1 -name <span class="string">"f*"</span> -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出深度距离当前目录至少两个子目录的所有文件:</span></span><br><span class="line">$ find . -mindepth 2 -name <span class="string">"f*"</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>-maxdepth和-mindepth应该作为find的第三个参数出现。如果作为第4个或之后的参数，就可能会影响到find的效率，因为它不得不进行一些不必要的检查。 </p><p>根据文件类型搜索</p><p>7、根据文件类型搜索</p><p><code>-type</code> 可以对文件搜索进行过滤 </p><table><thead><tr><th>文件类型</th><th>类型参数</th></tr></thead><tbody><tr><td>普通文件</td><td>f</td></tr><tr><td>符号链接</td><td>l</td></tr><tr><td>目录</td><td>d</td></tr><tr><td>字符设备</td><td>c</td></tr><tr><td>块设备</td><td>b</td></tr><tr><td>套接字</td><td>s</td></tr><tr><td>FIFO</td><td>p</td></tr></tbody></table><p>8、根据文件时间进行搜索</p><ul><li>访问时间（-atime）：用户最近一次访问文件的时间。</li><li>修改时间（-mtime）：文件内容最后一次被修改的时间。</li><li>变化时间（-ctime）：文件元数据（例如权限或所有权）最后一次改变的时间。</li></ul><blockquote><p>-atime、 -mtime、 -ctime可作为find的时间选项。它们可以用整数值指定，单位是天。这些整数值通常还带有 - 或 + ： - 表示小于， + 表示大于。 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出在最近7天内被访问过的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime -7 -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出恰好在7天前被访问过的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime 7 -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出访问时间超过7天的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime +7 -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>-atime、 -mtime以及-ctime都是基于时间的参数，其计量单位是“天”。还有其他一些基于时间的参数是以分钟作为计量单位的。这些参数包括： </p><ul><li>-amin（访问时间）</li><li>-mmin（修改时间）</li><li>-cmin（变化时间）</li></ul><p>使用 <code>-newer</code> ，我们可以指定一个用于比较时间戳的参考文件，然后找出比参考文件更新的（更近的修改时间）所有文件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出比file.txt修改时间更近的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -newer file.txt -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>9、基于文件大小的搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -size +2k</span><br><span class="line"><span class="comment"># 大于2KB的文件</span></span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -size -2k</span><br><span class="line"><span class="comment"># 小于2KB的文件</span></span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -size 2k</span><br><span class="line"><span class="comment"># 大小等于2KB的文件</span></span><br></pre></td></tr></table></figure><ul><li>b —— 块（512字节）</li><li>c —— 字节</li><li>w —— 字（2字节）</li><li>k —— 1024字节</li><li>M —— 1024k字节</li><li>G —— 1024M字节</li></ul><p>10、删除匹配的文件</p><p><code>-delete</code> 可以用来删除find查找到的匹配文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除当前目录下所有的 .swp文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.swp"</span> -delete</span><br></pre></td></tr></table></figure><p>11、基于文件权限和所有权的匹配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -perm 644 -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印出权限为644的文件</span></span><br></pre></td></tr></table></figure><p>-perm指明find应该只匹配具有特定权限值的文件。 </p><p>12、利用find执行命令或动作 </p><p>find命令可以借助选项-exec与其他命名进行结合。 -exec算得上是find最强大的特性之一。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> chown slynux &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#125;是一个与 -exec选项搭配使用的特殊字符串。对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名。</span></span><br></pre></td></tr></table></figure><p><code>-exec</code> 结合多个命令 :</p><p>我们无法在-exec参数中直接使用多个命令。它只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个shell脚本中（例如command.sh），然后在-exec中使用这个脚本：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec ./commands.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>13、让find跳过特定的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find devel/source_path \( -name <span class="string">".git"</span> -prune \) -o \( -<span class="built_in">type</span> f -<span class="built_in">print</span> \)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令打印出不包括在.git目录中的所有文件的名称（路径）。</span></span><br></pre></td></tr></table></figure><p><code>\( -name &quot;.git&quot; -prune \)</code> 的作用是用于进行排除，它指明了 .git目录应该被排除在外，而<code>\( -type f -print \)</code> 指明了需要执行的动作。这些动作需要被放置在第二个语句块中（打印出所有文件的名称和路径）。 </p><h3 id="2-3-玩转xargs"><a href="#2-3-玩转xargs" class="headerlink" title="2.3 玩转xargs"></a>2.3 玩转xargs</h3><p><code>xargs</code> 擅长将标准输入数据转换成命令行参数。</p><p><code>xargs</code> 命令把从 stdin接收到的数据重新格式化，再将其作为参数提供给其他命令。 </p><h4 id="2-3-1-将多行输入转换成单行输出"><a href="#2-3-1-将多行输入转换成单行输出" class="headerlink" title="2.3.1 将多行输入转换成单行输出"></a>2.3.1 将多行输入转换成单行输出</h4><p>只需要将换行符移除，再用” “（空格）进行代替，就可以实现多行输入的转换。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.txt <span class="comment"># 样例文件</span></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">7 8 9 10</span><br><span class="line">11 12</span><br><span class="line">$ cat example.txt | xargs</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12</span><br></pre></td></tr></table></figure><h4 id="2-3-2-将单行输入转换成多行输出"><a href="#2-3-2-将单行输入转换成多行输出" class="headerlink" title="2.3.2 将单行输入转换成多行输出"></a>2.3.2 将单行输入转换成多行输出</h4><p>指定每行最大的参数数量 <code>n</code>，我们可以将任何来自stdin的文本划分成多行，每行 <code>n</code> 个参数。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.txt | xargs -n 3</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">10 11 12</span><br></pre></td></tr></table></figure><h4 id="2-3-3-定制定界符"><a href="#2-3-3-定制定界符" class="headerlink" title="2.3.3 定制定界符"></a>2.3.3 定制定界符</h4><p>用 <code>-d</code> 选项为输入指定一个定制的定界符： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X</span><br><span class="line">split split split split</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X -n 2</span><br><span class="line">split split</span><br><span class="line">split split</span><br></pre></td></tr></table></figure><p>在这里，我们明确指定X作为输入定界符，而在默认情况下， xargs采用内部字段分隔符（空格）作为输入定界符。 </p><h4 id="2-3-4-读取stdin，将格式化参数传递给命令"><a href="#2-3-4-读取stdin，将格式化参数传递给命令" class="headerlink" title="2.3.4 读取stdin，将格式化参数传递给命令"></a>2.3.4 读取stdin，将格式化参数传递给命令</h4><p><code>-I</code> 指定替换字符串，这个字符串在xargs扩展时会被替换掉。如果将 <code>-I</code> 与 <code>xargs</code> 结合使用，对于每一个参数，命令都会被执行一次。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat args.txt</span><br><span class="line">arg1</span><br><span class="line">arg2</span><br><span class="line">arg3</span><br><span class="line">$ cat args.txt | xargs -I &#123;&#125; ./cecho.sh -p &#123;&#125; -l</span><br><span class="line">-p arg1 -l <span class="comment">#</span></span><br><span class="line">-p arg2 -l <span class="comment">#</span></span><br><span class="line">-p arg3 -l <span class="comment">#</span></span><br></pre></td></tr></table></figure><p><code>-I {}</code> 指定了替换字符串。对于每一个命令参数，字符串 <code>{}</code> 都会被从stdin读取到的参数替换掉。 </p><p>使用 <code>-I</code> 的时候，命令以循环的方式执行。 </p><p>xargs和find算是一对死党。两者结合使用可以让任务变得更轻松。 不过人们通常却是以一种错误的组合方式使用它们。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">print</span> | xargs rm -f</span><br></pre></td></tr></table></figure><p>这样做很危险。 有时可能会删除不必要删除的文件。 </p><p>只要我们把 <code>find</code> 的输出作为 <code>xargs</code> 的输入，就必须将 <code>-print0</code> 与 <code>find</code> 结合使用，以字符<code>null（&#39;\0&#39;）</code>来分隔输出。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -print0 | xargs -0 rm -f</span><br><span class="line"><span class="comment"># xargs -0将\0作为输入定界符。</span></span><br><span class="line"></span><br><span class="line">$ find source_code_dir_path -<span class="built_in">type</span> f -name <span class="string">"*.c"</span> -print0 | xargs -0 wc -l</span><br><span class="line"><span class="comment"># 统计源代码目录中所有C程序文件的行数</span></span><br></pre></td></tr></table></figure><h3 id="2-4-校验和与核实"><a href="#2-4-校验和与核实" class="headerlink" title="2.4 校验和与核实"></a>2.4 校验和与核实</h3><p>校验和（checksum）程序用来从文件中生成校验和密钥，然后利用这个校验和密钥核实文件的完整性。文件可以通过网络或任何存储介质分发到不同的地点。 </p><p>最知名且使用最为广泛的校验和技术是md5sum和SHA-1。它们对文件内容使用相应的算法来生成校验和。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum filename</span><br><span class="line">68b329da9893e34099c7d8ad5cb9c940 filename</span><br><span class="line"></span><br><span class="line">$ md5sum filename &gt; file_sum.md5</span><br><span class="line"></span><br><span class="line">$ md5sum file1 file2 file3 ..</span><br><span class="line"></span><br><span class="line">$ md5sum -c file_sum.md5</span><br><span class="line"><span class="comment"># 这个命令会输出校验和是否匹配的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要用所有的.md5信息来检查所有的文件，可以使用：</span></span><br><span class="line">$ md5sum -c *.md5</span><br></pre></td></tr></table></figure><p>计算SAH-1串的命令是sha1sum。其用法和md5sum的非常相似。只需要把先前讲过的那些命令中的md5sum替换成sha1sum就行了，记住将输入文件名从file_sum.md5改为file_sum.sha1。 </p><p>对目录进行校验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ md5deep -rl directory_path &gt; directory.md5</span><br><span class="line"><span class="comment"># -r使用递归的方式</span></span><br><span class="line"><span class="comment"># -l使用相对路径。默认情况下， md5deep会输出文件的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者也可以结合find来递归计算校验和：</span></span><br><span class="line">$ find directory_path -<span class="built_in">type</span> f -print0 | xargs -0 md5sum &gt;&gt; directory.md5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的命令进行核实：</span></span><br><span class="line">$ md5sum -c directory.md5</span><br></pre></td></tr></table></figure><h4 id="2-4-1-加密工具与散列"><a href="#2-4-1-加密工具与散列" class="headerlink" title="2.4.1 加密工具与散列"></a>2.4.1 加密工具与散列</h4><p><code>crypt</code>、 <code>gpg</code>、 <code>base64</code>、 <code>md5sum</code>、 <code>sha1sum</code> 以及 <code>openssl</code> 的用法。 </p><p>1）crypt是一个简单的加密工具，它从stdin接受一个文件以及口令作为输入，然后将加密数据输出到Stdout（因此要对输入、输出文件使用重定向）。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ crypt &lt;input_file &gt;output_file</span><br><span class="line">Enter passphrase:</span><br><span class="line"><span class="comment"># 它会要求输入一个口令。我们也可以通过命令行参数来提供口令。</span></span><br><span class="line"></span><br><span class="line">$ crypt PASSPHRASE &lt;input_file &gt;encrypted_file</span><br><span class="line"><span class="comment"># 如果需要解密文件，可以使用：</span></span><br><span class="line">$ crypt PASSPHRASE -d &lt;encrypted_file &gt;output_file</span><br></pre></td></tr></table></figure><p>2）gpg（GNU隐私保护）是一种应用广泛的工具，它使用加密技术来保护文件，以确保数据在送达目的地之前无法被读取。这里我们讨论如何加密、解密文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用gpg加密文件：</span></span><br><span class="line">$ gpg -c filename</span><br><span class="line"><span class="comment"># 该命令采用交互方式读取口令，并生成filename.gpg。使用以下命令解密gpg文件：</span></span><br><span class="line">$ gpg filename.gpg</span><br><span class="line"><span class="comment"># 该命令读取口令，然后对文件进行解密。</span></span><br></pre></td></tr></table></figure><p>3）Base64是一组相似的编码方案，它将ASCII字符转换成以64为基数的形式，以可读的ASCII字符串来描述二进制数据。 base64命令可以用来编码/解码Base64字符串。要将文件编码为Base64格式，可以使用： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ base64 filename &gt; outputfile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat file | base64 &gt; outputfile</span><br><span class="line"><span class="comment"># base64可以从stdin中进行读取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码Base64数据：</span></span><br><span class="line">$ base64 -d file &gt; outputfile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat base64_file | base64 -d &gt; outputfile</span><br></pre></td></tr></table></figure><p>4）md5sum与sha1sum都是单向散列算法，均无法逆推出原始数据。它们通常用于验证数据完整性或为特定数据生成唯一的密钥： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum file</span><br><span class="line">8503063d5488c3080d4800ff50850dc9 file</span><br><span class="line">$ sha1sum file</span><br><span class="line">1ba02b66e2e557fede8f61b7df282cd0a27b816b file</span><br></pre></td></tr></table></figure><p>这种类型的散列算法是存储密码的理想方案。密码使用其对应的散列值来存储。如果某个用户需要进行认证，读取该用户提供的密码并转换成散列值，然后将其与之前存储的散列值进行比对。如果相同，用户就通过认证，被允许访问；否则，就会被拒绝访问。 </p><p>5）openssl</p><p>用openssl生成shadow密码。 shadow密码通常都是salt密码。所谓SALT就是额外的一个字符串，用来起一个混淆的作用，使加密更加不易被破解。 salt由一些随机位组成，被用作密钥生成函数的输入之一，以生成密码的salt散列值。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ opensslpasswd -1 -salt SALT_STRING PASSWORD</span><br><span class="line"><span class="variable">$1</span><span class="variable">$SALT_STRING</span><span class="variable">$323VkWkSLHuhbt1zkSsUG</span>.</span><br><span class="line"><span class="comment"># 将SALT_STRING替换为随机字符串，并将PASSWORD替换成你想要使用的密码。</span></span><br></pre></td></tr></table></figure><h3 id="2-5-排序、唯一与重复"><a href="#2-5-排序、唯一与重复" class="headerlink" title="2.5 排序、唯一与重复"></a>2.5 排序、唯一与重复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对一组文件进行排序：</span></span><br><span class="line">$ sort file1.txt file2.txt &gt; sorted.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照数字顺序进行排序：</span></span><br><span class="line">$ sort -n file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照逆序进行排序：</span></span><br><span class="line">$ sort -r file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照月份进行排序（依照一月，二月，三月……）：</span></span><br><span class="line">$ sort -M months.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两个已排序过的文件：</span></span><br><span class="line">$ sort -m sorted1 sorted2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出已排序文件中不重复的行：</span></span><br><span class="line">$ sort file1.txt file2.txt | uniq</span><br></pre></td></tr></table></figure><p>检查文件是否已经排序过：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#功能描述：排序</span><br><span class="line">sort -C filename ;</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ]; then</span><br><span class="line">echo Sorted;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo Unsorted;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><code>-k</code> 指定了排序应该按照哪一个键（key）来进行。键指的是列号，而列号就是执行排序时的依据。 <code>-r</code> 告诉sort命令按照逆序进行排序。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依据第1列，以逆序形式排序</span></span><br><span class="line">$ sort -nrk 1 data.txt</span><br><span class="line">4 linux 1000</span><br><span class="line">3 bsd 1000</span><br><span class="line">2 winxp 4000</span><br><span class="line">1 mac 2000</span><br><span class="line"><span class="comment"># -nr表明按照数字，采用逆序形式排序</span></span><br><span class="line"><span class="comment"># 依据第2列进行排序</span></span><br><span class="line">$ sort -k 2 data.txt</span><br><span class="line">3 bsd 1000</span><br><span class="line">4 linux 1000</span><br><span class="line">1 mac 2000</span><br><span class="line">2 winxp 4000</span><br></pre></td></tr></table></figure><p>有时文本中可能会包含一些像空格之类的不必要的多余字符。如果需要忽略这些字符，并以字典序进行排序，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sort -bd unsorted.txt</span><br><span class="line"><span class="comment"># 选项-b用于忽略文件中的前导空白行，选项-d用于指明以字典序进行排序。</span></span><br></pre></td></tr></table></figure><p>sort选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-b：忽略每行前面开始出的空格字符；</span><br><span class="line"></span><br><span class="line">-c：检查文件是否已经按照顺序排序； </span><br><span class="line"></span><br><span class="line">-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符； </span><br><span class="line"></span><br><span class="line">-f：排序时，将小写字母视为大写字母； </span><br><span class="line"></span><br><span class="line">-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</span><br><span class="line"></span><br><span class="line">-m：将几个排序号的文件进行合并； </span><br><span class="line"></span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序； </span><br><span class="line"></span><br><span class="line">-n：依照数值的大小排序； </span><br><span class="line"></span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件； </span><br><span class="line"></span><br><span class="line">-r：以相反的顺序来排序； </span><br><span class="line"></span><br><span class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符； </span><br><span class="line"></span><br><span class="line">+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</span><br></pre></td></tr></table></figure><p>uniq选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：在每列旁边显示该行重复出现的次数； </span><br><span class="line"></span><br><span class="line">-d或--repeated：仅显示重复出现的行列； </span><br><span class="line"></span><br><span class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位； </span><br><span class="line"></span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符； </span><br><span class="line"></span><br><span class="line">-u或——unique：仅显示出一次的行列； </span><br><span class="line"></span><br><span class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。</span><br></pre></td></tr></table></figure><p>wc选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-c或--bytes或——chars：只显示Bytes数； <span class="comment"># 统计字符数</span></span><br><span class="line"></span><br><span class="line">-l或——lines：只显示列数； <span class="comment"># 统计行数</span></span><br><span class="line"></span><br><span class="line">-w或——words：只显示字数。<span class="comment"># 统计单词数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当不使用任何选项执行wc时，它会分别打印出文件的行数、单词数和字符数：</span></span><br><span class="line">$ wc file</span><br><span class="line">1435 15763 112200</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-L选项打印出文件中最长一行的长度：</span></span><br><span class="line">$ wc file -L</span><br><span class="line">205</span><br></pre></td></tr></table></figure><h3 id="2-6-临时文件命名与随机数"><a href="#2-6-临时文件命名与随机数" class="headerlink" title="2.6 临时文件命名与随机数"></a>2.6 临时文件命名与随机数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建临时文件：</span></span><br><span class="line">$ filename=`mktemp`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$filename</span></span><br><span class="line">/tmp/tmp.8xvhkjF5fH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时目录：</span></span><br><span class="line">$ dirname=`mktemp -d`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$dirname</span></span><br><span class="line">tmp.NI8xzW7VRX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果仅仅是想生成文件名，又不希望创建实际的文件或目录，方法如下：</span></span><br><span class="line">$ tmpfile=`mktemp -u`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$tmpfile</span></span><br><span class="line">/tmp/tmp.RsGmilRpcT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模板创建临时文件名：</span></span><br><span class="line"><span class="variable">$mktemp</span> test.XXX</span><br><span class="line">test.2tc</span><br></pre></td></tr></table></figure><p>如果提供了定制模板， X会被随机的字符（字母或数字）替换。注意， mktemp正常工作的前提是保证模板中只少要有3个X。 </p><h3 id="2-7-split-分割文件和数据"><a href="#2-7-split-分割文件和数据" class="headerlink" title="2.7 split 分割文件和数据"></a>2.7 split 分割文件和数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件分割成多个大小为10KB的文件</span></span><br><span class="line">$ split -b 10k data.file</span><br><span class="line">$ ls</span><br><span class="line">data.file xaa xab xac xad xae xaf xag xah xai xaj</span><br></pre></td></tr></table></figure><p>上面的命令将data.file分割成多个文件，每一个文件大小为10KB。这些文件以xab、 xac、 xad的形式命名。这表明它们都有一个字母后缀。如果想以数字为后缀，可以另外使用-d参数。此外，使用 -a length可以指定后缀长度： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 10k data.file -d -a 4</span><br><span class="line">$ ls</span><br><span class="line">data.file x0009 x0019 x0029 x0039 x0049 x0059 x0069 x0079</span><br></pre></td></tr></table></figure><p>除了k（KB）后缀，我们还可以使用M（MB）、 G（GB）、 c（byte）、 w（word）等后缀。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为分割后的文件指定文件名前缀 </span></span><br><span class="line">$ split -b 10k data.file -d -a 4 split_file</span><br><span class="line">$ ls</span><br><span class="line">data.file   split_file0002 split_file0005 split_file0008 strtok.c</span><br><span class="line">split_file0000 split_file0003 split_file0006 split_file0009</span><br><span class="line">split_file0001 split_file0004 split_file0007</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想按照数据块大小，而是需要根据行数来分割文件的话，可以使用 -l no_of_lines：</span></span><br><span class="line">$ split -l 10 data.file</span><br><span class="line"><span class="comment"># 分割成多个文件，每个文件包含10行</span></span><br></pre></td></tr></table></figure><p>csplit。它能够依据指定的条件和字符串匹配选项对日志文件进行分割。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat server.log</span><br><span class="line">SERVER-1</span><br><span class="line">[connection] 192.168.0.1 success</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 success</span><br><span class="line">SERVER-2</span><br><span class="line">[connection] 192.168.0.1 failed</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 success</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line">SERVER-3</span><br><span class="line">[connection] 192.168.0.1 pending</span><br><span class="line">[connection] 192.168.0.2 pending</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line">$ csplit server.log /SERVER/ -n 2 -s &#123;*&#125; -f server -b <span class="string">"%02d.log"</span> ; rm server00.log</span><br><span class="line">$ ls</span><br><span class="line">server01.log server02.log server03.log server.log</span><br></pre></td></tr></table></figure><p>有关这个命令的详细说明如下。 </p><ul><li>/SERVER/ 用来匹配某一行，分割过程即从此处开始。 </li><li>/[REGEX]/ 表示文本样式。包括从当前行（第一行）直到（但不包括）包含“SERVER”的匹配行。 </li><li>{*} 表示根据匹配重复执行分割，直到文件末尾为止。可以用{整数}的形式来指定分割执行的次数。 </li><li>-s 使命令进入静默模式，不打印其他信息。 </li><li>-n 指定分割后的文件名后缀的数字个数，例如01、 02、 03等。 </li><li>-f 指定分割后的文件名前缀（在上面的例子中， server就是前缀）。 </li><li>-b 指定后缀格式。例如%02d.log，类似于C语言中printf的参数格式。在这里文件名=前缀+后缀=server + %02d.log。 </li></ul><p>因为分割后的第一个文件没有任何内容（匹配的单词就位于文件的第一行中），所以我们删除了server00.log。 </p><h4 id="2-7-1-根据扩展名切分文件名-、"><a href="#2-7-1-根据扩展名切分文件名-、" class="headerlink" title="2.7.1 根据扩展名切分文件名$、"></a>2.7.1 根据扩展名切分文件名$、</h4><p>借助 <code>%</code> 操作符可以轻松将名称部分从 “名称.扩展名” 这种格式中提取出来。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">name=$&#123;file_jpg%.*&#125;</span><br><span class="line">echo File name is: $name</span><br><span class="line">输出结果：</span><br><span class="line">File name is: sample</span><br></pre></td></tr></table></figure><p>将文件名的扩展名部分提取出来，这可以借助 # 操作符实现。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension=$&#123;file_jpg#*.&#125;</span><br><span class="line">echo Extension is: jpg</span><br><span class="line">输出结果：</span><br><span class="line">Extension is: jpg</span><br></pre></td></tr></table></figure><p><code>${VAR%.*}</code>  的含义如下所述： </p><ul><li>从 $VAR中删除位于 % 右侧的通配符（在前例中是.*）所匹配的字符串。通配符从右向左进行匹配。 </li><li>给VAR赋值， VAR=sample.jpg。那么，通配符从右向左就会匹配到.jpg，因此，从 $VAR中删除匹配结果，就会得到输出sample。 </li></ul><p>%属于非贪婪（non-greedy）操作。它从右到左找出匹配通配符的最短结果。还有另一个操作符 %%，这个操作符与%相似，但行为模式却是贪婪的，这意味着它会匹配符合条件的最长的字符串。 </p><p>操作符%%则用.*从右向左执行贪婪匹配（.fun.book.txt）。 </p><p><code>${VAR#*.}</code> 的含义如下所述：<br>从$VAR中删除位于#右侧的通配符（即在前例中使用的*.）所匹配的字符串。通配<br>符从左向右进行匹配。<br>和 %% 类似， #也有一个相对应的贪婪操作符 ##。</p><p><code>##</code>从左向右进行贪婪匹配，并从指定变量中删除匹配结果。</p><p>这里有个能够提取域名不同部分的实用案例。假定 <code>URL=&quot;www.google.com&quot;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL%.*&#125;</span> <span class="comment"># 移除.*所匹配的最右边的内容</span></span><br><span class="line">www.google</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL%%.*&#125;</span> <span class="comment"># 将从右边开始一直匹配到最左边的*.移除（贪婪操作符）</span></span><br><span class="line">www</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL#*.&#125;</span> <span class="comment"># 移除*.所匹配的最左边的内容</span></span><br><span class="line">google.com</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL##*.&#125;</span> <span class="comment"># 将从左边开始一直匹配到最右边的*.移除（贪婪操作符）</span></span><br><span class="line">com</span><br></pre></td></tr></table></figure><h3 id="2-8-批量重命名和移动"><a href="#2-8-批量重命名和移动" class="headerlink" title="2.8 批量重命名和移动"></a>2.8 批量重命名和移动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 *.JPG更名为 *.jpg：</span></span><br><span class="line">$ rename *.JPG *.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件名中的空格替换成字符“_”：</span></span><br><span class="line">$ rename <span class="string">'s/ /_/g'</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换文件名的大小写：</span></span><br><span class="line">$ rename <span class="string">'y/A-Z/a-z/'</span> *</span><br><span class="line">$ rename <span class="string">'y/a-z/A-Z/'</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的 .mp3文件移入给定的目录：</span></span><br><span class="line">$ find path -<span class="built_in">type</span> f -name <span class="string">"*.mp3"</span> -<span class="built_in">exec</span> mv &#123;&#125; target_dir \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有文件名中的空格替换为字符“_”：</span></span><br><span class="line">$ find path -<span class="built_in">type</span> f -<span class="built_in">exec</span> rename <span class="string">'s/ /_/g'</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="3-以文件之名"><a href="#3-以文件之名" class="headerlink" title="3 以文件之名"></a>3 以文件之名</h2><h3 id="3-1-生成任意大小的文件"><a href="#3-1-生成任意大小的文件" class="headerlink" title="3.1 生成任意大小的文件"></a>3.1 生成任意大小的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=junk.data bs=1M count=1</span><br></pre></td></tr></table></figure><p>该命令会创建一个1MB大小的文件junk.data。来看一下命令参数： if代表输入文件（input file），of代表输出文件（output file）， bs代表以字节为单位的块大小（block size）， count代表需要被复制的块数。</p><p>使用dd命令时一定得留意，该命令运行在设备底层。要是你不小心出了岔子，搞不好会把磁盘清空或是损坏数据。所以一定要反复检查dd命令所用的语法是否正确，尤其是参数of=。 </p><table><thead><tr><th>单元大小</th><th>代码</th></tr></thead><tbody><tr><td>字节（1B）</td><td>c</td></tr><tr><td>字（2B）</td><td>w</td></tr><tr><td>块（512B）</td><td>b</td></tr><tr><td>千字节（1024B）</td><td>k</td></tr><tr><td>兆字节（1024KB）</td><td>M</td></tr><tr><td>吉字节（1024MB）</td><td>G</td></tr></tbody></table><p><code>ls -lS</code> 对当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息。  </p><h3 id="3-2-文件权限、所有权和粘滞位"><a href="#3-2-文件权限、所有权和粘滞位" class="headerlink" title="3.2 文件权限、所有权和粘滞位"></a>3.2 文件权限、所有权和粘滞位</h3><p>用命令ls -l可以列出文件的权限： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 slynux slynux 2497 2010-02-28 11:22 bot.py</span><br><span class="line">drwxr-xr-x 2 slynux slynux 4096 2010-05-27 14:31 a.py</span><br><span class="line">-rw-r--r-- 1 slynux slynux 539 2010-02-10 09:11 cl.pl</span><br></pre></td></tr></table></figure><ul><li><code>-</code>—— 普通文件。 </li><li>d —— 目录。 </li><li>c —— 字符设备。 </li><li>b —— 块设备。 </li><li>l —— 符号链接。 </li><li>s —— 套接字。 </li><li>p —— 管道。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改所有权</span></span><br><span class="line">$ chown user.group filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置粘滞位</span></span><br><span class="line"><span class="comment"># 要设置粘滞位，利用chmod将 +t应用于目录：</span></span><br><span class="line">$ chmod a+t directory_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以递归的方式设置权限</span></span><br><span class="line">$ chmod 777 . -R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以递归的方式设置所有权</span></span><br><span class="line">$ chown user.group . -R</span><br></pre></td></tr></table></figure><h3 id="3-3-创建不可修改的文件"><a href="#3-3-创建不可修改的文件" class="headerlink" title="3.3 创建不可修改的文件"></a>3.3 创建不可修改的文件</h3><p>chattr能够将文件设置为不可修改。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用下列命令将一个文件设置为不可修改：</span></span><br><span class="line">$ chattr +i file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要使文件恢复可写状态，移除不可修改属性即可：</span></span><br><span class="line">$ chattr -i file</span><br></pre></td></tr></table></figure><h3 id="3-4-查找符号链接及其指向目标"><a href="#3-4-查找符号链接及其指向目标" class="headerlink" title="3.4 查找符号链接及其指向目标"></a>3.4 查找符号链接及其指向目标</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符号链接：</span></span><br><span class="line">$ ln -s target symbolic_link_name</span><br><span class="line">例如：</span><br><span class="line">$ ln -l -s /var/www/ ~/web</span><br><span class="line"><span class="comment">#这个命令在已登录用户的home目录中创建了一个名为Web的符号链接。该链接指向/var/www。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的命令来验证是否创建链接：</span></span><br><span class="line">$ ls -l web</span><br><span class="line">lrwxrwxrwx 1 slynux slynux 8 2010-06-25 21:34 web -&gt; /var/www</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出当前目录下的符号链接：</span></span><br><span class="line">$ ls -l | grep <span class="string">"^l"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用find打印当前目录以及子目录下的符号链接：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> l -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用readlink打印出符号链接所指向的目标路径：</span></span><br><span class="line">$ readlink web</span><br><span class="line">/var/www</span><br></pre></td></tr></table></figure><h3 id="3-5-列举文件类型统计信息"><a href="#3-5-列举文件类型统计信息" class="headerlink" title="3.5 列举文件类型统计信息"></a>3.5 列举文件类型统计信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用下面的命令打印文件类型信息：</span></span><br><span class="line">$ file filename</span><br><span class="line">$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印不包括文件名在内的文件类型信息：</span></span><br><span class="line">$ file -b filename</span><br><span class="line">ASCII text</span><br></pre></td></tr></table></figure><h3 id="3-6-使用环回文件"><a href="#3-6-使用环回文件" class="headerlink" title="3.6 使用环回文件"></a>3.6 使用环回文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令可以创建一个1GB大小的文件：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=loobackfile.img bs=1G count=1</span><br><span class="line">1024+0 records <span class="keyword">in</span></span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 37.3155 s, 28.8 MB/s</span><br><span class="line"><span class="comment"># 你会发现创建好的文件大小超过了1GB。这是因为硬盘作为块设备，其分配存储空间时是按照块大小的整数倍来进行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用mkfs命令将1GB的文件格式化成ext4文件系统：</span></span><br><span class="line">$ mkfs.ext4 loopbackfile.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的命令检查文件系统：</span></span><br><span class="line">$ file loobackfile.img</span><br><span class="line">loobackfile.img: Linux rev 1.0 ext4 filesystem data,</span><br><span class="line">UUID=c9d56c42-f8e6-4cbd-aeab-369d5056660a (extents) (large files) (huge files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在就可以挂载环回文件了：</span></span><br><span class="line">$ mkdir /mnt/loopback</span><br><span class="line">$ mount -o loop loopbackfile.img /mnt/loopback</span><br><span class="line"><span class="comment"># -o loop用来挂载环回文件系统。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以手动来操作：</span></span><br><span class="line">$ losetup /dev/loop1 loopbackfile.img</span><br><span class="line">$ mount /dev/loop1 /mnt/loopback</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的方法进行卸载（umount）：</span></span><br><span class="line">$ umount mount_point</span><br></pre></td></tr></table></figure><h3 id="3-7-生成-ISO-文件及混合型-ISO"><a href="#3-7-生成-ISO-文件及混合型-ISO" class="headerlink" title="3.7 生成 ISO 文件及混合型 ISO"></a>3.7 生成 ISO 文件及混合型 ISO</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用下面的命令从/dev/cdrom创建一个ISO镜像：</span></span><br><span class="line">$ cat /dev/cdrom &gt; image.iso</span><br><span class="line"></span><br><span class="line"><span class="comment">#尽管可以奏效。但创建ISO镜像最好的方法还是使用dd工具：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/cdrom of=image.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># mkisofs命令用于创建ISO文件系统。</span></span><br><span class="line">$ mkisofs -V <span class="string">"Label"</span> -o image.iso source_dir/</span><br><span class="line"><span class="comment"># 选项 -o指定了ISO文件的路径。 source_dir是作为ISO文件内容来源的目录路径，选项 -V指定了ISO文件的卷标。</span></span><br></pre></td></tr></table></figure><h3 id="3-8-diff命令"><a href="#3-8-diff命令" class="headerlink" title="3.8 diff命令"></a>3.8 diff命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- 　<span class="comment"># 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。</span></span><br><span class="line">-a或--text 　<span class="comment"># diff预设只会逐行比较文本文件。</span></span><br><span class="line">-b或--ignore-space-change 　<span class="comment"># 不检查空格字符的不同。</span></span><br><span class="line">-B或--ignore-blank-lines 　 <span class="comment"># 不检查空白行。</span></span><br><span class="line">-c 　<span class="comment"># 显示全部内文，并标出不同之处。</span></span><br><span class="line">-C或--context <span class="comment"># 与执行"-c-"指令相同。</span></span><br><span class="line">-d或--minimal <span class="comment"># 使用不同的演算法，以较小的单位来做比较。</span></span><br><span class="line">-D或ifdef<span class="comment"># 此参数的输出格式可用于前置处理器巨集。</span></span><br><span class="line">-e或--ed<span class="comment"># 此参数的输出格式可用于ed的script文件。</span></span><br><span class="line">-f或-forward-ed<span class="comment"># 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span></span><br><span class="line">-H或--speed-large-files 　<span class="comment"># 比较大文件时，可加快速度。</span></span><br><span class="line">-l或--ignore-matching-lines 　<span class="comment"># 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</span></span><br><span class="line">-i或--ignore-case 　<span class="comment"># 不检查大小写的不同。</span></span><br><span class="line">-l或--paginate   <span class="comment"># 将结果交由pr程序来分页。</span></span><br><span class="line">-n或--rcs 　  <span class="comment"># 将比较结果以RCS的格式来显示。</span></span><br><span class="line">-N或--new-file 　  <span class="comment"># 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span></span><br><span class="line">-p 　  <span class="comment"># 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span></span><br><span class="line">-P或--unidirectional-new-file 　<span class="comment"># 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span></span><br><span class="line">-q或--brief 　<span class="comment"># 仅显示有无差异，不显示详细的信息。</span></span><br><span class="line">-r或--recursive 　<span class="comment"># 比较子目录中的文件。</span></span><br><span class="line">-s或--report-identical-files 　<span class="comment"># 若没有发现任何差异，仍然显示信息。</span></span><br><span class="line">-S或--starting-file 　<span class="comment"># 在比较目录时，从指定的文件开始比较。</span></span><br><span class="line">-t或--expand-tabs 　<span class="comment"># 在输出时，将tab字符展开。</span></span><br><span class="line">-T或--initial-tab 　<span class="comment"># 在每行前面加上tab字符以便对齐。</span></span><br><span class="line">-u,-U或--unified= 　<span class="comment"># 以合并的方式来显示文件内容的不同。</span></span><br><span class="line">-v或--version 　<span class="comment"># 显示版本信息。</span></span><br><span class="line">-w或--ignore-all-space 　<span class="comment"># 忽略全部的空格字符。</span></span><br><span class="line">-W或--width 　<span class="comment"># 在使用-y参数时，指定栏宽。</span></span><br><span class="line">-x或--exclude 　<span class="comment"># 不比较选项中所指定的文件或目录。</span></span><br><span class="line">-X或--exclude-from 　 <span class="comment"># 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件。</span></span><br><span class="line">-y或--side-by-side 　 <span class="comment"># 以并列的方式显示文件的异同之处。</span></span><br><span class="line">--<span class="built_in">help</span> 　 <span class="comment"># 显示帮助。</span></span><br><span class="line">--left-column 　<span class="comment"># 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</span></span><br><span class="line">--suppress-common-lines 　<span class="comment"># 在使用-y参数时，仅显示不同之处。</span></span><br></pre></td></tr></table></figure><p>生成目录的差异信息 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diff -Naur directory1 directory2</span><br></pre></td></tr></table></figure><ul><li>-N：将所有缺失的文件视为空文件。 </li><li>-a：将所有文件视为文本文件。 </li><li>-u：生成一体化输出。 </li><li>-r：遍历目录下的所有文件。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成patch文件</span></span><br><span class="line">$ diff -u version1.txt version2.txt &gt; version.patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下列命令来进行修补：</span></span><br><span class="line">$ patch -p1 version1.txt &lt; version.patch</span><br><span class="line">patching file version1.txt</span><br><span class="line"><span class="comment"># version1.txt的内容现在和verson2.txt的内容一模一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令可以撤销做出的修改：</span></span><br><span class="line">$ patch -p1 version1.txt &lt; version.patch</span><br><span class="line">patching file version1.txt</span><br><span class="line">Reversed (or previously applied) patch detected! Assume -R? [n] y</span><br><span class="line"><span class="comment"># 修改被撤销</span></span><br></pre></td></tr></table></figure><h3 id="3-9-more、less、head与tail命令"><a href="#3-9-more、less、head与tail命令" class="headerlink" title="3.9 more、less、head与tail命令"></a>3.9 more、less、head与tail命令</h3><h4 id="3-9-1-more文件内容输出查看工具"><a href="#3-9-1-more文件内容输出查看工具" class="headerlink" title="3.9.1 more文件内容输出查看工具"></a>3.9.1 more文件内容输出查看工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ more [参数选项] [文件] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数如下： </span></span><br><span class="line">+num   <span class="comment"># 从第num行开始显示； </span></span><br><span class="line">-num   <span class="comment"># 定义屏幕大小，为num行； </span></span><br><span class="line">+/pattern   <span class="comment"># 从pattern 前两行开始显示； </span></span><br><span class="line">-c   <span class="comment"># 从顶部清屏然后显示； </span></span><br><span class="line">-d   <span class="comment"># 提示Press space to continue, 'q' to quit.（按空格键继续，按q键退出），禁用响铃功能； </span></span><br><span class="line">-l    <span class="comment"># 忽略Ctrl+l （换页）字符； </span></span><br><span class="line">-p    <span class="comment"># 通过清除窗口而不是滚屏来对文件进行换页。和-c参数有点相似； </span></span><br><span class="line">-s    <span class="comment"># 把连续的多个空行显示为一行； </span></span><br><span class="line">-u    <span class="comment"># 把文件内容中的下划线去掉退出more的动作指令是q</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示提示，并从终端或控制台顶部显示；</span></span><br><span class="line">$ more -dc /etc/profile </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从profile的第4行开始显示；</span></span><br><span class="line">$ more +4 /etc/profile     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每屏显示4行；</span></span><br><span class="line">$ more -4 /etc/profile    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从profile中的第一个MAIL单词的前两行开始显示；</span></span><br><span class="line">$ more +/MAIL /etc/profile</span><br></pre></td></tr></table></figure><p>more 的动作指令：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter       # 向下n行，需要定义，默认为<span class="number">1</span>行； </span><br><span class="line">Ctrl+f    # 向下滚动一屏； </span><br><span class="line">空格键 # 向下滚动一屏； </span><br><span class="line">Ctrl+b  # 返回上一屏； </span><br><span class="line">=         # 输出当前行的行号； </span><br><span class="line">:f      # 输出文件名和当前行的行号； </span><br><span class="line">v      # 调用vi编辑器； </span><br><span class="line">! 命令          # 调用Shell，并执行命令； </span><br><span class="line">q     # 退出more当我们查看某一文件时，想调用vi来编辑它，不要忘记了v动作指令，这是比较方便的；</span><br></pre></td></tr></table></figure><p>其它命令通过管道和more结合的运用例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /etc |more</span><br></pre></td></tr></table></figure><h4 id="3-9-2-less查看文件内容工具"><a href="#3-9-2-less查看文件内容工具" class="headerlink" title="3.9.2 less查看文件内容工具"></a>3.9.2 less查看文件内容工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-c <span class="comment"># 从顶部（从上到下）刷新屏幕，并显示文件内容。而不是通过底部滚动完成刷新； </span></span><br><span class="line">-f <span class="comment"># 强制打开文件，二进制文件显示时，不提示警告； </span></span><br><span class="line">-i <span class="comment"># 搜索时忽略大小写；除非搜索串中包含大写字母； </span></span><br><span class="line">-I <span class="comment"># 搜索时忽略大小写，除非搜索串中包含小写字母； </span></span><br><span class="line">-m <span class="comment"># 显示读取文件的百分比； </span></span><br><span class="line">-M <span class="comment"># 显法读取文件的百分比、行号及总行数； </span></span><br><span class="line">-N <span class="comment"># 在每行前输出行号； </span></span><br><span class="line">-p <span class="comment"># pattern 搜索pattern；比如在/etc/profile搜索单词MAIL，就用 less -p MAIL /etc/profile </span></span><br><span class="line">-s <span class="comment"># 把连续多个空白行作为一个空白行显示； </span></span><br><span class="line">-Q <span class="comment"># 在终端下不响铃；</span></span><br></pre></td></tr></table></figure><p>less的动作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">回车键 <span class="comment"># 向下移动一行； </span></span><br><span class="line">y   <span class="comment"># 向上移动一行； </span></span><br><span class="line">空格键 <span class="comment"># 向下滚动一屏； </span></span><br><span class="line">b   <span class="comment"># 向上滚动一屏； </span></span><br><span class="line">d   <span class="comment"># 向下滚动半屏； </span></span><br><span class="line">h   <span class="comment"># less的帮助； </span></span><br><span class="line">u   <span class="comment"># 向上洋动半屏； </span></span><br><span class="line">w   <span class="comment"># 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示； </span></span><br><span class="line">g   <span class="comment"># 跳到第一行； </span></span><br><span class="line">G   <span class="comment"># 跳到最后一行； </span></span><br><span class="line">p   <span class="comment"># n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示； </span></span><br><span class="line">/pattern  <span class="comment"># 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词； </span></span><br><span class="line">v   <span class="comment"># 调用vi编辑器； </span></span><br><span class="line">q   <span class="comment"># 退出less </span></span><br><span class="line">!<span class="built_in">command</span>  <span class="comment"># 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件；</span></span><br></pre></td></tr></table></figure><h4 id="3-9-3-head"><a href="#3-9-3-head" class="headerlink" title="3.9.3 head"></a>3.9.3 head</h4><p>head 是显示一个文件的内容的前多少行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ head -n 10 /etc/profile</span><br></pre></td></tr></table></figure><h4 id="3-9-4-tail"><a href="#3-9-4-tail" class="headerlink" title="3.9.4 tail"></a>3.9.4 tail</h4><p>tail 是显示一个文件的内容的最后多少行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -n 5 /etc/profile</span><br></pre></td></tr></table></figure><h3 id="3-10-getopts-参数解析"><a href="#3-10-getopts-参数解析" class="headerlink" title="3.10 getopts 参数解析"></a>3.10 getopts 参数解析</h3><h4 id="3-10-1-getopts（shell内置命令）"><a href="#3-10-1-getopts（shell内置命令）" class="headerlink" title="3.10.1 getopts（shell内置命令）"></a>3.10.1 getopts（shell内置命令）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> getopt</span><br><span class="line">getopt 是 /usr/bin/getopt</span><br><span class="line">$ <span class="built_in">type</span> <span class="built_in">getopts</span> </span><br><span class="line"><span class="built_in">getopts</span> 是 shell 内建</span><br></pre></td></tr></table></figure><p>getopts不能直接处理长的选项（如：–prefix=/home等）</p><p>关于getopts的使用方法，可以man bash  搜索getopts。</p><p>getopts有两个参数，第一个参数是一个字符串，包括字符和“：”，每一个字符都是一个有效的选项，如果字符后面带有“：”，表示这个字符有自己的参数。getopts从命令中获取这些参数，并且删去了“-”，并将其赋值在第二个参数中，如果带有自己参数，这个参数赋值在 <code>$OPTARG</code>中。提供getopts的shell内置了 <code>$OPTARG</code> 这个变变，getopts修改了这个变量。</p><p>这里变量 <code>$OPTARG</code> 存储相应选项的参数，而 <code>$OPTIND</code> 总是存储原始 <code>$*</code> 中下一个要处理的元素位置。<code>while getopts &quot;:a:bc&quot; opt</code>   #第一个冒号表示忽略错误；字符后面的冒号表示该选项必须有自己的参数</p><p>getopts后面的字符串就是可以使用的选项列表，每个字母代表一个选项，后面带:的意味着选项除了定义本身之外，还会带上一个参数作为选项的值，比如d:在实际的使用中就会对应-d 30，选项的值就是30；getopts字符串中没有跟随:的是开关型选项，不需要再指定值，相当于true/false，只要带了这个参数就是true。如果命令行中包含了没有在getopts列表中的选项，会有警告信息，如果在整个getopts字符串前面也加上个:，就能消除警告信息了。</p><p>两个特殊变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$OPTIND</span>     <span class="comment"># 特殊变量，option index，会逐个递增, 初始值为1</span></span><br><span class="line"><span class="variable">$OPTARG</span>     <span class="comment"># 特殊变量，option argument，不同情况下有不同的值</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">echo $*</span><br><span class="line"><span class="keyword">while</span> getopts <span class="string">":a:bc"</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> $opt <span class="keyword">in</span></span><br><span class="line">                a ) echo $OPTARG</span><br><span class="line">                    echo $OPTIND;;</span><br><span class="line">                b ) echo <span class="string">"b $OPTIND"</span>;;</span><br><span class="line">                c ) echo <span class="string">"c $OPTIND"</span>;;</span><br><span class="line">                ? ) echo <span class="string">"error"</span></span><br><span class="line">                    exit <span class="number">1</span>;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo $OPTIND</span><br><span class="line">shift $(($OPTIND - <span class="number">1</span>))</span><br><span class="line">#通过shift $(($OPTIND - <span class="number">1</span>))的处理，$*中就只保留了除去选项内容的参数，可以在其后进行正常的shell编程处理了。</span><br><span class="line">echo $<span class="number">0</span></span><br><span class="line">echo $*</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./getopts.sh -a 11 -b -c</span><br><span class="line">-a 11 -b -c</span><br><span class="line">11</span><br><span class="line">3</span><br><span class="line">b 4</span><br><span class="line">c 5</span><br><span class="line">5</span><br><span class="line">./getopts.sh</span><br></pre></td></tr></table></figure><h4 id="3-10-2-getopt（一个外部工具）"><a href="#3-10-2-getopt（一个外部工具）" class="headerlink" title="3.10.2 getopt（一个外部工具）"></a>3.10.2 getopt（一个外部工具）</h4><p>具体用用法可以 man getopt</p><p><code>-o</code> 表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，如 <code>-carg</code> 而不能是 <code>-c arg</code>。</p><p><code>--long</code> 表示长选项</p><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"></span><br><span class="line"># A small example program <span class="keyword">for</span> using the <span class="keyword">new</span> getopt(<span class="number">1</span>) program.</span><br><span class="line"># This program will only work <span class="keyword">with</span> bash(<span class="number">1</span>)</span><br><span class="line"># An similar program using the tcsh(<span class="number">1</span>) script. language can be found</span><br><span class="line"># <span class="keyword">as</span> parse.tcsh</span><br><span class="line"></span><br><span class="line"># Example input and output (<span class="keyword">from</span> the bash prompt):</span><br><span class="line"># ./parse.bash -a par1 <span class="string">'another arg'</span> --c-long <span class="string">'wow!*\?'</span> -cmore -b <span class="string">" very long "</span></span><br><span class="line"># Option a</span><br><span class="line"># Option c, no argument</span><br><span class="line"># Option c, argument <span class="string">`more'</span></span><br><span class="line"><span class="string"># Option b, argument `</span> very long <span class="string">'</span></span><br><span class="line"><span class="string"># Remaining arguments:</span></span><br><span class="line"><span class="string"># --&gt; `par1'</span></span><br><span class="line"># --&gt; <span class="string">`another arg'</span></span><br><span class="line"><span class="string"># --&gt; `</span>wow!*\?<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note that we use `"$@"'</span> to <span class="keyword">let</span> each command-line parameter expand to a</span><br><span class="line"># separate word. The quotes around <span class="string">`$@' are essential!</span></span><br><span class="line"><span class="string"># We need TEMP as the `</span><span class="built_in">eval</span> <span class="keyword">set</span> --<span class="string">' would nuke the return value of getopt.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项</span></span><br><span class="line"><span class="string">#如-carg 而不能是-c arg</span></span><br><span class="line"><span class="string">#--long表示长选项</span></span><br><span class="line"><span class="string">#"$@"在上面解释过</span></span><br><span class="line"><span class="string"># -n:出错时的信息</span></span><br><span class="line"><span class="string"># -- ：举一个例子比较好理解：</span></span><br><span class="line"><span class="string">#我们要创建一个名字为 "-f"的目录你会怎么办？</span></span><br><span class="line"><span class="string"># mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用</span></span><br><span class="line"><span class="string"># mkdir -- -f 这样-f就不会被作为选项。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \</span></span><br><span class="line"><span class="string">     -n '</span>example.bash<span class="string">' -- "$@"`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if [ $? != 0 ] ; then echo "Terminating..." &gt;&amp;2 ; exit 1 ; fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note the quotes around `$TEMP'</span>: they are essential!</span><br><span class="line">#<span class="keyword">set</span> 会重新排列参数的顺序，也就是改变$<span class="number">1</span>,$<span class="number">2.</span>..$n的值，这些值在getopt中重新排列过了</span><br><span class="line"><span class="built_in">eval</span> <span class="keyword">set</span> -- <span class="string">"$TEMP"</span></span><br><span class="line"></span><br><span class="line">#经过getopt的处理，下面处理具体选项。</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"$1"</span> <span class="keyword">in</span></span><br><span class="line">                -a|--a-long) echo <span class="string">"Option a"</span> ; shift ;;</span><br><span class="line">                -b|--b-long) echo <span class="string">"Option b, argument \`$2'"</span> ; shift <span class="number">2</span> ;;</span><br><span class="line">                -c|--c-long)</span><br><span class="line">                        # c has an optional argument. As we are <span class="keyword">in</span> quoted mode,</span><br><span class="line">                        # an empty parameter will be generated <span class="keyword">if</span> its optional</span><br><span class="line">                        # argument is not found.</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"$2"</span> <span class="keyword">in</span></span><br><span class="line">                                <span class="string">""</span>) echo <span class="string">"Option c, no argument"</span>; shift <span class="number">2</span> ;;</span><br><span class="line">                                *)  echo <span class="string">"Option c, argument \`$2'"</span> ; shift <span class="number">2</span> ;;</span><br><span class="line">                        esac ;;</span><br><span class="line">                --) shift ; <span class="keyword">break</span> ;;</span><br><span class="line">                *) echo <span class="string">"Internal error!"</span> ; exit <span class="number">1</span> ;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo <span class="string">"Remaining arguments:"</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">do</span></span><br><span class="line">   echo <span class="string">'--&gt; '</span><span class="string">"\`$arg'"</span> ;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./getopt.sh --b-long abc -a -c33 remain</span><br><span class="line">Option b, argument `abc<span class="string">'</span></span><br><span class="line"><span class="string">Option a</span></span><br><span class="line"><span class="string">Option c, argument `33'</span></span><br><span class="line">Remaining arguments:</span><br><span class="line">--&gt; `remain<span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="3-11-只列出目录的各种方法"><a href="#3-11-只列出目录的各种方法" class="headerlink" title="3.11 只列出目录的各种方法"></a>3.11 只列出目录的各种方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ls –d：</span></span><br><span class="line">$ ls -d */</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用grep结合ls –F：</span></span><br><span class="line">$ ls -F | grep <span class="string">"/$"</span></span><br><span class="line"><span class="comment"># 当使用-F时，所有的输出项都会添加上一个代表文件类型的字符，如@、 *、 |等。目录对应的是 / 字符。我们用grep只过滤那些以 /$ 作为行尾标记的输出项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用grep结合ls –l：</span></span><br><span class="line">$ ls -l | grep <span class="string">"^d"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用find：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> d -maxdepth 1 -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><h3 id="3-12-使用pushd和popd进行快速定位"><a href="#3-12-使用pushd和popd进行快速定位" class="headerlink" title="3.12 使用pushd和popd进行快速定位"></a>3.12 使用pushd和popd进行快速定位</h3><p>使用pushd和popd时，可以无视cd命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压入并切换路径：</span></span><br><span class="line">$ <span class="built_in">pushd</span> /var/www</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再压入下一个目录路径：</span></span><br><span class="line">$ <span class="built_in">pushd</span> /usr/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的命令查看栈内容：</span></span><br><span class="line">$ <span class="built_in">dirs</span></span><br><span class="line">/usr/src /var/www ~ /usr/share /etc</span><br><span class="line">0 1   2 3 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当你想切换到列表中任意一个路径时，将每条路径从0到n进行编号，然后使用你希望切换到的路径编号，例如：</span></span><br><span class="line">$ <span class="built_in">pushd</span> +3</span><br><span class="line"><span class="comment"># 这条命令会将栈进行翻转并切换到目录 /use/share。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除最后添加的路径并把当前目录更改为上一级目录，可以使用以下命令：</span></span><br><span class="line">$ <span class="built_in">popd</span></span><br><span class="line"><span class="comment"># 用popd +num可以从列表中移除特定的路径。num是从左到右，从0到n开始计数的。</span></span><br></pre></td></tr></table></figure><h3 id="3-13-tree打印目录树"><a href="#3-13-tree打印目录树" class="headerlink" title="3.13 tree打印目录树"></a>3.13 tree打印目录树</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重点标记出匹配某种样式的文件：</span></span><br><span class="line">$ tree PATH -P <span class="string">"*.sh"</span> <span class="comment"># 用一个目录路径代替PATH</span></span><br><span class="line">|-- home</span><br><span class="line">| |-- packtpub</span><br><span class="line">| | `-- automate.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重点标记出除符合某种样式之外的那些文件：</span></span><br><span class="line">$ tree path -I PATTERN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -h选项同时打印出文件和目录的大小：</span></span><br><span class="line">$ tree -h</span><br></pre></td></tr></table></figure><h2 id="4-让文件飞"><a href="#4-让文件飞" class="headerlink" title="4 让文件飞"></a>4 让文件飞</h2><h3 id="4-1-正则表达式"><a href="#4-1-正则表达式" class="headerlink" title="4.1 正则表达式"></a>4.1 正则表达式</h3><table><thead><tr><th>正则表达式</th><th>描述</th><th align="left">示例</th></tr></thead><tbody><tr><td>^</td><td>行起始标记</td><td align="left">^tux 匹配以tux起始的行</td></tr><tr><td>$</td><td>行尾标记</td><td align="left">tux$ 匹配以tux结尾的行</td></tr><tr><td>.</td><td>匹配任意一个字符</td><td align="left">Hack.匹配Hackl和Hacki，它只能匹配单个字符</td></tr><tr><td>[ ]</td><td>匹配包含在 [字符] 之中的任意一个字符</td><td align="left">coo[kl] 匹配cook或cool</td></tr><tr><td>[ ^ ]</td><td>匹配除 <code>[^字符]</code> 之外的任意一个字符</td><td align="left"><code>9[^01]</code>匹配92、 93，但是不匹配91或90</td></tr><tr><td>[ - ]</td><td>匹配 [ ] 中指定范围内的任意一个字符</td><td align="left">[1-5] 匹配从1～5的任意一个数字</td></tr><tr><td>?</td><td>匹配之前的项1次或0次</td><td align="left">colou?r 匹配color或colour，但是不能匹配colouur</td></tr><tr><td>+</td><td>匹配之前的项1次或多次</td><td align="left">Rollno-9+ 匹配Rollno-99、Rollno-9，但是不能匹配Rollno-</td></tr><tr><td>*</td><td>匹配之前的项0次或多次</td><td align="left">co*l 匹配cl、 col、 coool等</td></tr><tr><td>( )</td><td>创建一个用于匹配的子串</td><td align="left">ma(tri)?x 匹配max或maxtrix</td></tr><tr><td>{n}</td><td>匹配之前的项n次</td><td align="left">[0-9]{3} 匹 配 任 意 一 个 三 位 数 ， [0-9]{3} 可 以 扩 展 为<code>[0-9][0-9][0-9]</code></td></tr><tr><td>{n, }</td><td>之前的项至少需要匹配n次</td><td align="left">[0-9]{2,} 匹配任意一个两位或更多位的数字</td></tr><tr><td>{n, m}</td><td>指定之前的项所必需匹配的最小次数和最大次数</td><td align="left">[0-9]{2,5} 匹配从两位数到五位数之间的任意一个数字</td></tr><tr><td>|</td><td>交替——匹配 | 两边的任意一项</td><td align="left">Oct  (1st | 2nd) 匹配Oct 1st或Oct 2nd</td></tr><tr><td>\</td><td>转义符可以将上面介绍的特殊字符进行转义</td><td align="left"><code>a\.b</code> 匹配a.b，但不能匹配ajb。通过在 . 之间加上前缀 \ ，从而忽略了 . 的特殊意义</td></tr></tbody></table><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>所有的字母和数字</td></tr><tr><td>[:alpha:]</td><td>所有字母</td></tr><tr><td>[:blank:]</td><td>水平制表符，空白等</td></tr><tr><td>[:cntrl:]</td><td>所有控制字符</td></tr><tr><td>[:digit:]</td><td>所有的数字</td></tr><tr><td><code>[:graph:]</code></td><td>所有可打印字符，不包括空格</td></tr><tr><td>[:lower:]</td><td>所有的小写字符</td></tr><tr><td>[:print:]</td><td>所有可打印字符，包括空格</td></tr><tr><td>[:punct:]</td><td>所有的标点字符</td></tr><tr><td>[:space:]</td><td>所有的横向或纵向的空白</td></tr><tr><td>[:upper:]</td><td>所有大写字母</td></tr></tbody></table><h3 id="4-2-grep命令"><a href="#4-2-grep命令" class="headerlink" title="4.2 grep命令"></a>4.2 grep命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-a<span class="comment"># 不要忽略二进制的数据。</span></span><br><span class="line">-A&lt;显示列数&gt;  <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之后的内容。</span></span><br><span class="line">-b<span class="comment"># 在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。</span></span><br><span class="line">-B&lt;显示列数&gt; <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前的内容。</span></span><br><span class="line">-c<span class="comment"># 计算符合范本样式的列数。</span></span><br><span class="line">-C&lt;显示列数&gt;或-&lt;显示列数&gt;<span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span></span><br><span class="line">-d&lt;进行动作&gt; <span class="comment"># 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</span></span><br><span class="line">-e&lt;范本样式&gt; <span class="comment"># 指定字符串做为查找文件内容的范本样式。</span></span><br><span class="line">-E<span class="comment"># 将范本样式为延伸的普通表示法来使用。</span></span><br><span class="line">-f&lt;范本文件&gt; <span class="comment"># 指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。</span></span><br><span class="line">-F<span class="comment"># 将范本样式视为固定字符串的列表。</span></span><br><span class="line">-G<span class="comment"># 将范本样式视为普通的表示法来使用。</span></span><br><span class="line">-h<span class="comment"># 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span></span><br><span class="line">-H<span class="comment"># 在显示符合范本样式的那一列之前，表示该列所属的文件名称。</span></span><br><span class="line">-i<span class="comment"># 忽略字符大小写的差别。</span></span><br><span class="line">-l<span class="comment"># 列出文件内容符合指定的范本样式的文件名称。</span></span><br><span class="line">-L<span class="comment"># 列出文件内容不符合指定的范本样式的文件名称。</span></span><br><span class="line">-n<span class="comment"># 在显示符合范本样式的那一列之前，标示出该列的列数编号。</span></span><br><span class="line">-q<span class="comment"># 不显示任何信息。</span></span><br><span class="line">-r<span class="comment"># 此参数的效果和指定“-d recurse”参数相同。</span></span><br><span class="line">-s<span class="comment"># 不显示错误信息。</span></span><br><span class="line">-v<span class="comment"># 反转查找。</span></span><br><span class="line">-V<span class="comment"># 显示版本信息。</span></span><br><span class="line">-w<span class="comment"># 只显示全字符合的列。</span></span><br><span class="line">-x<span class="comment"># 只显示全列符合的列。</span></span><br><span class="line">-o <span class="comment"># 只输出文件中匹配到的部分。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个grep命令也可以对多个文件进行搜索：</span></span><br><span class="line">$ grep <span class="string">"match_text"</span> file1 file2 file3 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># grep -E选项——这意味着使用扩展（extended）正则表达式：</span></span><br><span class="line">$ grep -E <span class="string">"[a-z]+"</span> filename</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ egrep <span class="string">"[a-z]+"</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只输出文件中匹配到的文本部分，可以使用选项 -o：</span></span><br><span class="line">$ <span class="built_in">echo</span> this is a line. | egrep -o <span class="string">"[a-z]+\."</span></span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印除包含match_pattern行之外的所有行，选项-v可以将匹配结果进行反转（invert）。可使用：</span></span><br><span class="line">$ grep -v match_pattern file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件或文本中包含匹配字符串的行数：</span></span><br><span class="line">$ grep -c <span class="string">"text"</span> filename</span><br><span class="line">10</span><br><span class="line"><span class="comment"># 需要注意的是-c只是统计匹配行的数量，并不是匹配的次数。。例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1 2 3 4\nhello\n5 6"</span> | egrep -c <span class="string">"[0-9]"</span></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要文件中统计匹配项的数量，可以使用下面的技巧：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1 2 3 4\nhello\n5 6"</span> | egrep -o <span class="string">"[0-9]"</span> | wc -l</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模式匹配所位于的字符或字节偏移：</span></span><br><span class="line">$ <span class="built_in">echo</span> gnu is not unix | grep -b -o <span class="string">"not"</span></span><br><span class="line">7:not</span><br><span class="line"><span class="comment"># 选项 -b总是和 -o配合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索多个文件并找出匹配文本位于哪一个文件中：</span></span><br><span class="line">$ grep -l linux sample1.txt sample2.txt</span><br><span class="line">sample1.txt</span><br><span class="line">sample2.txt</span><br><span class="line"><span class="comment"># 和-l相反的选项是-L，它会返回一个不匹配的文件列表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep的选项-R和-r功能一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略样式中的大小写</span></span><br><span class="line">$ <span class="built_in">echo</span> hello world | grep -i <span class="string">"HELLO"</span></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># grep匹配多个样式</span></span><br><span class="line">$ <span class="built_in">echo</span> this is a line of text | grep -e <span class="string">"this"</span> -e <span class="string">"line"</span> -o</span><br><span class="line">this</span><br><span class="line">line</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在grep搜索中指定或排除文件</span></span><br><span class="line">$ grep <span class="string">"main()"</span> . -r --include *.&#123;c,cpp&#125; <span class="comment"># 目录中递归搜索所有的 .c和 .cpp文件</span></span><br><span class="line"><span class="comment"># 如果需要排除目录，可以使用 --exclude-dir选项。</span></span><br><span class="line"><span class="comment"># 如果需要从文件中读取所需排除的文件列表，使用--exclude-from FILE。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用0值字节作为后缀的grep与xargs，为了指明输入的文件名是以0值字节（\0）作为终止符，需要在xargs中使用-0。</span></span><br><span class="line"><span class="comment"># grep使用-Z选项输出以0值字节作为终结符的文件名（\0）。</span></span><br><span class="line">$ grep <span class="string">"test"</span> file* -lZ | xargs -0 rm</span><br><span class="line"><span class="comment"># -Z通常和 -l结合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep的静默输出</span></span><br><span class="line"><span class="comment"># grep的静默选项（-q）来实现。在静默模式中， grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之后的3行，使用 -A选项：</span></span><br><span class="line">$ seq 10 | grep 5 -A 3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之前的3行，使用 -B选项：</span></span><br><span class="line">$ seq 10 | grep 5 -B 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之前以及之后的3行，使用-C选项：</span></span><br><span class="line">$ seq 10 | grep 5 -C 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有多个匹配，那么使用--作为各部分之间的定界符：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"a\nb\nc\na\nb\nc"</span> | grep a -A 1</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h3 id="4-3-cut-按列切分文件"><a href="#4-3-cut-按列切分文件" class="headerlink" title="4.3 cut 按列切分文件"></a>4.3 cut 按列切分文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示第2列和第3列：</span></span><br><span class="line">$ cut -f 2,3 filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>记法</th><th>范围</th></tr></thead><tbody><tr><td>N -</td><td>从第N个字节，字符或字段到行尾</td></tr><tr><td>N - M</td><td>从第N个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td></tr><tr><td>- M</td><td>第1个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td></tr></tbody></table><p>结合下列选项将字段指定为某个范围内的字节或字符 ：</p><ul><li>-b ：表示字节</li><li>-c ：表示字符</li><li>-f ：用于定义字段</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat range_fields.txt</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印第1个到第5个字符：</span></span><br><span class="line">$ cut -c1-5 range_fields.txt</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line"><span class="comment"># 打印前2个字符：</span></span><br><span class="line">$ cut range_fields.txt -c -2</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br></pre></td></tr></table></figure><h3 id="4-4-sed-进行文本替换"><a href="#4-4-sed-进行文本替换" class="headerlink" title="4.4 sed 进行文本替换"></a>4.4 sed 进行文本替换</h3><p>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-e &lt;script&gt;<span class="comment"># 以选项中指定的script来处理输入的文本文件</span></span><br><span class="line">-f &lt;script&gt;<span class="comment"># 以选项中指定的script文件来处理输入的文本文件</span></span><br><span class="line">-h<span class="comment"># 显示帮助</span></span><br><span class="line">-n<span class="comment"># 仅显示script处理后的结果</span></span><br><span class="line">-V<span class="comment"># 显示版本信息</span></span><br></pre></td></tr></table></figure><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a\ <span class="comment"># 在当前行下面插入文本。</span></span><br><span class="line">i\ <span class="comment"># 在当前行上面插入文本。</span></span><br><span class="line">c\ <span class="comment"># 把选定的行改为新的文本。 </span></span><br><span class="line">d <span class="comment"># 删除，删除选择的行。 </span></span><br><span class="line">D <span class="comment"># 删除模板块的第一行。</span></span><br><span class="line">s <span class="comment"># 替换指定字符 h 拷贝模板块的内容到内存中的缓冲区。 </span></span><br><span class="line">H <span class="comment"># 追加模板块的内容到内存中的缓冲区。 </span></span><br><span class="line">g <span class="comment"># 获得内存缓冲区的内容，并替代当前模板块中的文本。 </span></span><br><span class="line">G <span class="comment"># 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 </span></span><br><span class="line">l <span class="comment"># 列表不能打印字符的清单。 </span></span><br><span class="line">n <span class="comment"># 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 </span></span><br><span class="line">N <span class="comment"># 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 </span></span><br><span class="line">p <span class="comment"># 打印模板块的行。 P(大写) 打印模板块的第一行。 </span></span><br><span class="line">q <span class="comment"># 退出Sed。 </span></span><br><span class="line">b lable <span class="comment"># 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 </span></span><br><span class="line">r file <span class="comment"># 从file中读行。 </span></span><br><span class="line">t label <span class="comment"># if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 </span></span><br><span class="line">T label <span class="comment"># 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span></span><br><span class="line">w file <span class="comment"># 写并追加模板块到file末尾。 </span></span><br><span class="line">W file <span class="comment"># 写并追加模板块的第一行到file末尾。 </span></span><br><span class="line">! <span class="comment"># 表示后面的命令对所有没有被选定的行发生作用。 </span></span><br><span class="line">= <span class="comment"># 打印当前行号码。 </span></span><br><span class="line"><span class="comment"># 把注释扩展到下一个换行符以前。</span></span><br></pre></td></tr></table></figure><p>sed 替换标记：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g <span class="comment"># 表示行内全面替换。</span></span><br><span class="line">p <span class="comment"># 表示打印行。 </span></span><br><span class="line">w <span class="comment"># 表示把行写入一个文件。 </span></span><br><span class="line">x <span class="comment"># 表示互换模板块中的文本和缓冲区中的文本。 </span></span><br><span class="line">y <span class="comment"># 表示把一个字符翻译为另外的字符（但是不用于正则表达式） </span></span><br><span class="line">\1 <span class="comment"># 子串匹配标记 </span></span><br><span class="line">&amp; <span class="comment"># 已匹配字符串标记</span></span><br></pre></td></tr></table></figure><p>sed 元字符集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">^ <span class="comment"># 匹配行开始，如：/^sed/匹配所有以sed开头的行。</span></span><br><span class="line">$ <span class="comment"># 匹配行结束，如：/sed$/匹配所有以sed结尾的行。 </span></span><br><span class="line">. <span class="comment"># 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 </span></span><br><span class="line">* <span class="comment"># 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 </span></span><br><span class="line">[] <span class="comment"># 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 </span></span><br><span class="line">[^] <span class="comment"># 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/ 匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</span></span><br><span class="line">\(..\) <span class="comment"># 匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。 </span></span><br><span class="line">&amp; <span class="comment"># 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 </span></span><br><span class="line">\&lt;  <span class="comment"># 匹配单词的开始，如:/\&lt;love/匹配包含以开头的单词的行。</span></span><br><span class="line">\&gt;<span class="comment"># 匹配单词的结束，如:/love\&gt;/匹配包含以love结尾的单词的行。</span></span><br><span class="line">x\&#123;m\&#125; <span class="comment"># 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。 </span></span><br><span class="line">x\&#123;m,\&#125; <span class="comment"># 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。 </span></span><br><span class="line">x\&#123;m,n\&#125; <span class="comment"># 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed可以替换给定文本中的字符串。</span></span><br><span class="line">$ sed <span class="string">'s/pattern/replace_string/'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要在替换的同时保存更改，可以使用-i选项</span></span><br><span class="line">$ sed -i <span class="string">'s/text/replace/'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后缀/g意味着sed会替换每一处匹配。但是有时候我们只需要从第n处匹配开始替换。对此，可以使用/Ng选项。</span></span><br><span class="line">$ sed <span class="string">'s/pattern/replace_string/g'</span> file</span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/2g'</span></span><br><span class="line">thisTHISTHISTHIS</span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/3g'</span></span><br><span class="line">thisthisTHISTHIS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符/在sed中被作为定界符使用。我们可以像下面一样使用任意的定界符：</span></span><br><span class="line">$ sed <span class="string">'s:text:replace:g'</span></span><br><span class="line">$ sed <span class="string">'s|text|replace|g'</span></span><br><span class="line"><span class="comment"># 当定界符出现在样式内部时，我们必须用前缀\对它进行转义：</span></span><br><span class="line">$ sed <span class="string">'s|te\|xt|replace|g'</span></span><br><span class="line"><span class="comment"># \|是一个出现在样式内部并经过转义的定界符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除空白行</span></span><br><span class="line">$ sed <span class="string">'/^$/d'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已匹配字符串标记（&amp;）在sed中，我们可以用 &amp;标记匹配样式的字符串，这样就能够在替换字符串时使用已匹配的内容。</span></span><br><span class="line">$ <span class="built_in">echo</span> this is an example | sed <span class="string">'s/\w\+/[&amp;]/g'</span></span><br><span class="line">[this] [is] [an] [example]</span><br><span class="line"><span class="comment"># 正则表达式 \w\+ 匹配每一个单词，然后我们用[&amp;]替换它。 &amp; 对应于之前所匹配到的单词。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合多个表达式</span></span><br><span class="line">$ sed <span class="string">'expression'</span> | sed <span class="string">'expression'</span></span><br><span class="line"><span class="comment"># 它等价于</span></span><br><span class="line">$ sed <span class="string">'expression; expression'</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ sed -e <span class="string">'expression'</span> -e expression<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 引用。sed表达式通常用单引号来引用。双引号会通过对表达式求值来对其进行扩展。</span></span><br><span class="line"><span class="string">$ text=hello</span></span><br><span class="line"><span class="string">$ echo hello world | sed "s/$text/HELLO/"</span></span><br><span class="line"><span class="string">HELLO world</span></span><br></pre></td></tr></table></figure><h3 id="4-5-awk-进行高级文本处理"><a href="#4-5-awk-进行高级文本处理" class="headerlink" title="4.5 awk 进行高级文本处理"></a>4.5 awk 进行高级文本处理</h3><h4 id="4-5-1-awk-常用命令选项"><a href="#4-5-1-awk-常用命令选项" class="headerlink" title="4.5.1 awk 常用命令选项"></a>4.5.1 awk 常用命令选项</h4><ul><li><code>-F fs</code>        fs指定输入分隔符，fs可以是字符串或正则表达式，如<code>-F:</code><ul><li><code>-v var=value</code>   赋值一个用户定义变量，将外部变量传递给awk </li></ul></li><li><code>-f scripfile</code>      从脚本文件中读取awk命令 </li><li><code>-m[fr] val</code>          对val值设置内在限制，<code>-mf</code> 选项限制分配给val的最大块数目；<code>-mr</code> 选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li></ul><h4 id="4-5-2-awk-脚本基本结构"><a href="#4-5-2-awk-脚本基本结构" class="headerlink" title="4.5.2 awk 脚本基本结构"></a>4.5.2 awk 脚本基本结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; print "start" &#125; pattern&#123; commands &#125; END&#123; print "end" &#125;'</span> file</span><br><span class="line"><span class="comment"># 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;'</span> filename </span><br><span class="line">$ awk <span class="string">"BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;"</span> filename</span><br></pre></td></tr></table></figure><h4 id="4-5-3-awk-的工作原理"><a href="#4-5-3-awk-的工作原理" class="headerlink" title="4.5.3 awk 的工作原理"></a>4.5.3 awk 的工作原理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;'</span></span><br></pre></td></tr></table></figure><ul><li>第一步：执行 <code>BEGIN{ commands }</code> 语句块中的语句</li><li>第二步：从文件或标准输入(stdin)读取一行，然后执行 <code>pattern{ commands }</code> 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕</li><li>第三步：当读至输入流末尾时，执行 <code>END{ commands }</code> 语句块</li></ul><h4 id="4-5-4-awk-内置变量（预定义变量）"><a href="#4-5-4-awk-内置变量（预定义变量）" class="headerlink" title="4.5.4 awk 内置变量（预定义变量）"></a>4.5.4 awk 内置变量（预定义变量）</h4><p><strong>说明：</strong>  <code>[A][N][P][G]</code>表示第一个支持变量的工具，<code>[A]=awk</code>、<code>[N]=nawk</code>、<code>[P]=POSIXawk</code>、<code>[G]=gawk</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$n</span> <span class="comment"># 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 </span></span><br><span class="line"><span class="variable">$0</span> <span class="comment"># 这个变量包含执行过程中当前行的文本内容。 </span></span><br><span class="line">[N] ARGC <span class="comment"># 命令行参数的数目。 </span></span><br><span class="line">[G] ARGIND <span class="comment"># 命令行中当前文件的位置（从0开始算）。 </span></span><br><span class="line">[N] ARGV <span class="comment"># 包含命令行参数的数组。 </span></span><br><span class="line">[G] CONVFMT <span class="comment"># 数字转换格式（默认值为%.6g）。 </span></span><br><span class="line">[P] ENVIRON <span class="comment"># 环境变量关联数组。 </span></span><br><span class="line">[N] ERRNO <span class="comment"># 最后一个系统错误的描述。 </span></span><br><span class="line">[G] FIELDWIDTHS <span class="comment"># 字段宽度列表（用空格键分隔）。 </span></span><br><span class="line">[A] FILENAME <span class="comment"># 当前输入文件的名。 </span></span><br><span class="line">[P] FNR <span class="comment"># 同NR，但相对于当前文件。 </span></span><br><span class="line">[A] FS <span class="comment"># 字段分隔符（默认是任何空格）。 </span></span><br><span class="line">[G] IGNORECASE <span class="comment"># 如果为真，则进行忽略大小写的匹配。 </span></span><br><span class="line">[A] NF <span class="comment"># 表示字段数，在执行过程中对应于当前的字段数。 </span></span><br><span class="line">[A] NR <span class="comment"># 表示记录数，在执行过程中对应于当前的行号。 </span></span><br><span class="line">[A] OFMT <span class="comment"># 数字的输出格式（默认值是%.6g）。 </span></span><br><span class="line">[A] OFS <span class="comment"># 输出字段分隔符（默认值是一个空格）。 </span></span><br><span class="line">[A] ORS <span class="comment"># 输出记录分隔符（默认值是一个换行符）。 </span></span><br><span class="line">[A] RS <span class="comment"># 记录分隔符（默认是一个换行符）。 </span></span><br><span class="line">[N] RSTART <span class="comment"># 由match函数所匹配的字符串的第一个位置。 </span></span><br><span class="line">[N] RLENGTH <span class="comment"># 由match函数所匹配的字符串的长度。 </span></span><br><span class="line">[N] SUBSEP <span class="comment"># 数组下标分隔符（默认值是34）。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3nline2 f4 f5nline3 f6 f7"</span> | awk <span class="string">'&#123;print "Line No:"NR", No of fields:"NF, "$0="$0, "$1="$1, "$2="$2, "$3="$3&#125;'</span> </span><br><span class="line">Line No:1, No of fields:3 <span class="variable">$0</span>=line1 f2 f3 <span class="variable">$1</span>=line1 <span class="variable">$2</span>=f2 <span class="variable">$3</span>=f3 </span><br><span class="line">Line No:2, No of fields:3 <span class="variable">$0</span>=line2 f4 f5 <span class="variable">$1</span>=line2 <span class="variable">$2</span>=f4 <span class="variable">$3</span>=f5 </span><br><span class="line">Line No:3, No of fields:3 <span class="variable">$0</span>=line3 f6 f7 <span class="variable">$1</span>=line3 <span class="variable">$2</span>=f6 <span class="variable">$3</span>=f7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3n line2 f4 f5"</span> | awk <span class="string">'&#123;print $NF&#125;'</span> </span><br><span class="line">f3</span><br><span class="line">f5</span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3n line2 f4 f5"</span> | awk <span class="string">'&#123;print $(NF-1)&#125;'</span> </span><br><span class="line">f2 </span><br><span class="line">f4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每一行的第二和第三个字段：</span></span><br><span class="line">$ awk <span class="string">'&#123; print $2,$3 &#125;'</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件中的行数：</span></span><br><span class="line">$ awk <span class="string">'END&#123; print NR &#125;'</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个每一行中第一个字段值累加的例子：</span></span><br><span class="line">$ seq 5 | awk <span class="string">'BEGIN&#123; sum=0; print "总和：" &#125; &#123; print $1"+"; sum+=$1 &#125; END&#123; print "等于"; print sum &#125;'</span> </span><br><span class="line">总和： </span><br><span class="line">1+ </span><br><span class="line">2+ </span><br><span class="line">3+ </span><br><span class="line">4+ </span><br><span class="line">5+ </span><br><span class="line">等于 </span><br><span class="line">15</span><br></pre></td></tr></table></figure><h4 id="4-5-5-将外部变量值传递给awk"><a href="#4-5-5-将外部变量值传递给awk" class="headerlink" title="4.5.5 将外部变量值传递给awk"></a>4.5.5 将外部变量值传递给awk</h4><p>借助 <code>-v</code> 选项，可以将外部值（并非来自stdin）传递给awk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ VAR=10000 </span><br><span class="line">$ <span class="built_in">echo</span> | awk -v VARIABLE=<span class="variable">$VAR</span> <span class="string">'&#123; print VARIABLE &#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种传递外部变量方法：</span></span><br><span class="line">$ var1=<span class="string">"aaa"</span> </span><br><span class="line">$ var2=<span class="string">"bbb"</span> </span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当输入来自于文件时使用：</span></span><br><span class="line">$ awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span> filename</span><br></pre></td></tr></table></figure><h4 id="4-5-6-awk-运算与判断"><a href="#4-5-6-awk-运算与判断" class="headerlink" title="4.5.6 awk 运算与判断"></a>4.5.6 awk 运算与判断</h4><p><strong>算数运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+ -</td><td>加、减</td></tr><tr><td>* / &amp;</td><td>乘，除与求余</td></tr><tr><td>+ - !</td><td>一元加、减和逻辑非</td></tr><tr><td>^ ***</td><td>求幂</td></tr><tr><td>++ –</td><td>增加或减少，作为前缀或后缀</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";print a++,++a;&#125;'</span> </span><br><span class="line">0 2</span><br></pre></td></tr></table></figure><p style="color=red">**注意：**所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</p><p><strong>赋值运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>= += -= <em>= /= %= ^= *</em>=</td><td>赋值语句</td></tr></tbody></table><p><strong>逻辑运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>||</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);&#125;'</span></span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><p><strong>正则运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>~  ~!</td><td>匹配正则表达式和不匹配正则表达式</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="100testa";if(a ~ /^100*/)&#123;print "ok";&#125;&#125;'</span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><strong>关系运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&lt;  &lt;=  &gt;  &gt;=  !=  ==</td><td>关系运算符</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a=11;if(a &gt;= 9)&#123;print "ok";&#125;&#125;'</span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p style="color=red">**注意：**>  < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。</p><p><strong>其他运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>字段引用</td></tr><tr><td>空格</td><td>字符串连接符</td></tr><tr><td>? :</td><td>C条件表达式</td></tr><tr><td>in</td><td>数组中是否存在某键值</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";print a=="b"?"ok":"err";&#125;'</span> </span><br><span class="line">ok </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";arr[0]="b";arr[1]="c";print (a in arr);&#125;'</span> </span><br><span class="line">0 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";arr[0]="b";arr["b"]="c";print (a in arr);&#125;'</span> </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>运算级优先级表：</p><table><thead><tr><th>级别</th><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>=, +=, -=, *=, /=, %=, &amp;=, ^=, |=, &lt;&lt;=, &gt;&gt;=</td><td>赋值、运算</td></tr><tr><td>2</td><td>||</td><td>逻辑或</td></tr><tr><td>3</td><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>4</td><td>|</td><td>按位或</td></tr><tr><td>5</td><td>^</td><td>按位异或</td></tr><tr><td>6</td><td>&amp;</td><td>按位与</td></tr><tr><td>7</td><td>==, !=</td><td>等于、不等于</td></tr><tr><td>8</td><td>&lt;=, &gt;=, &lt;, &gt;</td><td>小于等于、大于等于、小于、大于</td></tr><tr><td>9</td><td>&lt;&lt;, &gt;&gt;</td><td>按位左移，按位右移</td></tr><tr><td>10</td><td>+, -</td><td>加、减</td></tr><tr><td>11</td><td>*, /, %</td><td>乘、除、取模</td></tr><tr><td>12</td><td>!, ~</td><td>逻辑非、按位取反或补码</td></tr><tr><td>13</td><td>-, +</td><td>正、负</td></tr></tbody></table><p>级别越高越优先</p><h4 id="4-5-7-awk-高级输入输出"><a href="#4-5-7-awk-高级输入输出" class="headerlink" title="4.5.7 awk 高级输入输出"></a>4.5.7 awk 高级输入输出</h4><p><strong>读取下一条记录：</strong></p><p>awk中 <code>next</code> 语句使用：在循环逐行匹配，如果遇到 <code>next</code>，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。net语句一般用于多行合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt </span><br><span class="line">a </span><br><span class="line">b </span><br><span class="line">c </span><br><span class="line">d </span><br><span class="line">e </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;'</span> text.txt </span><br><span class="line">2 b </span><br><span class="line">4 d</span><br></pre></td></tr></table></figure><p>当记录行号除以2余1，就跳过当前行。下面的 <code>print NR,$0</code> 也不会执行。下一行开始，程序有开始判断 <code>NR%2</code> 值。这个时候记录行号是 <code>：2</code>  ，就会执行下面语句块：<code>&#39;print NR,$0&#39;</code> </p><p>分析发现需要将包含有 “web” 行进行跳过，然后需要将内容与下面行合并为一行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt </span><br><span class="line">web01[192.168.2.100] </span><br><span class="line">httpd ok </span><br><span class="line">tomcat ok </span><br><span class="line">sendmail ok </span><br><span class="line">web02[192.168.2.101] </span><br><span class="line">httpd ok </span><br><span class="line">postfix ok </span><br><span class="line">web03[192.168.2.102] </span><br><span class="line">mysqld ok </span><br><span class="line">httpd ok </span><br><span class="line">0 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'/^web/&#123;T=$0;next;&#125;&#123;print T":t"$0;&#125;'</span> test.txt </span><br><span class="line">web01[192.168.2.100]: httpd ok </span><br><span class="line">web01[192.168.2.100]: tomcat ok </span><br><span class="line">web01[192.168.2.100]: sendmail ok </span><br><span class="line">web02[192.168.2.101]: httpd ok </span><br><span class="line">web02[192.168.2.101]: postfix ok </span><br><span class="line">web03[192.168.2.102]: mysqld ok </span><br><span class="line">web03[192.168.2.102]: httpd ok</span><br></pre></td></tr></table></figure><p><strong>简单地读取一条记录：</strong></p><p><code>awk getline</code> 用法：输出重定向需用到 <code>getline函数</code>。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。</p><p style="color=red">如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。 </p><p></p><blockquote><p>getline语法：getline var，变量var包含了特定行的内容。 </p></blockquote><p>awk getline从整体上来说，用法说明：</p><ul><li><strong>当其左右<p style="color=red">无</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline作用于当前文件，读入当前文件的第一行给其后跟的变量 <code>var</code> 或 <code>$0</code>（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。</li><li><strong>当其左右<p style="color=red">有</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; "date" | getline out; print out &#125;'</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，split函数把变量out转化成数组mon，然后打印数组mon的第二个元素：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; "date" | getline out; split(out,mon); print mon[2] &#125;'</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; while( "ls" | getline) print &#125;'</span></span><br></pre></td></tr></table></figure><p><strong>关闭文件：</strong></p><p>awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(<span class="string">"filename"</span>)</span><br></pre></td></tr></table></figure><p>filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。</p><p><strong>输出到一个文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt; "datafile"&#125;'</span></span><br><span class="line">或 </span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt;&gt; "datafile"&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="4-5-8-设置字段定界符"><a href="#4-5-8-设置字段定界符" class="headerlink" title="4.5.8 设置字段定界符"></a>4.5.8 设置字段定界符</h4><p style="color=red">默认的字段定界符是空格</p>，可以使用 `-F "定界符"` 明确指定一个定界符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F: <span class="string">'&#123; print $NF &#125;'</span> /etc/passwd </span><br><span class="line">或 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123; FS=":" &#125; &#123; print $NF &#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>在 <code>BEGIN语句块</code> 中则可以用 <code>OFS=“定界符”</code> 设置输出字段的定界符。</p><h4 id="4-5-9-流程控制语句"><a href="#4-5-9-流程控制语句" class="headerlink" title="4.5.9 流程控制语句"></a>4.5.9 流程控制语句</h4><p><strong>条件判断语句：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100; </span></span><br><span class="line"><span class="string">if(test&gt;90)&#123; </span></span><br><span class="line"><span class="string">print "very good"; </span></span><br><span class="line"><span class="string">&#125; else if(test&gt;60)&#123; </span></span><br><span class="line"><span class="string">print "good"; </span></span><br><span class="line"><span class="string">&#125; else&#123; </span></span><br><span class="line"><span class="string">print "no pass"; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">very good</span><br></pre></td></tr></table></figure><p>每条命令语句后面可以用 <code>;</code> </p><p style="color=red">分号</p>结尾。<p></p><p><strong>循环语句：</strong></p><p>while语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">while(i&lt;=test)&#123; </span></span><br><span class="line"><span class="string">total+=i; i++; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>for循环：</p><p>格式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(k in ENVIRON)&#123; </span></span><br><span class="line"><span class="string">print k"="ENVIRON[k]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line">TERM=linux </span><br><span class="line">G_BROKEN_FILENAMES=1 </span><br><span class="line">SHLVL=1 </span><br><span class="line"><span class="built_in">pwd</span>=/root/text </span><br><span class="line">... </span><br><span class="line">logname=root </span><br><span class="line">HOME=/root </span><br><span class="line">SSH_CLIENT=192.168.1.21 53087 22</span><br></pre></td></tr></table></figure><p><strong>注：</strong>ENVIRON是awk常量，是子典型数组。</p><p>格式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">for(i=0;i&lt;=100;i++)&#123; </span></span><br><span class="line"><span class="string">total+=i; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>do循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">i=0; </span></span><br><span class="line"><span class="string">do &#123;</span></span><br><span class="line"><span class="string">total+=i;i++;</span></span><br><span class="line"><span class="string">&#125; while(i&lt;=100) </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p><strong>其他语句：</strong></p><ul><li><strong>break</strong>          当 break 语句用于 while 或 for 语句时，导致退出程序循环</li><li><strong>continue</strong>       当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代</li><li><strong>next</strong>               能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程</li><li><strong>exit</strong>                 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行</li></ul><h4 id="4-5-10-数组应用"><a href="#4-5-10-数组应用" class="headerlink" title="4.5.10 数组应用"></a>4.5.10 数组应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到数组长度</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";lens=split(info,tA," ");print length(tA),lens;&#125;'</span> </span><br><span class="line">4 4</span><br><span class="line"><span class="comment"># length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># asort对数组进行排序，返回数组长度。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";split(info,tA," ");print asort(tA);&#125;'</span> </span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组内容（无序，有序输出）：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";split(info,tA," ");for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">4 <span class="built_in">test</span> </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line"></span><br><span class="line"><span class="comment"># for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";tlen=split(info,tA," ");for(k=1;k&lt;=tlen;k++)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line">4 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 注意：数组下标是从1开始，与C数组不一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断键值存在以及删除键值：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";if( "c" in tB)&#123;print "ok";&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;'</span> </span><br><span class="line">a a1 </span><br><span class="line">b b1</span><br><span class="line"><span class="comment"># 删除键值： </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";delete tB["a"];for(k in tB)&#123;print k,tB[k];&#125;&#125;'</span> </span><br><span class="line">b b1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维、多维数组使用</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(i=1;i&lt;=9;i++)&#123; </span></span><br><span class="line"><span class="string">for(j=1;j&lt;=9;j++)&#123; </span></span><br><span class="line"><span class="string">tarr[i,j]=i*j; </span></span><br><span class="line"><span class="string">print i,"*",j,"=",tarr[i,j]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line">1 * 1 = 1 </span><br><span class="line">1 * 2 = 2 </span><br><span class="line">1 * 3 = 3 </span><br><span class="line">1 * 4 = 4 </span><br><span class="line">1 * 5 = 5 </span><br><span class="line">1 * 6 = 6 </span><br><span class="line">... </span><br><span class="line">9 * 6 = 54 </span><br><span class="line">9 * 7 = 63 </span><br><span class="line">9 * 8 = 72 </span><br><span class="line">9 * 9 = 81</span><br><span class="line"><span class="comment"># 可以通过array[k,k2]引用获得数组内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方法：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(i=1;i&lt;=9;i++)&#123; </span></span><br><span class="line"><span class="string">for(j=1;j&lt;=9;j++)&#123; </span></span><br><span class="line"><span class="string">tarr[i,j]=i*j; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">for(m in tarr)&#123; </span></span><br><span class="line"><span class="string">split(m,tarr2,SUBSEP); print tarr2[1],"*",tarr2[2],"=",tarr[m]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="4-5-11-内置函数"><a href="#4-5-11-内置函数" class="headerlink" title="4.5.11 内置函数"></a>4.5.11 内置函数</h4><p>awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数。</p><p><strong>算数函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>atan2( y, x )</td><td>返回 y/x 的反正切</td></tr><tr><td>cos( x )</td><td>返回 x 的余弦；x 是弧度</td></tr><tr><td>sin( x )</td><td>返回 x 的正弦；x 是弧度</td></tr><tr><td>exp( x )</td><td>返回 x 幂函数</td></tr><tr><td>log( x )</td><td>返回 x 的自然对数</td></tr><tr><td>sqrt( x )</td><td>返回 x 平方根</td></tr><tr><td>int( x )</td><td>返回 x 的截断至整数的值</td></tr><tr><td>rand( )</td><td>返回任意数字 n，其中 0 &lt;= n &lt; 1</td></tr><tr><td>srand( [expr] )</td><td>将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;OFMT="%.3f";fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;&#125;'</span> </span><br><span class="line">0.841 22026.466 2.303 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得随机数：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">78 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">31 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">41</span><br></pre></td></tr></table></figure><p><strong>字符串函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>gsub( Ere, Repl, [ In ] )</td><td>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行</td></tr><tr><td>sub( Ere, Repl, [ In ] )</td><td>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）</td></tr><tr><td>index( String1, String2 )</td><td>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）</td></tr><tr><td>length [(String)]</td><td>返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td></tr><tr><td>blength [(String)]</td><td>返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td></tr><tr><td>substr( String, M, [ N ] )</td><td>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度</td></tr><tr><td>match( String, Ere )</td><td>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）</td></tr><tr><td>split( String, A, [Ere] )</td><td>将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建</td></tr><tr><td>tolower( String )</td><td>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td></tr><tr><td>toupper( String )</td><td>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td></tr><tr><td>sprintf(Format, Expr, Expr, . . . )</td><td>根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串</td></tr></tbody></table><p><strong>注：</strong>Ere都可以是正则表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gsub,sub使用 </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";gsub(/[0-9]+/,"!",info);print info&#125;'</span> </span><br><span class="line">this is a <span class="built_in">test</span>!<span class="built_in">test</span>!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找字符串（index使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print index(info,"test")?"ok":"no found";&#125;'</span> </span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式匹配查找(match使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print match(info,/[0-9]+/)?"ok":"no found";&#125;'</span> </span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取字符串(substr使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print substr(info,4,10);&#125;'</span> </span><br><span class="line">s is a tes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串分割（split使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test";split(info,tA," ");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">4 </span><br><span class="line">4 <span class="built_in">test</span> </span><br><span class="line">1 this </span><br><span class="line">2 is </span><br><span class="line">3 a</span><br></pre></td></tr></table></figure><p><strong>格式化字符串输出（sprintf使用）</strong> </p><p>格式化字符串格式：</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%d</td><td>十进制有符号整数</td></tr><tr><td>%u</td><td>十进制无符号整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%c</td><td>单个字符</td></tr><tr><td>%p</td><td>指针的值</td></tr><tr><td>%e</td><td>指数形式的浮点数</td></tr><tr><td>%x</td><td>%X 无符号以十六进制表示的整数</td></tr><tr><td>%o</td><td>无符号以八进制表示的整数</td></tr><tr><td>%g</td><td>自动选择合适的表示法</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;n1=124.113;n2=-1.224;n3=1.2345; printf("%.2f,%.2u,%.2g,%X,%on",n1,n2,n3,n1,n1);&#125;'</span> </span><br><span class="line">124.11,18446744073709551615,1.2,7C,174</span><br></pre></td></tr></table></figure><p><strong>一般函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>close( Expression )</td><td>用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的</td></tr><tr><td>system(command )</td><td>执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程</td></tr><tr><td>Expression | getline [ Variable ]</td><td>从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td></tr><tr><td>getline [ Variable ] &lt; Expression</td><td>从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td></tr><tr><td>getline [ Variable ]</td><td>将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开外部文件（close用法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;while("cat /etc/passwd"|getline)&#123;print $0;&#125;;close("/etc/passwd");&#125;'</span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐行读取外部文件(getline使用方法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;while(getline &lt; "/etc/passwd")&#123;print $0;&#125;;close("/etc/passwd");&#125;'</span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin </span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;print "Enter your name:";getline name;print name;&#125;'</span> </span><br><span class="line">Enter your name: </span><br><span class="line">chengmo </span><br><span class="line">chengmo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用外部应用程序(system使用方法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;b=system("ls -al");print b;&#125;'</span> </span><br><span class="line">total 42092 </span><br><span class="line">drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 . </span><br><span class="line">drwxr-xr-x 95 root root 4096 10-08 14:01 .. </span><br><span class="line"><span class="comment"># b返回值，是执行结果。</span></span><br></pre></td></tr></table></figure><p><strong>时间函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>函数名</td><td>说明</td></tr><tr><td>mktime( YYYY MM dd HH MM ss[ DST])</td><td>生成时间格式</td></tr><tr><td>strftime([format [, timestamp]])</td><td>格式化时间输出，将时间戳转为时间字符串 具体格式，见下表.</td></tr><tr><td>systime()</td><td>得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建指定时间(mktime使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp=mktime("2001 01 01 12 12 12");print strftime("%c",tstamp);&#125;'</span> </span><br><span class="line">2001年01月01日 星期一 12时12分12秒 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=mktime("2001 02 01 0 0 0");print tstamp2-tstamp1;&#125;'</span> </span><br><span class="line">2634468 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 求2个时间段中间时间差，介绍了strftime使用方法 </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=systime();print tstamp2-tstamp1;&#125;'</span> </span><br><span class="line">308201392</span><br></pre></td></tr></table></figure><p>strftime日期和时间格式说明符</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%a</td><td>星期几的缩写（Sun）</td></tr><tr><td>%A</td><td>星期几的完整写法（Sunday）</td></tr><tr><td>%b</td><td>月名的缩写（Oct）</td></tr><tr><td>%B</td><td>月名的完整写法（October）</td></tr><tr><td>%c</td><td>本地日期和时间</td></tr><tr><td>%d</td><td>十进制日期</td></tr><tr><td>%D</td><td>日期 08/20/99</td></tr><tr><td>%e</td><td>日期，如果只有一位会补上一个空格</td></tr><tr><td>%H</td><td>用十进制表示24小时格式的时间</td></tr><tr><td>%I</td><td>用十进制表示12小时格式的时间</td></tr><tr><td>%j</td><td>从1月1日期一年中的第几天</td></tr><tr><td>%m</td><td>十进制表示的月份</td></tr><tr><td>%M</td><td>十进制表示的分钟</td></tr><tr><td>%p</td><td>12小时表示法（AM/PM）</td></tr><tr><td>%S</td><td>十进制表示的秒</td></tr><tr><td>%U</td><td>十进制表示的一年中的第几个星期（星期天作为一个星期的开始）</td></tr><tr><td>%w</td><td>十进制表示的星期几（星期天是0）</td></tr><tr><td>%W</td><td>十进制表示的一年中的第几个星期（星期一作为一个星期的开始）</td></tr><tr><td>%x</td><td>重新设置本地日期（08/20/99）</td></tr><tr><td>%X</td><td>重新设置本地时间（12 : 00 : 00）</td></tr><tr><td>%y</td><td>两位数字表示的年（99）</td></tr><tr><td>%Y</td><td>当前月份</td></tr><tr><td>%Z</td><td>时区（PDT）</td></tr><tr><td>%%</td><td>百分号（%）</td></tr></tbody></table><h3 id="4-6-find-对目录中的所有文件进行文本替换"><a href="#4-6-find-对目录中的所有文件进行文本替换" class="headerlink" title="4.6 find 对目录中的所有文件进行文本替换"></a>4.6 find 对目录中的所有文件进行文本替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有.cpp文件中的Copyright替换成Copyleft：</span></span><br><span class="line">$ find . -name *.cpp -print0 | xargs -I&#123;&#125; -0 sed -i <span class="string">'s/Copyright/Copyleft/g'</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-exec实现同样的效果：</span></span><br><span class="line">$ find . -name *.cpp -<span class="built_in">exec</span> sed -i <span class="string">'s/Copyright/Copyleft/g'</span> \&#123;\&#125; \;</span><br></pre></td></tr></table></figure><h2 id="5-一团乱麻"><a href="#5-一团乱麻" class="headerlink" title="5 一团乱麻"></a>5 一团乱麻</h2><h3 id="5-1-wget命令"><a href="#5-1-wget命令" class="headerlink" title="5.1 wget命令"></a>5.1 wget命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-a&lt;日志文件&gt;：<span class="comment"># 在指定的日志文件中记录资料的执行过程； </span></span><br><span class="line">-A&lt;后缀名&gt;： <span class="comment"># 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔； </span></span><br><span class="line">-b：   <span class="comment"># 进行后台的方式运行wget； </span></span><br><span class="line">-B&lt;连接地址&gt;：<span class="comment"># 设置参考的连接地址的基地地址； </span></span><br><span class="line">-c：   <span class="comment"># 继续执行上次终端的任务； </span></span><br><span class="line">-C&lt;标志&gt;： <span class="comment"># 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； </span></span><br><span class="line">-d：   <span class="comment"># 调试模式运行指令； </span></span><br><span class="line">-D&lt;域名列表&gt;：    <span class="comment"># 设置顺着的域名列表，域名之间用“，”分隔； </span></span><br><span class="line">-e&lt;指令&gt;： <span class="comment"># 作为文件“.wgetrc”中的一部分执行指定的指令； </span></span><br><span class="line">-h：   <span class="comment"># 显示指令帮助信息； </span></span><br><span class="line">-i&lt;文件&gt;： <span class="comment"># 从指定文件获取要下载的URL地址； </span></span><br><span class="line">-l&lt;目录列表&gt;：<span class="comment"># 设置顺着的目录列表，多个目录用“，”分隔； </span></span><br><span class="line">-L：   <span class="comment"># 仅顺着关联的连接； </span></span><br><span class="line">-r：   <span class="comment"># 递归下载方式； </span></span><br><span class="line">-nc：   <span class="comment"># 文件存在时，下载文件不覆盖原有文件； </span></span><br><span class="line">-nv：   <span class="comment"># 下载时只显示更新和出错信息，不显示指令的详细执行过程； </span></span><br><span class="line">-q：   <span class="comment"># 不显示指令执行过程； </span></span><br><span class="line">-nh：   <span class="comment"># 不查询主机名称； </span></span><br><span class="line">-v：   <span class="comment"># 显示详细执行过程； </span></span><br><span class="line">-V：   <span class="comment"># 显示版本信息； </span></span><br><span class="line">--passive-ftp：   <span class="comment"># 使用被动模式PASV连接FTP服务器； </span></span><br><span class="line">--follow-ftp：   <span class="comment"># 从HTML文件中下载FTP连接文件。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget下载单个文件 </span></span><br><span class="line">$ wget http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并以不同的文件名保存 </span></span><br><span class="line">$ wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># wget限速下载 </span></span><br><span class="line">$ wget --<span class="built_in">limit</span>-rate=300k http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用wget断点续传 </span></span><br><span class="line">$ wget -c http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用wget后台下载 </span></span><br><span class="line">$ wget -b http://www.linuxde.net/testfile.zip </span><br><span class="line">Continuing <span class="keyword">in</span> background, pid 1840. </span><br><span class="line">Output will be written to `wget-log<span class="string">'.</span></span><br><span class="line"><span class="string"># 对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载，你可以使用以下命令来察看下载进度： </span></span><br><span class="line"><span class="string">$ tail -f wget-log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 伪装代理名称下载 </span></span><br><span class="line"><span class="string">$ wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.linuxde.net/testfile.zip</span></span><br><span class="line"><span class="string"># 有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装。</span></span><br></pre></td></tr></table></figure><p><strong>测试下载链接：</strong></p><p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --spider URL</span><br></pre></td></tr></table></figure><p>如果下载链接正确，将会显示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spider mode enabled. Check if remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 200 OK </span><br><span class="line">Length: unspecified [text/html] </span><br><span class="line">Remote file exists and could contain further links, </span><br><span class="line">but recursion is disabled -- not retrieving.</span><br></pre></td></tr></table></figure><p>这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget --spider url </span><br><span class="line">Spider mode enabled. Check <span class="keyword">if</span> remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 404 Not Found </span><br><span class="line">Remote file does not exist -- broken link!!!</span><br></pre></td></tr></table></figure><p>你可以在以下几种情况下使用–spider参数：</p><ul><li>定时下载之前进行检查</li><li>间隔检测网站是否可用</li><li>检查网站页面的死链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加重试次数 </span></span><br><span class="line">$ wget --tries=40 URL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载多个文件 </span></span><br><span class="line">$ wget -i filelist.txt </span><br><span class="line"><span class="comment"># 首先，保存一份下载链接文件： </span></span><br><span class="line">$ cat &gt; filelist.txt </span><br><span class="line">url1 </span><br><span class="line">url2 </span><br><span class="line">url3 </span><br><span class="line">url4 </span><br><span class="line"><span class="comment"># 接着使用这个文件和参数-i下载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤指定格式下载 </span></span><br><span class="line">$ wget --reject=gif ur </span><br><span class="line"><span class="comment"># 下载一个网站，但你不希望下载图片，可以使用这条命令。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把下载信息存入日志文件 </span></span><br><span class="line">$ wget -o download.log URL </span><br><span class="line"><span class="comment"># 不希望下载信息直接显示在终端而是在一个日志文件，可以使用。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制总下载文件大小 </span></span><br><span class="line">$ wget -Q5m -i filelist.txt </span><br><span class="line"><span class="comment"># 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</span></span><br></pre></td></tr></table></figure><p><strong>镜像网站：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --mirror -p --convert-links -P ./LOCAL URL</span><br></pre></td></tr></table></figure><p>下载整个网站到本地。</p><ul><li>–mirror 开户镜像下载</li><li>-p 下载所有为了html页面显示正常的文件</li><li>–convert-links 下载后，转换成本地的链接</li><li>-P ./LOCAL URL 保存所有文件和目录到本地指定目录</li></ul><p><strong>下载指定格式文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -A.pdf url</span><br></pre></td></tr></table></figure><p>可以在以下情况使用该功能：</p><ul><li>下载一个网站的所有图片</li><li>下载一个网站的所有视频</li><li>下载一个网站的所有PDF文件</li></ul><p><strong>FTP下载：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp-url </span><br><span class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><p>可以使用wget来完成ftp链接的下载。 </p><p>使用wget匿名ftp下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp-url</span><br></pre></td></tr></table></figure><p>使用wget用户名和密码认证的ftp下载： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><h3 id="5-2-curl-命令"><a href="#5-2-curl-命令" class="headerlink" title="5.2 curl 命令"></a>5.2 curl 命令</h3><p>常见参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-A/--user-agent &lt;string&gt;              <span class="comment"># 设置用户代理发送给服务器</span></span><br><span class="line">-b/--cookie &lt;name=string/file&gt;      <span class="comment"># cookie字符串或文件读取位置</span></span><br><span class="line">-c/--cookie-jar &lt;file&gt;                <span class="comment"># 操作结束后把cookie写入到这个文件中</span></span><br><span class="line">-C/--<span class="built_in">continue</span>-at &lt;offset&gt;             <span class="comment"># 断点续转</span></span><br><span class="line">-D/--dump-header &lt;file&gt;               <span class="comment"># 把header信息写入到该文件中</span></span><br><span class="line">-e/--referer                          <span class="comment"># 来源网址</span></span><br><span class="line">-f/--fail                             <span class="comment"># 连接失败时不显示http错误</span></span><br><span class="line">-o/--output                           <span class="comment"># 把输出写到该文件中</span></span><br><span class="line">-O/--remote-name                      <span class="comment"># 把输出写到该文件中，保留远程文件的文件名</span></span><br><span class="line">-r/--range &lt;range&gt;                    <span class="comment"># 检索来自HTTP/1.1或FTP服务器字节范围</span></span><br><span class="line">-s/--silent                           <span class="comment"># 静音模式。不输出任何东西</span></span><br><span class="line">-T/--upload-file &lt;file&gt;               <span class="comment"># 上传文件</span></span><br><span class="line">-u/--user &lt;user[:password]&gt;           <span class="comment"># 设置服务器的用户和密码</span></span><br><span class="line">-w/--write-out [format]               <span class="comment"># 什么输出完成后</span></span><br><span class="line">-x/--proxy &lt;host[:port]&gt;              <span class="comment"># 在给定的端口上使用HTTP代理</span></span><br><span class="line">-<span class="comment">#/--progress-bar                     # 进度条显示当前的传送状态</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不显示进度信息使用--silent选项。</span></span><br><span class="line">$ curl URL --silent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用选项 -O 将下载的数据写入到文件，必须使用文件的绝对地址：</span></span><br><span class="line">$ curl http://man.linuxde.net/text.iso --silent -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条：</span></span><br><span class="line">$ curl http://man.linuxde.net/test.iso -o filename.iso --progress</span><br><span class="line"><span class="comment">######################################### 100.0%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断点续传</span></span><br><span class="line">$ curl URL/File -C 偏移量 </span><br><span class="line"><span class="comment"># 偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -： </span></span><br><span class="line">$ curl -C -URL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--referer选项指定参照页字符串： </span></span><br><span class="line">$ curl --referer http://www.google.com http://man.linuxde.net </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl设置cookies 使用--cookie "COKKIES"选项来指定cookie，多个cookie使用分号分隔： </span></span><br><span class="line">$ curl http://man.linuxde.net --cookie <span class="string">"user=root;pass=123456"</span> </span><br><span class="line"><span class="comment"># 将cookie另存为一个文件，使用--cookie-jar选项： </span></span><br><span class="line">$ curl URL --cookie-jar cookie_file </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl设置用户代理字符串 有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用--user-agent或者-A选项：</span></span><br><span class="line">$ curl URL --user-agent <span class="string">"Mozilla/5.0"</span> curl URL -A <span class="string">"Mozilla/5.0"</span> </span><br><span class="line"><span class="comment"># 其他HTTP头部信息也可以使用curl来发送，使用-H"头部信息" 传递多个头部信息，例如： </span></span><br><span class="line">$ curl -H <span class="string">"Host:man.linuxde.net"</span> -H <span class="string">"accept-language:zh-cn"</span> URL </span><br><span class="line"></span><br><span class="line"><span class="comment"># curl的带宽控制和下载配额 使用--limit-rate限制curl的下载速度： </span></span><br><span class="line">$ curl URL --<span class="built_in">limit</span>-rate 50k </span><br><span class="line"><span class="comment"># 命令中用k（千字节）和m（兆字节）指定下载速度限制。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--max-filesize指定可下载的最大文件大小： </span></span><br><span class="line">$ curl URL --max-filesize bytes </span><br><span class="line"><span class="comment"># 如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl进行认证 使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码： </span></span><br><span class="line">$ curl -u user:<span class="built_in">pwd</span> http://man.linuxde.net </span><br><span class="line">$ curl -u user http://man.linuxde.net </span><br><span class="line"></span><br><span class="line"><span class="comment"># 只打印响应头部信息 通过-I或者-head可以只打印出HTTP头部信息： </span></span><br><span class="line">$ curl -I http://man.linuxde.net </span><br><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Server: nginx/1.2.5 </span><br><span class="line">date: Mon, 10 Dec 2012 09:24:34 GMT </span><br><span class="line">Content-Type: text/html; charset=UTF-8 </span><br><span class="line">Connection: keep-alive </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Pingback: http://man.linuxde.net/xmlrpc.php</span><br></pre></td></tr></table></figure><p>其他参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">-a/--append                    <span class="comment"># 上传文件时，附加到目标文件</span></span><br><span class="line">--anyauth                      <span class="comment"># 可以使用“任何”身份验证方法</span></span><br><span class="line">--basic                        <span class="comment"># 使用HTTP基本验证</span></span><br><span class="line">-B/--use-ascii                 <span class="comment"># 使用ASCII文本传输</span></span><br><span class="line">-d/--data &lt;data&gt;               <span class="comment"># HTTP POST方式传送数据</span></span><br><span class="line">--data-ascii &lt;data&gt;            <span class="comment"># 以ascii的方式post数据</span></span><br><span class="line">--data-binary &lt;data&gt;           <span class="comment"># 以二进制的方式post数据</span></span><br><span class="line">--negotiate                    <span class="comment"># 使用HTTP身份验证</span></span><br><span class="line">--digest                       <span class="comment"># 使用数字身份验证</span></span><br><span class="line">--<span class="built_in">disable</span>-eprt                 <span class="comment"># 禁止使用EPRT或LPRT</span></span><br><span class="line">--<span class="built_in">disable</span>-epsv                 <span class="comment"># 禁止使用EPSV</span></span><br><span class="line">--egd-file &lt;file&gt;              <span class="comment"># 为随机数据(SSL)设置EGD socket路径</span></span><br><span class="line">--tcp-nodelay                  <span class="comment"># 使用TCP_NODELAY选项</span></span><br><span class="line">-E/--cert &lt;cert[:passwd]&gt;      <span class="comment"># 客户端证书文件和密码 (SSL)</span></span><br><span class="line">--cert-type &lt;<span class="built_in">type</span>&gt;             <span class="comment"># 证书文件类型 (DER/PEM/ENG) (SSL)</span></span><br><span class="line">--key &lt;key&gt;                    <span class="comment"># 私钥文件名 (SSL)</span></span><br><span class="line">--key-type &lt;<span class="built_in">type</span>&gt;              <span class="comment"># 私钥文件类型 (DER/PEM/ENG) (SSL)</span></span><br><span class="line">--pass  &lt;pass&gt;                 <span class="comment"># 私钥密码 (SSL)</span></span><br><span class="line">--engine &lt;eng&gt;                 <span class="comment"># 加密引擎使用 (SSL). "--engine list" for list</span></span><br><span class="line">--cacert &lt;file&gt;                <span class="comment"># CA证书 (SSL)</span></span><br><span class="line">--capath &lt;directory&gt;           <span class="comment"># CA目   (made using c_rehash) to verify peer against (SSL)</span></span><br><span class="line">--ciphers &lt;list&gt;               <span class="comment"># SSL密码</span></span><br><span class="line">--compressed                   <span class="comment"># 要求返回是压缩的形势 (using deflate or gzip)</span></span><br><span class="line">--connect-timeout &lt;seconds&gt;    <span class="comment"># 设置最大请求时间</span></span><br><span class="line">--create-dirs                  <span class="comment"># 建立本地目录的目录层次结构</span></span><br><span class="line">--crlf                         <span class="comment"># 上传是把LF转变成CRLF</span></span><br><span class="line">--ftp-create-dirs              <span class="comment"># 如果远程目录不存在，创建远程目录</span></span><br><span class="line">--ftp-method [multicwd/nocwd/singlecwd]    <span class="comment"># 控制CWD的使用</span></span><br><span class="line">--ftp-pasv                     <span class="comment"># 使用 PASV/EPSV 代替端口</span></span><br><span class="line">--ftp-skip-pasv-ip             <span class="comment"># 使用PASV的时候,忽略该IP地址</span></span><br><span class="line">--ftp-ssl                      <span class="comment"># 尝试用 SSL/TLS 来进行ftp数据传输</span></span><br><span class="line">--ftp-ssl-reqd                 <span class="comment"># 要求用 SSL/TLS 来进行ftp数据传输</span></span><br><span class="line">-F/--form &lt;name=content&gt;       <span class="comment"># 模拟http表单提交数据</span></span><br><span class="line">-form-string &lt;name=string&gt;     <span class="comment"># 模拟http表单提交数据</span></span><br><span class="line">-g/--globoff                   <span class="comment"># 禁用网址序列和范围使用&#123;&#125;和[]</span></span><br><span class="line">-G/--get                       <span class="comment"># 以get的方式来发送数据</span></span><br><span class="line">-h/--<span class="built_in">help</span>                      <span class="comment"># 帮助</span></span><br><span class="line">-H/--header &lt;line&gt;             <span class="comment"># 自定义头信息传递给服务器</span></span><br><span class="line">--ignore-content-length        <span class="comment"># 忽略的HTTP头信息的长度</span></span><br><span class="line">-i/--include                   <span class="comment"># 输出时包括protocol头信息</span></span><br><span class="line">-I/--head                      <span class="comment"># 只显示文档信息</span></span><br><span class="line">-j/--junk-session-cookies      <span class="comment"># 读取文件时忽略session cookie</span></span><br><span class="line">--interface &lt;interface&gt;        <span class="comment"># 使用指定网络接口/地址</span></span><br><span class="line">--krb4 &lt;level&gt;                 <span class="comment"># 使用指定安全级别的krb4</span></span><br><span class="line">-k/--insecure                  <span class="comment"># 允许不使用证书到SSL站点</span></span><br><span class="line">-K/--config                    <span class="comment"># 指定的配置文件读取</span></span><br><span class="line">-l/--list-only                 <span class="comment"># 列出ftp目录下的文件名称</span></span><br><span class="line">--<span class="built_in">limit</span>-rate &lt;rate&gt;            <span class="comment"># 设置传输速度</span></span><br><span class="line">--<span class="built_in">local</span>-port&lt;NUM&gt;              <span class="comment"># 强制使用本地端口号</span></span><br><span class="line">-m/--max-time &lt;seconds&gt;        <span class="comment"># 设置最大传输时间</span></span><br><span class="line">--max-redirs &lt;num&gt;             <span class="comment"># 设置最大读取的目录数</span></span><br><span class="line">--max-filesize &lt;bytes&gt;         <span class="comment"># 设置最大下载的文件总量</span></span><br><span class="line">-M/--manual                    <span class="comment"># 显示全手动</span></span><br><span class="line">-n/--netrc                     <span class="comment"># 从netrc文件中读取用户名和密码</span></span><br><span class="line">--netrc-optional               <span class="comment"># 使用 .netrc 或者 URL来覆盖-n</span></span><br><span class="line">--ntlm                         <span class="comment"># 使用 HTTP NTLM 身份验证</span></span><br><span class="line">-N/--no-buffer                 <span class="comment"># 禁用缓冲输出</span></span><br><span class="line">-p/--proxytunnel               <span class="comment"># 使用HTTP代理</span></span><br><span class="line">--proxy-anyauth                <span class="comment"># 选择任一代理身份验证方法</span></span><br><span class="line">--proxy-basic                  <span class="comment"># 在代理上使用基本身份验证</span></span><br><span class="line">--proxy-digest                 <span class="comment"># 在代理上使用数字身份验证</span></span><br><span class="line">--proxy-ntlm                   <span class="comment"># 在代理上使用ntlm身份验证</span></span><br><span class="line">-P/--ftp-port &lt;address&gt;        <span class="comment"># 使用端口地址，而不是使用PASV</span></span><br><span class="line">-Q/--quote &lt;cmd&gt;               <span class="comment"># 文件传输前，发送命令到服务器</span></span><br><span class="line">--range-file                   <span class="comment"># 读取（SSL）的随机文件</span></span><br><span class="line">-R/--remote-time               <span class="comment"># 在本地生成文件时，保留远程文件时间</span></span><br><span class="line">--retry &lt;num&gt;                  <span class="comment"># 传输出现问题时，重试的次数</span></span><br><span class="line">--retry-delay &lt;seconds&gt;        <span class="comment"># 传输出现问题时，设置重试间隔时间</span></span><br><span class="line">--retry-max-time &lt;seconds&gt;     <span class="comment"># 传输出现问题时，设置最大重试时间</span></span><br><span class="line">-S/--show-error                <span class="comment"># 显示错误</span></span><br><span class="line">--socks4 &lt;host[:port]&gt;         <span class="comment"># 用socks4代理给定主机和端口</span></span><br><span class="line">--socks5 &lt;host[:port]&gt;         <span class="comment"># 用socks5代理给定主机和端口</span></span><br><span class="line">-t/--telnet-option &lt;OPT=val&gt;   <span class="comment"># Telnet选项设置</span></span><br><span class="line">--trace &lt;file&gt;                 <span class="comment"># 对指定文件进行debug</span></span><br><span class="line">--trace-ascii &lt;file&gt;           <span class="comment"># Like --跟踪但没有hex输出</span></span><br><span class="line">--trace-time                   <span class="comment"># 跟踪/详细输出时，添加时间戳</span></span><br><span class="line">--url &lt;URL&gt;                    <span class="comment"># Spet URL to work with</span></span><br><span class="line">-U/--proxy-user &lt;user[:password]&gt;  <span class="comment"># 设置代理用户名和密码</span></span><br><span class="line">-V/--version                   <span class="comment"># 显示版本信息</span></span><br><span class="line">-X/--request &lt;<span class="built_in">command</span>&gt;         <span class="comment"># 指定什么命令</span></span><br><span class="line">-y/--speed-time                <span class="comment"># 放弃限速所要的时间。默认为30</span></span><br><span class="line">-Y/--speed-limit               <span class="comment"># 停止传输速度的限制，速度时间'秒</span></span><br><span class="line">-z/--time-cond                 <span class="comment"># 传送时间设置</span></span><br><span class="line">-0/--http1.0                   <span class="comment"># 使用HTTP 1.0</span></span><br><span class="line">-1/--tlsv1                     <span class="comment"># 使用TLSv1（SSL）</span></span><br><span class="line">-2/--sslv2                     <span class="comment"># 使用SSLv2的（SSL）</span></span><br><span class="line">-3/--sslv3                     <span class="comment"># 使用的SSLv3（SSL）</span></span><br><span class="line">--3p-quote                     <span class="comment"># like -Q for the source URL for 3rd party transfer</span></span><br><span class="line">--3p-url                       <span class="comment"># 使用url，进行第三方传送</span></span><br><span class="line">--3p-user                      <span class="comment"># 使用用户名和密码，进行第三方传送</span></span><br><span class="line">-4/--ipv4                      <span class="comment"># 使用IP4</span></span><br><span class="line">-6/--ipv6                      <span class="comment"># 使用IP6</span></span><br></pre></td></tr></table></figure><h3 id="5-3-curl-wget两种方法模拟http的get-post请求"><a href="#5-3-curl-wget两种方法模拟http的get-post请求" class="headerlink" title="5.3 curl wget两种方法模拟http的get post请求"></a>5.3 curl wget两种方法模拟http的get post请求</h3><p><strong>get请求：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用curl命令：</span></span><br><span class="line">$ curl <span class="string">"http://www.baidu.com"</span>  <span class="comment"># 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span></span><br><span class="line">$ curl -i <span class="string">"http://www.baidu.com"</span>  <span class="comment"># 显示全部信息</span></span><br><span class="line">$ curl -l <span class="string">"http://www.baidu.com"</span> <span class="comment"># 只显示头部信息</span></span><br><span class="line">$ curl -v <span class="string">"http://www.baidu.com"</span> <span class="comment"># 显示get请求全过程解析</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget命令：</span></span><br><span class="line">$ wget <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure><p><strong>post请求：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用curl命令(通过-d参数，把访问参数放在里面)：</span></span><br><span class="line">$ curl -d <span class="string">"param1=value1&amp;param2=value2"</span> <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget命令：（--post-data参数来实现）</span></span><br><span class="line">$ wget --post-data <span class="string">'user=foo&amp;password=bar'</span>  http://server.com/auth.PHP</span><br></pre></td></tr></table></figure><h2 id="6-B计划"><a href="#6-B计划" class="headerlink" title="6 B计划"></a>6 B计划</h2><h3 id="6-1-用tar归档"><a href="#6-1-用tar归档" class="headerlink" title="6.1 用tar归档"></a>6.1 用tar归档</h3><p>tar支持的参数包括： <code>A</code>、 <code>c</code>、 <code>d</code>、 <code>r</code>、 <code>u</code>、 <code>x</code>、 <code>f</code> 和 <code>v</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用tar对文件进行归档：</span></span><br><span class="line">$ tar -cf output.tar file1 file2 file3 folder1 ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用选项-t列出归档文件中所包含的文件：</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要在归档或列出归档文件列表时获知更多的细节信息，可以使用-v或-vv参数</span></span><br><span class="line">$ $ tar -tvf archive.tar</span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file1</span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file2</span><br><span class="line"><span class="comment"># 文件名必须紧跟在-f之后，而且-f应该是选项中的最后一个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向归档文件中添加文件,追加选项-r</span></span><br><span class="line">$ tar -rvf original.tar new_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的方法列出归档文件中的内容：</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档文件中提取文件或文件夹, -x 表示提取</span></span><br><span class="line">$ tar -xf archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用选项-C来指定需要将文件提取到哪个目录：</span></span><br><span class="line">$ tar -xf archive.tar -C /path/to/extraction_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过将文件名指定为命令行参数来提取特定的文件：</span></span><br><span class="line">$ tar -xvf file.tar file1 file4</span><br><span class="line"><span class="comment"># 上面的命令只提取file1和file4，忽略其他文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在tar中使用stdin和stdout</span></span><br><span class="line">$ tar cvf - files/ | ssh user@example.com <span class="string">"tar xv -C Documents/"</span></span><br><span class="line"><span class="comment"># 在上面的例子中，对files目录中的内容进行了归档并输出到stdout（由'-'指明）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接两个归档文件, -A 选项轻松地合并多个tar文件</span></span><br><span class="line">$ tar -Af file1.tar file2.tar</span><br><span class="line"><span class="comment"># 查看内容，验证操作是否成功：</span></span><br><span class="line">$ tar -tvf file1.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过检查时间戳来更新归档文件中的内容</span></span><br><span class="line"><span class="comment"># 可以用更新选项-u指明：只有比归档文件中的同名文件更新时才会被添加。</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅当filea自上次被加入archive.tar后出现了变动才对其进行追加，可以使用：</span></span><br><span class="line">$ tar -uf archive.tar filea</span><br><span class="line"><span class="comment"># 如果两个filea的时间戳相同，则什么都不会发生。</span></span><br><span class="line"><span class="comment"># 可用touch命令修改文件的时间戳，然后再用tar命令：</span></span><br><span class="line">$ tar -uvvf archive.tar filea</span><br><span class="line">-rw-r--r-- slynux/slynux 0 2010-08-14 17:53 filea</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较归档文件与文件系统中的内容, 选项 -d 可以打印出两者之间的差别：</span></span><br><span class="line">$ tar -df archive.tar</span><br><span class="line">afile: Mod time differs</span><br><span class="line">afile: Size differs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档文件中删除文件, --delete选项从给定的归档文件中删除文件</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"><span class="comment"># 删除filea：</span></span><br><span class="line">$ tar --delete --file archive.tar filea</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">fileb</span><br><span class="line">filec</span><br></pre></td></tr></table></figure><p><strong>压缩tar归档文件：</strong></p><p>归档文件通常被压缩成下列格式之一： </p><ul><li>file.tar.gz </li><li>file.tar.bz2 </li><li>file.tar.lzma </li></ul><p>不同的tar选项可以用来指定不同的压缩格式： </p><ul><li>-j 指定bunzip2格式； </li><li>-z 指定gzip格式； </li><li>–lzma 指定lzma格式。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了让tar支持根据扩展名自动进行压缩，使用 -a或 --auto-compress选项：</span></span><br><span class="line">$ tar acvf archive.tar.gz filea fileb filec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档中排除部分文件,  --exclude [PATTERN]排除匹配通配符样式的文件</span></span><br><span class="line">$ tar -cf arch.tar * --exclude <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># 样式应该使用双引号来引用，避免shell对其进行扩展。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以将需要排除的文件列表放入文件中，同时配合选项 -X：</span></span><br><span class="line">$ cat list</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">$ tar -cf arch.tar * -X list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排除版本控制目录， 可以使用tar的 --exclude-vcs选项。例如：</span></span><br><span class="line">$ tar --exclude-vcs -czvvf source_code.tar.gz eye_of_gnome_svn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印总字节数，用–totals就可以在归档完成之后打印出总归档字节数：</span></span><br><span class="line">$ tar -cf arc.tar * --exclude <span class="string">"*.txt"</span> --totals</span><br><span class="line">Total bytes written: 20480 (20KiB, 12MiB/s)</span><br></pre></td></tr></table></figure><h3 id="6-2-用cpio归档"><a href="#6-2-用cpio归档" class="headerlink" title="6.2 用cpio归档"></a>6.2 用cpio归档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试文件：</span></span><br><span class="line">$ touch file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将测试文件按照下面的方法进行归档：</span></span><br><span class="line">$ <span class="built_in">echo</span> file1 file2 file3 | cpio -ov &gt; archive.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出cpio归档文件中的内容：</span></span><br><span class="line">$ cpio -it &lt; archive.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从cpio归档文件中提取文件：</span></span><br><span class="line">$ cpio -id &lt; archive.cpio</span><br></pre></td></tr></table></figure><p>对于归档命令： </p><ul><li>-o 指定了输出； </li><li>-v 用来打印归档文件列表。 </li></ul><p>在列出给定cpio归档文件所有内容的命令中： </p><ul><li>-i 用于指定输入； </li><li>-t 表示列出归档文件中的内容。 </li></ul><p>当使用命令进行提取时， -d用来表示提取。 cpio在覆盖文件时不会发出提示。 </p><h3 id="6-3-使用gzip压缩数据"><a href="#6-3-使用gzip压缩数据" class="headerlink" title="6.3 使用gzip压缩数据"></a>6.3 使用gzip压缩数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要使用gzip压缩文件，可以使用下面的命令：</span></span><br><span class="line">$ gzip filename</span><br><span class="line">$ ls</span><br><span class="line">filename.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将gzip文件解压缩的方法如下：</span></span><br><span class="line">$ gunzip filename.gz</span><br><span class="line">$ ls</span><br><span class="line">file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩文件的属性信息：</span></span><br><span class="line">$ gzip -l test.txt.gz</span><br><span class="line">compressed uncompressed ratio uncompressed_name</span><br><span class="line">35 6 -33.3% test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip命令可以从stdin中读入文件，也可以将压缩文件写出到stdout，选项 -c用来将输出指定到stdout。</span></span><br><span class="line">$ cat file | gzip -c &gt; file.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以指定gzip的压缩级别。用 --fast或 --best选项分别提供最低或最高的压缩比。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩归档文件</span></span><br><span class="line"><span class="comment"># 方法 1</span></span><br><span class="line">$ tar -czvvf archive.tar.gz [FILES]</span><br><span class="line">或者</span><br><span class="line">$ tar -cavvf archive.tar.gz [FILES]</span><br><span class="line"><span class="comment"># 选项 -a表明从文件扩展名自动推断压缩格式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 2</span></span><br><span class="line"><span class="comment"># 首先，创建一个tar归档文件：</span></span><br><span class="line">$ tar -cvvf archive.tar [FILES]</span><br><span class="line"><span class="comment"># 压缩tar归档文件：</span></span><br><span class="line">$ gzip archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># zcat——无需解压缩，直接读取gzip格式文件</span></span><br><span class="line">$ ls</span><br><span class="line">test.gz</span><br><span class="line">$ zcat test.gz</span><br><span class="line">A <span class="built_in">test</span> file</span><br><span class="line"><span class="comment"># 文件test包含了一行文本"A test file"</span></span><br><span class="line">$ ls</span><br><span class="line">test.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩率</span></span><br><span class="line"><span class="comment"># 我们可以指定压缩率，它共有9级，其中：</span></span><br><span class="line"><span class="comment"># 1级的压缩率最低，但是压缩速度最快；</span></span><br><span class="line"><span class="comment"># 9级的压缩率最高，但是压缩速度最慢。</span></span><br><span class="line">$ gzip -5 test.img</span><br><span class="line"><span class="comment"># 这应该能在压缩速度和压缩比之间获得一个不错的平衡。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bzip2，唯一的不同在于bzip2的压缩效率比gzip更高，但花费的时间比gzip更长</span></span><br><span class="line">$ bzip2 filename</span><br><span class="line"><span class="comment"># 解压缩bzip2格式的文件：</span></span><br><span class="line">$ bunzip2 filename.bz2</span><br><span class="line"><span class="comment"># 生成tar.bz2文件并从中提取内容的方法同之前介绍的tar.gz类似：</span></span><br><span class="line">$ tar -xjvf archive.tar.bz2</span><br><span class="line"><span class="comment"># 其中-j表明该归档文件是bzip2格式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用lzma</span></span><br><span class="line"><span class="comment"># lzma是另一种压缩工具，它的压缩率甚至比gzip和bzip2更好。</span></span><br><span class="line">$ lzma filename</span><br><span class="line"><span class="comment"># 解压缩lzma文件：</span></span><br><span class="line">$ unlzma filename.lzma</span><br><span class="line"><span class="comment"># 可以使用tar命令的--lzma选项对生成的tar归档文件进行压缩或提取：</span></span><br><span class="line">$ tar -cvvf --lzma archive.tar.lzma [FILES]</span><br><span class="line">或者</span><br><span class="line">$ tar -cavvf archive.tar.lzma [FILES]</span><br><span class="line"><span class="comment"># 如果要将经过lzma压缩过的tar归档文件中的内容提取到指定的目录中，可以使用：</span></span><br><span class="line">$ tar -xvvf --lzma archive.tar.lzma -C extract_directory</span><br><span class="line"><span class="comment"># 其中， -x用于提取内容， --lzma指定使用lzma对归档文件进行解压缩。</span></span><br><span class="line"><span class="comment"># 我们也可以用：</span></span><br><span class="line">$ tar -xavvf archive.tar.lzma -C extract_directory</span><br></pre></td></tr></table></figure><h3 id="6-4-用-zip-归档和压缩"><a href="#6-4-用-zip-归档和压缩" class="headerlink" title="6.4 用 zip 归档和压缩"></a>6.4 用 zip 归档和压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对归档文件采用ZIP格式进行压缩：</span></span><br><span class="line">$ zip file.zip file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对目录和文件进行递归操作, -r 用于指定递归操作：</span></span><br><span class="line">$ zip -r archive.zip folder1 folder2</span><br><span class="line"></span><br><span class="line"><span class="comment">#  要从ZIP文件中提取内容，可以使用：</span></span><br><span class="line">$ unzip file.zip</span><br><span class="line"><span class="comment"># 在完成提取操作之后， unzip并不会删除file.zip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要更新压缩文件中的内容，使用选项 -u：</span></span><br><span class="line">$ zip file.zip -u newfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从压缩文件中删除内容，则使用-d：</span></span><br><span class="line">$ zip -d arc.zip file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩文件中的内容：</span></span><br><span class="line">$ unzip -l archive.zip</span><br></pre></td></tr></table></figure><h3 id="6-5-更快的归档工具-pbzip2"><a href="#6-5-更快的归档工具-pbzip2" class="headerlink" title="6.5 更快的归档工具 pbzip2"></a>6.5 更快的归档工具 pbzip2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩单个文件：</span></span><br><span class="line">$ pbzip2 myfile.tar</span><br><span class="line"><span class="comment"># pbzip2会自动检测系统中处理器核心的数量，然后将myfile.tar压缩成myfile.tar.bz2。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将多个文件或目录进行归档及压缩，可以使用tar配合pbzip2来实现：</span></span><br><span class="line">$ tar cf myfile.tar.bz2 --use-compress-prog=pbzip2 dir_to_compress/</span><br><span class="line">或者</span><br><span class="line">$ tar -c directory_to_compress/ | pbzip2 -c &gt; myfile.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从pbzip2格式的文件中进行提取。</span></span><br><span class="line"><span class="comment"># 如果是tar.bz2文件，我们可以一次性完成解压缩和提取工作：</span></span><br><span class="line">$ pbzip2 -dc myfile.tar.bz2 | tar x</span><br><span class="line"><span class="comment"># 如果是经过pbzip2压缩过的归档文件，可以使用：</span></span><br><span class="line">$ pbzip2 -d myfile.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动指定处理器数量, 使用pbzip2的-p选项来手动指定处理器核心的数量</span></span><br><span class="line">$ pbzip2 -p4 myfile.tar</span><br><span class="line"><span class="comment"># 上面的命令告诉pbzip2使用4个处理器核心。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定压缩比</span></span><br><span class="line"><span class="comment"># 像其他压缩工具一样，我们可以使用从1到9的选项来分别指定最快和最优的压缩比。</span></span><br></pre></td></tr></table></figure><h3 id="6-6-创建压缩文件系统"><a href="#6-6-创建压缩文件系统" class="headerlink" title="6.6 创建压缩文件系统"></a>6.6 创建压缩文件系统</h3><p>squashfs是一种具有超高压缩率的只读型文件系统，这种文件系统能够将2GB~3GB的数据压缩成一个700MB的文件。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加源目录和文件，创建一个squashfs文件：</span></span><br><span class="line">$ sudo mksquashfs /etc test.squashfs</span><br><span class="line">Parallel mksquashfs: Using 2 processors</span><br><span class="line">Creating 4.0 filesystem on test.squashfs, block size 131072.</span><br><span class="line">[=======================================] 1867/1867 100%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用环回形式挂载squashfs文件：</span></span><br><span class="line">$ mkdir /mnt/squash</span><br><span class="line">$ mount -o loop compressedfs.squashfs /mnt/squash</span><br><span class="line"><span class="comment"># 你可以访问/mnt/squashfs访问其中的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在创建squashfs文件时排除部分文件, 选项-e，将需要排除的文件列表以命令行参数的方式来指定。例如：</span></span><br><span class="line">$ sudo mksquashfs /etc test.squashfs -e /etc/passwd /etc/shadow</span><br><span class="line"><span class="comment"># 也可以将需要排除的文件名列表写入文件，然后用 -ef指定该文件：</span></span><br><span class="line">$ cat excludelist</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line">$ sudo mksquashfs /etc test.squashfs -ef excludelist</span><br></pre></td></tr></table></figure><h3 id="6-7-使用-rsync-备份系统快照"><a href="#6-7-使用-rsync-备份系统快照" class="headerlink" title="6.7 使用 rsync 备份系统快照"></a>6.7 使用 rsync 备份系统快照</h3><p>rsync可以对位于不同位置的文件和目录进行同步，它利用差异计算以及压缩技术来最小化数据传输量。 </p><p>rsync也支持压缩、加密等多种特性。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将源目录复制到目的端：</span></span><br><span class="line">$ rsync -av /home/slynux/data slynux@192.168.0.6:/home/backups/data</span><br><span class="line"><span class="comment"># 其中：</span></span><br><span class="line"> -a表示要进行归档；</span><br><span class="line"> -v表示在stdout上打印出细节信息或进度。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据备份到远程服务器或主机：</span></span><br><span class="line">$ rsync -av source_dir username@host:PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的方法将远程主机上的数据恢复到本地主机：</span></span><br><span class="line">$ rsync -av username@host:PATH destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过网络进行传输时，压缩数据能够明显改善传输效率。我们可以用rsync的选项 -z 指定在网络传输时压缩数据。例如：</span></span><br><span class="line">$ rsync -avz <span class="built_in">source</span> destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个目录中的内容同步到另一个目录：</span></span><br><span class="line">$ rsync -av /home/<span class="built_in">test</span>/ /home/backups</span><br><span class="line"><span class="comment"># 这条命令将源目录（/home/test）中的内容（不包括目录本身）复制到现有的backups目录中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在使用rsync进行归档的过程中排除部分文件</span></span><br><span class="line">$ rsync -avz /home/code/some_code /mnt/disk/backup/code --exclude <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># 或者我们可以通过一个列表文件指定需要排除的文件。</span></span><br><span class="line"><span class="comment"># 这可以利用--exclude-from FILEPATH。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在更新rsync备份时，删除不存在的文件, rsync并不会在目的端删除那些在源端已不存在的文件</span></span><br><span class="line">$ rsync -avz SOURCE DESTINATION --delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定期进行备份</span></span><br><span class="line">$ crontab -ev</span><br><span class="line"><span class="comment"># 添加上这么一行：</span></span><br><span class="line">0 */10 * * * rsync -avz /home/code user@IP_ADDRESS:/home/backups</span><br><span class="line"><span class="comment"># 上面的crontab条目将rsync调度为每10个小时运行一次。</span></span><br></pre></td></tr></table></figure><h3 id="6-8-用-fsarchiver-创建全盘镜像"><a href="#6-8-用-fsarchiver-创建全盘镜像" class="headerlink" title="6.8 用 fsarchiver 创建全盘镜像"></a>6.8 用 fsarchiver 创建全盘镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件系统/分区备份。</span></span><br><span class="line"><span class="comment"># 使用fsarchiver的savefs选项：</span></span><br><span class="line">$ fsarchiver savefs backup.fsa /dev/sda1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时备份多个分区。</span></span><br><span class="line">$ fsarchiver savefs backup.fsa /dev/sda1 /dev/sda2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份归档中恢复分区。</span></span><br><span class="line">$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1</span><br><span class="line"><span class="comment"># id=0 表 明 我 们 希 望 从 备 份 归 档 中 提 取 第 一 个 分 区 的 内 容 ， 将 其 恢 复 到 由 dest=/dev/sda1所指定的分区中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份归档中恢复多个分区。</span></span><br><span class="line"><span class="comment"># 像之前一样，使用restfs选项：</span></span><br><span class="line">$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1 id=1,dest=/dev/sdb1</span><br></pre></td></tr></table></figure><h2 id="7-无网不利"><a href="#7-无网不利" class="headerlink" title="7 无网不利"></a>7 无网不利</h2><h3 id="7-1-设置网络"><a href="#7-1-设置网络" class="headerlink" title="7.1 设置网络"></a>7.1 设置网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动设置网络接口的IP地址：</span></span><br><span class="line">$ ifconfig wlan0 192.168.0.80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用以下命令设置比IP地址的子网掩码：</span></span><br><span class="line">$ ifconfig wlan0 192.168.0.80 netmask 255.255.252.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动配置网络接口</span></span><br><span class="line">$ dhclient eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印网络接口列表</span></span><br><span class="line">$ ifconfig | cut -c-10 | tr -d <span class="string">' '</span> | tr -s <span class="string">'\n'</span></span><br><span class="line">lo</span><br><span class="line">wlan0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示IP地址</span></span><br><span class="line">$ ifconfig wlan0 | egrep -o <span class="string">"inet addr:[^ ]*"</span> | grep -o <span class="string">"[0-9.]*"</span></span><br><span class="line">192.168.0.82</span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬件地址（MAC地址）欺骗</span></span><br><span class="line">$ ifconfig eth0 hw ether 00:1c:bf:87:25:d5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 名字服务器与DNS（域名服务）</span></span><br><span class="line">$ cat /etc/resolv.conf</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line"><span class="comment"># 我们可以像下面这样手动添加名字服务器：</span></span><br><span class="line">$ <span class="built_in">echo</span> nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS查找</span></span><br><span class="line">$ host google.com</span><br><span class="line">google.com has address 64.233.181.105</span><br><span class="line">google.com has address 64.233.181.99</span><br><span class="line">google.com has address 64.233.181.147</span><br><span class="line">google.com has address 64.233.181.106</span><br><span class="line">google.com has address 64.233.181.103</span><br><span class="line">google.com has address 64.233.181.104</span><br><span class="line"></span><br><span class="line">$ nslookup google.com</span><br><span class="line">Server: 8.8.8.8</span><br><span class="line">Address: 8.8.8.8<span class="comment">#53</span></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.105</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.99</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.147</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.106</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.103</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.104</span><br><span class="line">Server: 8.8.8.8</span><br><span class="line"><span class="comment"># 上面最后一行对应着用于DNS解析的默认名字服务器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用DNS服务器，也可以为IP地址解析添加符号名，这只需要向文件 /etc/hosts中加入条目即可。</span></span><br><span class="line"><span class="comment"># 用下面的方法进行添加：</span></span><br><span class="line">$ <span class="built_in">echo</span> IP_ADDRESS symbolic_name &gt;&gt; /etc/hosts</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> 192.168.0.9 backupserver &gt;&gt; /etc/hosts</span><br><span class="line"><span class="comment"># 添加了条目之后，任何时候解析backupserver，都会返回192.168.0.9。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示路由表信息</span></span><br><span class="line">$ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref UseIface</span><br><span class="line">192.168.0.0 * 255.255.252.0 U 2 0 0wlan0</span><br><span class="line">link-local * 255.255.0.0 U 1000 0 0wlan0</span><br><span class="line">default p4.local 0.0.0.0 UG 0 0 0wlan0</span><br><span class="line"><span class="comment"># 也可以使用：</span></span><br><span class="line">$ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref Use Iface</span><br><span class="line">192.168.0.0 0.0.0.0 255.255.252.0 U 2 0 0 wlan0</span><br><span class="line">169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 wlan0</span><br><span class="line">0.0.0.0 192.168.0.4 0.0.0.0 UG 0 0 0 wlan0</span><br><span class="line"><span class="comment"># -n指定以数字形式显示地址。如果使用-n， route会以数字形式的IP地址显示每一个条目；否则，如果IP地址具有对应的DNS条目，就会显示符号形式的主机名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认网关：</span></span><br><span class="line">$ route add default gw 192.168.0.1 wlan0</span><br></pre></td></tr></table></figure><h3 id="7-2-traceroute-命令"><a href="#7-2-traceroute-命令" class="headerlink" title="7.2 traceroute 命令"></a>7.2 traceroute 命令</h3><p>traceroute，它可以显示分组途径的所有网关的地址。 traceroute信息可以帮助我们搞明白分组到达目的地需要经过多少跳（hop）。中途的网关或路由器的数量给出了一个测量网络上两个节点之间距离的度量<br>（metric）。 traceroute的输出如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ traceroute google.com</span><br><span class="line">traceroute to google.com (74.125.77.104), 30 hops max, 60 byte packets</span><br><span class="line">1 gw-c6509.lxb.as5577.net (195.26.4.1) 0.313 ms 0.371 ms 0.457 ms</span><br><span class="line">2 40g.lxb-fra.as5577.net (83.243.12.2) 4.684 ms 4.754 ms 4.823 ms</span><br><span class="line">3 de-cix10.net.google.com (80.81.192.108) 5.312 ms 5.348 ms 5.327 ms</span><br><span class="line">4 209.85.255.170 (209.85.255.170) 5.816 ms 5.791 ms 209.85.255.172</span><br><span class="line">(209.85.255.172) 5.678 ms</span><br><span class="line">5 209.85.250.140 (209.85.250.140) 10.126 ms 9.867 ms 10.754 ms</span><br><span class="line">6 64.233.175.246 (64.233.175.246) 12.940 ms 72.14.233.114</span><br><span class="line">(72.14.233.114) 13.736 ms 13.803 ms</span><br><span class="line">7 72.14.239.199 (72.14.239.199) 14.618 ms 209.85.255.166</span><br><span class="line">(209.85.255.166) 12.755 ms 209.85.255.143 (209.85.255.143) 13.803 ms</span><br><span class="line">8 209.85.255.98 (209.85.255.98) 22.625 ms 209.85.255.110</span><br><span class="line">(209.85.255.110) 14.122 ms</span><br><span class="line">*</span><br><span class="line">9 ew-in-f104.1e100.net (74.125.77.104) 13.061 ms 13.256 ms 13.484 ms</span><br></pre></td></tr></table></figure><h3 id="7-3-列出网络上所有的活动主机-fping"><a href="#7-3-列出网络上所有的活动主机-fping" class="headerlink" title="7.3 列出网络上所有的活动主机 (fping)"></a>7.3 列出网络上所有的活动主机 (fping)</h3><p>fping的选项如下： </p><ul><li>选项 -a指定打印出所有活动主机的IP地址； </li><li>选项 -u指定打印出所有无法到达的主机； </li><li>选项 -g指定从 “IP地址/子网掩码”记法或者”IP地址范围”记法中生成一组IP地址； </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ fping -a 192.160.1/24 -g</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ fping -a 192.160.1 192.168.0.255 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以用已有的命令行工具来查询网络上的主机状态：</span></span><br><span class="line">$ fping -a 192.160.1/24 -g 2&gt; /dev/null</span><br><span class="line">192.168.0.1</span><br><span class="line">192.168.0.90</span><br><span class="line"><span class="comment"># 或者，使用：</span></span><br><span class="line">$ fping -a 192.168.0.1 192.168.0.255 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;/dev/null将由于主机无法到达所产生的错误信息打印到null设备。</span></span><br><span class="line">$ fping -a 192.168.0.1 192.168.0.5 192.168.0.6</span><br><span class="line"><span class="comment"># 将IP地址作为参数传递</span></span><br><span class="line">$ fping -a &lt; ip.list</span><br><span class="line"><span class="comment"># 从文件中传递一组IP地址</span></span><br></pre></td></tr></table></figure><h3 id="7-4-ssh-命令"><a href="#7-4-ssh-命令" class="headerlink" title="7.4 ssh 命令"></a>7.4 ssh 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SSH的压缩功能,选项-C启用这一功能：</span></span><br><span class="line">$ ssh -C user@hostname COMMANDS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据重定向至远程shell命令的stdin</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'text'</span> | ssh user@remote_host <span class="string">'echo'</span></span><br><span class="line">text</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 将文件中的数据进行重定向</span></span><br><span class="line">$ ssh user@remote_host <span class="string">'echo'</span> &lt; file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在远程主机中执行图形化命令</span></span><br><span class="line"><span class="comment"># 对此，你需要像这样设置变量$DISPLAY：</span></span><br><span class="line">$ ssh user@host <span class="string">"export DISPLAY=:0 ; command1; command2"</span><span class="string">""</span></span><br><span class="line"><span class="comment"># 这将启用远程主机上的图形化输出。如果你想在本地主机上也显示图形化输出，使用SSH的X11转发选项（forwarding option）：</span></span><br><span class="line">$ ssh -X user@host <span class="string">"command1; command2</span></span><br></pre></td></tr></table></figure><h3 id="7-5-通过网络传输文件"><a href="#7-5-通过网络传输文件" class="headerlink" title="7.5 通过网络传输文件"></a>7.5 通过网络传输文件</h3><p>计算机联网的主要目的就是资源共享。在资源共享方面，使用最多的是文件共享。有多种方法可以用来在网络中传输文件。这则攻略就讨论了如何用常见的协议FTP、 SFTP、 RSYNC和SCP传输文件。 </p><p>通过FTP传输文件可以使用lftp命令，通过SSH连接传输文件可以使用sftp， RSYNC使用SSH与rsync命令， scp通过SSH进行传输。 </p><p><strong>文件传输协议（File Transfer Protocol， FTP） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要连接FTP服务器传输文件，可以使用：</span></span><br><span class="line">$ lftp username@ftphost</span><br><span class="line"><span class="comment"># 它会提示你输入密码，然后显示一个像下面那样的登录提示符：</span></span><br><span class="line">lftp username@ftphost:~&gt;</span><br></pre></td></tr></table></figure><p>你可以在提示符后输入命令，如下所示。 </p><ul><li>用cd directory改变目录。 </li><li>用lcd改变本地主机的目录。 </li><li>用mkdir创建目录。 </li><li>列出远程机器当前目录下的文件使用Is。 </li><li>用get filename下载文件：<br><code>lftp username@ftphost:~&gt; get filename</code></li><li>用put filename从当前目录上传文件：<br><code>lftp username@ftphost:~&gt; put filename</code></li><li>用quit退出lftp会话。 </li></ul><p><strong>FTP自动传输 ：</strong></p><p>ftp是另一个可用于FTP文件传输的命令。相比较而言， lftp的用法更灵活。 lftp和ftp为用户启动一个交互式会话（通过显示消息来提示用户输入）。 </p><p><strong>SFTP（Secure FTP，安全FTP） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/slynux</span><br><span class="line">$ put testfile.jpg</span><br><span class="line">$ get serverfile.jpg</span><br><span class="line"><span class="comment"># 运行sftp：</span></span><br><span class="line">$ sftp user@domainname</span><br></pre></td></tr></table></figure><p><strong>rsync命令 ：</strong></p><p>rsync广泛用于网络文件复制及系统备份。 </p><p><strong>SCP（Secure Copy Program，安全复制程序） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp filename user@remotehost:/home/path</span><br><span class="line"></span><br><span class="line">$ scp user@remotehost:/home/path/filename filename</span><br></pre></td></tr></table></figure><p>用SCP进行递归复制 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r /home/slynux user@remotehost:/home/backups</span><br><span class="line"><span class="comment"># 将目录/home/slynux递归复制到远程主机中</span></span><br><span class="line"><span class="comment"># scp的 -p 选项能够在复制文件的同时保留文件的权限和模式。</span></span><br></pre></td></tr></table></figure><h3 id="7-6-连接网线网络"><a href="#7-6-连接网线网络" class="headerlink" title="7.6 连接网线网络"></a>7.6 连接网线网络</h3><p>我们需要用ifconfig分配IP地址和子网掩码才能连接上有线网络。对于无线网络来说，还需要其他工具（如iwconfig和iwlist）来配置更多的参数。 </p><p>iwlist工具扫描并列出可用的无线网络。用下面的命令进行扫描： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ iwlist scan</span><br><span class="line">wlan0 Scan completed :</span><br><span class="line">Cell 01 - Address: 00:12:17:7B:1C:65</span><br><span class="line">Channel:11</span><br><span class="line">Frequency:2.462 GHz (Channel 11)</span><br><span class="line">Quality=33/70 Signal level=-77 dBm</span><br><span class="line">                    Encryption key:on</span><br><span class="line">ESSID:<span class="string">"model-2"</span></span><br></pre></td></tr></table></figure><h3 id="7-7-在本地挂载点上挂载远程驱动器"><a href="#7-7-在本地挂载点上挂载远程驱动器" class="headerlink" title="7.7 在本地挂载点上挂载远程驱动器"></a>7.7 在本地挂载点上挂载远程驱动器</h3><p>sshfs允许你将远程文件系统挂载到本地挂载点上。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将位于远程主机上的文件系统挂载到本地挂载点上：</span></span><br><span class="line">$ sshfs -o allow_other user@remotehost:/home/path /mnt/mountpoint</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成任务后，可用下面的方法卸载：</span></span><br><span class="line">$ umount /mnt/mountpoint</span><br></pre></td></tr></table></figure><h3 id="7-8-网络流量与端口分析"><a href="#7-8-网络流量与端口分析" class="headerlink" title="7.8 网络流量与端口分析"></a>7.8 网络流量与端口分析</h3><p>列出系统中的开放端口以及运行在端口上的服务的详细信息，可以使用以下命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要列出本地主机当前的开放端口，可以使用：</span></span><br><span class="line">$ lsof -i | grep <span class="string">":[0-9]\+-&gt;"</span> -o | grep <span class="string">"[0-9]\+"</span> -o | sort | uniq</span><br></pre></td></tr></table></figure><p>用netstat查看开放端口与服务 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -tnp列出开放端口与服务：</span></span><br><span class="line">$ netstat -tnp</span><br></pre></td></tr></table></figure><h3 id="7-9-创建套接字"><a href="#7-9-创建套接字" class="headerlink" title="7.9 创建套接字"></a>7.9 创建套接字</h3><p>最简单的方法就是使用netcat命令（或nc）。我们需要两个套接字：一个用来侦听，一个用来连接。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置侦听套接字：</span></span><br><span class="line">$ nc -l 1234</span><br><span class="line"><span class="comment"># 这会在本地主机的端口1234上创建一个侦听套接字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到该套接字：</span></span><br><span class="line">$ nc HOST 1234</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想发送消息，只需要在执行第2步操作的主机终端中输入信息并按回车键就行了。消息会出现在执行第1步操作的主机终端中。</span></span><br></pre></td></tr></table></figure><p>在网络上进行快速文件复制 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在接收端执行下列命令：</span></span><br><span class="line">$ nc -l 1234 &gt; destination_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在发送端执行下列命令：</span></span><br><span class="line">$ nc HOST 1234 &lt; source_filename</span><br></pre></td></tr></table></figure><h3 id="7-10-iptables防火墙设置"><a href="#7-10-iptables防火墙设置" class="headerlink" title="7.10 iptables防火墙设置"></a>7.10 iptables防火墙设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阻塞发送到特定IP地址的流量：</span></span><br><span class="line">$ iptables -A OUTPUT -d 8.8.8.8 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞发送到特定端口的流量：</span></span><br><span class="line">$ iptables -A OUTPUT -p tcp -dport 21 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment">#  iptables中的第一个选项-A表明向链（chain）中添加一条新的规则，该规则由后续参数给出。OUTPUT链，它可以对所有出站（outgoing）的流量进行控制。-d指定了所要匹配的分组目的地址。-j来使iptables丢弃（DROP）符合条件的分组。-p指定该规则是适用于TCP， -dport指定了对应的端口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除对iptables链所做出的所有改动。</span></span><br><span class="line">$ iptables --flush</span><br></pre></td></tr></table></figure><h2 id="8-当个好管家"><a href="#8-当个好管家" class="headerlink" title="8 当个好管家"></a>8 当个好管家</h2><h3 id="8-1-监视磁盘使用情况"><a href="#8-1-监视磁盘使用情况" class="headerlink" title="8.1 监视磁盘使用情况"></a>8.1 监视磁盘使用情况</h3><p><code>df</code> 是disk free的缩写， <code>du</code> 是disk usage的缩写。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出某个文件（或多个文件）占用的磁盘空间：</span></span><br><span class="line">$ du file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要获得某个目录中所有文件的磁盘使用情况，并在每一行中显示各个文件的磁盘占用详情，可以使用：</span></span><br><span class="line">$ du -a DIRECTORY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以KB、 MB或块（block）为单位显示磁盘使用情况</span></span><br><span class="line">$ du -h FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示磁盘使用总计, -c 可以输出作为命令参数的所有文件和目录的磁盘使用情况</span></span><br><span class="line">$ du -c process_log.shpcpu.sh</span><br><span class="line">4 process_log.sh</span><br><span class="line">4 pcpu.sh</span><br><span class="line">8 total</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s（summarize，合计）则只输出合计数据。它可以配合 -h打印出人们易读的格式。</span></span><br><span class="line">$ du -sh slynux</span><br><span class="line">680K slynux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以字节（默认输出）为单位的文件大小：</span></span><br><span class="line">$ du -b FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以KB为单位的文件大小：</span></span><br><span class="line">$ du -k FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以MB为单位的文件大小：</span></span><br><span class="line">$ du -m FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以指定块为单位的文件大小：</span></span><br><span class="line">$ du -B BLOCK_SIZE FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从磁盘使用统计中排除部分文件</span></span><br><span class="line">$ du --exclude <span class="string">"*.txt"</span> FILES(s)</span><br><span class="line"><span class="comment"># 排除所有的.txt文件</span></span><br><span class="line">$ du --exclude-from EXCLUDE.txt DIRECTORY</span><br><span class="line"><span class="comment"># EXCLUDE.txt包含了需要排除的文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --max-depth指定du应该遍历的目录层次的最大深度。</span></span><br><span class="line">$ du --max-depth 2 DIRECTORY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出指定目录中最大的10个文件</span></span><br><span class="line">$ du -ak /home/slynux | sort -nrk 1 | head -n 4</span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> du -k &#123;&#125; \; | sort -nrk 1 | head</span><br></pre></td></tr></table></figure><p>du提供磁盘使用情况信息，而df提供磁盘可用空间信息。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem Size Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1 9.2G 2.2G 6.6G 25% /</span><br><span class="line">none 497M 240K 497M 1% /dev</span><br><span class="line">none 502M 168K 501M 1% /dev/shm</span><br><span class="line">none 502M 88K 501M 1% /var/run</span><br><span class="line">none 502M 0 502M 0% /var/lock</span><br><span class="line">none 502M 0 502M 0% /lib/init/rw</span><br><span class="line">none 9.2G 2.2G 6.6G 25% /var/lib/ureadahead/debugfs</span><br></pre></td></tr></table></figure><h3 id="8-2-计算命令执行时间"><a href="#8-2-计算命令执行时间" class="headerlink" title="8.2 计算命令执行时间"></a>8.2 计算命令执行时间</h3><ul><li>real: %e </li><li>user: %U </li><li>sys: %S </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ time COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用选项-o filename将相关的时间统计信息写入文件：</span></span><br><span class="line">$ /usr/bin/time -o output.txt COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将命令执行时间添加到文件而不影响其原有内容，使用选项-a以及-o：</span></span><br><span class="line">$ /usr/bin/time -a -o output.txt COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建格式化输出：</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Time: %U"</span> -a -o timing.log uname</span><br><span class="line">Linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用错误重定向操作符（2&gt;）对时间信息重定向。</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Time: %U"</span> uname&gt; command_output.txt 2&gt;time.log</span><br><span class="line">$ cat time.log</span><br><span class="line">Time: 0.00</span><br><span class="line">$ cat command_output.txt</span><br><span class="line">Linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用参数%Z显示系统页面大小：</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Page size: %Z bytes"</span> ls&gt; /dev/null</span><br><span class="line">Page size: 4096 bytes</span><br></pre></td></tr></table></figure><p>三种不同类型的时：</p><ul><li>Real时间指的是挂钟时间（wall clock time），也就是命令从开始执行到结束的时间。这段时间包括其他进程所占用的时间片（time slice）以及进程被阻塞时所花费的时间（例如，为等待I/O操作完成所用的时间）。 </li><li>User时间是指进程花费在用户模式（内核之外）中的CPU时间。这是唯一真正用于执行进程所花费的时间。执行其他进程以及花费在阻塞状态中的时间并没有计算在内。 </li><li>Sys时间是指进程花费在内核中的CPU时间。它代表在内核中执行系统调用所使用的时间，这和库代码（library code）不同，后者仍旧运行在用户空间。与“user时间”类似，这也是真正由进程使用的CPU时间。 </li></ul><p>time命令 一些可以使用的参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>%C</td><td>进行计时的命令名称以及命令行参数</td></tr><tr><td>%D</td><td>进程非共享数据区域的大小，以KB为单位</td></tr><tr><td>%E</td><td>进程使用的real时间（挂钟时间），显示格式为[小时:]分钟:秒</td></tr><tr><td>%x</td><td>命令的退出状态</td></tr><tr><td>%k</td><td>进程接收到的信号数量</td></tr><tr><td>%W</td><td>进程被交换出主存的次数</td></tr><tr><td>%Z</td><td>系统的页面大小。这是一个系统常量，但在不同的系统中，这个常量值也不同</td></tr><tr><td>%P</td><td>进程所获得的CPU时间百分比。这个值等于user+system时间除以总运行时间。结果以百分比形式显示</td></tr><tr><td>%K</td><td>进程的平均总（data+stack+text）内存使用量，以KB为单位</td></tr><tr><td>%w</td><td>进程主动进行上下文切换的次数，例如等待I/O操作完成</td></tr><tr><td>%c</td><td>进程被迫进行上下文切换的次数（由于时间片到期）</td></tr></tbody></table><h3 id="8-3-收集与当前登录用户、启动日志及启动故障的相关信息"><a href="#8-3-收集与当前登录用户、启动日志及启动故障的相关信息" class="headerlink" title="8.3 收集与当前登录用户、启动日志及启动故障的相关信息"></a>8.3 收集与当前登录用户、启动日志及启动故障的相关信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前登录用户的相关信息：</span></span><br><span class="line">$ who</span><br><span class="line">slynux pts/0 2010-09-29 05:24 (slynuxs-macbook-pro.local)</span><br><span class="line">slynux tty7 2010-09-29 07:08 (:0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得有关登录用户更详细的信息：</span></span><br><span class="line">$ w</span><br><span class="line">  07:09:05 up 1:45, 2 users, load average: 0.12, 0.06, 0.02</span><br><span class="line">USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</span><br><span class="line">slynux pts/0 slynuxs 05:24 0.00s 0.65s 0.11s sshd: slynux</span><br><span class="line">slynux tty7 :007:08 1:45m 3.28s 0.26s gnome-session</span><br><span class="line"><span class="comment"># 第一行列出了当前时间，系统运行时间，当前登录的用户数量以及过去的1分钟、 5分钟、 15分钟内的系统平均负载。接下来的每一行显示了每一个登录用户的详细信息，其中包括登录名、 TTY、远程主机、登录时间、空闲时间、自该用户登录后所使用的总CPU时间、当前运行进程所使用的CPU时间以及进程所对应的命令行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录主机的用户列表：</span></span><br><span class="line">$ users</span><br><span class="line">slynux slynux slynux hacker</span><br><span class="line">$ users | tr <span class="string">' '</span> <span class="string">'\n'</span> | sort | uniq</span><br><span class="line">slynux</span><br><span class="line">hacker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统已经加电运行了多长时间：</span></span><br><span class="line">$ uptime</span><br><span class="line">21:44:33 up 3:17, 8 users, load average: 0.09, 0.14, 0.09</span><br><span class="line">$ uptime | grep -Po <span class="string">'\d&#123;2&#125;\:\d&#123;2&#125;\:\d&#123;2&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取上一次启动以及用户登录会话的信息：</span></span><br><span class="line">$ last</span><br><span class="line">slynux tty7 :0 Tue Sep 28 18:27 still logged <span class="keyword">in</span></span><br><span class="line">reboot system boot 2.6.32-21-generic Tue Sep 28 18:10 - 21:46 (03:35)</span><br><span class="line">slynux pts/0 :0.0 Tue Sep 28 05:31 - crash (12:39)</span><br><span class="line"><span class="comment"># last命令可以提供登录会话信息。它实际上是一个系统登录日志，包括了登录tty、登录时间、状态等信息。</span></span><br><span class="line"><span class="comment"># last命令以日志文件/var/log/wtmp作为输入日志数据。它也可以用选项-f明确地指定日志文件。例如：</span></span><br><span class="line">$ last -f /var/<span class="built_in">log</span>/wtmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个用户登录会话的信息：</span></span><br><span class="line">$ last USER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取重启会话（reboot session）信息：</span></span><br><span class="line">$ last reboot</span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 18:10 - 21:48 (03:37)</span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 05:14 - 21:48 (16:33)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取失败的用户登录会话信息：</span></span><br><span class="line">$ lastb</span><br><span class="line"><span class="built_in">test</span> tty8 :0 Wed Dec 15 03:56 - 03:56 (00:00)</span><br><span class="line">slynux tty8 :0 Wed Dec 15 03:55 - 03:55 (00:00)</span><br></pre></td></tr></table></figure><h3 id="8-4-使用-watch-监视命令输出"><a href="#8-4-使用-watch-监视命令输出" class="headerlink" title="8.4 使用 watch 监视命令输出"></a>8.4 使用 watch 监视命令输出</h3><p>watch命令可以用来在终端中以固定的间隔监视命令输出。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ watch ls</span><br><span class="line"></span><br><span class="line">$ watch <span class="string">'ls -l | grep "^d"'</span></span><br><span class="line"><span class="comment"># 只列出目录</span></span><br><span class="line"><span class="comment"># 命令默认每2秒更新一次输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -n SECOND指定更新输出的时间间隔。例如：</span></span><br><span class="line">$ watch -n 5 <span class="string">'ls -l'</span></span><br><span class="line"><span class="comment"># 以5秒为间隔，监视ls -l的输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 突出标示watch输出中的差异, -d 可以启用这一功能：</span></span><br><span class="line">$ watch -d <span class="string">'COMMANDS'</span></span><br></pre></td></tr></table></figure><h3 id="8-5-用-logrotate-管理日志文件"><a href="#8-5-用-logrotate-管理日志文件" class="headerlink" title="8.5 用 logrotate 管理日志文件"></a>8.5 用 logrotate 管理日志文件</h3><p>用一种被称为轮替（rotation）的技术来限制日志文件的体积，一旦它超过了限定的大小，就对其内容进行抽取（strip），同时将 日志文件中的旧条目存储到日志目录中的归档文件内。旧的日志文件就会得以保存以便随后参阅。 </p><p><code>logrotate</code> 的配置目录位于/etc/logrotate.d。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/logrotate.d/program</span><br><span class="line">/var/<span class="built_in">log</span>/program.log &#123;</span><br><span class="line">missingok</span><br><span class="line">notifempty</span><br><span class="line">size 30k</span><br><span class="line">compress</span><br><span class="line">weekly</span><br><span class="line">rotate 5</span><br><span class="line">create 0600 root root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中各个参数的含义：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>missingok</td><td>如果日志文件丢失，则忽略；然后返回（不对日志文件进行轮替）</td></tr><tr><td>notifempty</td><td>仅当源日志文件非空时才对其进行轮替</td></tr><tr><td>size 30k</td><td>限制实施轮替的日志文件的大小。可以用1M表示1MB</td></tr><tr><td>compress</td><td>允许用gzip压缩较旧的日志</td></tr><tr><td>weekly</td><td>指定进行轮替的时间间隔。可以是weekly、 yearly或daily</td></tr><tr><td>rotate 5</td><td>这是需要保留的旧日志文件的归档数量。在这里指定的是5，所以这些文件名将会是program.log.1.gz、 program.log.2.gz等直到program.log.5.gz</td></tr><tr><td>create 0600 root root</td><td>指定所要创建的归档文件的模式、用户以及用户组</td></tr></tbody></table><h3 id="8-6-用-syslog-记录日志"><a href="#8-6-用-syslog-记录日志" class="headerlink" title="8.6 用 syslog 记录日志"></a>8.6 用 syslog 记录日志</h3><p>每一个标准应用进程都可以利用syslog记录日志信息。 </p><p>使用命令logger通过syslogd记录日志。 </p><p>Linux中一些重要的日志文件 ：</p><table><thead><tr><th>日志文件</th><th>描述</th></tr></thead><tbody><tr><td>/var/log/boot.log</td><td>系统启动信息</td></tr><tr><td>/var/log/httpd</td><td>Apache Web服务器日志</td></tr><tr><td>/var/log/messages</td><td>发布内核启动信息</td></tr><tr><td>/var/log/auth.log</td><td>用户认证日志</td></tr><tr><td>/var/log/dmesg</td><td>系统启动信息</td></tr><tr><td>/var/log/mail.log</td><td>邮件服务器日志</td></tr><tr><td>/var/log/Xorg.0.log</td><td>X服务器日志</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向系统日志文件/var/log/message中写入日志信息：</span></span><br><span class="line">$ logger This is a <span class="built_in">test</span> <span class="built_in">log</span> line</span><br><span class="line">$ tail -n 1 /var/<span class="built_in">log</span>/messages</span><br><span class="line">Sep 29 07:47:44 slynux-laptop slynux: This is a <span class="built_in">test</span> <span class="built_in">log</span> line</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果要记录特定的标记（tag），可以使用：</span></span><br><span class="line">$ logger -t TAG This is a message</span><br><span class="line">$ tail -n 1 /var/<span class="built_in">log</span>/messages</span><br><span class="line">Sep 29 07:48:42 slynux-laptop TAG: This is a message</span><br><span class="line"><span class="comment"># 但是当logger发送消息时，它用标记字符串来确定应该记录到哪一个日志文件中。 syslogd使用与日志相关联的TAG来决定应该将其记录到哪一个文件中。你可以从/etc/rsyslog.d/目录下的配置文件中看到标记字符串以及与其相关联的日志文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将另一个日志文件的最后一行记录到系统日志中，可以使用：</span></span><br><span class="line">$ logger -f /var/<span class="built_in">log</span>/source.log</span><br></pre></td></tr></table></figure><h3 id="8-7-通过监视用户登录找出入侵者"><a href="#8-7-通过监视用户登录找出入侵者" class="headerlink" title="8.7 通过监视用户登录找出入侵者"></a>8.7 通过监视用户登录找出入侵者</h3><p>入侵者定义为：屡次试图登入系统达两分钟以上，并且期间的登录过程全部失败。凡是这类用户都应该被检测出来并生成包含以下细节信息的报告： </p><ul><li>试图登录的账户 </li><li>试图登录的次数 </li><li>攻击者的IP地址 </li><li>IP地址所对应的主机 </li><li>进行登录的时间段 </li></ul><p>为了处理SSH登录失败的情况，还得知道用户认证会话日志会被记录在日志文件/var/log/auth.log中。脚本需要扫描这个日志文件来检测出失败的登录信息，执行各种检查来获取所需要的数据。我们可以用host命令找出IP地址所对应的主机。 </p><h3 id="8-8-监视磁盘活动"><a href="#8-8-监视磁盘活动" class="headerlink" title="8.8 监视磁盘活动"></a>8.8 监视磁盘活动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互式监视, iotop的-o选项只显示出那些正在进行I/O活动的进程：</span></span><br><span class="line">$ iotop -o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于shell脚本的非交互式用法：</span></span><br><span class="line">$ iotop -b -n 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视特定进程</span></span><br><span class="line">$ iotop -p PID</span><br></pre></td></tr></table></figure><h3 id="8-9-检查磁盘及文件系统错误"><a href="#8-9-检查磁盘及文件系统错误" class="headerlink" title="8.9 检查磁盘及文件系统错误"></a>8.9 检查磁盘及文件系统错误</h3><p>使用fsck的各种选项对文件系统错误进行检查和修复。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要检查分区或文件系统的错误，只需要将路径作为fsck的参数：</span></span><br><span class="line">$ fsck /dev/sdb3</span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">e2fsck 1.42.5 (29-Jul-2012)</span><br><span class="line">HDD2 has been mounted 26 <span class="built_in">times</span> without being checked, check forced.</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">HDD2: 75540/16138240 files (0.7% non-contiguous), 48756390/64529088 blocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查/etc/fstab中所配置的所有文件系统：</span></span><br><span class="line">$ fsck -A</span><br><span class="line"><span class="comment"># 该命令会依次检查/etc/fstab中列出的文件系统。 fstab文件对磁盘及其挂载点之间的映射关系进行了配置，以便于更便捷地挂载文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定fsck自动修复错误，无需询问是否进行修复：</span></span><br><span class="line">$ fsck -a /dev/sda2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟fsck要执行的操作：</span></span><br><span class="line">$ fsck -AN</span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /] fsck.ext4 /dev/sda8</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /home] fsck.ext4 /dev/sda7</span><br><span class="line">[/sbin/fsck.ext3 (1) -- /media/Data] fsck.ext3 /dev/sda6</span><br></pre></td></tr></table></figure><h2 id="9-管理重任"><a href="#9-管理重任" class="headerlink" title="9 管理重任"></a>9 管理重任</h2><h3 id="9-1-收集进程信息"><a href="#9-1-收集进程信息" class="headerlink" title="9.1 收集进程信息"></a>9.1 收集进程信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了包含更多的信息，可以使用-f（表示full）来显示多列，如下所示：</span></span><br><span class="line">$ ps -f</span><br><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">slynux 1220 1219 0 18:18 pts/0 00:00:00 -bash</span><br><span class="line">slynux 1587 1220 0 18:59 pts/0 00:00:00 ps -f</span><br><span class="line"><span class="comment"># 使用选项 -e（every）。选项-ax（all）也可以生成同样的输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行如下命令之一： ps –e， ps –ef， ps -ax或ps –axf。</span></span><br><span class="line">$ ps -e | head</span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1 ? 00:00:00 init</span><br><span class="line">2 ? 00:00:00 kthreadd</span><br><span class="line">3 ? 00:00:00 migration/0</span><br><span class="line">4 ? 00:00:00 ksoftirqd/0</span><br><span class="line">5 ? 00:00:00 watchdog/0</span><br><span class="line">6 ? 00:00:00 events/0</span><br><span class="line">7 ? 00:00:00 cpuset</span><br><span class="line">8 ? 00:00:00 khelper</span><br><span class="line">9 ? 00:00:00 netns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 -o 来指定想要显示的列，以便只打印出我们需要的内容。</span></span><br><span class="line"><span class="comment"># -o 的参数以逗号操作符（,）作为定界符。值得注意的是，逗号操作符与它分隔的参数之间是没有空格的。</span></span><br><span class="line"><span class="comment"># -e和过滤器结合使用没有任何实际效果，依旧会显示所有的进程。</span></span><br><span class="line"><span class="comment"># 示例如下，其中comm表示COMMAND， pcpu表示CPU占用率：</span></span><br><span class="line">$ ps -eo comm,pcpu | head</span><br><span class="line">COMMAND %CPU</span><br><span class="line">init 0.0</span><br><span class="line">kthreadd 0.0</span><br><span class="line">migration/0 0.0</span><br><span class="line">ksoftirqd/0 0.0</span><br><span class="line">watchdog/0 0.0</span><br><span class="line">events/0 0.0</span><br><span class="line">cpuset 0.0</span><br><span class="line">khelper 0.0</span><br><span class="line">netns 0.0</span><br></pre></td></tr></table></figure><p>选项-o可以使用不同的参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pcpu</td><td>CPU占用率</td></tr><tr><td>pid</td><td>进程ID</td></tr><tr><td>ppid</td><td>父进程ID</td></tr><tr><td>pmem</td><td>内存使用率</td></tr><tr><td>comm</td><td>可执行文件名</td></tr><tr><td>cmd</td><td>简单命令</td></tr><tr><td>user</td><td>启动进程的用户</td></tr><tr><td>nice</td><td>优先级</td></tr><tr><td>time</td><td>累计的CPU时间</td></tr><tr><td>etime</td><td>进程启动后流逝的时间</td></tr><tr><td>tty</td><td>所关联的TTY设备</td></tr><tr><td>euid</td><td>有效用户ID</td></tr><tr><td>stat</td><td>进程状态</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top, 默认会输出一个占用CPU最多的进程列表。输出结果每隔几秒就会更新。</span></span><br><span class="line">$ top</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据参数对ps输出进行排序</span></span><br><span class="line">$ ps -eo comm,pcpu --sort -pcpu | head</span><br><span class="line">COMMAND %CPU</span><br><span class="line">Xorg 0.1</span><br><span class="line">hald-addon-stor 0.0</span><br><span class="line">ata/0 0.0</span><br><span class="line">scsi_eh_0 0.0</span><br><span class="line">gnome-settings- 0.0</span><br><span class="line">init 0.0</span><br><span class="line">hald 0.0</span><br><span class="line">pulseaudio 0.0</span><br><span class="line">gdm-simple-gree 0.0</span><br><span class="line">$ ps -eo comm,pid,pcpu,pmem | grep bash</span><br><span class="line">bash 1255 0.0 0.3</span><br><span class="line">bash 1680 5.5 0.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出给定命令名所对应的进程ID，在参数后加上=就可以移除列名。</span></span><br><span class="line">$ ps -C bash -o pid=</span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line">$ pgrep bash</span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用换行符作为定界符，而是要自行指定可以像下面这样：</span></span><br><span class="line">$ pgrep bash -d <span class="string">":"</span></span><br><span class="line">1255:1680</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定进程的用户（拥有者）列表：</span></span><br><span class="line">$ pgrep -u root,slynux COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据真实用户或ID以及有效用户或ID过滤ps输出</span></span><br><span class="line"> 用 -u EUSER1,EUSER2 …，指定有效用户列表；</span><br><span class="line"> 用 -U RUSER1,RUSER2 …，指定真实用户列表</span><br><span class="line">$ ps -u root -U root -o user,pcpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用TTY过滤ps输出, 可以通过指定进程所属的TTY选择ps的输出。用选项 -t指定TTY列表：</span></span><br><span class="line">$ ps -t pts/0,pts/1</span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1238 pts/0 00:00:00 bash</span><br><span class="line">1835 pts/1 00:00:00 bash</span><br><span class="line">1864 pts/0 00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程线程的相关信息</span></span><br><span class="line"><span class="comment"># 通常与进程线程相关的信息在ps输出中是看不到的。我们可以用选项 –L 在ps输出中显示线程的相关信息。这会显示出两列： NLWP和NLP。 NLWP是进程的线程数量， NLP是ps输出中每个条目的线程ID。例如：</span></span><br><span class="line">$ ps -eLf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出宽度以及所要显示的列</span></span><br><span class="line"><span class="comment"># 可以按照你自己的使用方式来进行应用。尝试以下选项:</span></span><br><span class="line"> -f ps –ef</span><br><span class="line"> u ps -e u</span><br><span class="line"> ps ps -e w（w表示宽松输出）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示进程的环境变量</span></span><br><span class="line"><span class="comment"># 了解某个进程依赖哪些环境变量，这类信息我们通常都用得着。进程的运行方式可能极其依赖某组环境变量。我们可以利用环境变量调试并修复与进程相关的问题。</span></span><br><span class="line">$ ps -eo pid,cmd e | tail -n 3</span><br><span class="line">1162 hald-addon-acpi: listening on acpid socket /var/run/acpid.socket</span><br><span class="line">1172 sshd: slynux [priv]</span><br><span class="line">1237 sshd: slynux@pts/0</span><br><span class="line">1238 -bash USER=slynux LOGNAME=slynux HOME=/home/slynux</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</span><br><span class="line">MAIL=/var/mail/slynux SHELL=/bin/bash SSH_CLIENT=10.211.55.2 49277 22</span><br><span class="line">SSH_CONNECTION=10.211.55.2 49277 10.211.55.4 22 SSH_TTY=/dev/pts/0 TERM=xterm-color</span><br><span class="line">LANG=en_IN XDG_SESSION_COOKIE=d1e96f5cc8a7a3bc3a0a73e44c95121a-1286499339.</span><br><span class="line">592429-1573657095</span><br></pre></td></tr></table></figure><h3 id="9-2-which、-whereis、-file、-whatis与平均负载"><a href="#9-2-which、-whereis、-file、-whatis与平均负载" class="headerlink" title="9.2 which、 whereis、 file、 whatis与平均负载"></a>9.2 which、 whereis、 file、 whatis与平均负载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># which, which命令用来找出某个命令的位置。</span></span><br><span class="line">$ <span class="built_in">which</span> ls</span><br><span class="line">/bin/ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis</span></span><br><span class="line"><span class="comment"># whereis与which命令类似，但它不仅返回命令的路径，还能够打印出其对应的命令手册的位置以及命令源代码的路径（如果有的话）</span></span><br><span class="line">$ whereis ls</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># file</span></span><br><span class="line">$ file FILENAME</span><br><span class="line"><span class="comment"># 该命令会打印出与该文件类型相关的细节信息。</span></span><br><span class="line">$ file /bin/ls</span><br><span class="line">/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked</span><br><span class="line">(uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.15, stripped</span><br><span class="line"></span><br><span class="line"><span class="comment"># whatis, whatis命令会输出作为参数的命令的简短描述信息。</span></span><br><span class="line">$ whatis ls</span><br><span class="line">ls (1) - list directory contents</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平均负载</span></span><br><span class="line">$ uptime</span><br><span class="line">12:40:53 up 6:16, 2 users, load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure><h3 id="9-3-杀死进程以及发送或响应信号"><a href="#9-3-杀死进程以及发送或响应信号" class="headerlink" title="9.3 杀死进程以及发送或响应信号"></a>9.3 杀死进程以及发送或响应信号</h3><p>信号是Linux中的一种进程间通信机制。 当进程接收到一个信号时，它会通过执行对应的信号处理程序（signal handler）来进行响应。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有可用的信号：</span></span><br><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止进程：</span></span><br><span class="line">$ <span class="built_in">kill</span> PROCESS_ID_LIST</span><br><span class="line"><span class="comment"># kill命令默认发出一个TERM信号。进程ID列表使用空格作为进程ID之间的定界符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要通过kill命令向进程发送指定的信号，可以使用：</span></span><br><span class="line">$ <span class="built_in">kill</span> -s SIGNAL PID</span><br><span class="line"><span class="comment"># 参数SIGNAL要么是信号名称，要么是信号编号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们经常要强行杀死进程，可以使用：</span></span><br><span class="line">$ <span class="built_in">kill</span> -s SIGKILL PROCESS_ID</span><br><span class="line">或者</span><br><span class="line">$ <span class="built_in">kill</span> -9 PROCESS_ID</span><br></pre></td></tr></table></figure><p>常用到的信号量：</p><ul><li>SIGHUP 1——对控制进程或终端的终结进行挂起检测（hangup detection）</li><li>SIGINT 2——当按下Ctrl + C时发送该信号 </li><li>SIGKILL 9——用于强行杀死进程 </li><li>SIGTERM 15——默认用于终止进程 </li><li>SIGTSTP 20——当按下Ctrl + Z时发送该信号 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># killall命令通过命令名终止进程：</span></span><br><span class="line">$ killall process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称向进程发送信号：</span></span><br><span class="line">$ killall -s SIGNAL process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称强行杀死进程：</span></span><br><span class="line">$ killall -9 process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># pkill命令和kill命令类似，不过默认情况下pkill接受的是进程名，而非进程ID。例如：</span></span><br><span class="line">$ pkill process_name</span><br><span class="line">$ pkill -s SIGNAL process_name</span><br><span class="line"><span class="comment"># pkill不支持信号名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕捉并响应信号</span></span><br><span class="line"><span class="comment"># trap命令在脚本中用来为信号分配信号处理程序。</span></span><br><span class="line">$ <span class="built_in">trap</span> <span class="string">'signal_handler_function_name'</span> SIGNAL LIST</span><br></pre></td></tr></table></figure><h3 id="9-4-向用户终端发送消息"><a href="#9-4-向用户终端发送消息" class="headerlink" title="9.4 向用户终端发送消息"></a>9.4 向用户终端发送消息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wall命令用来向当前所有登录用户的终端写入消息。</span></span><br><span class="line">$ cat message | wall</span><br><span class="line">或者</span><br><span class="line">$ wall&lt; message</span><br><span class="line">Broadcast Message from slynux@slynux-laptop</span><br><span class="line">(/dev/pts/1) at 12:54 ...</span><br><span class="line">This is a messag</span><br></pre></td></tr></table></figure><h3 id="9-5-采集系统信息"><a href="#9-5-采集系统信息" class="headerlink" title="9.5 采集系统信息"></a>9.5 采集系统信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印当前系统的主机名：</span></span><br><span class="line">$ hostname</span><br><span class="line">或者</span><br><span class="line">$ uname -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印Linux内核版本、硬件架构等详细信息：</span></span><br><span class="line">$ uname -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内核发行版本：</span></span><br><span class="line">$ uname -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印主机类型：</span></span><br><span class="line">$ uname -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印CPU相关信息：</span></span><br><span class="line">$ cat /proc/cpuinfo</span><br><span class="line"><span class="comment"># 获取处理器名称：</span></span><br><span class="line">$ cat /proc/cpuinfo | sed -n 5p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内存的详细信息：</span></span><br><span class="line">$ cat /proc/meminfo</span><br><span class="line"><span class="comment"># 打印系统可用内存总量：</span></span><br><span class="line">$ cat /proc/meminfo | head -1</span><br><span class="line">MemTotal: 1026096 kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出系统的分区信息：</span></span><br><span class="line">$ cat /proc/partitions</span><br><span class="line">或者</span><br><span class="line">$ fdisk -l <span class="comment">#如果没有输出，切换到root用户执行该命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取系统的详细信息：</span></span><br><span class="line">$ lshw <span class="comment">#建议以root用户来执行</span></span><br></pre></td></tr></table></figure><h3 id="9-6-使用-proc-采集信息"><a href="#9-6-使用-proc-采集信息" class="headerlink" title="9.6 使用 proc 采集信息"></a>9.6 使用 proc 采集信息</h3><p>以Bash为例，它的进程ID是4295（pgrep bash），那么就会有一个对应的目录/proc/4295。进程对应的目录中包含了大量有关进程的信息。 /proc/PID中一些重要的文件如下所示。 </p><ul><li><p>environ：包含与进程相关的环境变量。使用cat /proc/4295/environ，可以显示所有传递给该进程的环境变量 </p></li><li><p>cwd： 是一个到进程工作目录（working directory）的符号链接 </p></li><li><p>exe：是一个到当前进程所对应的可执行文件的符号链接 </p><p>$ readlink /proc/4295/exe<br>/bin/bash</p></li><li><p>fd：包含了进程所使用的文件描述符 </p></li></ul><h3 id="9-7-用-cron-进行调度"><a href="#9-7-用-cron-进行调度" class="headerlink" title="9.7 用 cron 进行调度"></a>9.7 用 cron 进行调度</h3><p><strong>crontab任务配置基本格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  *　 *　 *　   *　　command</span><br><span class="line">分钟(0-59)　小时(0-23)　日期(1-31)　 月份(1-12)　星期(0-6,0代表星期天)　  命令</span><br></pre></td></tr></table></figure><p>cron表中的每一个条目都由6部分组成，并按照下列顺序排列： </p><ul><li>分钟（0～59） </li><li>小时（0～23） </li><li>天（1～31） </li><li>月份（1～12） </li><li>工作日（0～6） </li><li>命令（在指定时间执行的脚本或命令） </li></ul><p>星号（*）指定命令应该在每个时间段执行。 </p><p>除了数字还有几个个特殊的符号就是 <code>&quot;*&quot;</code> 、<code>&quot;/&quot;</code> 和 <code>&quot;-&quot;</code> 、<code>&quot;,&quot;</code> ，<code>*</code> 代表所有的取值范围内的数字，<code>&quot;/&quot;</code> 代表每的意思, <code>&quot;*/5&quot;</code> 表示每5个单位，<code>&quot;-&quot;</code> 代表从某个数字到某个数字, <code>&quot;,&quot;</code> 分开几个离散的数字。以下举几个例子说明问题： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定每小时的第5分钟执行一次ls命令</span></span><br><span class="line">5 * * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每天的 5:30 执行ls命令</span></span><br><span class="line">30 5 * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每月8号的7：30分执行ls命令</span></span><br><span class="line">30 7 8 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每年的6月8日5：30执行ls命令</span></span><br><span class="line">30 5 8 6 * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每星期日的6:30执行ls命令 [ 注：0表示星期天，1表示星期1，以此类推，也可以用英文来表示，sun表示星期天，mon表示星期一等。 ]</span></span><br><span class="line">30 6 * * 0 ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月10号及20号的3：30执行ls命令 [注：“，”用来连接多个不连续的时段 ]</span></span><br><span class="line">30 3 10,20 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天8-11点的第25分钟执行ls命令 [注：“-”用来连接连续的时段 ]</span></span><br><span class="line">25 8-11 * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每15分钟执行一次ls命令 [即每个小时的第0 15 30 45 60分钟执行ls命令 ]</span></span><br><span class="line">*/15 * * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个月中，每隔10天6:30执行一次ls命令[即每月的1、11、21、31日是的6：30执行一次ls命令。 ]</span></span><br><span class="line">30 6 */10 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天7：50以root 身份执行/etc/cron.daily目录中的所有可执行文件</span></span><br><span class="line">50 7 * * * root run-parts /etc/cron.daily   <span class="comment"># [ 注：run-parts参数表示，执行后面目录中的所有可执行文件。 ]</span></span><br></pre></td></tr></table></figure><p><strong>配置用户定时任务的语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ crontab [-u user]file</span><br><span class="line"></span><br><span class="line">$ crontab -u user[-i]</span><br></pre></td></tr></table></figure><p>参数与说明：</p><ul><li>crontab -u        //设定某个用户的cron服务</li><li>crontab -l        //列出某个用户cron服务的详细内容</li><li>crontab -r              //删除没个用户的cron服务</li><li>crontab -e             //编辑某个用户的cron服务</li></ul><h3 id="9-8-从终端截图"><a href="#9-8-从终端截图" class="headerlink" title="9.8 从终端截图"></a>9.8 从终端截图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取整个屏幕：</span></span><br><span class="line">$ import -window root screenshot.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动选择部分区域进行抓取：</span></span><br><span class="line">$ import screenshot.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取特定窗口：</span></span><br><span class="line">$ import -window window_id screenshot.png</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本命令&quot;&gt;&lt;a href=&quot;#1-基本命令&quot; class=&quot;headerlink&quot; title=&quot;1. 基本命令&quot;&gt;&lt;/a&gt;1. 基本命令&lt;/h2&gt;&lt;h3 id=&quot;1-1-shell-格式输出&quot;&gt;&lt;a href=&quot;#1-1-shell-格式输出&quot; class=&quot;headerlink&quot; title=&quot;1.1 shell 格式输出&quot;&gt;&lt;/a&gt;1.1 shell 格式输出&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Hello world !&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n	&lt;span class=&quot;comment&quot;&gt;# 忽略结尾的换行符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-e	&lt;span class=&quot;comment&quot;&gt;# 激活转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-E	&lt;span class=&quot;comment&quot;&gt;# disable转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; -e &lt;span class=&quot;string&quot;&gt;&quot;1\t2\t3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://miaopei.github.io/categories/Shell/"/>
    
    
      <category term="shell" scheme="http://miaopei.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令eval的用法</title>
    <link href="http://miaopei.github.io/2017/04/13/Linux%E5%91%BD%E4%BB%A4eval%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://miaopei.github.io/2017/04/13/Linux命令eval的用法/</id>
    <published>2017-04-13T11:50:19.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eval-command-line"><a href="#eval-command-line" class="headerlink" title="eval command-line"></a>eval command-line</h2><p>其中command－line是在终端上键入的一条普通命令行。<strong>然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次</strong>。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pipe=<span class="string">"|"</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> ls <span class="variable">$pipe</span> wc -l</span><br></pre></td></tr></table></figure><p>shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。</p><a id="more"></a><p><strong>如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（；｜ &amp;），I／o重定向符（&lt; &gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。</strong></p><h2 id="eval-echo-取得最后一个参数"><a href="#eval-echo-取得最后一个参数" class="headerlink" title="eval echo $# 取得最后一个参数"></a>eval echo $# 取得最后一个参数</h2><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat last</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $<span class="variable">$#</span></span><br><span class="line"></span><br><span class="line">$ ./last one two three four</span><br><span class="line">four</span><br></pre></td></tr></table></figure><p>第一遍扫描后，shell把反斜杠去掉了。当shell再次扫描该行时，它替换了$4的值，并执行echo命令</p><h2 id="以下示意如何用eval命令创建指向变量的“指针”："><a href="#以下示意如何用eval命令创建指向变量的“指针”：" class="headerlink" title="以下示意如何用eval命令创建指向变量的“指针”："></a>以下示意如何用eval命令创建指向变量的“指针”：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ x=100</span><br><span class="line"></span><br><span class="line">$ ptrx=x</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> <span class="built_in">echo</span> $<span class="variable">$ptrx</span>  <span class="comment">#指向ptrx，用这里的方法可以理解b中的例子</span></span><br><span class="line">100 打印100</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> <span class="variable">$ptrx</span>=50  <span class="comment">#将50存到ptrx指向的变量中。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">50 打印50</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;eval-command-line&quot;&gt;&lt;a href=&quot;#eval-command-line&quot; class=&quot;headerlink&quot; title=&quot;eval command-line&quot;&gt;&lt;/a&gt;eval command-line&lt;/h2&gt;&lt;p&gt;其中command－line是在终端上键入的一条普通命令行。&lt;strong&gt;然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次&lt;/strong&gt;。如：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pipe=&lt;span class=&quot;string&quot;&gt;&quot;|&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;eval&lt;/span&gt; ls &lt;span class=&quot;variable&quot;&gt;$pipe&lt;/span&gt; wc -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。&lt;/p&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://miaopei.github.io/categories/Shell/"/>
    
    
      <category term="Linux Shell" scheme="http://miaopei.github.io/tags/Linux-Shell/"/>
    
  </entry>
  
  <entry>
    <title>HTTP思维导图</title>
    <link href="http://miaopei.github.io/2017/04/12/HTTP%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://miaopei.github.io/2017/04/12/HTTP思维导图/</id>
    <published>2017-04-12T07:41:58.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自<span class="exturl" data-url="aHR0cDovL3lycTExMC5tZS8yMDE3LzAzLzA0LzIwMTcwMzA0LWh0dHAtbWluZG1hcC8=" title="http://yrq110.me/2017/03/04/20170304-http-mindmap/">HTTP思维导图<i class="fa fa-external-link"></i></span>。</p><p>HTTP mindmap整理</p><p>source from 《HTTP权威指南》</p><a id="more"></a><h3 id="概述-Summary"><a href="#概述-Summary" class="headerlink" title="概述-Summary"></a>概述-Summary</h3><img src="/images/imageHttp/HTTP-1.svg"><h3 id="报文-Message"><a href="#报文-Message" class="headerlink" title="报文-Message"></a>报文-Message</h3><img src="/images/imageHttp/HTTP-2.svg"><h3 id="连接-Connection"><a href="#连接-Connection" class="headerlink" title="连接-Connection"></a>连接-Connection</h3><img src="/images/imageHttp/HTTP-3.svg"><h3 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理-Proxy"></a>代理-Proxy</h3><img src="/images/imageHttp/HTTP-4.svg"><h3 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存-Cache"></a>缓存-Cache</h3><img src="/images/imageHttp/HTTP-5.svg"><h3 id="网关、隧道与中继-Gateway、Tunnel-and-Relay"><a href="#网关、隧道与中继-Gateway、Tunnel-and-Relay" class="headerlink" title="网关、隧道与中继-Gateway、Tunnel and Relay"></a>网关、隧道与中继-Gateway、Tunnel and Relay</h3><img src="/images/imageHttp/HTTP-6.svg"><h3 id="识别-Identification"><a href="#识别-Identification" class="headerlink" title="识别-Identification"></a>识别-Identification</h3><img src="/images/imageHttp/HTTP-7.svg"><h3 id="认证-Authentication"><a href="#认证-Authentication" class="headerlink" title="认证-Authentication"></a>认证-Authentication</h3><img src="/images/imageHttp/HTTP-8.svg"><h3 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全-Security"></a>安全-Security</h3><img src="/images/imageHttp/HTTP-9.svg"><h3 id="实体与编码-Entity-and-Encoding"><a href="#实体与编码-Entity-and-Encoding" class="headerlink" title="实体与编码-Entity and Encoding"></a>实体与编码-Entity and Encoding</h3><img src="/images/imageHttp/HTTP-10.svg">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章来自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3lycTExMC5tZS8yMDE3LzAzLzA0LzIwMTcwMzA0LWh0dHAtbWluZG1hcC8=&quot; title=&quot;http://yrq110.me/2017/03/04/20170304-http-mindmap/&quot;&gt;HTTP思维导图&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;HTTP mindmap整理&lt;/p&gt;
&lt;p&gt;source from 《HTTP权威指南》&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://miaopei.github.io/categories/http/"/>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Webpack创建、运行vue.js项目及其目录结构详解</title>
    <link href="http://miaopei.github.io/2017/04/10/Webpack%E5%88%9B%E5%BB%BA%E3%80%81%E8%BF%90%E8%A1%8Cvue-js%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://miaopei.github.io/2017/04/10/Webpack创建、运行vue-js项目及其目录结构详解/</id>
    <published>2017-04-10T10:18:27.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目环境搭建："><a href="#项目环境搭建：" class="headerlink" title="项目环境搭建："></a>项目环境搭建：</h3><p>1.安装node</p><p>进入<a href="[https://nodejs.org/en/](https://nodejs.org/en/">node官网</a>进行下载。</p><p>版本查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v6.10.1</span><br></pre></td></tr></table></figure><p style="color:red;">**注意：**node版本最好新一点，推介6.0以上。 </p><a id="more"></a><p>2.全局安装vue-cli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g vue-cli</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果安装失败可能需要root权限重新安装。</p><p>3.创建一个基于 <code>webpack</code> 模板的新项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vue init webpack project-name <span class="comment">#(默认安装2.0版本)</span></span><br><span class="line">$ vue init webpack<span class="comment">#1.0 project-name #(安装1.0版本)</span></span><br></pre></td></tr></table></figure><h3 id="项目目录结构："><a href="#项目目录结构：" class="headerlink" title="项目目录结构："></a>项目目录结构：</h3><p><img src="http://i.imgur.com/P64Q8uK.png" alt></p><p><img src="http://i.imgur.com/beLRmUA.png" alt></p><ul><li><p>main.js是入口文件，主要作用是初始化vue实例并使用需要的插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。其实你也可以理解为所有的路由也是App.vue的子组件。所以我将router标示为App.vue的子组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;hello&gt;&lt;/hello&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Hello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>index.html文件入口</p></li><li><p>src放置组件和入口文件</p></li><li><p>node_modules为依赖的模块</p></li><li><p>config中配置了路径端口值等</p></li><li><p>build中配置了webpack的基本配置、开发环境配置、生产环境配置等</p></li></ul><h3 id="运行项目："><a href="#运行项目：" class="headerlink" title="运行项目："></a>运行项目：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> project-name</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br><span class="line"><span class="comment"># 上述步骤都完成后在浏览器输入：localhost:8080</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;项目环境搭建：&quot;&gt;&lt;a href=&quot;#项目环境搭建：&quot; class=&quot;headerlink&quot; title=&quot;项目环境搭建：&quot;&gt;&lt;/a&gt;项目环境搭建：&lt;/h3&gt;&lt;p&gt;1.安装node&lt;/p&gt;
&lt;p&gt;进入&lt;a href=&quot;[https://nodejs.org/en/](https://nodejs.org/en/&quot;&gt;node官网&lt;/a&gt;进行下载。&lt;/p&gt;
&lt;p&gt;版本查看：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ node -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v6.10.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p style=&quot;color:red;&quot;&gt;**注意：**node版本最好新一点，推介6.0以上。 &lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://miaopei.github.io/categories/Docker/"/>
    
    
      <category term="webpack" scheme="http://miaopei.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>lighttpd 配置https</title>
    <link href="http://miaopei.github.io/2017/03/31/lighttpd-%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://miaopei.github.io/2017/03/31/lighttpd-配置https/</id>
    <published>2017-03-31T04:34:28.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="确定安装的lighttpd支持ssl"><a href="#确定安装的lighttpd支持ssl" class="headerlink" title="确定安装的lighttpd支持ssl"></a>确定安装的lighttpd支持ssl</h3><p>版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lighttpd -v</span><br><span class="line">lighttpd/1.4.35 (ssl) - a light and fast webserver</span><br><span class="line">Build-Date: Apr 25 2017 10:25:18</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h3><p>完整的ssl证书分为四个部分：</p><ul><li>CA根证书（root CA）</li><li>中级证书（Intermediate Certificate）</li><li>域名证书</li><li>证书秘钥（仅由开发者提供）</li></ul><p>证书相当于公钥，pem相当于私钥。</p><p>Self-Signed Certificates：包含公钥和私钥的结合体，证书（公钥）会在连接请求的时候发给浏览器，以便浏览器解密和加密。</p><p>创建Self-Signed Certificates：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><p>上边的命令生成一个server.pem文件。</p><h3 id="lighttpd-conf-配置"><a href="#lighttpd-conf-配置" class="headerlink" title="lighttpd.conf 配置"></a>lighttpd.conf 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SERVER</span>[<span class="string">"socket"</span>] == <span class="string">"[::]:443"</span> &#123;  </span><br><span class="line">     ssl.engine      = <span class="string">"enable"</span></span><br><span class="line">     ssl.pemfile     = <span class="string">"/mnt/flash/server.pem"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制定向到HTTPS"><a href="#强制定向到HTTPS" class="headerlink" title="强制定向到HTTPS"></a>强制定向到HTTPS</h3><p>下面是 <code>lighttpd.conf</code> 文件中关于强制 HTTP 定向到 HTTPS 的部分配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HTTP</span>[<span class="string">"scheme"</span>] == <span class="string">"http"</span> &#123;</span><br><span class="line">    <span class="comment"># capture vhost name with regex conditiona -&gt; %0 in redirect pattern</span></span><br><span class="line">    <span class="comment"># must be the most inner block to the redirect rule</span></span><br><span class="line">    <span class="variable">$HTTP</span>[<span class="string">"host"</span>] =~ <span class="string">".*"</span> &#123;</span><br><span class="line">        url.redirect = (<span class="string">".*"</span> =&gt; <span class="string">"https://%0<span class="variable">$0</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此功能需要lighttpd <code>mod_redirect</code> 模块支持。使用此功能前确保模块已经安装。</p><h3 id="lighttpd安全配置"><a href="#lighttpd安全配置" class="headerlink" title="lighttpd安全配置"></a>lighttpd安全配置</h3><p><strong>禁用 SSL Compression (抵御 CRIME 攻击)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.use-compression = <span class="string">"disable"</span></span><br></pre></td></tr></table></figure><p><strong>禁用 SSLv2 及 SSLv3</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl.use-sslv2 = <span class="string">"disable"</span></span><br><span class="line">ssl.use-sslv3 = <span class="string">"disable"</span></span><br></pre></td></tr></table></figure><p><strong>抵御 Poodle 和 SSL downgrade 攻击</strong></p><p>需要支持 <code>TLS-FALLBACK-SCSV</code> 以自动开启此功能。下列 openSSL 版本包含对 <code>TLS-FALLBACK-SCSV</code> 的支持，lighttpd 会自动启用此特性。</p><ul><li>OpenSSL <strong>1.0.1</strong> 在 <code>1.0.1j</code> 及之后的版本中支持</li><li>OpenSSL <strong>1.0.0</strong> 在 <code>1.0.0o</code> 及之后的版本中支持</li><li>OpenSSL <strong>0.9.8</strong> 在 <code>0.9.8zc</code> 及之后的版本中支持</li></ul><p><strong>加密及交换算法</strong></p><p>一份推介的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.cipher-list = <span class="string">"EECDH+AESGCM:EDH+AESGCM:AES128+EECDH:AES128+EDH"</span></span><br></pre></td></tr></table></figure><p>如果您需要兼容一些老式系统和浏览器 (例如 Windows XP 和 IE6)，请使用下面的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.cipher-list = <span class="string">"EECDH+AESGCM:EDH+AESGCM:ECDHE-RSA-AES128-GCM-SHA256:AES256+EECDH:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4"</span></span><br></pre></td></tr></table></figure><p><strong>配置 Forward Secrecy 和 DHE 参数</strong></p><p>生成强 DHE 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/ssl/certs</span><br><span class="line">$ openssl dhparam -out dhparam.pem 4096</span><br></pre></td></tr></table></figure><p><strong>建议您使用性能强劲的平台生成此文件</strong>，例如最新版的至强物理机。如果您只有一台小型 VPS，请使用 <code>openssl dhparam -out dhparam.pem 2048</code> 命令生成 2048bit 的参数文件。</p><p>添加到 SSL 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl.dh-file = <span class="string">"/etc/ssl/certs/dhparam.pem"</span></span><br><span class="line">ssl.ec-curve = <span class="string">"secp384r1"</span></span><br></pre></td></tr></table></figure><p><strong>启用 HSTS</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.modules += ( <span class="string">"mod_setenv"</span> )</span><br><span class="line"><span class="variable">$HTTP</span>[<span class="string">"scheme"</span>] == <span class="string">"https"</span> &#123;</span><br><span class="line">    setenv.add-response-header  = ( <span class="string">"Strict-Transport-Security"</span> =&gt; <span class="string">"max-age=63072000; includeSubdomains; preload"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0xpZ2h0dHBk" title="https://wiki.archlinux.org/index.php/Lighttpd">Lighttpd<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;确定安装的lighttpd支持ssl&quot;&gt;&lt;a href=&quot;#确定安装的lighttpd支持ssl&quot; class=&quot;headerlink&quot; title=&quot;确定安装的lighttpd支持ssl&quot;&gt;&lt;/a&gt;确定安装的lighttpd支持ssl&lt;/h3&gt;&lt;p&gt;版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ lighttpd -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lighttpd/1.4.35 (ssl) - a light and fast webserver&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Build-Date: Apr 25 2017 10:25:18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
      <category term="lighttpd" scheme="http://miaopei.github.io/tags/lighttpd/"/>
    
  </entry>
  
  <entry>
    <title>lighttpd+fastcgi</title>
    <link href="http://miaopei.github.io/2017/03/31/lighttpd-fastcgi/"/>
    <id>http://miaopei.github.io/2017/03/31/lighttpd-fastcgi/</id>
    <published>2017-03-31T04:34:28.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>lighttpd</code> 提供了一种外部程序调用的接口，即 <code>FastCGI</code> 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。</p><p>这就意味着能够在 <code>Apache</code> 服务器上运行的 <code>FastCGI</code> 程序，也一定可以无缝的在 <code>lighttpd</code> 上使用。</p><a id="more"></a><h3 id="FastCGI介绍"><a href="#FastCGI介绍" class="headerlink" title="FastCGI介绍"></a>FastCGI介绍</h3><p>1）就像 <code>CGI</code> 一样，<code>FastCGI</code> 也是独立于编程语言的。<br>2）就像 <code>CGI</code> 一样，<code>FastCGI</code> 程序运行在完全独立于核心 <code>Web Server</code> 之外的进程中，和 <code>API</code> 方式相比，提供了很大的安全性。（API会将程序代码与核心Web Server挂接在一起，这就意味着基于问题API的应用程序可能会使整个Web Server或另一个应用程序崩溃；一个恶意API还可以从核心Web Server或另一个应用程序中盗取安全密钥）</p><p>3) 虽然 <code>FastCGI</code> 不能一夜之间复制CGI的所有功能，但是 <code>FastCGI</code> 一直宣扬开放，这也使得我们拥有很多免费的 <code>FastCGI</code> 应用程序库（C/C++、Java、Perl、TCL）和免费的Server模块（Apache、ISS、Lighttpd）。</p><p>4) 就像 <code>CGI</code> 一样，<code>FastCGI</code> 并不依附于任何 <code>Web Server</code> 的内部架构，因此即使 <code>Server</code> 的技术实现变动，<code>FastCGI</code> 仍然非常稳定；而 <code>API</code> 设计是反映 <code>Web Server</code> 内部架构的，因此，一旦架构改变，API要随之变动。</p><p>5) <code>FastCGI</code> 程序可以运行在任何机器上，完全可以和 <code>Web Server</code> 不在一台机器上。这种分布式计算的思想可以确保可扩展性、提高系统可用性和安全性。</p><p>6) <code>CGI</code> 程序主要是对 <code>HTTP</code> 请求做计算处理，而 <code>FastCGI</code> 却还可以做得更多，例如模块化认证、授权检查、数据类型转换等等。在未来，<code>FastCGI</code> 还会有能力扮演更多角色。</p><p>7) <code>FastCGI</code> 移除了 <code>CGI</code> 程序的许多弊端。例如，针对每一个新请求，<code>WebServer</code> 都必须重启 <code>CGI</code> 程序来处理新请求，这导致 <code>WebServer</code> 的性能会大受影响。而 <code>FastCGI</code> 通过保持进程处理运行状态并持续处理请求的方式解决了该问题，这就将进程创建和销毁的时间节省了出来。</p><p>8) <code>CGI</code> 程序需要通过管道（pipe）方式与 <code>Web Server</code> 通信，而 <code>FastCGI</code> 则是通过 <code>Unix-Domain-Sockets</code> 或 <code>TCP/IP</code> 方式来实现与 <code>Web Server</code> 的通信。这确保了 <code>FastCGI</code> 可以运行在 <code>Web Server</code> 之外的服务器上。<code>FastCGI</code> 提供了 <code>FastCGI</code> 负载均衡器，它可以有效控制多个独立的 <code>FastCGI Server</code> 的负载，这种方式比 <code>load-balancer+apache+mod_php</code> 方式能够承担更多的流量。</p><h3 id="FastCGI-模块"><a href="#FastCGI-模块" class="headerlink" title="FastCGI 模块"></a>FastCGI 模块</h3><p>若要 <code>lighttpd</code> 支持 <code>fastcgi</code>，则需要配置如下内容：</p><p>在 <code>fastcgi.conf</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.modules += ( &quot;mod_fastcgi&quot; )</span><br></pre></td></tr></table></figure><p>及在 <code>module.conf</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;conf.d/fastcgi.conf&quot;</span><br></pre></td></tr></table></figure><h3 id="FastCGI-配置选项"><a href="#FastCGI-配置选项" class="headerlink" title="FastCGI 配置选项"></a>FastCGI 配置选项</h3><p><code>lighttpd</code> 通过 <code>fastcgi</code> 模块的方式实现了对 <code>fastcgi</code> 的支持，并且在配置文件中提供了三个相关的选项：</p><p>1） fastcgi.debug</p><p>可以设置一个从0到65535的值，用于设定 <code>FastCGI</code> 模块的调试等级。当前仅有0和1可用。<strong>1表示开启调试（会输出调试信息），0表示禁用</strong>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.debug = 1</span><br></pre></td></tr></table></figure><p>2） fastcgi.map-extentsions</p><p>同一个 <code>fastcgi server</code> 能够映射多个扩展名，如 <code>.php3</code> 和 <code>.php4</code> 都对应 <code>.php</code>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot; )</span><br></pre></td></tr></table></figure><p>or for multiple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot;, &quot;.php4&quot; =&gt; &quot;.php&quot; )</span><br></pre></td></tr></table></figure><p>3） fastcgi.server</p><p>这个配置是告诉 <code>Web Server</code> 将 <code>FastCGI</code> 请求发送到哪里，其中每一个文件扩展名可以处理一个类型的请求。负载均衡器可以实现对同一扩展名的多个对象的负载均衡。</p><p><code>fastcgi.server</code> 的结构语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">( &lt;extension&gt; =&gt;</span><br><span class="line">  ( [ &lt;name&gt; =&gt; ]</span><br><span class="line">    ( <span class="comment"># Be careful: lighty does *not* warn you if it doesn't know a specified option here (make sure you have no typos)</span></span><br><span class="line">      <span class="string">"host"</span> =&gt; &lt;string&gt; ,</span><br><span class="line">      <span class="string">"port"</span> =&gt; &lt;<span class="built_in">integer</span>&gt; ,</span><br><span class="line">      <span class="string">"socket"</span> =&gt; &lt;string&gt;,                 <span class="comment"># either socket or host+port</span></span><br><span class="line">      <span class="string">"bin-path"</span> =&gt; &lt;string&gt;,               <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"bin-environment"</span> =&gt; &lt;array&gt;,         <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"bin-copy-environment"</span> =&gt; &lt;array&gt;,    <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"mode"</span> =&gt; &lt;string&gt;,                   <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"docroot"</span> =&gt; &lt;string&gt; ,               <span class="comment"># optional if "mode" is not "authorizer"</span></span><br><span class="line">      <span class="string">"check-local"</span> =&gt; &lt;string&gt;,            <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"max-procs"</span> =&gt; &lt;<span class="built_in">integer</span>&gt;,             <span class="comment"># optional - when omitted, default is 4</span></span><br><span class="line">      <span class="string">"broken-scriptfilename"</span> =&gt; &lt;boolean&gt;, <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"kill-signal"</span> =&gt; &lt;<span class="built_in">integer</span>&gt;,           <span class="comment"># optional, default is SIGTERM(15) (v1.4.14+)</span></span><br><span class="line">    ),</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; ...</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中：</p><blockquote><p><strong>extentsion</strong> ：文件名后缀或以”/”开头的前缀（也可为文件名）<br><strong>name</strong> ：这是一个可选项，表示handler的名称，在mod_status中用于统计功能，可以清晰的分辨出是哪一个handler处理了<extension>。<strong>host</strong> ：FastCGI进程监听的IP地址。此处不支持hostname形式。<br><strong>port</strong> ：FastCGI进程所监听的TCP端口号<br><strong>bin-path</strong> ：本地FastCGI二进制程序的路径，当本地没有FastCGI正在运行时，会启动这个FastCGI程序。<br><strong>socket</strong> ：unix-domain-socket所在路径。<br><strong>mode</strong> ：可以选择FastCGI协议的模式，默认是“responder”，还可以选择authorizer。<br><strong>docroot</strong> ：这是一个可选项，对于responder模式来讲，表示远程主机docroot；对于authorizer模式来说，它表示MANDATORY，并且指向授权请求的docroot。<br><strong>check_local</strong> ：这是一个可选项，默认是enable。如果是enable，那么server会首先在本地（server.document-root）目录中检查被请求的文件是否存在，如果不存在，则给用户返回404（Not Found），而不会把这个请求传递给FastCGI。如果是disable，那么server不会检查本地文件，而是直接将请求转发给FastCGI。（disable的话，server从某种意义上说就变为了一个转发器）<br><strong>broken-scriptfilename</strong> ：以类似PHP抽取PATH_INFO的方式，抽取URL中的SCRIPT_FILENAME。</extension></p></blockquote><p>如果 <code>bin-path</code> 被设置了，那么：</p><blockquote><p><strong>max-procs</strong> ：设置多少个FastCGI进程被启动<br><strong>bin-environment</strong> ：在FastCGI进程启动时设置一个环境变量<br><strong>bin-copy-environment</strong> ：清除环境，并拷贝指定的变量到全新的环境中。<br><strong>kill-signal</strong> ：默认的话，在停止FastCGI进程时，lighttpd会发送SIGTERM(-15)信号给子进程。此处可以设置发送的信号。</p></blockquote><p><strong>举例</strong> ：</p><p>使用前缀来对应主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = (</span><br><span class="line">  <span class="string">"/remote_scripts/"</span> =&gt;</span><br><span class="line">  (( <span class="string">"host"</span> =&gt; <span class="string">"192.168.0.3"</span>,</span><br><span class="line">     <span class="string">"port"</span> =&gt; 9000,</span><br><span class="line">     <span class="string">"check-local"</span> =&gt; <span class="string">"disable"</span>,</span><br><span class="line">     <span class="string">"docroot"</span> =&gt; <span class="string">"/"</span> <span class="comment"># remote server may use</span></span><br><span class="line">                      <span class="comment"># it's own docroot</span></span><br><span class="line">  ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果有一个请求 “<span class="exturl" data-url="aHR0cDovL215LmV4YW1wbGUub3JnL3JlbW90ZV9zY3JpcHRzL3Rlc3QuY2dpJnF1b3Q777yM6YKj5LmIc2VydmVy5Lya5bCG5YW26L2s5Y+R57uZMTkyLjE2OC4wLjPnmoQ5MDAw56uv5Y+j77yM5bm25LiU" title="http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且">http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且<i class="fa fa-external-link"></i></span> <code>SCRIPT_NAME</code> 会被赋值为 <code>“/remote_scripts/test.cgi”</code>。如果所设置的 <code>handler</code> 的末尾不是 <code>“/”</code> ，那么会被认为是一个文件。</p><p><strong>负载均衡</strong> ：</p><p><code>FastCGI</code> 模块提供了一种在多台 <code>FastCGI</code> 服务器间负载均衡的方法。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = ( <span class="string">".php"</span> =&gt;</span><br><span class="line">  (</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; <span class="string">"10.0.0.2"</span>,</span><br><span class="line">      <span class="string">"port"</span> =&gt; 1030</span><br><span class="line">    ),</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; <span class="string">"10.0.0.3"</span>,</span><br><span class="line">      <span class="string">"port"</span> =&gt; 1030 )</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>为了更好的理解负载均衡实现的原理，建议你置 <code>fastcgi.debug</code> 为 <code>1</code> 。即使对于本机的多个 <code>FastCGI</code> ，你也会获得如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proc: 127.0.0.1 1031  1 1 1 31454</span><br><span class="line">proc: 127.0.0.1 1028  1 1 1 31442</span><br><span class="line">proc: 127.0.0.1 1030  1 1 1 31449</span><br><span class="line">proc: 127.0.0.1 1029  1 1 2 31447</span><br><span class="line">proc: 127.0.0.1 1026  1 1 2 31438</span><br><span class="line">got proc: 34 31454</span><br><span class="line">release proc: 40 31438</span><br><span class="line">proc: 127.0.0.1 1026  1 1 1 31438</span><br><span class="line">proc: 127.0.0.1 1028  1 1 1 31442</span><br><span class="line">proc: 127.0.0.1 1030  1 1 1 31449</span><br><span class="line">proc: 127.0.0.1 1031  1 1 2 31454</span><br><span class="line">proc: 127.0.0.1 1029  1 1 2 31447</span><br></pre></td></tr></table></figure><p>上述信息显示出了IP地址，端口号、当前链接数（也就是负载）（倒数第二列）、进程ID（倒数第一列）等等。整个输出信息总是以负载域来从小到大排序的。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><span class="exturl" data-url="aHR0cDovL3JlZG1pbmUubGlnaHR0cGQubmV0L3Byb2plY3RzLzEvd2lraS9Eb2NzOk1vZEZhc3RDR0k=" title="http://redmine.lighttpd.net/projects/1/wiki/Docs:ModFastCGI"><i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5mYXN0Y2dpLmNvbQ==" title="http://www.fastcgi.com"><i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3JvY2xpbnV4LmNuLz9wPTIzNDc=" title="http://roclinux.cn/?p=2347">说说lighttpd的fastcgi<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3luZXQvcC80MTczNDUwLmh0bWw=" title="http://www.cnblogs.com/skynet/p/4173450.html">Nginx + CGI/FastCGI + C/Cpp<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDAwNjU5Ng==" title="https://segmentfault.com/a/1190000004006596">FastCGI+lighttpd开发之介绍和环境搭建<i class="fa fa-external-link"></i></span></p><h3 id="附：QC-V3-PP-版本-lighttpd-conf"><a href="#附：QC-V3-PP-版本-lighttpd-conf" class="headerlink" title="附：QC V3 PP 版本 lighttpd.conf"></a>附：QC V3 PP 版本 lighttpd.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/qtilighttpd.conf </span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Copyright (c) 2016 Qualcomm Technologies, Inc.</span></span><br><span class="line"><span class="comment"># All Rights Reserved.</span></span><br><span class="line"><span class="comment"># Confidential and Proprietary - Qualcomm Technologies, Inc.</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">server.document-root = <span class="string">"/opt/qcom/www"</span></span><br><span class="line"></span><br><span class="line">server.port    = 80</span><br><span class="line">server.username    = <span class="string">"apps"</span></span><br><span class="line">server.groupname  = <span class="string">"apps"</span></span><br><span class="line">server.bind    = <span class="string">"0.0.0.0"</span></span><br><span class="line">server.tag    = <span class="string">"lighttpd"</span></span><br><span class="line"><span class="variable">$SERVER</span>[<span class="string">"socket"</span>] == <span class="string">"[::]:80"</span> &#123;  &#125;</span><br><span class="line"></span><br><span class="line">server.errorlog-use-syslog  = <span class="string">"enable"</span></span><br><span class="line">accesslog.use-syslog    = <span class="string">"enable"</span></span><br><span class="line"></span><br><span class="line">server.modules    = (</span><br><span class="line">  <span class="string">"mod_access"</span>,<span class="string">"mod_accesslog"</span>, <span class="string">"mod_cgi"</span>, <span class="string">"mod_fastcgi"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fastcgi.debug = 1</span><br><span class="line">fastcgi.server = (</span><br><span class="line">    <span class="string">"/fsmoam"</span> =&gt; (</span><br><span class="line">    <span class="string">"fsmoam.fcgi.handler"</span> =&gt; (</span><br><span class="line">        <span class="string">"socket"</span> =&gt; <span class="string">"/tmp/fsmoam.fcgi.socket"</span>,</span><br><span class="line">        <span class="string">"check-local"</span> =&gt; <span class="string">"disable"</span>,</span><br><span class="line">        <span class="string">"bin-path"</span> =&gt; <span class="string">"/opt/qcom/bin/tests/fsmWebServer --default-log-level=DEBUG"</span>,</span><br><span class="line">        <span class="string">"max-procs"</span> =&gt; 1)</span><br><span class="line">     )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mimetype mapping</span></span><br><span class="line">mimetype.assign    = (</span><br><span class="line">  <span class="string">".pdf"</span>    =&gt;  <span class="string">"application/pdf"</span>,</span><br><span class="line">  <span class="string">".sig"</span>    =&gt;  <span class="string">"application/pgp-signature"</span>,</span><br><span class="line">  <span class="string">".spl"</span>    =&gt;  <span class="string">"application/futuresplash"</span>,</span><br><span class="line">  <span class="string">".class"</span>  =&gt;  <span class="string">"application/octet-stream"</span>,</span><br><span class="line">  <span class="string">".ps"</span>    =&gt;  <span class="string">"application/postscript"</span>,</span><br><span class="line">  <span class="string">".torrent"</span>  =&gt;  <span class="string">"application/x-bittorrent"</span>,</span><br><span class="line">  <span class="string">".dvi"</span>    =&gt;  <span class="string">"application/x-dvi"</span>,</span><br><span class="line">  <span class="string">".gz"</span>    =&gt;  <span class="string">"application/x-gzip"</span>,</span><br><span class="line">  <span class="string">".pac"</span>    =&gt;  <span class="string">"application/x-ns-proxy-autoconfig"</span>,</span><br><span class="line">  <span class="string">".swf"</span>    =&gt;  <span class="string">"application/x-shockwave-flash"</span>,</span><br><span class="line">  <span class="string">".tar.gz"</span>  =&gt;  <span class="string">"application/x-tgz"</span>,</span><br><span class="line">  <span class="string">".tgz"</span>    =&gt;  <span class="string">"application/x-tgz"</span>,</span><br><span class="line">  <span class="string">".tar"</span>    =&gt;  <span class="string">"application/x-tar"</span>,</span><br><span class="line">  <span class="string">".zip"</span>    =&gt;  <span class="string">"application/zip"</span>,</span><br><span class="line">  <span class="string">".mp3"</span>    =&gt;  <span class="string">"audio/mpeg"</span>,</span><br><span class="line">  <span class="string">".m3u"</span>    =&gt;  <span class="string">"audio/x-mpegurl"</span>,</span><br><span class="line">  <span class="string">".wma"</span>    =&gt;  <span class="string">"audio/x-ms-wma"</span>,</span><br><span class="line">  <span class="string">".wax"</span>    =&gt;  <span class="string">"audio/x-ms-wax"</span>,</span><br><span class="line">  <span class="string">".ogg"</span>    =&gt;  <span class="string">"audio/x-wav"</span>,</span><br><span class="line">  <span class="string">".wav"</span>    =&gt;  <span class="string">"audio/x-wav"</span>,</span><br><span class="line">  <span class="string">".gif"</span>    =&gt;  <span class="string">"image/gif"</span>,</span><br><span class="line">  <span class="string">".jpg"</span>    =&gt;  <span class="string">"image/jpeg"</span>,</span><br><span class="line">  <span class="string">".jpeg"</span>    =&gt;  <span class="string">"image/jpeg"</span>,</span><br><span class="line">  <span class="string">".png"</span>    =&gt;  <span class="string">"image/png"</span>,</span><br><span class="line">  <span class="string">".xbm"</span>    =&gt;  <span class="string">"image/x-xbitmap"</span>,</span><br><span class="line">  <span class="string">".xpm"</span>    =&gt;  <span class="string">"image/x-xpixmap"</span>,</span><br><span class="line">  <span class="string">".xwd"</span>    =&gt;  <span class="string">"image/x-xwindowdump"</span>,</span><br><span class="line">  <span class="string">".css"</span>    =&gt;  <span class="string">"text/css"</span>,</span><br><span class="line">  <span class="string">".html"</span>    =&gt;  <span class="string">"text/html"</span>,</span><br><span class="line">  <span class="string">".htm"</span>    =&gt;  <span class="string">"text/html"</span>,</span><br><span class="line">  <span class="string">".js"</span>    =&gt;  <span class="string">"text/javascript"</span>,</span><br><span class="line">  <span class="string">".asc"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".c"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".conf"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".text"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".txt"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".dtd"</span>    =&gt;  <span class="string">"text/xml"</span>,</span><br><span class="line">  <span class="string">".xml"</span>    =&gt;  <span class="string">"text/xml"</span>,</span><br><span class="line">  <span class="string">".mpeg"</span>    =&gt;  <span class="string">"video/mpeg"</span>,</span><br><span class="line">  <span class="string">".mpg"</span>    =&gt;  <span class="string">"video/mpeg"</span>,</span><br><span class="line">  <span class="string">".mov"</span>    =&gt;  <span class="string">"video/quicktime"</span>,</span><br><span class="line">  <span class="string">".qt"</span>    =&gt;  <span class="string">"video/quicktime"</span>,</span><br><span class="line">  <span class="string">".avi"</span>    =&gt;  <span class="string">"video/x-msvideo"</span>,</span><br><span class="line">  <span class="string">".asf"</span>    =&gt;  <span class="string">"video/x-ms-asf"</span>,</span><br><span class="line">  <span class="string">".asx"</span>    =&gt;  <span class="string">"video/x-ms-asf"</span>,</span><br><span class="line">  <span class="string">".wmv"</span>    =&gt;  <span class="string">"video/x-ms-wmv"</span>,</span><br><span class="line">  <span class="string">".bz2"</span>    =&gt;  <span class="string">"application/x-bzip"</span>,</span><br><span class="line">  <span class="string">".tbz"</span>    =&gt;  <span class="string">"application/x-bzip-compressed-tar"</span>,</span><br><span class="line">  <span class="string">".tar.bz2"</span>  =&gt;  <span class="string">"application/x-bzip-compressed-tar"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">index-file.names = ( <span class="string">"index.html"</span> )</span><br><span class="line"></span><br><span class="line">cgi.assign = ( <span class="string">".sh"</span> =&gt; <span class="string">"/bin/sh"</span> )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;lighttpd&lt;/code&gt; 提供了一种外部程序调用的接口，即 &lt;code&gt;FastCGI&lt;/code&gt; 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。&lt;/p&gt;
&lt;p&gt;这就意味着能够在 &lt;code&gt;Apache&lt;/code&gt; 服务器上运行的 &lt;code&gt;FastCGI&lt;/code&gt; 程序，也一定可以无缝的在 &lt;code&gt;lighttpd&lt;/code&gt; 上使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="lighttpd" scheme="http://miaopei.github.io/tags/lighttpd/"/>
    
      <category term="FastCGI" scheme="http://miaopei.github.io/tags/FastCGI/"/>
    
  </entry>
  
  <entry>
    <title>svn 常用操作命令</title>
    <link href="http://miaopei.github.io/2017/03/29/svn-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://miaopei.github.io/2017/03/29/svn-常用操作命令/</id>
    <published>2017-03-29T08:23:27.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span><br><span class="line">$ svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名</span><br><span class="line"><span class="comment"># 也可以使用缩写</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">$ svn co http://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>注</strong> ：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。 不指定本地目录全路径，则检出到当前目录下。</p><h2 id="导出（导出一个干净的不带-svn文件夹的目录树）"><a href="#导出（导出一个干净的不带-svn文件夹的目录树）" class="headerlink" title="导出（导出一个干净的不带.svn文件夹的目录树）"></a>导出（导出一个干净的不带.svn文件夹的目录树）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn  <span class="built_in">export</span>  [-r 版本号]  http://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">$ svn  <span class="built_in">export</span>  [-r 版本号]  svn://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">$ svn  <span class="built_in">export</span>  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn <span class="built_in">export</span> svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">$ svn <span class="built_in">export</span> svn://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br><span class="line">$ svn <span class="built_in">export</span> /home/testapp /home/testtools</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：第一种从版本库导出干净工作目录树的形式是指定URL，</p><p>​     如果指定了修订版本号，会导出相应的版本，</p><p>​     如果没有指定修订版本，则会导出最新的，导出到指定位置。</p><p>​     如果省略 本地目录全路径，URL的最后一部分会作为本地目录的名字。</p><p>​     第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留，</p><p>​     但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。</p><h2 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn　add　文件名</span><br><span class="line"><span class="comment"># 注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn add test.php  <span class="comment"># 添加test.php </span></span><br><span class="line">$ svn commit -m <span class="string">"添加我的测试用test.php"</span> test.php</span><br><span class="line">$ svn add *.php  <span class="comment"># 添加当前目录下所有的php文件</span></span><br><span class="line">$ svn commit -m <span class="string">"添加我的测试用全部php文件"</span> *.php</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ svn　commit　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line">$ svn　ci　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line"><span class="comment"># 必须带上-m参数，参数可以为空，但是必须写上-m</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn commit -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> *   <span class="comment"># 注意这个*表示全部文件</span></span><br><span class="line">$ svn commit -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">$ svn commit -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php   <span class="comment"># 保持锁就用–no-unlock开关</span></span><br><span class="line">$ svn ci -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> *   <span class="comment"># 注意这个*表示全部文件</span></span><br><span class="line">$ svn ci -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">$ svn ci -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php   <span class="comment"># 保持锁就用–no-unlock开关</span></span><br></pre></td></tr></table></figure><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ svn　update</span><br><span class="line">$ svn　update　-r　修正版本　文件名</span><br><span class="line">$ svn　update　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span></span><br><span class="line">$ svn update </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将版本库中的文件 test.cpp 还原到修正版本（revision）200</span></span><br><span class="line">$ svn update -r 200 test.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新与版本库同步。提交的时候提示过期冲突，需要先 update 修改文件，然后清除svn resolved，最后再提交commit。</span></span><br><span class="line">$ svn update test.php</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ svn　delete　svn://路径(目录或文件的全路径) -m <span class="string">"删除备注信息文本"</span></span><br><span class="line"><span class="comment"># 推荐如下操作：</span></span><br><span class="line">$ svn　delete　文件名 </span><br><span class="line">$ svn　ci　-m　<span class="string">"删除备注信息文本"</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn delete svn://localhost/testapp/test.php -m <span class="string">"删除测试文件test.php"</span></span><br><span class="line"><span class="comment"># 推荐如下操作：</span></span><br><span class="line">$ svn delete test.php </span><br><span class="line">$ svn ci -m <span class="string">"删除测试文件test.php"</span></span><br></pre></td></tr></table></figure><h2 id="加锁-解锁"><a href="#加锁-解锁" class="headerlink" title="加锁 / 解锁"></a>加锁 / 解锁</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svn　lock　-m　<span class="string">"加锁备注信息文本"</span>　[--force]　文件名 </span><br><span class="line">$ svn　unlock　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn lock -m <span class="string">"锁信测试用test.php文件"</span> test.php </span><br><span class="line">$ svn unlock test.php</span><br></pre></td></tr></table></figure><h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ svn　diff　文件名 </span><br><span class="line">$ svn　diff　-r　修正版本号m:修正版本号n　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 将修改的文件与基础版本比较</span></span><br><span class="line">$ svn diff test.php </span><br><span class="line"></span><br><span class="line"><span class="comment"># 对修正版本号200 和 修正版本号201 比较差异</span></span><br><span class="line">$ svn diff -r 200:201 test.php</span><br></pre></td></tr></table></figure><h2 id="查看文件或者目录状态"><a href="#查看文件或者目录状态" class="headerlink" title="查看文件或者目录状态"></a>查看文件或者目录状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ svn st 目录路径/名</span><br><span class="line"><span class="comment"># 目录下的文件和子目录的状态，正常状态不显示.</span></span><br><span class="line"><span class="comment"># 【?：不在svn的控制中；  M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 </span></span><br><span class="line">$ svn status 目录路径/名　　　　　</span><br><span class="line">$ svn -v 目录路径/名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件和子目录状态</span></span><br><span class="line"><span class="comment"># 【第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人】</span></span><br><span class="line">$ svn status -v 目录路径/名</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。</p><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ svn　<span class="built_in">log</span>　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 显示这个文件的所有修改记录，及其版本号的变化</span></span><br><span class="line">$ svn <span class="built_in">log</span> test.php</span><br></pre></td></tr></table></figure><h2 id="查看文件详细信息"><a href="#查看文件详细信息" class="headerlink" title="查看文件详细信息"></a>查看文件详细信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ svn　info　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn info test.php</span><br></pre></td></tr></table></figure><h2 id="SVN-帮助"><a href="#SVN-帮助" class="headerlink" title="SVN 帮助"></a>SVN 帮助</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全部功能选项</span></span><br><span class="line">$ svn　<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 具体功能的说明</span></span><br><span class="line">$ svn　<span class="built_in">help</span>　ci</span><br></pre></td></tr></table></figure><h2 id="查看版本库下的文件和目录列表"><a href="#查看版本库下的文件和目录列表" class="headerlink" title="查看版本库下的文件和目录列表"></a>查看版本库下的文件和目录列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn　list　svn://路径(目录或文件的全路径)</span><br><span class="line">$ svn　ls　svn://路径(目录或文件的全路径)</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn list svn://localhost/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示svn://localhost/test目录下的所有属于版本库的文件和目录</span></span><br><span class="line">$ svn ls svn://localhost/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="创建纳入版本控制下的新目录"><a href="#创建纳入版本控制下的新目录" class="headerlink" title="创建纳入版本控制下的新目录"></a>创建纳入版本控制下的新目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svn　mkdir　目录名</span><br><span class="line">$ svn　mkdir　-m　<span class="string">"新增目录备注文本"</span>　http://目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn mkdir newdir</span><br><span class="line">$ svn mkdir -m <span class="string">"Making a new dir."</span> svn://localhost/<span class="built_in">test</span>/newdir</span><br></pre></td></tr></table></figure><p><strong>注</strong> ： 添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn update</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：如果手工在checkout出来的目录里创建了一个新文件夹newsubdir，</p><p>​     再用svn mkdir newsubdir命令后，SVN会提示：</p><p>​     svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？</p><p>​     svn: 无法创建目录“hello”: 文件已经存在</p><pre><code> 此时，用如下命令解决：svn add --non-recursive newsubdir</code></pre><p>​     在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录</p><p>​     再用 svn mkdir -m “添hello功能模块文件” <span class="exturl" data-url="c3ZuOi8vbG9jYWxob3N0L3Rlc3QvbmV3ZGlyL25ld3N1YmRpcg==" title="svn://localhost/test/newdir/newsubdir">svn://localhost/test/newdir/newsubdir<i class="fa fa-external-link"></i></span> 命令，</p><p>​     SVN提示：</p><p>​     svn: File already exists: filesystem ‘/data/svnroot/test/db’, transaction ‘4541-1’,</p><p>​     path ‘/newdir/newsubdir ‘</p><h2 id="恢复本地修改"><a href="#恢复本地修改" class="headerlink" title="恢复本地修改"></a>恢复本地修改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ svn　revert　[--recursive]　文件名</span><br><span class="line"><span class="comment"># 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 丢弃对一个文件的修改</span></span><br><span class="line">$ svn revert foo.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复一整个目录的文件，. 为当前目录</span></span><br><span class="line">$ svn revert --recursive .</span><br></pre></td></tr></table></figure><h2 id="把工作拷贝更新到别的URL"><a href="#把工作拷贝更新到别的URL" class="headerlink" title="把工作拷贝更新到别的URL"></a>把工作拷贝更新到别的URL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ svn　switch　http://目录全路径　本地目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># (原为123的分支)当前所在目录分支到localhost/test/456</span></span><br><span class="line">$ svn switch http://localhost/<span class="built_in">test</span>/456 .</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ svn　resolved　[本地目录全路径]</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn update</span><br><span class="line">C foo.c</span><br><span class="line">Updated to revision 31.</span><br><span class="line"><span class="comment"># 如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span></span><br><span class="line">$ ls</span><br><span class="line">foo.c</span><br><span class="line">foo.c.mine</span><br><span class="line">foo.c.r30</span><br><span class="line">foo.c.r31</span><br><span class="line"><span class="comment"># 当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span></span><br><span class="line"><span class="comment"># 你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</span></span><br></pre></td></tr></table></figure><h2 id="不checkout而查看输出特定文件或URL的内容"><a href="#不checkout而查看输出特定文件或URL的内容" class="headerlink" title="不checkout而查看输出特定文件或URL的内容"></a>不checkout而查看输出特定文件或URL的内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ svn　cat　http://文件全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn cat http://localhost/<span class="built_in">test</span>/readme.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支copy</span></span><br><span class="line"><span class="comment"># 从branchA拷贝出一个新分支branchB</span></span><br><span class="line">$ svn copy branchA branchB  -m <span class="string">"make B branch"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并内容到分支merge</span></span><br><span class="line"><span class="comment"># 把对branchA的修改合并到分支branchB</span></span><br><span class="line">$ svn merge branchA branchB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;检出&quot;&gt;&lt;a href=&quot;#检出&quot; class=&quot;headerlink&quot; title=&quot;检出&quot;&gt;&lt;/a&gt;检出&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 也可以使用缩写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 例子：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn co http://localhost/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;/testapp --username wzhnsc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="svn" scheme="http://miaopei.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>hexo 使用指南</title>
    <link href="http://miaopei.github.io/2017/03/28/hexo-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://miaopei.github.io/2017/03/28/hexo-使用指南/</id>
    <published>2017-03-28T08:53:46.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装、初始化和配置"><a href="#安装、初始化和配置" class="headerlink" title="安装、初始化和配置"></a>安装、初始化和配置</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>git</li><li>node.js</li><li>github</li></ul><a id="more"></a><h3 id="安装和初始化"><a href="#安装和初始化" class="headerlink" title="安装和初始化"></a>安装和初始化</h3><p>首先确定已经安装好了 <code>nodejs</code> 和 <code>npm</code> 以及 <code>git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAw" title="http://localhost:4000">http://localhost:4000<i class="fa fa-external-link"></i></span>，会看到生成好的博客。</p><h3 id="主目录结构"><a href="#主目录结构" class="headerlink" title="主目录结构"></a>主目录结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-- _config.yml</span><br><span class="line">|-- package.json</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source</span><br><span class="line">   |-- _posts</span><br><span class="line">|-- themes</span><br><span class="line">|-- .gitignore</span><br><span class="line">|-- package.json</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。</p><p><strong>package.json</strong></p><p>hexo框架的参数和所依赖插件，如下：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"3.2.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.10"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>scaffold</strong></p><p>scaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。</p><p><strong>_config.yml文件</strong></p><p>_config.yml 采用YAML语法格式，<span class="exturl" data-url="aHR0cDovL215Lm9zY2hpbmEubmV0L3UvMTg2MTgzNy9ibG9nLzUyNjE0Mj9wPSU3QiU3QnRvdGFsUGFnZSU3RCU3RA==" title="http://my.oschina.net/u/1861837/blog/526142?p=%7B%7BtotalPage%7D%7D">具体语法自行学习<i class="fa fa-external-link"></i></span> 。<br>具体配置可以参考<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbi5odG1s" title="https://hexo.io/zh-cn/docs/configuration.html">官方文档<i class="fa fa-external-link"></i></span>，_config.yml 文件中的内容，并对主要参数做简单的介绍</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span>   <span class="comment">#网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span>     <span class="comment">#网站副标题</span></span><br><span class="line"><span class="attr">description:</span>  <span class="comment">#网站描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span>  <span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span>    <span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span>    <span class="comment">#网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://yoursite.com</span>   <span class="comment">#你的站点Url</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                    <span class="comment">#站点的根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>   <span class="comment">#文章的 永久链接 格式   </span></span><br><span class="line"><span class="attr">permalink_defaults:</span>    <span class="comment">#永久链接中各部分的默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory   </span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span>         <span class="comment">#资源文件夹，这个文件夹用来存放内容</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span>         <span class="comment">#公共文件夹，这个文件夹用于存放生成的站点文件。</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span>              <span class="comment">#标签文件夹     </span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span>      <span class="comment">#归档文件夹</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span>   <span class="comment">#分类文件夹</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span>   <span class="comment">#Include code 文件夹</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span>            <span class="comment">#国际化（i18n）文件夹</span></span><br><span class="line"><span class="attr">skip_render:</span>               <span class="comment">#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>   <span class="comment">#新文章的文件名称</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>       <span class="comment">#预设布局</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span>           <span class="comment">#把标题转换为 title case</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span>        <span class="comment">#在新标签中打开链接</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span>           <span class="comment">#把文件名称转换为 (1) 小写或 (2) 大写</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span>       <span class="comment">#是否显示草稿</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span>   <span class="comment">#是否启动 Asset 文件夹</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span>       <span class="comment">#把链接改为与根目录的相对位址    </span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span>               <span class="comment">#显示未来的文章</span></span><br><span class="line"><span class="attr">highlight:</span>                 <span class="comment">#内容中代码块的设置    </span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span>          <span class="comment">#分类别名</span></span><br><span class="line"><span class="attr">tag_map:</span>               <span class="comment">#标签别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span>         <span class="comment">#日期格式</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span>           <span class="comment">#时间格式    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span>    <span class="comment">#分页数量</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span>   <span class="comment">#主题名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="comment">#  部署部分的设置</span></span><br><span class="line"><span class="attr">deploy:</span>     </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span>  <span class="comment">#类型，常用的git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/nanshanyi/nanshanyi.github.io.git</span> <span class="comment">#github仓库的地址</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>如果页面中出现中文，应以UTF-8无BOM编码格式，所以不要用win自带的记事本，而是用notepad++这种支持编码转换的编辑器。</strong></p><p>由于google在天朝大陆被墙，进入 <code>themes\landscape\layout\_partial</code> ，打开 <code>head.ejs</code> ，删掉第31行 <code>fonts.googleapis.com</code> 的链接。</p><p>下载下来 <code>jQuery-2.0.3.min.js</code> ，放到 <code>themes\landscape\source\js</code> 文件夹中。之后进入 <code>themes\landscape\layout\_partial</code> ，打开 <code>after-footer.ejs</code> ，将第17行的路径替换为 <code>/js/jquery-2.0.3.min.js</code> 。</p><p>至此大功告成。</p><h2 id="写文章-amp-草稿"><a href="#写文章-amp-草稿" class="headerlink" title="写文章&amp;草稿"></a>写文章&amp;草稿</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p>命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post <span class="string">"new article"</span></span><br></pre></td></tr></table></figure><p>之后在 <code>soource/_posts</code> 目录下面多了一个 <code>new-article.md</code> 的文件。</p><h3 id="文章属性"><a href="#文章属性" class="headerlink" title="文章属性"></a>文章属性</h3><table><thead><tr><th>Setting</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>layout</td><td>Layout</td><td>post或page</td></tr><tr><td>title</td><td>文章的标题</td><td></td></tr><tr><td>date</td><td>穿件日期</td><td>文件的创建日期</td></tr><tr><td>updated</td><td>修改日期</td><td>文件的修改日期</td></tr><tr><td>comments</td><td>是否开启评论</td><td>true</td></tr><tr><td>tags</td><td>标签</td><td></td></tr><tr><td>categories</td><td>分类</td><td></td></tr><tr><td>permalink</td><td>url中的名字</td><td>文件名</td></tr><tr><td>toc</td><td>是否开启目录</td><td>true</td></tr><tr><td>reward</td><td>是否开启打赏</td><td>true</td></tr></tbody></table><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - 日记</span><br><span class="line">tags:</span><br><span class="line">  - Hexo</span><br><span class="line">  - node.js</span><br></pre></td></tr></table></figure><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><code>&lt;!--more--&gt;</code> 之上的内容为摘要。</p><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>草稿相当于很多博客都有的“私密文章”功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"new draft"</span></span><br></pre></td></tr></table></figure><p>会在 <code>source/_drafts</code> 目录下生成一个 <code>new-draft.md</code> 文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到 <code>_drafts</code> 目录之中。</p><p>如果你希望强行预览草稿，更改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render_drafts: true</span><br></pre></td></tr></table></figure><p>或者，如下方式启动server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server --drafts</span><br></pre></td></tr></table></figure><p>下面这条命令可以把草稿变成文章，或者页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">$ hexo publish drafts hexo-使用指南</span><br></pre></td></tr></table></figure><h2 id="Blog中出入图片和音乐"><a href="#Blog中出入图片和音乐" class="headerlink" title="Blog中出入图片和音乐"></a>Blog中出入图片和音乐</h2><p>文章推介：<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzUzZTBkMmE2MTdkYQ==" title="http://www.jianshu.com/p/53e0d2a617da">Hexo 博客中插入音乐/视频<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cDovL2Jsb2cuc2hpcWljaGFuLmNvbS91c2UtcWluaXUtc3RvcmUtaW1hZ2UtZm9yLWhleG8v" title="http://blog.shiqichan.com/use-qiniu-store-image-for-hexo/">使用七牛为Hexo存储图片<i class="fa fa-external-link"></i></span></p><pre><code>[hexo主题中添加相册功能](http://www.cnblogs.com/xljzlw/p/5137622.html)</code></pre><p>​           <span class="exturl" data-url="aHR0cDovL3d1Y2hvbmcubWUvYmxvZy8yMDE0LzEyLzEzL2hleG8tdGhlbWUtY3JlYXRpbmctaW1hZ2Utc3R5bGVzLz91dG1fc291cmNlPXR1aWNvb2wmdXRtX21lZGl1bT1yZWZlcnJhbCM=" title="http://wuchong.me/blog/2014/12/13/hexo-theme-creating-image-styles/?utm_source=tuicool&utm_medium=referral#">为 Hexo 主题添加多种图片样式(主题不错考虑移植)<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzg2MDc=" title="https://yq.aliyun.com/articles/8607">Hexo折腾记——基本配置篇<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qYXJzb24tNzQyNi9wLzU1MTU4NzAuaHRtbA==" title="http://www.cnblogs.com/jarson-7426/p/5515870.html">hexo博客进阶－相册和独立域名<i class="fa fa-external-link"></i></span></p><p>插入图片基本分为两种办法** ：</p><p>（1） 放在本地文件</p><p>首先在根目录下确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。<br>在 hexo 目录，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>之后再使用 <code>hexo new &#39;new&#39;</code>创建新博客的时候，会在 <code>source/_posts</code> 里面创建 <code>.md</code> 文件的同时生成一个相同的名字的文件夹。把该文章中需要使用的图片放在该文件夹下即可。<br>使用的时候</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">“图片描述”（可以不写）</span>](<span class="link">/文件夹名/你的图片名字.JPG</span>)</span><br><span class="line">例如：</span><br><span class="line">！[ ] (new/text.jpg)</span><br></pre></td></tr></table></figure><p>（2）放在<span class="exturl" data-url="aHR0cHM6Ly9wb3J0YWwucWluaXUuY29tL3NpZ251cD9jb2RlPTNsZ2xhczZwZ2kycWE=" title="https://portal.qiniu.com/signup?code=3lglas6pgi2qa">七牛<i class="fa fa-external-link"></i></span>上，需要先注册，上传图片生成链接，直接在文章中使用链接即可。</p><p><strong>插入音乐</strong> ：</p><p>可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器；复制代码，直接粘贴到博文中即可。这样会显示一个网易的播放器，可以把</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">298</span> <span class="attr">height</span>=<span class="string">52</span> <span class="attr">src</span>=<span class="string">"http://music.163.com/outchain/player?type=2&amp;id=32192436&amp;auto=1&amp;height=32"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">//其中的width=298 height=52 均改为0就看不到了，依然可以播放音乐</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/Y60twn8.png" alt></p><p><img src="http://i.imgur.com/i42cvBI.png" alt></p><h2 id="代码高亮highlight-js支持"><a href="#代码高亮highlight-js支持" class="headerlink" title="代码高亮highlight.js支持"></a>代码高亮highlight.js支持</h2><p><span class="exturl" data-url="aHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcv" title="https://highlightjs.org/">highlightjs官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvc3RhdGljL2RlbW8v" title="https://highlightjs.org/static/demo/">highlightjs主题风格<i class="fa fa-external-link"></i></span></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy55ZWhiZWF0cy5jb20vMjAxNS8wNC8wOC9oZXhvLXNlYXJjaC8=" title="http://www.yehbeats.com/2015/04/08/hexo-search/">Hexo，Yilia主题添加站内搜索功能<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2t1YW5ncWkubWUvdHJpY2tzL2VuYWJsZS10YWJsZS1vZi1jb250ZW50cy1vbi1oZXhvLw==" title="http://kuangqi.me/tricks/enable-table-of-contents-on-hexo/">为Hexo博客添加目录<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9hcnRpY2xlLzE5OTYyNA==" title="http://www.ituring.com.cn/article/199624">Hexo站点中添加文章目录以及归档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2NyZXNjZW50bW9vbi5pbmZvLzIwMTQvMTIvMTEvcG9wdWxhci13aWRnZXQv" title="http://crescentmoon.info/2014/12/11/popular-widget/">使用LeanCloud平台为Hexo博客添加文章浏览量统计组件<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy50dWljb29sLmNvbS9hcnRpY2xlcy9BQkZuMnFV" title="http://www.tuicool.com/articles/ABFn2qU">使用hexo搭建静态博客<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9hcnRpY2xlLzE5OTAzNT91dG1fc291cmNlPXR1aWNvb2wmdXRtX21lZGl1bT1yZWZlcnJhbA==" title="http://www.ituring.com.cn/article/199035?utm_source=tuicool&utm_medium=referral">Hexo Docs中文 ： （二）基本用法<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装、初始化和配置&quot;&gt;&lt;a href=&quot;#安装、初始化和配置&quot; class=&quot;headerlink&quot; title=&quot;安装、初始化和配置&quot;&gt;&lt;/a&gt;安装、初始化和配置&lt;/h2&gt;&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;node.js&lt;/li&gt;
&lt;li&gt;github&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://miaopei.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>nodejs+webpack+vuejs 搭建开发环境学习套路</title>
    <link href="http://miaopei.github.io/2017/03/27/nodejs-webpack-vuejs-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AD%A6%E4%B9%A0%E5%A5%97%E8%B7%AF/"/>
    <id>http://miaopei.github.io/2017/03/27/nodejs-webpack-vuejs-搭建开发环境学习套路/</id>
    <published>2017-03-27T10:02:52.000Z</published>
    <updated>2017-03-28T10:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><span class="exturl" data-url="aHR0cDovL3Z1ZWpzLm9yZy92Mi9ndWlkZS8=" title="http://vuejs.org/v2/guide/">官方手册<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv" title="https://cn.vuejs.org/">中文官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly92dWVmZS5jbi92Mi9ndWlkZS8=" title="https://vuefe.cn/v2/guide/">vuejs 2.0 中文文档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=" title="http://es6.ruanyifeng.com/">ECMAScript 6 入门<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Nub2RlanMub3JnL3RvcGljLzUyOGM5YTM4ZDJiMzg5M2YyYWJiNmVlYg==" title="http://cnodejs.org/topic/528c9a38d2b3893f2abb6eeb">node.js相关的中文文档及教程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkv" title="http://nodejs.cn/api/">Node.js中文网API<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3dlYnBhY2tkb2MuY29tLw==" title="http://webpackdoc.com/">Webpack 中文指南<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3dlYnBhY2syLw==" title="http://www.css88.com/doc/webpack2/">webpack2.2中文文档<i class="fa fa-external-link"></i></span></p><p>以上是提供的一些官方资料，下面开始我们的套路吧：</p><a id="more"></a><h3 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建"></a>环境构建</h3><p>1.新建一个目录<code>vuepro</code><br>2.初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vuepro</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化的时候可以一路回车，在最后输入"yes"后会生成package.json文件</span></span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>3.安装模块，先装这么多，有需要再安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install vue webpack babel-loader babel-core babel-preset-env babel-cli babel-preset-es2015 html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>4.创建良好的目录层级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir src</span><br><span class="line">$ <span class="built_in">cd</span> src &amp;&amp; mkdir -p html jssrc webapp</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/qkj7kJd.png" alt>    </p><p><code>html</code>放置模板文件，<code>jssrc</code>放置js文件，最终编译好的文件放置在<code>webapp</code>目录里，这个目录也就是我们网站的目录。</p><p>5.在项目根目录下创建webpack配置文件：<code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack=<span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports =</span><br><span class="line">&#123;</span><br><span class="line">    entry:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//入口文件</span></span><br><span class="line">        <span class="string">"index"</span>:__dirname+<span class="string">'/src/jssrc/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname+<span class="string">'/src/webapp/js'</span>,  <span class="comment">//输出文件夹</span></span><br><span class="line">        filename:<span class="string">'[name].js'</span>   <span class="comment">//最终打包生成的文件名(只是文件名，不带路径的哦)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*resolve: &#123;</span></span><br><span class="line"><span class="comment">        alias: &#123;</span></span><br><span class="line"><span class="comment">            vue: 'vue/dist/vue.js'</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;,*/</span></span><br><span class="line">    externals: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,<span class="attr">loader</span>:<span class="string">"babel-loader"</span>,<span class="attr">query</span>:&#123;<span class="attr">compact</span>:<span class="literal">true</span>&#125;&#125;,</span><br><span class="line">            <span class="comment">//这里肯定要加入n个loader 譬如vue-loader、babel-loader、css-loader等等</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            filename: __dirname+<span class="string">'/src/webapp/index.html'</span>,   <span class="comment">//目标文件</span></span><br><span class="line">            template: __dirname+<span class="string">'/src/html/index.html'</span>, <span class="comment">//模板文件</span></span><br><span class="line">            inject:<span class="string">'body'</span>,</span><br><span class="line">            hash:<span class="literal">true</span>,  <span class="comment">//代表js文件后面会跟一个随机字符串,解决缓存问题</span></span><br><span class="line">            chunks:[<span class="string">"index"</span>]</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.同样在根目录下创建babel配置文件：<code>.babelrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot; : [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在webpack里面配置loader，我们上面webpack配置中已经写了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loaders:[</span><br><span class="line">           &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,<span class="attr">loader</span>:<span class="string">"babel-loader"</span>,<span class="attr">query</span>:&#123;<span class="attr">compact</span>:<span class="literal">true</span>&#125;&#125;,</span><br><span class="line">  <span class="comment">// 经过测试旧版用的是loader:"babel",在新版中用的是loader:"babel-loader"</span></span><br><span class="line">       ]</span><br></pre></td></tr></table></figure><p>这句话意思就是：凡是 <code>.js</code> 文件都使用 <code>babel-loader</code> , 并且压缩。</p><h3 id="学习vue最简单的一个套路"><a href="#学习vue最简单的一个套路" class="headerlink" title="学习vue最简单的一个套路"></a>学习vue最简单的一个套路</h3><p>思考：数据如何渲染？</p><p>套路如下：</p><p>首先要有个数据块标记</p><p>vue里面可以像模板引擎一样写上 <code>{\{name\}}</code></p><p>其中 <code>name</code> 就是变量名</p><h3 id="接下来进行实战练习"><a href="#接下来进行实战练习" class="headerlink" title="接下来进行实战练习"></a>接下来进行实战练习</h3><p><img src="http://i.imgur.com/UhW18FI.png" alt>    </p><p>index.htm l如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"me"</span>&gt;</span></span><br><span class="line">        我的年龄是&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index.js 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>; <span class="comment">//会去node_modules\vue\package.json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#me"</span>,</span><br><span class="line">    data:&#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此，我们需要用 <code>webpack</code> 打包，打包到 <code>webapp</code> 目录下。 </p><p>需要修改2个地方： </p><p>(1)因为我们的 <code>webpack</code> 不是全局安装的，所以不能直接执行 <code>webpack</code> 命令，我们这里借助 <code>npm</code> 来执行。所以需要修改项目根目录下的 <code>package.json</code> 文件，加入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">  "build": "webpack"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>表示：执行build，就会去node_modules.bin\下去寻找webpack命令。<code>build</code> 这个名字是自定义的。</p><p>(2)还需要修改 webpack 配置文件：<code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            vue: <span class="string">'vue/dist/vue.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>我们之前把这个注释掉了，现在打开。此处的意义是找到 <code>node_modules/vue/dist/vue.js</code></p><p>最后，我们就来打包，看看结果是怎样的？ </p><p>终端里还是cd到项目根目录下，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/wmjrYdu.png" alt>    </p><p><code>index.html</code>  就是打包之后的模板文件，<code>js/index.js</code> 就是打包之后的js文件，在 <code>index.html</code> 被引用了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"me"</span>&gt;</span></span><br><span class="line">        我的年龄是&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/index.js?43c73980e35f1569ef72"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预览一下index.html: </p><p><img src="http://i.imgur.com/6kHwB4L.png" alt></p><p>这样就完成了 <code>vueJS</code> 的一个简单案列</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3Z1ZWpzLm9yZy92Mi9ndWlkZS8=&quot; title=&quot;http://vuejs.org/v2/guide/&quot;&gt;官方手册&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jbi52dWVqcy5vcmcv&quot; title=&quot;https://cn.vuejs.org/&quot;&gt;中文官网&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly92dWVmZS5jbi92Mi9ndWlkZS8=&quot; title=&quot;https://vuefe.cn/v2/guide/&quot;&gt;vuejs 2.0 中文文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=&quot; title=&quot;http://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Nub2RlanMub3JnL3RvcGljLzUyOGM5YTM4ZDJiMzg5M2YyYWJiNmVlYg==&quot; title=&quot;http://cnodejs.org/topic/528c9a38d2b3893f2abb6eeb&quot;&gt;node.js相关的中文文档及教程&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL25vZGVqcy5jbi9hcGkv&quot; title=&quot;http://nodejs.cn/api/&quot;&gt;Node.js中文网API&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3dlYnBhY2tkb2MuY29tLw==&quot; title=&quot;http://webpackdoc.com/&quot;&gt;Webpack 中文指南&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3dlYnBhY2syLw==&quot; title=&quot;http://www.css88.com/doc/webpack2/&quot;&gt;webpack2.2中文文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上是提供的一些官方资料，下面开始我们的套路吧：&lt;/p&gt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://miaopei.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github 博客多终端同步</title>
    <link href="http://miaopei.github.io/2017/03/20/Hexo-Github-%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/"/>
    <id>http://miaopei.github.io/2017/03/20/Hexo-Github-博客多终端同步/</id>
    <published>2017-03-19T20:20:57.000Z</published>
    <updated>2019-06-05T04:03:57.392Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9ua2V5X0xaTC9hcnRpY2xlL2RldGFpbHMvNjA4NzA4OTE=" title="http://blog.csdn.net/Monkey_LZL/article/details/60870891">原文链接<i class="fa fa-external-link"></i></span></p><p>主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解：</p><a id="more"></a><h2 id="1-准备条件"><a href="#1-准备条件" class="headerlink" title="1. 准备条件"></a>1. 准备条件</h2><p>安装了Node.js,Git,Hexo环境<br>完成Github与本地Hexo的对接<br>这部分大家可以参考<span class="exturl" data-url="aHR0cHM6Ly94dWFud28ub3JnLzIwMTUvMDMvMjYvaGV4by1pbnRvci8=" title="https://xuanwo.org/2015/03/26/hexo-intor/">史上最详细的Hexo博客搭建图文教程<i class="fa fa-external-link"></i></span></p><p>配置好这些，就可以捋起袖子大干一场了！</p><h2 id="2-在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上"><a href="#2-在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上" class="headerlink" title="2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上"></a>2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上</h2><p>在利用Github+Hexo搭建自己的博客时，新建了一个Hexo的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到Github项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件</span></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line">$ git commit -m <span class="string">"Blog Source Hexo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建hexo分支</span></span><br><span class="line">$ git branch hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到hexo分支上</span></span><br><span class="line">$ git checkout hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地与Github项目对接</span></span><br><span class="line">$ git remote add origin https://github.com/yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># push到Github项目的hexo分支上</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure><p>这样你的github项目中就会多出一个Hexo分支，这个就是用于多终端同步关键的部分。</p><h2 id="3-另一终端完成clone和push更新"><a href="#3-另一终端完成clone和push更新" class="headerlink" title="3. 另一终端完成clone和push更新"></a>3. 另一终端完成clone和push更新</h2><p>此时在另一终端更新博客，只需要将Github的hexo分支clone下来，进行初次的相关配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将Github中hexo分支clone到本地</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b hexo https://github.com/yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到刚刚clone的文件夹内</span></span><br><span class="line">$ <span class="built_in">cd</span> yourname.github.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># cheackout 远程代码到本地hexo分支</span></span><br><span class="line">$ git checkout -b hexo origin/hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init</span></span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个.md文件，并编辑完成自己的博客内容</span></span><br><span class="line">$ hexo new post <span class="string">"new blog name"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客</span></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line">$ git commit -m <span class="string">"XX"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新分支</span></span><br><span class="line">$ git push origin hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master</span></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><h2 id="4-不同终端间愉快地玩耍"><a href="#4-不同终端间愉快地玩耍" class="headerlink" title="4. 不同终端间愉快地玩耍"></a>4. 不同终端间愉快地玩耍</h2><p>在不同的终端已经做完配置，就可以愉快的分享自己更新的博客<br>进入自己相应的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先pull完成本地与远端的融合</span></span><br><span class="line">$ git pull origin hexo</span><br><span class="line"></span><br><span class="line">$ hexo new post <span class="string">" new blog name"</span></span><br><span class="line"></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"XX"</span></span><br><span class="line"></span><br><span class="line">$ git push origin hexo</span><br><span class="line"></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9ua2V5X0xaTC9hcnRpY2xlL2RldGFpbHMvNjA4NzA4OTE=&quot; title=&quot;http://blog.csdn.net/Monkey_LZL/article/details/60870891&quot;&gt;原文链接&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解：&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://miaopei.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>常用Git命令清单</title>
    <link href="http://miaopei.github.io/2017/01/27/git-common-list/"/>
    <id>http://miaopei.github.io/2017/01/27/git-common-list/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-07-02T09:33:42.589Z</updated>
    
    <content type="html"><![CDATA[<p>我每天使用 Git ，但是很多命令记不住。</p><p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p><a id="more"></a><p><img src="http://i.imgur.com/zYeQxr4.png" alt></p><p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><pre><code># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><pre><code># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><pre><code># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><pre><code># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><pre><code># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><pre><code># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]</code></pre><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><pre><code># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><pre><code># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><pre><code># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop</code></pre><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><pre><code># 生成一个可供发布的压缩包$ git archive</code></pre>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git使用规范流程</title>
    <link href="http://miaopei.github.io/2017/01/27/git-using-standard-process/"/>
    <id>http://miaopei.github.io/2017/01/27/git-using-standard-process/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-07-02T09:33:51.493Z</updated>
    
    <content type="html"><![CDATA[<p>团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。</p><p>否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。</p><p>下面是ThoughtBot 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。</p><a id="more"></a><p><img src="http://i.imgur.com/WjTakfD.png" alt></p><h2 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h2><p>首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考《Git分支管理策略》）。</p><pre><code># 获取主干最新代码$ git checkout master$ git pull# 新建一个开发分支myfeature$ git checkout -b myfeature</code></pre><h2 id="第二步：提交分支commit"><a href="#第二步：提交分支commit" class="headerlink" title="第二步：提交分支commit"></a>第二步：提交分支commit</h2><p>分支修改后，就可以提交commit了。</p><pre><code>$ git add --all$ git status$ git commit --verbose</code></pre><p><code>git add</code> 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。</p><p><code>git status</code> 命令，用来查看发生变动的文件。</p><p><code>git commit</code> 命令的 <code>verbose</code> 参数，会列出 diff 的结果。</p><h2 id="第三步：撰写提交信息"><a href="#第三步：撰写提交信息" class="headerlink" title="第三步：撰写提交信息"></a>第三步：撰写提交信息</h2><p>提交commit时，必须给出完整扼要的提交信息，下面是一个范本。</p><pre><code>Present-tense summary under 50 characters* More information about commit (under 72 characters).* More information about commit (under 72 characters).http://project.management-system.com/ticket/123</code></pre><p>第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。</p><h2 id="第四步：与主干同步"><a href="#第四步：与主干同步" class="headerlink" title="第四步：与主干同步"></a>第四步：与主干同步</h2><p>分支的开发过程中，要经常与主干保持同步。</p><pre><code>$ git fetch origin$ git rebase origin/master</code></pre><h2 id="第五步：合并commit"><a href="#第五步：合并commit" class="headerlink" title="第五步：合并commit"></a>第五步：合并commit</h2><p>分支开发完成后，很可能有一堆 <code>commit</code>，但是合并到主干的时候，往往希望只有一个（或最多两三个）<code>commit</code>，这样不仅清晰，也容易管理。</p><p>那么，怎样才能将多个 <code>commit</code> 合并呢？这就要用到 <code>git rebase</code> 命令。</p><pre><code>$ git rebase -i origin/master</code></pre><p><code>git rebase</code> 命令的 <code>i</code> 参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usagepick de9b1eb Fix PostChecker::Post#urlspick 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend# Rebase 8db7e8b..fa20af3 onto 8db7e8b## Commands:#  p, pick = use commit#  r, reword = use commit, but edit the commit message#  e, edit = use commit, but stop for amending#  s, squash = use commit, but meld into previous commit#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message#  x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out</code></pre><p>上面的互动界面，先列出当前分支最新的4个 <code>commit</code>（越下面越新）。每个 <code>commit</code> 前面有一个操作命令，默认是 <code>pick</code>，表示该行 <code>commit</code> 被选中，要进行 <code>rebase</code> 操作。</p><p>4个commit的下面是一大堆注释，列出可以使用的命令。</p><ul><li>pick：正常选中</li><li>reword：选中，并且修改提交信息；</li><li>edit：选中，rebase时会暂停，允许你修改这个commit（参考这里）</li><li>squash：选中，会将当前commit与上一个commit合并</li><li>fixup：与squash相同，但不会保存当前commit的提交信息</li><li>exec：执行其他shell命令</li></ul><p>上面这6个命令当中，<code>squash</code> 和 <code>fixup</code> 可以用来合并 <code>commit</code>。先把需要合并的 <code>commit</code> 前面的动词，改成 <code>squash</code>（或者s）。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlss 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend</code></pre><p>这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。</p><pre><code># This is a combination of 3 commits.# The first commit&apos;s message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:Hey kids, stop all the highlighting</code></pre><p>如果将第三行的 <code>squash</code> 命令改成 <code>fixup</code> 命令。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlsf 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend</code></pre><p>运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。</p><pre><code># This is a combination of 3 commits.# The first commit&apos;s message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:# Hey kids, stop all the highlighting</code></pre><p>Pony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。</p><pre><code>$ git reset HEAD~5$ git add .$ git commit -am &quot;Here&apos;s the bug fix that closes #28&quot;$ git push --force</code></pre><p><code>squash</code> 和 <code>fixup</code> 命令，还可以当作命令行参数使用，自动合并commit。</p><pre><code>$ git commit --fixup  $ git rebase -i --autosquash </code></pre><p>这个用法请参考<span class="exturl" data-url="aHR0cDovL2ZsZS5naXRodWIuaW8vZ2l0LXRpcC1rZWVwLXlvdXItYnJhbmNoLWNsZWFuLXdpdGgtZml4dXAtYW5kLWF1dG9zcXVhc2guaHRtbA==" title="http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html">http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html<i class="fa fa-external-link"></i></span>，这里就不解释了。</p><h2 id="第六步：推送到远程仓库"><a href="#第六步：推送到远程仓库" class="headerlink" title="第六步：推送到远程仓库"></a>第六步：推送到远程仓库</h2><p>合并commit后，就可以推送当前分支到远程仓库了。</p><pre><code>$ git push --force origin myfeature</code></pre><p><code>git push</code> 命令要加上 <code>force</code> 参数，因为 <code>rebase</code> 以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送。</p><h2 id="第七步：发出Pull-Request"><a href="#第七步：发出Pull-Request" class="headerlink" title="第七步：发出Pull Request"></a>第七步：发出Pull Request</h2><p>提交到远程仓库以后，就可以发出 <code>Pull Request</code> 到 <code>master</code> 分支，然后请求别人进行代码 <code>review</code>，确认可以合并到 <code>master</code>。</p>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="http://miaopei.github.io/2016/12/23/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://miaopei.github.io/2016/12/23/Docker-学习笔记/</id>
    <published>2016-12-23T02:14:50.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h1><h3 id="常用Docker命令"><a href="#常用Docker命令" class="headerlink" title="常用Docker命令"></a>常用Docker命令</h3><hr><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启Docker守护进程调试模式</span></span><br><span class="line">$ sudo docker daemon -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Docker信息</span></span><br><span class="line">$ sudo docker info </span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止或者启动Docker</span></span><br><span class="line">$ sudo service docker stop/start </span><br><span class="line"></span><br><span class="line"><span class="comment"># 以命令行模式运行一个容器</span></span><br><span class="line">$ sudo docker run -i -t ubuntu /bin/bash </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给容器命名</span></span><br><span class="line">$ sudo docker run --name Micheal_container -i -t ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动或者停止运行的容器</span></span><br><span class="line">$ sudo docker start/stop Micheal_container </span><br><span class="line"></span><br><span class="line"><span class="comment"># 附着到正在运行的容器</span></span><br><span class="line">$ sudo docker attach Micheal_container</span><br></pre></td></tr></table></figure><p><strong>创建守护式容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的docker run 使用了<code>-d</code>参数，因此Docker会将容器放到后台运行。</p></blockquote><p><strong>Docker日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取守护式容器的日志</span></span><br><span class="line">$ sudo docker logs daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪守护式容器的日志</span></span><br><span class="line">$ sudo docker logs -f daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取日志的最后10行</span></span><br><span class="line">$ sudo docker logs --tail 10 daemon_dave </span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪某个容器的最新日志</span></span><br><span class="line">$ sudo docker logs --tail 0 -f daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># -t 标志为每条日志项加上时间戳</span></span><br><span class="line">$ sudo docker logs -ft daemon_dave</span><br></pre></td></tr></table></figure><p><strong>Docker日志驱动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --<span class="built_in">log</span>-driver=<span class="string">"syslog"</span> --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p>使用syslog将会禁用docker logs命令，并且将所有容器的日志输出都重定向到Syslog。</p></blockquote><p><strong>查看容器内的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker top daemon_dave</span><br></pre></td></tr></table></figure><p><strong>Docker统计信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker stats daemon_dave daemon_kate daemon_clear daemon_sarah</span><br></pre></td></tr></table></figure><blockquote><p>以上命令可以看到一个守护容器的列表，以及他们的CPU、内存、网络I/O以及存储I/O的性能和指标。这对快速监控一台主机上的一组容器非常有用。</p></blockquote><p><strong>在容器内部运行进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -d daemon_dave touch /etc/new_config_file</span><br></pre></td></tr></table></figure><blockquote><p><code>-d</code>表示需要运行一个后台进程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内运行交互命令</span></span><br><span class="line">$ sudo docker <span class="built_in">exec</span> -t -i daemon_dave /bin/bash</span><br></pre></td></tr></table></figure><p><strong>自动重启容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --restart=always --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p><code>--restart</code>标志被设置为always。无论容器的退出代码是什么，Docker都会自动重启改容器。除了always，还可以将这个标志设为<code>on-failure</code>，这样，只有当容器的退出代码为非0值的时候，才会自动重启。另外，on-failure还接受一个可选的重启次数参数，<code>--restart=on-failure:5</code>,Docker会尝试自动重启改容器，最多重启5次。</p></blockquote><p><strong>深入容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect daemon_dave</span><br></pre></td></tr></table></figure><blockquote><p>docker inspect命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置以及很多有用的数据。可以使用<code>-f</code>或者<code>--format</code>标志来选定查看结果。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format=<span class="string">'&#123;.State.Running&#125;'</span> daemon_dave</span><br></pre></td></tr></table></figure><blockquote><p>查看多个容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format <span class="string">'&#123;.Name&#125; &#123;.State.Running&#125;'</span> daemon_dave Micheal_container</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong><br>​    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker rm daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line">$ sudo docker rm `sudo docker ps -a -q`</span><br></pre></td></tr></table></figure><p><strong>列出所有镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br></pre></td></tr></table></figure><p><strong>拉去镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure><p><strong>运行一个带标签的Docker镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t --name new_container ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure><p><strong>查找镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker search puppet</span><br></pre></td></tr></table></figure><p><strong>构建镜像</strong></p><ul><li>使用<code>docker commit</code>命令</li><li>使用<code>docker build</code>命令和<code>Dockerfile</code>文件</li></ul><p><strong>用Docker的commit命令创建镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来安装需要安装的工具，安装完成后exit退出容器, eg：</span></span><br><span class="line">$ apt-get -yqq update</span><br><span class="line">$ apt-get -y install apache2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定提交修改过的容器的ID（可以通过docker ps -l -q命令得到刚创建的容器的ID）</span></span><br><span class="line">$ sudo docker commit 4aab3cecb76 micheal/apache2  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查新创建的镜像</span></span><br><span class="line">sudo docker images micheal/apache2  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交另一个新定制容器</span></span><br><span class="line"><span class="comment"># -m 选项用来指定新创建的镜像的提交信息，-a 用来列出该镜像的作者信息。</span></span><br><span class="line">$ sudo docker commit -m<span class="string">"A new custom image"</span> -a<span class="string">"Micheal"</span> 4aab3cecb76 micheal/apache2:webserver</span><br></pre></td></tr></table></figure><p><strong>用Dockerfile构建镜像</strong></p><p>Dockerfile文件示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Vsersion: 0.0.1</span></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER Micheal "miaopei@baicells.com"</span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get -y install nginx</span><br><span class="line">RUN echo 'Hi, I an in your container' &gt; /usr/share/nginx/html/index.html</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><blockquote><p>Dockerfile中的指令会按照顺序从上到下执行，所以根据需要合理安排指令的顺序。</p><p>如果Dockerfile由于某些原因没有正常结束，那么用户得到了一个可以使用的镜像。这对调试非常有帮助：可以基于改镜像运行一个具备交互功能的容器，使用最后创建的镜像对为什么用户指令会失败进行调试。</p><p><strong>每个Dockerfile的第一条指令必须是FROM</strong>,FROM指令指定一个已经存在的镜像，后续指令都将基于该镜像进行，这个镜像被称为基础镜像。</p><p>MAINTAINER指令告诉Docker镜像的作者是谁，以及作者的电子邮件。有助于标识镜像的所有者和联系方式。</p></blockquote><blockquote><p>默认情况下，RUN指令会在shell里使用命令包装器<code>/bin/sh -c</code>来执行，如果是在一个不支持shell的平台上运行或者不希望在shell中运行（比如避免shell字符串篡改），也可以使用<code>exec</code>格式的RUN指令，如下所示：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ "apt-get", " install", "-y", "nginx" ]</span><br></pre></td></tr></table></figure><blockquote><p>EXPOSE指令告诉Docker该容器内的应用程序将会使用该容器的指定端口。</p></blockquote><p><strong>基于Dockerfile构建新镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web"</span> .</span><br><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web:v1"</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里Docker假设在这个Git仓库的根目录下存在Dockerfile文件</span></span><br><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web:v1"</span> git@github.com:micheal/docker_static_web  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略Dockerfile的构建缓存</span></span><br><span class="line">$ sudo docker build --no-cache -t=<span class="string">"micheal/static_web"</span> .</span><br></pre></td></tr></table></figure><p><strong>查看镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出Docker镜像</span></span><br><span class="line">$ sudo docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像每一层，以及创建这些层的Dockerfile指令</span></span><br><span class="line">$ sudo docker <span class="built_in">history</span> micheal/static_web </span><br><span class="line"></span><br><span class="line">$ sudo docker run -d -p 80 --name statix_web micheal/static_web nginx -g <span class="string">"daemon off;"</span></span><br></pre></td></tr></table></figure><blockquote><p>nginx -g “daemon off;”,这将以前台的方式启动Nginx。</p><p><code>-p</code>标志用来控制Docker在运行时应该公开那些网络端口给外部（宿主机）。运行一个容器时，Docker可以通过两种方式来在宿主机上分配端口。</p><ul><li>Docker可以在宿主机上随机选择一个位于32768 ~ 61000的一个比较大的端口号来映射到容器中的80端口上。</li><li>可以在Docker宿主机只指定一个具体的端口号来映射到容器中的80端口上。</li></ul></blockquote><p><strong>查看Docker端口映射情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回宿主机中映射的端口</span></span><br><span class="line">$ sudo socker port static_web 80 </span><br><span class="line"></span><br><span class="line"><span class="comment"># -p会将容器内的80端口绑定到宿主机的8080端口上</span></span><br><span class="line">$ sudo docker run -d -p 8080:80 --name statix_web micheal/static_web nginx -g <span class="string">"daemon off;"</span></span><br></pre></td></tr></table></figure><p><strong>Dockerfile指令</strong></p><ol><li>CMD</li></ol><blockquote><p>CMD指令用于指定一个容器启动时要运行的命令。这有点儿类似于RUN指令，只是RUN指令是指定容器镜像被构建时要运行的命令，而CMD是指定容器被启动时要运行的命令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash/"</span>, <span class="string">"-l"</span>]</span><br></pre></td></tr></table></figure><ol><li>ENTRYPOINT</li></ol><blockquote><p>ENTRYPOINT和CMD指令非常类似，我们可在docker run命令行中覆盖CMD指令，而ENTRYPOINT指令提供的命令则不容易在启动容器的时候被覆盖。</p><p>可以组合使用ENTRYPOINT和CMD指令来完成一些巧妙的工作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">"/usr/sbin/nginx"</span>]</span><br><span class="line">CMD [<span class="string">"-h"</span>]</span><br></pre></td></tr></table></figure><ol><li>WORKDIR</li></ol><blockquote><p>WORKDIR指令用来在从镜像创建一个新容器时，在容器内部设置一个工作目录，ENTRYPOINT和/或CMD指定的程序会在这个目录下执行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /opt/webapp/db</span><br><span class="line">RUN bundle install</span><br><span class="line">WORKDIR /opt/webapp</span><br><span class="line">ENTRYPOINT [<span class="string">"rackup"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>-w</code>标志在运行时覆盖工作目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -ti -w /var/<span class="built_in">log</span> ubuntu <span class="built_in">pwd</span>/var/<span class="built_in">log</span></span><br></pre></td></tr></table></figure><ol><li>ENV</li></ol><blockquote><p>ENV指令用来在镜像构建过程中设置环境变量。这些变量会持久保存到从我们镜像创建的任何容器中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV RVM_PATH /home/rvm</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用docker run命令行的<code>-e</code>标志来传递环境变量。这些环境变量只会在运行时有效。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -ti -e <span class="string">"WEB_PORT=8080"</span> ubuntu env</span><br></pre></td></tr></table></figure><ol><li>USER</li></ol><blockquote><p>USER指令用来指定该镜像会以什么样的用户身份来运行。我们可以指定用户名或者UID以及组或GID，甚至是两者的组合。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure><blockquote><p>也可以在docker run命令行中通过<code>-u</code>标志覆盖该指令指定的值。</p></blockquote><ol><li>VOLUME</li></ol><blockquote><p>VOLUME指令用来向基于镜像创建的容器添加卷。一个卷可以存在于一个或者多个容器内特定的目录，这个目录可以绕过联合文件系统，并提供如下共享数据或者对数据进行持久化的功能。</p><ul><li>卷可以在容器间共享和重用</li><li>一个容器可以不是必须和其他容器共享卷</li><li>对卷的修改是立即生效的</li><li>对卷的修改不会对更新镜像产生影响</li><li>卷会一直存在直到没有任何容器再使用它</li></ul><p>卷功能让我们可以将数据（如源代码）、数据库或者其他内容添加到镜像中而不是将这些内容提交到镜像中，并且允许我们在多个容器间共享这些内容，我们可以利用此功能来测试容器和内部应用程序代码，管理日志，或者处理容器内部的数据库。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/opt/project"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>这条指令将会基于此镜像的任何容器创建一个名为/opt/project的挂载点。</p><p>也可以通过指定数组的方式指定多个卷</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/opt/project"</span>, <span class="string">"/data"</span>]</span><br></pre></td></tr></table></figure><ol><li>ADD</li></ol><blockquote><p>ADD指令用来将构建环境下的文件和目录复制到镜像中。不能对构建目录或者上下文之外的文件进行ADD操作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD software.lic /opt/application/software.lic</span><br><span class="line">ADD latest.tar.gz /var/www/wordpress/   //这条指令会将归档文件解开到指定的目录下</span><br></pre></td></tr></table></figure><ol><li>COPY</li></ol><blockquote><p>COPY指令非常类似ADD，它们根本不同是COPY只关心构建上下文中复制本地文件，而不会去做文件提取（extraction）和解压（decompression）的工作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY conf.d/ /etc/apache2/</span><br></pre></td></tr></table></figure><ol><li>LABEL</li></ol><blockquote><p>LABEL指令用于为Docker镜像添加元数据。元数据以键值对的形式展现</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=<span class="string">"1.0"</span></span><br><span class="line">LABEL location=<span class="string">"New York"</span> <span class="built_in">type</span>=<span class="string">"Data Center"</span> role=<span class="string">"Web Server"</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用docker inspect命令查看容器标签</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect micheal/apache2</span><br></pre></td></tr></table></figure><ol><li>STOPSIGNAL</li></ol><blockquote><p>STOPSIGNAL指令用来设置停止容器时发送什么系统调用信号给容器。</p></blockquote><ol><li>ARG</li></ol><blockquote><p>ARG指令用来定义可以在docker build命令运行时传递给构建运行时的变量，我们只需要在构建时使用–build-arg标志即可。用户只能在构建时指定在Dockerfile文件汇总定义过的参数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG build</span><br><span class="line">ARG webapp_user=user</span><br><span class="line"></span><br><span class="line">$ docker build --build-arg build=1234 -t micheal/webapp .</span><br></pre></td></tr></table></figure><ol><li>ONBUILD</li></ol><blockquote><p>ONBUILD指令能为镜像添加触发器（trigger）。当一个镜像被用做其他镜像的基础镜像时（比如用户的镜像需要从某未准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本），该镜像中的触发器将会被执行。</p><p>触发器会在构建过程中插入新指令，我们可以认为这些指令是紧跟在FROM之后指定的。触发器可以是任何构建指令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN <span class="built_in">cd</span> /app/src/ &amp;&amp; make</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码将会在创建的镜像中加入ONBUILD触发器，ONBUILD指令可以在镜像上运行docker inspect命令查看。</p></blockquote><p><strong>Docker Networking</strong></p><blockquote><p>容器之间的连接用网络创建，这被称为Docker Networking。Docker Networking允许用户创建自己的网络，容器可以通过这个网上互相通信。更重要的是，现在容器可以跨越不同的宿主机来通信，并且网络配置可以更灵活的定制。Docker Networking也和Docker Compose以及Swarm进行了集成。</p><p>要想使用Docker网络，需要先创建一个网络，然后在这个网络下启动容器。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network create app</span><br></pre></td></tr></table></figure><blockquote><p>这里使用docker network命令创建了一个桥接网络，命名为app。可以使用docker network inspect命令查看新创建的这个网络。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect app</span><br></pre></td></tr></table></figure><blockquote><p>我们可以看到这个新网络是一个本地的桥接网络（这非常像docker0网络），而且现在没有容器再这个网络中运行。</p><p>可以使用<code>docker network ls</code>命令列出当前系统中所有的网络。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network ls</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用 <code>docker network rm</code>命令删除一个Docker网络。</p><p>在Docker网络中创建Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --net=app --name db micheal/redis</span><br></pre></td></tr></table></figure><blockquote><p><code>--net</code>标志指定了新容器将会在那个网络中运行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect app</span><br></pre></td></tr></table></figure><blockquote><p>将已有容器连接到Docker网络</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network connect app db2</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>docker network disconnect</code> 命令断开一个容器与指定网络的连接</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network disconnect app db2</span><br></pre></td></tr></table></figure><p><strong>通过Docker链接连接容器</strong></p><blockquote><p>启动一个Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name redis micheal/redis</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里没有公开容器的任何端口。一会就能看到这么做的原因。</p></blockquote><blockquote><p>链接Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -p 4567 --name webapp --link redis:db -t -i -v <span class="variable">$PWD</span>/webapp_redis:/opt/webapp micheal/sinatra /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>这个命令做了不少事情，我们逐一解释。首先，我们使用<code>-p</code>标志公开4567端口，这样就能从外面访问web应用程序。</p><p>我们还使用<code>--name</code>标志给容器命名为webapp，并且使用了<code>-v</code>标志把web应用程序目录作为卷挂载到了容器里。</p><p>然而，这次我们使用了一个新标志<code>--link</code>。<code>--link</code>标志创建了两个容器间的客户-服务链接。这个标志需要两个参数：一个是要链接的容器的名字，另一个是链接的别名。这个例子中我们创建了客户联系，webapp容器是客户，redis容器是“服务”，并且为这个服务增加了db作为别名。这个别名让我们可以一致地访问容器公开信息，而无须关注底层容器的名字。链接让服务容器有能力与客户容器通信，并且能分享一些连接细节，这些细节有助于在应用程序中配置并使用这个链接。</p></blockquote><blockquote><p>连接也能得到一些安全上的好处。注意，启动 Redis 容器时，并没有使用<code>-p</code>标志公开Redis的端口。因为不需要这么做。通过把容器链接在一起，可以让客户直接访问任意服务容器的公开端口（即客户webapp容器可以连接到服务redis容器的6379端口）。更妙的是，只有使用<code>--link</code>标志链接到这个容器的容器才能连接到这个端口。容器的端口不需要对本地宿主机公开，现在我们已经拥有一个非常安全的模型。通过这个安全模型，就可以限制容器化应用程序被攻击面，减少应用暴露的网络。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker基本命令&quot;&gt;&lt;a href=&quot;#Docker基本命令&quot; class=&quot;headerlink&quot; title=&quot;Docker基本命令&quot;&gt;&lt;/a&gt;Docker基本命令&lt;/h1&gt;&lt;h3 id=&quot;常用Docker命令&quot;&gt;&lt;a href=&quot;#常用Docker命令&quot; class=&quot;headerlink&quot; title=&quot;常用Docker命令&quot;&gt;&lt;/a&gt;常用Docker命令&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://miaopei.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://miaopei.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>leveldb原理剖析</title>
    <link href="http://miaopei.github.io/2016/07/15/Program-C/leveldb/"/>
    <id>http://miaopei.github.io/2016/07/15/Program-C/leveldb/</id>
    <published>2016-07-15T02:14:50.000Z</published>
    <updated>2019-06-14T08:02:10.592Z</updated>
    
    <content type="html"><![CDATA[<p>在说LevelDb之前，先认识两位大牛，Jeff Dean和Sanjay Ghemawat，这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。</p><p>Jeff Dean其人：<span class="exturl" data-url="aHR0cDovL3Jlc2VhcmNoLmdvb2dsZS5jb20vcGVvcGxlL2plZmYvaW5kZXguaHRtbA==" title="http://research.google.com/people/jeff/index.html">http://research.google.com/people/jeff/index.html<i class="fa fa-external-link"></i></span>，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。</p><a id="more"></a><p>Sanjay Ghemawat其人：<span class="exturl" data-url="aHR0cDovL3Jlc2VhcmNoLmdvb2dsZS5jb20vcGVvcGxlL3NhbmpheS9pbmRleC5odG1s" title="http://research.google.com/people/sanjay/index.html">http://research.google.com/people/sanjay/index.html<i class="fa fa-external-link"></i></span>，Google大规模分布式平台GFS，Bigtable和MapReduce主要设计和实现工程师。</p><p>LevelDb就是这两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C++ 程序库。正像上面介绍的，这二位是Bigtable的设计和实现者，如果了解Bigtable的话，应该知道在这个影响深远的分布式存储系统中有两个核心的部分：Master Server和Tablet Server。其中Master Server做一些管理数据的存储以及分布式调度工作，实际的分布式数据存储以及读写操作是由Tablet Server完成的，而LevelDb则可以理解为一个简化版的Tablet Server。</p><hr><h2 id="LevelDb-剖析之一：介绍"><a href="#LevelDb-剖析之一：介绍" class="headerlink" title="LevelDb 剖析之一：介绍"></a>LevelDb 剖析之一：介绍</h2><p>LevelDb有如下一些特点：</p><p>首先，LevelDb是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。</p><p>其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。</p><p>再次，像大多数KV系统一样，LevelDb的操作接口很简单，基本操作包括写记录，读记录以及删除记录。也支持针对多条操作的原子批量操作。</p><p>另外，LevelDb支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。</p><p>除此外，LevelDb还支持数据压缩等操作，这对于减小存储空间以及增快IO效率都有直接的帮助。</p><p>LevelDb性能非常突出，官方网站报道其随机写性能达到40万条记录每秒，而随机读性能达到6万条记录每秒。总体来说，LevelDb的写操作要大大快于读操作，而顺序读写操作则大大快于随机读写操作。</p><hr><h2 id="LevelDb剖析之二：整体架构"><a href="#LevelDb剖析之二：整体架构" class="headerlink" title="LevelDb剖析之二：整体架构"></a>LevelDb剖析之二：整体架构</h2><p>LevelDb本质上是一套存储系统以及在这套存储系统上提供的一些操作接口。为了便于理解整个系统及其处理流程，我们可以从两个不同的角度来看待LevleDb：静态角度和动态角度。从静态角度，可以假想整个系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等；从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。</p><p>本节所讲的整体架构主要从静态角度来描述，之后接下来的几节内容会详述静态结构涉及到的文件或者内存数据结构，LevelDb剖析后半部分主要介绍动态视角下的LevelDb，就是说整个系统是怎么运转起来的。</p><p>LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么您会看到如下一番景象：</p><p><img src="/images/imageLeveldb/level1.png" alt="LevelDb结构"></p><p>从图中可以看出，构成LevelDb静态结构的包括六个主要部分：内存中的MemTable和Immutable MemTable以及磁盘上的几种主要文件：Current文件，Manifest文件，log文件以及SSTable文件。当然，LevelDb除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是LevelDb的主体构成元素。</p><p>LevelDb的Log文件和Memtable与Bigtable论文中介绍的是一致的，当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p><p>Log文件在系统中的作用主要是用于系统崩溃恢复而不丢失数据，假如没有Log文件，因为写入的记录刚开始是保存在内存中的，此时如果系统崩溃，内存中的数据还没有来得及Dump到磁盘，所以会丢失数据（Redis就存在这个问题）。为了避免这种情况，LevelDb在写入内存前先将操作记录到Log文件中，然后再记入内存中，这样即使系统崩溃，也可以从Log文件中恢复内存中的Memtable，不会造成数据的丢失。</p><p>当Memtable插入的数据占用内存到了一个界限后，需要将内存的记录导出到外存文件中，LevleDb会生成新的Log文件和Memtable，原先的Memtable就成为Immutable Memtable，顾名思义，就是说这个Memtable的内容是不可更改的，只能读不能写入或者删除。新到来的数据被记入新的Log文件和Memtable，LevelDb后台调度会将Immutable Memtable的数据导出到磁盘，形成一个新的SSTable文件。SSTable就是由内存中的数据不断导出并进行Compaction操作后形成的，而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。</p><p>SSTable中的文件是Key有序的，就是说在文件中小key记录排在大Key记录之前，各个Level的SSTable都是如此，但是这里需要注意的一点是：Level 0的SSTable文件（后缀为.sst）和其它Level的文件相比有特殊性：这个层级内的.sst文件，两个文件可能存在key重叠，比如有两个level 0的sst文件，文件A和文件B，文件A的key范围是：{bar, car}，文件B的Key范围是{blue,samecity}，那么很可能两个文件都存在key=”blood”的记录。对于其它Level的SSTable文件来说，则不会出现同一层级内.sst文件的key重叠现象，就是说Level L中任意两个.sst文件，那么可以保证它们的key值是不会重叠的。这点需要特别注意，后面您会看到很多操作的差异都是由于这个原因造成的。</p><p>SSTable中的某个文件属于特定层级，而且其存储的记录是key有序的，那么必然有文件中的最小key和最大key，这是非常重要的信息，LevelDb应该记下这些信息。Manifest就是干这个的，它记载了SSTable各个文件的管理信息，比如属于哪个Level，文件名称叫啥，最小key和最大key各自是多少。下图是Manifest所存储内容的示意：</p><p><img src="/images/imageLeveldb/level2.png" alt="Manifest存储示意图"></p><p>图中只显示了两个文件（manifest会记载所有SSTable文件的这些信息），即Level 0的test.sst1和test.sst2文件，同时记载了这些文件各自对应的key范围，比如test.sstt1</p><p>的key范围是“an”到 “banana”，而文件test.sst2的key范围是“baby”到“samecity”，可以看出两者的key范围是有重叠的。</p><p>Current文件是干什么的呢？这个文件的内容只有一个信息，就是记载当前的manifest文件名。因为在LevleDb的运行过程中，随着Compaction的进行，SSTable文件会发生变化，会有新的文件产生，老的文件被废弃，Manifest也会跟着反映这种变化，此时往往会新生成Manifest文件来记载这种变化，而Current则用来指出哪个Manifest文件才是我们关心的那个Manifest文件。</p><p>以上介绍的内容就构成了LevelDb的整体静态结构，在LevelDb剖析接下来的内容中，我们会首先介绍重要文件或者内存数据的具体数据布局与结构。</p><hr><h2 id="LevelDb剖析之三：log文件"><a href="#LevelDb剖析之三：log文件" class="headerlink" title="LevelDb剖析之三：log文件"></a>LevelDb剖析之三：log文件</h2><p>上节内容讲到log文件在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。</p><p>下面我们带大家看看log文件的具体物理和逻辑布局是怎样的，LevelDb对于一个log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位，下图展示的log文件由3个Block构成，所以从物理布局来讲，一个log文件就是由连续的32K大小Block构成的。</p><p><img src="/images/imageLeveldb/level3.png" alt="log文件布局"></p><p>在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在LevelDb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理</p><p>记录头包含三个字段，ChechSum是对“类型”和“数据”字段的校验码，为了避免处理不完整或者是被破坏的数据，当LevelDb读取记录数据时候会对数据进行校验，如果发现和存储的CheckSum相同，说明数据完整无破坏，可以继续后续流程。“记录长度”记载了数据的大小，“数据”则是上面讲的Key:Value数值对，“类型”字段则指出了每条记录的逻辑结构和log文件物理分块结构之间的关系，具体而言，主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。</p><p> 如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。</p><p>假设目前存在三条记录，Record A，Record B和Record C，其中Record A大小为10K，Record B 大小为80K，Record C大小为12K，那么其在log文件中的逻辑布局会如图3.1所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。</p><p>从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDb一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p><hr><h2 id="LevelDb剖析之四：SSTable文件"><a href="#LevelDb剖析之四：SSTable文件" class="headerlink" title="LevelDb剖析之四：SSTable文件"></a>LevelDb剖析之四：SSTable文件</h2><p>SSTable是Bigtable中至关重要的一块，对于LevelDb来说也是如此，对LevelDb的SSTable实现细节的了解也有助于了解Bigtable中一些实现细节。</p><p>本节内容主要讲述SSTable的静态布局结构，我们曾在“LevelDb剖析之二：整体架构”中说过，SSTable文件形成了不同Level的层级结构，至于这个层级结构是如何形成的我们放在后面Compaction一节细说。本节主要介绍SSTable某个文件的物理布局和逻辑布局结构，这对了解LevelDb的运行过程很有帮助。</p><p>LevelDb不同层级有很多SSTable文件（以后缀.sst为特征），所有.sst文件内部布局都是一样的。上节介绍Log文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：Log文件中的记录是Key无序的，即先后记录的key大小没有明确大小关系，而.sst文件内部则是根据记录的Key由小到大排列的，从下面介绍的SSTable布局可以体会到Key有序是为何如此设计.sst文件结构的关键。</p><p><img src="/images/imageLeveldb/level4.png" alt="4.1 sst文件的分块结构"></p><p>上图展示了一个 <code>.sst</code> 文件的物理划分结构，同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。</p><p>以上是 <code>.sst</code> 的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。图4.2展示了 <code>.sst</code> 文件的内部逻辑解释。</p><p><img src="/images/imageLeveldb/level5.png" alt="4.2 逻辑布局"></p><p>从上图可以看出，从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。</p><p>LevelDb 1.2版对于Meta Block尚无实际使用，只是保留了一个接口，估计会在后续版本中加入内容，下面我们看看数据索引区和文件尾部Footer的内部结构。</p><p><img src="/images/imageLeveldb/level6.png" alt="4.3 数据索引"></p><p>图4.3是数据索引的内部结构示意图。再次强调一下，Data Block内的KV记录是按照Key由小到大排列的，数据索引区的每条记录是对某个Data Block建立的索引信息，每条索引信息包含三个内容，以图4.3所示的数据块i的索引Index i来说：红色部分的第一个字段记载大于等于数据块i中最大的Key值的那个Key，第二个字段指出数据块i在.sst文件中的起始位置，第三个字段指出Data Block i的大小（有时候是有数据压缩的）。后面两个字段好理解，是用于定位数据块在文件中的位置的，第一个字段需要详细解释一下，在索引里保存的这个Key值未必一定是某条记录的Key,以图4.3的例子来说，假设数据块i 的最小Key=“samecity”，最大Key=“the best”;数据块i+1的最小Key=“the fox”,最大Key=“zoo”,那么对于数据块i的索引Index i来说，其第一个字段记载大于等于数据块i的最大Key(“the best”)同时要小于数据块i+1的最小Key(“the fox”)，所以例子中Index i的第一个字段是：“the c”，这个是满足要求的；而Index i+1的第一个字段则是“zoo”，即数据块i+1的最大Key。</p><p>文件末尾Footer块的内部结构见图4.4，metaindex_handle指出了metaindex block的起始位置和大小；inex_handle指出了index Block的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的，后面跟着一个填充区和魔数。</p><p>上面主要介绍的是数据管理区的内部结构，下面我们看看数据区的一个Block的数据部分内部是如何布局的（图4.1中的红色部分），图4.5是其内部布局示意图。</p><p><img src="/images/imageLeveldb/level7.png" alt="4.5 数据Block内部结构"></p><p>从图中可以看出，其内部也分为两个部分，前面是一个个KV记录，其顺序是根据Key值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point）,其实是一些指针，指出Block内容中的一些记录位置。</p><p>“重启点”是干什么的呢？我们一再强调，Block内容里的KV记录是按照Key大小有序的，这样的话，相邻的两条记录很可能Key部分存在重叠，比如key i=“the Car”，Key i+1=“the color”,那么两者存在重叠部分“the c”，为了减少Key的存储量，Key i+1可以只存储和上一条Key不同的部分“olor”，两者的共同部分从Key i中可以获得。记录的Key在Block内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的Key部分，而是重新记录所有的Key值，假设Key i+1是一个重启点，那么Key里面会完整存储“the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。</p><p><img src="/images/imageLeveldb/level8.png" alt="4.6 记录格式"></p><p>在Block内容区，每个KV记录的内部结构是怎样的？图4.6给出了其详细结构，每个记录包含5个字段：key共享长度，比如上面的“olor”记录， 其key和上一条记录共享的Key部分长度是“the c”的长度，即5；key非共享长度，对于“olor”来说，是4；value长度指出Key:Value中Value的长度，在后面的Value内容字段中存储实际的Value值；而key非共享内容则实际存储“olor”这个Key字符串。</p><p>上面讲的这些就是.sst文件的全部内部奥秘。</p><hr><h2 id="LevelDb剖析之五：MemTable详解"><a href="#LevelDb剖析之五：MemTable详解" class="headerlink" title="LevelDb剖析之五：MemTable详解"></a>LevelDb剖析之五：MemTable详解</h2><p>LevelDb剖析前述小节大致讲述了磁盘文件相关的重要静态结构，本小节讲述内存中的数据结构Memtable，Memtable在整个体系中的重要地位也不言而喻。总体而言，所有KV数据都是存储在Memtable，Immutable Memtable和SSTable中的，Immutable Memtable从结构上讲和Memtable是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而Memtable则是允许写入和读取的。当Memtable写入的数据占用内存到达指定数量，则自动转换为Immutable Memtable，等待Dump到磁盘中，系统会自动生成新的Memtable供写操作写入新数据，理解了Memtable，那么Immutable Memtable自然不在话下。</p><p>LevelDb的MemTable提供了将KV数据写入，删除以及读取KV记录的操作接口，但是事实上Memtable并不存在真正的删除操作,删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，真正的删除操作是Lazy的，会在以后的Compaction过程中去掉这个KV。</p><p>需要注意的是，LevelDb的Memtable中KV对是根据Key大小有序存储的，在系统插入新的KV时，LevelDb要把这个KV插到合适的位置上以保持这种Key有序性。其实，LevelDb的Memtable类只是一个接口类，真正的操作是通过背后的SkipList来做的，包括插入操作和读取操作等，所以Memtable的核心数据结构是一个SkipList。</p><p>SkipList是由William Pugh发明。他在Communications of the ACM June 1990, 33(6) 668-676 发表了Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。</p><p>SkipList是平衡树的一种替代数据结构，但是和红黑树不相同的是，SkipList对于树的平衡的实现是基于一种随机化的算法的，这样也就是说SkipList的插入和删除的工作是比较简单的。</p><p>关于SkipList的详细介绍可以参考这篇文章，<span class="exturl" data-url="aHR0cDovL2xpcHBpb3V5YW5nb25saW5lLmluZm8vc2tpcC1saXN0Lw==" title="http://lippiouyangonline.info/skip-list/">skip-list原理解析<i class="fa fa-external-link"></i></span>讲述的很清楚，LevelDb的SkipList基本上是一个具体实现，并无特殊之处。</p><p>SkipList不仅是维护有序数据的一个简单实现，而且相比较平衡树来说，在插入数据的时候可以避免频繁的树节点调整操作，所以写入效率是很高的，LevelDb整体而言是个高写入系统，SkipList在其中应该也起到了很重要的作用。Redis为了加快插入操作，也使用了SkipList来作为内部实现数据结构。</p><hr><h2 id="LevelDb剖析之六-写入与删除记录"><a href="#LevelDb剖析之六-写入与删除记录" class="headerlink" title="LevelDb剖析之六 写入与删除记录"></a>LevelDb剖析之六 写入与删除记录</h2><p>在之前的五节LevelDb剖析中，我们介绍了LevelDb的一些静态文件及其详细布局，从本节开始，我们看看LevelDb的一些动态操作，比如读写记录，Compaction，错误恢复等操作。</p><p>本节介绍levelDb的记录更新操作，即插入一条KV记录或者删除一条KV记录。levelDb的更新操作速度是非常快的，源于其内部机制决定了这种更新操作的简单性。</p><p><img src="/images/imageLeveldb/level9.png" alt="6.1 LevelDb写入记录"></p><p>图6.1是levelDb如何更新KV数据的示意图，从图中可以看出，对于一个插入操作Put(Key,Value)来说，完成插入操作包含两个具体步骤：首先是将这条KV记录以顺序写的方式追加到之前介绍过的log文件末尾，因为尽管这是一个磁盘读写操作，但是文件的顺序追加写入效率是很高的，所以并不会导致写入速度的降低；第二个步骤是:如果写入log文件成功，那么将这条KV记录插入内存中的Memtable中，前面介绍过，Memtable只是一层封装，其内部其实是一个Key有序的SkipList列表，插入一条新记录的过程也很简单，即先查找合适的插入位置，然后修改相应的链接指针将新记录插入即可。完成这一步，写入记录就算完成了，所以一个插入记录操作涉及一次磁盘文件追加写和内存SkipList插入操作，这是为何levelDb写入速度如此高效的根本原因。</p><p>从上面的介绍过程中也可以看出：log文件内是key无序的，而Memtable中是key有序的。那么如果是删除一条KV记录呢？对于levelDb来说，并不存在立即删除的操作，而是与插入操作相同的，区别是，插入操作插入的是Key:Value 值，而删除操作插入的是“Key:删除标记”，并不真正去删除记录，而是后台Compaction的时候才去做真正的删除操作。</p><p>levelDb的写入操作就是如此简单。真正的麻烦在后面将要介绍的读取操作中。</p><hr><h2 id="LevelDb剖析之七：读取记录"><a href="#LevelDb剖析之七：读取记录" class="headerlink" title="LevelDb剖析之七：读取记录"></a>LevelDb剖析之七：读取记录</h2><p>LevelDb是针对大规模Key/Value数据的单机存储库，从应用的角度来看，LevelDb就是一个存储工具。而作为称职的存储工具，常见的调用接口无非是新增KV，删除KV，读取KV，更新Key对应的Value值这么几种操作。LevelDb的接口没有直接支持更新操作的接口，如果需要更新某个Key的Value,你可以选择直接生猛地插入新的KV，保持Key相同，这样系统内的key对应的value就会被更新；或者你可以先删除旧的KV， 之后再插入新的KV，这样比较委婉地完成KV的更新操作。</p><p>假设应用提交一个Key值，下面我们看看LevelDb是如何从存储的数据中读出其对应的Value值的。图7-1是LevelDb读取过程的整体示意图。</p><p><img src="/images/imageLeveldb/level10.png" alt="7-1 LevelDb读取记录流程"></p><p>LevelDb首先会去查看内存中的Memtable，如果Memtable中包含key及其对应的value，则返回value值即可；如果在Memtable没有读到key，则接下来到同样处于内存中的Immutable Memtable中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。因为SSTable数量较多，而且分成多个Level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于level 0的文件中查找，如果找到则返回对应的value值，如果没有找到那么到level 1中的文件中去找，如此循环往复，直到在某层SSTable文件中找到这个key对应的value为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p><p>那么为什么是从Memtable到Immutable Memtable，再从Immutable Memtable到文件，而文件中为何是从低level到高level这么一个查询路径呢？道理何在？之所以选择这么个查询路径，是因为从信息的更新时间来说，很明显Memtable存储的是最新鲜的KV对；Immutable Memtable中存储的KV数据对的新鲜程度次之；而所有SSTable文件中的KV数据新鲜程度一定不如内存中的Memtable和Immutable Memtable的。对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。也就是说，上面列出的查找路径就是按照数据新鲜程度排列出来的，越新鲜的越先查找。</p><p>为啥要优先查找新鲜的数据呢？这个道理不言而喻，举个例子。比如我们先往levelDb里面插入一条数据 {key=”<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20mcXVvdDs=" title="http://www.samecity.com&quot;">www.samecity.com&quot;<i class="fa fa-external-link"></i></span>  value=”我们”},过了几天，samecity网站改名为：69同城，此时我们插入数据{key=”<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20mcXVvdDs=" title="http://www.samecity.com&quot;">www.samecity.com&quot;<i class="fa fa-external-link"></i></span>  value=”69同城”}，同样的key,不同的value；逻辑上理解好像levelDb中只有一个存储记录，即第二个记录，但是在levelDb中很可能存在两条记录，即上面的两个记录都在levelDb中存储了，此时如果用户查询key=”<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20mcXVvdDss5oiR5Lus5b2T54S25biM5pyb5om+5Yiw5pyA5paw55qE5pu05paw6K6w5b2V77yM5Lmf5bCx5piv56ys5LqM5Liq6K6w5b2V6L+U5Zue77yM6L+Z5bCx5piv5Li65L2V6KaB5LyY5YWI5p+l5om+5paw6bKc5pWw5o2u55qE5Y6f5Zug44CC" title="http://www.samecity.com&quot;,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。">www.samecity.com&quot;,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。<i class="fa fa-external-link"></i></span></p><p>前文有讲：对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。这是一个结论，理论上需要一个证明过程，否则会招致如下的问题：为神马呢？从道理上讲呢，很明白：因为Level L+1的数据不是从石头缝里蹦出来的，也不是做梦梦到的，那它是从哪里来的？Level L+1的数据是从Level L 经过Compaction后得到的（如果您不知道什么是Compaction，那么……..也许以后会知道的），也就是说，您看到的现在的Level L+1层的SSTable数据是从原来的Level L中来的，现在的Level L比原来的Level L数据要新鲜，所以可证，现在的Level L比现在的Level L+1的数据要新鲜。</p><p>SSTable文件很多，如何快速地找到key对应的value值？在LevelDb中，level 0一直都爱搞特殊化，在level 0和其它level中查找某个key的过程是不一样的。因为level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含，这样的话LevelDb的策略是先找出level 0中哪些文件包含这个key（manifest文件中记载了level和对应的文件及文件里key的范围信息，LevelDb在内存中保留这种映射表）， 之后按照文件的新鲜程度排序，新的文件排在前面，之后依次查找，读出key对应的value。而如果是非level 0的话，因为这个level的文件之间key是不重叠的，所以只从一个文件就可以找到key对应的value。</p><p>最后一个问题,如果给定一个要查询的key和某个key range包含这个key的SSTable文件，那么levelDb是如何进行具体查找过程的呢？levelDb一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后levelDb根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的SSTable文件并不包含这个key，所以到下一级别的SSTable中去查找。</p><p>从之前介绍的LevelDb的写操作和这里介绍的读操作可以看出，相对写操作，读操作处理起来要复杂很多，所以写的速度必然要远远高于读数据的速度，也就是说，LevelDb比较适合写操作多于读操作的应用场合。而如果应用是很多读操作类型的，那么顺序读取效率会比较高，因为这样大部分内容都会在缓存中找到，尽可能避免大量的随机读取操作。</p><hr><h2 id="LevelDb剖析之八：Compaction操作"><a href="#LevelDb剖析之八：Compaction操作" class="headerlink" title="LevelDb剖析之八：Compaction操作"></a>LevelDb剖析之八：Compaction操作</h2><p>前文有述，对于LevelDb来说，写入记录操作很简单，删除记录仅仅写入一个删除标记就算完事，但是读取记录比较复杂，需要在内存以及各个层级文件中依照新鲜程度依次查找，代价很高。为了加快读取速度，levelDb采取了compaction的方式来对已有的记录进行整理压缩，通过这种方式，来删除掉一些不再有效的KV数据，减小数据规模，减少文件数量等。</p><p>levelDb的compaction机制和过程与Bigtable所讲述的是基本一致的，Bigtable中讲到三种类型的compaction: minor ，major和full。所谓minor Compaction，就是把memtable中的数据导出到SSTable文件中；major compaction就是合并不同层级的SSTable文件，而full compaction就是将所有SSTable进行合并。</p><p>LevelDb包含其中两种，minor和major。</p><p>我将为大家详细叙述其机理。</p><p>先来看看minor Compaction的过程。Minor compaction 的目的是当内存中的memtable大小到了一定值时，将内容保存到磁盘文件中，图8.1是其机理示意图。 </p><p><img src="/images/imageLeveldb/level11.png" alt="8.1 minor compaction"></p><p>从8.1可以看出，当memtable数量到了一定程度会转换为immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable其实是一个多层级队列SkipList，其中的记录是根据key有序排列的。所以这个minor compaction实现起来也很简单，就是按照immutable memtable中记录由小到大遍历，并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 数据，这样就完成了一次minor compaction。从图中也可以看出，对于被删除的记录，在minor compaction过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉key记录，但是这个KV数据在哪里?那需要复杂的查找，所以在minor compaction的时候并不做删除，只是将这个key作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的compaction中会去做。</p><p>当某个level下的SSTable文件数目超过一定设置值后，levelDb会从这个level的SSTable中选择一个文件（level&gt;0），将其和高一层级的level+1的SSTable文件合并，这就是major compaction。</p><p>我们知道在大于0的层级中，每个SSTable文件内的Key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。Level 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。</p><p>levelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，levelDb在这里有个小技巧， 就是说轮流来，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。</p><p>如果选好了level L的文件A和level L+1层的文件进行合并，那么问题又来了，应该选择level L+1哪些文件进行合并？levelDb选择L+1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。</p><p>也就是说，选定了level L的文件A,之后在level L+1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。</p><p>图8.2说明了这一过程。</p><p><img src="/images/imageLeveldb/level12.png" alt="8.2 SSTable Compaction"></p><p>Major compaction的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的Key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个Key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入level L+1层中新生成的一个SSTable文件中。就这样对KV数据一一处理，形成了一系列新的L+1层数据文件，之前的L层文件和L+1层参与compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了L层和L+1层文件记录的合并过程。</p><p>那么在major compaction过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于L层中存在这个Key，那么这个KV在major compaction过程中可以抛掉。因为我们前面分析过，对于层级低于L的文件中如果存在同一Key的记录，那么说明对于Key来说，有更新鲜的Value存在，那么过去的Value就等于没有意义了，所以可以删除。</p><hr><h2 id="LevelDb剖析之九-levelDb中的Cache"><a href="#LevelDb剖析之九-levelDb中的Cache" class="headerlink" title="LevelDb剖析之九 levelDb中的Cache"></a>LevelDb剖析之九 levelDb中的Cache</h2><p>书接前文，前面讲过对于levelDb来说，读取操作如果没有在内存的memtable中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在level 0中最新的文件中找到了这个key，那么也需要读取2次磁盘，一次是将SSTable的文件中的index部分读入内存，这样根据这个index可以确定key是在哪个block中存储；第二次是读入这个block的内容，然后在内存中查找key对应的value。</p><p>levelDb中引入了两个不同的Cache:Table Cache和Block Cache。其中Block Cache是配置可选的，即在配置文件中指定是否打开这个功能。</p><p><img src="/images/imageLeveldb/level3.png" alt="9.1 table cache"></p><p>图9.1是table cache的结构。在Cache中，key值是SSTable的文件名称，Value部分包含两部分，一个是指向磁盘打开的SSTable文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个SSTable文件对应的Table结构指针，table结构在内存中，保存了SSTable的index内容以及用来指示block cache用的cache_id ,当然除此外还有其它一些内容。</p><p>比如在get(key)读取操作中，如果levelDb确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，levelDb会首先查找Table Cache，看这个文件是否在缓存里，如果找到了，那么根据index部分就可以查找是哪个block包含这个key。如果没有在缓存中找到文件，那么打开SSTable文件，将其index部分读入内存，然后插入Cache里面，去index里面定位哪个block包含这个Key 。如果确定了文件哪个block包含这个key，那么需要读入block内容，这是第二次读取。</p><p>Block Cache是为了加快这个过程的，图9.2是其结构示意图。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p><p>如果levelDb发现这个block在block cache中，那么可以避免读取数据，直接在cache里的block内容里面查找key的value就行，如果没找到呢？那么读入block内容并把它插入block cache中。levelDb就是这样通过两个cache来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p><hr><h2 id="LevelDb剖析之十-Version、VersionEdit、VersionSet"><a href="#LevelDb剖析之十-Version、VersionEdit、VersionSet" class="headerlink" title="LevelDb剖析之十 Version、VersionEdit、VersionSet"></a>LevelDb剖析之十 Version、VersionEdit、VersionSet</h2><p>Version 保存了当前磁盘以及内存中所有的文件信息，一般只有一个Version叫做”current” version（当前版本）。Leveldb还保存了一系列的历史版本，这些历史版本有什么作用呢？</p><p>当一个Iterator创建后，Iterator就引用到了current version(当前版本)，只要这个Iterator不被delete那么被Iterator引用的版本就会一直存活。这就意味着当你用完一个Iterator后，需要及时删除它。</p><p>当一次Compaction结束后（会生成新的文件，合并前的文件需要删除），Leveldb会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p><p>VersionSet 是所有Version的集合，管理着所有存活的Version。</p><p>VersionEdit 表示Version之间的变化，相当于delta 增量，表示有增加了多少文件，删除了文件。下图表示他们之间的关系。</p><p>Version0 +VersionEdit–&gt;Version1</p><p>VersionEdit会保存到MANIFEST文件中，当做数据恢复时就会从MANIFEST文件中读出来重建数据。</p><p>leveldb的这种版本的控制，让我想到了双buffer切换，双buffer切换来自于图形学中，用于解决屏幕绘制时的闪屏问题，在服务器编程中也有用处。</p><p>比如我们的服务器上有一个字典库，每天我们需要更新这个字典库，我们可以新开一个buffer，将新的字典库加载到这个新buffer中，等到加载完毕，将字典的指针指向新的字典库。</p><p>leveldb的version管理和双buffer切换类似，但是如果原version被某个iterator引用，那么这个version会一直保持，直到没有被任何一个iterator引用，此时就可以删除这个version。</p><p>注：本文参考了这篇文章：<span class="exturl" data-url="aHR0cDovL3d3dy5zYW1lY2l0eS5jb20vYmxvZy9JbmRleC5hc3A/U29ydElEPTEy" title="http://www.samecity.com/blog/Index.asp?SortID=12">http://www.samecity.com/blog/Index.asp?SortID=12<i class="fa fa-external-link"></i></span><br>参考资料：1.<span class="exturl" data-url="aHR0cDovL3poLndpa2lwZWRpYS5vcmcvd2lraS9MZXZlbERC" title="http://zh.wikipedia.org/wiki/LevelDB">维基百科<i class="fa fa-external-link"></i></span><br>　　　　　2.<span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2xldmVsZGIv" title="http://code.google.com/p/leveldb/">google code<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在说LevelDb之前，先认识两位大牛，Jeff Dean和Sanjay Ghemawat，这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。&lt;/p&gt;
&lt;p&gt;Jeff Dean其人：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3Jlc2VhcmNoLmdvb2dsZS5jb20vcGVvcGxlL2plZmYvaW5kZXguaHRtbA==&quot; title=&quot;http://research.google.com/people/jeff/index.html&quot;&gt;http://research.google.com/people/jeff/index.html&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。&lt;/p&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>处理并发之二：libevent的eventbuffer</title>
    <link href="http://miaopei.github.io/2016/07/12/Program-C/libevent/"/>
    <id>http://miaopei.github.io/2016/07/12/Program-C/libevent/</id>
    <published>2016-07-12T02:14:50.000Z</published>
    <updated>2019-06-14T07:46:43.817Z</updated>
    
    <content type="html"><![CDATA[<p>bufferevent这个结构体</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">ev_base</span>;</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent_ops</span> *<span class="title">be_ops</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev_read</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev_write</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">input</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span>;</span> </span><br><span class="line">    bufferevent_data_cb readcb;</span><br><span class="line">    bufferevent_data_cb writecb;</span><br><span class="line">    bufferevent_event_cb errorcb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 struct bufferevent 内置了两个 event（读/写）和对应的缓冲区。当有数据被读入(input)的时候，readcb 被调用，当 output 被输出完成的时候，writecb 被调用，当网络 I/O 出现错误，如链接中断，超时或其他错误时，errorcb 被调用。<br>使用 bufferevent 的过程：</p><p><strong>1. 设置sock为非阻塞的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:  evutil_make_socket_nonblocking(fd);</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用bufferevent_socket_new创建一个structbufferevent *bev，关联该sockfd，托管给event_base</strong></p><p>函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent * <span class="title">bufferevent_socket_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">int</span> options)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// eg:  struct bufferevent *bev;  </span></span></span><br><span class="line"><span class="function"><span class="comment">// bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span></span></span><br></pre></td></tr></table></figure><p><strong>3. 设置读写对应的回调函数</strong></p><p>函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,   </span></span></span><br><span class="line"><span class="function"><span class="params">bufferevent_data_cb readcb, bufferevent_data_cb writecb,  </span></span></span><br><span class="line"><span class="function"><span class="params">bufferevent_event_cb eventcb, <span class="keyword">void</span> *cbarg)</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// eg. bufferevent_setcb(bev, readcb, NULL, errorcb, NULL);</span></span></span><br></pre></td></tr></table></figure><p><strong>4. 启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的</strong></p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> event)</span>   </span></span><br><span class="line"><span class="function"><span class="comment">// eg. bufferevent_enable(bev, EV_READ|EV_WRITE);</span></span></span><br></pre></td></tr></table></figure><p><strong>5. 进入bufferevent_setcb回调函数：</strong></p><p>在readcb里面从input中读取数据，处理完毕后填充到output中； writecb对于服务端程序，只需要readcb就可以了，可以置为NULL； errorcb 用于处理一些错误信息。</p><p>针对这些使用过程进入源码进行分析：</p><p><strong>1. bufferevent_socket_new</strong>     </p><ul><li>在bufferevent_init_common中调用evbuffer_new()初始化input和output</li><li>在event_assign中初始化bufferevent中的ev_read和ev_write事件。</li><li>在evbuffer_add_cb中给output添加了一个callback bufferevent_socket_outbuf_cb</li></ul><p><strong>2. bufferevent_setcb</strong></p><p>该函数的作用主要是赋值，把该函数后面的参数，赋值给第一个参数 <code>struct bufferevent *bufev</code> 定义的变量</p><p><strong>3. bufferevent_enable</strong></p><p>调用event_add将读写事件加入到事件监听队列中。</p><p>对bufferevent常用的几个函数进行分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">evbuffer_readln</span><span class="params">(struct evbuffer*buffer, <span class="keyword">size_t</span> *n_read_out,<span class="keyword">enum</span></span></span></span><br><span class="line"><span class="function"><span class="params">evbuffer_eol_style eol_style)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//含义：Read a single line from an evbuffer.</span></span><br><span class="line"><span class="comment">//返回值：读到的一行内容</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add</span><span class="params">(struct evbuffer *buf,<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含义：将数据添加到evbuffer的结尾</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove</span><span class="params">(struct evbuffer*buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含义：从evbuffer读取数据到data</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> evbuffer_get_length(<span class="keyword">const</span> structevbuffer *buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含义：返回evbuffer中存储的字节长度</span></span><br></pre></td></tr></table></figure><p>暂时先分析到这里，下面是代码，客户端发送消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0, Client 0 send Message:</span><br><span class="line">Request: Hello Server! over</span><br></pre></td></tr></table></figure><p>服务端一条消息收完成后，会回复：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response ok! Hello Client!</span><br></pre></td></tr></table></figure><p>服务端从bufferevent中取出消息是按行取的。代码可能有不完善的地方，由于才疏学浅，研究时间短（3天），希望高手提出宝贵意见。</p><details><summary>buffer_server.c</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;     </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;        </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span></span>;  </span><br><span class="line"><span class="comment">//struct bufferevent内建了两个event(read/write)和对应的缓冲区(struct evbuffer *input, *output)，并提供相应的函数用来操作缓冲区(或者直接操作bufferevent)   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收到数据后，判断是不一样一条消息的结束，结束标志为"over"字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readcb</span><span class="params">(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"called readcb!\n"</span>);   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">input</span>, *<span class="title">output</span>;</span>  </span><br><span class="line">    <span class="keyword">char</span> *request_line;  </span><br><span class="line">    <span class="keyword">size_t</span> len;  </span><br><span class="line">    <span class="comment">//其实就是取出bufferevent中的input  </span></span><br><span class="line">    input = bufferevent_get_input(bev);</span><br><span class="line">    <span class="comment">//其实就是取出bufferevent中的output </span></span><br><span class="line">    output = bufferevent_get_output(bev);  </span><br><span class="line">    <span class="keyword">size_t</span> input_len = evbuffer_get_length(input);      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input_len: %d\n"</span>, input_len);  </span><br><span class="line">    <span class="keyword">size_t</span> output_len = evbuffer_get_length(output);     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"output_len: %d\n"</span>, output_len);    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;        </span><br><span class="line">        <span class="comment">//从evbuffer前面取出一行，用一个新分配的空字符结束</span></span><br><span class="line">        <span class="comment">//的字符串返回这一行,EVBUFFER_EOL_CRLF表示行尾是一个可选的回车，后随一个换行符</span></span><br><span class="line">        request_line = evbuffer_readln(input, &amp;len, EVBUFFER_EOL_CRLF);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == request_line)&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The first line has not arrived yet.\n"</span>);            </span><br><span class="line">            <span class="built_in">free</span>(request_line);<span class="comment">//之所以要进行free是因为 line = mm_malloc(n_to_copy+1))，在这里进行了malloc </span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Get one line date: %s\n"</span>, request_line); </span><br><span class="line">            <span class="comment">//用于判断是不是一条消息的结束  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strstr</span>(request_line, <span class="string">"over"</span>) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> *response = <span class="string">"Response ok! Hello Client!\r\n"</span>;  </span><br><span class="line">                <span class="comment">//Adds data to an event buffer  </span></span><br><span class="line">                evbuffer_add(output, response, <span class="built_in">strlen</span>(response));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"服务端接收一条数据完成，回复客户端一条消息: %s\n"</span>, response);                 </span><br><span class="line">                <span class="built_in">free</span>(request_line);  </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">free</span>(request_line);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">size_t</span> input_len1 = evbuffer_get_length(input);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input_len1: %d\n"</span>, input_len1); </span><br><span class="line">    <span class="keyword">size_t</span> output_len1 = evbuffer_get_length(output);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"output_len1: %d\n\n"</span>, output_len1);  </span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errorcb</span><span class="params">(struct bufferevent *bev, <span class="keyword">short</span> error, <span class="keyword">void</span> *ctx)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (error &amp; BEV_EVENT_EOF) &#123; </span><br><span class="line">        <span class="comment">/* connection has been closed, do any clean up here */</span>    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connection closed\n"</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (error &amp; BEV_EVENT_ERROR)&#123;    </span><br><span class="line">        <span class="comment">/* check errno to see what error occurred */</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"some other error\n"</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error &amp; BEV_EVENT_TIMEOUT) </span><br><span class="line">        <span class="comment">/* must be a timeout event handle, handle it */</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Timed out\n"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">bufferevent_free(bev);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_accept</span><span class="params">(<span class="keyword">evutil_socket_t</span> listener, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">arg</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span>  </span><br><span class="line"><span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);  </span><br><span class="line"><span class="keyword">int</span> fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);  </span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"accept"</span>);  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (fd &gt; FD_SETSIZE)&#123;  </span><br><span class="line">close(fd);  </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">struct bufferevent *bev;</span><br><span class="line">evutil_make_socket_nonblocking(fd);           </span><br><span class="line"><span class="comment">//使用bufferevent_socket_new创建一个struct bufferevent*bev，</span></span><br><span class="line"><span class="comment">//关联该sockfd，托管给event_base           </span></span><br><span class="line"><span class="comment">//BEV_OPT_CLOSE_ON_FREE表示释放bufferevent时关闭底层传输端口。</span></span><br><span class="line">    <span class="comment">//这将关闭底层套接字，释放底层bufferevent等</span></span><br><span class="line">bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);           </span><br><span class="line"><span class="comment">//设置读写对应的回调函数  </span></span><br><span class="line">bufferevent_setcb(bev, readcb, <span class="literal">NULL</span>, errorcb, <span class="literal">NULL</span>);  </span><br><span class="line">bufferevent_setwatermark(bev, EV_READ, <span class="number">0</span>, MAX_LINE);          </span><br><span class="line"><span class="comment">//启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。</span></span><br><span class="line"><span class="comment">//正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的  </span></span><br><span class="line">bufferevent_enable(bev, EV_READ|EV_WRITE); </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line"><span class="keyword">evutil_socket_t</span> listener;   </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">listener_event</span>;</span>    </span><br><span class="line">base = event_base_new();  </span><br><span class="line"><span class="keyword">if</span> (!base)  </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;  </span><br><span class="line"><span class="built_in">sin</span>.sin_addr.s_addr = <span class="number">0</span>;  </span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(<span class="number">8000</span>);   </span><br><span class="line">listener = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">evutil_make_socket_nonblocking(listener);  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> WIN32&#123;    </span></span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">1</span>;        </span><br><span class="line">    setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, </span><br><span class="line">                   &amp;one, <span class="keyword">sizeof</span>(one));  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">    <span class="keyword">if</span>(bind(listener, (struct sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);          </span><br><span class="line">        <span class="keyword">return</span>;     </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listen(listener, <span class="number">16</span>)&lt;<span class="number">0</span>)&#123;perror(<span class="string">"listen"</span>);  </span><br><span class="line">        <span class="keyword">return</span>;     </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (<span class="keyword">void</span>*)base);</span><br><span class="line">    event_add(listener_event, <span class="literal">NULL</span>);  event_base_dispatch(base);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);   </span><br><span class="line">    run();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bufferevent这个结构体&lt;/p&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://miaopei.github.io/2016/07/11/Program-C/multi-thread/"/>
    <id>http://miaopei.github.io/2016/07/11/Program-C/multi-thread/</id>
    <published>2016-07-11T02:14:50.000Z</published>
    <updated>2019-06-14T06:12:33.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyMzc1NTA5" title="https://www.zhihu.com/question/22375509">怎么样才算得上熟悉多线程编程？<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC91LzE4NjQ1NjcvYmxvZy8zNDA0NzE=" title="https://my.oschina.net/u/1864567/blog/340471">C++多线程模型与锁<i class="fa fa-external-link"></i></span></p></blockquote><ol><li>了解进程线程的基本概念，能用一种语言在一个平台上实现一个多线程的例子。（这些不会还写熟悉多线程就太大无畏了）</li><li>了解为什么要用Mutex之类的工具做锁来同步和保护资源。弄懂诸如racing condition，死锁之类的概念。50%公司的见面题，用来砍死大无畏。</li><li>了解编译器优化带来的影响，了解cache的影响，了解volatile，memory barrier之类的概念。如果是主Java的话，去了解一下JVM的内存模型。以上这些偏硬偏系统端的公司喜欢问，不过由于太基础，稍稍好奇一点的多线程领域程序员都应该会了解，否则略显大无畏。</li><li>了解一下你主攻平台＋语言所提供的工具库，知道常用的工具的用法和使用场景：Mutex，Semaphore，原子操作集，Condition Variable，spin lock。这几个算是比较常用的，在各个平台＋语言也都有对应实现。老实说，spinlock，condition variable是我工作里从没用过的，但是也被问过，其他几个都太常用了，如果是java的话再多看一组Executor相关的，以及Java多线程相关的keywords，和object本身提供的同步函数，wait notify之类的，在主Java的公司问过。</li><li>了解常用的多线程设计范式，比如读写锁（Reader/Writer Lock，非常经典的范式，有偏向读和写的不同变形，至少被要求写过3次），生产消费范式（写过2次），一些常用容器的实现，比如BlockingQueue（写过3次）或者concurrentHashmap（写过2次）。如果是主Java的话可以看看JDK的实现。熟悉一下一些算不上多线程设计模式的小技巧，比如传递只读对象可以避免加锁，或者Copy传递以防外部修改之类的（讨论环节被问过）。另外值得特别一提的一个小细节是，Singleton的线程安全是个很有意思而且容易出错的话题，值得一看（只被问过一次，不过我答挂了，所以印象及其深）。还有可能会问的是一些有趣的小场景让你实现一些功能需要线程安全，无法特别准备，但是你能了解上面说的这些范式，不傻的话大多数都能想出来。<br>如果和我一样多线程方面是主Java的话，记得Doug Lea的书写的很明白，不过不记得当时读完的是哪本，70%可能是下面这个<br><span class="exturl" data-url="aHR0cDovL3d3dy5hbWF6b24uY29tL0phdmEtQ29uY3VycmVuY3ktUHJhY3RpY2UtQnJpYW4tR29ldHovZHAvMDMyMTM0OTYwMQ==" title="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601<i class="fa fa-external-link"></i></span><br>否则就是<br>Concurrent Programming in Java: Design Principles and Pattern (2nd Edition): Doug Lea: 0785342310092: Amazon.com: Books</li></ol><p>这个大致是一些公司对多线程部分的要求，如果应聘者声称熟悉这个部分。上面所有点都是本人面试被问到的，基本上能看完上面这些，可以做到不用很心虚在简历上写自己熟悉多线程而不会被揭穿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyMzc1NTA5&quot; title=&quot;https://www.zhihu.com/question/2
      
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>处理并发之一：LINUX Epoll 机制介绍</title>
    <link href="http://miaopei.github.io/2016/07/08/Program-C/linux-epoll/"/>
    <id>http://miaopei.github.io/2016/07/08/Program-C/linux-epoll/</id>
    <published>2016-07-08T02:14:50.000Z</published>
    <updated>2019-06-14T07:19:50.504Z</updated>
    
    <content type="html"><![CDATA[<p>Epoll 可是当前在 Linux 下开发大规模并发网络程序的热门人选，Epoll 在 Linux2.6 内核中正式引入，和 select 相似，其实都 I/O 多路复用技术而已，并没有什么神秘的。</p><p>其实在 Linux 下设计并发网络程序，向来不缺少方法，比如典型的 Apache 模型（Process Per Connection，简称 PPC），TPC（Thread Per Connection）模型，以及 select 模型和 poll 模型，那为何还要再引入 Epoll 这个东东呢？那还是有得说说的…</p><a id="more"></a><h2 id="常用模型的缺点"><a href="#常用模型的缺点" class="headerlink" title="常用模型的缺点"></a>常用模型的缺点</h2><p>如果不摆出来其他模型的缺点，怎么能对比出 Epoll 的优点呢。</p><h3 id="PPC-TPC-模型"><a href="#PPC-TPC-模型" class="headerlink" title="PPC/TPC 模型"></a>PPC/TPC 模型</h3><p>这两种模型思想类似，就是让每一个到来的连接一边自己做事去，别再来烦我。只是 PPC 是为它开了一个进程，而 TPC 开了一个线程。可是别烦我是有代价的，它要时间和空间啊，连接多了之后，那么多的进程 / 线程切换，这开销就上来了；因此这类模型能接受的最大连接数都不会高，一般在几百个左右。</p><h3 id="select模型"><a href="#select模型" class="headerlink" title="select模型"></a>select模型</h3><ol><li><p>最大并发数限制，因为一个进程所打开的 FD（文件描述符）是有限制的，由 FD_SETSIZE 设置，默认值是 1024/2048，因此 Select 模型的最大并发数就被相应限制了。自己改改这个FD_SETSIZE？想法虽好，可是先看看下面吧…</p></li><li><p>效率问题，select 每次调用都会线性扫描全部的 FD 集合，这样效率就会呈现线性下降，把FD_SETSIZE 改大的后果就是，大家都慢慢来，什么？都超时了？？！！</p></li><li><p>内核 / 用户空间 内存拷贝问题，如何让内核把 FD 消息通知给用户空间呢？在这个问题上 select 采取了内存拷贝方法。</p></li></ol><h3 id="poll-模型"><a href="#poll-模型" class="headerlink" title="poll 模型"></a>poll 模型</h3><p>基本上效率和 select 是相同的，select 缺点的 2 和 3 它都没有改掉。</p><h2 id="Epoll-的提升"><a href="#Epoll-的提升" class="headerlink" title="Epoll 的提升"></a>Epoll 的提升</h2><p>把其他模型逐个批判了一下，再来看看 Epoll 的改进之处吧，其实把 select 的缺点反过来那就是 Epoll 的优点了。</p><ol><li><p>Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048,  一般来说这个数目和系统内存关系很大，具体数目可以 <code>cat /proc/sys/fs/file-max</code> 察看。</p></li><li><p>效率提升，Epoll 最大的优点就在于它只管你 “活跃” 的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll 的效率就会远远高于 select 和 poll。</p></li><li><p>内存拷贝，Epoll 在这点上使用了 “共享内存”，这个内存拷贝也省略了。</p></li></ol><h2 id="Epoll为什么高效"><a href="#Epoll为什么高效" class="headerlink" title="Epoll为什么高效"></a>Epoll为什么高效</h2><p>Epoll 的高效和其数据结构的设计是密不可分的，这个下面就会提到。</p><p>首先回忆一下 select 模型，当有 I/O 事件到来时，select 通知应用程序有事件到了快去处理，而应用程序必须轮询所有的 FD 集合，测试每个 FD 是否有事件发生，并处理事件；</p><details><summary>代码像下面这样：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = select(maxfd+<span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">120</span>);</span><br><span class="line"><span class="keyword">if</span>(res &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_CONNECTION; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(allConnection[i],&amp;readfds))</span><br><span class="line">        &#123;</span><br><span class="line">            handleEvent(allConnection[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if(res == 0) handle timeout, res &lt; 0 handle error</span></span><br></pre></td></tr></table></figure></details><p>Epoll 不仅会告诉应用程序有 I/0 事件到来，还会告诉应用程序相关的信息，这些信息是应用程序填充的，因此根据这些信息应用程序就能直接定位到事件，而不必遍历整个 FD 集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">intres = epoll_wait(epfd, events, <span class="number">20</span>, <span class="number">120</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res;i++)</span><br><span class="line">&#123;</span><br><span class="line">    handleEvent(events[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Epoll-关键数据结构"><a href="#Epoll-关键数据结构" class="headerlink" title="Epoll 关键数据结构"></a>Epoll 关键数据结构</h2><p>前面提到 Epoll 速度快和其数据结构密不可分，其关键数据结构就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;      <span class="comment">// Epoll events</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;      <span class="comment">// User datavariable</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">   <span class="keyword">void</span> *ptr;</span><br><span class="line">   <span class="keyword">int</span> fd;</span><br><span class="line">   <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">   <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>结构体 <code>epoll_event</code> 被用于注册所感兴趣的事件和回传所发生待处理的事件. </p><p>其中 <code>epoll_data</code> 联合体用来保存触发事件的某个文件描述符相关的数据. </p><p>例如一个 client 连接到服务器，服务器通过调用 accept 函数可以得到于这个 client 对应的 socket 文件描述符，可以把这文件描述符赋给 epoll_data 的 fd 字段以便后面的读写操作在这个文件描述符上进行。epoll_event 结构体的 events 字段是表示感兴趣的事件和被触发的事件可能的取值为： </p><ul><li>EPOLLIN ：表示对应的文件描述符可以读；</li><li>EPOLLOUT：表示对应的文件描述符可以写；</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读</li><li>EPOLLERR：表示对应的文件描述符发生错误；</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET：表示对应的文件描述符有事件发生；</li></ul><p><strong>ET 和 LT 模式</strong></p><p>LT(level triggered) 是缺省的工作方式，并且同时支持 block 和 no-block socket. 在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的 select/poll 都是这种模型的代表。</p><p>ET (edge-triggered) 是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 EWOULDBLOCK 错误）。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知(only once)，不过在 TCP 协议中，ET 模式的加速效用仍需要更多的 benchmark 确认。</p><p>ET 和 LT 的区别在于 LT 事件不会丢弃，而是只要读 buffer 里面有数据可以让用户读，则不断的通知你。而 ET 则只在事件发生之时通知。可以简单理解为 LT 是水平触发，而 ET 则为边缘触发。</p><p>ET 模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用 ET 模式,需要一直 <code>read/write</code> 直到出错为止, 很多人反映为什么采用 ET 模式只接收了一部分数据就再也得不到通知了, 大多因为这样; 而 LT 模式是只要有数据没有处理就会一直通知下去的.</p><h2 id="使用-Epoll"><a href="#使用-Epoll" class="headerlink" title="使用 Epoll"></a>使用 Epoll</h2><p>既然 Epoll 相比 select 这么好，那么用起来如何呢？会不会很繁琐啊…先看看下面的三个函数吧，就知道 Epoll 的易用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>生成一个 Epoll 专用的文件描述符，其实是申请一个内核空间，用来存放你想关注的 socket fd 上是否发生以及发生了什么事件。size 就是你在这个 Epoll fd 上能关注的最大 socket fd 数，大小自定，只要内存足够。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</p><ul><li>EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；</li><li>EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件；</li><li>EPOLL_CTL_DEL：从 epfd 中删除一个 fd；</li></ul><p>第三个参数是需要监听的 fd，第四个参数是告诉内核需要监听什么事</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_event * events,<span class="keyword">int</span> maxevents,<span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>等待 I/O 事件的发生；参数说明：</p><ul><li>epfd: 由 <code>epoll_create()</code> 生成的 Epoll 专用的文件描述符；</li><li>epoll_event: 用于回传代处理事件的数组；</li><li>maxevents: 每次能处理的事件数；</li><li>timeout: 等待 I/O 事件发生的超时值；</li><li>返回发生事件数。</li></ul><hr><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>首先对服务端和客户端做下说明：</p><ul><li><p>我想实现的是客户端和服务端并发的程序，客户端通过配置并发数，说明有多少个用户去连接服务端。</p></li><li><p>客户端会发送消息：”Client: i send message Hello Server!”，其中 <code>i</code> 表示哪一个客户端；收到消息：”Recv Server Msg Content:%s\n”。</p></li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发送：Client: 1 send message "Hello Server!"</span><br><span class="line">接收：Recv Derver Msg Content:Hello, client fd: 6</span><br><span class="line">服务端收到后给客户端回复消息："Hello, client fd: i"，其中 i 表示服务端接收的 fd, 用户区别是哪一个客户端。接收客户端消息："Terminal Received Msg Content:%s\n"</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送：Hello, client fd: 6</span><br><span class="line">接收：Terminal Received Msg Content:Client: 1 send message "Hello Server!"</span><br></pre></td></tr></table></figure><p>备注：这里在接收到消息后，直接打印出消息，如果需要对消息进行处理（如果消息处理比较占用时间，不能立即返回，可以将该消息放入一个队列中，然后开启一个线程从队列中取消息进行处理，这样的话不会因为消息处理而阻塞 epoll）。libenent 好像对这种有 2 中处理方式，一个就是回调，要求回调函数，不占用太多的时间，基本能立即返回，另一种好像也是一个队列实现的，这个还需要研究。</p><p>服务端代码说明：</p><p>服务端在绑定监听后，开启了一个线程，用于负责接收客户端连接，加入到 epoll 中，这样只要 accept 到客户端的连接，就将其 add EPOLLIN 到 epoll 中，然后进入循环调用 epoll_wait，监听到读事件，接收数据，并将事件修改为 EPOLLOUT；反之监听到写事件，发送数据，并将事件修改为EPOLLIN。</p><details><summary>服务器代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cepollserver.h  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  C_EPOLL_SERVER_H  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  C_EPOLL_SERVER_H  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MAX_SOCKFD_COUNT 65535  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEpollServer</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    CEpollServer();  </span><br><span class="line">    ~CEpollServer();  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* chIp, <span class="keyword">int</span> iPort)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Listen</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListenThread</span><span class="params">( <span class="keyword">void</span>* lpVoid )</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span>        m_iEpollFd;  </span><br><span class="line">    <span class="keyword">int</span>        m_isock;  </span><br><span class="line">    <span class="keyword">pthread_t</span>       m_ListenThreadId;<span class="comment">// 监听线程句柄  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cepollserver.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line">CEpollServer::CEpollServer()  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">CEpollServer::~CEpollServer()  </span><br><span class="line">&#123;  </span><br><span class="line">    close(m_isock);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">bool</span> CEpollServer::InitServer(<span class="keyword">const</span> <span class="keyword">char</span>* pIp, <span class="keyword">int</span> iPort)  </span><br><span class="line">&#123;  </span><br><span class="line">    m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置非阻塞模式  </span></span><br><span class="line">    <span class="keyword">int</span> opts = O_NONBLOCK;  </span><br><span class="line">    <span class="keyword">if</span>(fcntl(m_iEpollFd,F_SETFL,opts)&lt;<span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"设置非阻塞模式失败!\n"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    m_isock = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">0</span> &gt; m_isock ) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket error!\n"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">　　  </span><br><span class="line">    sockaddr_in listen_addr;  </span><br><span class="line">    listen_addr.sin_family=AF_INET;  </span><br><span class="line">    listen_addr.sin_port=htons ( iPort );  </span><br><span class="line">    listen_addr.sin_addr.s_addr=htonl(INADDR_ANY);  </span><br><span class="line">    listen_addr.sin_addr.s_addr=inet_addr(pIp);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ireuseadd_on = <span class="number">1</span>;<span class="comment">//支持端口复用  </span></span><br><span class="line">    setsockopt(m_isock, SOL_SOCKET, SO_REUSEADDR, &amp;ireuseadd_on, <span class="keyword">sizeof</span>(ireuseadd_on) );  </span><br><span class="line">　　  </span><br><span class="line">    <span class="keyword">if</span> ( bind ( m_isock, ( sockaddr * ) &amp;listen_addr,<span class="keyword">sizeof</span> ( listen_addr ) ) !=<span class="number">0</span> ) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bind error\n"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( listen ( m_isock, <span class="number">20</span>) &lt;<span class="number">0</span> ) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"listen error!\n"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"服务端监听中...\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听线程，此线程负责接收客户端连接，加入到epoll中  </span></span><br><span class="line">    <span class="keyword">if</span> ( pthread_create( &amp;m_ListenThreadId, <span class="number">0</span>, ( <span class="keyword">void</span> * ( * ) ( <span class="keyword">void</span> * ) ) ListenThread, <span class="keyword">this</span> ) != <span class="number">0</span> ) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server 监听线程创建失败!!!"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听线程  </span></span><br><span class="line"><span class="keyword">void</span> CEpollServer::ListenThread( <span class="keyword">void</span>* lpVoid )  </span><br><span class="line">&#123;  </span><br><span class="line">    CEpollServer *pTerminalServer = (CEpollServer*)lpVoid;  </span><br><span class="line">    sockaddr_in remote_addr;  </span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span> (remote_addr);  </span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;  </span><br><span class="line">        <span class="keyword">int</span> client_socket = accept (pTerminalServer-&gt;m_isock, ( sockaddr * ) &amp;remote_addr,(<span class="keyword">socklen_t</span>*)&amp;len );  </span><br><span class="line">        <span class="keyword">if</span> ( client_socket &lt; <span class="number">0</span> ) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Server Accept失败!, client_socket: %d\n"</span>, client_socket);  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            struct epoll_event    ev;  </span><br><span class="line">            ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;  </span><br><span class="line">            ev.data.fd = client_socket;     <span class="comment">//记录socket句柄  </span></span><br><span class="line">            epoll_ctl(pTerminalServer-&gt;m_iEpollFd, EPOLL_CTL_ADD, client_socket, &amp;ev);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">　　  </span><br><span class="line"><span class="keyword">void</span> CEpollServer::Run()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>    <span class="title">events</span>[_<span class="title">MAX_SOCKFD_COUNT</span>];</span>  </span><br><span class="line">        <span class="keyword">int</span> nfds = epoll_wait( m_iEpollFd, events,  _MAX_SOCKFD_COUNT, <span class="number">-1</span> );  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> client_socket = events[i].data.fd;  </span><br><span class="line">            <span class="keyword">char</span> buffer[<span class="number">1024</span>];<span class="comment">//每次收发的字节数小于1024字节  </span></span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1024</span>);  </span><br><span class="line">            <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)<span class="comment">//监听到读事件，接收数据  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">int</span> rev_size = recv(events[i].data.fd,buffer, <span class="number">1024</span>,<span class="number">0</span>);  </span><br><span class="line">                <span class="keyword">if</span>( rev_size &lt;= <span class="number">0</span> )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"recv error: recv size: "</span> &lt;&lt; rev_size &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_del</span>;</span>  </span><br><span class="line">                    event_del.data.fd = events[i].data.fd;  </span><br><span class="line">                    event_del.events = <span class="number">0</span>;  </span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Terminal Received Msg Content:%s\n"</span>,buffer);  </span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>    <span class="title">ev</span>;</span>  </span><br><span class="line">                    ev.events = EPOLLOUT | EPOLLERR | EPOLLHUP;  </span><br><span class="line">                    ev.data.fd = client_socket;     <span class="comment">//记录socket句柄  </span></span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;ev);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLOUT)<span class="comment">//监听到写事件，发送数据  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">char</span> sendbuff[<span class="number">1024</span>];  </span><br><span class="line">                <span class="built_in">sprintf</span>(sendbuff, <span class="string">"Hello, client fd: %d\n"</span>, client_socket);  </span><br><span class="line">                <span class="keyword">int</span> sendsize = send(client_socket, sendbuff, <span class="built_in">strlen</span>(sendbuff)+<span class="number">1</span>, MSG_NOSIGNAL);  </span><br><span class="line">                <span class="keyword">if</span>(sendsize &lt;= <span class="number">0</span>)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_del</span>;</span>  </span><br><span class="line">                    event_del.data.fd = events[i].data.fd;  </span><br><span class="line">                    event_del.events = <span class="number">0</span>;  </span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Server reply msg ok! buffer: %s\n"</span>, sendbuff);  </span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>    <span class="title">ev</span>;</span>  </span><br><span class="line">                    ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;  </span><br><span class="line">                    ev.data.fd = client_socket;     <span class="comment">//记录socket句柄  </span></span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;ev);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"EPOLL ERROR\n"</span> &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, events[i].data.fd, &amp;events[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>客户端代码：</summary><p>说明：测试是两个并发进行测试，每一个客户端都是一个长连接。代码中在连接服务器（ConnectToServer）时将用户 ID 和 socketid 关联起来。用户 ID 和 socketid 是一一对应的关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DEFINE_EPOLLCLIENT_H_  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DEFINE_EPOLLCLIENT_H_  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MAX_SOCKFD_COUNT 65535  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* @brief 用户状态 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _EPOLL_USER_STATUS_EM  </span><br><span class="line">&#123;  </span><br><span class="line">    FREE = <span class="number">0</span>,  </span><br><span class="line">    CONNECT_OK = <span class="number">1</span>,<span class="comment">//连接成功  </span></span><br><span class="line">    SEND_OK = <span class="number">2</span>,<span class="comment">//发送成功  </span></span><br><span class="line">    RECV_OK = <span class="number">3</span>,<span class="comment">//接收成功  </span></span><br><span class="line">&#125;EPOLL_USER_STATUS_EM;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*@brief </span></span><br><span class="line"><span class="comment">*@CEpollClient class 用户状态结构体 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserStatus</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    EPOLL_USER_STATUS_EM iUserStatus;<span class="comment">//用户状态  </span></span><br><span class="line">    <span class="keyword">int</span> iSockFd;<span class="comment">//用户状态关联的socketfd  </span></span><br><span class="line">    <span class="keyword">char</span> cSendbuff[<span class="number">1024</span>];<span class="comment">//发送的数据内容  </span></span><br><span class="line">    <span class="keyword">int</span> iBuffLen;<span class="comment">//发送数据内容的长度  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uEpollEvents;<span class="comment">//Epoll events  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEpollClient</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:CEpollClient </span></span><br><span class="line"><span class="comment">    * 描述:构造函数 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserCount  </span></span><br><span class="line"><span class="comment">    * @param [in] pIP IP地址 </span></span><br><span class="line"><span class="comment">    * @param [in] iPort 端口号 </span></span><br><span class="line"><span class="comment">    * @return 无返回 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    CEpollClient(<span class="keyword">int</span> iUserCount, <span class="keyword">const</span> <span class="keyword">char</span>* pIP, <span class="keyword">int</span> iPort);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:CEpollClient </span></span><br><span class="line"><span class="comment">    * 描述:析构函数 </span></span><br><span class="line"><span class="comment">    * @return 无返回 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    ~CEpollClient();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:RunFun </span></span><br><span class="line"><span class="comment">    * 描述:对外提供的接口，运行epoll类 </span></span><br><span class="line"><span class="comment">    * @return 无返回值 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">RunFun</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:ConnectToServer </span></span><br><span class="line"><span class="comment">    * 描述:连接到服务器 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserId 用户ID </span></span><br><span class="line"><span class="comment">    * @param [in] pServerIp 连接的服务器IP </span></span><br><span class="line"><span class="comment">    * @param [in] uServerPort 连接的服务器端口号 </span></span><br><span class="line"><span class="comment">    * @return 成功返回socketfd,失败返回的socketfd为-1 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ConnectToServer</span><span class="params">(<span class="keyword">int</span> iUserId,<span class="keyword">const</span> <span class="keyword">char</span> *pServerIp,<span class="keyword">unsigned</span> <span class="keyword">short</span> uServerPort)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:SendToServerData </span></span><br><span class="line"><span class="comment">    * 描述:给服务器发送用户(iUserId)的数据 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserId 用户ID </span></span><br><span class="line"><span class="comment">    * @return 成功返回发送数据长度 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SendToServerData</span><span class="params">(<span class="keyword">int</span> iUserId)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:RecvFromServer </span></span><br><span class="line"><span class="comment">    * 描述:接收用户回复消息 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserId 用户ID </span></span><br><span class="line"><span class="comment">    * @param [in] pRecvBuff 接收的数据内容 </span></span><br><span class="line"><span class="comment">    * @param [in] iBuffLen 接收的数据长度 </span></span><br><span class="line"><span class="comment">    * @return 成功返回接收的数据长度，失败返回长度为-1 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">RecvFromServer</span><span class="params">(<span class="keyword">int</span> iUserid,<span class="keyword">char</span> *pRecvBuff,<span class="keyword">int</span> iBuffLen)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:CloseUser </span></span><br><span class="line"><span class="comment">    * 描述:关闭用户 </span></span><br><span class="line"><span class="comment">    * @param [in] iUserId 用户ID </span></span><br><span class="line"><span class="comment">    * @return 成功返回true </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CloseUser</span><span class="params">(<span class="keyword">int</span> iUserId)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * @brief </span></span><br><span class="line"><span class="comment">    * 函数名:DelEpoll </span></span><br><span class="line"><span class="comment">    * 描述:删除epoll事件 </span></span><br><span class="line"><span class="comment">    * @param [in] iSockFd socket FD </span></span><br><span class="line"><span class="comment">    * @return 成功返回true </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DelEpoll</span><span class="params">(<span class="keyword">int</span> iSockFd)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span>    m_iUserCount;<span class="comment">//用户数量；  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UserStatus</span> *<span class="title">m_pAllUserStatus</span>;</span><span class="comment">//用户状态数组  </span></span><br><span class="line">    <span class="keyword">int</span>    m_iEpollFd;<span class="comment">//需要创建epollfd  </span></span><br><span class="line">    <span class="keyword">int</span>    m_iSockFd_UserId[_MAX_SOCKFD_COUNT];<span class="comment">//将用户ID和socketid关联起来  </span></span><br><span class="line">    <span class="keyword">int</span>    m_iPort;<span class="comment">//端口号  </span></span><br><span class="line">    <span class="keyword">char</span>   m_ip[<span class="number">100</span>];<span class="comment">//IP地址  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cepollclient.h"</span>  </span></span><br><span class="line"></span><br><span class="line">CEpollClient::CEpollClient(<span class="keyword">int</span> iUserCount, <span class="keyword">const</span> <span class="keyword">char</span>* pIP, <span class="keyword">int</span> iPort)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">strcpy</span>(m_ip, pIP);  </span><br><span class="line">    m_iPort = iPort;  </span><br><span class="line">    m_iUserCount = iUserCount;  </span><br><span class="line">    m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT);  </span><br><span class="line">    m_pAllUserStatus = (struct UserStatus*)<span class="built_in">malloc</span>(iUserCount*<span class="keyword">sizeof</span>(struct UserStatus));  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iuserid=<span class="number">0</span>; iuserid&lt;iUserCount ; iuserid++) &#123;  </span><br><span class="line">        m_pAllUserStatus[iuserid].iUserStatus = FREE;  </span><br><span class="line">        <span class="built_in">sprintf</span>(m_pAllUserStatus[iuserid].cSendbuff, <span class="string">"Client: %d send message \"Hello Server!\"\r\n"</span>, iuserid);  </span><br><span class="line">        m_pAllUserStatus[iuserid].iBuffLen = <span class="built_in">strlen</span>(m_pAllUserStatus[iuserid].cSendbuff) + <span class="number">1</span>;  </span><br><span class="line">        m_pAllUserStatus[iuserid].iSockFd = <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">memset</span>(m_iSockFd_UserId, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(m_iSockFd_UserId));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">CEpollClient::~CEpollClient()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">free</span>(m_pAllUserStatus);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CEpollClient::ConnectToServer(<span class="keyword">int</span> iUserId,<span class="keyword">const</span> <span class="keyword">char</span> *pServerIp,<span class="keyword">unsigned</span> <span class="keyword">short</span> uServerPort)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>( (m_pAllUserStatus[iUserId].iSockFd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>) ) &lt; <span class="number">0</span> ) &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: init socket fail, reason is:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="string">",errno is:"</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        m_pAllUserStatus[iUserId].iSockFd = <span class="number">-1</span>;  </span><br><span class="line">        <span class="keyword">return</span>  m_pAllUserStatus[iUserId].iSockFd;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span>  </span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));  </span><br><span class="line">    addr.sin_family = AF_INET;  </span><br><span class="line">    addr.sin_port = htons(uServerPort);  </span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(pServerIp);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> ireuseadd_on = <span class="number">1</span>;<span class="comment">//支持端口复用  </span></span><br><span class="line">    setsockopt(m_pAllUserStatus[iUserId].iSockFd, SOL_SOCKET, SO_REUSEADDR, &amp;ireuseadd_on, <span class="keyword">sizeof</span>(ireuseadd_on));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ul = <span class="number">1</span>;  </span><br><span class="line">    ioctl(m_pAllUserStatus[iUserId].iSockFd, FIONBIO, &amp;ul); <span class="comment">//设置为非阻塞模式   </span></span><br><span class="line">    connect(m_pAllUserStatus[iUserId].iSockFd, (<span class="keyword">const</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));  </span><br><span class="line">    m_pAllUserStatus[iUserId].iUserStatus = CONNECT_OK;  </span><br><span class="line">    m_pAllUserStatus[iUserId].iSockFd = m_pAllUserStatus[iUserId].iSockFd;  </span><br><span class="line">    <span class="keyword">return</span> m_pAllUserStatus[iUserId].iSockFd;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CEpollClient::SendToServerData(<span class="keyword">int</span> iUserId)  </span><br><span class="line">&#123;  </span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//此处控制发送频率，避免狂打日志，正常使用中需要去掉  </span></span><br><span class="line">    <span class="keyword">int</span> isendsize = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">if</span>( CONNECT_OK == m_pAllUserStatus[iUserId].iUserStatus || RECV_OK == m_pAllUserStatus[iUserId].iUserStatus) &#123;  </span><br><span class="line">        isendsize = send(m_pAllUserStatus[iUserId].iSockFd, m_pAllUserStatus[iUserId].cSendbuff, m_pAllUserStatus[iUserId  </span><br><span class="line">].iBuffLen, MSG_NOSIGNAL);  </span><br><span class="line">        <span class="keyword">if</span>(isendsize &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: SendToServerData, send fail, reason is:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="string">",errno is:"</span>&lt;&lt;errno&lt;  </span><br><span class="line">&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[CEpollClient info]: iUserId: %d Send Msg Content:%s\n"</span>, iUserId, m_pAllUserStatus[iUserId].cSendbuff  </span><br><span class="line">);  </span><br><span class="line">            m_pAllUserStatus[iUserId].iUserStatus = SEND_OK;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> isendsize;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CEpollClient::RecvFromServer(<span class="keyword">int</span> iUserId,<span class="keyword">char</span> *pRecvBuff,<span class="keyword">int</span> iBuffLen) </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> irecvsize = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(SEND_OK == m_pAllUserStatus[iUserId].iUserStatus) &#123;  </span><br><span class="line">        irecvsize = recv(m_pAllUserStatus[iUserId].iSockFd, pRecvBuff, iBuffLen, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &gt; irecvsize) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: iUserId: "</span> &lt;&lt; iUserId &lt;&lt; <span class="string">"RecvFromServer, recv fail, reason is:"</span>&lt;&lt;strerror(errn  </span><br><span class="line">o)&lt;&lt;<span class="string">",errno is:"</span>&lt;&lt;errno&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == irecvsize) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[warning:] iUserId: "</span>&lt;&lt; iUserId &lt;&lt; <span class="string">"RecvFromServer, STB收到数据为0，表示对方断开连接,irecvsize:"</span>&lt;&lt;ire  </span><br><span class="line">cvsize&lt;&lt;<span class="string">",iSockFd:"</span>&lt;&lt; m_pAllUserStatus[iUserId].iSockFd &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Recv Server Msg Content:%s\n"</span>, pRecvBuff);  </span><br><span class="line">            m_pAllUserStatus[iUserId].iUserStatus = RECV_OK;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> irecvsize;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">bool</span> CEpollClient::CloseUser(<span class="keyword">int</span> iUserId)  </span><br><span class="line">&#123;  </span><br><span class="line">    close(m_pAllUserStatus[iUserId].iSockFd);  </span><br><span class="line">    m_pAllUserStatus[iUserId].iUserStatus = FREE;  </span><br><span class="line">    m_pAllUserStatus[iUserId].iSockFd = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">      </span><br><span class="line"><span class="keyword">int</span> CEpollClient::RunFun()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> isocketfd = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iuserid=<span class="number">0</span>; iuserid&lt;m_iUserCount; iuserid++) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span>  </span><br><span class="line">        isocketfd = ConnectToServer(iuserid, m_ip, m_iPort);  </span><br><span class="line">        <span class="keyword">if</span>(isocketfd &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: RunFun, connect fail"</span> &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        m_iSockFd_UserId[isocketfd] = iuserid;<span class="comment">//将用户ID和socketid关联起来  </span></span><br><span class="line">  </span><br><span class="line">        event.data.fd = isocketfd;  </span><br><span class="line">        event.events = EPOLLIN|EPOLLOUT|EPOLLERR|EPOLLHUP;  </span><br><span class="line">  </span><br><span class="line">        m_pAllUserStatus[iuserid].uEpollEvents = event.events;  </span><br><span class="line">        epoll_ctl(m_iEpollFd, EPOLL_CTL_ADD, event.data.fd, &amp;event);  </span><br><span class="line">　　&#125;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[_<span class="title">MAX_SOCKFD_COUNT</span>];</span>  </span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>];  </span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="number">1024</span>);  </span><br><span class="line">        <span class="keyword">int</span> nfds = epoll_wait(m_iEpollFd, events, _MAX_SOCKFD_COUNT, <span class="number">100</span> );<span class="comment">//等待epoll事件的产生  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ifd=<span class="number">0</span>; ifd&lt;nfds; ifd++)<span class="comment">//处理所发生的所有事件  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_nfds</span>;</span>  </span><br><span class="line">            <span class="keyword">int</span> iclientsockfd = events[ifd].data.fd;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"events[ifd].data.fd: "</span> &lt;&lt; events[ifd].data.fd &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">            <span class="keyword">int</span> iuserid = m_iSockFd_UserId[iclientsockfd];<span class="comment">//根据socketfd得到用户ID  </span></span><br><span class="line">            <span class="keyword">if</span>( events[ifd].events &amp; EPOLLOUT )  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">int</span> iret = SendToServerData(iuserid);  </span><br><span class="line">                <span class="keyword">if</span>( <span class="number">0</span> &lt; iret )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    event_nfds.events = EPOLLIN|EPOLLERR|EPOLLHUP;  </span><br><span class="line">                    event_nfds.data.fd = iclientsockfd;  </span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;event_nfds);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error:] EpollWait, SendToServerData fail, send iret:"</span>&lt;&lt;iret&lt;&lt;<span class="string">",iuserid:"</span>&lt;&lt;iuser  </span><br><span class="line">                        id&lt;&lt;<span class="string">",fd:"</span>&lt;&lt;events[ifd].data.fd&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                    DelEpoll(events[ifd].data.fd);  </span><br><span class="line">                    CloseUser(iuserid);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( events[ifd].events &amp; EPOLLIN )<span class="comment">//监听到读事件，接收数据  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">int</span> ilen = RecvFromServer(iuserid, buffer, <span class="number">1024</span>);  </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> &gt; ilen)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error]: RunFun, recv fail, reason is:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="string">",errno is:"</span>&lt;&lt;errno&lt;&lt;e  </span><br><span class="line">                        ndl;  </span><br><span class="line">                    DelEpoll(events[ifd].data.fd);  </span><br><span class="line">                    CloseUser(iuserid);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == ilen)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient warning:] server disconnect,ilen:"</span>&lt;&lt;ilen&lt;&lt;<span class="string">",iuserid:"</span>&lt;&lt;iuserid&lt;&lt;<span class="string">",fd:"</span>&lt;&lt;events[  </span><br><span class="line">                        ifd].data.fd&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                    DelEpoll(events[ifd].data.fd);  </span><br><span class="line">                    CloseUser(iuserid);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    m_iSockFd_UserId[iclientsockfd] = iuserid;<span class="comment">//将socketfd和用户ID关联起来  </span></span><br><span class="line">                    event_nfds.data.fd = iclientsockfd;  </span><br><span class="line">                    event_nfds.events = EPOLLOUT|EPOLLERR|EPOLLHUP;  </span><br><span class="line">                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;event_nfds);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;<span class="string">"[CEpollClient error:] other epoll error"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                DelEpoll(events[ifd].data.fd);  </span><br><span class="line">                CloseUser(iuserid);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">　　  </span><br><span class="line"><span class="keyword">bool</span> CEpollClient::DelEpoll(<span class="keyword">int</span> iSockFd)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">bool</span> bret = <span class="literal">false</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_del</span>;</span>  </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &lt; iSockFd)  </span><br><span class="line">    &#123;  </span><br><span class="line">        event_del.data.fd = iSockFd;  </span><br><span class="line">        event_del.events = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">if</span>( <span class="number">0</span> == epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del) )  </span><br><span class="line">        &#123;  </span><br><span class="line">            bret = <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"[SimulateStb error:] DelEpoll,epoll_ctl error,iSockFd:"</span>&lt;&lt;iSockFd&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        m_iSockFd_UserId[iSockFd] = <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        bret = <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> bret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>服务器主程序：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cepollserver.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    CEpollServer  theApp;  </span><br><span class="line">    theApp.InitServer(<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>);  </span><br><span class="line">    theApp.Run();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>客户端主程序：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cepollclient.h"</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    CEpollClient *pCEpollClient = <span class="keyword">new</span> CEpollClient(<span class="number">2</span>, <span class="string">"127.0.0.1"</span>, <span class="number">8000</span>);  </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pCEpollClient)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[epollclient error]:main init"</span>&lt;&lt;<span class="string">"Init CEpollClient fail"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    pCEpollClient-&gt;RunFun();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != pCEpollClient)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">delete</span> pCEpollClient;  </span><br><span class="line">        pCEpollClient = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Epoll 可是当前在 Linux 下开发大规模并发网络程序的热门人选，Epoll 在 Linux2.6 内核中正式引入，和 select 相似，其实都 I/O 多路复用技术而已，并没有什么神秘的。&lt;/p&gt;
&lt;p&gt;其实在 Linux 下设计并发网络程序，向来不缺少方法，比如典型的 Apache 模型（Process Per Connection，简称 PPC），TPC（Thread Per Connection）模型，以及 select 模型和 poll 模型，那为何还要再引入 Epoll 这个东东呢？那还是有得说说的…&lt;/p&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>C 代码优化小贴士</title>
    <link href="http://miaopei.github.io/2016/07/06/Program-C/c-code-opt/"/>
    <id>http://miaopei.github.io/2016/07/06/Program-C/c-code-opt/</id>
    <published>2016-07-06T02:14:50.000Z</published>
    <updated>2019-06-14T06:47:57.606Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><span style="color: #000000">虽然对于优化C代码有很多有效的指导方针，但是对于彻底地了解编译器和你工作的机器依然无法取代，通常，加快程序的速度也会加大代码量。这些增加的代码也会影响一个程序的复杂度和可读性，这是不可接受的，比如你在一些小型的设备上编程，例如：移动设备、PDA……，这些有着严格的内存限制，于是，在优化的座右铭是:写代码在内存和速度都应该优化。</span></p><h2>整型数 / Integers</h2><p>在我们知道使用的数不可能是负数的时候，应该使用unsigned int取代int，一些处理器处理整数算数运算的时候unsigned int比int快，于是，在一个紧致的循环里面定义一个整型变量，最好这样写代码：</p><pre class="brush: c; gutter: true">register unsigned int variable_name;</pre><p>然而，我们不能保证编译器会注意到那个register关键字，也有可能，对某种处理器来说，有没有unsigned是一样的。这两个关键字并不是可以在所有的编译器中应用。</p>**记住，整形数运算要比浮点数运算快得多，因为处理器可以直接进行整型数运算，浮点数运算需要依赖于外部的浮点数处理器或者浮点数数学库。**<p>我们处理小数的时候要精确点些（比如我们在做一个简单的统计程序时），要限制结果不能超过100，要尽可能晚的把它转化成浮点数。</p><p>还有一个整形提升的问题，比如下面这个例子：<pre class="brush: c; gutter: true">size_t n = 10;int i ;for(i = -1; i < n; ++i){printf("%d\n",i);}</pre>这段代码实际上什么也不会输出，因为size_t是unsigned int类型，i会自动转换成unsigned int就变成了一个很大的正数，所以和n比较自然什么都不会输出。</p><p>在算术运算中，char和short会自动转换成int，转换的原则就是如果int类型能过包括操作数类型的所有范围，则操作数（比如unsigned short）转换成int，否则转换成unsigned int，int和long类型运算以此类推，**总是向着精度更高、位更长的类型转换。**</p><h2>除法和余数 / Division and Remainder</h2><p>在标准的处理器中，根据分子和分母的不同，一个32位的除法需要20-140个时钟周期来执行完成，等于一个固定的时间加上每个位被除的时间。</p><p>Time (分子/ 分母) = C0 + C1* log<sub>2</sub> (分子/分母)</p><p>= C0 + C1 * (log<sub>2</sub> (分子) &#8211; log<sub>2</sub> (分母)).<br>现在的ARM处理器需要消耗20+4.3N个时钟周期，这是一个非常费时的操作，要尽可能的避免。在有些情况下，除法表达式可以用乘法表达是来重写。比方说，(a/b)&gt;c可以写成a&gt;(c*b),条件是我们已经知道b为非负数而且b*c不会超过整型数的取值范围。如果我们能够确定其中的一个操作数为unsigned，那么使用无符号除法将会更好，因为它要比有符号除法快得多。</p><h2>合并除法运算和取余运算 / Combining division and remainder</h2><p>在一些情况下，除法运算和取余运算都需要用到，在这种情况下，编译器会将除法运算和取余运算合并，因为除法运算总是同时返回商和余数。如果两个运算都要用到，我们可以将他们写到一起。</p><pre class="brush: c; gutter: true">typedef unsigned int uint;uint div32u (uint a) {     return a / 32;}int div32s (int a) {     return a / 32;}</pre><p>这两种除法都会避免调用除法函数（进行移位操作），另外，无符号的除法要比有符号的除法使用更少的指令。有符号的除法要耗费更多的时间，因为这种除法是使最终结果趋向于零的，而移位则是趋向于负无穷。</p><h2>取模运算的替换 / An alternative for modulo arithmetic</h2><p>我们一般使用取余运算进行取模，不过，有时候使用 if 语句来重写也是可行的。考虑下面的两个例子：</p><pre class="brush: c; gutter: true">uint modulo_func1 (uint count){    return (++count % 60);}uint modulo_func2 (uint count){    if (++count &gt;= 60)        count = 0;    return (count);}</pre><p>第二个例子要比第一个更可取，因为由它产生的代码会更快，注意：这只是在count取值范围在0 – 59之间的时候才行。</p><p>但是我们可以使用如下的代码（笔者补充）实现等价的功能：</p><pre class="brush: c; gutter: true">uint modulo_func3 (uint count){    if (++count &gt;= 60)        count %= 60;    return (count);}</pre><h2>使用数组索引 / Using array indices</h2><p>假设你要依据某个变量的值，设置另一个变量的取值为特定的字符，你可能会这样做：</p><pre class="brush: c; gutter: true">switch(queue) {    case 0 :   letter = &#039;W&#039;;        break;    case 1 :   letter = &#039;S&#039;;        break;    case 2 :   letter = &#039;U&#039;;        break;}</pre><p>或者这样：</p><pre class="brush: c; gutter: true">if(queue == 0)    letter = &#039;W&#039;;else if ( queue == 1 )    letter = &#039;S&#039;;else    letter = &#039;U&#039;;</pre><p>有一个简洁且快速的方式是简单的将变量的取值做成一个字符串索引，例如：</p><pre class="brush: c; gutter: true">static char *classes = &quot;WSU&quot;;letter = classes[queue];</pre><h2> 全局变量 / Global variables</h2><p>全局变量不会被分配在寄存器上，修改全局变量需要通过指针或者调用函数的方式间接进行。所以编译器不会将全局变量存储在寄存器中，那样会带来额外的、不必要的负担和存储空间。所以在比较关键的循环中，我们要不使用全局变量。<br></p>******如果一个函数要频繁的使用全局变量，我们可以使用局部变量，作为全局变量的拷贝，这样就可以使用寄存器了。条件是本函数调用的任何子函数不使用这些全局变量。**<p>举个例子：</p><pre class="brush: c; gutter: true">int f(void);int g(void);int errs;void test1(void){    errs += f();    errs += g();}void test2(void){    int localerrs = errs;    localerrs += f();    localerrs += g();    errs = localerrs;}</pre><p>可以看到test1()中每次加法都需要读取和存储全局变量errs，而在test2()中，localerrs分配在寄存器上，只需要一条指令。</p><h2>使用别名 / Using Aliases</h2><p>考虑下面的例子：</p><pre class="brush: c; gutter: true">void func1( int *data ){    int i;    for(i = 0; i &lt; 10; i++)        anyfunc(*data, i);}</pre><p>即使*data从来没有变化，编译器却不知道anyfunc()没有修改它，于是程序每次用到它的时候，都要把它从内存中读出来，可能它只是某些变量的别名，这些变量在程序的其他部分被修改。如果能够确定它不会被改变，我们可以这样写：</p><pre class="brush: c; gutter: true">void func1( int *data ){int i;int localdata;localdata = *data;for(i=0; i&lt;10; i++)anyfunc(localdata, i);}</pre><p>这样会给编译器优化工作更多的选择余地。</p><h2>活跃变量和泄漏 / Live variables and spilling</h2><p>寄存器的数量在每个处理器当中都是固定的，所以在程序的某个特定的位置，可以保存在寄存器中的变量的数量是有限制的。有些编译器支持“生命周期分割”（live-range splitting），也就是说在函数的不同部分，变量可以被分配到不同的寄存器或者内存中。变量的生存范围被定义成：起点是对该变量的一次空间分配，终点是在下次空间分配之前的最后一次使用之间。在这个范围内，变量的值是合法的，是活的。在生存范围之外，变量不再被使用，是死的，它的寄存器可以供其他变量使用，这样，编译器就可以安排更多的变量到寄存器当中。<br>可分配到寄存器的变量需要的寄存器数量等于经过生命范围重叠的变量的数目，如果这个数目超过可用的寄存器的数量，有些变量就必须被暂时的存储到内存中。这种处理叫做“泄漏(spilling)”。<br>编译器优先释放最不频繁使用的变量，将释放的代价降到最低。可以通过以下方式避免变量的“释放”：</p><ul><li>限制活跃变量的最大数目：通常可以使用简单小巧的表达式，在函数内部不使用太多的变量。把大的函数分割成更加简单的、更加小巧的多个函数，也可能会有所帮助。</li><li>使用关键字register修饰最经常使用的变量：告诉编译器这个变量将会被经常用到，要求编译器使用非常高的优先级将此变量分配到寄存器中。尽管如此，在某些情况下，变量还是可能被泄漏。</li></ul><h2>变量类型 / Variable Types</h2><p>C编译器支持基本的变量类型：char、short、int、long(signed、unsigned)、float、double。为变量定义最恰当的类型，非常重要，因为这样可以减少代码和数据的长度，可以非常显著的提高效率。</p><h2>局部变量 / Local variables</h2><p>如果可能，局部变量要避免使用char和short。对于char和short类型，编译器在每次分配空间以后，都要将这种局部变量的尺寸减少到8位或16位。这对于符号变量来说称为符号扩展，对无符号变量称为无符号扩展。这种操作是通过将寄存器左移24或16位，然后再有符号（或无符号的）右移同样的位数来实现的，需要两条指令（无符号字节变量的无符号扩展需要一条指令）。<br>这些移位操作可以通过使用int和unsigned int的局部变量来避免。这对于那些首先将数据调到局部变量然后利用局部变量进行运算的情况尤其重要。即使数据以8位或16位的形式输入或输出，把他们当作32位来处理仍是有意义的。<br>我们来考虑下面的三个例子函数：</p><pre class="brush: c; gutter: true">int wordinc (int a){     return a + 1;}short shortinc (short a){     return a + 1;}char charinc (char a){     return a + 1;}</pre><p>他们的运算结果是相同的，但是第一个代码片断要比其他片断运行的要快。</p><h2>指针 / Pointers</h2><p>如果可能，我们应该使用结构体的引用作为参数，也就是结构体的指针，否则，整个结构体就会被压入堆栈，然后传递，这会降低速度。程序适用值传递可能需要几K字节，而一个简单的指针也可以达到同样的目的，只需要几个字节就可以了。<br>如果在函数内部不会改变结构体的内容，那么就应该将参数声明为const型的指针。举个例子：</p><pre class="brush: c; gutter: true">void print_data_of_a_structure (const Thestruct  *data_pointer){     ...printf contents of the structure...}</pre><p>这个例子代码告知编译器在函数内部不会改变外部结构体的内容，访问他们的时候，不需要重读。还可以确保编译器捕捉任何修改这个只读结构体的代码，给结构体以额外的保护。</p><h2>指针链 / Pointer chains</h2><p>指针链经常被用来访问结构体的信息，比如，下面的这段常见的代码：</p><pre class="brush: c; gutter: true">typedef struct { int x, y, z; } Point3;typedef struct { Point3 *pos, *direction; } Object;void InitPos1(Object *p){    p-&gt;pos-&gt;x = 0;    p-&gt;pos-&gt;y = 0;    p-&gt;pos-&gt;z = 0;}</pre><p>代码中，处理器在每次赋值操作的时候都要重新装载p-&gt;pos，因为编译器不知道p-&gt;pos-&gt;x不是p-&gt;pos的别名。更好的办法是将p-&gt;pos缓存成一个局部变量，如下：</p><pre class="brush: c; gutter: true">void InitPos2(Object *p){     Point3 *pos = p-&gt;pos;    pos-&gt;x = 0;     pos-&gt;y = 0;    pos-&gt;z = 0;}</pre><p>另一个可能的方法是将Point3结构体包含在Object结构体中，完全避免指针的使用。</p><h2>条件的执行 / Conditional Execution</h2><p>条件执行主要用在if语句中，同时也会用到由关系运算(&lt;,==,&gt;等)或bool运算(&amp;&amp;, !等)组成的复杂的表达式。尽可能的保持if和else语句的简单是有好处的，这样才能很好的条件化。关系表达式应该被分成包含相似条件的若干块。<br>下面的例子演示了编译器如何使用条件执行：</p><pre class="brush: c; gutter: true">int g(int a, int b, int c, int d){    if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &lt; 0 &amp;&amp; d &lt; 0)  //分组化的条件被捆绑在一起        return a + b + c + d;    return -1;}</pre><p>条件被分组，便以其能够条件化他们。</p><h2>Boolean表达式和范围检查 / Boolean Expressions &amp; Range checking</h2><p>有一种常见的boolean表达式被用来检查是否一个变量取值在某个特定的范围内，比方说，检查一个点是否在一个窗口内。</p><pre class="brush: c; gutter: true">bool PointInRectangelArea (Point p, Rectangle *r){    return (p.x &gt;= r-&gt;xmin &amp;&amp; p.x &lt; r-&gt;xmax &amp;&amp; p.y &gt;= r-&gt;ymin &amp;&amp; p.y &lt; r-&gt;ymax);}</pre><p>这里还有一个更快的方法：把(x &gt;= min &amp;&amp; x &lt; max) 转换成 (unsigned)(x-min) &lt; (max-min). 尤其是min为0时，更为有效。下面是优化后的代码：</p><pre class="brush: c; gutter: true">bool PointInRectangelArea (Point p, Rectangle *r){    return ((unsigned) (p.x - r-&gt;xmin) &lt; r-&gt;xmax &amp;&amp; (unsigned) (p.y - r-&gt;ymin) &lt; r-&gt;ymax);}</pre><h2>Boolean表达式&amp;与零的比较 / Boolean Expressions &amp; Compares with zero</h2><p>在比较(CMP)指令后，相应的处理器标志位就会被设置。这些标志位也可以被其他的指令设置，诸如MOV, ADD, AND, MUL, 也就是基本的数学和逻辑运算指令（数据处理指令）。假如一条数据处理指令要设置这些标志位，那么N和Z标志位的设置方法跟把数字和零比较的设置方法是一样的。N标志位表示结果是不是负数，Z标志位表示结果是不是零。<br>在C语言中，处理器中的N和Z标志位对应的有符号数的关系运算符是x &lt; 0, x &gt;= 0, x == 0, x != 0，无符号数对应的是x == 0, x != 0 (or x &gt; 0)。<br>C语言中，每用到一个关系运算符，编译器就会产生一个比较指令。如果关系运算符是上面的其中一个，在数据处理指令紧跟比较指令的情况下，编译器就会将比较指令优化掉。比如：</p><pre class="brush: c; gutter: true">int aFunction(int x, int y){    if (x + y &lt; 0)        return 1;    else        return 0;}</pre><p>这样做，会在关键循环中节省比较指令，使代码长度减少，效率增加。C语言中没有借位(carry)标志位和溢出(overflow)标志位的概念，所以如果不使用内嵌汇编语言，要访问C和V标志位是不可能的。尽管如此，编译器支持借位标志位（无符号数溢出），比方说：</p><pre class="brush: c; gutter: true">int sum(int x, int y){     int res;     res = x + y;     if ((unsigned) res &lt; (unsigned) x) // carry set?  //        res++;     return res;}</pre><h2>惰性评估计算 / Lazy Evaluation Exploitation</h2><p>在类似与这样的 if(a&gt;10 &amp;&amp; b=4) 语句中, 确保AND表达式的第一部分最有可能为false, 结果第二部分极有可能不被执行.</p><p>用switch() 代替if&#8230;else&#8230;，在条件选择比较多的情况下，可以用if…else…else…，像这样：</p><pre class="brush: c; gutter: true">if( val == 1)    dostuff1();else if (val == 2)    dostuff2();else if (val == 3)    dostuff3();</pre><p>使用switch可以更快：</p><pre class="brush: c; gutter: true">switch( val ){    case 1: dostuff1(); break;    case 2: dostuff2(); break;    case 3: dostuff3(); break;}</pre><p>在if语句中，即使是最后一个条件成立，也要先判断所有前面的条件是否成立。Switch语句能够去除这些额外的工作。如果你不得不使用if…else，那就把最可能的成立的条件放在前面。</p><h2>二分分解 / Binary Breakdown</h2><p>把判断条件做成二进制的风格，比如，不要使用下面的列表：</p><pre class="brush: c; gutter: true">if(a == 1) {     } else if(a == 2) {     } else if(a == 3) {     } else if(a == 4) {     } else if(a == 5) {     } else if(a == 6) {     } else if(a == 7) {     } else if(a == 8) {     }}</pre><p>而采用：</p><pre class="brush: c; gutter: true">if(a &lt;= 4) {     if(a == 1) {     } else if(a == 2) {     } else if(a == 3) {     } else if(a == 4) {     } } else {     if(a == 5) {     } else if(a == 6) {     } else if(a == 7) {     } else if(a == 8) {     } }</pre><p>甚至：</p><pre class="brush: c; gutter: true">if(a &lt;= 4) {     if(a &lt;= 2) {         if(a == 1) {                 /* a is 1 */         } else {                 /* a must be 2 */         }     } else {         if(a == 3) {                 /* a is 3 */         } else {                 /* a must be 4 */         }     } } else {     if(a &lt;= 6) {         if(a == 5) {                 /* a is 5 */         } else {                 /* a must be 6 */         }     } else {         if(a == 7) {                 /* a is 7 */         } else {                 /* a must be 8 */         }     } }</pre><p>慢速、低效：</p><pre class="brush: c; gutter: true">c = getch();switch(c){    case &#039;A&#039;: {        do something;          break;      }     case &#039;H&#039;: {        do something;        break;    }      case &#039;Z&#039;: {         do something;         break;     }}</pre><p>快速、高效：</p><pre class="brush: c; gutter: true">c = getch();switch(c) {    case 0: {        do something;        break;    }      case 1: {        do something;         break;    }     case 2: {        do something;         break;     }}</pre><p>以上是两个case语句之间的比较</p><h2>switch语句和查找表 / Switch statement vs. lookup tables</h2><p>switch语句通常用于以下情况：</p><ul><li>调用几个函数中的一个</li><li>设置一个变量或返回值</li><li>执行几个代码片断中的一个</li></ul><p>如果case表示是密集的，在使用switch语句的前两种情况中，可以使用效率更高的查找表。比如下面的两个实现汇编代码转换成字符串的例程：</p><pre class="brush: c; gutter: true">char * Condition_String1(int condition) {    switch(condition) {         case 0: return &quot;EQ&quot;;         case 1: return &quot;NE&quot;;         case 2: return &quot;CS&quot;;         case 3: return &quot;CC&quot;;         case 4: return &quot;MI&quot;;         case 5: return &quot;PL&quot;;         case 6: return &quot;VS&quot;;         case 7: return &quot;VC&quot;;         case 8: return &quot;HI&quot;;         case 9: return &quot;LS&quot;;         case 10: return &quot;GE&quot;;         case 11: return &quot;LT&quot;;         case 12: return &quot;GT&quot;;         case 13: return &quot;LE&quot;;         case 14: return &quot;&quot;;         default: return 0;    }}char * Condition_String2(int condition) {    if((unsigned) condition &gt;= 15) return 0;    return          &quot;EQNECSCCMIPLVSVCHILSGELTGTLE&quot; +           3 * condition;}</pre><p>第一个例程需要240个字节，第二个只需要72个。</p><h2>循环终止 / Loop termination</h2><p>如果不加留意地编写循环终止条件，就可能会给程序带来明显的负担。我们应该尽量使用“倒数到零”的循环，使用简单的循环终止条件。循环终止条件相对简单，程序在执行的时候也会消耗相对少的时间。拿下面两个计算n!的例子来说，第一个例子使用递增循环，第二个使用递减循环。</p><pre class="brush: c; gutter: true">int fact1_func (int n){    int i, fact = 1;    for (i = 1; i &lt;= n; i++)        fact *= i;    return (fact);}<p>int fact2_func(int n)<br>{    int i, fact = 1;<br>    for (i = n; i != 0; i–)<br>        fact *= i;<br>    return (fact);<br>}</p></pre><p></p><p>结果是，第二个例子要比第一个快得多。</p><h2>更快的for()循环 / Faster for() loops</h2><p>这是一个简单而有效的概念，通常情况下，我们习惯把for循环写成这样：</p><pre class="brush: c; gutter: true">for( i = 0;  i &lt; 10;  i++){ ... }</pre><p>i 值依次为：0,1,2,3,4,5,6,7,8,9</p><p>在不在乎循环计数器顺序的情况下，我们可以这样：</p><pre class="brush: c; gutter: true">for( i = 10;  i--; ) { ... }</pre><p>i 值依次为: 9,8,7,6,5,4,3,2,1,0,而且循环要更快</p><p>这种方法是可行的，因为它是用更快的i&#8211;作为测试条件的，也就是说“i是否为非零数，如果是减一，然后继续”。相对于原先的代码，处理器不得不“把i减去10，结果是否为非零数，如果是，增加i，然后继续”，在紧密循环(tight loop)中，这会产生显著的区别。<br>这种语法看起来有一点陌生，却完全合法。循环中的第三条语句是可选的（无限循环可以写成这样for(;;)）,下面的写法也可以取得同样的效果：</p><pre class="brush: c; gutter: true">for(i = 10;  i;  i--){}</pre><p>或者:</p><pre class="brush: c; gutter: true">for(i = 10;  i != 0;  i--){}</pre><p>我们唯一要小心的地方是要记住循环需要停止在0（如果循环是从50-80，这样做就不行了），而且循环的计数器为倒计数方式。</p><p>另外，我们还可以把计数器分配到寄存器上，可以产生更为有效的代码。这种将循环计数器初始化成循环次数，然后递减到零的方法，同样适用于while和do语句。</p><h2>混合循环/ Loop jamming</h2><p>在可以使用一个循环的场合，决不要使用两个。但是如果你要在循环中进行大量的工作，超过处理器的指令缓冲区，在这种情况下，使用两个分开的循环可能会更快，因为有可能这两个循环都被完整的保存在指令缓冲区里了。</p><pre class="brush: c; gutter: true">//原先的代码for(i = 0; i &lt; 100; i++){    stuff();}for(i = 0; i &lt; 100; i++){    morestuff();}        //更好的做法for(i = 0; i &lt; 100; i++){    stuff();    morestuff();}</pre><h2>函数循环 / Function Looping</h2><p>调用函数的时候，在性能上就会付出一定的代价。不光要改变程序指针，还要将那些正在使用的变量压入堆栈，分配新的变量空间。为了提高程序的效率，在程序的函数结构上，有很多工作可以做。保证程序的可读性的同时，还要尽量控制程序的大小。<br>如果一个函数在一个循环中被频繁调用，就可以考虑将这个循环放在函数的里面，这样可以免去重复调用函数的负担，比如：</p><pre class="brush: c; gutter: true">for(i = 0 ; i &lt; 100 ; i++) {     func(t,i); }void func(int w, d) {     lots of stuff. }</pre><p>可以写成：</p><pre class="brush: c; gutter: true">func(t);void func(w) {     for(i = 0; i &lt; 100; i++) {         //lots of stuff.     } }</pre><h2>展开循环 / Loop unrolling</h2><p>为了提高效率，可以将小的循环解开，不过这样会增加代码的尺寸。循环被拆开后，会降低循环计数器更新的次数，减少所执行的循环的分支数目。如果循环只重复几次，那它完全可以被拆解开，这样，由循环所带来的额外开销就会消失。</p><p>比如:</p><pre class="brush: c; gutter: true">for(i = 0; i &lt; 3; i++){     something(i);}//更高效的方式：something(0);something(1);something(2);</pre><p>因为在每次的循环中，i 的值都会增加，然后检查是否有效。编译器经常会把这种简单的循环解开，前提是这些循环的次数是固定的。对于这样的循环：</p><pre class="brush: c; gutter: true">for(i = 0; i &lt;  limit; i++) { ... }</pre><p>就不可能被拆解，因为我们不知道它循环的次数到底是多少。不过，将这种类型的循环拆解开并不是不可能的。</p><p>与简单循环相比，下面的代码的长度要长很多，然而具有高得多的效率。选择8作为分块大小，只是用来演示，任何合适的长度都是可行的。例子中，循环的成立条件每八次才被检验一次，而不是每次都要检验。如果需要处理的数组的大小是确定的，我们就可以使用数组的大小作为分块的大小（或者是能够整除数组长度的数值）。不过，分块的大小跟系统的缓存大小有关。</p><pre class="brush: c; gutter: true">#include&lt;stdio.H&gt; #define BLOCKSIZE (8) <p>int main(void)<br>{     int i = 0;<br>    int limit = 33;  /* could be anything */<br>    int blocklimit;</p><pre><code>/* The limit may not be divisible by BLOCKSIZE,   go as near as we can first, then tidy up. */ blocklimit = (limit / BLOCKSIZE) * BLOCKSIZE;/* unroll the loop in blocks of 8 */ while(i &amp;lt; blocklimit) {     printf(&amp;quot;process(%d)\n&amp;quot;, i);     printf(&amp;quot;process(%d)\n&amp;quot;, i+1);     printf(&amp;quot;process(%d)\n&amp;quot;, i+2);     printf(&amp;quot;process(%d)\n&amp;quot;, i+3);     printf(&amp;quot;process(%d)\n&amp;quot;, i+4);     printf(&amp;quot;process(%d)\n&amp;quot;, i+5);     printf(&amp;quot;process(%d)\n&amp;quot;, i+6);     printf(&amp;quot;process(%d)\n&amp;quot;, i+7);     /* update the counter */     i += 8; } /*  * There may be some left to do. * This could be done as a simple for() loop,  * but a switch is faster (and more interesting)  */ if( i &amp;lt; limit ) {     /* Jump into the case at the place that will allow     * us to finish off the appropriate number of items.      */     switch( limit - i )     {         case 7 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 6 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 5 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 4 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 3 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 2 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++;         case 1 : printf(&amp;quot;process(%d)\n&amp;quot;, i);     }} return 0;</code></pre><p>}</p></pre><p></p><p>&nbsp;</p><h2>计算非零位的个数 / counting the number of bits set</h2><p>例1：测试单个的最低位，计数，然后移位。</p><pre class="brush: c; gutter: true">//example1int countbit1(uint n){    int bits = 0;    while (n != 0) {        if(n &amp; 1) bits++;            n &gt;&gt;= 1;    }      return bits;}</pre><p>例2：先除4，然后计算被4处的每个部分。循环拆解经常会给程序优化带来新的机会。</p><pre class="brush: c; gutter: true">//example - 2int countbit2(uint n){    int bits = 0;    while (n != 0) {        if (n &amp; 1) bits++;        if (n &amp; 2) bits++;        if (n &amp; 4) bits++;        if (n &amp; 8) bits++;            n &gt;&gt;= 4;    }    return bits;}</pre><h2>尽早地退出循环 / Early loop breaking</h2><p>通常没有必要遍历整个循环。举例来说，在数组中搜索一个特定的值，我们可以在找到我们需要值之后立刻退出循环。下面的例子在10000个数字中搜索-99。</p><pre class="brush: c; gutter: true">found = FALSE; for(i=0;i&lt;10000;i++) {     if(list[i] == -99) {          found = TRUE;     } } if(found) printf(&quot;Yes, there is a -99. Hooray!\n&quot;);</pre><p>这样做是可行的，但是不管这个被搜索到的项目出现在什么位置，都会搜索整个数组。跟好的方法是，再找到我们需要的数字以后，立刻退出循环。</p><pre class="brush: c; gutter: true">found = FALSE; for(i = 0; i &lt; 10000; i++) {     if( list[i] == -99 ) {         found = TRUE;         break;     } } if( found ) printf(&quot;Yes, there is a -99. Hooray!\n&quot;);</pre><p>如果数字出现在位置23上，循环就会终止，忽略剩下的9977个。</p><h2>函数设计 / Function Design</h2><p>保持函数短小精悍，是对的。这可以使编译器能够跟高效地进行其他的优化，比如寄存器分配。</p><h2>调用函数的开销 / Function call overhead</h2><p>对处理器而言，调用函数的开销是很小的，通常，在被调用函数所进行的工作中，所占的比例也很小。能够使用寄存器传递的函数参数个数是有限制的。这些参数可以是整型兼容的（char,short,int以及float都占用一个字），或者是4个字以内的结构体（包括2个字的double和long long）。假如参数的限制是4，那么第5个及后面的字都会被保存到堆栈中。这会增加在调用函数是存储这些参数的，以及在被调用函数中恢复这些参数的代价。</p><pre class="brush: c; gutter: true">int f1(int a, int b, int c, int d) {     return a + b + c + d;}int g1(void) {    return f1(1, 2, 3, 4);}int f2(int a, int b, int c, int d, int e, int f) {    return a + b + c + d + e + f;}ing g2(void) {    return f2(1, 2, 3, 4, 5, 6);}</pre><p>g2函数中，第5、6个参数被保存在堆栈中，在f2中被恢复，每个参数带来2次内存访问。</p><h2>最小化参数传递的开销 / Minimizing parameter passing overhead</h2><p>为了将传递参数给函数的代价降至最低，我们可以：<br>尽可能确保函数的形参不多于四个，甚至更少，这样就不会使用堆栈来传递参数。<br>如果一个函数形参多于四个，那就确保在这个函数能够做大量的工作，这样就可以抵消由传递堆栈参数所付出的代价。<br>用指向结构体的指针作形参，而不是结构体本身。<br>把相关的参数放到一个结构里里面，然后把它的指针传给函数，可以减少参数的个数，增加程序的可读性。<br>将long类型的参数的个数降到最小，因为它使用两个参数的空间。对于double也同样适用。<br>避免出现参数的一部分使用寄存器传输，另一部分使用堆栈传输的情况。这种情况下参数将被全部压到堆栈里。<br>避免出现函数的参数个数不定的情况。这种情况下，所有参数都使用堆栈。</p><h2>叶子函数 / Leaf functions</h2><p>如果一个函数不再调用其他函数，这样的函数被称为叶子函数。在许多应用程序中，大约一半的函数调用是对叶子函数的调用。叶子函数在所有平台上都可以得到非常高效的编译，因为他们不需要进行参数的保存和恢复。在入口压栈和在出口退栈的代价，跟一个足够复杂的需要4个或者5个参数的叶子函数所完成的工作相比，是非常小的。如果可能的话，我们就要尽量安排经常被调用的函数成为叶子函数。函数被调用的次数可以通过模型工具（profiling facility）来确定。这里有几种方法可以确保函数被编译成叶子函数：</p><ul><li>不调用其他函数：包括那些被转换成调用C语言库函数的运算，比如除法、浮点运算。</li><li>使用关键字__inline修饰小的函数。</li></ul><h2>内联函数 / Inline functions</h2><p>对于所有调试选项，内嵌函数是被禁止的。使用inline关键字修饰函数后，跟普通的函数调用不同，代码中对该函数的调用将会被函数体本身代替。这会使代码更快，另一方面它会影响代码的长度，尤其是内嵌函数比较大而且经常被调用的情况下。</p><pre class="brush: c; gutter: true">__inline int square(int x) {    return x * x;}double length(int x, int y){    return sqrt(square(x) + square(y));}</pre><p>使用内嵌函数有几个优点：</p><ul><li>没有调用函数的开销。</li></ul><p>因为函数被直接代替，没有任何额外的开销，比如存储和恢复寄存器。</p><ul><li>更低的参数赋值开销。</li></ul><p>参数传递的开销通常会更低，因为它不需要复制变量。如果其中一些参数是常量，编译器还可以作进一步的优化。</p><p>内嵌函数的缺点是如果函数在许多地方被调用，将会增加代码的长度。长度差别的大小非常依赖于内嵌函数的大小和调用的次数。</p><p>仅将少数关键函数设置成内嵌函数是明智的。如果设置得当，内嵌函数可以减少代码的长度，一次函数调用需要一定数量的指令，但是，使用优化过的内嵌函数可以编译成更少的指令。</p><h2>使用查找表 / Using Lookup Tables</h2><p>有些函数可以近似成查找表，这样可以显著的提高效率。查找表的精度一般比计算公式的精度低，不过在大多数程序中，这种精度就足够了。<br>许多信号处理软件（比如MODEM调制软件）会大量的使用sin和cos函数，这些函数会带来大量的数学运算。对于实时系统来说，精度不是很重要，sin/cos查找表显得更加实用。使用查找表的时候，尽量将相近的运算合并成一个查找表，这样要比使用多个查找表要更快和使用更少的空间。</p><h2>浮点运算 / Floating-Point Arithmetic</h2><p>尽管浮点运算对于任何处理器来讲都是很费时间的，有的时候，我们还是不得不用到浮点运算，比方说实现信号处理。尽管如此，编写浮点运算代码的时候，我们要牢记：</p><ul><li>浮点除法是慢的</li></ul><p>除法要比加法或者乘法慢两倍，我们可以把被一个常数除的运算写成被这个数的倒数乘（比如，x=x/3.0写成x=x*(1.0/3.0)）。倒数的计算在编译阶段就被完成。</p><ul><li>使用float代替double</li></ul><p>Float型变量消耗更少的内存和寄存器，而且因为它的低精度所以具有更高的效率。在精度足够的情况下，就要使用float。</p><ul><li>不要使用先验函数（transcendental functions），</li></ul><p>先验函数（比如sin，cos，log）是通过使用一系列的乘法和加法实现的，所以这些运算会比普通的乘法慢10倍以上。</p><ul><li>简化浮点表达式</li></ul><p>编译器在整型跟浮点型混合的运算中不会进行太多的优化。比如3 * (x / 3) 不会被优化成x，因为浮点运算通常会导致精度的降低，甚至表达式的顺序都是重要的： (a + b) 　　  + c 不等于 a + (b + c)。因此，进行手动的优化是有好处的。</p><p>不过，在特定的场合下，浮点运算的效率达不到指定的水平，这种情况下，最好的办法可能是放弃浮点运算，转而使用定点运算。当变量的变化范围足够的小，定点运算要比浮点运算精度更高、速度更快。</p><h2>其他的技巧 / Misc tips</h2><ul><li>一般情况下，可以用存储空间换取时间。你可以缓存那些经常用到的数据，而不是每次都重新计算、或者重新装载。比如sin/cos表，或者伪随机数的表（如果你不是真的需要随机数，你可以在开始的时候计算1000个，在随后的代码中重复利用就是了）</li><li>尽量少的使用全局变量。</li><li>将一个文件内部的变量声明成静态的，除非它有必要成为全局的。</li><li>不要使用递归。递归可以使代码非常整齐和美观，但会产生大量的函数调用和开销。</li><li>访问单维数组要比多维数组快</li><li>使用#defined宏代替经常用到的小函数。</li></ul><hr><h2>引用/References</h2><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5hcm0uY29tL3BkZnMvREFJMDAzNEFfZWZmaWNpZW50X2MucGRm" title="http://www.arm.com/pdfs/DAI0034A_efficient_c.pdf">Writing Efficient C for ARM<i class="fa fa-external-link"></i></span><ul><li>Document number: ARM DAI 0034A</li><li>Issued: January 1998</li><li>Copyright Advanced RISC Machines Ltd. (ARM) 1998</li></ul></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5yZGR2cy5jb20vRmFzdGVyQy8=" title="http://www.rddvs.com/FasterC/">Richard&#8217;s C Optimization page<i class="fa fa-external-link"></i></span> OR: How to make your C, C++ or Java program run faster with little effort.</li><li><span class="exturl" data-url="aHR0cDovL3d3dy50bGRwLm9yZy9MRFAvTEcvaXNzdWU3MS9qb3NoaS5odG1s" title="http://www.tldp.org/LDP/LG/issue71/joshi.html">Code Optimization Using the GNU C Compiler<i class="fa fa-external-link"></i></span> By Rahul U Joshi.</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcy5wcmluY2V0b24uZWR1L3NvZnR3YXJlL2xjYy9kb2MvbGludXguaHRtbA==" title="http://www.cs.princeton.edu/software/lcc/doc/linux.html">Compile C Faster on Linux<i class="fa fa-external-link"></i></span> [Christopher W. Fraser (Microsoft Research), David R. Hanson (Princeton University)]</li><li>CODE OPTIMIZATION &#8211; COMPILER [<span class="exturl" data-url="aHR0cDovL3d3dy5pYmlibGlvLm9yZy9wdWIvbGFuZ3VhZ2VzL2ZvcnRyYW4vY2gxLTEwLmh0bWw=" title="http://www.ibiblio.org/pub/languages/fortran/ch1-10.html">1<i class="fa fa-external-link"></i></span>] [<span class="exturl" data-url="aHR0cDovL3d3dy5pYmlibGlvLm9yZy9wdWIvbGFuZ3VhZ2VzL2ZvcnRyYW4vY2gxLTkuaHRtbA==" title="http://www.ibiblio.org/pub/languages/fortran/ch1-9.html">2<i class="fa fa-external-link"></i></span>][Thanks to Craig Burley for the excellent comments. Thanks to Timothy Prince for the note on architectures with Instruction Level Parallelism].</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jb3lvdGVndWxjaC5jb20vYWNvdmVhLw==" title="http://www.coyotegulch.com/acovea/">An Evolutionary Analysis of GNU C Optimizations<i class="fa fa-external-link"></i></span> [Using Natural Selection to Investigate Software Complexities by Scott Robert Ladd. Updated: 16 December 2003]</li></ul><h2>其他网络资源 / Other URLs</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy54czRhbGwubmwvfmVrb25pam4vbG9vcHkuaHRtbA==" title="http://www.xs4all.nl/~ekonijn/loopy.html">http://www.xs4all.nl/~ekonijn/loopy.html<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5wdWJsaWMuYXN1LmVkdS9+c3NoZXR0eS9PcHRpbWl6aW5nX0NvZGVfTWFudWFsLmRvYw==" title="http://www.public.asu.edu/~sshetty/Optimizing_Code_Manual.doc">http://www.public.asu.edu/~sshetty/Optimizing_Code_Manual.doc<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5hYmFybmV0dC5kZW1vbi5jby51ay90dXRvcmlhbC5odG1s" title="http://www.abarnett.demon.co.uk/tutorial.html">http://www.abarnett.demon.co.uk/tutorial.html<i class="fa fa-external-link"></i></span></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>本文翻译自： <span class="exturl" data-url="aHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vQXJ0aWNsZXMvNjE1NC9Xcml0aW5nLUVmZmljaWVudC1DLWFuZC1DLUNvZGUtT3B0aW1pemF0aW9u" title="http://www.codeproject.com/Articles/6154/Writing-Efficient-C-and-C-Code-Optimization">codeproject<i class="fa fa-external-link"></i></span>，感谢codingwu的整理，转载请注明<span class="exturl" data-url="aHR0cDovL2Nvb2xzaGVsbC5pbmZvLzIwMTQvMTIvYy1jb2RlLW9wdC5odG1s" title="http://coolshell.info/2014/12/c-code-opt.html">出处<i class="fa fa-external-link"></i></span>。</p>]]></content>
    
    <summary type="html">
    
      虽然对于优化 C 代码有很多有效的指导方针，但是对于彻底地了解编译器和你工作的机器依然无法取代，通常，加快程序的速度也会加大代码量。这些增加的代码也会影响一个程序的复杂度和可读性，这是不可接受的，比如你在一些小型的设备上编程，例如：移动设备、PDA……，这些有着严格的内存限制，于是，在优化的座右铭是:写代码在内存和速度都应该优化。
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>C 语言高级编程指南</title>
    <link href="http://miaopei.github.io/2016/07/03/Program-C/c-advaced-programming/"/>
    <id>http://miaopei.github.io/2016/07/03/Program-C/c-advaced-programming/</id>
    <published>2016-07-03T02:14:50.000Z</published>
    <updated>2019-06-14T06:43:47.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整形溢出和提升"><a href="#整形溢出和提升" class="headerlink" title="整形溢出和提升"></a>整形溢出和提升</h2><p>大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,</p><a id="more"></a><p>你觉得输出结果是什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(i)) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个变量转换成无符号整形时,i的值不再是-1,而是 size_t的最大值,因为sizeof操作返回的是一个 size_t类型的无符号数。</p><p>在C99/C11标准里写道:</p><blockquote><p>“If the operand that has unsigned integer type has rank greater or<br>equal to the rank of the type of the other operand, then the operand<br>with signed integer type is converted to the type of the operand with<br>unsigned integer type.”</p></blockquote><p>在 C 标准里面 size_t 至少是一个 16 位的无符号整数, 对于给定的架构 size_t 一般对应 long, 所以sizeof（int）和 size_t 至少相等, 这就带来了可移植性的问题, C 标准没有定义 short, int, long, longlong 的大小, 只是说明了他们的最小长度, 对于 x86_64 架构, long 在Linux下是 64 位, 而在 64 位 Windows 下是 32 位。一般的方法是采用固定长度的类型比如定义在 C99 头文件stdint.h中的uint16_t, int32_t, uint_least16_t, uint_fast16_t 等。</p><p>如果 int 可以表示原始类型的所有值,那么这个操作数会转换成 int, 否则他会转换成 unsigned int。下面这个函数在 32 位平台返回 65536, 但是在 16 位系统返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> sum()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> a = <span class="number">65535</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于char 类型到底是 signed 还是 unsigned 取决于硬件架构和操作系统,通常<br>由特定平台的 ABI(Application Binary Interface) 指定,如果是 signed char,下面的代码输出-128 和-127,否则输出 128,129(x86 架构)。</p><pre><code>char c = 128;char d = 129;printf(&quot;%d,%d\n&quot;,c,d);</code></pre><hr><h2 id="内存管理和分配"><a href="#内存管理和分配" class="headerlink" title="内存管理和分配"></a>内存管理和分配</h2><p>malloc 函数分配制定字节大小的内存,对象未被初始化,如果 size 是 0 取<br>决与系统实现。malloc(0) 返回一个空指针或者 unique pointer, 如果 size 是表达式的运算结果, 确保没有整形溢出。</p><blockquote><p>“If the size of the space requested is 0, the behavior is<br>implementation- defined: the value returned shall be either a null<br>pointer or a unique pointer.”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> computed_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elem_size &amp;&amp; num &gt; SIZE_MAX / elem_size) &#123;</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"overflow"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">computed_size = elem_size*num;</span><br></pre></td></tr></table></figure><p>malloc 不会给分配的内存初始化，如果要对新分配的内存初始化，可以用 calloc 代替 malloc, 一般情况下给序列分配相等大小的元素时, 用 calloc 来代替用表达式计算大小, calloc 会把内存初始化为 0。</p><p>realloc 用来对已经分配内存的对象改变大小,如果新的 size 更大,额外的空间<br>没 有 被 初 始 化 , 如 果 提 供 给 realloc 的 指 针 是 空 指 针 , realloc 就 等 效 于malloc,如果原指针非空而 new size是0,结果依赖于操作系统的具体实现。</p><blockquote><p>“In case of failure realloc shall return NULL and leave provided memory<br>object intact. Thus it is important not only to check for integer<br>overflow of size argument, but also to correctly handle object size if<br>realloc fails.”</p></blockquote><details><summary>下面这段代码可以带你领会 malloc, calloc，realloc, free 的用法：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_OK            0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_NULL_ERROR    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_SIZE_ERROR    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_ALLOC_ERROR   3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_vector</span><span class="params">(struct <span class="built_in">vector</span> *vc, <span class="keyword">size_t</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_NULL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vc-&gt;data = <span class="number">0</span>;</span><br><span class="line">    vc-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for integer and SIZE_MAX overflow */</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || SIZE_MAX / num &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_SIZE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vc-&gt;data = <span class="built_in">calloc</span>(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calloc faild */</span></span><br><span class="line">    <span class="keyword">if</span> (vc-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_ALLOC_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vc-&gt;size = num * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">return</span> VECTOR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">grow_vector</span><span class="params">(struct <span class="built_in">vector</span> *vc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *newptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> newsize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_NULL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* check for integer and SIZE_MAX overflow */</span></span><br><span class="line">    <span class="keyword">if</span> (vc-&gt;size == <span class="number">0</span> || SIZE_MAX / <span class="number">2</span> &lt; vc-&gt;size) &#123;</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">   <span class="keyword">return</span> VECTOR_SIZE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    newsize = vc-&gt;size * <span class="number">2</span>;</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(vc-&gt;data, newsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* realloc faild; vector stays intact size was not changed */</span></span><br><span class="line">    <span class="keyword">if</span> (newptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> VECTOR_ALLOC_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* upon success; update new address and size */</span></span><br><span class="line">    vc-&gt;data = newptr;</span><br><span class="line">    vc-&gt;size = newsize;</span><br><span class="line">    <span class="keyword">return</span> VECTOR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><hr><h2 id="避免重大错误"><a href="#避免重大错误" class="headerlink" title="避免重大错误"></a>避免重大错误</h2><ol><li><p>使用未初始化的变量</p><p>C 语言要求所有变量在使用之前要初始化，使用未初始化的变量会造成为定义的行为，这和 C++ 不同，C++ 保证所有变量在使用之前都得到初始化，Java <strong>尽量保证</strong> 变量使用前的得到初始化，如类基本数据成员会被初始化为默认值。</p></li><li><p>free 错误</p><p>对空指针调用 free, 对不是由 malloc family 函数分配的指针调用 free,或者对已经调用 free 的指针再次调用 free。</p><p>一开始初始化指针为 NULL 可以减少错误, GCC 和 Clang 编译器有 -Wuninitialized 选项来对未初始化的变量显示警告信息, 另外不要将同一个指针用于静态变量和动态变量。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nullfree</span><span class="params">(<span class="keyword">void</span> **pptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = *pptr;</span><br><span class="line">    assert(ptr != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    *pptr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>对空指针解引用，数组越界访问</p><p>对 NULL 指针或者 free’d 内存解引用，数组越界访问，是很明显的错误，为了消除这种错误，一般的做法就是增加数组越界检查的功能，比如 Java 里的 array 就有下标检查的功能，但是这样会带来严重的性能代价，我们要修改 ABI（application binary interface），让每个指针都跟随着它的范围信息，在数值计算中 cost is terrible。</p></li><li><p>违反类型规则</p><p>把 <code>int*</code> 指针 cast 成 <code>float*</code>，然后对它解引用，在 C 里面会引发 undefined behavior，C 规定这种类型的转换需要使用 memset，C++ 里面有个 reinterpret_cast 函数用于无关类型之间的转换，<code>reinterpret_cast &lt;new_type&gt; (expression)</code></p></li></ol><hr><h2 id="防止内存泄漏"><a href="#防止内存泄漏" class="headerlink" title="防止内存泄漏"></a>防止内存泄漏</h2><p>内存泄漏发生在程序不再使用的动态内存没有得到释放，这需要我们掌握动态分配对象的作用域，尤其是什么时候该调用 free 来释放内存，常用的几种方法如下：</p><ol><li>在程序启动的时候分配</li></ol><p>在程序启动的时候分配需要的 heap memory，程序退出时把释放的任务交给操作系统，这种方法一般适用于程序运行后马上退出的那种。</p><ol start="2"><li><p>使用变长数组（VLA）</p><p> 如果你需要一块变长大小的空间并且作用域在函数中，变长数组可以帮到你，但是也有一个限制，一个函数中的变长数组内存大小一般不超过几百字节，这个数字 C 标准没有明确的定义，最好是把内存分配到栈上，在栈上允许分配的最大 VLA 内存是 SIZE_MAX，掌握目标平台的栈大小可以有效的防止栈溢出。</p></li><li><p>使用引用计数</p><p> 引用计数是一个很好的管理内存的方法，特别是当你不希望自己定义的对象被复制时，每一次赋值把引用计数加 1, 每次失去引用就把引用计数减1,当引用计数等于0时，以为的对象已经不再需要了，我们需要释放对象占用的内存，由于C不提供自动的析构函数，我们必须手动释放内存，看一个例子：</p></li></ol><details><summary>例子：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REF_OBJ 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_obj_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">uint16_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_obj_t</span> <span class="title">references</span>[<span class="title">MAX_REF_OBJ</span>];</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> reference_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create memory object and return handle */</span></span><br><span class="line"><span class="keyword">uint16_t</span> create(<span class="keyword">size_t</span> size)&#123;</span><br><span class="line"><span class="keyword">if</span> (reference_count &gt;= MAX_REF_OBJ)</span><br><span class="line">        <span class="keyword">return</span> RC_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size)&#123;</span><br><span class="line">      <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            references[reference_count].ptr = ptr;</span><br><span class="line">            references[reference_count].count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> reference_count++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> RC_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get memory object and increment reference counter */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">retain</span><span class="params">(<span class="keyword">uint16_t</span> handle)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(handle &lt; reference_count &amp;&amp; handle &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        references[handle].count++;</span><br><span class="line">        <span class="keyword">return</span> references[handle].ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* decrement reference counter */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">uint16_t</span> handle)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"release\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(handle &lt; reference_count &amp;&amp; handle &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mem_obj_t</span> *<span class="title">object</span> = &amp;<span class="title">references</span>[<span class="title">handle</span>];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object-&gt;count &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"released\n"</span>);</span><br><span class="line">            <span class="built_in">free</span>(object-&gt;ptr);</span><br><span class="line">            reference_count--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"decremented\n"</span>);</span><br><span class="line">            object-&gt;count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>C++ 标准库有个 <code>auto_ptr</code> 智能指针，能够自动释放指针所指对象的内存，C++ boost 库有个<code>boost::shared_ptr</code> 智能指针，内置引用计数，支持拷贝和赋值，看下面这个例子：</p><blockquote><p> “Objects of shared_ptr types have the ability of taking ownership of a pointer and share that ownership: once they take ownership, the group of owners of a pointer become responsible for its deletion when the last one of them releases that ownership.”</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Basic useage</span></span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count of p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(p1); <span class="comment">// or p2 = p1;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count of p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    *p1 = <span class="number">999</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p2: "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p2.reset();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count of p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>内存池，有利于减少内存碎片，看下面这个例子：</li></ol><details><summary>例子：</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_pool_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* ptr;<span class="comment">//指向内存池起始地址</span></span><br><span class="line">    <span class="keyword">size_t</span> size;<span class="comment">//内存池大小</span></span><br><span class="line">    <span class="keyword">size_t</span> used;<span class="comment">//已用内存大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//create memory pool</span></span><br><span class="line"><span class="function">struct mem_pool_t* <span class="title">create_pool</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">mem_pool_t</span>* pool=<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(struct <span class="keyword">men_pool_t</span>));</span><br><span class="line">    <span class="keyword">if</span>(pool!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">void</span>* mem=<span class="built_in">calloc</span>(<span class="number">1</span>,size);</span><br><span class="line">        <span class="keyword">if</span>(mem!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pool-&gt;ptr=mem;</span><br><span class="line">            pool-&gt;size=size;</span><br><span class="line">            pool-&gt;used=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> pool;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate memory from pool</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">pool_alloc</span><span class="params">(<span class="keyword">mem_pool_t</span>* pool,<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pool=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> bytes_left=pool-&gt;size-pool-&gt;used;</span><br><span class="line">    <span class="keyword">if</span>(size&amp;&amp;size&lt;=bytes_left)&#123;</span><br><span class="line">        <span class="keyword">void</span>* mem=pool-&gt;ptr+pool-&gt;used;</span><br><span class="line">        pool-&gt;used+=size;</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">／／release memory of the pool</span><br><span class="line"><span class="keyword">void</span> pool_free(<span class="keyword">mem_pool_t</span>* pool)&#123;</span><br><span class="line"><span class="keyword">if</span>(pool!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(pool-&gt;ptr);</span><br><span class="line"><span class="built_in">free</span>(pool);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ol start="5"><li><p>垃圾回收机制</p><p>引用计数采用的方法是当内存不再需要时得到手动释放，垃圾回收发生在内存分配失败或者内存到达一定的水位（watermarks），实现垃圾回收最简单的一个算法是 MARK AND SWEEP 算法，该算法的思路是遍历所有动态分配对象的内存，标记那些还能继续使用的，回收那些没有被标记的内存。</p><p>Java 采用的垃圾回收机制就更复杂了，思路也是回收那些不再使用的内存，JAVA 的垃圾回收和C++ 的析构函数又不一样，C++ 保证对象在使用之前得到初始化，对象超出作用域之后内存得到释放，而 JAVA 不能保证对象一定被析构。 </p></li></ol><hr><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>我们一般的概念里指针和数组名是可互换的，但是在编译器里他们被不同的对待，当我们说一个对象或者表达式具有某种类型的时候我们一般是说这个对象是个左值（lvalue），当对象不是 const 的时候，左值是可以修改的，比如对象是复制操作符的左参数，而数组名是一个 const 左值，指向地一个元素的 const 指针，所以你不能给数组名赋值或者意图改变数组名，如果表达式是数组类型，数组名通常转换成指向地一个元素的指针。</p><p>但是也有例外，什么情况下数组名不是一个指针呢？</p><ol><li>当它是 sizeof 操作符的操作数时，返回数组占的内存字节数</li><li>当它是取地址操作 <code>&amp;</code> 的操作数时，返回一个数组的地址</li></ol><p>看下面这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">short</span> *pa;</span><br><span class="line"><span class="keyword">short</span> (*px)[];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pa = a;</span><br><span class="line">    px = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%p; pa:%p; px:%p\n"</span>, a, pa, px);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[1]:%i; pa[1]:%i (*px)[1]:%i\n"</span>, a[<span class="number">1</span>], pa[<span class="number">1</span>],(*px)[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a 是一个 short 类型数组，pa 是一个指向 short 类型的指针，px 呢？</p><ul><li><p>px 是一个指向数组类型的指针，在 a 被赋值给 pa 之前，他的值被转换成一个指向数组第一个元素的指针，下面那个 a 却没有转换，因为遇到的是 <code>&amp;</code> 操作符。</p></li><li><p>数组下标 <code>a[1]</code> 等价于 <code>(a+1)</code>, 和 <code>p[1]</code> 一样，也指向 <code>*(p+1)</code>，但是两者还是有区别的，a 是一个数组，它实际上存储的是第一个元素的地址，所以数组 a 是用来定位第一个元素的，而 pa 不一样，它就是一个指针，不是用来定位的。</p></li></ul><p>再比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">c=&amp;a[<span class="number">0</span>];<span class="comment">//c是指向数组a地一个元素的指针</span></span><br><span class="line">c=a;<span class="comment">//a自动转换成指向第一个元素的指针，实际上是指针拷贝</span></span><br><span class="line">b=a;<span class="comment">//非法的，你不能用赋值符把一个数组的所有元素赋给另一个数组</span></span><br><span class="line">a=c;<span class="comment">//非法的，你不能修改const指针的值</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整形溢出和提升&quot;&gt;&lt;a href=&quot;#整形溢出和提升&quot; class=&quot;headerlink&quot; title=&quot;整形溢出和提升&quot;&gt;&lt;/a&gt;整形溢出和提升&lt;/h2&gt;&lt;p&gt;大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,&lt;/p&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>CPlusPlus 设计模式</title>
    <link href="http://miaopei.github.io/2016/06/28/Program-C/cplus-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://miaopei.github.io/2016/06/28/Program-C/cplus-设计模式/</id>
    <published>2016-06-28T02:14:50.000Z</published>
    <updated>2019-06-14T06:11:54.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p>定义一个单例类：</p><ol><li>私有化它的构造函数，以防止外界创建单例类的对象；</li><li>使用类的私有静态指针变量指向类的唯一实例；</li><li>使用一个公有的静态方法获取该实例。</li></ol></blockquote><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><blockquote><p>即第一次调用该类实例的时候才产生一个新的该类实例，并在以后仅返回此实例。</p><p>需要用锁，来保证其线程安全性：原因：多个线程可能进入判断是否已经存在实例的 if 语句，从而non thread safety.</p><p>使用double-check来保证thread safety.但是如果处理大量数据时，该锁才成为严重的性能瓶颈。</p></blockquote><details><summary>1. 静态成员实例的懒汉模式：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)</span><br><span class="line">    &#123;</span><br><span class="line">        Lock();<span class="comment">//借用其它类来实现，如boost</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        UnLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>2. 内部静态实例的懒汉模式：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonInside</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SingletonInside* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Lock(); <span class="comment">// not needed after C++0x</span></span><br><span class="line">        <span class="keyword">static</span> SingletonInside instance;</span><br><span class="line">        UnLock(); <span class="comment">// not needed after C++0x</span></span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SingletonInside()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><blockquote><p>即无论是否调用该类的实例，在程序开始时就会产生一个该类的实例，并在以后仅返回此实例。</p><p>由静态初始化实例保证其线程安全性，WHY？因为静态实例初始化在程序开始时<strong>进入主函数之前就由主线程以单线程方式完成了初始化</strong>，不必担心多线程问题。</p><p>故在性能需求较高时，应使用这种模式，避免频繁的锁争夺。</p></blockquote><details><summary>饿汉模式：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonStatic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> SingletonStatic* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SingletonStatic* m_instance;</span><br><span class="line">    SingletonStatic()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部初始化 before invoke main</span></span><br><span class="line"><span class="keyword">const</span> SingletonStatic* SingletonStatic::m_instance = <span class="keyword">new</span> SingletonStatic;</span><br></pre></td></tr></table></figure></details><p><strong>m_pInstance 指向的空间什么时候释放呢？更严重的问题是，该实例的析构函数什么时候执行？</strong></p><details><summary>单例模式 - 线程安全</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Singleton() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton ctor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singleton() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton dtor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Garbo</span></span></span><br><span class="line"><span class="class">    &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        ~Garbo()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::m_pInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Garbo dtor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> Garbo garbo; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Singleton::Garbo Singleton::garbo;  <span class="comment">// 一定要初始化，不然程序结束时不会析构garbo</span></span><br><span class="line">Singleton *Singleton::m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">Singleton *Singleton::GetInstance()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (m_pInstance == <span class="literal">NULL</span>) </span><br><span class="line">        m_pInstance = <span class="keyword">new</span> Singleton;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *p1 = Singleton::GetInstance();</span><br><span class="line">    Singleton *p2 = Singleton::GetInstance();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 == p2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出结果如下：</span></span><br><span class="line">Singleton ctor</span><br><span class="line">p1 == p2</span><br><span class="line">Garbo dtor</span><br><span class="line">Singleton dtor</span><br></pre></td></tr></table></figure></details><p>类 CGarbo 被定义为 CSingleton 的私有内嵌类，以防该类被在其他地方滥用。</p><p>程序运行结束时，系统会调用 CSingleton的 静态成员 Garbo 的析构函数，该析构函数会删除单例的唯一实例。</p><p>使用这种方法释放单例对象有以下特征：</p><ul><li><p>在单例类内部定义专有的嵌套类；</p></li><li><p>在单例类内定义私有的专门用于释放的静态成员；</p></li><li><p>利用程序在结束时析构全局变量的特性，选择最终的释放时机；</p></li><li><p>使用单例的代码不需要任何操作，不必关心对象的释放。</p></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuZmF0ZWRpZXIuY29tLzIwMTUvMDMvMDQvZGVjb3VwbGluZy1ieS11c2luZy1yZWZsZWN0LWFuZC1zaW1wbGUtZmFjdG9yeS1wYXR0ZXJuLWluLWNwcC8=" title="http://blog.fatedier.com/2015/03/04/decoupling-by-using-reflect-and-simple-factory-pattern-in-cpp/">在C++中利用反射和简单工厂模式实现业务模块解耦<i class="fa fa-external-link"></i></span></p></blockquote><p>用一个单独的类来做创造实例的过程，就是工厂。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><details><summary>简单工厂模式基本代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProduct() &#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> :</span> <span class="keyword">public</span> AbstractProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> :</span> <span class="keyword">public</span> AbstractProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProduct* <span class="title">createProduct</span><span class="params">(<span class="keyword">char</span> product)</span> </span>&#123;</span><br><span class="line">        AbstractProduct* ap = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">switch</span>(product) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>: ap = <span class="keyword">new</span> ProductA(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'B'</span>: ap = <span class="keyword">new</span> ProductB(); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Factory* f = <span class="keyword">new</span> Factory();</span><br><span class="line">    AbstractProduct* apa = f-&gt;createProduct(<span class="string">'A'</span>);</span><br><span class="line">    apa-&gt;Operation();  <span class="comment">// ProductA</span></span><br><span class="line"></span><br><span class="line">    AbstractProduct* apb = f-&gt;createProduct(<span class="string">'B'</span>);</span><br><span class="line">    apb-&gt;Operation();  <span class="comment">// ProductB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> apa;</span><br><span class="line">    <span class="keyword">delete</span> apb;</span><br><span class="line">    <span class="keyword">delete</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><img src="/images/imageProgramC/%E7%AE%80%E5%8D%95%E8%BF%90%E7%AE%97%E5%B7%A5%E5%8E%82.png" alt="简单运算工厂"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation <span class="title">createOperate</span><span class="params">(<span class="built_in">string</span> operate)</span> </span>&#123;</span><br><span class="line">        Operation oper = null;</span><br><span class="line">        <span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"+"</span>: oper = <span class="keyword">new</span> OperationAdd(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"-"</span>: oper = <span class="keyword">new</span> OperationSub(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"*"</span>: oper = <span class="keyword">new</span> OperationMul(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"/"</span>: oper = <span class="keyword">new</span> OperationDiv(); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。</p></blockquote><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。</p><p><img src="/images/imageProgramC/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="工厂方法模式结构图"></p><details><summary>工厂方法模式基本代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Product()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteProductA"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteProductB"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">FactoryMethod</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Creator()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreatorA</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreatorB</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Creator* ca = <span class="keyword">new</span> ConcreteCreatorA();</span><br><span class="line">    Product* pa = ca-&gt;FactoryMethod();</span><br><span class="line">    pa-&gt;Operation(); <span class="comment">// ConcreteProductA</span></span><br><span class="line"></span><br><span class="line">    Creator* cb = <span class="keyword">new</span> ConcreteCreatorB();</span><br><span class="line">    Product* pb = cb-&gt;FactoryMethod();</span><br><span class="line">    pb-&gt;Operation(); <span class="comment">// ConcreteProductB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ca;</span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line">    <span class="keyword">delete</span> cb;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>把简单工厂模式中的工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，就变成了一个工厂抽象接口和多个具体生成对象的工厂。</p><p><img src="/images/imageProgramC/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE-01.png" alt="工厂方法模式结构图"></p><p>这样整个工厂和产品体系就没有修改，而只是扩展，符合开放 - 封闭原则。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><img src="/images/imageProgramC/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="抽象工厂模式结构图"></p><details><summary>抽象工厂模式基本代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProductA()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> :</span> <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> :</span> <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProductB()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> :</span> <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> :</span> <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductA* <span class="title">CreateProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductB* <span class="title">CreateProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractFactory()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA1* <span class="title">CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB1* <span class="title">CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA2* <span class="title">CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB2* <span class="title">CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractFactory* af1 = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">    <span class="comment">// 具体工厂创建对应的具体产品</span></span><br><span class="line">    AbstractProductA* apa1 = af1-&gt;CreateProductA();  <span class="comment">// 工厂1创建产品A</span></span><br><span class="line">    apa1-&gt;Operation();  <span class="comment">// ProductA1</span></span><br><span class="line"></span><br><span class="line">    AbstractProductB* apb1 = af1-&gt;CreateProductB();  <span class="comment">// 工厂1创建产品B</span></span><br><span class="line">    apb1-&gt;Operation();  <span class="comment">// ProductB1</span></span><br><span class="line"></span><br><span class="line">    AbstractFactory* af2 = <span class="keyword">new</span> ConcreteFactory2();</span><br><span class="line">    AbstractProductA* apa2 = af2-&gt;CreateProductA();  <span class="comment">// 工厂2创建产品A</span></span><br><span class="line">    apa2-&gt;Operation();  <span class="comment">// ProductA2</span></span><br><span class="line"></span><br><span class="line">    AbstractProductB* apb2 = af2-&gt;CreateProductB();  <span class="comment">// 工厂2创建产品B</span></span><br><span class="line">    apb2-&gt;Operation();  <span class="comment">// ProductB2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> apa1;</span><br><span class="line">    <span class="keyword">delete</span> apa2;</span><br><span class="line">    <span class="keyword">delete</span> af1;</span><br><span class="line">    <span class="keyword">delete</span> apb1;</span><br><span class="line">    <span class="keyword">delete</span> apb2;</span><br><span class="line">    <span class="keyword">delete</span> af2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>抽象工厂函数的优缺点</strong></p><p>优点：</p><ul><li>易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这样就使得改变一个应用的具体工厂变得非常容易，只需要改变具体工厂即可使用不同的产品配置。</li><li>让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂实现分离，不会出现在客户代码中。</li></ul><p>缺点：增加新的产品时需要改动多处代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是
      
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Interview STL</title>
    <link href="http://miaopei.github.io/2016/06/18/Program-C/STL/"/>
    <id>http://miaopei.github.io/2016/06/18/Program-C/STL/</id>
    <published>2016-06-18T02:14:50.000Z</published>
    <updated>2019-06-14T06:13:21.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9ub3RlL2Jsb2IvbWFzdGVyL1NUTC5tZA==" title="https://github.com/huihut/note/blob/master/STL.md">github . huihut/note/STL.md<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdGwv" title="http://www.cplusplus.com/reference/stl/">cplusplus . stl<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3poLmNwcHJlZmVyZW5jZS5jb20vdy8lRTklQTYlOTYlRTklQTElQjU=" title="http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference . C++ 参考手册<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sdW1uL2RldGFpbHMvZ2Vlay1zdGwuaHRtbA==" title="http://blog.csdn.net/column/details/geek-stl.html">CSDN专栏：STL学习笔记<i class="fa fa-external-link"></i></span></li></ul><a id="more"></a><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li>容器（containers）</li><li>算法（algorithms）</li><li>迭代器（iterators）</li><li>仿函数（functors）</li><li>配接器（adapters）</li><li>空间配置器（allocator）</li></ul><h2 id="容器（containers）"><a href="#容器（containers）" class="headerlink" title="容器（containers）"></a>容器（containers）</h2><ul><li>序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted）</li><li>关联式容器（associattive containers）</li></ul><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>array是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。</p><p>在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。</p><p>与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。</p><p>零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。</p><p>与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。</p><p>数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">size_t</span> <span class="title">N</span> &gt; <span class="title">class</span> <span class="title">array</span>;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160405225541788" alt></p><h4 id="array-begin"><a href="#array-begin" class="headerlink" title="array::begin"></a>array::begin</h4><p>返回指向数组容器中第一个元素的迭代器。</p><p><img src="https://i.stack.imgur.com/oa3EQ.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; myarray = &#123;<span class="number">2</span>, <span class="number">16</span>, <span class="number">77</span>,<span class="number">34</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myarray.begin(); it != myarray.end(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 2 16 77 34 50</span><br></pre></td></tr></table></figure><h4 id="array-end"><a href="#array-end" class="headerlink" title="array::end"></a>array::end</h4><p>返回指向数组容器中最后一个元素之后的理论元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123; <span class="number">5</span>, <span class="number">19</span>, <span class="number">77</span>, <span class="number">34</span>, <span class="number">99</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> it = myarray.begin(); it != myarray.end(); ++it )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 5 19 77 34 99</span><br></pre></td></tr></table></figure><h4 id="array-rbegin"><a href="#array-rbegin" class="headerlink" title="array::rbegin"></a>array::rbegin</h4><p>返回指向数组容器中最后一个元素的反向迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      reverse_iterator rbegin（）<span class="keyword">noexcept</span>;</span><br><span class="line">const_reverse_iterator rbegin（）<span class="keyword">const</span> <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,4&gt; myarray = &#123;<span class="number">4</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">14</span>&#125; ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 14 80 26 4</span><br></pre></td></tr></table></figure><h4 id="array-rend"><a href="#array-rend" class="headerlink" title="array::rend"></a>array::rend</h4><p>返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,4&gt; myarray = &#123;<span class="number">4</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">14</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 14 80 26 4</span><br></pre></td></tr></table></figure><h4 id="array-cbegin"><a href="#array-cbegin" class="headerlink" title="array::cbegin"></a>array::cbegin</h4><p>返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const_iterator cbegin（）<span class="keyword">const</span> <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123;<span class="number">2</span>, <span class="number">16</span>, <span class="number">77</span>, <span class="number">34</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> it = myarray.cbegin(); it != myarray.cend(); ++it )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;   <span class="comment">// cannot modify *it</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 2 16 77 34 50</span><br></pre></td></tr></table></figure><h4 id="array-cend"><a href="#array-cend" class="headerlink" title="array::cend"></a>array::cend</h4><p>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123; <span class="number">15</span>, <span class="number">720</span>, <span class="number">801</span>, <span class="number">1002</span>, <span class="number">3502</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> it = myarray.cbegin(); it != myarray.cend(); ++it )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;   <span class="comment">// cannot modify *it</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 2 16 77 34 50</span><br></pre></td></tr></table></figure><h4 id="array-crbegin"><a href="#array-crbegin" class="headerlink" title="array::crbegin"></a>array::crbegin</h4><p>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const_reverse_iterator crbegin（）<span class="keyword">const</span> <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,6&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125; ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray backwards:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;   <span class="comment">// cannot modify *rit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray backwards: 60 50 40 30 20 10</span><br></pre></td></tr></table></figure><h4 id="array-crend"><a href="#array-crend" class="headerlink" title="array::crend"></a>array::crend</h4><p>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_reverse_iterator <span class="title">crend</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,6&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125; ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray backwards:"</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rit;   <span class="comment">// cannot modify *rit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray backwards: 60 50 40 30 20 10</span><br></pre></td></tr></table></figure><h4 id="array-size"><a href="#array-size" class="headerlink" title="array::size"></a>array::size</h4><p>返回数组容器中元素的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> size_type size（）<span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myints;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of myints:"</span> &lt;&lt; myints.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(myints):"</span> &lt;&lt; <span class="keyword">sizeof</span>(myints) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size of myints: 5</span><br><span class="line">sizeof(myints): 20</span><br></pre></td></tr></table></figure><h4 id="array-max-size"><a href="#array-max-size" class="headerlink" title="array::max_size"></a>array::max_size</h4><p>返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myints;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of myints: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size of myints: "</span> &lt;&lt; myints.max_size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size of myints: 10</span><br><span class="line">max_size of myints: 10</span><br></pre></td></tr></table></figure><h4 id="array-empty"><a href="#array-empty" class="headerlink" title="array::empty"></a>array::empty</h4><p>返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,0&gt; first;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; second;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first "</span> &lt;&lt; (first.empty() ? <span class="string">"is empty"</span> : <span class="string">"is not empty"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second "</span> &lt;&lt; (second.empty() ? <span class="string">"is empty"</span> : <span class="string">"is not empty"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first is empty</span><br><span class="line">second is not empt</span><br></pre></td></tr></table></figure><h4 id="array-operator"><a href="#array-operator" class="headerlink" title="array::operator[]"></a>array::operator[]</h4><p>返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      reference <span class="keyword">operator</span>[] (size_type n);</span><br><span class="line">const_reference <span class="keyword">operator</span>[] (size_type n) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myarray;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign some values:</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        myarray[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print content</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myarray[i];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h4 id="array-at"><a href="#array-at" class="headerlink" title="array::at"></a>array::at</h4><p>返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reference <span class="title">at</span> <span class="params">( size_type n )</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">at</span> <span class="params">( size_type n )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myarray;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign some values:</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        myarray[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print content</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myarray[i];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h4 id="array-front"><a href="#array-front" class="headerlink" title="array::front"></a>array::front</h4><p>返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。<br>在空容器上调用此函数会导致未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reference <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">2</span>, <span class="number">16</span>, <span class="number">77</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"front is: "</span> &lt;&lt; myarray.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"back is: "</span> &lt;&lt; myarray.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 77</span></span><br><span class="line"></span><br><span class="line">  myarray.front() = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray now contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x : myarray ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">front is: 2</span><br><span class="line">back is: 77</span><br><span class="line">myarray now contains: 100 16 77</span><br></pre></td></tr></table></figure><h4 id="array-back"><a href="#array-back" class="headerlink" title="array::back"></a>array::back</h4><p>返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。<br>在空容器上调用此函数会导致未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">reference <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">5</span>, <span class="number">19</span>, <span class="number">77</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"front is: "</span> &lt;&lt; myarray.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"back is: "</span> &lt;&lt; myarray.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 77</span></span><br><span class="line"></span><br><span class="line">  myarray.back() = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray now contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x : myarray ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">front is: 5</span><br><span class="line">back is: 77</span><br><span class="line">myarray now contains: 5 19 50</span><br></pre></td></tr></table></figure><h4 id="array-data"><a href="#array-data" class="headerlink" title="array::data"></a>array::data</h4><p>返回指向数组对象中第一个元素的指针。</p><p>由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">value_type* <span class="title">data</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> value_type* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="string">"Test string"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">char</span>,12&gt; charray;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span> (charray.data(),cstr,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; charray.data() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test string</span><br></pre></td></tr></table></figure><h4 id="array-fill"><a href="#array-fill" class="headerlink" title="array::fill"></a>array::fill</h4><p>用val填充数组所有元素，将val设置为数组对象中所有元素的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,6&gt; myarray;</span><br><span class="line"></span><br><span class="line">  myarray.fill(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myarray contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x : myarray) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray contains: 5 5 5 5 5 5</span><br></pre></td></tr></table></figure><h4 id="array-swap"><a href="#array-swap" class="headerlink" title="array::swap"></a>array::swap</h4><p>通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。</p><p>与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="built_in">array</span>&amp; x)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;())))</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; first = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; second = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">  first.swap (second);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x : first) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x : second) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first: 11 22 33 44 55</span><br><span class="line">second: 10 20 30 40 50</span><br></pre></td></tr></table></figure><h4 id="get（array）"><a href="#get（array）" class="headerlink" title="get（array）"></a>get（array）</h4><p>形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> I，<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt; <span class="title">T</span>＆<span class="title">get</span>（<span class="title">array</span> &lt;T，N&gt;＆<span class="title">arr</span>）<span class="title">noexcept</span>;</span> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> I，<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt; <span class="title">T</span> &amp;&amp; <span class="title">get</span>（<span class="title">array</span> &lt;T，N&gt; &amp;&amp; <span class="title">arr</span>）<span class="title">noexcept</span>;</span> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> I，<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt; <span class="title">const</span> <span class="title">T</span>＆<span class="title">get</span>（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">arr</span>）<span class="title">noexcept</span>;</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mytuple (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tuple_element&lt;<span class="number">0</span>,<span class="keyword">decltype</span>(myarray)&gt;::type myelement;  <span class="comment">// int myelement</span></span><br><span class="line"></span><br><span class="line">  myelement = <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(myarray);</span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(myarray) = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(myarray);</span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(myarray) = myelement;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element in myarray: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(myarray) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element in mytuple: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first element in myarray: 30</span><br><span class="line">first element in mytuple: 10</span><br></pre></td></tr></table></figure><h4 id="relational-operators-array"><a href="#relational-operators-array" class="headerlink" title="relational operators (array)"></a>relational operators (array)</h4><p>形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_T</span> <span class="title">N</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span> ==（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">lhs</span>，<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">rhs</span>）;</span></span><br><span class="line">（<span class="number">2</span>）</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_T</span> <span class="title">N</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span>！=（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">lhs</span>，<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">rhs</span>）;</span></span><br><span class="line">（<span class="number">3</span>）</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_T</span> <span class="title">N</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span> &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;</span></span><br><span class="line"><span class="class">（4）</span></span><br><span class="line"><span class="class">template &lt;class T，size_T N&gt; </span></span><br><span class="line"><span class="class">  bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;</span></span><br><span class="line"><span class="class">（5）</span></span><br><span class="line"><span class="class">template &lt;class T，size_T N&gt; </span></span><br><span class="line"><span class="class">  bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;</span></span><br><span class="line"><span class="class">（6）</span></span><br><span class="line"><span class="class">template &lt;class T，size_T N&gt; </span></span><br><span class="line"><span class="class">  bool operator&gt; =（<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">lhs</span>，<span class="title">const</span> <span class="title">array</span> &lt;T，N&gt;＆<span class="title">rhs</span>）;</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; a = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; b = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; c = &#123;<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a==b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a and b are equal\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (b!=c) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b and c are not equal\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (b&lt;c) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b is less than c\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (c&gt;b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c is greater than b\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (a&lt;=b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a is less than or equal to b\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (a&gt;=b) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a is greater than or equal to b\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a and b are equal</span><br><span class="line">b and c are not equal</span><br><span class="line">b is less than c</span><br><span class="line">c is greater than b</span><br><span class="line">a is less than or equal to b</span><br><span class="line">a is greater than or equal to b</span><br></pre></td></tr></table></figure><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector是表示可以改变大小的数组的序列容器。</p><p>就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。</p><p>在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。</p><p>相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。</p><p>因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。</p><p>与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。</p><p>针对 vector 的各种常见操作的复杂度（效率）如下： </p><ul><li>随机访问 - 常数 O(1) </li><li>在尾部增删元素 - 平摊（amortized）常数 O(1)}} </li><li>增删元素 - 至 vector 尾部的线性距离 O(n)}}</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt; &gt; <span class="title">class</span> <span class="title">vector</span>;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160406151211233" alt></p><h4 id="vector-vector"><a href="#vector-vector" class="headerlink" title="vector::vector"></a>vector::vector</h4><p>（1）empty容器构造函数（默认构造函数）<br>构造一个空的容器，没有元素。<br>（2）fill构造函数<br>用n个元素构造一个容器。每个元素都是val的副本（如果提供）。<br>（3）范围（range）构造器<br>使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。<br>（4）复制（copy）构造函数（并用分配器复制）<br>按照相同的顺序构造一个包含x中每个元素的副本的容器。<br>（5）移动（move）构造函数（和分配器移动）<br>构造一个获取x元素的容器。<br>如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。<br>x保持未指定但有效的状态。<br>（6）初始化列表构造函数<br>构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line">         <span class="built_in">vector</span> (size_type n, <span class="keyword">const</span> value_type&amp; val,</span><br><span class="line">                 <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type());</span><br><span class="line">range (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">vector</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">          <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br><span class="line">copy (<span class="number">4</span>)</span><br><span class="line"><span class="built_in">vector</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&amp; x);</span><br><span class="line"><span class="built_in">vector</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line">move (<span class="number">5</span>)</span><br><span class="line"><span class="built_in">vector</span> (<span class="built_in">vector</span>&amp;&amp; x);</span><br><span class="line"><span class="built_in">vector</span> (<span class="built_in">vector</span>&amp;&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">vector</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first;             <span class="comment">// empty vector of ints</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; second(<span class="number">4</span>, <span class="number">100</span>);    <span class="comment">// four ints with value 100</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; third(second.begin(), second.end());<span class="comment">// iterating through second</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fourth(third);     <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the iterator constructor can also be used to construct from arrays:</span></span><br><span class="line">    <span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fifth(myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of fifth are:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The contents of fifth are: 16 2 77 29</span><br></pre></td></tr></table></figure><h4 id="vector-vector-1"><a href="#vector-vector-1" class="headerlink" title="vector::~vector"></a>vector::~vector</h4><p>销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">vector</span>();</span><br></pre></td></tr></table></figure><h4 id="vector-operator"><a href="#vector-operator" class="headerlink" title="vector::operator="></a>vector::operator=</h4><p>将新内容分配给容器，替换其当前内容，并相应地修改其大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copy (<span class="number">1</span>)</span><br><span class="line"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> <span class="built_in">vector</span>&amp; x);</span><br><span class="line">move (<span class="number">2</span>)</span><br><span class="line"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span>= (<span class="built_in">vector</span>&amp;&amp; x);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span></span>= (<span class="built_in">initializer_list</span>&lt;value_type&gt; il);</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;int&gt; foo (3,0);</span><br><span class="line">  std::vector&lt;int&gt; bar (5,0);</span><br><span class="line"></span><br><span class="line">  bar = foo;</span><br><span class="line">  foo = std::vector&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Size of foo: 0</span><br><span class="line">Size of bar: 3</span><br></pre></td></tr></table></figure><h4 id="vector-begin"><a href="#vector-begin" class="headerlink" title="vector::begin"></a>vector::begin</h4><h4 id="vector-end"><a href="#vector-end" class="headerlink" title="vector::end"></a>vector::end</h4><h4 id="vector-rbegin"><a href="#vector-rbegin" class="headerlink" title="vector::rbegin"></a>vector::rbegin</h4><h4 id="vector-rend"><a href="#vector-rend" class="headerlink" title="vector::rend"></a>vector::rend</h4><h4 id="vector-cbegin"><a href="#vector-cbegin" class="headerlink" title="vector::cbegin"></a>vector::cbegin</h4><h4 id="vector-cend"><a href="#vector-cend" class="headerlink" title="vector::cend"></a>vector::cend</h4><h4 id="vector-rcbegin"><a href="#vector-rcbegin" class="headerlink" title="vector::rcbegin"></a>vector::rcbegin</h4><h4 id="vector-rcend"><a href="#vector-rcend" class="headerlink" title="vector::rcend"></a>vector::rcend</h4><h4 id="vector-size"><a href="#vector-size" class="headerlink" title="vector::size"></a>vector::size</h4><p>返回vector中元素的数量。</p><p>这是vector中保存的实际对象的数量，不一定等于其存储容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myints;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"0. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) myints.push_back(i);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myints.insert (myints.end(),<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myints.pop_back();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3. size: "</span> &lt;&lt; myints.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0. size: 0</span><br><span class="line">1. size: 10</span><br><span class="line">2. size: 20</span><br><span class="line">3. size: 19</span><br></pre></td></tr></table></figure><h4 id="vector-max-size"><a href="#vector-max-size" class="headerlink" title="vector::max_size"></a>vector::max_size</h4><p>返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制，</p><p>这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some content in the vector:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; myvector.size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size: "</span> &lt;&lt; myvector.max_size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A possible output for this program could be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size: 100</span><br><span class="line">capacity: 128</span><br><span class="line">max_size: 1073741823</span><br></pre></td></tr></table></figure><h4 id="vector-resize"><a href="#vector-resize" class="headerlink" title="vector::resize"></a>vector::resize</h4><p>调整容器的大小，使其包含n个元素。</p><p>如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。</p><p>如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。</p><p>如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。</p><p>注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some initial content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  myvector.resize(<span class="number">5</span>);</span><br><span class="line">  myvector.resize(<span class="number">8</span>,<span class="number">100</span>);</span><br><span class="line">  myvector.resize(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;myvector.size();i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myvector[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0</span><br></pre></td></tr></table></figure><h4 id="vector-capacity"><a href="#vector-capacity" class="headerlink" title="vector::capacity"></a>vector::capacity</h4><p>返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some content in the vector:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; (<span class="keyword">int</span>) myvector.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; (<span class="keyword">int</span>) myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size: "</span> &lt;&lt; (<span class="keyword">int</span>) myvector.max_size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A possible output for this program could be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size: 100</span><br><span class="line">capacity: 128</span><br><span class="line">max_size: 1073741823</span><br></pre></td></tr></table></figure><h4 id="vector-empty"><a href="#vector-empty" class="headerlink" title="vector::empty"></a>vector::empty</h4><p>返回vector是否为空（即，它的size是否为0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!myvector.empty())</span><br><span class="line">  &#123;</span><br><span class="line">     sum += myvector.back();</span><br><span class="line">     myvector.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total: 55</span><br></pre></td></tr></table></figure><h4 id="vector-reserve"><a href="#vector-reserve" class="headerlink" title="vector::reserve"></a>vector::reserve</h4><p>请求vector容量至少足以包含n个元素。</p><p>如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。</p><p>在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。</p><p>这个函数对vector大小没有影响，也不能改变它的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span> <span class="params">(size_type n)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type sz;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo;</span><br><span class="line">  sz = foo.capacity();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"making foo grow:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">    foo.push_back(i);</span><br><span class="line">    <span class="keyword">if</span> (sz!=foo.capacity()) &#123;</span><br><span class="line">      sz = foo.capacity();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity changed: "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar;</span><br><span class="line">  sz = bar.capacity();</span><br><span class="line">  bar.reserve(<span class="number">100</span>);   <span class="comment">// this is the only difference with foo above</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"making bar grow:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">    bar.push_back(i);</span><br><span class="line">    <span class="keyword">if</span> (sz!=bar.capacity()) &#123;</span><br><span class="line">      sz = bar.capacity();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity changed: "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">making foo grow:</span><br><span class="line">capacity changed: 1</span><br><span class="line">capacity changed: 2</span><br><span class="line">capacity changed: 4</span><br><span class="line">capacity changed: 8</span><br><span class="line">capacity changed: 16</span><br><span class="line">capacity changed: 32</span><br><span class="line">capacity changed: 64</span><br><span class="line">capacity changed: 128</span><br><span class="line">making bar grow:</span><br><span class="line">capacity changed: 100</span><br></pre></td></tr></table></figure><h4 id="vector-shrink-to-fit"><a href="#vector-shrink-to-fit" class="headerlink" title="vector::shrink_to_fit"></a>vector::shrink_to_fit</h4><p>要求容器减小其capacity(容量)以适应其尺寸。</p><p>该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1. capacity of myvector: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myvector.resize(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2. capacity of myvector: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  myvector.shrink_to_fit();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3. capacity of myvector: "</span> &lt;&lt; myvector.capacity() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. capacity of myvector: 100</span><br><span class="line">2. capacity of myvector: 100</span><br><span class="line">3. capacity of myvector: 10</span><br></pre></td></tr></table></figure><h4 id="vector-operator-1"><a href="#vector-operator-1" class="headerlink" title="vector::operator[]"></a>vector::operator[]</h4><h4 id="vector-at"><a href="#vector-at" class="headerlink" title="vector::at"></a>vector::at</h4><h4 id="vector-front"><a href="#vector-front" class="headerlink" title="vector::front"></a>vector::front</h4><h4 id="vector-back"><a href="#vector-back" class="headerlink" title="vector::back"></a>vector::back</h4><h4 id="vector-data"><a href="#vector-data" class="headerlink" title="vector::data"></a>vector::data</h4><h4 id="vector-assign"><a href="#vector-assign" class="headerlink" title="vector::assign"></a>vector::assign</h4><p>将新内容分配给vector，替换其当前内容，并相应地修改其大小。</p><p>在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。</p><p>在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。</p><p>在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。</p><p>所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">range (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">assign</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; second;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; third;</span><br><span class="line"></span><br><span class="line">  first.assign (<span class="number">7</span>,<span class="number">100</span>);             <span class="comment">// 7 ints with a value of 100</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  it=first.begin()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  second.assign (it,first.end()<span class="number">-1</span>); <span class="comment">// the 5 central values of first</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">1776</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  third.assign (myints,myints+<span class="number">3</span>);   <span class="comment">// assigning from array.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of first: "</span> &lt;&lt; <span class="keyword">int</span> (first.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of second: "</span> &lt;&lt; <span class="keyword">int</span> (second.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of third: "</span> &lt;&lt; <span class="keyword">int</span> (third.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Size of first: 7</span><br><span class="line">Size of second: 5</span><br><span class="line">Size of third: 3</span><br></pre></td></tr></table></figure><p>补充：vector::assign 与 vector::operator= 的区别：</p><ol><li>vector::assign 实现源码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(size_type __n, <span class="keyword">const</span> _Tp&amp; __val)</span> </span>&#123; _M_fill_assign(__n, __val); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;_Tp, _Alloc&gt;:</span>:_M_fill_assign(<span class="keyword">size_t</span> __n, <span class="keyword">const</span> value_type&amp; __val) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__n &gt; capacity()) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator());</span><br><span class="line">    __tmp.swap(*<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__n &gt; size()) &#123;</span><br><span class="line">    fill(begin(), end(), __val);</span><br><span class="line">    _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    erase(fill_n(begin(), __n, __val), end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>vector::operator= 实现源码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;_Tp,_Alloc&gt;&amp; </span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;_Tp,_Alloc&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;__x != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __xlen = __x.size();</span><br><span class="line">    <span class="keyword">if</span> (__xlen &gt; capacity()) &#123;</span><br><span class="line">      iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());</span><br><span class="line">      destroy(_M_start, _M_finish);</span><br><span class="line">      _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">      _M_start = __tmp;</span><br><span class="line">      _M_end_of_storage = _M_start + __xlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size() &gt;= __xlen) &#123;</span><br><span class="line">      iterator __i = copy(__x.begin(), __x.end(), begin());</span><br><span class="line">      destroy(__i, _M_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      copy(__x.begin(), __x.begin() + size(), _M_start);</span><br><span class="line">      uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    _M_finish = _M_start + __xlen;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-push-back"><a href="#vector-push-back" class="headerlink" title="vector::push_back"></a>vector::push_back</h4><p>在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。</p><p>这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="keyword">int</span> myint;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter some integers (enter 0 to end):\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; myint;</span><br><span class="line">    myvector.push_back (myint);</span><br><span class="line">  &#125; <span class="keyword">while</span> (myint);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector stores "</span> &lt;&lt; <span class="keyword">int</span>(myvector.size()) &lt;&lt; <span class="string">" numbers.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-pop-back"><a href="#vector-pop-back" class="headerlink" title="vector::pop_back"></a>vector::pop_back</h4><p>删除vector中的最后一个元素，有效地将容器size减少一个。</p><p>这破坏了被删除的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  myvector.push_back (<span class="number">100</span>);</span><br><span class="line">  myvector.push_back (<span class="number">200</span>);</span><br><span class="line">  myvector.push_back (<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!myvector.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    sum+=myvector.back();</span><br><span class="line">    myvector.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The elements of myvector add up to "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The elements of myvector add up to 600</span><br></pre></td></tr></table></figure><h4 id="vector-insert"><a href="#vector-insert" class="headerlink" title="vector::insert"></a>vector::insert</h4><p>通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。 </p><p>由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">single <span class="title">element</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line">range (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">insert</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br><span class="line">move (<span class="number">4</span>)</span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, value_type&amp;&amp; val)</span></span>;</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="built_in">initializer_list</span>&lt;value_type&gt; il)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  it = myvector.begin();</span><br><span class="line">  it = myvector.insert ( it , <span class="number">200</span> );</span><br><span class="line"></span><br><span class="line">  myvector.insert (it,<span class="number">2</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "it" no longer valid, get a new one:</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anothervector (<span class="number">2</span>,<span class="number">400</span>);</span><br><span class="line">  myvector.insert (it+<span class="number">2</span>,anothervector.begin(),anothervector.end());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myarray [] = &#123; <span class="number">501</span>,<span class="number">502</span>,<span class="number">503</span> &#125;;</span><br><span class="line">  myvector.insert (myvector.begin(), myarray, myarray+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (it=myvector.begin(); it&lt;myvector.end(); it++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 501 502 503 300 300 400 400 200 100 100 100</span><br></pre></td></tr></table></figure><p>补充：insert 迭代器野指针错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vi;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取vector第一个元素的迭代器</span></span><br><span class="line">vi = v.begin();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错</span></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">v.insert(vi, <span class="number">2</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正：应该把<code>vi = v.begin();</code>放到<code>v.push_back(10);</code>后面</p><h4 id="vector-erase"><a href="#vector-erase" class="headerlink" title="vector::erase"></a>vector::erase</h4><p>从vector中删除单个元素（position）或一系列元素（[first，last））。</p><p>这有效地减少了被去除的元素的数量，从而破坏了容器的大小。</p><p>由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some values (from 1 to 10)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// erase the 6th element</span></span><br><span class="line">  myvector.erase (myvector.begin()+<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// erase the first 3 elements:</span></span><br><span class="line">  myvector.erase (myvector.begin(),myvector.begin()+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;myvector.size(); ++i)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myvector[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 4 5 7 8 9 10</span><br></pre></td></tr></table></figure><h4 id="vector-swap"><a href="#vector-swap" class="headerlink" title="vector::swap"></a>vector::swap</h4><p>通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。</p><p>在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。</p><p>请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="built_in">vector</span>&amp; x)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"></span><br><span class="line">  foo.swap(bar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;foo.size(); i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; foo[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;bar.size(); i++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; bar[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo contains: 200 200 200 200 200 </span><br><span class="line">bar contains: 100 100 100</span><br></pre></td></tr></table></figure><h4 id="vector-clear"><a href="#vector-clear" class="headerlink" title="vector::clear"></a>vector::clear</h4><p>从vector中删除所有的元素（被销毁），留下size为0的容器。</p><p>不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：<code>vector&lt;T&gt;().swap(x);   // clear x reallocating</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.begin(); it != v.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 size  = "</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 capacity  = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v1.clear();</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 size  = "</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 capacity  = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v1.push_back(<span class="number">11</span>);</span><br><span class="line">v1.push_back(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 size  = "</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 capacity  = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">50 50 50 50 50</span><br><span class="line">v1 size  = 5</span><br><span class="line">v1 capacity  = 5</span><br><span class="line"></span><br><span class="line">v1 size  = 0</span><br><span class="line">v1 capacity  = 5</span><br><span class="line">11 22</span><br><span class="line">v1 size  = 2</span><br><span class="line">v1 capacity  = 5</span><br></pre></td></tr></table></figure><h4 id="vector-emplace"><a href="#vector-emplace" class="headerlink" title="vector::emplace"></a>vector::emplace</h4><p>通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。</p><p>这有效地增加了一个容器的大小。</p><p>分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。</p><p>由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。</p><p>该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">emplace</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = myvector.emplace ( myvector.begin()+<span class="number">1</span>, <span class="number">100</span> );</span><br><span class="line">  myvector.emplace ( it, <span class="number">200</span> );</span><br><span class="line">  myvector.emplace ( myvector.end(), <span class="number">300</span> );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: myvector)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvector contains: 10 200 100 20 30 300</span><br></pre></td></tr></table></figure><h4 id="vector-emplace-back"><a href="#vector-emplace-back" class="headerlink" title="vector::emplace_back"></a>vector::emplace_back</h4><p>在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。</p><p>这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。</p><p>该元素是通过调用allocator_traits :: construct来转换args来创建的。</p><p>与push_back相比，emplace_back可以避免额外的复制和移动操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_back</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">President</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> country;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line"> </span><br><span class="line">    President(<span class="built_in">std</span>::<span class="built_in">string</span> p_name, <span class="built_in">std</span>::<span class="built_in">string</span> p_country, <span class="keyword">int</span> p_year)</span><br><span class="line">        : name(<span class="built_in">std</span>::move(p_name)), country(<span class="built_in">std</span>::move(p_country)), year(p_year)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being constructed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President(President&amp;&amp; other)</span><br><span class="line">        : name(<span class="built_in">std</span>::move(other.name)), country(<span class="built_in">std</span>::move(other.country)), year(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being moved.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> President&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; elections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:\n"</span>;</span><br><span class="line">    elections.emplace_back(<span class="string">"Nelson Mandela"</span>, <span class="string">"South Africa"</span>, <span class="number">1994</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; reElections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\npush_back:\n"</span>;</span><br><span class="line">    reElections.push_back(President(<span class="string">"Franklin Delano Roosevelt"</span>, <span class="string">"the USA"</span>, <span class="number">1936</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nContents:\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: elections) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was elected president of "</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: reElections) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was re-elected president of "</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">I am being constructed.</span><br><span class="line"> </span><br><span class="line">push_back:</span><br><span class="line">I am being constructed.</span><br><span class="line">I am being moved.</span><br><span class="line"> </span><br><span class="line">Contents:</span><br><span class="line">Nelson Mandela was elected president of South Africa in 1994.</span><br><span class="line">Franklin Delano Roosevelt was re-elected president of the USA in 1936.</span><br></pre></td></tr></table></figure><h4 id="vector-get-allocator"><a href="#vector-get-allocator" class="headerlink" title="vector::get_allocator"></a>vector::get_allocator</h4><p>返回与vector关联的构造器对象的副本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="keyword">int</span> * p;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate an array with space for 5 elements using vector's allocator:</span></span><br><span class="line">  p = myvector.get_allocator().allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// construct values in-place on the array:</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) myvector.get_allocator().construct(&amp;p[i],i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The allocated array contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; p[i];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// destroy and deallocate:</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) myvector.get_allocator().destroy(&amp;p[i]);</span><br><span class="line">  myvector.get_allocator().deallocate(p,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The allocated array contains: 0 1 2 3 4</span><br></pre></td></tr></table></figure><h4 id="relational-operators-vector"><a href="#relational-operators-vector" class="headerlink" title="relational operators (vector)"></a>relational operators (vector)</h4><h4 id="swap-vector"><a href="#swap-vector" class="headerlink" title="swap (vector)"></a>swap (vector)</h4><h4 id="vector-1"><a href="#vector-1" class="headerlink" title="vector "></a>vector <bool></bool></h4><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。</p><p>特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。</p><p>因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。</p><p>两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。</p><p>对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。</p><p>deque上常见操作的复杂性（效率）如下： </p><ul><li>随机访问 - 常数O(1) </li><li>在结尾或开头插入或移除元素 - 摊销不变O(1) </li><li>插入或移除元素 - 线性O(n)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt; &gt; <span class="title">class</span> <span class="title">deque</span>;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="http://img.blog.csdn.net/20170727225856144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlg2Nzc1ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br><img src="https://images0.cnblogs.com/blog/559453/201401/092150340824.png" alt></p><h4 id="deque-deque"><a href="#deque-deque" class="headerlink" title="deque::deque"></a>deque::deque</h4><p>构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容：</p><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; first;                                <span class="comment">// empty deque of ints</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; second (<span class="number">4</span>,<span class="number">100</span>);                       <span class="comment">// four ints with value 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; third (second.begin(),second.end());  <span class="comment">// iterating through second</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; fourth (third);                       <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// the iterator constructor can be used to copy arrays:</span></span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; fifth (myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of fifth are:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The contents of fifth are: 16 2 77 29</span><br></pre></td></tr></table></figure><h4 id="deque-push-back"><a href="#deque-push-back" class="headerlink" title="deque::push_back"></a>deque::push_back</h4><p>在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。</p><p>这有效地增加了一个容器的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line">  <span class="keyword">int</span> myint;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter some integers (enter 0 to end):\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; myint;</span><br><span class="line">    mydeque.push_back (myint);</span><br><span class="line">  &#125; <span class="keyword">while</span> (myint);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque stores "</span> &lt;&lt; (<span class="keyword">int</span>) mydeque.size() &lt;&lt; <span class="string">" numbers.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-push-front"><a href="#deque-push-front" class="headerlink" title="deque::push_front"></a>deque::push_front</h4><p>在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。</p><p>这有效地增加了一个容器的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque (<span class="number">2</span>,<span class="number">100</span>);     <span class="comment">// two ints with a value of 100</span></span><br><span class="line">  mydeque.push_front (<span class="number">200</span>);</span><br><span class="line">  mydeque.push_front (<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">300 200 100 100</span><br></pre></td></tr></table></figure><h4 id="deque-pop-back"><a href="#deque-pop-back" class="headerlink" title="deque::pop_back"></a>deque::pop_back</h4><p>删除deque容器中的最后一个元素，有效地将容器大小减少一个。</p><p>这破坏了被删除的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  mydeque.push_back (<span class="number">10</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">20</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!mydeque.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    sum+=mydeque.back();</span><br><span class="line">    mydeque.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The elements of mydeque add up to "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The elements of mydeque add up to 60</span><br></pre></td></tr></table></figure><h4 id="deque-pop-front"><a href="#deque-pop-front" class="headerlink" title="deque::pop_front"></a>deque::pop_front</h4><p>删除deque容器中的第一个元素，有效地减小其大小。</p><p>这破坏了被删除的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">  mydeque.push_back (<span class="number">100</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">200</span>);</span><br><span class="line">  mydeque.push_back (<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Popping out the elements in mydeque:"</span>;</span><br><span class="line">  <span class="keyword">while</span> (!mydeque.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; mydeque.front();</span><br><span class="line">    mydeque.pop_front();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe final size of mydeque is "</span> &lt;&lt; <span class="keyword">int</span>(mydeque.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Popping out the elements in mydeque: 100 200 300</span><br><span class="line">The final size of mydeque is 0</span><br></pre></td></tr></table></figure><h4 id="deque-emplace-front"><a href="#deque-emplace-front" class="headerlink" title="deque::emplace_front"></a>deque::emplace_front</h4><p>在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。</p><p>这有效地增加了一个容器的大小。</p><p>该元素是通过调用allocator_traits::construct来转换args来创建的。</p><p>存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_front</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mydeque.emplace_front (<span class="number">111</span>);</span><br><span class="line">  mydeque.emplace_front (<span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: mydeque)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydeque contains: 222 111 10 20 30</span><br></pre></td></tr></table></figure><h4 id="deque-emplace-back"><a href="#deque-emplace-back" class="headerlink" title="deque::emplace_back"></a>deque::emplace_back</h4><p>在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。</p><p>这有效地增加了一个容器的大小。</p><p>该元素是通过调用allocator_traits::construct来转换args来创建的。</p><p>存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_back</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mydeque.emplace_back (<span class="number">100</span>);</span><br><span class="line">  mydeque.emplace_back (<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mydeque contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: mydeque)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydeque contains: 10 20 30 100 200</span><br></pre></td></tr></table></figure><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。</p><p>forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表</p><p>之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。</p><p>与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。</p><p>的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。</p><p>该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。</p><p><img src="http://img.blog.csdn.net/20160407212133266" alt></p><h4 id="forward-list-forward-list"><a href="#forward-list-forward-list" class="headerlink" title="forward_list::forward_list"></a>forward_list::forward_list</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line">fill (<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line">range (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">forward_list</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br><span class="line">copy (<span class="number">4</span>)</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst);</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line">move (<span class="number">5</span>)</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst);</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">forward_list</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; first;                      <span class="comment">// default: empty</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; second (<span class="number">3</span>,<span class="number">77</span>);              <span class="comment">// fill: 3 seventy-sevens</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; third (second.begin(), second.end()); <span class="comment">// range initialization</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; fourth (third);            <span class="comment">// copy constructor</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; fifth (<span class="built_in">std</span>::move(fourth));  <span class="comment">// move ctor. (fourth wasted)</span></span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; sixth = &#123;<span class="number">3</span>, <span class="number">52</span>, <span class="number">25</span>, <span class="number">90</span>&#125;;    <span class="comment">// initializer_list constructor</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first:"</span> ; <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: first)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second:"</span>; <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: second) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"third:"</span>;  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: third)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fourth:"</span>; <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: fourth) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fifth:"</span>;  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: fifth)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sixth:"</span>;  <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: sixth)  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">forward_list constructor examples:</span><br><span class="line">first:</span><br><span class="line">second: 77 77 77</span><br><span class="line">third: 77 77 77</span><br><span class="line">fourth:</span><br><span class="line">fifth: 77 77 77</span><br><span class="line">sixth: 3 52 25 90</span><br></pre></td></tr></table></figure><h4 id="forward-list-forward-list-1"><a href="#forward-list-forward-list-1" class="headerlink" title="forward_list::~forward_list"></a>forward_list::~forward_list</h4><h4 id="forward-list-before-begin"><a href="#forward-list-before-begin" class="headerlink" title="forward_list::before_begin"></a>forward_list::before_begin</h4><p>返回指向容器中第一个元素之前的位置的迭代器。</p><p>返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; mylist = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mylist.insert_after ( mylist.before_begin(), <span class="number">11</span> );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x: mylist ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist contains: 11 20 30 40 50</span><br></pre></td></tr></table></figure><h4 id="forward-list-cbefore-begin"><a href="#forward-list-cbefore-begin" class="headerlink" title="forward_list::cbefore_begin"></a>forward_list::cbefore_begin</h4><p>返回指向容器中第一个元素之前的位置的const_iterator。</p><p>一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。</p><p>返回的价值不得解除引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">cbefore_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; mylist = &#123;<span class="number">77</span>, <span class="number">2</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">  mylist.insert_after ( mylist.cbefore_begin(), <span class="number">19</span> );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span>&amp; x: mylist ) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist contains: 19 77 2 16</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。</p><p>在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;</span><br></pre></td></tr></table></figure><p>在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // <span class="title">map</span>:</span>:key_type</span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                                       // <span class="title">map</span>:</span>:mapped_type</span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,                     // <span class="title">map</span>:</span>:key_compare</span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;pair&lt;const Key,T&gt; &gt;    // <span class="title">map</span>:</span>:allocator_type</span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure><h4 id="map-map"><a href="#map-map" class="headerlink" title="map::map"></a>map::map</h4><p>构造一个映射容器对象，根据所使用的构造器版本初始化其内容：</p><p>（1）空容器构造函数（默认构造函数）</p><p>构造一个空的容器，没有元素。</p><p>（2）范围构造函数</p><p>构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。</p><p>（3）复制构造函数（并用分配器复制）</p><p>使用x中的每个元素的副本构造一个容器。</p><p>（4）移动构造函数（并与分配器一起移动）</p><p>构造一个获取x元素的容器。<br>如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。<br>x保持未指定但有效的状态。</p><p>（5）初始化列表构造函数</p><p>用il中的每个元素的副本构造一个容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">empty (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">map</span> <span class="params">(<span class="keyword">const</span> key_compare&amp; comp = key_compare(),</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">map</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc)</span></span>;</span><br><span class="line">range (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">map</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">key_compare</span>&amp; <span class="title">comp</span> = <span class="title">key_compare</span>(),</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">allocator_type</span>&amp; = <span class="title">allocator_type</span>());</span></span><br><span class="line">copy (<span class="number">3</span>)</span><br><span class="line"><span class="built_in">map</span> (<span class="keyword">const</span> <span class="built_in">map</span>&amp; x);</span><br><span class="line"><span class="built_in">map</span> (<span class="keyword">const</span> <span class="built_in">map</span>&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line">move (<span class="number">4</span>)</span><br><span class="line"><span class="built_in">map</span> (<span class="built_in">map</span>&amp;&amp; x);</span><br><span class="line"><span class="built_in">map</span> (<span class="built_in">map</span>&amp;&amp; x, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br><span class="line"><span class="function">initializer <span class="title">list</span> <span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">map</span> <span class="params">(<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> key_compare&amp; comp = key_compare(),</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fncomp</span> <span class="params">(<span class="keyword">char</span> lhs, <span class="keyword">char</span> rhs)</span> </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classcomp</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>&amp; lhs, <span class="keyword">const</span> <span class="keyword">char</span>&amp; rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; first;</span><br><span class="line"></span><br><span class="line">  first[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">  first[<span class="string">'b'</span>]=<span class="number">30</span>;</span><br><span class="line">  first[<span class="string">'c'</span>]=<span class="number">50</span>;</span><br><span class="line">  first[<span class="string">'d'</span>]=<span class="number">70</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; second (first.begin(),first.end());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; third (second);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>,classcomp&gt; fourth;                 <span class="comment">// class as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span>(*fn_pt)(<span class="keyword">char</span>,<span class="keyword">char</span>) = fncomp;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>,<span class="keyword">bool</span>(*)(<span class="keyword">char</span>,<span class="keyword">char</span>)&gt; fifth (fn_pt); <span class="comment">// function pointer as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-begin"><a href="#map-begin" class="headerlink" title="map::begin"></a>map::begin</h4><p>返回引用map容器中第一个元素的迭代器。</p><p>由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。</p><p>如果容器是空的，则返回的迭代器值不应被解除引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'b'</span>] = <span class="number">100</span>;</span><br><span class="line">  mymap[<span class="string">'a'</span>] = <span class="number">200</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>] = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// show content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; 200</span><br><span class="line">b =&gt; 100</span><br><span class="line">c =&gt; 300</span><br></pre></td></tr></table></figure><h4 id="map-key-comp"><a href="#map-key-comp" class="headerlink" title="map::key_comp"></a>map::key_comp</h4><p>返回容器用于比较键的比较对象的副本。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::key_compare mycomp = mymap.key_comp();</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">100</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">200</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap contains:\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> highest = mymap.rbegin()-&gt;first;     <span class="comment">// key value of last element</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( mycomp((*it++).first, highest) );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mymap contains:</span><br><span class="line">a =&gt; 100</span><br><span class="line">b =&gt; 200</span><br><span class="line">c =&gt; 300</span><br></pre></td></tr></table></figure><h4 id="map-value-comp"><a href="#map-value-comp" class="headerlink" title="map::value_comp"></a>map::value_comp</h4><p>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'x'</span>]=<span class="number">1001</span>;</span><br><span class="line">  mymap[<span class="string">'y'</span>]=<span class="number">2002</span>;</span><br><span class="line">  mymap[<span class="string">'z'</span>]=<span class="number">3003</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap contains:\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; highest = *mymap.rbegin();          <span class="comment">// last element</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( mymap.value_comp()(*it++, highest) );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mymap contains:</span><br><span class="line">x =&gt; 1001</span><br><span class="line">y =&gt; 2002</span><br><span class="line">z =&gt; 3003</span><br></pre></td></tr></table></figure><h4 id="map-find"><a href="#map-find" class="headerlink" title="map::find"></a>map::find</h4><p>在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。</p><p>如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。 </p><p>另一个成员函数map::count可以用来检查一个特定的键是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">50</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">100</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">150</span>;</span><br><span class="line">  mymap[<span class="string">'d'</span>]=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  it = mymap.find(<span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != mymap.end())</span><br><span class="line">    mymap.erase (it);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// print content:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"elements in mymap:"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a =&gt; "</span> &lt;&lt; mymap.find(<span class="string">'a'</span>)-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c =&gt; "</span> &lt;&lt; mymap.find(<span class="string">'c'</span>)-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d =&gt; "</span> &lt;&lt; mymap.find(<span class="string">'d'</span>)-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elements in mymap:</span><br><span class="line">a =&gt; 50</span><br><span class="line">c =&gt; 150</span><br><span class="line">d =&gt; 200</span><br></pre></td></tr></table></figure><h4 id="map-count"><a href="#map-count" class="headerlink" title="map::count"></a>map::count</h4><p>在容器中搜索具有等于k的键的元素，并返回匹配的数量。</p><p>由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。</p><p>如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">  mymap [<span class="string">'a'</span>]=<span class="number">101</span>;</span><br><span class="line">  mymap [<span class="string">'c'</span>]=<span class="number">202</span>;</span><br><span class="line">  mymap [<span class="string">'f'</span>]=<span class="number">303</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (c=<span class="string">'a'</span>; c&lt;<span class="string">'h'</span>; c++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    <span class="keyword">if</span> (mymap.count(c)&gt;<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" is an element of mymap.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" is not an element of mymap.\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a is an element of mymap.</span><br><span class="line">b is not an element of mymap.</span><br><span class="line">c is an element of mymap.</span><br><span class="line">d is not an element of mymap.</span><br><span class="line">e is not an element of mymap.</span><br><span class="line">f is an element of mymap.</span><br><span class="line">g is not an element of mymap.</span><br></pre></td></tr></table></figure><h4 id="map-lower-bound"><a href="#map-lower-bound" class="headerlink" title="map::lower_bound"></a>map::lower_bound</h4><p>将迭代器返回到下限</p><p>返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。</p><p>该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。</p><p>如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。</p><p>一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">lower_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator itlow,itup;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">20</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">40</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">60</span>;</span><br><span class="line">  mymap[<span class="string">'d'</span>]=<span class="number">80</span>;</span><br><span class="line">  mymap[<span class="string">'e'</span>]=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  itlow=mymap.lower_bound (<span class="string">'b'</span>);  <span class="comment">// itlow points to b</span></span><br><span class="line">  itup=mymap.upper_bound (<span class="string">'d'</span>);   <span class="comment">// itup points to e (not d!)</span></span><br><span class="line"></span><br><span class="line">  mymap.erase(itlow,itup);        <span class="comment">// erases [itlow,itup)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// print content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; 20</span><br><span class="line">e =&gt; 100</span><br></pre></td></tr></table></figure><h4 id="map-upper-bound"><a href="#map-upper-bound" class="headerlink" title="map::upper_bound"></a>map::upper_bound</h4><p>将迭代器返回到上限</p><p>返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。</p><p>该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。</p><p>如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。</p><p>类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">upper_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator itlow,itup;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">20</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">40</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">60</span>;</span><br><span class="line">  mymap[<span class="string">'d'</span>]=<span class="number">80</span>;</span><br><span class="line">  mymap[<span class="string">'e'</span>]=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  itlow=mymap.lower_bound (<span class="string">'b'</span>);  <span class="comment">// itlow points to b</span></span><br><span class="line">  itup=mymap.upper_bound (<span class="string">'d'</span>);   <span class="comment">// itup points to e (not d!)</span></span><br><span class="line"></span><br><span class="line">  mymap.erase(itlow,itup);        <span class="comment">// erases [itlow,itup)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// print content:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; 20</span><br><span class="line">e =&gt; 100</span><br></pre></td></tr></table></figure><h4 id="map-equal-range"><a href="#map-equal-range" class="headerlink" title="map::equal_range"></a>map::equal_range</h4><p>获取相同元素的范围</p><p>返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。 </p><p>如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;const_iterator,const_iterator&gt; equal_range (<span class="keyword">const</span> key_type&amp; k) <span class="keyword">const</span>;</span><br><span class="line">pair&lt;iterator,iterator&gt;             equal_range (<span class="keyword">const</span> key_type&amp; k);</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">  mymap[<span class="string">'b'</span>]=<span class="number">20</span>;</span><br><span class="line">  mymap[<span class="string">'c'</span>]=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator,<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator&gt; ret;</span><br><span class="line">  ret = mymap.equal_range(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lower bound points to: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"upper bound points to: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ret.second-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; ret.second-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lower bound points to: &apos;b&apos; =&gt; 20</span><br><span class="line">upper bound points to: &apos;c&apos; =&gt; 30</span><br></pre></td></tr></table></figure><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><h3 id="无序容器（Unordered-Container）：unordered-set、unordered-multiset、unordered-map、unordered-multimap"><a href="#无序容器（Unordered-Container）：unordered-set、unordered-multiset、unordered-map、unordered-multimap" class="headerlink" title="无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap"></a>无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap</h3><p>包括：</p><ul><li>unordered_set</li><li>unordered_multiset</li><li>unordered_map</li><li>unordered_multimap</li></ul><p>都是以哈希表实现的。</p><p><img src="http://img.blog.csdn.net/20160410123436394" alt></p><p>unordered_set、unodered_multiset结构：</p><p><img src="http://img.blog.csdn.net/20160410123518692" alt></p><p>unordered_map、unodered_multimap结构：</p><p><img src="http://img.blog.csdn.net/20160410123525739" alt></p><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h3 id="unordered-multiset"><a href="#unordered-multiset" class="headerlink" title="unordered_multiset"></a>unordered_multiset</h3><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><h3 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h3><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Types</span>&gt; <span class="title">class</span> <span class="title">tuple</span>;</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple, std::get, std::tie, std::ignore</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; foo (<span class="number">10</span>,<span class="string">'x'</span>);</span><br><span class="line">  <span class="keyword">auto</span> bar = <span class="built_in">std</span>::make_tuple (<span class="string">"test"</span>, <span class="number">3.1</span>, <span class="number">14</span>, <span class="string">'y'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(bar) = <span class="number">100</span>;                                    <span class="comment">// access element</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myint; <span class="keyword">char</span> mychar;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tie (myint, mychar) = foo;                            <span class="comment">// unpack elements</span></span><br><span class="line">  <span class="built_in">std</span>::tie (<span class="built_in">std</span>::ignore, <span class="built_in">std</span>::ignore, myint, mychar) = bar;  <span class="comment">// unpack (with ignore)</span></span><br><span class="line"></span><br><span class="line">  mychar = <span class="built_in">std</span>::get&lt;<span class="number">3</span>&gt;(bar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(foo) = <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(bar);</span><br><span class="line">  <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(foo) = mychar;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(foo) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(foo) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo contains: 100 y</span><br></pre></td></tr></table></figure><h4 id="tuple-tuple"><a href="#tuple-tuple" class="headerlink" title="tuple::tuple"></a>tuple::tuple</h4><p>构建一个 tuple（元组）对象。</p><p>这涉及单独构建其元素，初始化取决于调用的构造函数形式：</p><p>（1）默认的构造函数</p><p>构建一个 元组对象的元素值初始化。</p><p>（2）复制/移动构造函数</p><p>该对象使用tpl的内容进行初始化 元组目的。tpl<br>的相应元素被传递给每个元素的构造函数。</p><p>（3）隐式转换构造函数</p><p>同上。tpl中的<br>所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。</p><p>（4）初始化构造函数<br>用elems中的相应元素初始化每个元素。elems<br>的相应元素被传递给每个元素的构造函数。</p><p>（5）对转换构造函数</p><p>该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。</p><p>（6）分配器版本</p><p>和上面的版本一样，除了每个元素都是使用allocator alloc构造的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line">copy / move (<span class="number">2</span>)</span><br><span class="line">tuple (<span class="keyword">const</span> tuple&amp; tpl) = <span class="keyword">default</span>;</span><br><span class="line">tuple (tuple&amp;&amp; tpl) = <span class="keyword">default</span>;</span><br><span class="line"><span class="function">implicit <span class="title">conversion</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">template &lt;class... UTypes&gt;</span><br><span class="line">  tuple (<span class="keyword">const</span> tuple&lt;UTypes...&gt;&amp; tpl);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span></span><br><span class="line">initialization (<span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="keyword">const</span> Types&amp;... elems)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">explicit</span> <span class="title">tuple</span> (<span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span></span><br><span class="line"><span class="function">conversion from <span class="title">pair</span> <span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line">template &lt;class U1, class U2&gt;</span><br><span class="line">  tuple (<span class="keyword">const</span> pair&lt;U1,U2&gt;&amp; pr);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span></span><br><span class="line">allocator (<span class="number">6</span>)</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">tuple</span>&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">tuple</span>&amp;&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>,<span class="title">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">tuple</span>&lt;UTypes...&gt;&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">Types</span>&amp;... <span class="title">elems</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">const</span> <span class="title">pair</span>&lt;U1,U2&gt;&amp; <span class="title">pr</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">tuple</span> (<span class="title">allocator_arg_t</span> <span class="title">aa</span>, <span class="title">const</span> <span class="title">Alloc</span>&amp; <span class="title">alloc</span>, <span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // std::make_pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple, std::make_tuple, std::get</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; first;                             <span class="comment">// default</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; second (first);                    <span class="comment">// copy</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; third (<span class="built_in">std</span>::make_tuple(<span class="number">20</span>,<span class="string">'b'</span>));   <span class="comment">// move</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">long</span>,<span class="keyword">char</span>&gt; fourth (third);                   <span class="comment">// implicit conversion</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; fifth (<span class="number">10</span>,<span class="string">'a'</span>);                    <span class="comment">// initialization</span></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; sixth (<span class="built_in">std</span>::make_pair(<span class="number">30</span>,<span class="string">'c'</span>));    <span class="comment">// from pair / move</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sixth contains: "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(sixth);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" and "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(sixth) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sixth contains: 30 and c</span><br></pre></td></tr></table></figure><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。</p><p>pair是tuple（元组）的一个特例。</p><p>pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p><p>应用：</p><ul><li>可以将两个类型数据组合成一个如map&lt;key, value&gt;</li><li>当某个函数需要两个返回值时</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">struct</span> <span class="title">pair</span>;</span></span><br></pre></td></tr></table></figure><h4 id="pair-pair"><a href="#pair-pair" class="headerlink" title="pair::pair"></a>pair::pair</h4><p>构建一个pair对象。</p><p>这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式：</p><p>（1）默认的构造函数</p><p>构建一个 对对象的元素值初始化。</p><p>（2）复制/移动构造函数（和隐式转换）</p><p>该对象被初始化为pr的内容 对目的。pr<br>的相应成员被传递给每个成员的构造函数。</p><p>（3）初始化构造函数</p><p>会员 第一是由一个和成员构建的第二与b。</p><p>（4）分段构造</p><p>构造成员 first  和 second  到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">pair</span><span class="params">()</span></span>;</span><br><span class="line">copy / move (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">V</span>&gt; <span class="title">pair</span> (<span class="title">const</span> <span class="title">pair</span>&lt;U,V&gt;&amp; <span class="title">pr</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">V</span>&gt; <span class="title">pair</span> (<span class="title">pair</span>&lt;U,V&gt;&amp;&amp; <span class="title">pr</span>);</span></span><br><span class="line">pair (<span class="keyword">const</span> pair&amp; pr) = <span class="keyword">default</span>;</span><br><span class="line">pair (pair&amp;&amp; pr) = <span class="keyword">default</span>;</span><br><span class="line">initialization (<span class="number">3</span>)</span><br><span class="line">pair (<span class="keyword">const</span> first_type&amp; a, <span class="keyword">const</span> second_type&amp; b);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">V</span>&gt; <span class="title">pair</span> (<span class="title">U</span>&amp;&amp; <span class="title">a</span>, <span class="title">V</span>&amp;&amp; <span class="title">b</span>);</span></span><br><span class="line">piecewise (<span class="number">4</span>)</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args1</span>, <span class="title">class</span>... <span class="title">Args2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">pair</span> (<span class="title">piecewise_construct_t</span> <span class="title">pwc</span>, <span class="title">tuple</span>&lt;Args1...&gt; <span class="title">first_args</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">tuple</span>&lt;Args2...&gt; <span class="title">second_args</span>);</span></span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // std::pair, std::make_pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product1;                     <span class="comment">// default constructor</span></span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product2 (<span class="string">"tomatoes"</span>,<span class="number">2.30</span>);   <span class="comment">// value init</span></span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product3 (product2);          <span class="comment">// copy constructor</span></span><br><span class="line"></span><br><span class="line">  product1 = <span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"lightbulbs"</span>),<span class="number">0.99</span>);   <span class="comment">// using make_pair (move)</span></span><br><span class="line"></span><br><span class="line">  product2.first = <span class="string">"shoes"</span>;                  <span class="comment">// the type of first is string</span></span><br><span class="line">  product2.second = <span class="number">39.90</span>;                   <span class="comment">// the type of second is double</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product1.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product1.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product2.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product2.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product3.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product3.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The price of lightbulbs is $0.99</span><br><span class="line">The price of shoes is $39.9</span><br><span class="line">The price of tomatoes is $2.3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;STL&quot;&gt;&lt;a href=&quot;#STL&quot; class=&quot;headerlink&quot; title=&quot;STL&quot;&gt;&lt;/a&gt;STL&lt;/h1&gt;&lt;h2 id=&quot;网站&quot;&gt;&lt;a href=&quot;#网站&quot; class=&quot;headerlink&quot; title=&quot;网站&quot;&gt;&lt;/a&gt;网站&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9ub3RlL2Jsb2IvbWFzdGVyL1NUTC5tZA==&quot; title=&quot;https://github.com/huihut/note/blob/master/STL.md&quot;&gt;github . huihut/note/STL.md&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdGwv&quot; title=&quot;http://www.cplusplus.com/reference/stl/&quot;&gt;cplusplus . stl&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3poLmNwcHJlZmVyZW5jZS5jb20vdy8lRTklQTYlOTYlRTklQTElQjU=&quot; title=&quot;http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5&quot;&gt;cppreference . C++ 参考手册&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sdW1uL2RldGFpbHMvZ2Vlay1zdGwuaHRtbA==&quot; title=&quot;http://blog.csdn.net/column/details/geek-stl.html&quot;&gt;CSDN专栏：STL学习笔记&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Interview C C++</title>
    <link href="http://miaopei.github.io/2016/06/08/Program-C/interview/"/>
    <id>http://miaopei.github.io/2016/06/08/Program-C/interview/</id>
    <published>2016-06-08T02:14:50.000Z</published>
    <updated>2019-06-14T06:12:15.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-C-面试知识总结"><a href="#C-C-面试知识总结" class="headerlink" title="C/C++ 面试知识总结"></a>C/C++ 面试知识总结</h1><p>C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。</p><p>勘误新增请 Issue、PR，建议、讨论请 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvaXNzdWVzLzEy" title="https://github.com/huihut/interview/issues/12">#issues/12<i class="fa fa-external-link"></i></span>，排版使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL216bG9naW4vY2hpbmVzZS1jb3B5d3JpdGluZy1ndWlkZWxpbmVz" title="https://github.com/mzlogin/chinese-copywriting-guidelines">中文文案排版指北<i class="fa fa-external-link"></i></span></p><p>使用建议：</p><ul><li><code>Ctrl + F</code>：快速查找定位知识点</li><li><code>TOC 导航</code>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phd2lsL0dheUh1Yg==" title="https://github.com/jawil/GayHub">jawil/GayHub<i class="fa fa-external-link"></i></span> 插件快速目录跳转</li></ul><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#cc">C/C++</a></li><li><a href="#stl">STL</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li><li><a href="#%E7%AE%97%E6%B3%95">算法</a></li><li><a href="#problems">Problems</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E5%BA%93">链接装载库</a></li><li><a href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">海量数据处理</a></li><li><a href="#%E9%9F%B3%E8%A7%86%E9%A2%91">音视频</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li><li><a href="#%E4%B9%A6%E7%B1%8D">书籍</a></li><li><a href="#%E5%A4%8D%E4%B9%A0%E5%88%B7%E9%A2%98%E7%BD%91%E7%AB%99">复习刷题网站</a></li><li><a href="#%E6%8B%9B%E8%81%98%E6%97%B6%E9%97%B4%E5%B2%97%E4%BD%8D">招聘时间岗位</a></li><li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E7%BB%8F%E9%AA%8C">面试题目经验</a></li></ul><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针和指针常量；</li><li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><details><summary>const 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="comment">// 还有其中区别方法，沿着 * 号划一条线：</span></span><br><span class="line"><span class="comment">// 如果const位于 * 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；</span></span><br><span class="line"><span class="comment">// 如果const位于 * 的右侧，const就是修饰指针本身，即指针本身是常量。</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure></details><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。</li><li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ol><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81YzM1Y2MyMThiYjQ=" title="https://www.jianshu.com/p/5c35cc218bb4">C++ static 和const 的作用<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 <code>this</code> 指针：<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol><h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>不能包含循环、递归、switch 等复杂操作；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><details><summary>inline 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure></details><h4 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h4><ol><li>将 inline 函数体复制到 inline 函数调用点处； </li><li>为所用 inline 函数中的局部变量分配内存空间； </li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h4 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h4><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcy50ZWNobmlvbi5hYy5pbC91c2Vycy95ZWNoaWVsL2MrKy1mYXEvaW5saW5lLXZpcnR1YWxzLmh0bWw=" title="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html">Are “inline virtual” member functions ever actually “inlined”?<i class="fa fa-external-link"></i></span></p><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><details><summary>虚函数内联使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">Base b;</span><br><span class="line">b.who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">ptr-&gt;who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p><details><summary>assert() 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure></details><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h3><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul><h3 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h3><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p><details><summary>#pragma pack(n) 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure></details><h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bit mode: <span class="number">2</span>;    <span class="comment">// mode 占 2 位</span></span><br></pre></td></tr></table></figure><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和连接的</li></ul><p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><details><summary>extern "C" 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></details><h3 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h3><h4 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p><p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p><h4 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h4><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p><p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p><p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student(); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h3><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>最本质的一个区别就是默认的访问控制<ol><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ol></li></ul><h3 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><details><summary>union 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h3><p><span class="exturl" data-url="aHR0cDovL2Rvbmd4aWNoZW5nLm9yZy9jcHAvb29jLw==" title="http://dongxicheng.org/cpp/ooc/">C 语言实现封装、继承和多态<i class="fa fa-external-link"></i></span></p><h3 id="explicit（显式）构造函数"><a href="#explicit（显式）构造函数" class="headerlink" title="explicit（显式）构造函数"></a>explicit（显式）构造函数</h3><p>explicit 修饰的构造函数可用来防止隐式转换</p><details><summary>explicit 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test1(<span class="keyword">int</span> n)            <span class="comment">// 普通构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> n)</span>   <span class="comment">// explicit（显式）构造函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test1 t1=<span class="number">12</span>;            <span class="comment">// 隐式调用其构造函数，成功</span></span><br><span class="line">    Test2 t2=<span class="number">12</span>;            <span class="comment">// 编译错误，不能隐式调用其构造函数</span></span><br><span class="line">    <span class="function">Test2 <span class="title">t2</span><span class="params">(<span class="number">12</span>)</span></span>;           <span class="comment">// 显式调用成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h3><ul><li>能访问私有成员  </li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><h4 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h4><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure><h4 id="构造函数的-using-声明【C-11】"><a href="#构造函数的-using-声明【C-11】" class="headerlink" title="构造函数的 using 声明【C++11】"></a>构造函数的 using 声明【C++11】</h4><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">derived(parms) : base(args) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h4><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure><h4 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 <code>using 指示</code> 污染命名空间</h4><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了制定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><details><summary>using 使用</summary> <p>尽量少使用 <code>using 指示</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>应该多使用 <code>using 声明</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></details><h3 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ol><details><summary>:: 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    count = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h3><h4 id="限定作用域的枚举类型"><a href="#限定作用域的枚举类型" class="headerlink" title="限定作用域的枚举类型"></a>限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span> input, output, append &#125;;</span><br></pre></td></tr></table></figure><h4 id="不限定作用域的枚举类型"><a href="#不限定作用域的枚举类型" class="headerlink" title="不限定作用域的枚举类型"></a>不限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy53ZWl4dWV5dWFuLm5ldC92aWV3LzU4MjQuaHRtbA==" title="http://www.weixueyuan.net/view/5824.html">C++ 枚举类型详解<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure><details><summary>decltype 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>常规引用，一般表示对象的身份。</p><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p><p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p><ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li></ul><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aWFvbHUxMTc1L2FydGljbGUvZGV0YWlscy80Njg4OTUyMw==" title="https://blog.csdn.net/tianxiaolu1175/article/details/46889523">详解c++ 引用（reference）与 指针（pointer）的区别与联系<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul><li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li></ul><h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><p>好处</p><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li></ol></li></ul><h3 id="initializer-list-列表初始化【C-11】"><a href="#initializer-list-列表初始化【C-11】" class="headerlink" title="initializer_list 列表初始化【C++11】"></a>initializer_list 列表初始化【C++11】</h3><p>用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p><details><summary>initializer_list 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.size() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.end(), l.begin(), l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> T*, <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; c_arr() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.size()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p><img src="http://img.my.csdn.net/uploads/201211/22/1353564524_6375.png" alt="面向对象特征"></p><p>面向对象三大特征 —— 封装、继承、多态</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li><li>关键字：public, protected, friendly, private。不写默认为 friendly。</li></ul><table><thead><tr><th>关键字</th><th>当前类</th><th>包内</th><th>子孙类</th><th>包外</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>friendly</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>基类（父类）——&gt; 派生类（子类）</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。</li><li>C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。</li><li>多态是以封装和继承为基础的。</li></ul><h4 id="静态多态（早绑定）"><a href="#静态多态（早绑定）" class="headerlink" title="静态多态（早绑定）"></a>静态多态（早绑定）</h4><p>函数重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态多态（晚绑定）"><a href="#动态多态（晚绑定）" class="headerlink" title="动态多态（晚绑定）"></a>动态多态（晚绑定）</h4><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li></ul><p><strong>注意：</strong></p><ul><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数，解释见：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcjJUU4JTk5JTlBJUU1JTg3JUJEJUU2JTk1JUIwdmlydHVhbCVFNSU4RiVBRiVFNCVCQiVBNSVFNiU5OCVBRiVFNSU4NiU4NSVFOCU4MSU5NCVFNSU4NyVCRCVFNiU5NSVCMGlubGluZSVFNSU5MCU5Nw==" title="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97">虚函数（virtual）可以是内联函数（inline）吗？<i class="fa fa-external-link"></i></span></li></ul><details><summary>动态多态使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                     // 形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p><details><summary>虚析构函数使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();    </span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIyNjAyMzgvYXJ0aWNsZS9kZXRhaWxzLzUzNjEwNDYy" title="https://blog.csdn.net/u012260238/article/details/53610462">CSDN . C++ 中的虚函数、纯虚函数区别和联系<i class="fa fa-external-link"></i></span></p><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 </li><li>虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 </li><li>带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。</li></ul><h3 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h3><ul><li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li></ul><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p><p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><h3 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h3><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h3 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h3><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h3 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h3><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有有定于任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数</li></ul></li></ul><h3 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a>内存分配和管理</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9jaGVucXguZ2l0aHViLmlvLzIwMTQvMDkvMjUvQ3BwLU1lbW9yeS1NYW5hZ2VtZW50Lw==" title="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">C/C++内存管理详解<i class="fa fa-external-link"></i></span> - ShinChan’s Blog</p></blockquote><h4 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h4><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ol><h4 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h4><p>用于分配、释放内存</p><details><summary>malloc、free 使用</summary> <p>申请内存，确认是否申请成功</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">assert(str != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>释放内存后指针置空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></details><h4 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h4><ol><li>new / new[]：完成两件事，先底层调用 malloc 分了配内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><details><summary>new、delete 使用</summary> <p>申请内存，确认是否申请成功</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t = <span class="keyword">new</span> T();     <span class="comment">// 先内存分配 ，再构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t;           <span class="comment">// 先析构函数，再内存释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="定位-new"><a href="#定位-new" class="headerlink" title="定位 new"></a>定位 new</h4><p>定位 new（placement new）允许我们向 new 传递额外的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (palce_address) type</span><br><span class="line"><span class="keyword">new</span> (palce_address) type (initializers)</span><br><span class="line"><span class="keyword">new</span> (palce_address) type [size]</span><br><span class="line"><span class="keyword">new</span> (palce_address) type [size] &#123; braced initializer <span class="built_in">list</span> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>palce_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h3 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h3><p><span class="exturl" data-url="aHR0cHM6Ly9pc29jcHAub3JnL3dpa2kvZmFxL2ZyZWVzdG9yZS1tZ210I2RlbGV0ZS10aGlz" title="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this">Is it legal (and moral) for a member function to say delete this?<i class="fa fa-external-link"></i></span></p><p>合法，但：</p><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol><h3 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvMGE1ODRhYTEzZjgwNGYzZWE3MmI0NDJhMDY1YTc2MTg=" title="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618">如何定义一个只能在堆上（栈上）生成对象的类?<i class="fa fa-external-link"></i></span></p><h4 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h4><p>方法：将析构函数设置为私有</p><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p><h4 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h4><p>方法：将 new 和 delete 重载为私有</p><p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2xleGlhby9hcnRpY2xlL2RldGFpbHMvNTY3NzMwMzk=" title="https://blog.csdn.net/haolexiao/article/details/56773039">C++11及C++14标准的智能指针<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4MTk4MjUyOTQvYXJ0aWNsZS9kZXRhaWxzLzUyMTM5MzI4" title="https://blog.csdn.net/a819825294/article/details/52139328">C++ 智能指针<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMTA0NjY2Lw==" title="http://blog.jobbole.com/104666/">使用 C++11 智能指针时要避开的 10 大错误<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h4><p>头文件：<code>#include &lt;memory&gt;</code></p><h4 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps (<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))；</span><br></pre></td></tr></table></figure><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h4><ol><li>shared_ptr</li><li>unique_ptr</li><li>weak_ptr</li><li>auto_ptr（被 C++11 弃用）</li></ol><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li><li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li></ul><h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p><ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li></ul><h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p><ul><li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li></ul><h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p><ul><li>unique_ptr 用于取代 auto_ptr</li></ul><h5 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h5><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p><h5 id="auto-ptr-与-unique-ptr-比较"><a href="#auto-ptr-与-unique-ptr-比较" class="headerlink" title="auto_ptr 与 unique_ptr 比较"></a>auto_ptr 与 unique_ptr 比较</h5><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li><li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li></ul><h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vemgtQ04vbGlicmFyeS81ZjZjOWY4aC5hc3B4" title="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx">MSDN . 强制转换运算符<i class="fa fa-external-link"></i></span></p><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ29vZGhhY2tlci9hcmNoaXZlLzIwMTEvMDcvMjAvMjExMTk5Ni5odG1s" title="https://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html">C++类型转换总结<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><ul><li>用于非多态类型的转换</li><li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li><li>通常用于转换数值数据类型（如 float -&gt; int）</li><li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li></ul><blockquote><p>向上转换是一种隐式转换。</p></blockquote><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li><li>执行行运行时类型检查</li><li>只适用于指针或引用</li><li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><ul><li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li></ul><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><ul><li>用于位的简单重新解释</li><li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li><li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li><li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li><li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li></ul><h4 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h4><ul><li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li></ul><details><summary>bad_cast 使用</summary> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Circle&amp; ref_circle = <span class="keyword">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> (bad_cast b) &#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught: "</span> &lt;&lt; b.what();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><h4 id="dynamic-cast-1"><a href="#dynamic-cast-1" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li></ul><h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><h4 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h4><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：<code>typeinfo</code></li></ul><details><summary>typeid、type_info 使用</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>                       // 能飞的</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>= <span class="number">0</span>;     <span class="comment">// 起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>= <span class="number">0</span>;        <span class="comment">// 降落</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> :</span> <span class="keyword">public</span> Flyable         <span class="comment">// 鸟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foraging</span><span class="params">()</span> </span>&#123;...&#125;           <span class="comment">// 觅食</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> :</span> <span class="keyword">public</span> Flyable        <span class="comment">// 飞机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">carry</span><span class="params">()</span> </span>&#123;...&#125;              <span class="comment">// 运输</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> take <span class="title">off</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info &amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">doSomething</span><span class="params">(Flyable *obj)</span>                 <span class="comment">// 做些事情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;takeoff();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*obj).name() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 输出传入对象类型（"class Bird" or "class Plane"）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(*obj) == <span class="keyword">typeid</span>(Bird))            <span class="comment">// 判断对象类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bird *bird = <span class="keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="comment">// 对象转化</span></span><br><span class="line">        bird-&gt;foraging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj-&gt;land();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h3 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h3><ol><li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li><li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li><li>尽可能使用 const</li><li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li><li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li><li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li><li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li><li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li><li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li><li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li><li>在 <code>operator=</code> 中处理 “自我赋值”</li><li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li><li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li><li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li><li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li><li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li><li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li><li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li><li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li><li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li><li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li><li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li><li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li><li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li><li>考虑写一个不抛异常的 swap 函数</li><li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li><li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li><li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li><li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li><li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li><li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能过够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li><li>确定你的 public 继承塑模出 is-a 关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li><li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li><li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li><li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li><li>绝不重新定义继承而来的 non-virtual 函数</li><li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li></ol><h3 id="Google-C-Style-Guide"><a href="#Google-C-Style-Guide" class="headerlink" title="Google C++ Style Guide"></a>Google C++ Style Guide</h3><blockquote><p>英文：<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL3N0eWxlZ3VpZGUvY3BwZ3VpZGUuaHRtbA==" title="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide<i class="fa fa-external-link"></i></span><br>中文：<span class="exturl" data-url="aHR0cHM6Ly96aC1nb29nbGUtc3R5bGVndWlkZS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvZ29vZ2xlLWNwcC1zdHlsZWd1aWRlL2NvbnRlbnRzLw==" title="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">C++ 风格指南<i class="fa fa-external-link"></i></span></p></blockquote><details><summary>Google C++ Style Guide 图</summary><p><img src="/images/imageProgramC/interview/GoogleCppStyleGuide.png" alt="Google C++ Style Guide"></p><blockquote><p>图片来源于：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZvaWRjY2MvYXJ0aWNsZS9kZXRhaWxzLzM3NTk5MjAz" title="https://blog.csdn.net/voidccc/article/details/37599203">CSDN . 一张图总结Google C++编程规范(Google C++ Style Guide)<i class="fa fa-external-link"></i></span></p></blockquote></details><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="STL-索引"><a href="#STL-索引" class="headerlink" title="STL 索引"></a>STL 索引</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RM" title="https://github.com/huihut/interview/tree/master/STL">STL 方法含义索引<i class="fa fa-external-link"></i></span></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTU2MDcxNjZmYjlhMDFjYjI1NmQ1MDE=" title="https://juejin.im/post/5a5607166fb9a01cb256d501">C++ STL容器总结<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h3><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI2FycmF5" title="https://github.com/huihut/interview/tree/master/STL#array">array<i class="fa fa-external-link"></i></span></td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持快速随机访问</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3ZlY3Rvcg==" title="https://github.com/huihut/interview/tree/master/STL#vector">vector<i class="fa fa-external-link"></i></span></td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1)<br>头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持快速随机访问</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI2xpc3Q=" title="https://github.com/huihut/interview/tree/master/STL#list">list<i class="fa fa-external-link"></i></span></td><td>双向链表</td><td>插入、删除 O(1)<br>随机读改 O(n)</td><td>无序</td><td>可重复</td><td>支持快速增删</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI2RlcXVl" title="https://github.com/huihut/interview/tree/master/STL#deque">deque<i class="fa fa-external-link"></i></span></td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3N0YWNr" title="https://github.com/huihut/interview/tree/master/STL#stack">stack<i class="fa fa-external-link"></i></span></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3F1ZXVl" title="https://github.com/huihut/interview/tree/master/STL#queue">queue<i class="fa fa-external-link"></i></span></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3ByaW9yaXR5X3F1ZXVl" title="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue<i class="fa fa-external-link"></i></span></td><td>vector + max-heap</td><td>插入、删除 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI3NldA==" title="https://github.com/huihut/interview/tree/master/STL#set">set<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI211bHRpc2V0" title="https://github.com/huihut/interview/tree/master/STL#multiset">multiset<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI21hcA==" title="https://github.com/huihut/interview/tree/master/STL#map">map<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvU1RMI211bHRpbWFw" title="https://github.com/huihut/interview/tree/master/STL#multimap">multimap<i class="fa fa-external-link"></i></span></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td>hash_set</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>hash_multiset</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td>hash_map</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>hash_multimap</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><h3 id="STL-算法"><a href="#STL-算法" class="headerlink" title="STL 算法"></a>STL 算法</h3><table><thead><tr><th>算法</th><th>底层算法</th><th>时间复杂度</th><th>可不可重复</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9hbGdvcml0aG0vZmluZC8=" title="http://www.cplusplus.com/reference/algorithm/find/">find<i class="fa fa-external-link"></i></span></td><td>顺序查找</td><td>O(n)</td><td>可重复</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2djYy1taXJyb3IvZ2NjL2Jsb2IvbWFzdGVyL2xpYnN0ZGMrKy12My9pbmNsdWRlL2JpdHMvc3RsX2FsZ28uaCNMNDgwOA==" title="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808">sort<i class="fa fa-external-link"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50cm9zb3J0" title="https://en.wikipedia.org/wiki/Introsort">内省排序<i class="fa fa-external-link"></i></span></td><td>O(n*log<sub>2</sub>n)</td><td>可重复</td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h4 id="顺序栈（Sequence-Stack）"><a href="#顺序栈（Sequence-Stack）" class="headerlink" title="顺序栈（Sequence Stack）"></a>顺序栈（Sequence Stack）</h4><p><a href="DataStructure/SqStack.cpp">SqStack.cpp</a></p><details><summary>顺序栈数据结构和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqSrack;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/SqStack.png" alt></p></details><h4 id="队列（Sequence-Queue）"><a href="#队列（Sequence-Queue）" class="headerlink" title="队列（Sequence Queue）"></a>队列（Sequence Queue）</h4><details><summary>队列数据结构</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType * elem;</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> maxSize;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></details><h5 id="非循环队列"><a href="#非循环队列" class="headerlink" title="非循环队列"></a>非循环队列</h5><details><summary>非循环队列图片</summary><p><img src="/images/imageProgramC/interview/SqQueue.png" alt></p><p><code>SqQueue.rear++</code></p></details><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><details><summary>循环队列图片</summary><p><img src="/images/imageProgramC/interview/SqLoopStack.png" alt></p><p><code>SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize</code></p></details><h4 id="顺序表（Sequence-List）"><a href="#顺序表（Sequence-List）" class="headerlink" title="顺序表（Sequence List）"></a>顺序表（Sequence List）</h4><p><a href="DataStructure/SqList.cpp">SqList.cpp</a></p><details><summary>顺序表数据结构和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/SqList.png" alt></p></details><h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><p><a href="DataStructure/LinkList.cpp">LinkList.cpp</a></p><p><a href="DataStructure/LinkList_with_head.cpp">LinkList_with_head.cpp</a></p><details><summary>链式数据结构</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure></details><h4 id="链队列（Link-Queue）"><a href="#链队列（Link-Queue）" class="headerlink" title="链队列（Link Queue）"></a>链队列（Link Queue）</h4><details><summary>链队列图片</summary><p><img src="/images/imageProgramC/interview/LinkQueue.png" alt></p></details><h4 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h4><h5 id="单链表（Link-List）"><a href="#单链表（Link-List）" class="headerlink" title="单链表（Link List）"></a>单链表（Link List）</h5><details><summary>单链表图片</summary><p><img src="/images/imageProgramC/interview/LinkList.png" alt></p></details><h5 id="双向链表（Du-Link-List）"><a href="#双向链表（Du-Link-List）" class="headerlink" title="双向链表（Du-Link-List）"></a>双向链表（Du-Link-List）</h5><details><summary>双向链表图片</summary><p><img src="/images/imageProgramC/interview/DuLinkList.png" alt></p></details><h5 id="循环链表（Cir-Link-List）"><a href="#循环链表（Cir-Link-List）" class="headerlink" title="循环链表（Cir-Link-List）"></a>循环链表（Cir-Link-List）</h5><details><summary>循环链表图片</summary><p><img src="/images/imageProgramC/interview/CirLinkList.png" alt></p></details><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="DataStructure/HashTable.cpp">HashTable.cpp</a></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>哈希函数：<code>H(key): K -&gt; D , key ∈ K</code></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>直接定址法</li><li>除留余数法</li><li>数字分析法</li><li>折叠法</li><li>平方取中法</li></ul><h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><ul><li>链地址法：key 相同的用单链表链接</li><li>开放定址法<ul><li>线性探测法：key 相同 -&gt; 放到 key 的下一个位置，<code>Hi = (H(key) + i) % m</code></li><li>二次探测法：key 相同 -&gt; 放到 <code>Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2）</code></li><li>随机探测法：<code>H = (H(key) + 伪随机数) % m</code></li></ul></li></ul><h4 id="线性探测的哈希表数据结构"><a href="#线性探测的哈希表数据结构" class="headerlink" title="线性探测的哈希表数据结构"></a>线性探测的哈希表数据结构</h4><details><summary>线性探测的哈希表数据结构和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">KeyType key;</span><br><span class="line">&#125;RcdType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">RcdType *rcd;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">bool</span> *tag;</span><br><span class="line">&#125;HashTable;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/HashTable.png" alt></p></details><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>函数直接或间接地调用自身</p><h4 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h4><ul><li>分治法<ul><li>问题的分解</li><li>问题规模的分解</li></ul></li><li>折半查找（递归）</li><li>归并查找（递归）</li><li>快速排序（递归）</li></ul><h4 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h4><ul><li>迭代：反复利用变量旧值推出新值</li><li>折半查找（迭代）</li><li>归并查找（迭代）</li></ul><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><h5 id="头尾链表存储表示"><a href="#头尾链表存储表示" class="headerlink" title="头尾链表存储表示"></a>头尾链表存储表示</h5><details><summary>广义表的头尾链表存储表示和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的头尾链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom;</span><br><span class="line">        <span class="comment">// atom 是原子结点的值域，AtomType 由用户定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="comment">// ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾</span></span><br><span class="line">    &#125; a;</span><br><span class="line">&#125; *GList, GLNode;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/GeneralizedList1.png" alt></p></details><h5 id="扩展线性链表存储表示"><a href="#扩展线性链表存储表示" class="headerlink" title="扩展线性链表存储表示"></a>扩展线性链表存储表示</h5><details><summary>扩展线性链表存储表示和图片</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的扩展线性链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom; <span class="comment">// 原子结点的值域</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">hp</span>;</span> <span class="comment">// 表结点的表头指针</span></span><br><span class="line">    &#125; a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">tp</span>;</span></span><br><span class="line">    <span class="comment">// 相当于线性链表的 next，指向下一个元素结点</span></span><br><span class="line">&#125; *GList1, GLNode1;</span><br></pre></td></tr></table></figure><p><img src="/images/imageProgramC/interview/GeneralizedList2.png" alt></p></details><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><a href="DataStructure/BinaryTree.cpp">BinaryTree.cpp</a></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i &gt;= 1）</li><li>深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k &gt;= 1）</li><li>度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1</li><li>有 n 个结点的完全二叉树深度 k = ⌊ log<sub>2</sub>(n) ⌋ + 1 </li><li>对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点<ol><li>若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋</li><li>若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i</li><li>若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1</li></ol></li></ol><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><details><summary>二叉树数据结构</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure></details><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><details><summary>二叉树顺序存储图片</summary><p><img src="/images/imageProgramC/interview/SqBinaryTree.png" alt></p></details><h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><details><summary>二叉树链式存储图片</summary><p><img src="/images/imageProgramC/interview/LinkBinaryTree.png" alt></p></details><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul><li>先序遍历</li><li>中序遍历</li><li>后续遍历</li><li>层次遍历</li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>满二叉树</li><li>完全二叉树（堆）<ul><li>大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右</li><li>小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右</li></ul></li><li>二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右</li><li>平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1</li><li>最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：<ul><li>LL型：根的左孩子右旋</li><li>RR型：根的右孩子左旋</li><li>LR型：根的左孩子左旋，再右旋</li><li>RL型：右孩子的左子树，先右旋，再左旋</li></ul></li></ul><h3 id="其他树及森林"><a href="#其他树及森林" class="headerlink" title="其他树及森林"></a>其他树及森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul><li>双亲表示法</li><li>双亲孩子表示法</li><li>孩子兄弟表示法</li></ul><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>一种不相交的子集所构成的集合 S = {S1, S2, …, Sn}</p><h4 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h4><h5 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h5><ul><li>| 左子树树高 - 右子树树高 | &lt;= 1</li><li>平衡二叉树必定是二叉搜索树，反之则不一定</li><li>最小二叉平衡树的节点的公式：<code>F(n)=F(n-1)+F(n-2)+1</code> （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）</li></ul><details><summary>平衡二叉树图片</summary><p><img src="/images/imageProgramC/interview/Self-balancingBinarySearchTree.png" alt></p></details><h5 id="最小失衡树"><a href="#最小失衡树" class="headerlink" title="最小失衡树"></a>最小失衡树</h5><p>平衡二叉树插入新结点导致失衡的子树</p><p>调整：</p><ul><li>LL 型：根的左孩子右旋</li><li>RR 型：根的右孩子左旋</li><li>LR 型：根的左孩子左旋，再右旋</li><li>RL 型：右孩子的左子树，先右旋，再左旋</li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h5 id="红黑树的特征是什么？"><a href="#红黑树的特征是什么？" class="headerlink" title="红黑树的特征是什么？"></a>红黑树的特征是什么？</h5><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是 NIL 节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）</li></ol><h5 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h5><ol><li>变色</li><li>左旋</li><li>右旋</li></ol><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul><li>关联数组：如 STL 中的 map、set</li></ul><h5 id="红黑树、B-树、B-树的区别？"><a href="#红黑树、B-树、B-树的区别？" class="headerlink" title="红黑树、B 树、B+ 树的区别？"></a>红黑树、B 树、B+ 树的区别？</h5><ul><li>红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些</li><li>B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。</li></ul><h4 id="B-树（B-tree）、B-树（B-tree）"><a href="#B-树（B-tree）、B-树（B-tree）" class="headerlink" title="B 树（B-tree）、B+ 树（B+-tree）"></a>B 树（B-tree）、B+ 树（B+-tree）</h4><details><summary>B 树、B+ 树图片</summary><p><img src="https://i.stack.imgur.com/l6UyF.png" alt="B 树（B-tree）、B+ 树（B+-tree）"></p></details><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>一般化的二叉查找树（binary search tree）</li><li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li></ul><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ul><li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li></ul><h5 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h5><ul><li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li><li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li></ul><h5 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h5><p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p><h5 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h5><ul><li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li><li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li></ul><blockquote><p>B 树、B+ 树区别来自：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODcwMjE4L2RpZmZlcmVuY2VzLWJldHdlZW4tYi10cmVlcy1hbmQtYi10cmVlcw==" title="https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees">differences-between-b-trees-and-b-trees<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaXZpY3Rvci9wLzU4NDkwNjEuaHRtbA==" title="https://www.cnblogs.com/ivictor/p/5849061.html">B树和B+树的区别<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h4><details><summary>八叉树图片</summary><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png" alt></p></details><p>八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><ul><li>三维计算机图形</li><li>最邻近搜索</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最差时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td><a href="Algorithm/BubbleSort.h">冒泡排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td><a href="Algorithm/SelectionSort.h">选择排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>数组不稳定、链表稳定</td></tr><tr><td><a href="Algorithm/InsertSort.h">插入排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td><a href="Algorithm/QuickSort.h">快速排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n<sup>2</sup>)</td><td>O(log<sub>2</sub>n)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/HeapSort.cpp">堆排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n*log<sub>2</sub>n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/MergeSort.h">归并排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n*log<sub>2</sub>n)</td><td>O(n)</td><td>稳定</td></tr><tr><td><a href="Algorithm/ShellSort.h">希尔排序</a></td><td>O(n*log<sup>2</sup>n)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/CountSort.cpp">计数排序</a></td><td>O(n+m)</td><td>O(n+m)</td><td>O(n+m)</td><td>稳定</td></tr><tr><td><a href="Algorithm/BucketSort.cpp">桶排序</a></td><td>O(n)</td><td>O(n)</td><td>O(m)</td><td>稳定</td></tr><tr><td><a href="Algorithm/RadixSort.h">基数排序</a></td><td>O(k*n)</td><td>O(n<sup>2</sup>)</td><td></td><td>稳定</td></tr></tbody></table><blockquote><ul><li>均按从小到大排列</li><li>k：代表数值中的 “数位” 个数</li><li>n：代表数据规模</li><li>m：代表数据的最大值减最小值</li><li>来自：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JThFJTkyJUU1JUJBJThGJUU3JUFFJTk3JUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">wikipedia . 排序算法<i class="fa fa-external-link"></i></span></li></ul></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><table><thead><tr><th>查找算法</th><th>平均时间复杂度</th><th>空间复杂度</th><th>查找条件</th></tr></thead><tbody><tr><td><a href="Algorithm/SequentialSearch.h">顺序查找</a></td><td>O(n)</td><td>O(1)</td><td>无序或有序</td></tr><tr><td><a href="Algorithm/BinarySearch.h">二分查找（折半查找）</a></td><td>O(log<sub>2</sub>n)</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="Algorithm/InsertionSearch.h">插值查找</a></td><td>O(log<sub>2</sub>(log<sub>2</sub>n))</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="Algorithm/FibonacciSearch.cpp">斐波那契查找</a></td><td>O(log<sub>2</sub>n)</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="DataStructure/HashTable.cpp">哈希查找</a></td><td>O(1)</td><td>O(n)</td><td>无序或有序</td></tr><tr><td><a href="Algorithm/BSTSearch.h">二叉查找树（二叉搜索树查找）</a></td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr><tr><td><a href="DataStructure/RedBlackTree.cpp">红黑树</a></td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr><tr><td>2-3树</td><td>O(log<sub>2</sub>n - log<sub>3</sub>n)</td><td></td><td></td></tr><tr><td>B树/B+树</td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr></tbody></table><h3 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h3><table><thead><tr><th>图搜索算法</th><th>数据结构</th><th>遍历时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUI5JUJGJUU1JUJBJUE2JUU0JUJDJTk4JUU1JTg1JTg4JUU2JTkwJTlDJUU3JUI0JUEy" title="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS广度优先搜索<i class="fa fa-external-link"></i></span></td><td>邻接矩阵<br>邻接链表</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUI3JUIxJUU1JUJBJUE2JUU0JUJDJTk4JUU1JTg1JTg4JUU2JTkwJTlDJUU3JUI0JUEy" title="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">DFS深度优先搜索<i class="fa fa-external-link"></i></span></td><td>邻接矩阵<br>邻接链表</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td><td>O(|v|<sup>2</sup>)<br>O(|v|+|E|)</td></tr></tbody></table><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><table><thead><tr><th>算法</th><th>思想</th><th>应用</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg4JTg2JUU2JUIyJUJCJUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法<i class="fa fa-external-link"></i></span></td><td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvUHJvYmxlbXMvUm91bmRSb2JpblByb2JsZW0=" title="https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem">循环赛日程安排问题<i class="fa fa-external-link"></i></span>、排序算法（快速排序、归并排序）</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThBJUE4JUU2JTgwJTgxJUU4JUE3JTg0JUU1JTg4JTky" title="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划<i class="fa fa-external-link"></i></span></td><td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvdHJlZS9tYXN0ZXIvUHJvYmxlbXMvS25hcHNhY2tQcm9ibGVt" title="https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem">背包问题<i class="fa fa-external-link"></i></span>、斐波那契数列</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI0JUFBJUU1JUJGJTgzJUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">贪心法<i class="fa fa-external-link"></i></span></td><td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</td><td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</td></tr></tbody></table><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><h3 id="Single-Problem"><a href="#Single-Problem" class="headerlink" title="Single Problem"></a>Single Problem</h3><ul><li><a href="Problems/ChessboardCoverageProblem">Chessboard Coverage Problem（棋盘覆盖问题）</a></li><li><a href="Problems/KnapsackProblem">Knapsack Problem（背包问题）</a></li><li><a href="Problems/NeumannNeighborProblem">Neumann Neighbor Problem（冯诺依曼邻居问题）</a></li><li><a href="Problems/RoundRobinProblem">Round Robin Problem（循环赛日程安排问题）</a></li><li><a href="Problems/TubingProblem">Tubing Problem（输油管道问题）</a></li></ul><h3 id="Leetcode-Problems"><a href="#Leetcode-Problems" class="headerlink" title="Leetcode Problems"></a>Leetcode Problems</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhb2VsL2xlZXRjb2Rl" title="https://github.com/haoel/leetcode">Github . haoel/leetcode<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BlenkvTGVldENvZGU=" title="https://github.com/pezy/LeetCode">Github . pezy/LeetCode<i class="fa fa-external-link"></i></span></li></ul><h3 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a>剑指 Offer</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poZWRhaGh0L0NvZGluZ0ludGVydmlld0NoaW5lc2Uy" title="https://github.com/zhedahht/CodingInterviewChinese2">Github . zhedahht/CodingInterviewChinese2<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dhdGllbWUvQ29kaW5nSW50ZXJ2aWV3cw==" title="https://github.com/gatieme/CodingInterviews">Github . gatieme/CodingInterviews<i class="fa fa-external-link"></i></span></li></ul><h3 id="Cracking-the-Coding-Interview-程序员面试金典"><a href="#Cracking-the-Coding-Interview-程序员面试金典" class="headerlink" title="Cracking the Coding Interview 程序员面试金典"></a>Cracking the Coding Interview 程序员面试金典</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NhcmVlcmN1cC9jdGNp" title="https://github.com/careercup/ctci">Github . careercup/ctci<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3RhL2NyYWNraW5nLXRoZS1jb2RpbmctaW50ZXJ2aWV3" title="https://www.nowcoder.com/ta/cracking-the-coding-interview">牛客网 . 程序员面试金典<i class="fa fa-external-link"></i></span></li></ul><h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2FjdGl2aXR5L29q" title="https://www.nowcoder.com/activity/oj">牛客网 . 在线编程专题<i class="fa fa-external-link"></i></span></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjA1NDkyNQ==" title="https://zhuanlan.zhihu.com/p/26054925">【构建操作系统】进程间通信<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd6aGVuMjA5L2FydGljbGUvZGV0YWlscy83ODI0OTI4OA==" title="https://blog.csdn.net/wangzhen209/article/details/78249288">C++ 高性能服务器网络框架设计细节<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxNTE2ODI3L2Fuc3dlci81MzU3Njc1NA==" title="https://www.zhihu.com/question/21516827/answer/53576754">epoll编程，如何实现高并发服务器开发？<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODU1MjU5MA==" title="https://zhuanlan.zhihu.com/p/38552590">如何实现高并发服务器开发<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3dlaWZ1L2FydGljbGUvZGV0YWlscy80NjgzNTQzNw==" title="https://blog.csdn.net/luoweifu/article/details/46835437">编程思想之多线程与多进程(4)——C++中的多线程<i class="fa fa-external-link"></i></span></p></blockquote><p>对于有线程系统：</p><ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul><p>对于无线程系统：</p><ul><li>进程是资源调度、分配的独立单位</li></ul><h4 id="进程之间的通信方式以及优缺点"><a href="#进程之间的通信方式以及优缺点" class="headerlink" title="进程之间的通信方式以及优缺点"></a>进程之间的通信方式以及优缺点</h4><ul><li>管道（PIPE）<ul><li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信<ul><li>优点：可以实现任意关系的进程间的通信</li><li>缺点：<ol><li>长期存于系统中，使用不当容易出错</li><li>缓冲区有限</li></ol></li></ul></li><li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul><li>优点：简单方便</li><li>缺点：<ol><li>局限于单向通信 </li><li>只能创建在它的进程以及其有亲缘关系的进程之间</li><li>缓冲区有限</li></ol></li></ul></li></ul></li><li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问<ul><li>优点：可以同步进程</li><li>缺点：信号量有限</li></ul></li><li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识<ul><li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li><li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul></li><li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul><li>优点：无须复制，快捷，信息量大</li><li>缺点：<ol><li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li><li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ol></li></ul></li><li>套接字（Socket）：可用于不同及其间的进程通信<ul><li>优点：<ol><li>传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>传输数据时间短，性能高</li><li>适合于客户端和服务器端之间信息实时交互</li><li>可以加密,数据安全性强</li></ol></li><li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li></ul></li></ul><h4 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h4><ul><li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul><li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持着是否已经释放锁。</li><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)<ul><li>无名线程信号量</li><li>命名线程信号量</li></ul></li><li>信号机制(Signal)：类似进程间的信号处理</li><li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li></ul><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  </p><blockquote><p>进程之间的通信方式以及优缺点来源于：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VqaWFmZWlfbmpnY3h5L2FydGljbGUvZGV0YWlscy83NzA5ODk3Nw==" title="http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977">进程线程面试题总结<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="进程之间私有和共享的资源"><a href="#进程之间私有和共享的资源" class="headerlink" title="进程之间私有和共享的资源"></a>进程之间私有和共享的资源</h4><ul><li>私有：地址空间、堆、全局变量、栈、寄存器</li><li>共享：代码段，公共数据，进程目录，进程 ID</li></ul><h4 id="线程之间私有和共享的资源"><a href="#线程之间私有和共享的资源" class="headerlink" title="线程之间私有和共享的资源"></a>线程之间私有和共享的资源</h4><ul><li>私有：线程栈，寄存器，程序寄存器</li><li>共享：堆，地址空间，全局变量，静态变量</li></ul><h4 id="多进程与多线程间的对比、优劣与选择"><a href="#多进程与多线程间的对比、优劣与选择" class="headerlink" title="多进程与多线程间的对比、优劣与选择"></a>多进程与多线程间的对比、优劣与选择</h4><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table><thead><tr><th>对比维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td><td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU 利用率低</td><td>占用内存少，切换简单，CPU 利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度很快</td><td>线程占优</td></tr><tr><td>编程、调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会互相影响</td><td>一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布式</td><td>进程占优</td></tr></tbody></table><h5 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h5><table><thead><tr><th>优劣</th><th>多进程</th><th>多线程</th></tr></thead><tbody><tr><td>优点</td><td>编程、调试简单，可靠性较高</td><td>创建、销毁、切换速度快，内存、资源占用小</td></tr><tr><td>缺点</td><td>创建、销毁、切换速度慢，内存、资源占用大</td><td>编程、调试复杂，可靠性较差</td></tr></tbody></table><h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><ul><li>需要频繁创建销毁的优先用线程</li><li>需要进行大量计算的优先使用线程</li><li>强相关的处理用线程，弱相关的处理用进程</li><li>可能要扩展到多机分布的用进程，多核分布的用线程</li><li>都满足需求的情况下，用你最熟悉、最拿手的方式</li></ul><blockquote><p>多进程与多线程间的对比、优劣与选择来自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2hlbmdsb25nNjY2L2FydGljbGUvZGV0YWlscy84NTU3MjE1" title="https://blog.csdn.net/lishenglong666/article/details/8557215">多线程还是多进程的选择及区别<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>将应用程序分为多个、独立的、单纯和的进程，它们运行在同一时刻，就像你可以同时进行网页浏览和文字处理，这些独立的进程可以通过所有常规的进程间通信渠道互相传递信息（信号、套接字、文件、管道等）。</li><li>操作系统在进程间提供的附加保护操作和更高级别的通信机制，意味着可以比线程更容易地编写安全的并发代码。</li><li>使用独立的进程实现并发，可以在网络连接的不同的机器上运行独立的进程，虽然这增加了通信成本，但在一个精心设计的系统上，这可能是一个提高并行可用行和提高性能的低成本方法。</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>这种进程之间的通信通常设置复杂，或是速度较慢，或两者兼备，因为操作系统通常在进程间提供了大量的保护，以避免一个进程不小心修改了属于另一个进程的数据。</li><li>运行多个进和所需的固有开销：启动进程需要时间，操作系统必须投入内部资源来管理进程。</li></ul><h4 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul><li>每个线程相互独立运行，且每个线程可以运行不同的指令序列。但进程中的所有的线程都共享相同的地址空间，并且从所有线程中访问大部分数据——全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。</li><li>共享的地址空间，以及缺少线程间的数据保护，使得使用多线程相关的开销远小于使用多进程，因为操作系统有更少的簿记要做。</li></ul><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul><li><p>虽然通常可以在进程之间共享内存，但这难以建立并且通常难以管理，因为同一数据的内存地址在不同的进程中也不尽相同。</p></li><li><p>共享内存的灵活性是有代价的：如果数据要被多个线程访问，那么必须确保当每个线程访问时所看到的数据是一致的。</p></li></ul><h3 id="Linux-内核的同步方式"><a href="#Linux-内核的同步方式" class="headerlink" title="Linux 内核的同步方式"></a>Linux 内核的同步方式</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</p><h4 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4><ul><li>原子操作</li><li>信号量（semaphore）</li><li>读写信号量（rw_semaphore）</li><li>自旋锁（spinlock）</li><li>大内核锁（BKL，Big Kernel Lock）</li><li>读写锁（rwlock）</li><li>大读者锁（brlock-Big Reader Lock）</li><li>读-拷贝修改(RCU，Read-Copy Update)</li><li>顺序锁（seqlock）</li></ul><blockquote><p>来自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLXN5bmNoL3BhcnQxLw==" title="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/">Linux 内核的同步机制，第 1 部分<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLXN5bmNoL3BhcnQyLw==" title="https://www.ibm.com/developerworks/cn/linux/l-synch/part2/">Linux 内核的同步机制，第 2 部分<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><ul><li>系统资源不足</li><li>资源分配不当</li><li>进程运行推进顺序不合适</li></ul><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ul><li>互斥</li><li>请求和保持</li><li>不剥夺</li><li>环路</li></ul><h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ul><li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li><li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li><li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li><li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li><li>有序资源分配法</li><li>银行家算法</li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li>Windows：FCB 表 + FAT + 位图</li><li>Unix：inode + 混合索引 + 成组链接</li></ul><h3 id="主机字节序与网络字节序"><a href="#主机字节序与网络字节序" class="headerlink" title="主机字节序与网络字节序"></a>主机字节序与网络字节序</h3><h4 id="主机字节序（CPU-字节序）"><a href="#主机字节序（CPU-字节序）" class="headerlink" title="主机字节序（CPU 字节序）"></a>主机字节序（CPU 字节序）</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：</p><ul><li>大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址</li><li>小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址</li></ul><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p>32 位整数 <code>0x12345678</code> 是从起始位置为 <code>0x00</code> 的地址开始存放，则：</p><table><thead><tr><th>内存地址</th><th>0x00</th><th>0x01</th><th>0x02</th><th>0x03</th></tr></thead><tbody><tr><td>大端</td><td>12</td><td>34</td><td>56</td><td>78</td></tr><tr><td>小端</td><td>78</td><td>56</td><td>34</td><td>12</td></tr></tbody></table><details><summary>大端小端图片</summary><p><img src="/images/imageProgramC/interview/CPU-Big-Endian.svg.png" alt="大端序"><br><img src="/images/imageProgramC/interview/CPU-Little-Endian.svg.png" alt="小端序"></p></details><h5 id="判断大端小端"><a href="#判断大端小端" class="headerlink" title="判断大端小端"></a>判断大端小端</h5><details><summary>判断大端小端</summary><p>可以这样判断自己 CPU 字节序是大端还是小端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*((<span class="keyword">char</span>*)&amp;i) == <span class="number">0x12</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"小端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h5 id="各架构处理器的字节序"><a href="#各架构处理器的字节序" class="headerlink" title="各架构处理器的字节序"></a>各架构处理器的字节序</h5><ul><li>x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；</li><li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；</li><li>ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。</li></ul><h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保重数据在不同主机之间传输时能够被正确解释。</p><p>网络字节顺序采用：大端（Big Endian）排列方式。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li>全局置换：在整个内存空间置换</li><li>局部置换：在本进程中进行置换</li></ul><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>全局：</p><ul><li>工作集算法</li><li>缺页率置换算法</li></ul><p>局部：</p><ul><li>最佳置换算法（OPT）</li><li>先进先出置换算法（FIFO）</li><li>最近最久未使用（LRU）算法</li><li>时钟（Clock）置换算法</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机经网络体系结构：</p><p><img src="/images/imageProgramC/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机经网络体系结构"></p><h3 id="各层作用及协议"><a href="#各层作用及协议" class="headerlink" title="各层作用及协议"></a>各层作用及协议</h3><table><thead><tr><th>分层</th><th>作用</th><th>协议</th></tr></thead><tbody><tr><td>物理层</td><td>通过媒介传输比特，确定机械及电气规范（比特 Bit）</td><td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td></tr><tr><td>数据链路层</td><td>将比特组装成帧和点到点的传递（帧 Frame）</td><td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td></tr><tr><td>网络层</td><td>负责数据包从源到宿的传递和网际互连（包 Packet）</td><td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td></tr><tr><td>运输层</td><td>提供端到端的可靠报文传递和错误恢复（ 段Segment）</td><td>TCP、UDP、SPX</td></tr><tr><td>会话层</td><td>建立、管理和终止会话（会话协议数据单元 SPDU）</td><td>NFS、SQL、NETBIOS、RPC</td></tr><tr><td>表示层</td><td>对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）</td><td>JPEG、MPEG、ASII</td></tr><tr><td>应用层</td><td>允许访问OSI环境的手段（应用协议数据单元 APDU）</td><td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td></tr></tbody></table><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul><li>传输数据的单位 ———— 比特</li><li>数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点）</li></ul><p>通道：</p><ul><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li><li>双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul><p>通道复用技术：</p><ul><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>主要信道：</p><ul><li>点对点信道</li><li>广播信道</li></ul><h4 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h4><ul><li>数据单元 ———— 帧</li></ul><p>三个基本问题：</p><ul><li>封装成帧：把网络层的 IP 数据报封装成帧，<code>SOH - 数据部分 - EOT</code></li><li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li><li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li></ul><p>点对点协议（Point-to-Point Protocol）：</p><ul><li>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</li></ul><h4 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h4><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li><li>ARP（Address Resolution Protocol，地址解析协议）</li><li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li></ul><h4 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP 网际协议"></a>IP 网际协议</h4><p>IP 地址分类：</p><ul><li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li></ul><table><thead><tr><th>IP 地址类别</th><th>网络号</th><th>网络范围</th><th>主机号</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A 类</td><td>8bit，第一位固定为 0</td><td>0 —— 127</td><td>24bit</td><td>1.0.0.0 —— 127.255.255.255</td></tr><tr><td>B 类</td><td>16bit，前两位固定为  10</td><td>128.0 —— 191.255</td><td>16bit</td><td>128.0.0.0 —— 191.255.255.255</td></tr><tr><td>C  类</td><td>24bit，前三位固定为  110</td><td>192.0.0 —— 223.255.255</td><td>8bit</td><td>192.0.0.0 —— 223.255.255.255</td></tr><tr><td>D  类</td><td>前四位固定为 1110，后面为多播地址</td><td></td><td></td><td></td></tr><tr><td>E  类</td><td>前五位固定为 11110，后面保留为今后所用</td><td></td><td></td><td></td></tr></tbody></table><p>IP 数据报格式：</p><p><img src="/images/imageProgramC/interview/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IP 数据报格式"></p><h4 id="ICMP-网际控制报文协议"><a href="#ICMP-网际控制报文协议" class="headerlink" title="ICMP 网际控制报文协议"></a>ICMP 网际控制报文协议</h4><p>ICMP 报文格式：</p><p><img src="/images/imageProgramC/interview/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="ICMP 报文格式"></p><p>应用：</p><ul><li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性<ul><li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li></ul></li></ul><h4 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h4><ul><li>RIP（Routing Information Protocol，路由信息协议）</li><li>OSPF（Open Sortest Path First，开放最短路径优先）</li></ul><h4 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h4><ul><li>BGP（Border Gateway Protocol，边界网关协议）</li></ul><h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><ul><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li><li>多播路由选择协议</li></ul><h4 id="VPN-和-NAT"><a href="#VPN-和-NAT" class="headerlink" title="VPN 和 NAT"></a>VPN 和 NAT</h4><ul><li>VPN（Virtual Private Network，虚拟专用网）</li><li>NAT（Network Address Translation，网络地址转换）</li></ul><h4 id="路由表包含什么？"><a href="#路由表包含什么？" class="headerlink" title="路由表包含什么？"></a>路由表包含什么？</h4><ol><li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li><li>子网掩码（subnet mask）：用来判断 IP 所属网络</li><li>下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: <code>0.0.0.0</code>, Netmask: <code>0.0.0.0</code>）指向自治系统的出口。</li></ol><p>根据应用和执行的不同，路由表可能含有如下附加信息：</p><ol><li>花费（Cost）：就是数据发送过程中通过路径所需要的花费。</li><li>路由的服务质量</li><li>路由中需要过滤的出/入连接列表</li></ol><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>协议：</p><ul><li>TCP（Transmission Control Protocol，传输控制协议）</li><li>UDP（User Datagram Protocol，用户数据报协议）</li></ul><p>端口：</p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>HTTPS</th><th>SNMP</th></tr></thead><tbody><tr><td>端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>443</td><td>161</td></tr></tbody></table><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li></ul><p>特征：</p><ul><li>面向连接</li><li>只能点对点（一对一）通信</li><li>可靠交互</li><li>全双工通信</li><li>面向字节流</li></ul><p>TCP 如何保证可靠传输：</p><ul><li>确认和超时重传</li><li>数据合理分片和排序</li><li>流量控制</li><li>拥塞控制</li><li>数据校验</li></ul><p>TCP 报文结构</p><p><img src="/images/imageProgramC/interview/TCP%E6%8A%A5%E6%96%87.png" alt="TCP 报文"></p><p>TCP 首部</p><p><img src="/images/imageProgramC/interview/TCP%E9%A6%96%E9%83%A8.png" alt="TCP 首部"></p><p>TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：</p><ul><li>URG：紧急比特（urgent），当 <code>URG＝1</code> 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li><li>ACK：确认比特（Acknowledge）。只有当 <code>ACK＝1</code> 时确认号字段才有效，代表这个封包为确认封包。当 <code>ACK＝0</code> 时，确认号无效。</li><li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li><li>RST：复位比特(Reset)，当 <code>RST＝1</code> 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li><li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li><li>FIN：终止比特(Final)，用来释放一个连接。当 <code>FIN＝1</code> 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li></ul><p>特征：</p><ul><li>无连接</li><li>尽最大努力交付</li><li>面向报文</li><li>没有拥塞控制</li><li>支持一对一、一对多、多对一、多对多的交互通信</li><li>首部开销小</li></ul><p>UDP 报文结构</p><p><img src="/images/imageProgramC/interview/UDP%E6%8A%A5%E6%96%87.png" alt="UDP 报文"></p><p>UDP 首部</p><p><img src="/images/imageProgramC/interview/UDP%E9%A6%96%E9%83%A8.png" alt="UDP 首部"></p><blockquote><p>TCP/UDP 图片来源于：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0plcnJ5QzgwODAvdW5kZXJzdGFuZC10Y3AtdWRw" title="https://github.com/JerryC8080/understand-tcp-udp">https://github.com/JerryC8080/understand-tcp-udp<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h4><ol><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li><li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ol><h4 id="TCP-黏包问题"><a href="#TCP-黏包问题" class="headerlink" title="TCP 黏包问题"></a>TCP 黏包问题</h4><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5><p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li><li>在数据包之间设置边界，如添加特殊符号 <code>\r\n</code> 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 <code>\r\n</code>，则会误判为消息的边界。</li><li>使用更加复杂的应用层协议。</li></ul><h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><details><summary>利用可变窗口进行流量控制</summary><p><img src="/images/imageProgramC/interview/%E5%88%A9%E7%94%A8%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B.png" alt></p></details><h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul><li>慢开始( slow-start )</li><li>拥塞避免( congestion avoidance )</li><li>快重传( fast retransmit )</li><li>快恢复( fast recovery )</li></ul><details><summary>TCP的拥塞控制图</summary><p><img src="/images/imageProgramC/interview/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png" alt><br><img src="/images/imageProgramC/interview/%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt><br><img src="/images/imageProgramC/interview/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p></details><h4 id="TCP-传输连接管理"><a href="#TCP-传输连接管理" class="headerlink" title="TCP 传输连接管理"></a>TCP 传输连接管理</h4><blockquote><p>因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvYmxvYi9tYXN0ZXIvaW1hZ2VzL1RDUC10cmFuc3BvcnQtY29ubmVjdGlvbi1tYW5hZ2VtZW50LnBuZw==" title="https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png">https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png<i class="fa fa-external-link"></i></span></p></blockquote><h5 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h5><p><img src="/images/imageProgramC/interview/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p><p>【TCP 建立连接全过程解释】</p><ol><li>客户端发送 SYN 给服务器，说明客户端请求建立连接；</li><li>服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；</li><li>客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；</li><li>服务端收到客户端的 ACK，连接已建立，可以数据传输。</li></ol><h5 id="TCP-为什么要进行三次握手？"><a href="#TCP-为什么要进行三次握手？" class="headerlink" title="TCP 为什么要进行三次握手？"></a>TCP 为什么要进行三次握手？</h5><p>【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIW1zZy9wb25nYmEva0Y2TzctTUZ4TTAvNVM3eklKNHlxS1VK" title="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ">Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}<i class="fa fa-external-link"></i></span></p></blockquote><p>【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI0ODUzNjMzL2Fuc3dlci8xMTUxNzMzODY=" title="https://www.zhihu.com/question/24853633/answer/115173386">知乎 . TCP 为什么是三次握手，而不是两次或四次？<i class="fa fa-external-link"></i></span></p></blockquote><p>【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvYmxvYi9tYXN0ZXIvaW1hZ2VzL1RDUC10cmFuc3BvcnQtY29ubmVjdGlvbi1tYW5hZ2VtZW50LnBuZw==" title="https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png">《计算机网络（第 7 版）-谢希仁》<i class="fa fa-external-link"></i></span></p></blockquote><h5 id="TCP-四次挥手释放连接"><a href="#TCP-四次挥手释放连接" class="headerlink" title="TCP 四次挥手释放连接"></a>TCP 四次挥手释放连接</h5><p><img src="/images/imageProgramC/interview/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p><p>【TCP 释放连接全过程解释】</p><ol><li>客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li><li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li><li>客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li><li>服务端继续发送之前没发完的数据给客户端；</li><li>服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li><li>客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）；</li><li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。</li></ol><h5 id="TCP-为什么要进行四次挥手？"><a href="#TCP-为什么要进行四次挥手？" class="headerlink" title="TCP 为什么要进行四次挥手？"></a>TCP 为什么要进行四次挥手？</h5><p>【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？</p><p>【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p><p>【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</p><p>【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p><p>【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</p><p>【答案三】</p><ol><li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li><li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li></ol><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L292ZXJzdGFjay9hcnRpY2xlL2RldGFpbHMvODgzMzg5NA==" title="https://blog.csdn.net/overstack/article/details/8833894">Time-wait状态(2MSL)一些理解<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="TCP-有限状态机"><a href="#TCP-有限状态机" class="headerlink" title="TCP 有限状态机"></a>TCP 有限状态机</h4><details><summary>TCP 有限状态机图片</summary><p><img src="/images/imageProgramC/interview/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="TCP 的有限状态机"></p></details><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zMzVkZTEzMjNjZTk=" title="https://www.jianshu.com/p/335de1323ce9">TCP和UDP详解<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hNWNmODFiMWE5NzY=" title="https://www.jianshu.com/p/a5cf81b1a976">HTTP、TCP、UDP详解<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><ul><li>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</li></ul><p>域名：</p><ul><li><code>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}</code>，如：<code>blog.huihut.com</code></li></ul><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><ul><li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li><li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</li></ul><h4 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h4><ul><li><p>TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p></li><li><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。</p></li><li><p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。</p></li><li><p>Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。</p></li></ul><h4 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h4><ul><li>WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问</li></ul><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><ul><li>URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）</li></ul><p>标准格式：</p><ul><li><code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li></ul><p>完整格式：</p><ul><li><code>协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li></ul><blockquote><p>其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项<br>如：<code>https://github.com/huihut/interview#cc</code></p></blockquote><h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p><p>请求方法</p><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>OPTIONS</td><td>请求一些选项信息，允许客户端查看服务器的性能</td></tr><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>HEAD</td><td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>状态码（Status-Code）</p><ul><li>1xx：表示通知信息，如请求收到了或正在进行处理<ul><li>100 Continue：继续，客户端应继续其请求</li><li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li></ul></li><li>2xx：表示成功，如接收或知道了<ul><li>200 OK: 请求成功</li></ul></li><li>3xx：表示重定向，如要完成请求还必须采取进一步的行动<ul><li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li></ul></li><li>4xx：表示客户的差错，如请求中有错误的语法或不能完成<ul><li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li><li>401 Unauthorized: 请求要求用户的身份认证</li><li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li><li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li><li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li></ul></li><li>5xx：表示服务器的差错，如服务器失效无法完成请求<ul><li>500 Internal Server Error: 服务器内部错误，无法完成请求</li><li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li><li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li></ul></li></ul><blockquote><p>更多状态码：<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2h0dHAvaHR0cC1zdGF0dXMtY29kZXMuaHRtbA==" title="http://www.runoob.com/http/http-status-codes.html">菜鸟教程 . HTTP状态码<i class="fa fa-external-link"></i></span></p></blockquote><h5 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h5><ul><li>SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</li><li>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：<ul><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ul></li><li>SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2t5bmV0L2FyY2hpdmUvMjAxMC8xMi8xMi8xOTAzOTQ5Lmh0bWw=" title="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket 编程（不限 Linux）<i class="fa fa-external-link"></i></span></p><p><img src="/images/imageProgramC/interview/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF.jpg" alt="Socket 客户端服务器通讯"></p><h4 id="Socket-中的-read-、write-函数"><a href="#Socket-中的-read-、write-函数" class="headerlink" title="Socket 中的 read()、write() 函数"></a>Socket 中的 read()、write() 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><h5 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h5><ul><li>read 函数是负责从 fd 中读取内容。</li><li>当读成功时，read 返回实际所读的字节数。</li><li>如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。</li><li>如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。</li></ul><h5 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h5><ul><li>write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。</li><li>成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。</li><li>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</li><li>（1）write 的返回值大于 0，表示写了部分或者是全部的数据。</li><li>（2）返回的值小于 0，此时出现了错误。</li><li>如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。</li></ul><h4 id="Socket-中-TCP-的三次握手建立连接"><a href="#Socket-中-TCP-的三次握手建立连接" class="headerlink" title="Socket 中 TCP 的三次握手建立连接"></a>Socket 中 TCP 的三次握手建立连接</h4><p>我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</p><ol><li>客户端向服务器发送一个 SYN J</li><li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1</li><li>客户端再想服务器发一个确认 ACK K+1</li></ol><p>只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png" alt="socket 中发送的 TCP 三次握手"></p><p>从图中可以看出：</p><ol><li>当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；  </li><li>服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；  </li><li>客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；  </li><li>服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。</li></ol><h4 id="Socket-中-TCP-的四次握手释放连接"><a href="#Socket-中-TCP-的四次握手释放连接" class="headerlink" title="Socket 中 TCP 的四次握手释放连接"></a>Socket 中 TCP 的四次握手释放连接</h4><p>上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png" alt="socket 中发送的 TCP 四次握手"></p><p>图示过程如下：</p><ol><li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；</li><li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；</li><li>接收到这个 FIN 的源发送端 TCP 对它进行确认。</li></ol><p>这样每个方向上都有一个 FIN 和 ACK。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>数据库事务四大特性：原子性、一致性、分离性、持久性</li><li>数据库索引：顺序索引、B+ 树索引、hash 索引<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvYXJ0aWNsZXMvdGhlb3J5LW9mLW15c3FsLWluZGV4Lmh0bWw=" title="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vc3FsL3NxbF9jb25zdHJhaW50cy5hc3A=" title="http://www.w3school.com.cn/sql/sql_constraints.asp">SQL 约束 (Constraints)<i class="fa fa-external-link"></i></span></li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li>第一范式（1NF）：属性（字段）是最小单位不可再分</li><li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）</li><li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）</li><li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）</li><li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p>各大设计模式例子参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvbHVtbi9kZXRhaWxzLzE1MzkyLmh0bWw=" title="https://blog.csdn.net/column/details/15392.html">CSDN专栏 . C++ 设计模式<i class="fa fa-external-link"></i></span> 系列博文</p></blockquote><p><a href="DesignPattern">设计模式工程目录</a></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><a href="DesignPattern/SingletonPattern">单例模式例子</a></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><a href="DesignPattern/AbstractFactoryPattern">抽象工厂模式例子</a></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><a href="DesignPattern/AdapterPattern">适配器模式例子</a></p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><a href="DesignPattern/BridgePattern">桥接模式例子</a></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><a href="DesignPattern/ObserverPattern">观察者模式例子</a></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ul><li>单一职责原则（SRP，Single Responsibility Principle）</li><li>里氏替换原则（LSP，Liskov Substitution Principle）</li><li>依赖倒置原则（DIP，Dependence Inversion Principle）</li><li>接口隔离原则（ISP，Interface Segregation Principle）</li><li>迪米特法则（LoD，Law of Demeter）</li><li>开放封闭原则（OCP，Open Close Principle）</li></ul><h2 id="链接装载库"><a href="#链接装载库" class="headerlink" title="链接装载库"></a>链接装载库</h2><h3 id="内存、栈、堆"><a href="#内存、栈、堆" class="headerlink" title="内存、栈、堆"></a>内存、栈、堆</h3><p>一般应用程序内存空间有如下区域：</p><ul><li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文</li><li>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</li><li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里</li><li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：</p><ul><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>保存上下文：包括函数调用前后需要保持不变的寄存器</li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆分配算法：</p><ul><li>空闲链表（Free List）</li><li>位图（Bitmap）</li><li>对象池</li></ul><h4 id="“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”"><a href="#“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”" class="headerlink" title="“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”"></a>“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”</h4><p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。</p><p>普遍原因：</p><ul><li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针</li><li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</li></ul><h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><h4 id="各平台文件格式"><a href="#各平台文件格式" class="headerlink" title="各平台文件格式"></a>各平台文件格式</h4><table><thead><tr><th>平台</th><th>可执行文件</th><th>目标文件</th><th>动态库/共享对象</th><th>静态库</th></tr></thead><tbody><tr><td>Windows</td><td>exe</td><td>obj</td><td>dll</td><td>lib</td></tr><tr><td>Unix/Linux</td><td>ELF、out</td><td>o</td><td>so</td><td>a</td></tr><tr><td>Mac</td><td>Mach-O</td><td>o</td><td>dylib、tbd、framework</td><td>a、framework</td></tr></tbody></table><h4 id="编译链接过程"><a href="#编译链接过程" class="headerlink" title="编译链接过程"></a>编译链接过程</h4><ol><li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li><li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）</li><li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）</li><li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</li></ol><blockquote><p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</p></blockquote><blockquote><p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</p></blockquote><h4 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h4><p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p><blockquote><p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</p></blockquote><h5 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h5><ul><li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式</li><li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式</li><li>Intel/Microsoft 的 OMF（Object Module Format）</li><li>Unix 的 <code>a.out</code> 格式</li><li>MS-DOS 的 <code>.COM</code> 格式</li></ul><blockquote><p>PE 和 ELF 都是 COFF（Common File Format）的变种</p></blockquote><h5 id="目标文件存储结构"><a href="#目标文件存储结构" class="headerlink" title="目标文件存储结构"></a>目标文件存储结构</h5><table><thead><tr><th>段</th><th>功能</th></tr></thead><tbody><tr><td>File Header</td><td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td></tr><tr><td>.text section</td><td>代码段，执行语句编译成的机器代码</td></tr><tr><td>.data section</td><td>数据段，已初始化的全局变量和局部静态变量</td></tr><tr><td>.bss section</td><td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td></tr><tr><td>.rodata section</td><td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td></tr><tr><td>.comment section</td><td>注释信息段，存放编译器版本信息</td></tr><tr><td>.note.GNU-stack section</td><td>堆栈提示段</td></tr></tbody></table><blockquote><p>其他段略</p></blockquote><h4 id="链接的接口————符号"><a href="#链接的接口————符号" class="headerlink" title="链接的接口————符号"></a>链接的接口————符号</h4><p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p><p>如下符号表（Symbol Table）：</p><table><thead><tr><th>Symbol（符号名）</th><th>Symbol Value （地址）</th></tr></thead><tbody><tr><td>main</td><td>0x100</td></tr><tr><td>Add</td><td>0x123</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h3 id="Linux-的共享库（Shared-Library）"><a href="#Linux-的共享库（Shared-Library）" class="headerlink" title="Linux 的共享库（Shared Library）"></a>Linux 的共享库（Shared Library）</h3><p>Linux 下的共享库就是普通的 ELF 共享对象。</p><p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p><code>libname.so.x.y.z</code></p><ul><li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译</li><li>y：次版本号，高版本号向后兼容低版本号</li><li>z：发布版本号，不对接口进行更改，完全兼容</li></ul><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p><ul><li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li><li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li><li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li></ul><blockquote><p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p></blockquote><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul><li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li><li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li><li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li></ul><h4 id="so-共享库的编写"><a href="#so-共享库的编写" class="headerlink" title="so 共享库的编写"></a>so 共享库的编写</h4><details><summary>使用 CLion 编写共享库</summary><p>创建一个名为 MySharedLib 的共享库</p><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(MySharedLib SHARED library.cpp library.h)</span><br></pre></td></tr></table></figure><p>library.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 Hello World!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可变模版参数求和</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Types&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T first, Types ... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + sum&lt;T&gt;(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>library.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="so-共享库的使用（被可执行项目调用）"><a href="#so-共享库的使用（被可执行项目调用）" class="headerlink" title="so 共享库的使用（被可执行项目调用）"></a>so 共享库的使用（被可执行项目调用）</h4><details><summary>使用 CLion 调用共享库</summary><p>创建一个名为 TestSharedLib 的可执行项目</p><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(TestSharedLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++11 编译</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件路径</span></span><br><span class="line"><span class="keyword">set</span>(INC_DIR /home/xx/code/clion/MySharedLib)</span><br><span class="line"><span class="comment"># 库文件路径</span></span><br><span class="line"><span class="keyword">set</span>(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;INC_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(TestSharedLib main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 MySharedLib 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(TestSharedLib MySharedLib)</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 + 3 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1 + 2 = 3</span><br><span class="line">1 + 2 + 3 = 6</span><br></pre></td></tr></table></figure></details><h3 id="运行库（Runtime-Library）"><a href="#运行库（Runtime-Library）" class="headerlink" title="运行库（Runtime Library）"></a>运行库（Runtime Library）</h3><h4 id="典型程序运行步骤"><a href="#典型程序运行步骤" class="headerlink" title="典型程序运行步骤"></a>典型程序运行步骤</h4><ol><li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）</li><li>入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。</li><li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。</li><li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。</li></ol><blockquote><p>一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。</p></blockquote><h4 id="glibc-入口"><a href="#glibc-入口" class="headerlink" title="glibc 入口"></a>glibc 入口</h4><p><code>_start -&gt; __libc_start_main -&gt; exit -&gt; _exit</code></p><p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。</p><h4 id="MSVC-CRT-入口"><a href="#MSVC-CRT-入口" class="headerlink" title="MSVC CRT 入口"></a>MSVC CRT 入口</h4><p><code>int mainCRTStartup(void)</code></p><p>执行如下操作：</p><ol><li>初始化和 OS 版本有关的全局变量。</li><li>初始化堆。</li><li>初始化 I/O。</li><li>获取命令行参数和环境变量。</li><li>初始化 C 库的一些数据。</li><li>调用 main 并记录返回值。</li><li>检查错误并将 main 的返回值返回。</li></ol><h4 id="C-语言运行库（CRT）"><a href="#C-语言运行库（CRT）" class="headerlink" title="C 语言运行库（CRT）"></a>C 语言运行库（CRT）</h4><p>大致包含如下功能：</p><ul><li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li><li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。</li><li>I/O：I/O 功能的封装和实现。</li><li>堆：堆的封装和实现。</li><li>语言实现：语言中一些特殊功能的实现。</li><li>调试：实现调试功能的代码。</li></ul><h4 id="C语言标准库（ANSI-C）"><a href="#C语言标准库（ANSI-C）" class="headerlink" title="C语言标准库（ANSI C）"></a>C语言标准库（ANSI C）</h4><p>包含：</p><ul><li>标准输入输出（stdio.h）</li><li>文件操作（stdio.h）</li><li>字符操作（ctype.h）</li><li>字符串操作（string.h）</li><li>数学函数（math.h）</li><li>资源管理（stdlib.h）</li><li>格式转换（stdlib.h）</li><li>时间/日期（time.h）</li><li>断言（assert.h）</li><li>各种类型上的常数（limits.h &amp; float.h）</li><li>变长参数（stdarg.h）</li><li>非局部跳转（setjmp.h）</li></ul><h2 id="回调函数和钩子函数"><a href="#回调函数和钩子函数" class="headerlink" title="回调函数和钩子函数"></a>回调函数和钩子函数</h2><h3 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a>什么是回调函数？</h3><p>简而言之，回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。 </p><h4 id="为什么要使用回调函数？"><a href="#为什么要使用回调函数？" class="headerlink" title="为什么要使用回调函数？"></a>为什么要使用回调函数？</h4><p>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为 int ）的被调用函数。 </p><p>如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、 shell 排序、 shake 排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（ int 、 float 、 string ），此时，该怎么办呢？可以使用函数指针，并进行回调。 </p><p>回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API 使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。 </p><p>另一个使用回调机制的 API 函数是 EnumWindow() ，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。 EnumWindow() 并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。 </p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>不管怎么说，<strong>回调函数是继续自 C 语言的，因而，在 C++ 中，应只在与 C 代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在 C++ 中应使用虚拟方法或函数符（ functor ），而不是回调函数</strong>。</p><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p>也可以这样，更容易理解：回调函数就好像是一个中断处理函数，系统在符合你设定的条件时自动调用。</p><p>为此，你需要做三件事：</p><ol><li><p>声明；</p></li><li><p>定义；</p></li><li><p>设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用。</p></li></ol><p>声明和定义时应注意：回调函数由系统调用，所以可以认为它属于WINDOWS系统，不要把它当作你的某个类的成员函数</p><p>回调函数是一个程序员不能显式调用的函数；通过将回调函数的地址传给调用者从而实现调用。回调函数使用是必要的，在我们想通过一个统一接口实现不同的内容，这时用回掉函数非常合适。比如，我们为几个不同的设备分别写了不同的显示函数：void TVshow(); void ComputerShow(); void NoteBookShow()…等等。这是我们想用一个统一的显示函数，我们这时就可以用回掉函数了。void show(void (*ptr)()); 使用时根据所传入的参数不同而调用不同的回调函数。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy52b2lkY24uY29tL2FydGljbGUvcC1jcGl0dWdwdS1iY2cuaHRtbA==" title="http://www.voidcn.com/article/p-cpitugpu-bcg.html">C语言中的回调函数<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODI5MzkwMg==" title="https://segmentfault.com/a/1190000008293902">一文搞懂C语言回调函数<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvY2hvL2FydGljbGUvZGV0YWlscy81MTU4MzExMg==" title="https://blog.csdn.net/socho/article/details/51583112">c语言实现回调函数<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2Nwcm9ncmFtbWluZy9jLWZ1bi1wb2ludGVyLWNhbGxiYWNrLmh0bWw=" title="http://www.runoob.com/cprogramming/c-fun-pointer-callback.html">函数指针<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="什么是钩子函数？"><a href="#什么是钩子函数？" class="headerlink" title="什么是钩子函数？"></a>什么是钩子函数？</h3><p>钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。对每种类型的钩子由系统来维护一个钩子链，最近安装的钩子放在链的开始，而最先安装的钩子放在最后，也就是后加入的先获得控制权。</p><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>钩子函数是Windows消息处理机制的一部分，通过设置“钩子”，应用程序可以在系统级对所有消息、事件进行过滤，访问在正常情况下无法访问的消息。钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol><li><p>局部钩子：仅钩挂您自己进程的事件。</p></li><li><p>远程钩子：可以钩挂自己进程或其他进程的事件，</p><p>远程钩子又分为两种：</p><ul><li>一种是系统级的全局钩子，</li><li>一种是线程级的钩子。</li></ul><p>全局钩子函数需要定义在 DLL 中，线程级的钩子中经常用到 GetCurrentThreadID 函数来获取当前线程的ID。</p></li></ol><h4 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h4><p>当创建一个钩子时，WINDOWS会先在内存中创建一个数据结构，该数据结构包含了钩子的相关信息，然后把该结构体加到已经存在的钩子链表中去。新的钩子将加到老的前面。当一个事件发生时，如果安装的是一个局部钩子，自己进程中的钩子函数将被调用。如果是一个远程钩子，系统就必须把钩子函数插入到其他进程的地址空间，要做到这一点要求钩子函数必须在一个动态链接库中，所以如果想要使用远程钩子，就必须把该钩子函数放到动态链接库中去。</p><p>两个例外：</p><ul><li>工作日志钩子</li><li>工作日志回放钩子。</li></ul><p>这两个钩子的钩子函数必须在安装钩子的线程中。原因是：</p><ul><li>这两个钩子是用来监控比较底层的硬件事件的，既然是记录和回放，所有的事件就当然都是有先后次序的。所以如果把回调函数放在DLL中，输入的事件被放在几个线程中记录，所以我们无法保证得到正确的次序。</li></ul><p>解决办法：把钩子函数放到单个的线程中，譬如安装钩子的线程。</p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8xMjgxNDUuaHRt" title="https://www.jb51.net/article/128145.htm">浅谈c++ hook 钩子的使用介绍<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="异步消息的传递－回调机制"><a href="#异步消息的传递－回调机制" class="headerlink" title="异步消息的传递－回调机制"></a>异步消息的传递－回调机制</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWNhbGxiYWNrL2luZGV4Lmh0bWw=" title="https://www.ibm.com/developerworks/cn/linux/l-callback/index.html">异步消息的传递－回调机制<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="什么是回调"><a href="#什么是回调" class="headerlink" title="什么是回调"></a>什么是回调</h4><p>软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：</p><ul><li>同步调用</li><li>回调</li><li>异步调用</li></ul><p>同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。</p><p><strong>回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知</strong>。</p><p>同步调用是三者当中最简单的，而回调又常常是异步调用的基础，因此，下面我们着重讨论回调机制在不同软件架构中的实现。</p><img src="/images/imageProgramC/interview/回调机制-01.gif"><p>对于不同类型的语言（如结构化语言和对象语言）、平台（Win32、JDK）或构架（CORBA、DCOM、WebService），客户和服务的交互除了同步方式以外，都需要具备一定的异步通知机制，让服务方（或接口提供方）在某些情况下能够主动通知客户，而回调是实现异步的一个最简捷的途径。</p><p>对于一般的结构化语言，可以通过回调函数来实现回调。回调函数也是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数。</p><p>在面向对象的语言中，回调则是通过接口或抽象类来实现的，我们把实现这种接口的类成为回调类，回调类的对象成为回调对象。对于象C++或Object Pascal这些兼容了过程特性的对象语言，不仅提供了回调对象、回调方法等特性，也能兼容过程语言的回调函数机制。</p><p>Windows平台的消息机制也可以看作是回调的一种应用，我们通过系统提供的接口注册消息处理函数（即回调函数），从而实现接收、处理消息的目的。由于Windows平台的API是用C语言来构建的，我们可以认为它也是回调函数的一个特例。</p><p>对于分布式组件代理体系CORBA，异步处理有多种方式，如回调、事件服务、通知服务等。事件服务和通知服务是CORBA用来处理异步消息的标准服务，他们主要负责消息的处理、派发、维护等工作。对一些简单的异步处理过程，我们可以通过回调机制来实现。</p><p>下面我们集中比较具有代表性的语言（C、Object Pascal）和架构（CORBA）来分析回调的实现方式、具体作用等。</p><h4 id="过程语言中的回调（C）"><a href="#过程语言中的回调（C）" class="headerlink" title="过程语言中的回调（C）"></a>过程语言中的回调（C）</h4><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><p>回调在C语言中是通过函数指针来实现的，通过将回调函数的地址传给被调函数从而实现回调。因此，要实现回调，必须首先定义函数指针，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void Func(char *s)；// 函数原型</span><br><span class="line"><span class="keyword">void</span> (*pFunc) (<span class="keyword">char</span> *);<span class="comment">//函数指针</span></span><br></pre></td></tr></table></figure><p>可以看出，函数的定义和函数指针的定义非常类似。</p><p>一般的话，为了简化函数指针类型的变量定义，提高程序的可读性，我们需要把函数指针类型自定义一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pcb)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>回调函数可以象普通函数一样被程序调用，但是只有它被当作参数传递给被调函数时才能称作回调函数。</p><p>被调函数的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetCallBack</span><span class="params">(pcb callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户在调用上面的函数时，需要自己实现一个pcb类型的回调函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fCallback</span><span class="params">(<span class="keyword">char</span> *s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* do something */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 然后，就可以直接把fCallback当作一个变量传递给GetCallBack,</span></span><br><span class="line">GetCallBack（fCallback）;</span><br></pre></td></tr></table></figure><p>如果赋了不同的值给该参数，那么调用者将调用不同地址的函数。赋值可以发生在运行时，这样使你能实现动态绑定。</p><h5 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h5><p>到目前为止，我们只讨论了函数指针及回调而没有去注意 ANSI C/C++ 的编译器规范。许多编译器有几种调用规范。如在Visual C++中，可以在函数类型前加 <code>_cdecl</code>，<code>_stdcall</code> 或者 <code>_pascal</code> 来表示其调用规范（默认为 <code>_cdecl</code>）。C++ Builder也支持 <code>_fastcall</code> 调用规范。调用规范影响编译器产生的给定函数名，参数传递的顺序（从右到左或从左到右），堆栈清理责任（调用者或者被调用者）以及参数传递机制（堆栈，CPU寄存器等）。</p><p>将调用规范看成是函数类型的一部分是很重要的；不能用不兼容的调用规范将地址赋值给函数指针。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用函数是以 int 为参数，以 int 为返回值</span></span><br><span class="line">__<span class="function">stdcall <span class="keyword">int</span> <span class="title">callee</span><span class="params">(<span class="keyword">int</span>)</span></span>; </span><br><span class="line"><span class="comment">// 调用函数以函数指针为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">caller</span><span class="params">( __cdecl <span class="keyword">int</span>(*ptr)(<span class="keyword">int</span>))</span></span>; </span><br><span class="line"><span class="comment">// 在 p 中企图存储被调用函数地址的非法操作</span></span><br><span class="line">__<span class="function">cdecl <span class="title">int</span><span class="params">(*p)</span><span class="params">(<span class="keyword">int</span>)</span> </span>= callee; <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure><p>指针 p 和 callee() 的类型不兼容，因为它们有不同的调用规范。因此不能将被调用者的地址赋值给指针p，尽管两者有相同的返回值和参数列</p><h5 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h5><p>C 语言的标准库函数中很多地方就采用了回调函数来让用户定制处理过程。如常用的快速排序函数、二分搜索函数等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> width, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> (_USERENTRY *fcmp)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">// 二分搜索函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bsearch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *base, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> (_USERENTRY *fcmp)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><p>其中 fcmp 就是一个回调函数的变量。</p><p>下面给出一个具体的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">5</span>] = &#123; <span class="number">54</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">22</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x;</span><br><span class="line">   qsort((<span class="keyword">void</span> *)<span class="built_in">list</span>, <span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="built_in">list</span>[<span class="number">0</span>]), sort_function);</span><br><span class="line">   <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%i\n"</span>, <span class="built_in">list</span>[x]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> *(<span class="keyword">int</span>*)a-*(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回调在分布式计算中的应用（CORBA）"><a href="#回调在分布式计算中的应用（CORBA）" class="headerlink" title="回调在分布式计算中的应用（CORBA）"></a>回调在分布式计算中的应用（CORBA）</h4><h5 id="回调接口模型"><a href="#回调接口模型" class="headerlink" title="回调接口模型"></a>回调接口模型</h5><p>CORBA 的消息传递机制有很多种，比如回调接口、事件服务和通知服务等。回调接口的原理很简单，CORBA 客户和服务器都具有双重角色，即充当服务器也是客户客户。</p><p>回调接口的反向调用与正向调用往往是同时进行的，如果服务端多次调用该回调接口，那么这个回调接口就变成异步接口了。因此，回调接口在 CORBA 中常常充当事件注册的用途，客户端调用该注册函数时，客户函数就是回调函数，在此后的调用中，由于不需要客户端的主动参与，该函数就是实现了一种异步机制。</p><p>从 CORBA 规范我们知道，一个 CORBA 接口在服务端和客户端有不同的表现形式，在客户端一般使用桩（Stub）文件，服务端则用到框架（Skeleton）文件，接口的规格采用 IDL 来定义。而回调函数的引入，使得服务端和客户端都需要实现一定的桩和框架。下面是回调接口的实现模型：</p><img src="/images/imageProgramC/interview/回调机制-02.gif"><p>下面给出了一个使用回调的接口文件，服务端需要实现 Server 接口的框架，客户端需要实现 CallBack 的框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module cb</span><br><span class="line">&#123;</span><br><span class="line">    interface CallBack;</span><br><span class="line">    interface Server;</span><br><span class="line">    interface CallBack </span><br><span class="line">    &#123;</span><br><span class="line">    void OnEvent(in long Source,in long msg);</span><br><span class="line">    &#125;;</span><br><span class="line">    interface Server </span><br><span class="line">    &#123;</span><br><span class="line">        long RegisterCB(in CallBack cb);</span><br><span class="line">        void UnRegisterCB(in long hCb);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户端首先通过同步方式调用服务端的接口 RegistCB，用来注册回调接口 CallBack。服务端收到该请求以后，就会保留该接口引用，如果发生某种事件需要向客户端通知的时候就通过该引用调用客户方的 OnEvent 函数，以便对方及时处理。</p><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><h3 id="避免野指针的方法"><a href="#避免野指针的方法" class="headerlink" title="避免野指针的方法"></a>避免野指针的方法</h3><p>为了防止野指针带来的灾难，建议指针在定义时给一个初值，比如“NULL”，意思是不指向任何内存地址。然后再使用malloc函数给指针分配一块存储空间。</p><details><summary>避免野指针的方法</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"123"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="literal">NULL</span>; <span class="comment">//str2 赋初值，不指向任何内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2的值是: %u\n"</span>, str2);</span><br><span class="line">    </span><br><span class="line">    str2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2被分配的地址是: %u\n"</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(str2, str1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2指向的字符串是: %s\n"</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != str2)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">free</span>(str2); <span class="comment">// 主动释放分配给str2的内存</span></span><br><span class="line">    str2 = <span class="literal">NULL</span>; <span class="comment">// 让str2不指向任何内存    </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9qdWx5X3YvYXJ0aWNsZS9kZXRhaWxzLzY2ODU5NjI=" title="http://blog.csdn.net/v_july_v/article/details/6685962"> 海量数据处理面试题集锦<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9KVUxZX3YvYXJ0aWNsZS9kZXRhaWxzLzYyNzk0OTg=" title="http://blog.csdn.net/v_JULY_v/article/details/6279498">十道海量数据处理面试题与十个方法大总结<i class="fa fa-external-link"></i></span></li></ul><h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy55dW5saWFvaW0uY29tL2ltLzE4NjkuaHRtbA==" title="http://www.yunliaoim.com/im/1869.html">最全实时音视频开发要用到的开源工程汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dlYnJ0Yy5vcmcuY24vMTglRTQlQjglQUElRTUlQUUlOUUlRTYlOTclQjYlRTklOUYlQjMlRTglQTclODYlRTklQTIlOTElRTUlQkMlODAlRTUlOEYlOTElRTQlQjglQUQlRTQlQkMlOUElRTclOTQlQTglRTUlODglQjAlRTUlQkMlODAlRTYlQkElOTAlRTklQTElQjklRTclOUIlQUUv" title="http://webrtc.org.cn/18%E4%B8%AA%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BC%9A%E7%94%A8%E5%88%B0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">18个实时音视频开发中会用到开源项目<i class="fa fa-external-link"></i></span></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9ic19mYXEuaHRtbA==" title="http://www.stroustrup.com/bs_faq.html">Bjarne Stroustrup 的常见问题<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9ic19mYXEyLmh0bWw=" title="http://www.stroustrup.com/bs_faq2.html">Bjarne Stroustrup 的 C++ 风格和技巧常见问题<i class="fa fa-external-link"></i></span></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul><li>《C++ Primer》</li><li>《Effective C++》</li><li>《More Effective C++》</li><li>《深度探索 C++ 对象模型》</li><li>《深入理解 C++11》</li><li>《STL 源码剖析》</li></ul><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><ul><li>《剑指 Offer》</li><li>《编程珠玑》</li><li>《程序员面试宝典》</li></ul><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul><li>《深入理解计算机系统》</li><li>《Windows 核心编程》</li><li>《Unix 环境高级编程》</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>《Unix 网络编程》</li><li>《TCP/IP 详解》</li></ul><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li>《程序员的自我修养》</li></ul><h2 id="复习刷题网站"><a href="#复习刷题网站" class="headerlink" title="复习刷题网站"></a>复习刷题网站</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20v" title="https://leetcode.com/">leetcode<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIubmV0Lw==" title="https://www.nowcoder.net/">牛客网<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW1vb2MuY29tLw==" title="https://www.imooc.com/">慕课网<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tLw==" title="http://www.runoob.com/">菜鸟教程<i class="fa fa-external-link"></i></span></li></ul><h2 id="招聘时间岗位"><a href="#招聘时间岗位" class="headerlink" title="招聘时间岗位"></a>招聘时间岗位</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2FjdGl2aXR5L2NhbXB1czIwMTk=" title="https://www.nowcoder.com/activity/campus2019">牛客网 . 2019 IT名企校招指南<i class="fa fa-external-link"></i></span></li></ul><h2 id="面试题目经验"><a href="#面试题目经验" class="headerlink" title="面试题目经验"></a>面试题目经验</h2><h3 id="牛客网-1"><a href="#牛客网-1" class="headerlink" title="牛客网"></a>牛客网</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvMTI4MDU=" title="https://www.nowcoder.com/discuss/12805">牛客网 . 2017秋季校园招聘笔经面经专题汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvMjUyNjg=" title="https://www.nowcoder.com/discuss/25268">牛客网 . 史上最全2017春招面经大合集！！<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvNTc5Nzg=" title="https://www.nowcoder.com/discuss/57978">牛客网 . 面试题干货在此<i class="fa fa-external-link"></i></span></li></ul><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI5NjkzMDE2" title="https://www.zhihu.com/question/29693016">知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI0OTY0OTg3" title="https://www.zhihu.com/question/24964987">知乎 . 互联网公司最常见的面试算法题有哪些？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMTg0ODU3" title="https://www.zhihu.com/question/20184857">知乎 . 面试 C++ 程序员，什么样的问题是好问题？<i class="fa fa-external-link"></i></span></li></ul><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGp6Y29tZS9hcnRpY2xlL2RldGFpbHMvNTc0MTU4" title="http://blog.csdn.net/ljzcome/article/details/574158">CSDN . 全面整理的C++面试题<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdjaGFvOTkvYXJ0aWNsZS9kZXRhaWxzLzc0NTI0ODA3P2xvY2F0aW9uTnVtPTYmZnBzPTE=" title="http://blog.csdn.net/Xiongchao99/article/details/74524807?locationNum=6&fps=1">CSDN . 百度研发类面试题（C++方向）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmFraW5lL2FydGljbGUvZGV0YWlscy81MTMyMTU0NA==" title="http://blog.csdn.net/fakine/article/details/51321544">CSDN . c++常见面试题30道<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb25ldmVyX3NheV9sb3ZlL2FydGljbGUvZGV0YWlscy81MTIyMzg4Ng==" title="http://blog.csdn.net/onever_say_love/article/details/51223886">CSDN . 腾讯2016实习生面试经验（已经拿到offer)<i class="fa fa-external-link"></i></span></li></ul><h3 id="cnblogs"><a href="#cnblogs" class="headerlink" title="cnblogs"></a>cnblogs</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vWTFGb2N1cy9wLzY3MDcxMjEuaHRtbA==" title="https://www.cnblogs.com/Y1Focus/p/6707121.html">cnblogs . C++面试集锦( 面试被问到的问题 )<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZmFuZ3l1a3Vhbi9hcmNoaXZlLzIwMTAvMDkvMTgvMTgyOTg3MS5odG1s" title="https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html">cnblogs . C/C++ 笔试、面试题目大汇总<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTFVPNzcvcC81NzcxMjM3Lmh0bWw=" title="https://www.cnblogs.com/LUO77/p/5771237.html">cnblogs . 常见C++面试题及基本知识点总结（一）<i class="fa fa-external-link"></i></span></li></ul><h3 id="Segmentfault"><a href="#Segmentfault" class="headerlink" title="Segmentfault"></a>Segmentfault</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwMzc0NTUyOQ==" title="https://segmentfault.com/a/1190000003745529">segmentfault . C++常见面试问题总结<i class="fa fa-external-link"></i></span></li></ul><h3 id="HTTP相关知识"><a href="#HTTP相关知识" class="headerlink" title="HTTP相关知识"></a>HTTP相关知识</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjM2ODczMg==" title="https://segmentfault.com/a/1190000012368732">你必须知道的HTTP基本概念<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9pbXF1cXUuY29tL3Bvc3QvbmV0d29yay1wcm90b2NvbC1pbi1icm93c2VyLmh0bWw=" title="https://imququ.com/post/network-protocol-in-browser.html">浏览器中常见网络协议介绍<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDA3MzE3" title="https://cloud.tencent.com/developer/article/1007317">WebRTC介绍及简单应用<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2htYWkvYXJ0aWNsZS9kZXRhaWxzLzY5NjgxNTk1" title="https://blog.csdn.net/fishmai/article/details/69681595">WebRTC架构简介<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWIxNGJkOWNlNTFkNDUwNjg4MTM0NDMw" title="https://juejin.im/entry/5b14bd9ce51d450688134430">了不起的WebRTC：生态日趋完善，或将实时音视频技术白菜化<i class="fa fa-external-link"></i></span></li></ul><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><ul><li><span class="exturl" data-url="aHR0cDovL3NwYXJrLmFwYWNoZWNuLm9yZy9kb2NzL2NuLzIuMi4wLw==" title="http://spark.apachecn.org/docs/cn/2.2.0/">Apache Spark 中文文档<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxODUyOTYvYXJ0aWNsZS9kZXRhaWxzLzc2ODU1Nzcw" title="https://blog.csdn.net/u012185296/article/details/76855770">Apache Spark 2.2.0 官方文档中文版（翻译完成 98%. 除 MLib 外） | ApacheCN<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h3YzM1MDQ3L2FydGljbGUvZGV0YWlscy82MDMzMDUyOA==" title="https://blog.csdn.net/xwc35047/article/details/60330528">30分钟概览Spark分布式计算引擎<i class="fa fa-external-link"></i></span></li></ul><h3 id="加密安全问题"><a href="#加密安全问题" class="headerlink" title="加密安全问题"></a>加密安全问题</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1ZmFsaWFuZzAwMy9hcnRpY2xlL2RldGFpbHMvNzk3ODIxNjg=" title="https://blog.csdn.net/wufaliang003/article/details/79782168">SHA算法系列介绍<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yMjVmZjk0MzkxMzI=" title="https://www.jianshu.com/p/225ff9439132">比特币背后的密码学原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5kaXd1eWEvYXJ0aWNsZS9kZXRhaWxzLzc5NTcxNjM5" title="https://blog.csdn.net/tiandiwuya/article/details/79571639">比特币的加密算法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnV4cHJvYmUyMDE3L2FydGljbGUvZGV0YWlscy82MjA0OTAwMQ==" title="https://blog.csdn.net/linuxprobe2017/article/details/62049001">密码学大事件！ SHA-1 哈希碰撞实例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzI4NTI3Lmh0bWw=" title="https://www.freebuf.com/articles/web/28527.html">如何安全的存储用户的密码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXFuaXUuY29tL2xlYXJuLzMwMjM4Lmh0bWw=" title="https://www.aqniu.com/learn/30238.html">机器学习作用于信息安全的五大顶级案例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzUwODUzODkx" title="https://www.zhihu.com/question/50853891">机器学习和数据挖掘在网络安全领域会有哪些应用？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGVpcGhvbmUuY29tL25ld3MvMjAxNjA5L2ZZNHB6dHQ0UlFzck9xamkuaHRtbA==" title="https://www.leiphone.com/news/201609/fY4pztt4RQsrOqji.html">机器学习正在安全领域挂起一阵小旋风，但这里面有BUG<i class="fa fa-external-link"></i></span></li></ul><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLm1iYWxpYi5jb20vc3RvcnkvODg1MDY=" title="https://news.mbalib.com/story/88506">终于有人把P2P、P2C、O2O、B2C、B2B、C2C 的区别讲透了！<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTA2NjkzOQ==" title="https://zhuanlan.zhihu.com/p/35066939">如何真正让小程序,WebRTC和APP互通连麦直播<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly8zNmtyLmNvbS9wLzUxMTc1NzUuaHRtbA==" title="https://36kr.com/p/5117575.html">创业者必读：开发一款 App 到底需要多久？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80MmMyNDkxNjgyNzU=" title="https://www.jianshu.com/p/42c249168275">如何开发一个app（Android）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hYWVmNWNlYjM5MzY=" title="https://www.jianshu.com/p/aaef5ceb3936">微信小程序开发教程–从零开始<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTkzMTU1MQ==" title="https://zhuanlan.zhihu.com/p/39931551">面向机器学习:数据平台的设计与搭建<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjEzNTQ4MmU1MWQ0NTA2ZGMwYWFhMTQ=" title="https://juejin.im/post/5b135482e51d4506dc0aaa14">基于Apache Spark以BigDL搭建可扩展的分布式深度学习框架<i class="fa fa-external-link"></i></span></li><li></li></ul><h3 id="高德面试"><a href="#高德面试" class="headerlink" title="高德面试"></a>高德面试</h3><p>基本知识</p><p>1、进程和线程</p><p>2、多线程通讯方式</p><p>3、消费者和生产者模式（消费者是否轮询方式读取消息，用等待信号方式）</p><p>4、linux命令   top、netstat</p><p>5、gdb调试，怎样切换到某个线程</p><p>6、inline和宏定义区别</p><p>7、vector和list区别，什么情况分别是用什么</p><p>8、类的什么函数不能作为虚函数、析构函数能否作为虚函数，虚函数怎么实现的</p><p>9、setsocektopt   no-delay，等参数的作用</p><p>10、tcp关闭时的几个步骤，tcp的慢启动时啥意思，，，，</p><p>11、epoll模型，我说的是多线程，每个线程一个epoll，一个专门接收链接，另外的读数据 ，解码在哪个线程中进行</p><p>12、c++11 智能指针</p><p>13、死锁概念</p><p>14、什么叫做稳定排序、有哪些排序算法、快排怎么实现的</p><p>15、怎么样判断一棵树和平衡二叉树</p><p>16、当前编写代码（输入一个字符串和一个分隔符，，，，，，把字符串用分割符分割几部分，然后输出）</p><p>项目：</p><p>1、freeswitch的系统结构模型、并发的语音的最大路数，语音编码</p><p>2、视频花屏是怎样优化的</p><p>3、rtp，udp</p><p>4、语音包、和视频包是不是固定大小的，，，是否分包</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-C-面试知识总结&quot;&gt;&lt;a href=&quot;#C-C-面试知识总结&quot; class=&quot;headerlink&quot; title=&quot;C/C++ 面试知识总结&quot;&gt;&lt;/a&gt;C/C++ 面试知识总结&lt;/h1&gt;&lt;p&gt;C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。&lt;/p&gt;
&lt;p&gt;勘误新增请 Issue、PR，建议、讨论请 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2h1aWh1dC9pbnRlcnZpZXcvaXNzdWVzLzEy&quot; title=&quot;https://github.com/huihut/interview/issues/12&quot;&gt;#issues/12&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;，排版使用 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL216bG9naW4vY2hpbmVzZS1jb3B5d3JpdGluZy1ndWlkZWxpbmVz&quot; title=&quot;https://github.com/mzlogin/chinese-copywriting-guidelines&quot;&gt;中文文案排版指北&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl + F&lt;/code&gt;：快速查找定位知识点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TOC 导航&lt;/code&gt;：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2phd2lsL0dheUh1Yg==&quot; title=&quot;https://github.com/jawil/GayHub&quot;&gt;jawil/GayHub&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt; 插件快速目录跳转&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>重拾十大经典排序算法</title>
    <link href="http://miaopei.github.io/2016/06/05/Program-C/algorithm/"/>
    <id>http://miaopei.github.io/2016/06/05/Program-C/algorithm/</id>
    <published>2016-06-05T02:14:50.000Z</published>
    <updated>2019-06-28T01:46:21.857Z</updated>
    
    <content type="html"><![CDATA[<p>最近在工作中偶然间涉及到数据库的存储和访问，数据库里存放着员工的指纹、年龄以及姓名等信息，当然指纹是通过<code>md5</code>加密存储的。目前需要对员工的年龄、学历、工作年限等进行排序，如果只有几十个上百个样本，应该不会那么麻烦；关键这是几万名员工的数据，这个量很大，马虎不得。悄悄的告诉你，别惹我，我懂得删库跑路哦。</p><p>脑海中对排序的记忆有点模糊，只对<span style="color: #1976D2; ">「归并排序」</span>印象较为深刻，为了加深理解，重拾<span style="color: #1976D2; ">「数据结构与算法」</span>，并总结了一下常用的十大经典排序算法，由于平台为<code>linux</code>，因此代码全部用<code>C++</code>实现，全部源码均在<code>linux</code>下编译通过并测试成功，可以作为参考。</p><a id="more"></a><p>排序算法在程序猿的编程生涯中虽然用的不多，但是作为基本功，还是要掌握一下。排序算法是<span style="color: #1976D2; ">「数据结构与算法」</span>中最基本的算法，它分为<span style="color: #1976D2; ">「内部排序」</span>和<span style="color: #1976D2; ">「外部排序」</span>；<span style="color: #1976D2; ">「内部排序」</span>一般在内存中实现；当数据量很大时，内存有限，不能将所有的数据都放到内存中来，这个时候必须使用<span style="color: #1976D2; ">「外部排序」</span>。</p><p>先看一张图，对常用算法的时间复杂度做个比较：</p><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最佳情况</th><th>最坏情况</th><th>空间复杂度</th><th>排序方式</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$O(n \log n)$</td><td>$O(n \log^2 n)$</td><td>$O(n \log^2 n)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n)$</td><td>Out-place</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n^2)$</td><td>$O(\log n)$</td><td>In-place</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(k)$</td><td>Out-place</td><td>稳定</td></tr><tr><td>桶排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n^2)$</td><td>$O(n+k)$</td><td>Out-place</td><td>稳定</td></tr><tr><td>基数排序</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n+k)$</td><td>Out-place</td><td>稳定</td></tr></tbody></table><p>这里的<span style="color: #1976D2; ">「稳定」</span>是指当排序后两个相等键值的顺序和排序之前的顺序相同；</p><ul><li>n: 代表数据规模及数据量大小</li><li>k: 桶的个数</li><li>In-place: 不占用额外内存，只占用常数内存</li><li>Out-place: 占用额外内存</li></ul><h2 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一 冒泡排序"></a><span style="color: #1976D2; ">一 冒泡排序</span></h2><p>冒泡排序是排序算法中较为简单的一种，英文称为<code>Bubble Sort。</code>它遍历所有的数据，每次对相邻元素进行两两比较，如果顺序和预先规定的顺序不一致，则进行位置交换；这样一次遍历会将最大或最小的数据上浮到顶端，之后再重复同样的操作，直到所有的数据有序。</p><p>如果有$n$个数据，那么需要$O(n^2)$的比较次数，所以当数据量很大时，冒泡算法的效率并不高。<br>当输入的数据是反序时，花的时间最长，当输入的数据是正序时，时间最短。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：<span style="color: #D32F2F; ">$O(n^2)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：<span style="color: #D32F2F; ">$O(1)$</span></p><p>动态演示：<br><img src="/images/imageProgramC/bubbleSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">61</span>, <span class="number">17</span>, <span class="number">29</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">60</span>, <span class="number">72</span>, <span class="number">21</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">62</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">bubble_sort(arr, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line">len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">bubble_sort(arrf, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>新建代码文件<code>bubble_sort.cpp，</code>将以上代码写入，<code>linux</code>下编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -o bubble_sort bubble_sort.cpp</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bubble_sort</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 17 21 22 29 34 50 60 61 62 72</span><br><span class="line">0.6 1.5 1.9 3.8 4.4 5.4 10.5 12.4 17.5 19.1 19.7 23.8 25.4 28.6</span><br></pre></td></tr></table></figure><p>以下的编译方法和测试方法和这里一样，所以下面不再重复编译和测试的说明。</p><h2 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二 选择排序"></a><span style="color: #1976D2; ">二 选择排序</span></h2><p>选择排序简单直观，英文称为<code>Selection Sort，</code>先在数据中找出最大或最小的元素，放到序列的起始；然后再从余下的数据中继续寻找最大或最小的元素，依次放到排序序列中，直到所有数据样本排序完成。很显然，选择排序也是一个费时的排序算法，无论什么数据，都需要$O(n^2)$的时间复杂度，不适宜大量数据的排序。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n^2)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(1)$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/selectionSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(T arr[],<span class="keyword">int</span> len )</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len  - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">min = j;</span><br><span class="line"><span class="built_in">std</span>::swap(arr[i], arr[min]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">selection_sort(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三 插入排序"></a><span style="color: #1976D2; ">三 插入排序</span></h2><p>插入排序英文称为<code>Insertion Sort，</code>它通过构建有序序列，对于未排序的数据序列，在已排序序列中从后向前扫描，找到相应的位置并插入，类似打扑克牌时的码牌。插入排序有一种优化的算法，可以进行拆半插入。</p><p>基本思路是先将待排序序列的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；然后从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置，直到所有数据都完成排序；如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n^2)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(1)$</span></p><p>动态演示：<br><img src="/images/imageProgramC/insertionSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(T arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        T key=arr[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; key&lt;arr[j];j--)</span><br><span class="line">        arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">        arr[j+<span class="number">1</span>]=key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">insertion_sort(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="四-希尔排序"><a href="#四-希尔排序" class="headerlink" title="四 希尔排序"></a><span style="color: #1976D2; ">四 希尔排序</span></h2><p>希尔排序也称递减增量排序，是插入排序的一种改进版本，英文称为<code>Shell Sort</code>，效率虽高，但它是一种不稳定的排序算法。</p><p>插入排序在对几乎已经排好序的数据操作时，效果是非常好的；但是插入排序每次只能移动一位数据，因此插入排序效率比较低。</p><p>希尔排序在插入排序的基础上进行了改进，它的基本思路是先将整个数据序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全部数据进行依次直接插入排序。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n \log n)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(1)$</span></p><p>假如有这样一组数据，<span style="color: #1976D2; ">[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，</span>如果以步长<code>5</code>进行分割，每一列为一组，那么这组数据应该首先分成这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>之后对每列进行插入排序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>将上述四行数据依序拼接在一起，得到<span style="color: #1976D2; ">[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]，</span>此时<code>10</code>已经移到正确的顺序了，之后以步长<code>3</code>进行插入排序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>排序之后变为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure><p>最后以步长 1 进行排序。</p><p>步长的选择是希尔排序的关键，只要最终步长为<code>1</code>，任何步长序列都可以。建议最初步长选择为数据长度的一半，直到最终的步长为<code>1</code>。</p><p>图解：</p><p><img src="/images/imageProgramC/shell.png" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(T <span class="built_in">array</span>[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; <span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[j - h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arrf[] = &#123; <span class="number">13</span>，<span class="number">14</span>，<span class="number">94</span>，<span class="number">33</span>，<span class="number">82</span>，<span class="number">25</span>，<span class="number">59</span>，<span class="number">94</span>，<span class="number">65</span>，<span class="number">23</span>，<span class="number">45</span>，<span class="number">27</span>，<span class="number">73</span>，<span class="number">25</span>，<span class="number">39</span>，<span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">shell_sort(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="五-归并排序"><a href="#五-归并排序" class="headerlink" title="五 归并排序"></a><span style="color: #1976D2; ">五 归并排序</span></h2><p>归并排序英文称为<code>Merge Sort</code>，归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法<code>（Divide and Conquer）</code>的一个非常典型的应用。它首先将数据样本拆分为两个子数据样本, 并分别对它们排序, 最后再将两个子数据样本合并在一起; 拆分后的两个子数据样本序列, 再继续递归的拆分为更小的子数据样本序列, 再分别进行排序, 直到最后数据序列为1，而不再拆分，此时即完成对数据样本的最终排序。 </p><p>归并排序严格遵循从左到右或从右到左的顺序合并子数据序列, 它不会改变相同数据之间的相对顺序, 因此归并排序是一种稳定的排序算法.</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现分为两种方法：</p><ul><li>自上而下的递归；</li><li>自下而上的迭代；</li></ul><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n \log n)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(n)$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/mergeSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_iteration</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;<span class="comment">//迭代法</span></span><br><span class="line">T* a = arr;</span><br><span class="line">T* b = <span class="keyword">new</span> T[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line"><span class="keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</span><br><span class="line"><span class="keyword">int</span> k = low;</span><br><span class="line"><span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line"><span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line"><span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">b[k++] = a[start1++];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">b[k++] = a[start2++];</span><br><span class="line">&#125;</span><br><span class="line">T* temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">b[i] = a[i];</span><br><span class="line">b = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive_t</span><span class="params">(T arr[], T reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;<span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"><span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line"><span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line"><span class="keyword">merge_sort_recursive_t</span>(arr, reg, start1, end1);</span><br><span class="line"><span class="keyword">merge_sort_recursive_t</span>(arr, reg, start2, end2);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> k = start;</span><br><span class="line"><span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">reg[k++] = arr[start1++];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">reg[k++] = arr[start2++];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(T arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">T *reg = <span class="keyword">new</span> T[len];</span><br><span class="line"><span class="keyword">merge_sort_recursive_t</span>(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</span><br><span class="line">merge_sort_recursive(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">merge_sort_iteration(arrf,len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="六-快速排序"><a href="#六-快速排序" class="headerlink" title="六 快速排序"></a><span style="color: #1976D2; ">六 快速排序</span></h2><p>快速排序,英文称为Quicksort，又称划分交换排序 partition-exchange sort 简称快排。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。首先从数列中挑出一个元素，并将这个元素称为「基准」，英文pivot。重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。之后，在子序列中继续重复这个方法，直到最后整个数据序列排序完成。</p><p>在平均状况下，排序n个项目要$O(n \log n)$次比较。在最坏状况下则需要$O(n^2)$次比较，但这种状况并不常见。事实上，快速排序通常明显比其他算法更快，因为它的内部循环可以在大部分的架构上很有效率地达成。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; "> $O(n \log n)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>： ：<span style="color: #D32F2F; ">$O(\log n)$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/quickSort.gif" alt></p><p>更直观一些的动图演示：</p><p><img src="/images/imageProgramC/Sorting_quicksort_anim.gif" alt></p><p>代码分两种方式实现，分别为迭代法和递归法。</p><details><summary>迭代法：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    Range(<span class="keyword">int</span> s = <span class="number">0</span>, <span class="keyword">int</span> e = <span class="number">0</span>) &#123;</span><br><span class="line">        start = s, end = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// </span></span><br><span class="line">    </span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        T mid = arr[range.end];</span><br><span class="line">        <span class="keyword">int</span> left = range.start, right = range.end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;</span><br><span class="line">            <span class="built_in">std</span>::swap(arr[left], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= arr[range.end])</span><br><span class="line">            <span class="built_in">std</span>::swap(arr[left], arr[range.end]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left++;</span><br><span class="line">        </span><br><span class="line">        r[p++] = Range(range.start, left - <span class="number">1</span>);</span><br><span class="line">        r[p++] = Range(left + <span class="number">1</span>, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>递归法：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(T arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    T mid = arr[end];</span><br><span class="line">    <span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[left], arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[left], arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    </span><br><span class="line">    quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="七-堆排序"><a href="#七-堆排序" class="headerlink" title="七 堆排序"></a><span style="color: #1976D2; ">七 堆排序</span></h2><p>堆排序，英文称Heapsort，是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序实现分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>算法步骤：</p><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1</li></ol><p><span style="color: #43A047; ">平均时间复杂度</span>： ：<span style="color: #D32F2F; ">$O(n \log n)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>： ：<span style="color: #D32F2F; ">$O(1)$</span></p><p>动图演示：</p><p><img src="/images/imageProgramC/Sorting_heapsort_anim.gif" alt></p><p>来一个更直观一些的：</p><p><img src="/images/imageProgramC/heapSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="comment">//建立父节点指标和子节点指标</span></span><br><span class="line"><span class="keyword">int</span> dad = start;</span><br><span class="line"><span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">//子节点指标在范围内才做比较</span></span><br><span class="line"><span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">//比较两个子节点大小，选择最大的</span></span><br><span class="line">son++;</span><br><span class="line"><span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点大于子节点代表调整完毕，直接跳出函数</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//否則交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">swap(arr[dad], arr[son]);</span><br><span class="line">dad = son;</span><br><span class="line">son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化，i从最后一个父节点开始调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//先將第一个元素和已经排好的元素前一位做交换，再重调整，(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">heap_sort(arr, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="八-计数排序"><a href="#八-计数排序" class="headerlink" title="八 计数排序"></a><span style="color: #1976D2; ">八 计数排序</span></h2><p>计数排序英文称Counting sort，是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于  i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。基本的步骤如下：</p><ol><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>对所有的计数累加,从C中的第一个元素开始，每一项和前一项相加</li><li>反向填充目标数组,将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1</li></ol><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n + k )$</span></p><p><span style="color: #43A047; ">空间复杂度</span>： ：<span style="color: #D32F2F; ">$O(k)$</span></p><p>动图演示：</p><p><img src="/images/imageProgramC/countingSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Count_Sort</span><span class="params">(<span class="keyword">int</span>* Data, <span class="keyword">int</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* Cout = <span class="literal">NULL</span>;           </span><br><span class="line">    Cout = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * Len);   </span><br><span class="line">    <span class="comment">//初始化记数为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Len; i++) &#123;</span><br><span class="line">        Cout[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录重复的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Len; i++) &#123;</span><br><span class="line">        Cout[Data[i]] += <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定不比该位置大的数据个数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Len; i++) &#123;</span><br><span class="line">        Cout[i] += Cout[i - <span class="number">1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* Sort = <span class="literal">NULL</span>;           </span><br><span class="line">    Sort = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * Len);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Len; i++) &#123;</span><br><span class="line">        <span class="comment">//将数组反向填充到Sort，每次拿出一个就减一</span></span><br><span class="line">        Cout[Data[i]] -= <span class="number">1</span>;   </span><br><span class="line">        Sort[Cout[Data[i]]] = Data[i];           </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序结束，将排序好的数据复制到原来数组中。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Len; ++i) &#123;</span><br><span class="line">        Data[i] = Sort[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放申请的空间。</span></span><br><span class="line">    <span class="built_in">free</span>(Cout);</span><br><span class="line">    <span class="built_in">free</span>(Sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="九-桶排序"><a href="#九-桶排序" class="headerlink" title="九 桶排序"></a><span style="color: #1976D2; ">九 桶排序</span></h2><p>桶排序也称为箱排序，英文称为 Bucket Sort。它是将数组划分到一定数量的有序的桶里，然后再对每个桶中的数据进行排序，最后再将各个桶里的数据有序的合并到一起。</p><p><span style="color: #43A047; ">平均时间复杂度</span>：：<span style="color: #D32F2F; ">$O(n + k)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>：：<span style="color: #D32F2F; ">$O(n + k)$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/bucketsort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> tValue; </span><br><span class="line">tNode *next; </span><br><span class="line"></span><br><span class="line">tNode(<span class="keyword">int</span> val) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;tValue = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> *arrf, <span class="keyword">const</span> <span class="keyword">int</span> SIZE)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tNode **pNode = (tNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tNode *) * <span class="number">512</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pNode)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(pNode, <span class="number">0</span>, <span class="keyword">sizeof</span>(tNode *) * <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> shiftNum = <span class="number">0</span>;</span><br><span class="line">tNode *p = <span class="literal">NULL</span>;</span><br><span class="line">tNode *pLast = <span class="literal">NULL</span>;</span><br><span class="line">tNode *pNewNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">shiftNum = arrf[i] &gt;&gt; <span class="number">24</span>;</span><br><span class="line">p = pNode[shiftNum];</span><br><span class="line"></span><br><span class="line">pNewNode = <span class="keyword">new</span> tNode(arrf[i]);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pNewNode)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p) &#123;</span><br><span class="line">pNode[shiftNum] = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arrf[i] &lt;= p-&gt;tValue) &#123;</span><br><span class="line">pNode[shiftNum] = pNewNode;</span><br><span class="line">pNewNode-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">NULL</span> != p-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span> (arrf[i] &gt; p-&gt;next-&gt;tValue)</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pNewNode-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">p = pNode[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">NULL</span> != p) &#123;</span><br><span class="line">arrf[k++] = p-&gt;tValue;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>,<span class="number">558</span>,<span class="number">772</span>,<span class="number">935</span>,<span class="number">344</span>,<span class="number">487</span>,<span class="number">96</span>,<span class="number">665</span>,<span class="number">302</span>,<span class="number">735</span>,<span class="number">954</span>,<span class="number">308</span>,<span class="number">718</span>,<span class="number">147</span>,<span class="number">185</span>,<span class="number">371</span>,<span class="number">166</span>,<span class="number">849</span>,<span class="number">202</span>,<span class="number">478</span>,<span class="number">874</span>,<span class="number">169</span>,<span class="number">980</span>,<span class="number">125</span>,<span class="number">44</span>,<span class="number">15</span>,<span class="number">279</span>,<span class="number">882</span>,<span class="number">466</span>,<span class="number">974</span> &#125;;</span><br><span class="line"></span><br><span class="line">bucket_sort(arr,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="十-基数排序"><a href="#十-基数排序" class="headerlink" title="十 基数排序"></a><span style="color: #1976D2; ">十 基数排序</span></h2><p>基数排序英文称Radix sort，是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串和特定格式的浮点数，所以基数排序也仅限于整数。它首先将所有待比较数值，统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p><span style="color: #43A047; ">平均时间复杂度</span>： ：<span style="color: #D32F2F; ">$O(n \times k)$</span></p><p><span style="color: #43A047; ">空间复杂度</span>： ：<span style="color: #D32F2F; ">$O(n + k )$</span></p><p>动态演示：</p><p><img src="/images/imageProgramC/radixSort.gif" alt></p><details><summary>代码：</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> <span class="comment">//辅助函数，求数据的最大位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxData = data[<span class="number">0</span>];<span class="comment">///&lt; 最大数</span></span><br><span class="line">    <span class="comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p) &#123;</span><br><span class="line">        <span class="comment">//p *= 10; // Maybe overflow</span></span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"><span class="comment">/*  int d = 1; //保存最大的位数</span></span><br><span class="line"><span class="comment">    int p = 10;</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        while(data[i] &gt;= p)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p *= 10;</span></span><br><span class="line"><span class="comment">            ++d;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return d;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = maxbit(data, n);</span><br><span class="line">    <span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;  <span class="comment">//将所有桶中记录依次收集到tmp中      </span></span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        </span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><span style="color: #1976D2; ">参考</span></h2><p><span style="color: #1976D2; ">wiki</span><br><span style="color: #1976D2; "><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1c3RjYy9KUy1Tb3J0aW5nLUFsZ29yaXRobQ==" title="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm<i class="fa fa-external-link"></i></span></span><br><span style="color: #1976D2; ">「数据结构与算法」</span><br><span style="color: #1976D2; ">「算法导论」</span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在工作中偶然间涉及到数据库的存储和访问，数据库里存放着员工的指纹、年龄以及姓名等信息，当然指纹是通过&lt;code&gt;md5&lt;/code&gt;加密存储的。目前需要对员工的年龄、学历、工作年限等进行排序，如果只有几十个上百个样本，应该不会那么麻烦；关键这是几万名员工的数据，这个量很大，马虎不得。悄悄的告诉你，别惹我，我懂得删库跑路哦。&lt;/p&gt;
&lt;p&gt;脑海中对排序的记忆有点模糊，只对&lt;span style=&quot;color: #1976D2; &quot;&gt;「归并排序」&lt;/span&gt;印象较为深刻，为了加深理解，重拾&lt;span style=&quot;color: #1976D2; &quot;&gt;「数据结构与算法」&lt;/span&gt;，并总结了一下常用的十大经典排序算法，由于平台为&lt;code&gt;linux&lt;/code&gt;，因此代码全部用&lt;code&gt;C++&lt;/code&gt;实现，全部源码均在&lt;code&gt;linux&lt;/code&gt;下编译通过并测试成功，可以作为参考。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://miaopei.github.io/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://miaopei.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://miaopei.github.io/2016/06/03/Program-C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://miaopei.github.io/2016/06/03/Program-C/数据结构/</id>
    <published>2016-06-03T02:14:50.000Z</published>
    <updated>2019-06-28T01:48:02.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><a id="more"></a><img src="/images/imageProgramC/数据结构-00.png"><h2 id="一、数据结构概念"><a href="#一、数据结构概念" class="headerlink" title="一、数据结构概念"></a>一、数据结构概念</h2><h3 id="1-1-数据结构相关概念"><a href="#1-1-数据结构相关概念" class="headerlink" title="1.1 数据结构相关概念"></a>1.1 数据结构相关概念</h3><p><strong>疑惑</strong></p><p>1、我学完了C语言，可是现在感觉还是写不出代码。</p><p>2、为什么会有各种各样的程序存在？</p><p>3、程序的本质是什么？</p><ul><li><p>程序是为了具体问题而存在的 </p></li><li><p>程序需要围绕问题的解决进行设计</p></li><li><p>同一个问题可以有多种解决方案</p></li><li><p>如何追求程序的“性价比”？</p></li><li><p>是否有可量化的方法判别程序的好坏？</p></li></ul><p><strong>数据结构起源</strong></p><ul><li><p>计算机从解决数值计算问题到解决生活中的问题</p></li><li><p>现实生活中的问题涉及不同个体间的复杂联系</p></li><li><p>需要在计算机程序中描述生活中个体间的联系</p></li><li><p>*<em>数据结构主要研究非数值计算程序问题中的操作对象以及它们之间的关系 *</em></p></li><li><p><strong>不是研究复杂的算法</strong></p></li></ul><p><strong>数据结构中的基本概念</strong></p><p>数据 – 程序的操作对象，用于描述客观事物  (int a, int b,)</p><p>数据的特点：</p><ul><li><p>可以输入到计算机</p></li><li><p>可以被计算机程序处理</p></li></ul><p>数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等</p><p><strong>数据元素：组成数据的基本单位</strong></p><p>数据项：一个数据元素由若干数据项组成</p><p><strong>数据对象 – 性质相同的数据元素的集合   （比如：数组，链表）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyTeacher</span>&#123;</span>   <span class="comment">//一种数据类型</span></span><br><span class="line"><span class="keyword">char</span>name[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">char</span>tile[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span>age;</span><br><span class="line"><span class="keyword">char</span>addr[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main21</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyTeacher</span>  <span class="title">t1</span>;</span> <span class="comment">//数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MyTeacher</span> <span class="title">tArray</span>[30];</span> <span class="comment">//数据对象</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;t1, <span class="number">0</span>, <span class="keyword">sizeof</span>(t1));</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(t1.name, <span class="string">"name"</span>); <span class="comment">//数据项</span></span><br><span class="line"><span class="built_in">strcpy</span>(t1.addr, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line"><span class="built_in">strcpy</span>(t1.tile, <span class="string">"addr"</span>); <span class="comment">//数据项</span></span><br><span class="line">t1.age = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/数据结构.png"><p>数据元素之间不是独立的，存在特定的关系，这些关系即结构</p><p>*<em>数据结构指数据对象中数据元素之间的关系   *</em></p><p>如：数组中各个元素之间存在固定的线性关系   </p><ul><li>编写一个“好”的程序之前，必须分析待处理问题中各个对象的特性，以及对象之间的关系。</li></ul><p>基本概念总结：</p><img src="/images/imageProgramC/数据结构-01.png"><p><strong>数据的逻辑结构</strong></p><p>指数据元素之间的逻辑关系。即从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。逻辑结构可细分为4类：</p><img src="/images/imageProgramC/数据结构-02.png"><p><strong>数据的物理结构</strong></p><img src="/images/imageProgramC/数据结构-03.png"><p><strong>数据的运算</strong></p><img src="/images/imageProgramC/数据结构-04.png"><h3 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h3><p><strong>算法概念</strong></p><ul><li><p>算法是<strong>特定问题求解步骤的描述</strong></p></li><li><p>在计算机中表现为指令的有限序列 </p></li><li><p>算法是独立存在的一种解决问题的方法和思想。</p></li><li><p>对于算法而言，语言并不重要，重要的是思想。</p></li></ul><p><strong>算法和数据结构区别</strong></p><ul><li><p>数据结构只是静态的描述了数据元素之间的关系</p></li><li><p>高效的程序需要在数据结构的基础上设计和选择算法</p></li></ul><p><strong>程序 = 数据结构 + 算法</strong></p><p>总结：</p><ul><li><p>算法是为了解决实际问题而设计的</p></li><li><p>数据结构是算法需要处理的问题载体</p></li><li><p>数据结构与算法相辅相成</p></li></ul><p><strong>算法特性</strong></p><p>输入</p><ul><li>算法具有0个或多个输入</li></ul><p>输出</p><ul><li>算法至少有1个或多个输出</li></ul><p>有穷性</p><ul><li>算法在有限的步骤之后会自动结束而不会无限循环</li></ul><p>确定性</p><ul><li>算法中的每一步都有确定的含义，不会出现二义性</li></ul><p>可行性</p><ul><li>算法的每一步都是可行的</li></ul><p><strong>算法效率的度量</strong></p><p>1、事后统计法</p><ul><li>比较不同算法对同一组输入数据的运行处理时间</li><li>缺陷    <ul><li>为了获得不同算法的运行时间必须编写相应程序</li><li>运行时间严重依赖硬件以及运行时的环境因素</li><li>算法的测试数据的选取相当困难</li></ul></li><li>事后统计法虽然直观，但是实施困难且缺陷多</li></ul><p>算法效率的度量</p><ul><li>事前分析估算</li><li>依据统计的方法对算法效率进行估算</li><li>影响算法效率的主要因素<ul><li>算法采用的策略和方法</li><li>问题的输入规模</li><li>编译器所产生的代码</li><li>计算机执行速度</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法最终编译成具体的计算机指令</span></span><br><span class="line"><span class="comment">//每一个指令，在具体的计算机上运行速度固定</span></span><br><span class="line"><span class="comment">//通过具体的n的步骤，就可以推导出算法的复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;                         </span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">array</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)   </span><br><span class="line">        <span class="built_in">array</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">        ret += <span class="built_in">array</span>[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>); </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">ret += i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>( n &gt; <span class="number">0</span> )</span><br><span class="line">        ret = (<span class="number">1</span> + n) * n / <span class="number">2</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum1(<span class="number">100</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum2(<span class="number">100</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum3(<span class="number">100</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;len; j++)&#123;</span><br><span class="line">            s += i*j;  <span class="comment">//n*n</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/数据结构-05.png"><p><strong>注意 1</strong>：判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略。</p><p><strong>注意 2</strong>：在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度。</p><p>2、大 O 表示法</p><ul><li><p>算法效率严重依赖于操作(Operation)数量</p></li><li><p>在判断时首先关注操作数量的最高次项</p></li><li><p>操作数量的估算可以作为时间复杂度的估算</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">5</span>) = O(<span class="number">1</span>)</span><br><span class="line">O(<span class="number">2</span>n + <span class="number">1</span>) = O(<span class="number">2</span>n) = O(n)  </span><br><span class="line">O(n2+ n + <span class="number">1</span>) = O(n2)</span><br><span class="line">O(<span class="number">3</span>n3+<span class="number">1</span>) = O(<span class="number">3</span>n3) = O(n3)</span><br></pre></td></tr></table></figure><p>常见时间复杂度</p><img src="/images/imageProgramC/数据结构-06.png"><p>关系</p><img src="/images/imageProgramC/数据结构-07.png"><p>3、算法的空间复杂度</p><p>算法的空间复杂度通过计算算法的存储空间实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S(n) = O(f(n))</span><br></pre></td></tr></table></figure><p>其中，<code>n</code> 为问题规模，<code>f(n)</code> 为在问题规模为 <code>n</code> 时所占用存储空间的函数</p><p>大 O 表示法同样适用于算法的空间复杂度</p><p><strong>当算法执行时所需要的空间是常数时，空间复杂度为O(1)</strong></p><p>空间与时间的策略：</p><ul><li><p>多数情况下，算法执行时所用的时间更令人关注</p></li><li><p>如果有必要，可以通过增加空间复杂度来降低时间复杂度</p></li><li><p>同理，也可以通过增加时间复杂度来降低空间复杂度</p></li></ul><p>练习1：分析 sum1 sum2 sum3 函数的空间复杂度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">4</span>n+<span class="number">12</span>)  O(<span class="number">8</span>)=O(<span class="number">1</span>)  O(<span class="number">4</span>)=O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>总结：实现算法时，需要分析具体问题，对执行时间和空间的要求。</p><p>练习2：时间换空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题： </span></span><br><span class="line"><span class="comment">    在一个由自然数 1-1000 中某些数字所组成的数组中，每个数字可能出现零次或者多次。</span></span><br><span class="line"><span class="comment">    设计一个算法，找出出现次数最多的数字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">方法<span class="number">1</span>：</span><br><span class="line">   排序，然后找出出现次数最多的数字</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sp[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = a[i] - <span class="number">1</span>;    </span><br><span class="line">        sp[index]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( max &lt; sp[i] )</span><br><span class="line">            max = sp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( max == sp[i] )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line">    search(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(*<span class="built_in">array</span>));   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把每个数字出现的次数的中间结果，缓存下来；在缓存的结果中求最大值。</p><img src="/images/imageProgramC/数据结构-08.png"><h2 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h2><h3 id="2-1-线性表基本概念"><a href="#2-1-线性表基本概念" class="headerlink" title="2.1 线性表基本概念"></a>2.1 线性表基本概念</h3><p><strong>线性表定义</strong></p><ul><li><p>线性表(List)是零个或多个数据元素的集合 </p></li><li><p>线性表中的数据元素之间是有顺序的</p></li><li><p>线性表中的数据元素个数是有限的</p></li><li><p>线性表中的数据元素的类型必须相同</p></li></ul><img src="/images/imageProgramC/数据结构-09.png"><p><strong>数学定义</strong></p><p>线性表是具有相同类型的 n（ ≥ 0）个数据元素的有限序列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（a1, a2, …, an）</span><br><span class="line">ai 是表项，n 是表长度。</span><br></pre></td></tr></table></figure><p><strong>性质</strong></p><ul><li><p>a0 为线性表的第一个元素，只有一个后继</p></li><li><p>an 为线性表的最后一个元素，只有一个前驱</p></li><li><p>除 a0 和 an 外的其它元素 ai，既有前驱，又有后继</p></li><li><p>线性表能够逐项访问和顺序存取</p></li></ul><p><strong>练习</strong></p><p>下面的关系中可以用线性表描述的是</p><ul><li><p>A.班级中同学的友谊关系 N:N</p></li><li><p>B.公司中的上下级关系  1:N</p></li><li><p>C.冬天图书馆排队占座关系 </p></li><li><p>D.花名册上名字之间的关系 1::1</p></li></ul><p><strong>线性表的操作</strong></p><ul><li><p>创建线性表</p></li><li><p>销毁线性表</p></li><li><p>清空线性表</p></li><li><p>将元素插入线性表</p></li><li><p>将元素从线性表中删除</p></li><li><p>获取线性表中某个位置的元素</p></li><li><p>获取线性表的长度</p></li></ul><blockquote><p>线性表在程序中表现为一种特殊的数据类型</p><p>线性表的操作在程序中的表现为一组函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C 语言描述=====》线性表的设计与实现</span></span><br><span class="line"><span class="comment">ADT 抽象层  《[数据结构(C语言版)].严蔚敏_吴伟民.扫描版.pdf》 p44页 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WBM_LIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WBM_LIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并且返回一个空的线性表</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//销毁一个线性表list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//将一个线性表list中的所有元素清空, 线性表回到创建时的初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//向一个线性表list的pos位置处插入新元素node</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;  </span><br><span class="line"><span class="comment">//获取一个线性表list的pos位置处的元素</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//删除一个线性表list的pos位置处的元素  返回值为被删除的元素，NULL表示删除失败</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意: */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;  (重点:分离思想)</span><br></pre></td></tr></table></figure><h3 id="2-2-线性表的顺序存储结构"><a href="#2-2-线性表的顺序存储结构" class="headerlink" title="2.2 线性表的顺序存储结构"></a>2.2 线性表的顺序存储结构</h3><p><strong>基本概念</strong></p><img src="/images/imageProgramC/数据结构-10.png"><p><strong>设计与实现</strong></p><p>插入元素算法</p><ul><li><p>判断线性表是否合法</p></li><li><p>判断插入位置是否合法</p></li><li><p>把最后一个元素到插入位置的元素后移一个位置</p></li><li><p>将新元素插入</p></li><li><p>线性表长度加 1</p></li></ul><p>获取元素操作</p><ul><li><p>判断线性表是否合法</p></li><li><p>判断位置是否合法</p></li><li><p>直接通过数组下标的方式获取元素</p></li></ul><p>删除元素算法</p><ul><li><p>判断线性表是否合法</p></li><li><p>判断删除位置是否合法</p></li><li><p>将元素取出</p></li><li><p>将删除位置后的元素分别向前移动一个位置</p></li><li><p>线性表长度减 1</p></li></ul><p>链表顺序存储插入算法和删除算法</p><img src="/images/imageProgramC/数据结构-11.png"><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><p>无需为线性表中的逻辑关系增加额外的空间</p></li><li><p>可以快速的获取表中合法位置的元素</p></li></ul><p>缺点：</p><ul><li><p>插入和删除操作需要移动大量元素</p></li><li><p>当线性表长度变化较大时难以确定存储空间的容量</p></li></ul><h3 id="2-3-线性表的链式存储"><a href="#2-3-线性表的链式存储" class="headerlink" title="2.3 线性表的链式存储"></a>2.3 线性表的链式存储</h3><p><strong>基本概念</strong></p><p>链式存储定义</p><ul><li>为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。</li></ul><img src="/images/imageProgramC/数据结构-12.png"><p>表头结点</p><ul><li>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息</li></ul><p>数据结点</p><ul><li>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息</li></ul><p>尾结点</p><ul><li>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li></ul><p><strong>链表技术领域推演</strong></p><img src="/images/imageProgramC/数据结构-13.png"><p><strong>设计与实现</strong></p><p>链表链式存储 <code>_api</code> 实现分析</p><p>在C语言中可以用结构体来定义链表中的指针域</p><p>链表中的表头结点也可以用结构体实现</p><img src="/images/imageProgramC/数据结构-14.png"><img src="/images/imageProgramC/数据结构-15.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> * LK;      <span class="comment">// 不希望看到内部数据是可以这么定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function">LK <span class="title">init_LinkList</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_LinkList</span><span class="params">(LK <span class="built_in">list</span>, <span class="keyword">int</span> position, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foreach_LinkList</span><span class="params">(LK <span class="built_in">list</span>, <span class="keyword">void</span>(*myforeach)(<span class="keyword">void</span> *))</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveByPos_LinkList</span><span class="params">(LK <span class="built_in">list</span>, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destroy_LinkList</span><span class="params">(LK <span class="built_in">list</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点、位置从0的单链表</span></span><br><span class="line"><span class="comment">// 返回链表中第3个位置处，元素的值</span></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Get</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>&#123; </span><br><span class="line"><span class="keyword">int</span>  i = <span class="number">0</span>;</span><br><span class="line">TLinkList *tList = (TLinkList *)<span class="built_in">list</span>;</span><br><span class="line">LinkListNode *current = <span class="literal">NULL</span>;</span><br><span class="line">LinkListNode *ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || pos &lt; <span class="number">0</span> || pos &gt;= tList-&gt;length)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">current = (LinkListNode *)tList;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">ret = current-&gt;next;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>返回第三个位置的,移动pos次以后，当前指针指向哪里？</p><p>答案：指向位置2，所以需要返回 <code>ret = current-&gt;next;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    备注：循环遍历时，</span></span><br><span class="line"><span class="comment">    遍历第1次，指向位置0</span></span><br><span class="line"><span class="comment">        遍历第2次，指向位置1</span></span><br><span class="line"><span class="comment">        遍历第3次，指向位置2</span></span><br><span class="line"><span class="comment">        遍历第n次，指向位置n-1;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以如果想返回位置 n 的元素的值，需要怎么做 <code>ret = current-&gt;next;</code></p><p>此问题是：*<em>指向头结点的指针移动 n 次 和 第 n 个元素之间的关系？ *</em></p><p>删除元素</p><img src="/images/imageProgramC/数据结构-16.png"><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><p>无需一次性定制链表的容量 </p></li><li><p>插入和删除操作无需移动数据元素</p></li></ul><p>缺点：</p><ul><li><p>数据元素必须保存后继元素的位置信息</p></li><li><p>获取指定数据的元素操作需要顺序访问之前的元素</p></li></ul><h3 id="2-4-循环链表"><a href="#2-4-循环链表" class="headerlink" title="2.4 循环链表"></a>2.4 循环链表</h3><p><strong>基本概念</strong></p><p>循环链表的定义：将单链表中最后一个数据元素的next指针指向第一个元素</p><img src="/images/imageProgramC/数据结构-17.png"><p>循环链表拥有单链表的所有操作</p><ul><li><p>创建链表</p></li><li><p>销毁链表</p></li><li><p>获取链表长度</p></li><li><p>清空链表</p></li><li><p>获取第pos个元素操作</p></li><li><p>插入元素到位置pos</p></li><li><p>删除位置pos处的元素</p></li></ul><p>新增功能：<strong>游标</strong> 的定义</p><p>在循环链表中可以定义一个“当前”指针，这个指针通常称为 <strong>游标</strong>，可以通过这个游标来遍历链表中的所有元素。</p><img src="/images/imageProgramC/数据结构-18.png"><p>循环链表新操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将游标重置指向链表中的第一个数据元素</span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_Reset</span><span class="params">(CircleList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前游标指向的数据元素</span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_Current</span><span class="params">(CircleList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将游标移动指向到链表中的下一个数据元素</span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_Next</span><span class="params">(CircleList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接指定删除链表中的某个数据元素 </span></span><br><span class="line"><span class="function">CircleListNode* <span class="title">CircleList_DeleteNode</span><span class="params">(CircleList* <span class="built_in">list</span>, CircleListNode* node)</span></span>;  </span><br><span class="line"><span class="comment">// 根据元素的 值 删除, 元素 pk 根据元素的 位置 删除元素</span></span><br></pre></td></tr></table></figure><p><strong>循环链表的应用</strong></p><p><strong>证明循环链表</strong></p><ul><li>打印两次。</li></ul><p><strong>约瑟夫问题求解</strong></p><blockquote><p>约瑟夫问题 - 循环链表典型应用</p><p>n 个人围成一个圆圈，首先第 1 个人从 1 开始一个人一个人顺时针报数，报到第 m 个人，令其出列。然后再从下一 个人开始从 1 顺时针报数，报到第 m 个人，再令其出列，…，如此下去，求出列顺序。</p></blockquote><img src="/images/imageProgramC/数据结构-19.png"><p><strong>设计与实现</strong></p><p><strong>循环链表插入元素的分析</strong> </p><p>1） 普通插入元素（和单链表是一样的）</p><p>2） 尾插法（和单链表是一样的，单链表的写法支持尾插法；因：辅助指针向后跳length次，指向最后面那个元素）</p><img src="/images/imageProgramC/数据结构-20.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList_Insert</span><span class="params">(<span class="built_in">list</span>, (CircleListNode*)&amp;v1, CircleList_Length(<span class="built_in">list</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>3） 头插法（要进行头插法，需要求出尾结点，和单链表不一样的地方，保证是循环链表）第一次插入元素时，让游标指向 0 号结点</p><img src="/images/imageProgramC/数据结构-21.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList_Insert</span><span class="params">(<span class="built_in">list</span>, (CircleListNode*)&amp;v1, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>4）第一次插入元素</p><img src="/images/imageProgramC/数据结构-22.png"><p><strong>循环链表插入综合场景分析图</strong></p><img src="/images/imageProgramC/数据结构-23.png"><p><strong>循环链表删除结点分析</strong></p><p>1、 删除普通结点</p><p>2、 删除头结点（删除 0 号位置处元素），需要求出尾结点</p><img src="/images/imageProgramC/数据结构-24.png"><p><strong>优点和缺点</strong></p><p>优点：功能强了。</p><ul><li><p>循环链表只是在单链表的基础上做了一个加强</p></li><li><p>循环链表可以完全取代单链表的使用</p></li><li><p>循环链表的 Next 和 Current 操作可以高效的遍历链表中的所有元素</p></li></ul><p>缺点：</p><ul><li>代码复杂度提高了</li></ul><h3 id="2-5-双向链表"><a href="#2-5-双向链表" class="headerlink" title="2.5 双向链表"></a>2.5 双向链表</h3><p><strong>基本概念</strong> </p><p>请思考： 为什么 <strong>需要</strong> 双向链表？</p><ul><li><p>单链表的结点都只有一个指向下一个结点的指针</p></li><li><p>单链表的数据元素无法直接访问其前驱元素</p></li><li><p><strong>逆序访问单链表</strong> 中的元素是极其 <strong>耗时</strong> 的操作！</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">len = LinkList_Length(<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">for</span> (i=len<span class="number">-1</span>; len&gt;=<span class="number">0</span>; i++) <span class="comment">//O(n)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode *p = LinkList_Get(<span class="built_in">list</span>, i); <span class="comment">//O(n)</span></span><br><span class="line">    <span class="comment">//访问数据元素p中的元素</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向链表的定义</strong></p><p>在单链表的结点中增加一个指向其前驱的 pre 指针</p><img src="/images/imageProgramC/数据结构-25.png"><p>双向链表拥有单链表的所有操作</p><ul><li><p>创建链表</p></li><li><p>销毁链表</p></li><li><p>获取链表长度</p></li><li><p>清空链表</p></li><li><p>获取第 pos 个元素操作</p></li><li><p>插入元素到位置 pos</p></li><li><p>删除位置 pos 处的元素</p></li></ul><p><strong>设计与实现</strong></p><p>循环链表一般操作</p><blockquote><p> 插入操作</p></blockquote><img src="/images/imageProgramC/数据结构-26.png"><p>插入操作异常处理</p><ul><li><p>插入第一个元素异常处理</p></li><li><p>在 0 号位置处插入元素；</p></li></ul><blockquote><p>删除操作</p></blockquote><img src="/images/imageProgramC/数据结构-27.png"><p>删除操作异常处理</p><p>双向链表的新操作</p><ul><li><p>获取当前游标指向的数据元素</p></li><li><p>将游标重置指向链表中的第一个数据元素</p></li><li><p>将游标移动指向到链表中的下一个数据元素</p></li><li><p>将游标移动指向到链表中的上一个数据元素</p></li><li><p>直接指定删除链表中的某个数据元素</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_DeleteNode</span><span class="params">(DLinkList* <span class="built_in">list</span>, DLinkListNode* node)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Reset</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Current</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Next</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">DLinkListNode* <span class="title">DLinkList_Pre</span><span class="params">(DLinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//大家一定要注意：教科书不会告诉你 项目上如何用；哪些点是项目的重点；做一个企业级的财富库，完成你人生开发经验的积累，是我们的学习重点，要注意！</span></span><br></pre></td></tr></table></figure><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><p>双向链表在单链表的基础上增加了指向前驱的指针</p></li><li><p>功能上双向链表可以完全取代单链表的使用</p></li><li><p>双向链表的 Next，Pre 和 Current 操作可以高效的遍历链表中的所有元素</p></li></ul><p>缺点：</p><ul><li>代码复杂</li></ul><h2 id="三、栈-stack-和队列-queue"><a href="#三、栈-stack-和队列-queue" class="headerlink" title="三、栈 stack 和队列 queue"></a>三、栈 stack 和队列 queue</h2><h3 id="3-1栈-stack"><a href="#3-1栈-stack" class="headerlink" title="3.1栈 stack"></a>3.1栈 stack</h3><p><strong>Stack基本概念</strong></p><ul><li><p>栈是一种  特殊的线性表  </p></li><li><p>栈仅能在线性表的一端进行操作</p><ul><li>栈顶(Top)：允许操作的一端</li><li>栈底(Bottom)：不允许操作的一端</li></ul></li></ul><img src="/images/imageProgramC/数据结构-28.png"><p><strong>Stack的常用操作</strong></p><ul><li><p>创建栈</p></li><li><p>销毁栈</p></li><li><p>清空栈</p></li><li><p>进栈</p></li><li><p>出栈</p></li><li><p>获取栈顶元素</p></li><li><p>获取栈的大小 </p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack* <span class="title">Stack_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack_Destroy</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack_Clear</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack_Push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Stack_Pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Stack_Top</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack_Size</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_STACK_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>栈模型和链表模型关系分析</strong></p><img src="/images/imageProgramC/数据结构-29.png"><p><strong>栈的顺序存储设计与实现</strong></p><img src="/images/imageProgramC/数据结构-30.png"><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  __MY_SEQLIST_H__ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MY_SEQLIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqListNode;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqStack_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SeqStack _Destroy(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SeqStack _Clear(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SeqStack _Length(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SeqStack _Capacity(SeqStack * <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SeqStack _Insert(SeqStack * <span class="built_in">list</span>, SeqListNode* node, <span class="keyword">int</span> pos);</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Get</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Delete</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//__MY_SEQLIST_H__</span></span></span><br></pre></td></tr></table></figure><p><strong>栈的链式存储设计与实现</strong></p><img src="/images/imageProgramC/数据结构-31.png"><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_LINKSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_LINKSTACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack* <span class="title">LinkStack_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack_Destroy</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack_Clear</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack_Push</span><span class="params">(LinkStack* <span class="built_in">stack</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkStack_Pop</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkStack_Top</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack_Size</span><span class="params">(LinkStack* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_LINKSTACK_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>栈的应用</strong></p><p><strong>案例1：就近匹配</strong></p><blockquote><p>应用1：就近匹配 </p><p>几乎所有的编译器都具有检测括号是否匹配的能力</p><p>如何实现编译器中的符号成对检测？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>]; </span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">4</span>]; </span><br><span class="line">    p = a[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>算法思路</p><ul><li><p>从第一个字符开始扫描</p></li><li><p>当遇见普通字符时忽略，</p></li><li><p>当遇见左符号时压入栈中</p></li><li><p>当遇见右符号时从栈中弹出栈顶符号，并进行匹配</p><ul><li>匹配成功：继续读入下一个字符</li><li>匹配失败：立即停止，并报错</li></ul></li><li><p>结束：</p><ul><li>成功: 所有字符扫描完毕，且栈为空</li><li>失败：匹配失败或所有字符扫描完毕但栈非空</li></ul></li></ul></blockquote><p>当需要检测成对出现但又互不相邻的事物时，可以使用栈 “后进先出” 的特性，栈非常适合于需要“就近匹配”的场合</p><p><strong>案例2：中缀表达式和后缀表达式</strong></p><blockquote><p>应用2：中缀 后缀</p></blockquote><blockquote><p>计算机的本质工作就是做数学运算，那计算机可以读入字符串</p><p>“9 + (3 - 1) * 5 + 8 / 2”并计算值吗？</p></blockquote><blockquote><p>后缀表达式  ==？符合计算机运算</p><p>波兰科学家在20世纪50年代提出了一种将运算符放在数字后面的后缀表达式对应的，</p><p>我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例：</span></span><br><span class="line"><span class="number">5</span> + <span class="number">4</span>=&gt; <span class="number">5</span> <span class="number">4</span> +  </span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> * <span class="number">3</span> =&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> * +  </span><br><span class="line"><span class="number">8</span> + ( <span class="number">3</span> – <span class="number">1</span> ) * <span class="number">5</span> =&gt; <span class="number">8</span> <span class="number">3</span> <span class="number">1</span> – <span class="number">5</span> * +</span><br></pre></td></tr></table></figure><blockquote><p>中缀表达式符合人类的阅读和思维习惯</p><p>后缀表达式符合计算机的“运算习惯”</p><p>如何将中缀表达式转换成后缀表达式？</p></blockquote><blockquote><p>中缀转后缀算法：</p><ul><li><p>遍历中缀表达式中的数字和符号</p></li><li><p>对于数字：直接输出</p></li><li><p>对于符号：</p><ul><li>左括号：进栈  </li><li>运算符号：与栈顶符号进行优先级比较<ul><li>若栈顶符号优先级低：此符合进栈  （默认栈顶若是左括号，左括号优先级最低）</li><li>若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈</li></ul></li></ul></li><li><p>右括号：将栈顶符号弹出并输出，直到匹配左括号</p></li><li><p>遍历结束：将栈中的所有符号弹出并输出</p></li><li><p>中缀转后缀</p></li></ul></blockquote><img src="/images/imageProgramC/数据结构-32.png"><blockquote><p>计算机是如何基于后缀表达式计算的？</p><p>8 3 1 – 5 * + </p></blockquote><blockquote><p>遍历后缀表达式中的数字和符号</p><p>对于数字：进栈</p><p>对于符号：</p><ul><li><p>从栈中弹出右操作数</p></li><li><p>从栈中弹出左操作数</p></li><li><p>根据符号进行运算</p></li><li><p>将运算结果压入栈中</p></li></ul><p>遍历结束：栈中的唯一数字为计算结果</p></blockquote><img src="/images/imageProgramC/数据结构-33.png"><blockquote><p>栈的神奇！    </p><p>中缀表达式是人习惯的表达方式</p><p>后缀表达式是计算机喜欢的表达方式</p><p>通过栈可以方便的将中缀形式变换为后缀形式</p><p>中缀表达式的计算过程类似程序编译运行的过程  </p></blockquote><blockquote><p>扩展：给你一个字符串，计算结果</p><p>“1 + 2 * (66 / (2 * 3) + 7 )”   </p><ul><li><p>字符串解析</p></li><li><p>词法语法分析</p></li><li><p>优先级分析     </p></li><li><p>数据结构选型===》栈还是树？</p></li></ul></blockquote><h3 id="3-2-队列queue"><a href="#3-2-队列queue" class="headerlink" title="3.2 队列queue"></a>3.2 <strong>队列queue</strong></h3><p><strong>queue基本概念</strong></p><ul><li><p>队列是一种特殊的线性表  </p></li><li><p>队列仅在线性表的两端进行操作</p></li><li><p>队头(Front)：取出数据元素的一端</p></li><li><p>队尾(Rear)：插入数据元素的一端</p></li><li><p>队列不允许在中间部位进行操作！</p></li></ul><img src="/images/imageProgramC/数据结构-34.png"><p><strong>queue常用操作</strong></p><ul><li><p>销毁队列</p></li><li><p>清空队列</p></li><li><p>进队列</p></li><li><p>出队列</p></li><li><p>获取队头元素</p></li><li><p>获取队列的长度</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue* <span class="title">Queue_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Destroy</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Clear</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Append</span><span class="params">(Queue* <span class="built_in">queue</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Queue_Retrieve</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Queue_Header</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Length</span><span class="params">(Queue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_QUEUE_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>队列模型和链表模型关系分析</strong></p><img src="/images/imageProgramC/数据结构-35.png"><p><strong>队列的顺序存储设计与实现</strong></p><p>队列也是一种特殊的线性表；可以用线性表顺序存储来模拟队列。</p><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_SEQQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_SEQQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqQueue* <span class="title">SeqQueue_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue_Destroy</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue_Clear</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue_Append</span><span class="params">(SeqQueue* <span class="built_in">queue</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">SeqQueue_Retrieve</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">SeqQueue_Header</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue_Length</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue_Capacity</span><span class="params">(SeqQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_SEQQUEUE_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>队列的链式存储设计与实现</strong></p><p>队列也是一种特殊的线性表；可以用线性表链式存储来模拟队列的链式存储。</p><p><strong>设计与实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_LINKQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_LINKQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkQueue* <span class="title">LinkQueue_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue_Destroy</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue_Clear</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue_Append</span><span class="params">(LinkQueue* <span class="built_in">queue</span>, <span class="keyword">void</span>* item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkQueue_Retrieve</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkQueue_Header</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue_Length</span><span class="params">(LinkQueue* <span class="built_in">queue</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_LINKQUEUE_H_</span></span></span><br></pre></td></tr></table></figure><h2 id="四、树专题"><a href="#四、树专题" class="headerlink" title="四、树专题"></a>四、树专题</h2><p><strong>树基本概念</strong></p><p>非线性结构，一个直接前驱，但可能有多个直接后继（1:n）</p><img src="/images/imageProgramC/数据结构-79.png"><img src="/images/imageProgramC/数据结构-78.png"><p><strong>树的表示法</strong></p><ul><li><p>图形表示法</p></li><li><p>广义表表示法</p></li><li><p>左孩子－右兄弟表示法</p></li><li><p>双亲孩子表示法</p></li></ul><p><strong>树的逻辑结构</strong></p><ul><li><p>一对多（1:n），有多个直接后继（如家谱树、目录树等等），但只有一个根结点，且子树之间互不相交。</p></li><li><p>广义表表示法</p></li><li><p>左孩子－右兄弟表示法</p></li></ul><h3 id="4-1-二叉树概念"><a href="#4-1-二叉树概念" class="headerlink" title="4.1 二叉树概念"></a>4.1 二叉树概念</h3><img src="/images/imageProgramC/数据结构-80.png"><img src="/images/imageProgramC/数据结构-81.png"><img src="/images/imageProgramC/数据结构-82.png"><img src="/images/imageProgramC/数据结构-83.png"><img src="/images/imageProgramC/数据结构-84.png"><img src="/images/imageProgramC/数据结构-85.png"><img src="/images/imageProgramC/数据结构-86.png"><img src="/images/imageProgramC/数据结构-87.png"><img src="/images/imageProgramC/数据结构-38.png"><p>先序遍历（DLR）：先访问根、再访问左、再访问右</p><p>中序遍历（LDR）：先访问左、再访问根、再访问右</p><p>后序遍历（LRD）：先访问左、再访问右、再访问根</p><img src="/images/imageProgramC/数据结构-88.png"><img src="/images/imageProgramC/数据结构-89.png"><p>二叉树的结构最简单，规律性最强。可以证明，所有树都能转为唯一对应的二叉树，不失一般性</p><p>定义：是 n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成</p><p>二叉树性质</p><blockquote><p>性质1: 在二叉树的第 <code>i</code> 层上至多有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PTJee2ktMX0=" title="https://www.codecogs.com/eqnedit.php?latex=2^{i-1}"><img src="https://latex.codecogs.com/gif.latex?2^{i-1}" title="2^{i-1}"><i class="fa fa-external-link"></i></span> 个结点（<code>i&gt;0</code>）</p></blockquote><blockquote><p>性质2: 深度为 <code>k</code> 的二叉树至多有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PTJeayZzcGFjZTstMQ==" title="https://www.codecogs.com/eqnedit.php?latex=2^k&space;-1"><img src="https://latex.codecogs.com/gif.latex?2^k&space;-1" title="2^k -1"><i class="fa fa-external-link"></i></span> 个结点（<code>k&gt;0</code>）</p></blockquote><blockquote><p>性质3: 对于任何一棵二叉树，若 2 度的结点数有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMg==" title="https://www.codecogs.com/eqnedit.php?latex=n_2"><img src="https://latex.codecogs.com/gif.latex?n_2" title="n_2"><i class="fa fa-external-link"></i></span> 个，则叶子数（<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMA==" title="https://www.codecogs.com/eqnedit.php?latex=n_0"><img src="https://latex.codecogs.com/gif.latex?n_0" title="n_0"><i class="fa fa-external-link"></i></span>）必定为 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMiZzcGFjZTsmcGx1czsmc3BhY2U7MQ==" title="https://www.codecogs.com/eqnedit.php?latex=n_2&space;&plus;&space;1"><img src="https://latex.codecogs.com/gif.latex?n_2&space;&plus;&space;1" title="n_2 + 1"><i class="fa fa-external-link"></i></span> （即<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PW5fMCZzcGFjZTs9JnNwYWNlO25fMiZzcGFjZTsmcGx1czsmc3BhY2U7MQ==" title="https://www.codecogs.com/eqnedit.php?latex=n_0&space;=&space;n_2&space;&plus;&space;1"><img src="https://latex.codecogs.com/gif.latex?n_0&space;=&space;n_2&space;&plus;&space;1" title="n_0 = n_2 + 1"><i class="fa fa-external-link"></i></span>）</p></blockquote><p>满二叉树：一棵深度为 <code>k</code> 且有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PTJeayZzcGFjZTstJnNwYWNlOzE=" title="https://www.codecogs.com/eqnedit.php?latex=2^k&space;-&space;1"><img src="https://latex.codecogs.com/gif.latex?2^k&space;-&space;1" title="2^k - 1"><i class="fa fa-external-link"></i></span> 个结点的二叉树。（特点：每层都“充满”了结点）</p><p>完全二叉树：深度为 <code>k</code> 的，有 <code>n</code> 个结点的二叉树，当且仅当其每一个结点都与深度为 <code>k</code> 的满二叉树中编号从 1 至 <code>n</code> 的结点一一对应。</p><p>理解：（<code>k-1</code> 层与满二叉树完全相同，第 <code>k</code> 层结点尽力靠左）</p> <img src="/images/imageProgramC/数据结构-36.png"><blockquote><p>性质4: 具有 <code>n</code> 个结点的完全二叉树的深度必为 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PXxcbG9nXzJufCZzcGFjZTsmcGx1czsmc3BhY2U7MQ==" title="https://www.codecogs.com/eqnedit.php?latex=|\log_2n|&space;&plus;&space;1"><img src="https://latex.codecogs.com/gif.latex?|\log_2n|&space;&plus;&space;1" title="|\log_2n| + 1"><i class="fa fa-external-link"></i></span></p></blockquote><blockquote><p>性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为 <code>i</code> 的结点，其左孩子编号必为 <code>2i</code>，其右孩子编号必为 <code>2i + 1</code>；其双亲的编号必为 <code>i/2</code>（<code>i=1</code> 时为根,除外）</p></blockquote><p><strong>二叉树的存储结构</strong></p><ul><li><p>1、顺序存储结构</p><p>按二叉树的结点“自上而下、从左至右”编号，用一组连续的存储单元存储。</p><p>答：一律转为完全二叉树！</p><p>讨论：不是完全二叉树怎么办？</p><p>方法很简单，将各层空缺处统统补上“虚结点”，其内容为空</p></li><li><p>2、链式存储结构</p></li></ul><p><strong>二叉树的表示</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct BiTNode</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">intdata;</span></span><br><span class="line"><span class="comment"> struct BiTNode *lchild, *rchild;</span></span><br><span class="line"><span class="comment">&#125;BiTNode, *BiTree;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> <span class="title">BiTNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> * <span class="title">BiTree</span>;</span></span><br></pre></td></tr></table></figure><p><strong>树的三叉链表表示</strong></p><img src="/images/imageProgramC/数据结构-37.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="comment">//左右孩子指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">&#125;TriTNode, *TriTree;</span><br><span class="line"></span><br><span class="line">双亲链表法</span><br><span class="line"><span class="comment">//双亲链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> parentPosition; <span class="comment">//指向双亲的指针 //数组下标</span></span><br><span class="line"><span class="keyword">char</span> LRTag; <span class="comment">//左右孩子标志域</span></span><br><span class="line">&#125;BPTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BPTNode nodes[<span class="number">100</span>]; <span class="comment">//因为节点之间是分散的，需要把节点存储到数组中</span></span><br><span class="line"><span class="keyword">int</span> num_node;  <span class="comment">//节点数目</span></span><br><span class="line"><span class="keyword">int</span> root; <span class="comment">//根结点的位置 //注意此域存储的是父亲节点在数组的下标</span></span><br><span class="line">&#125;BPTree;</span><br><span class="line"><span class="comment">//用这个数据结构能表达出一颗树，为什么？</span></span><br></pre></td></tr></table></figure><p><strong>二叉树的遍历</strong></p><img src="/images/imageProgramC/数据结构-38.png"><p>树的遍历本质剖析</p><img src="/images/imageProgramC/数据结构-39.png"><h3 id="4-2-二叉树编程实践"><a href="#4-2-二叉树编程实践" class="headerlink" title="4.2 二叉树编程实践"></a>4.2 二叉树编程实践</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span>  data; </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>；</span></span><br><span class="line"><span class="class">&#125; <span class="title">NODE</span>;</span></span><br><span class="line">NODE *root;</span><br></pre></td></tr></table></figure><p><strong>先序遍历算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DLR(NODE *root )</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (root) <span class="comment">//非空二叉树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“%d”,root-&gt;data); <span class="comment">//访问D</span></span><br><span class="line">        DLR(root-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">        DLR(root-&gt;rchild); <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LDR(NODE *root)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(root !=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        LDR(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(“%d”,root-&gt;data);</span><br><span class="line">        LDR(root-&gt;rchild); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LRD (NODE *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root !=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        LRD(root-&gt;lchild);</span><br><span class="line">        LRD(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(“%d”,root-&gt;data); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例1：计算二叉树中叶子结点的数目</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//全局变量</span></span><br><span class="line">DLR_CountLeafNum(NODE *root)<span class="comment">//采用中序遍历的递归算法</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> ( root)  <span class="comment">//非空二叉树条件，还可写成if(root !=NULL )</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;lchild&amp;&amp;!root-&gt;rchild)  <span class="comment">//是叶子结点则统计并打印</span></span><br><span class="line">        &#123;   </span><br><span class="line">            sum++;     </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);  </span><br><span class="line">        &#125;</span><br><span class="line">        DLR_CountLeafNum(root-&gt;lchild); <span class="comment">//递归遍历左子树，直到叶子处；</span></span><br><span class="line">        DLR_CountLeafNum(root-&gt;rchild);&#125;<span class="comment">//递归遍历右子树，直到叶子处；</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思想：    1）求根结点左子树的叶子结点个数，累计到sum中，求根结点右子树的叶子结点个数累计到sum中。<br>​        2）若左子树还是树，重复步骤1；若右子树还是树，重复步骤1。<br>​        3）全局变量转成函数参数<br>​        4）按照先序、中序、后序方式计算叶子结点，<br>===》三种遍历的本质思想强化：访问结点的路径都是一样的，计算结点的时机不同。</p></blockquote><p><strong>案例2：求二叉树的深度</strong></p><blockquote><p>思想：    1）求根结点左子树高度，根结点右子树高度，比较的子树最大高度，再 +1。</p><p>​        2）若左子树还是树，重复步骤 1；若右子树还是树，重复步骤 1。</p></blockquote><p><strong>案例3：完全Copy二叉树</strong></p><blockquote><p>思想：    1）malloc新结点，</p><p>​        2）拷贝左子树，拷贝右子树，让新结点连接左子树，右子树</p><p>​        3）若左子树还是树，重复步骤1、2；若右子树还是树，重复步骤1、2。</p></blockquote><p><strong>案例4：树的非递归遍历(中序遍历)</strong></p><blockquote><p>中序 遍历的几种情况</p><p>分析1：</p><ul><li>什么时候访问根、什么时候访问左子树、什么访问右子树</li><li>当左子树为空或者左子树已经访问完毕以后，再访问根</li><li>访问完毕根以后，再访问右子树。</li></ul><p>分析2：</p><ul><li>非递归遍历树，访问结点时，为什么是栈，而不是其他模型（比如说是队列）。</li><li>先走到的后访问、后走到的先访问，显然是栈结构</li></ul><p>分析3：结点所有路径情况</p><ul><li><p>步骤1：</p><ul><li>如果结点有左子树，该结点入栈；</li><li>如果结点没有左子树，访问该结点；</li></ul></li><li><p>步骤2：</p><ul><li>如果结点有右子树，重复步骤1；</li><li>如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1</li><li>如果栈为空，表示遍历结束。 </li></ul></li></ul><p>注意：入栈的结点表示，本身没有被访问过，同时右子树也没有被访问过。</p><p>分析4：有一个一直往左走入栈的操作，中序遍历的起点</p></blockquote><img src="/images/imageProgramC/数据结构-40.png"><img src="/images/imageProgramC/数据结构-41.png"><p>作业：自己编写堆栈函数原型，实现中序遍历非递归算法</p><h3 id="4-3-二叉树的创建"><a href="#4-3-二叉树的创建" class="headerlink" title="4.3 二叉树的创建"></a>4.3 <strong>二叉树的创建</strong></h3><p><strong>中序和先序创建树</strong></p><p>1、根据中序遍历的结果能确定一棵树吗？</p><p>中序遍历：结果为：“12345”，这个“12345”能确定一棵树吗？</p><p>请思考，会有多少种形状。</p><p>2、如何才能确定一棵树？</p><blockquote><p>结论：    通过中序遍历和先序遍历可以确定一个树</p><p>​        通过中序遍历和后续遍历可以确定一个树</p><p>​        通过先序遍历和后序遍历确定不了一个树。</p></blockquote><p>单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。</p><p>3、根据先序和中序结果画树</p><blockquote><p>算法</p><p>1、通过先序遍历找到根结点A，再通过A在中序遍历的位置找出左子树，右子树</p><p>2、在A的左子树中，找左子树的根结点（在先序中找），转步骤1</p><p>3、在A的右子树中，找右子树的根结点（在先序中找），转步骤1</p></blockquote><blockquote><p>讲解：</p><p>先序遍历结果：ADEBCF</p><p>中序遍历结果：DEACFB</p></blockquote><blockquote><p>练习：</p><p>先序遍历结果：ABDHKECFIGJ</p><p>中序遍历结果：HKDBEAIFCGJ</p></blockquote><p>4、学习算法可借助工具、动画</p><p><strong>#号法创建树</strong></p><p>1、什么是 <code>#</code> 号法创建树</p><p><code>#</code> 创建树，让树的每一个节点都变成度数为2的树</p><img src="/images/imageProgramC/数据结构-42.png"><p>先序遍历：<code>124###3##</code> 可以唯一确定一棵树吗，为什么？</p><img src="/images/imageProgramC/数据结构-43.png"><p>2、<code>#</code> 创建树练习</p><p>先序遍历：<code>ABDH#K###E##CFI###G#J##</code> ,请画出树的形状</p><p><code>#</code> 号法画出树关键点：</p><p>要清楚的确定<strong>左子树什么结束</strong>，<strong>右子树什么时候开始</strong>。</p><p>3、<code>#</code> 号法编程实践</p><p>利用前序遍历来建树（结点值陆续从键盘输入，用 DLR 为宜）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bintree <span class="title">createBTpre</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    Bintree T; </span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(“%c”,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch==’#’) </span><br><span class="line">        T=<span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        T=( Bintree )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTNode));</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        T-&gt;lchild=createBTpre(); </span><br><span class="line">        T-&gt;rchild=createBTpre();</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历销毁一个树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BiTree_Free</span><span class="params">(BiTNode* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode *tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (T!= <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T-&gt;rchild != <span class="literal">NULL</span>) BiTree_Free(T-&gt;rchild);</span><br><span class="line"><span class="keyword">if</span> (T-&gt;lchild != <span class="literal">NULL</span>) BiTree_Free(T-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(T); </span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-二叉线索树"><a href="#4-4-二叉线索树" class="headerlink" title="4.4 二叉线索树"></a>4.4 <strong>二叉线索树</strong></h3><p><strong>线索化概念</strong></p><p>1、前言</p><p>普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得。</p><p>若可将遍历后对应的有关前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树了。</p><p>二叉线索树思想是干什么的？</p><img src="/images/imageProgramC/数据结构-44.png"><p>中序遍历这棵树===》转换成链表访问</p><p>2、线索化思想</p><img src="/images/imageProgramC/数据结构-45.png"><img src="/images/imageProgramC/数据结构-46.png"><img src="/images/imageProgramC/数据结构-47.png"><blockquote><p>结论：    线索化过程就是在遍历过程（假设是中序遍历）中修改空指针的过程：</p><p>​        将空的lchild改为结点的直接前驱；</p><p>​        将空的rchild改为结点的直接后继。</p></blockquote><p>3、线索化思想训练</p><img src="/images/imageProgramC/数据结构-48.png"><p>请将此树线索化。</p><p>1）右空指针线索化：</p><img src="/images/imageProgramC/数据结构-49.png"><p>2）左空指针线索化</p><img src="/images/imageProgramC/数据结构-50.png"><p>3）总结</p><img src="/images/imageProgramC/数据结构-51.png"><p><strong>线索化的实现</strong></p><p>1）线索化树结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>/* 二叉线索存储结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>data;<span class="comment">/* 结点数据 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">/* 左右孩子指针 */</span></span><br><span class="line"><span class="keyword">int</span>LTag;</span><br><span class="line"><span class="keyword">int</span>RTag;<span class="comment">/* 左右标志 */</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><p>2）线索化思想分析</p><img src="/images/imageProgramC/数据结构-52.png"><p>线索化的本质：让前后结点，建立关系；</p><p>1）两个辅助指针变量形成差值后：后继结点的左孩子指向前驱结点，前驱结点的右孩子指向后继结点。</p><p>2）赋值指针变量和业务操作的逻辑关系</p><img src="/images/imageProgramC/数据结构-53.png"><img src="/images/imageProgramC/数据结构-54.png"><p>4） 二叉树线索化树的遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 中序遍历二叉线索树T(头结点)的非递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrNode* T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">BiThrNode* p;</span><br><span class="line">p = T-&gt;lchild; <span class="comment">/* p指向根结点 */</span></span><br><span class="line"><span class="keyword">while</span> (p != T)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">/* 空树或遍历结束时,p==T */</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;LTag == Link)</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-霍夫曼树"><a href="#4-5-霍夫曼树" class="headerlink" title="4.5 霍夫曼树"></a>4.5 <strong>霍夫曼树</strong></h3><p>组建一个网络，耗费最小 WPL最小；这个方法是霍夫曼想出来的，称为霍夫曼树</p><img src="/images/imageProgramC/数据结构-55.png"><p><strong>霍夫曼树的构造</strong></p><p>对于文本 ”BADCADFEED” 的传输而言，因为重复出现的只有 ”ABCDEF” 这6个字符，因此可以用下面的方式编码：</p><img src="/images/imageProgramC/数据结构-56.png"><p>接收方可以根据每3个bit进行一次字符解码的方式还原文本信息。</p><p>这样的编码方式需要30个bit位才能表示10个字符</p><p>那么当传输一篇500个字符的情报时，需要15000个bit位</p><p>在战争年代，这种编码方式对于情报的发送和接受是很低效且容易出错的。</p><p>如何提高收发效率？</p><p>要提高效率，必然要从编码方式的改进入手，要避免每个字符都占用相同的bit位</p><img src="/images/imageProgramC/数据结构-57.png"><p>准则：任一字符的<strong>编码</strong>都不是另一个字符编码的前缀！</p><p>也就是说：每一个字符的编码路径，都不包含另外一个字符的路径。</p><blockquote><p>霍夫曼树</p><p>1、给定 n 个数值 { v1, v2, …, vn}</p><p>2、根据这 n 个数值构造二叉树集合 F</p><p>F = { T1, T2, …, Tn}</p><p>Ti 的数据域为 vi，左右子树为空</p><p>3、在 F 中选取两棵根结点的值最小的树作为左右子树构造一棵新的二叉树，这棵二叉树的根结点中的值为左右子树根结点中的值之和</p><p>4、在 F 中删除这两棵子树，并将构造的新二叉树加入F中</p><p>5、重复 3 和 4，直到 F 中只剩下一个树为止。这棵树即霍夫曼树</p></blockquote><p>假设经过统计 ABCDEF 在需要传输的报文中出现的概率如下</p><img src="/images/imageProgramC/数据结构-58.png"><img src="/images/imageProgramC/数据结构-59.png"><p>霍夫曼树是一种特殊的二叉树           </p><p>霍夫曼树应用于信息编码和数据压缩领域 </p><p>霍夫曼树是现代压缩算法的基础 </p><h2 id="五、-排序"><a href="#五、-排序" class="headerlink" title="五、 排序"></a>五、 排序</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。</p><p>排序数学定义：</p><ul><li>假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：Kp1≤Kp2≤…≤Kpn 。按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序 </li></ul><p>排序的稳定性：</p><ul><li>如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的；否则称这个排序方法是不稳定的。</li></ul><p>多关键字排序：</p><ul><li><p>排序时需要比较的关键字多余一个</p></li><li><p>排序结果首先按关键字1进行排序</p></li><li><p>当关键字1相同时按关键字2进行排序</p></li><li><p>当关键字n-1相同时按关键字n进行排序</p></li><li><p>对于多关键字排序，只需要在比较操作时同时考虑多个关键字即可！</p></li></ul><p>排序中的关键操作：</p><ul><li><p>比较</p><ul><li>任意两个数据元素通过比较操作确定先后次序</li></ul></li><li><p>交换</p><ul><li>数据元素之间需要交换才能得到预期结果</li></ul></li></ul><p>内排序和外排序：</p><ul><li><p>内排序</p><ul><li>整个排序过程不需要访问外存便能完成  </li></ul></li><li><p>外排序</p><ul><li>待排序的数据元素数量很大，整个序列的排序过程不可能在内存中完成</li></ul></li></ul><p>排序的审判：</p><ul><li><p>时间性能</p><ul><li>关键性能差异体现在比较和交换的数量  </li></ul></li><li><p>辅助存储空间</p><ul><li>为完成排序操作需要的额外的存储空间  </li><li>必要时可以“空间换时间”</li></ul></li><li><p>算法的实现复杂性</p><ul><li>过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能</li></ul></li></ul><p>总结：</p><ul><li><p>排序是数据元素从无序到有序的过程</p></li><li><p>排序具有稳定性，是选择排序算法的因素之一</p></li><li><p>比较和交换是排序的基本操作</p></li><li><p>多关键字排序与单关键字排序无本质区别</p></li><li><p>排序的时间性能是区分排序算法好坏的主要因素</p></li></ul><h3 id="5-2-选择法"><a href="#5-2-选择法" class="headerlink" title="5.2 选择法"></a>5.2 选择法</h3><p>基本思想：</p><ul><li>每一趟 (例如第 i 趟，i = 0, 1, …,n-2)在后面 n-i个待排的数据元素中选出关键字最小的元素, 作为有序元素序列的第 i 个元素。</li></ul><p>排序过程：</p><ul><li><p>首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换</p></li><li><p>再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第二个记录交换</p></li><li><p>重复上述操作，共进行n-1趟排序后，排序结束</p></li></ul><img src="/images/imageProgramC/数据结构-60.png"><img src="/images/imageProgramC/数据结构-61.png"><h3 id="5-3-插入排序"><a href="#5-3-插入排序" class="headerlink" title="5.3 插入排序"></a>5.3 插入排序</h3><p>基本思想：</p><ul><li>元素1个元素，</li></ul><p>排序过程：</p><ul><li>整个排序过程为 n-1 趟插入，即先将序列中第 1 个记录看成是一个有序子序列，然后从第 2 个记录开始，逐个进行插入，直至整个序列有序</li></ul><p>实质：对线性表执行 n-1 次插入操作，只是先要找到插入位置</p><p>V[0], V[1], …, V[i-1] 已经排好序。这时已经排好序。这时,用V[i]的关键字与 V[i-1], V[i-2], …的关键字进行比较, 找到插入位置即将V[i]]插入, 原来位置上的对象向后顺移。</p><p>插入排序关键点：</p><ul><li>1、拿出一个元素，留出位置</li><li>2、符合条件的元素后移</li></ul><img src="/images/imageProgramC/数据结构-62.png"><h3 id="5-4-冒泡排序"><a href="#5-4-冒泡排序" class="headerlink" title="5.4 冒泡排序"></a>5.4 冒泡排序</h3><img src="/images/imageProgramC/数据结构-63.png"><img src="/images/imageProgramC/数据结构-64.png"><h3 id="5-5-希尔排序"><a href="#5-5-希尔排序" class="headerlink" title="5.5 希尔排序"></a>5.5 希尔排序</h3><p>排序过程：</p><ul><li>先取一个正整数 d1&lt;n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2&lt;d1，重复上述分组和排序操作；直至 di=1，即所有记录放进一个组中排序为止</li></ul><p>O(n-1.3)</p><p>Q(nlogn)    </p><p>希尔排序是不稳定的。</p><img src="/images/imageProgramC/数据结构-65.png"><h3 id="5-6-快速排序"><a href="#5-6-快速排序" class="headerlink" title="5.6 快速排序"></a>5.6 快速排序</h3><p>思想：</p><ul><li><p>快速排序是对冒泡排序的一种改进。它的基本思想是：</p></li><li><p>通过一躺排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，基准数据排在这两个子序列的中间；</p></li><li><p>然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></li></ul><img src="/images/imageProgramC/数据结构-67.png"><img src="/images/imageProgramC/数据结构-68.png"><img src="/images/imageProgramC/数据结构-69.png"><img src="/images/imageProgramC/数据结构-70.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n*logn)</span></span><br><span class="line">不稳定，分组，后面的有可能跑到前面去了。</span><br><span class="line"><span class="number">21</span> <span class="number">100</span> <span class="number">3</span> <span class="number">50</span> <span class="number">1</span>  </span><br><span class="line"><span class="number">3</span> <span class="number">1</span>  <span class="number">21</span>  <span class="number">100</span> <span class="number">50</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span>    <span class="number">21</span>   <span class="number">50</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="5-7-归并排序"><a href="#5-7-归并排序" class="headerlink" title="5.7 归并排序"></a>5.7 归并排序</h3><p>注意：一个元素，可以看做有序的，是稳定的算法</p><img src="/images/imageProgramC/数据结构-71.png"><img src="/images/imageProgramC/数据结构-72.png"><img src="/images/imageProgramC/数据结构-73.png"><p>对一个数组分成两路，mid中间</p><img src="/images/imageProgramC/数据结构-74.png"><p>设两个有序的子文件(相当于输入堆)放在同一向量中相邻的位置上：R[low..m],R[m+1..high],先将它们合并到一个局部的暂存向量R1(相当于输出堆)中,待合并完成后将R1复制回R[low..high]中。  </p><img src="/images/imageProgramC/数据结构-75.png"><h3 id="5-8-排序总结"><a href="#5-8-排序总结" class="headerlink" title="5.8 排序总结"></a>5.8 排序总结</h3><img src="/images/imageProgramC/数据结构-90.png"><h2 id="六、C-模板类与数据结构基础"><a href="#六、C-模板类与数据结构基础" class="headerlink" title="六、C++ 模板类与数据结构基础"></a>六、C++ 模板类与数据结构基础</h2><p>C++模板是容器的概念。</p><img src="/images/imageProgramC/数据结构-77.png"><p><strong>理论提高：</strong>所有容器提供的都是值（value）语意，而非引用（reference）语意。<strong>容器执行插入元素的操作时，内部实施拷贝动作。</strong>所以STL容器内存储的元素必须<strong>能够被拷贝</strong>（必须提供拷贝构造函数）。</p><p>加入到容器中的元素，应该可以被加入才行。</p><p><strong>模板类设计与实现</strong></p><blockquote><p>链表类_链式存储设计与实现 </p><p>栈类_链式存储设计与实现 </p><p>队列类_链式存储设计与实现 </p></blockquote><blockquote><p>链表类_顺序存储设计与实现 </p><p>栈类_顺序存储设计与实现 </p><p>队列类_顺序存储设计与实现 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://miaopei.github.io/categories/DataStructure/"/>
    
    
      <category term="DataStructure" scheme="http://miaopei.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>C 进阶</title>
    <link href="http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/"/>
    <id>http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/</id>
    <published>2016-05-24T02:14:50.000Z</published>
    <updated>2019-06-14T06:13:11.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-语言进阶"><a href="#C-语言进阶" class="headerlink" title="C 语言进阶"></a>C 语言进阶</h1><h2 id="一、-内存分区"><a href="#一、-内存分区" class="headerlink" title="一、 内存分区"></a>一、 内存分区</h2><p>栈区</p><ul><li>由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。</li></ul><a id="more"></a><p>堆区</p><ul><li>由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：在内存动态存储区中分配nmemb块长度为size字节的连续区域。<span class="built_in">calloc</span>自动将分配的内存置<span class="number">0</span>。</span><br><span class="line">参数：</span><br><span class="line">nmemb：所需内存单元数量</span><br><span class="line">size：每个内存单元的大小（单位：字节）</span><br><span class="line">返回值：</span><br><span class="line">成功：分配空间的起始地址</span><br><span class="line">失败：<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：重新分配用<span class="built_in">malloc</span>或者<span class="built_in">calloc</span>函数在堆中分配内存空间的大小。<span class="built_in">realloc</span>不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么<span class="built_in">realloc</span>会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。</span><br><span class="line">参数：</span><br><span class="line">ptr：为之前用<span class="built_in">malloc</span>或者<span class="built_in">calloc</span>分配的内存地址，如果此参数等于<span class="literal">NULL</span>，那么和<span class="built_in">realloc</span>与<span class="built_in">malloc</span>功能一致</span><br><span class="line">size：为重新分配内存的大小, 单位：字节</span><br><span class="line">返回值：</span><br><span class="line">成功：新分配的堆内存地址</span><br><span class="line">失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>全局/静态区</p><ul><li><p>全局静态区内的变量在编译阶段已经分配好内存空间并初始化。这块内存在程序运行期间一直存在,它主要存储<strong>全局变量</strong>、<strong>静态变量</strong>和<strong>常量</strong>。</p><p><strong>注意</strong>：</p><ul><li>这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。</li><li>全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。</li><li>字符串常量存储在全局/静态存储区的常量区。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">10</span>;<span class="comment">//全局/静态区</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> v2 = <span class="number">20</span>; <span class="comment">//常量，一旦初始化，不可修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> v3 = <span class="number">20</span>; <span class="comment">//全局/静态区</span></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局/静态区，编译器默认初始化为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么全局static int 和 全局int变量有什么区别？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> v4 = <span class="number">20</span>; <span class="comment">//全局/静态区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串常量是否可修改？字符串常量优化</strong>：</p><table><thead><tr><th>ANSI C中规定：修改字符串常量，结果是未定义的。<br>ANSI C并没有规定编译器的实现者对字符串的处理，例如：<br>1. 有些编译器可修改字符串常量，有些编译器则不可修改字符串常量。<br>2. 有些编译器把多个相同的字符串常量看成一个（这种优化可能出现在字符串常量中，节省空间），有些则不进行此优化。如果进行优化，则可能导致修改一个字符串常量导致另外的字符串常量也发生变化，结果不可知。<br><strong>所以尽量不要去修改字符串常量</strong>！</th></tr></thead><tbody><tr><td>C99标准：<br>char <em>p = “abc”; defines p with type ‘‘pointer to char’’ and initializes it to point to an object with type ‘‘array of char’’ with length 4 whose elements are initialized with a character string literal. *</em>If an attempt is made to use p to modify the contents of the array, the behavior is undefined**.</td></tr></tbody></table><p><strong>总结</strong></p><p>在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等，初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。</p><p><strong>数据区包括</strong>：堆，栈，全局/静态存储区。</p><p><strong>全局/静态存储区包括</strong>：常量区，全局区、静态区。</p><p><strong>常量区包括</strong>：字符串常量区、常变量区。</p><p><strong>代码区</strong>：存放程序编译后的二进制代码，不可寻址区。</p><p><strong>可以说，C/C++内存分区其实只有两个，即代码区和数据区</strong>。</p><p>函数调用模型：</p><ul><li>在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。</li></ul><p>栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：</p><ul><li>函数的返回地址；</li><li>函数的参数；</li><li>临时变量；</li><li>保存的上下文：包括在函数调用前后需要保持不变的寄存器。</li></ul><img src="/images/imageProgramC/函数调用流程.png"><p>栈的生长方向和内存存放方向：</p><img src="/images/imageProgramC/栈的生长方向和内存存放方向.png"><h2 id="二、指针强化"><a href="#二、指针强化" class="headerlink" title="二、指针强化"></a>二、指针强化</h2><p><strong>指针是一种数据类型，占用内存空间，用来保存内存地址</strong>。</p><h3 id="2-1-野指针和空指针"><a href="#2-1-野指针和空指针" class="headerlink" title="2.1 野指针和空指针"></a>2.1 野指针和空指针</h3><h4 id="2-1-1-空指针"><a href="#2-1-1-空指针" class="headerlink" title="2.1.1 空指针"></a>2.1.1 空指针</h4><p>标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。</p><p>对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未执行任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。</p><p>如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。</p><p><strong>不允许向NULL和非法地址拷贝内存</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//给p指向的内存区域拷贝内容</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"1111"</span>); <span class="comment">//err</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *q = <span class="number">0x1122</span>;</span><br><span class="line"><span class="comment">//给q指向的内存区域拷贝内容</span></span><br><span class="line"><span class="built_in">strcpy</span>(q, <span class="string">"2222"</span>); <span class="comment">//err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-野指针"><a href="#2-1-2-野指针" class="headerlink" title="2.1.2 野指针"></a>2.1.2 野指针</h4><p><strong>在使用指针时，要避免野指针的出现</strong>：</p><p>野指针指向一个已删除的对象或未申请访问受限内存区域的<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzE1OTQxNy5odG0=" title="http://baike.baidu.com/view/159417.htm">指针<i class="fa fa-external-link"></i></span>。与空指针不同，野指针无法通过简单地判断是否为 <span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzMyOTQ4NC5odG0=" title="http://baike.baidu.com/view/329484.htm">NULL<i class="fa fa-external-link"></i></span>避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。</p><p><strong>什么情况下会导致野指针</strong>？</p><ul><li><p><strong>指针变量未初始化</strong></p><ul><li>任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</li></ul></li><li><p><strong>指针释放后未置空</strong></p><ul><li>有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。</li></ul></li><li><p><strong>指针操作超越变量作用域</strong></p><ul><li><strong>不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放</strong>。</li></ul></li></ul><p><strong>操作野指针是非常危险的操作，应该规避野指针的出现</strong>：</p><ul><li><p><strong>初始化时置 NULL</strong></p><ul><li>指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。</li></ul></li><li><p><strong>释放时置 NULL</strong></p><ul><li>当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。</li></ul></li></ul><p><strong>用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据</strong>，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。请看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func(), n;</span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value = %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">100</span></span><br></pre></td></tr></table></figure><p> n 是 func() 内部的局部变量，func() 返回了指向 n 的指针，根据上面的观点，func() 运行结束后 n 将被销毁，使用 <code>*p</code> 应该获取不到 n 的值。但是从运行结果来看，我们的推理好像是错误的，func() 运行结束后 <code>*p</code> 依然可以获取局部变量 n 的值，这个上面的观点不是相悖吗？</p><p>为了进一步看清问题的本质，不妨将上面的代码稍作修改，在第9~10行之间增加一个函数调用，看看会有什么效果：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func(), n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c.biancheng.net\n"</span>);</span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value = %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.biancheng.net</span><br><span class="line">value = <span class="number">-2</span></span><br></pre></td></tr></table></figure><p>可以看到，现在 p 指向的数据已经不是原来 n 的值了，它变成了一个毫无意义的甚至有些怪异的值。与前面的代码相比，该段代码仅仅是在 <code>*p</code> 之前增加了一个函数调用，这一细节的不同却导致运行结果有天壤之别，究竟是为什么呢？</p><p>前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。</p><blockquote><p>关于函数调用的原理以及函数如何占用内存的更多细节，我们将在《<span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9jcHAvdS9jMjAv" title="http://c.biancheng.net/cpp/u/c20/">C语言和内存<i class="fa fa-external-link"></i></span>》专题中深入探讨，相信你必将有所顿悟，解开心中的谜团。</p></blockquote><p>第一个例子在调用其他函数之前使用 <code>*p</code> 抢先获得了 n 的值并将它保存起来，第二个例子显然没有抓住机会，有其他函数被调用后才使用 <code>*p</code> 获取数据，这个时候已经晚了，内存已经被后来的函数覆盖了，而覆盖它的究竟是一份什么样的数据我们无从推断（一般是一个没有意义甚至有些怪异的值）。</p><p><strong>总结</strong>：</p><p>常规程序中，函数返回的指针通常应该是：</p><ul><li>指向静态（static）变量；</li><li>指向专门申请分配的（如用malloc）空间；</li><li>指向常量区（如指向字符串”hello”）；</li><li>指向全局变量；</li><li>指向程序代码区（如指向函数的指针）。 </li></ul><p>除这5项以外，其它怪技巧不提倡。</p><p><strong>函数内的变量，没有关键字static修饰的变量的生命周期只在本函数内，函数结束后变量自动销毁</strong>。当返回为指针的时候需要特别注意，因为<strong>函数结束后指针所指向的地址依然存在，但是该地址可以被其他程序修改，里面的内容就不确定了，有可能后面的操作会继续用到这块地址，有可能不会用到，所以会出现时对时错的情况，如果需要返回一个指针而又不出错的话只能调用内存申请函数</strong></p><h3 id="2-2-间接访问操作符"><a href="#2-2-间接访问操作符" class="headerlink" title="2.2 间接访问操作符"></a>2.2 间接访问操作符</h3><p>通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是 <code>*</code>。</p><p>注意：对一个<code>int*</code>类型指针解引用会产生一个整型值，类似地，对一个<code>float*</code>指针解引用会产生了一个float类型的值。</p><ul><li><p>在指针声明时，<code>*</code> 号表示所声明的变量为指针</p></li><li><p>在指针使用时，<code>*</code> 号表示操作指针所指向的内存空间</p><ul><li><code>*</code> 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存</li><li><code>*</code> 放在等号的左边赋值（给内存赋值，写内存）</li><li><code>*</code> 放在等号的右边取值（从内存中取值，读内存）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指针</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//指针指向谁，就把谁的地址赋给指针</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">p = &amp;a;</span><br><span class="line">*p = <span class="number">20</span>;<span class="comment">//*在左边当左值，必须确保内存可写</span></span><br><span class="line"><span class="comment">//*号放右面，从内存中读值</span></span><br><span class="line"><span class="keyword">int</span> b = *p;</span><br><span class="line"><span class="comment">//必须确保内存可写</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"hello world!"</span>;</span><br><span class="line">*str = <span class="string">'m'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p:%d\n"</span>, *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b:%d\n"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-指针的步长"><a href="#2-3-指针的步长" class="headerlink" title="2.3 指针的步长"></a>2.3 <strong>指针的步长</strong></h3><p>指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。</p><h3 id="2-4-指针的意义-间接赋值"><a href="#2-4-指针的意义-间接赋值" class="headerlink" title="2.4 指针的意义_间接赋值"></a>2.4 指针的意义_间接赋值</h3><p>通过指针间接赋值成立的三大条件：</p><ul><li><p>2个变量（一个普通变量一个指针变量、或者一个实参一个形参）</p></li><li><p>建立关系</p></li><li><p>通过 <code>*</code> 操作指针指向的内存</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;<span class="comment">//两个变量</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//建立关系</span></span><br><span class="line"><span class="comment">//指针指向谁，就把谁的地址赋值给指针</span></span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="comment">//通过*操作内存</span></span><br><span class="line">*p = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>间接赋值：从1级指针到2级指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllocateSpace</span><span class="params">(<span class="keyword">char</span>** p)</span></span>&#123;</span><br><span class="line">*p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(*p, <span class="string">"hello world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeSpace</span><span class="params">(<span class="keyword">char</span>** p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(*p);</span><br><span class="line">*p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AllocateSpace(&amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br><span class="line">FreeSpace(&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p内存释放!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>间接赋值的推论</strong>：</p><ul><li><p>用 1 级指针形参，去间接修改了 0 级指针(实参)的值。</p></li><li><p>用 2 级指针形参，去间接修改了 1 级指针(实参)的值。</p></li><li><p>用 3 级指针形参，去间接修改了 2 级指针(实参)的值。</p></li><li><p>用 n 级指针形参，去间接修改了 n-1 级指针(实参)的值。</p></li></ul><h3 id="2-5-指针做函数参数"><a href="#2-5-指针做函数参数" class="headerlink" title="2.5 指针做函数参数"></a>2.5 指针做函数参数</h3><p>指针做函数参数，具备输入和输出特性：</p><ul><li><p>输入：主调函数分配内存</p></li><li><p>输出：被调用函数分配内存</p></li></ul><p>输入特性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p <span class="comment">/* in */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//给p指向的内存区域拷贝内容</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"abcddsgsd"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输入，主调函数分配内存</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">fun(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf  = %s\n"</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出特性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> **p <span class="comment">/* out */</span>, <span class="keyword">int</span> *len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp, <span class="string">"adlsgjldsk"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//间接赋值</span></span><br><span class="line">*p = tmp;</span><br><span class="line">*len = <span class="built_in">strlen</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输出，被调用函数分配内存，地址传递</span></span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">fun(&amp;p, &amp;len);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p = %s, len = %d\n"</span>, p, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-字符串指针强化"><a href="#2-6-字符串指针强化" class="headerlink" title="2.6 字符串指针强化"></a>2.6 字符串指针强化</h3><p><strong>字符串是以0或者’\0’结尾的字符数组，(数字0和字符’\0’等价)</strong></p><p><strong>如果以字符串初始化，那么编译器默认会在字符串尾部添加’\0’</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str3[] = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><ul><li><p>sizeof 计算数组大小，数组包含’\0’字符</p></li><li><p>strlen 计算字符串的长度，到’\0’结束</p></li></ul><p>字符串拷贝功能实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1）应该判断下传入的参数是否为NULL</span></span><br><span class="line"><span class="comment">//2）最好不要直接使用形参</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_string04</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">char</span>* source)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dest == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (source == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* src = source;</span><br><span class="line"><span class="keyword">char</span>* tar = dest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*tar++ = *src++)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串的格式化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">     根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 <span class="string">'\0'</span> 为止。</span><br><span class="line">参数： </span><br><span class="line">str：字符串首地址</span><br><span class="line">format：字符串格式，用法和<span class="built_in">printf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际格式化的字符个数</span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 格式化字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"你好,%s,欢迎加入我们!"</span>, <span class="string">"John"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>,buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"我今年%d岁了!"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 拼接字符串</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">sprintf</span>(buf,<span class="string">"%s %s"</span>,str1,str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s len:%d\n"</span>, buf,len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 数字转字符串</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"><span class="comment">//设置宽度 右对齐</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%8d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"><span class="comment">//设置宽度 左对齐</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%-8d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</span><br><span class="line">参数：</span><br><span class="line">str：指定的字符串首地址</span><br><span class="line">format：字符串格式，用法和<span class="built_in">scanf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际读取的字符个数</span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>格式</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>%*s或%*d</code></td><td>跳过数据</td></tr><tr><td>%[width]s</td><td>读指定宽度的数据</td></tr><tr><td>%[a-z]</td><td>匹配a到z中任意字符(尽可能多的匹配)</td></tr><tr><td>%[aBc]</td><td>匹配a、B、c中一员，贪婪性</td></tr><tr><td><code>%[^a]</code></td><td>匹配非a的任意字符，贪婪性</td></tr><tr><td><code>%[^a-z]</code></td><td>表示读取除a-z以外的所有字符</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 跳过数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//匹配第一个字符是否是数字，如果是，则跳过</span></span><br><span class="line"><span class="comment">//如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"123456aaaa"</span>, <span class="string">"%*d%s"</span>, buf); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 读取指定宽度数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"123456aaaa"</span>, <span class="string">"%7s"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 匹配a-z中任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line">  <span class="comment">//先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配</span></span><br><span class="line"><span class="comment">//如果不是停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"abcdefg123456"</span>, <span class="string">"%[a-z]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 匹配aBc中的任何一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"abcdefg123456"</span>, <span class="string">"%[aBc]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 匹配非a的任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"bcdefag123456"</span>, <span class="string">"%[^a]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 匹配非a-z中的任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//跳过前面的数字</span></span><br><span class="line"><span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">"123456ABCDbcdefag"</span>, <span class="string">"%[^a-z]"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-1-一级指针易错点"><a href="#2-6-1-一级指针易错点" class="headerlink" title="2.6.1 一级指针易错点"></a>2.6.1 一级指针易错点</h4><ul><li><p>越界</p></li><li><p>指针叠加会不断改变指针指向 <code>p++</code></p></li><li><p>返回局部变量地址</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdedsgads"</span>; <span class="comment">//栈区，</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[get_str]str = %s\n"</span>, str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同一块内存释放多次<ul><li>free()函数的功能只是告诉系统 p 指向的内存可以回收了。就是说，p 指向的内存使用权交还给系统。但是，p的值还是原来的值(野指针)，p还是指向原来的内存</li></ul></li></ul><h3 id="2-7-const使用"><a href="#2-7-const使用" class="headerlink" title="2.7 const使用"></a>2.7 const使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const修饰变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1. const基本概念</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//i = 100; //错误，只读变量初始化之后不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义const变量最好初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="comment">//j = 100; //错误，不能再次赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. c语言的const是一个只读变量，并不是一个常量，可通过指针间接修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//k = 100; //错误，不可直接修改，我们可通过指针间接修改</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"k:%d\n"</span>, k);</span><br><span class="line"><span class="keyword">int</span>* p = &amp;k;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"k:%d\n"</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const 修饰指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//const放在*号左侧 修饰p_a指针指向的内存空间不能修改,但可修改指针的指向</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p_a = &amp;a;</span><br><span class="line"><span class="comment">//*p_a = 100; //不可修改指针指向的内存空间</span></span><br><span class="line">p_a = &amp;b; <span class="comment">//可修改指针的指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const放在*号的右侧， 修饰指针的指向不能修改，但是可修改指针指向的内存空间</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p_b = &amp;a;</span><br><span class="line"><span class="comment">//p_b = &amp;b; //不可修改指针的指向</span></span><br><span class="line">*p_b = <span class="number">100</span>; <span class="comment">//可修改指针指向的内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的指向和指针指向的内存空间都不能修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p_c = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const指针用法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次都对对象进行拷贝，效率低，应该用指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonByValue</span><span class="params">(struct Person person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, person.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是用指针会有副作用，可能会不小心修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonByPointer</span><span class="params">(<span class="keyword">const</span> struct Person *person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, person-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span> = &#123;</span> <span class="string">"Obama"</span>, <span class="number">1101</span>, <span class="number">23</span>, <span class="number">87</span> &#125;;</span><br><span class="line"><span class="comment">//printPersonByValue(p);</span></span><br><span class="line">printPersonByPointer(&amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、指针的指针-二级指针"><a href="#三、指针的指针-二级指针" class="headerlink" title="三、指针的指针(二级指针)"></a>三、指针的指针(二级指针)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br></pre></td></tr></table></figure><p>它在内存中的大概模样大致如下：</p><img src="/images/imageProgramC/二级指针.png"><h3 id="3-1-二级指针做形参输出特性"><a href="#3-1-二级指针做形参输出特性" class="headerlink" title="3.1 二级指针做形参输出特性"></a>3.1 二级指针做形参输出特性</h3><p>二级指针做参数的输出特性是指由被调函数分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调函数,由参数n确定分配多少个元素内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate_space</span><span class="params">(<span class="keyword">int</span> **arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//堆上分配n个int类型元素内存</span></span><br><span class="line"><span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)* n);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == temp)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给内存初始化值</span></span><br><span class="line"><span class="keyword">int</span> *pTemp = temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line"><span class="comment">//temp[i] = i + 100;</span></span><br><span class="line">*pTemp = i + <span class="number">100</span>;</span><br><span class="line">pTemp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针间接赋值</span></span><br><span class="line">*arr = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二级指针输出特性(由被调函数分配内存)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//给arr指针间接赋值</span></span><br><span class="line">allocate_space(&amp;arr,n);</span><br><span class="line"><span class="comment">//输出arr指向数组的内存</span></span><br><span class="line">print_array(arr, n);</span><br><span class="line"><span class="comment">//释放arr所指向内存空间的值</span></span><br><span class="line"><span class="keyword">if</span> (arr != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-二级指针做形参输入特性"><a href="#3-2-二级指针做形参输入特性" class="headerlink" title="3.2 二级指针做形参输入特性"></a>3.2 二级指针做形参输入特性</h3><p>二级指针做形参输入特性是指由主调函数分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> **arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,*(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二级指针输入特性(由主调函数分配内存)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> a5 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>** arr = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * n);</span><br><span class="line">arr[<span class="number">0</span>] = &amp;a1;</span><br><span class="line">arr[<span class="number">1</span>] = &amp;a2;</span><br><span class="line">arr[<span class="number">2</span>] = &amp;a3;</span><br><span class="line">arr[<span class="number">3</span>] = &amp;a4;</span><br><span class="line">arr[<span class="number">4</span>] = &amp;a5;</span><br><span class="line"></span><br><span class="line">print_array(arr,n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、位运算"><a href="#四、位运算" class="headerlink" title="四、位运算"></a>四、位运算</h2><h3 id="4-1-位逻辑运算符"><a href="#4-1-位逻辑运算符" class="headerlink" title="4.1 位逻辑运算符"></a>4.1 位逻辑运算符</h3><p>4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(&amp;&amp; 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。</p><ul><li><strong>按位取反~</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> a = <span class="number">2</span>;   <span class="comment">//00000010</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b = ~a;  <span class="comment">//11111101</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, a); <span class="comment">//ret = 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, b); <span class="comment">//ret = 253</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>位与（AND）: &amp;</strong></p><ul><li>二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。</li></ul></li><li><p><strong>位或（OR）: |</strong></p><ul><li>二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1.</li></ul></li><li><p><strong>位异或:</strong></p><ul><li>二进制运算符 <code>^</code> 对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0.</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10010011</span>) </span><br><span class="line">^ (<span class="number">00111101</span>)</span><br><span class="line">= (<span class="number">10101110</span>)</span><br></pre></td></tr></table></figure><p><strong>用法</strong>：</p><ul><li>打开位</li></ul><p>已知：10011010：</p><ol><li><p>将位2打开</p><p><code>flag | 10011010</code></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">| (<span class="number">00000100</span>)</span><br><span class="line">= (<span class="number">10011110</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>将所有位打开。</p><p><code>flag | ~flag</code></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">| (<span class="number">01100101</span>)</span><br><span class="line">= (<span class="number">11111111</span>)</span><br></pre></td></tr></table></figure><ul><li><p>关闭位</p><p><code>flag &amp; ~flag</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">&amp; (<span class="number">01100101</span>)</span><br><span class="line">= (<span class="number">00000000</span>)</span><br></pre></td></tr></table></figure><ul><li><p>转置位</p><ul><li>转置(toggling)一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开。您可以使用位异或运算符来转置。其思想是如果b是一个位(1或0)，那么如果b为1则 <code>b^1</code> 为0，如果b为0，则 <code>1^b</code> 为1。无论b的值是0还是1, <code>0^b</code> 为b.</li></ul><p><code>flag ^ 0xff</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10010011</span>)</span><br><span class="line">^ (<span class="number">11111111</span>)</span><br><span class="line">= (<span class="number">01101100</span>)</span><br></pre></td></tr></table></figure><ul><li>交换两个数不需要临时变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a ^ b = temp;</span></span><br><span class="line"><span class="comment">//a ^ temp = b;</span></span><br><span class="line"><span class="comment">//b ^ temp = a</span></span><br><span class="line">  (<span class="number">10010011</span>)</span><br><span class="line">^ (<span class="number">00100110</span>)</span><br><span class="line">= (<span class="number">10110101</span>)</span><br><span class="line"></span><br><span class="line">  (<span class="number">10110101</span>)</span><br><span class="line">^ (<span class="number">00100110</span>)</span><br><span class="line">   <span class="number">10010011</span></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = b ^ a;</span><br><span class="line">    a = a ^ b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d b = %d/n"</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-移位运算符"><a href="#4-2-移位运算符" class="headerlink" title="4.2 移位运算符"></a>4.2 移位运算符</h3><ul><li><p><strong>左移 &lt;&lt;</strong></p><ul><li><p>左移运算符 <code>&lt;&lt;</code> 将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。</p></li><li><p>左移一位相当于原值 <code>*2</code>.</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10001010</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">(<span class="number">00101000</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">1</span> = <span class="number">2</span>;</span><br><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">1</span> = <span class="number">4</span>;</span><br><span class="line"><span class="number">4</span> &lt;&lt; <span class="number">1</span> = <span class="number">8</span>;</span><br><span class="line"><span class="number">8</span> &lt;&lt; <span class="number">2</span> = <span class="number">32</span></span><br></pre></td></tr></table></figure><ul><li><strong>右移 &gt;&gt;</strong><ul><li>右移运算符 <code>&gt;&gt;</code> 将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。<strong>对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充</strong>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有符号值</span></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">00100010</span>)     <span class="comment">//在某些系统上的结果值</span></span><br><span class="line"></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">11100010</span>)     <span class="comment">//在另一些系统上的解雇</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号值</span></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">00100010</span>)    <span class="comment">//所有系统上的结果值</span></span><br></pre></td></tr></table></figure><p><strong>用法：移位运算符</strong>：</p><ul><li>移位运算符能够提供快捷、高效（依赖于硬件）对2的幂的乘法和除法。</li></ul><table><thead><tr><th>number &lt;&lt; n</th><th>number乘以2的n次幂</th></tr></thead><tbody><tr><td>number &gt;&gt; n</td><td>如果number非负，则用number除以2的n次幂</td></tr></tbody></table><h2 id="五、多维数组"><a href="#五、多维数组" class="headerlink" title="五、多维数组"></a>五、多维数组</h2><h3 id="5-1-一维数组"><a href="#5-1-一维数组" class="headerlink" title="5.1 一维数组"></a>5.1 一维数组</h3><ul><li>元素类型角度：数组是相同类型的变量的有序集合</li><li>内存角度：连续的一大片内存空间</li></ul><p><strong>请问：指针和数组是等价的吗？</strong></p><p>答案是<strong>否定</strong>的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下：</p><ul><li>当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。</li><li>当数组名作为&amp;操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//arr = NULL; //arr作为指针常量，不可修改</span></span><br><span class="line"><span class="keyword">int</span> *p = arr; <span class="comment">//此时arr作为指针常量来使用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(arr):%d\n"</span>, <span class="keyword">sizeof</span>(arr)); <span class="comment">//此时sizeof结果为整个数组的长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;arr type is %s\n"</span>, <span class="keyword">typeid</span>(&amp;arr).name()); <span class="comment">//int(*)[10]而不是int*</span></span><br></pre></td></tr></table></figure><p><strong>下标引用</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>*(arr + 3)</strong> ,这个表达式是什么意思呢？<ul><li>首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(arr + <span class="number">3</span>)</span><br><span class="line">arr[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>问题 1</strong>：数组下标可否为负值？</p><p><strong>问题 2</strong>：请阅读如下代码，说出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, *p); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, p[<span class="number">-1</span>]);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="5-1-1-数组和指针"><a href="#5-1-1-数组和指针" class="headerlink" title="5.1.1 数组和指针"></a>5.1.1 数组和指针</h4><p>指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *b;</span><br></pre></td></tr></table></figure><p>声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。</p><p>因此，表达式 <code>*a</code> 是完全合法的，但是表达式 <code>*b</code> 却是非法的。<code>*b</code> 将访问内存中一个不确定的位置，将会导致程序终止。另一方面 b++ 可以通过编译，a++ 却不行，因为 a 是一个常量值。</p><h4 id="5-1-2-作为函数参数的数组名"><a href="#5-1-2-作为函数参数的数组名" class="headerlink" title="5.1.2 作为函数参数的数组名"></a>5.1.2 作为函数参数的数组名</h4><p>当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> *arr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。<strong>同样sizeof arr值是指针的长度，而不是数组的长度</strong>。</p><p>现在我们清楚了，<strong>为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数</strong>。</p><h3 id="5-2-多维数组"><a href="#5-2-多维数组" class="headerlink" title="5.2 多维数组"></a>5.2 多维数组</h3><p><strong>数组名</strong>：</p><ul><li>一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。</p><p><strong>指向数组的指针(数组指针)</strong>：</p><p>数组指针，它是指针，指向数组的指针。</p><p>数组的类型由<strong>元素类型</strong>和<strong>数组大小</strong>共同决定：int array[5]  的类型为  int[5]；C语言可通过typedef定义一个数组类型：</p><p>定义数组指针有一下三种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先定义数组类型，再用数组类型定义数组指针</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType</span></span><br><span class="line">typedef int(ArrayType)[10];</span><br><span class="line"><span class="comment">//int ArrayType[10]; //定义一个数组，数组名为ArrayType</span></span><br><span class="line"></span><br><span class="line">ArrayType myarr; <span class="comment">//等价于 int myarr[10];</span></span><br><span class="line">ArrayType* pArr = &amp;arr; <span class="comment">//定义了一个数组指针pArr，并且指针指向数组arr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,(*pArr)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//定义数组指针类型</span></span><br><span class="line">typedef int(*ArrayType)[10];</span><br><span class="line">ArrayType pArr = &amp;arr; <span class="comment">//定义了一个数组指针pArr，并且指针指向数组arr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">(*pArr)[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, (*pArr)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>(*pArr)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">(*pArr)[i] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, (*pArr)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-1-指针数组-元素为指针"><a href="#5-2-1-指针数组-元素为指针" class="headerlink" title="5.2.1 指针数组(元素为指针)"></a>5.2.1 指针数组(元素为指针)</h4><p><strong>栈区指针数组</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组做函数函数，退化为指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_sort</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j --)&#123;</span><br><span class="line"><span class="comment">//比较两个字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(arr[j<span class="number">-1</span>],arr[j]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">char</span>* temp = arr[j - <span class="number">1</span>];</span><br><span class="line">arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//主调函数分配内存</span></span><br><span class="line"><span class="comment">//指针数组</span></span><br><span class="line"><span class="keyword">char</span>* p[] = &#123; <span class="string">"bbb"</span>, <span class="string">"aaa"</span>, <span class="string">"ccc"</span>, <span class="string">"eee"</span>, <span class="string">"ddd"</span>&#125;;</span><br><span class="line"><span class="comment">//char** p = &#123; "aaa", "bbb", "ccc", "ddd", "eee" &#125;; //错误</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">array_print(p, len);</span><br><span class="line"><span class="comment">//对字符串进行排序</span></span><br><span class="line">array_sort(p, len);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">array_print(p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆区指针数组</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">allocate_memory</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>** temp = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * n);</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分别给每一个指针malloc分配内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">temp[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)* <span class="number">30</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp[i], <span class="string">"%2d_hello world!"</span>, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(<span class="keyword">char</span>** buf,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buf == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line"><span class="built_in">free</span>(buf[i]);</span><br><span class="line">buf[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span>** p = allocate_memory(n);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">array_print(p, n);</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line">free_memory(p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维数组的线性存储特性式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的线性存储</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[][<span class="number">3</span>] = &#123;</span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr2[][<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何证明二维数组是线性的？</span></span><br><span class="line"><span class="comment">//通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">PrintArray((<span class="keyword">int</span>*)arr, len);</span><br><span class="line">PrintArray((<span class="keyword">int</span>*)arr2, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维数组的3种形式参数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组的第一种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray01</span><span class="params">(<span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的第二种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray02</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的第二种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray03</span><span class="params">(<span class="keyword">int</span>(*arr)[<span class="number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[][<span class="number">3</span>] = &#123; </span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintArray01(arr);</span><br><span class="line">PrintArray02(arr);</span><br><span class="line">PrintArray03(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p><strong>编程提示</strong>：</p><ul><li>源代码的可读性几乎总是比程序的运行时效率更为重要</li><li><strong>只要有可能，函数的指针形参都应该声明为const</strong></li><li>在多维数组的初始值列表中使用完整的多层花括号提供可读性</li></ul><p><strong>内容总结</strong>：</p><ul><li>在绝大多数表达式中，数组名的值是指向数组第1个元素的指针。<strong>这个规则只有两个例外，sizeof和对数组名&amp;</strong>。</li><li>指针和数组并不相等。当我们声明一个数组的时候，同时也分配了内存。但是声明指针的时候，只分配容纳指针本身的空间。</li><li>当数组名作为函数参数时，实际传递给函数的是一个指向数组第1个元素的指针。</li><li>我们不单可以创建指向普通变量的指针，也可创建指向数组的指针。</li></ul><h2 id="六、结构体"><a href="#六、结构体" class="headerlink" title="六、结构体"></a>六、结构体</h2><h3 id="6-1-结构体基础知识"><a href="#6-1-结构体基础知识" class="headerlink" title="6.1 结构体基础知识"></a>6.1 结构体基础知识</h3><p>结构体类型的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PERSON</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;Person;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。</p><p><strong>结构体变量的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;p1; <span class="comment">//定义类型同时定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;p2; <span class="comment">//定义类型同时定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p3</span>;</span> <span class="comment">//通过类型直接定义</span></span><br></pre></td></tr></table></figure><p><strong>结构体成员的使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//在栈上分配空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(p1.name, <span class="string">"John"</span>);</span><br><span class="line">p1.age = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//如果是普通变量，通过点运算符操作结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p1.name, p1.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆上分配空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">p2</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>));</span></span><br><span class="line"><span class="built_in">strcpy</span>(p2-&gt;name, <span class="string">"Obama"</span>);</span><br><span class="line">p2-&gt;age = <span class="number">33</span>;</span><br><span class="line"><span class="comment">//如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p2-&gt;name, p2-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝和浅拷贝</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个老师有N个学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Teacher t1;</span><br><span class="line">t1.name = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t1.name , <span class="string">"John"</span>);</span><br><span class="line"></span><br><span class="line">Teacher t2;</span><br><span class="line">t2 = t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对手动开辟的内存，需要手动拷贝</span></span><br><span class="line">t2.name = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t2.name, t1.name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(t1.name);</span><br><span class="line">t1.name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(t2.name);</span><br><span class="line">t1.name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//在栈上分配空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>[3] = &#123;</span></span><br><span class="line">&#123; <span class="string">"John"</span>, <span class="number">30</span> &#125;,</span><br><span class="line">&#123; <span class="string">"Obama"</span>, <span class="number">33</span> &#125;,</span><br><span class="line">&#123; <span class="string">"Edward"</span>, <span class="number">25</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>[3] = &#123;</span> <span class="string">"John"</span>, <span class="number">30</span>, <span class="string">"Obama"</span>, <span class="number">33</span>, <span class="string">"Edward"</span>, <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>,p1[i].name,p1[i].age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----------------\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p2[i].name, p2[i].age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----------------\n"</span>);</span><br><span class="line"><span class="comment">//在堆上分配结构体数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">p3</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>) * 3);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(p3[i].name, <span class="string">"Name_%d"</span>, i + <span class="number">1</span>);</span><br><span class="line">p3[i].age = <span class="number">20</span> + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p3[i].name, p3[i].age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-结构体嵌套指针"><a href="#6-2-结构体嵌套指针" class="headerlink" title="6.2 结构体嵌套指针"></a>6.2 结构体嵌套指针</h3><p><strong>结构体嵌套一级指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate_memory</span><span class="params">(struct Person** person)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (person == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">temp</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>));</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给name指针分配内存</span></span><br><span class="line">temp-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)* <span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(temp-&gt;name, <span class="string">"John"</span>);</span><br><span class="line">temp-&gt;age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">*person = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_person</span><span class="params">(struct Person* person)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>,person-&gt;name,person-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(struct Person** person)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (person == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">temp</span> = *<span class="title">person</span>;</span></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(temp-&gt;name);</span><br><span class="line">temp-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">allocate_memory(&amp;p);</span><br><span class="line">print_person(p);</span><br><span class="line">free_memory(&amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体嵌套二级指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个老师有N个学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">char</span>** students;</span><br><span class="line">&#125;Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_teacher</span><span class="params">(Teacher** teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (teacher == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建老师数组</span></span><br><span class="line">Teacher* teachers = (Teacher*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Teacher)* n);</span><br><span class="line"><span class="keyword">if</span> (teachers == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给每一个老师分配学生</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(teachers[i].name, <span class="string">"老师_%d"</span>, i + <span class="number">1</span>);</span><br><span class="line">teachers[i].students = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)&#123;</span><br><span class="line">teachers[i].students[j] = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(teachers[i].students[j], <span class="string">"学生_%d"</span>, num + <span class="number">1</span>);</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*teacher = teachers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_teacher</span><span class="params">(Teacher* teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, teacher[i].name);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  %s"</span>,teacher[i].students[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(Teacher** teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (teacher == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher* temp = *teacher;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j ++)&#123;</span><br><span class="line"><span class="built_in">free</span>(temp[i].students[j]);</span><br><span class="line">temp[i].students[j] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(temp[i].students);</span><br><span class="line">temp[i].students = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Teacher* p = <span class="literal">NULL</span>;</span><br><span class="line">create_teacher(&amp;p,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">print_teacher(p, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">free_memory(&amp;p,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-结构体成员偏移量"><a href="#6-3-结构体成员偏移量" class="headerlink" title="6.3 结构体成员偏移量"></a>6.3 结构体成员偏移量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一旦结构体定义下来，则结构体中的成员内存布局就定下了</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> a;  </span><br><span class="line"><span class="keyword">int</span> b;      </span><br><span class="line"><span class="keyword">int</span> c;        </span><br><span class="line"></span><br><span class="line">&#125; Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Teacher  t1;</span><br><span class="line">Teacher*p = <span class="literal">NULL</span>;</span><br><span class="line">p = &amp;t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> offsize1 = (<span class="keyword">int</span>)&amp;(p-&gt;b) - (<span class="keyword">int</span>)p;  <span class="comment">//age 相对于结构体 Teacher的偏移量</span></span><br><span class="line"><span class="keyword">int</span> offsize2 = (<span class="keyword">int</span>)&amp;(((Teacher *)<span class="number">0</span>)-&gt;b);<span class="comment">//绝对0地址 age的偏移量</span></span><br><span class="line"><span class="keyword">int</span> offsize3 = offsetof(Teacher, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"offsize1:%d \n"</span>, offsize1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"offsize2:%d \n"</span>, offsize2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"offsize3:%d \n"</span>, offsize3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-结构体字节对齐"><a href="#6-4-结构体字节对齐" class="headerlink" title="6.4 结构体字节对齐"></a>6.4 结构体字节对齐</h3><p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。</p><p>从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是<strong>内存对齐</strong>。</p><h4 id="6-4-1-内存对齐原因"><a href="#6-4-1-内存对齐原因" class="headerlink" title="6.4.1 内存对齐原因"></a>6.4.1 内存对齐原因</h4><p>我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等</p><p>内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)。如果没有对齐，为了访问一个变量可能产生二次访问。</p><p><strong>为什么要简单内存对齐？</strong></p><ul><li>提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量。</li><li>某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。</li></ul><h4 id="6-4-2-如何内存对齐"><a href="#6-4-2-如何内存对齐" class="headerlink" title="6.4.2 如何内存对齐"></a>6.4.2 如何内存对齐</h4><ul><li>对于标准数据类型，它的地址只要是它的长度的整数倍。</li><li>对于非标准数据类型，比如结构体，要遵循一下对齐原则：<ul><li>数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为<strong>min（当前成员的大小，#pargama pack(n)）</strong>整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。</li><li>结构体总的大小，也就是sizeof的结果，必须是<strong>min（结构体内部最大成员，#pargama pack(n)）</strong>的整数倍，不足要补齐。</li><li>结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。</li></ul></li></ul><p>手动设置对齐模数:</p><ul><li><strong>#pragma pack(show)</strong><ul><li>显示当前packing alignment的字节数，以warning message的形式被显示。</li></ul></li><li><strong>#pragma pack(push)</strong> <ul><li>将当前指定的packing alignment数组进行压栈操作，这里的栈是the internal compiler stack,同事设置当前的packing alignment为n；如果n没有指定，则将当前的packing alignment数组压栈。</li></ul></li><li><strong>#pragma pack(pop)</strong> <ul><li>从internal compiler stack中删除最顶端的reaord; 如果没有指定n,则当前栈顶record即为新的packing alignement数值；如果指定了n，则n成为新的packing alignment值</li></ul></li><li><strong>#pragma pack(n)</strong><ul><li>指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 </li></ul></li></ul><p>内存对齐案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> b;</span><br><span class="line"><span class="keyword">double</span> c;</span><br><span class="line"><span class="keyword">float</span> d;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT2</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line">Student b; </span><br><span class="line"><span class="keyword">double</span> c;</span><br><span class="line">&#125;Student2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//a从偏移量0位置开始存储</span></span><br><span class="line"><span class="comment">//b从4位置开始存储</span></span><br><span class="line"><span class="comment">//c从8位置开始存储</span></span><br><span class="line"><span class="comment">//d从12位置开存储</span></span><br><span class="line"><span class="comment">//所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof Student:%d\n"</span>,<span class="keyword">sizeof</span>(Student));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Student2 </span></span><br><span class="line"><span class="comment">//a从偏移量为0位置开始 8</span></span><br><span class="line"><span class="comment">//b从偏移量为Student内部最大成员整数倍开始，也就是8开始 24</span></span><br><span class="line"><span class="comment">//c从8的整数倍地方开始,也就是32开始</span></span><br><span class="line"><span class="comment">//所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof Student2:%d\n"</span>, <span class="keyword">sizeof</span>(Student2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、文件操作"><a href="#七、文件操作" class="headerlink" title="七、文件操作"></a>七、文件操作</h2><p>文件在今天的计算机系统中作用是很重要的。文件用来存放程序、文档、数据、表格、图片和其他很多种类的信息。作为一名程序员，您必须编程来创建、写入和读取文件。编写程序从文件读取信息或者将结果写入文件是一种经常性的需求。C提供了强大的和文件进行通信的方法。使用这种方法我们可以在程序中打开文件，然后使用专门的I/O函数读取文件或者写入文件。</p><p><strong>文件的概念</strong></p><ul><li>一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。</li></ul><p><strong>流的概念</strong></p><p>流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。</p><p>C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。</p><p><strong>文本流</strong></p><ul><li>文本流，也就是我们常说的以文本模式读取文件。文本流的有些特性在不同的系统中可能不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只使用一个换行符结尾。</li><li>标准C把文本定义为零个或者多个字符，后面跟一个表示结束的换行符(\n).对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式和内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形势而操纵文本的能力简化了可移植程序的创建。</li></ul><p><strong>二进制流</strong></p><ul><li>二进制流中的字节将完全根据程序编写它们的形式写入到文件中，而且完全根据它们从文件或设备读取的形式读入到程序中。它们并未做任何改变。这种类型的流适用于非文本数据，但是如果你不希望I/O函数修改文本文件的行末字符，也可以把它们用于文本文件。</li></ul><p>c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。</p><p><strong>我们程序中，经常看到的文本方式打开文件和二进制方式打开文件仅仅体现在换行符的处理上</strong>。</p><p>比如说，在widows下，文件的换行符是 <code>\r\n</code>，而在Linux下换行符则是 <code>\n</code>.</p><p>当对文件使用文本方式打开的时候，读写的windows文件中的换行符\r\n会被替换成\n读到内存中，当在windows下写入文件的时候，\n被替换成\r\n再写入文件。如果使用二进制方式打开文件，则不进行\r\n和\n之间的转换。 那么由于Linux下的换行符就是\n, 所以文本文件方式和二进制方式无区别。</p><h3 id="7-1-文件的操作"><a href="#7-1-文件的操作" class="headerlink" title="7.1 文件的操作"></a>7.1 文件的操作</h3><p><strong>文件流总览</strong></p><p>标准库函数是的我们在C程序中执行与文件相关的I/O任务非常方便。下面是关于文件I/O的一般概况。</p><ul><li>程序为同时处于活动状态的每个文件声明一个指针变量，其类型为 <code>FILE*</code>。这个指针指向这个FILE结构，当它处于活动状态时由流使用。</li><li>流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式(读、写、或者读写)。Fopen和操作系统验证文件或者设备是否存在并初始化FILE。</li><li>根据需要对文件进行读写操作。</li><li>最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放FILE结构。</li></ul><p>标准I/O更为简单，因为它们并不需要打开或者关闭。</p><p>I/O函数以三种基本的形式处理数据：<strong>单个字符</strong>、<strong>文本行</strong>和<strong>二进制数据</strong>。对于每种形式都有一组特定的函数对它们进行处理。</p><p><strong>输入/输出函数家族</strong></p><table><thead><tr><th>家族名</th><th>目的</th><th>可用于所有流</th><th>只用于stdin和stdout</th></tr></thead><tbody><tr><td>getchar</td><td>字符输入</td><td>fgetc、getc</td><td>getchar</td></tr><tr><td>putchar</td><td>字符输出</td><td>fputc、putc</td><td>putchar</td></tr><tr><td>gets</td><td>文本行输入</td><td>fgets</td><td>gets</td></tr><tr><td>puts</td><td>文本行输出</td><td>fputs</td><td>puts</td></tr><tr><td>scanf</td><td>格式化输入</td><td>fscanf</td><td>scanf</td></tr><tr><td>printf</td><td>格式化输出</td><td>fprintf</td><td>printf</td></tr></tbody></table><h3 id="7-2-文件打开关闭"><a href="#7-2-文件打开关闭" class="headerlink" title="7.2 文件打开关闭"></a>7.2 文件打开关闭</h3><p>文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line">功能：打开文件</span><br><span class="line">参数：</span><br><span class="line">filename：需要打开的文件名，根据需要加上路径</span><br><span class="line">mode：打开文件的权限设置</span><br><span class="line">返回值：</span><br><span class="line">成功：文件指针</span><br><span class="line">失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方式</th><th>含义</th></tr></thead><tbody><tr><td>“r”</td><td>打开，只读，文件必须已经存在。</td></tr><tr><td>“w”</td><td>只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。</td></tr><tr><td>“a”</td><td>只能在文件末尾追加数据,如果文件不存在则创建</td></tr><tr><td>“rb”</td><td>打开一个二进制文件，只读</td></tr><tr><td>“wb”</td><td>打开一个二进制文件，只写</td></tr><tr><td>“ab”</td><td>打开一个二进制文件，追加</td></tr><tr><td>“r+”</td><td>允许读和写,文件必须已存在</td></tr><tr><td>“w+”</td><td>允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。</td></tr><tr><td>“a+”</td><td>允许读和追加数据,如果文件不存在则创建</td></tr><tr><td>“rb+”</td><td>以读/写方式打开一个二进制文件</td></tr><tr><td>“wb+”</td><td>以读/写方式建立一个新的二进制文件</td></tr><tr><td>“ab+”</td><td>以读/写方式打开一个二进制文件进行追加</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "\\"这样的路径形式，只能在windows使用</span></span><br><span class="line"><span class="comment">// "/"这样的路径形式，windows和linux平台下都可用，建议使用这种</span></span><br><span class="line"><span class="comment">// 路径可以是相对路径，也可是绝对路径</span></span><br><span class="line">fp = fopen(<span class="string">"../test"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="comment">//fp = fopen("..\\test", "w");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) <span class="comment">//返回空，说明打开失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//perror()是标准出错打印函数，能打印调用库函数出错原因</span></span><br><span class="line">perror(<span class="string">"open"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。</span><br><span class="line">参数：</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值.</p><p><strong>文件读写函数回顾</strong></p><ul><li>按照字符读写文件：fgetc(), fputc()</li><li>按照行读写文件：fputs(), fgets()</li><li>按照块读写文件：fread(), fwirte()</li><li>按照格式化读写文件：fprintf(), fscanf()</li><li>按照随机位置读写文件：fseek(), ftell(), rewind()    </li></ul><p><strong>块读写函数回顾</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式给文件写入内容</span><br><span class="line">参数：</span><br><span class="line">ptr：准备写入文件数据的地址</span><br><span class="line">size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定写入文件内容的块数据大小</span><br><span class="line">nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功写入文件数据的块数，此值和nmemb相等</span><br><span class="line">失败：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式从文件中读取内容</span><br><span class="line">参数：</span><br><span class="line">ptr：存放读取出来数据的内存空间</span><br><span class="line">size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定读取文件内容的块数据大小</span><br><span class="line">nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于<span class="number">0</span>，说明读到文件的结尾。</span><br><span class="line">失败：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>格式化读写函数回顾</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件</span><br><span class="line">format：字符串格式，用法和<span class="built_in">printf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际写入文件的字符个数</span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件</span><br><span class="line">format：字符串格式，用法和<span class="built_in">scanf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际从文件中读取的字符个数</span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>fscanf遇到空格和换行时结束。</strong></p><h3 id="7-3-读写配置文件"><a href="#7-3-读写配置文件" class="headerlink" title="7.3 读写配置文件"></a>7.3 读写配置文件</h3><img src="/images/imageProgramC/文件读写案例.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> key[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">char</span> val[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span>&#123;</span></span><br><span class="line">FILE *fp; <span class="comment">//保存文件指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">list</span>;</span> <span class="comment">//保存配置信息</span></span><br><span class="line"><span class="keyword">int</span> lines; <span class="comment">//配置信息条数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_file</span><span class="params">(<span class="keyword">char</span> *path, struct config **myconfig)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == path)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以读写的方式打开文件</span></span><br><span class="line">FILE *fp = fopen(path, <span class="string">"r+"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> ==fp)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件打开失败!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置文件信息分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span> *<span class="title">conf</span> = (<span class="title">struct</span> <span class="title">config</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">config</span>));</span></span><br><span class="line">conf-&gt;fp = fp;</span><br><span class="line">conf-&gt;<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的间接赋值</span></span><br><span class="line">*myconfig = conf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计文件行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> lines = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="number">1024</span>, config-&gt;fp))&#123;</span><br><span class="line"><span class="comment">//如果是注释则不统计</span></span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'#'</span>)&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">lines++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将文件指针重置到开始位置</span></span><br><span class="line">fseek(config-&gt;fp,<span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得配置文件行数</span></span><br><span class="line">config-&gt;lines = count_file(config);</span><br><span class="line"><span class="comment">//给每一行配置信息分配内存</span></span><br><span class="line">config-&gt;<span class="built_in">list</span> = (struct info *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct info) * config-&gt;lines);</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="number">1024</span>, config-&gt;fp))&#123;</span><br><span class="line"><span class="comment">//去除每一行最后的\n字符</span></span><br><span class="line">buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">//如果是注释则不显示</span></span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'#'</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(config-&gt;<span class="built_in">list</span>[index].key, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">memset</span>(config-&gt;<span class="built_in">list</span>[index].val, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *delimit = <span class="built_in">strchr</span>(buf, <span class="string">':'</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(config-&gt;<span class="built_in">list</span>[index].key, buf, delimit - buf);</span><br><span class="line"><span class="built_in">strncpy</span>(config-&gt;<span class="built_in">list</span>[index].val, delimit + <span class="number">1</span>, <span class="built_in">strlen</span>(delimit + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span> , <span class="number">1024</span>);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">get_file</span><span class="params">(struct config *config, <span class="keyword">char</span> *key)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == key)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; config-&gt;lines;i ++)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(config-&gt;<span class="built_in">list</span>[i].key,key) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> config-&gt;<span class="built_in">list</span>[i].val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件指针</span></span><br><span class="line">fclose(config-&gt;fp);</span><br><span class="line">config-&gt;fp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//释放配置信息</span></span><br><span class="line"><span class="built_in">free</span>(config-&gt;<span class="built_in">list</span>);</span><br><span class="line">config-&gt;<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *path = <span class="string">"./my.ini"</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span> *<span class="title">conf</span> = <span class="title">NULL</span>;</span></span><br><span class="line">load_file(path, &amp;conf);</span><br><span class="line">parse_file(conf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"username"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"password"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"server_ip"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"server_port"</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"aaaa"</span>));</span><br><span class="line">destroy_file(conf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、链表"><a href="#八、链表" class="headerlink" title="八、链表"></a>八、链表</h2><h3 id="8-1-链表基本概念"><a href="#8-1-链表基本概念" class="headerlink" title="8.1 链表基本概念"></a>8.1 链表基本概念</h3><img src="/images/imageProgramC/链表.png"><ul><li>链表是一种常用的数据结构，它通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的动态性（<strong>非顺序存储</strong>）。</li><li>数据域用来存储数据，指针域用于建立与下一个结点的联系。</li><li>建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。</li><li><strong>链表的开销，主要是访问顺序性和组织链的空间损失</strong>。</li></ul><p><strong>数组和链表的区别</strong>：</p><ul><li><p>数组：一次性分配一块连续的存储区域。</p><p>优点：随机访问元素效率高</p><p>缺点：</p><ul><li>需要分配一块连续的存储区域（很大区域，有可能分配失败）</li><li>删除和插入某个元素效率低</li></ul></li><li><p>链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。</p><p>优点：</p><ul><li>不需要一块连续的存储区域</li><li>删除和插入某个元素效率高</li></ul><p>缺点：随机访问元素效率低</p></li></ul><h4 id="8-1-1-有关结构体的自身引用"><a href="#8-1-1-有关结构体的自身引用" class="headerlink" title="8.1.1 有关结构体的自身引用"></a>8.1.1 有关结构体的自身引用</h4><p>问题1：请问结构体可以嵌套本类型的结构体变量吗？</p><p>问题2：请问结构体可以嵌套本类型的结构体指针变量吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">Student stu; <span class="comment">//结构体可以嵌套其他类型的结构体</span></span><br><span class="line"><span class="comment">//Teacher stu;</span></span><br><span class="line"><span class="comment">//struct _TEACHER teacher; //此时Teacher类型的成员还没有确定，编译器无法分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>* <span class="title">teacher</span>;</span> <span class="comment">//不论什么类型的指针，都只占4个字节，编译器可确定内存分配</span></span><br><span class="line">&#125;Teacher;</span><br></pre></td></tr></table></figure><ul><li>结构体可以嵌套另外一个结构体的任何类型变量;</li><li><strong>结构体嵌套本结构体普通变量（不可以）</strong>。本结构体的类型大小无法确定，类型本质：固定大小内存块别名;</li><li><strong>结构体嵌套本结构体指针变量（可以）</strong>, 指针变量的空间能确定，32位， 4字节， 64位， 8字节;</li></ul><h4 id="8-1-2-链表节点"><a href="#8-1-2-链表节点" class="headerlink" title="8.1.2 链表节点"></a>8.1.2 <strong>链表节点</strong></h4><p>大家思考一下，我们说链表是由一系列的节点组成，那么如何表示一个包含了数据域和指针域的节点呢？</p><p><strong>链表的节点类型实际上是结构体变量，此结构体包含数据域和指针域</strong>：</p><ul><li><p>数据域用来存储数据；</p></li><li><p>指针域用于建立与下一个结点的联系，<strong>当此节点为尾节点时，指针域的值为NULL</strong>；</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>       </span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/链表-01.png"><h4 id="8-1-3-链表的分类"><a href="#8-1-3-链表的分类" class="headerlink" title="8.1.3 链表的分类"></a>8.1.3 链表的分类</h4><p>链表分为：</p><ul><li>静态链表</li><li>动态链表</li></ul><p>静态链表和动态链表是线性表链式存储结构的两种不同的表示方式：</p><ul><li><p>所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表称为“静态链表”。</p></li><li><p>所谓动态链表，是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。</p></li></ul><p><strong>静态链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化三个结构体变量</span></span><br><span class="line">Stu s1 = &#123; <span class="number">1</span>, <span class="string">"yuri"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">Stu s2 = &#123; <span class="number">2</span>, <span class="string">"lily"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">Stu s3 = &#123; <span class="number">3</span>, <span class="string">"lilei"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">s1.next = &amp;s2; <span class="comment">//s1的next指针指向s2</span></span><br><span class="line">s2.next = &amp;s3;</span><br><span class="line">s3.next = <span class="literal">NULL</span>; <span class="comment">//尾结点</span></span><br><span class="line"></span><br><span class="line">Stu *p = &amp;s1;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d, name = %s\n"</span>, p-&gt;id, p-&gt;name);</span><br><span class="line"><span class="comment">//结点往后移动一位</span></span><br><span class="line">p = p-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//动态分配3个节点</span></span><br><span class="line">Stu *s1 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">s1-&gt;id = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s1-&gt;name, <span class="string">"yuri"</span>);</span><br><span class="line"></span><br><span class="line">Stu *s2 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">s2-&gt;id = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s2-&gt;name, <span class="string">"lily"</span>);</span><br><span class="line"></span><br><span class="line">Stu *s3 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">s3-&gt;id = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s3-&gt;name, <span class="string">"lilei"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立节点的关系</span></span><br><span class="line">s1-&gt;next = s2; <span class="comment">//s1的next指针指向s2</span></span><br><span class="line">s2-&gt;next = s3;</span><br><span class="line">s3-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历节点</span></span><br><span class="line">Stu *p = s1;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d, name = %s\n"</span>, p-&gt;id, p-&gt;name);</span><br><span class="line"><span class="comment">//结点往后移动一位</span></span><br><span class="line">p = p-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点空间</span></span><br><span class="line">p = s1;</span><br><span class="line">Stu *tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">tmp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带头和不带头链表</strong></p><ul><li>带头链表：固定一个节点作为头结点(数据域不保存有效数据)，起一个标志位的作用，以后不管链表节点如何改变，此头结点固定不变。</li></ul><img src="/images/imageProgramC/链表-02.png"><ul><li>不带头链表：头结点不固定，根据实际需要变换头结点(如在原来头结点前插入新节点，然后，新节点重新作为链表的头结点)。</li></ul><img src="/images/imageProgramC/链表-03.png"><p><strong>单向链表、双向链表、循环链表</strong></p><ul><li>单向链表：</li></ul><img src="/images/imageProgramC/链表-04.png"><ul><li>双向链表：</li></ul><img src="/images/imageProgramC/链表-05.png"><ul><li>循环链表：</li></ul><img src="/images/imageProgramC/链表-06.png"><h3 id="8-2-链表基本操作"><a href="#8-2-链表基本操作" class="headerlink" title="8.2 链表基本操作"></a>8.2 链表基本操作</h3><h4 id="8-2-1-创建链表"><a href="#8-2-1-创建链表" class="headerlink" title="8.2.1 创建链表"></a>8.2.1 <strong>创建链表</strong></h4><p>使用结构体定义节点类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id; <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;link_node;</span><br></pre></td></tr></table></figure><p>编写函数：<code>link_node* init_linklist()</code></p><p>建立带有头结点的单向链表，循环创建结点，结点数据域中的数值从键盘输入，以 -1 作为输入结束标志，链表的头结点地址由函数值返回.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;link_node;</span><br><span class="line"></span><br><span class="line"><span class="function">link_node *<span class="title">init_linklist</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建头结点指针</span></span><br><span class="line">link_node* head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//给头结点分配内存</span></span><br><span class="line">head = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前节点</span></span><br><span class="line">link_node* p_current = head;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//循环向链表中插入节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input data:\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果输入-1，则退出循环</span></span><br><span class="line"><span class="keyword">if</span> (data == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给新节点分配内存</span></span><br><span class="line">link_node* newnode = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给节点赋值</span></span><br><span class="line">newnode-&gt;data = data;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//新节点入链表，也就是将节点插入到最后一个节点的下一个位置</span></span><br><span class="line">p_current-&gt;next = newnode;</span><br><span class="line"><span class="comment">//更新辅助指针p_current</span></span><br><span class="line">p_current = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-遍历链表"><a href="#8-2-2-遍历链表" class="headerlink" title="8.2.2 遍历链表"></a>8.2.2 遍历链表</h4><p>编写函数：<code>void foreach_linklist(link_node* head)</code></p><p>顺序输出单向链表各项结点数据域中的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foreach_linklist</span><span class="params">(link_node* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值指针变量</span></span><br><span class="line">link_node* p_current = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,p_current-&gt;data);</span><br><span class="line">p_current = p_current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-3-插入节点"><a href="#8-2-3-插入节点" class="headerlink" title="8.2.3 插入节点"></a>8.2.3 <strong>插入节点</strong></h4><p>编写函数: <code>void insert_linklist(link_node* head,int val,int data).</code></p><p>在指定值后面插入数据data,如果值val不存在，则在尾部插入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在值val前插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_linklist</span><span class="params">(link_node* head, <span class="keyword">int</span> val, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个辅助指针</span></span><br><span class="line">link_node* p_prev = head;</span><br><span class="line">link_node* p_current = p_prev-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (p_current-&gt;data == val)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">p_prev = p_current;</span><br><span class="line">p_current = p_prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果p_current为NULL，说明不存在值为val的节点</span></span><br><span class="line"><span class="keyword">if</span> (p_current == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在值为%d的节点!\n"</span>,val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建新的节点</span></span><br><span class="line">link_node* newnode = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line">newnode-&gt;data = data;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新节点入链表</span></span><br><span class="line">newnode-&gt;next = p_current;</span><br><span class="line">p_prev-&gt;next = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-4-删除节点"><a href="#8-2-4-删除节点" class="headerlink" title="8.2.4 删除节点"></a>8.2.4 <strong>删除节点</strong></h4><p>编写函数: <code>void remove_linklist(link_node* head,int val)</code></p><p>删除第一个值为val的结点.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除值为val的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_linklist</span><span class="params">(link_node* head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助指针</span></span><br><span class="line">link_node* p_prev = head;</span><br><span class="line">link_node* p_current = p_prev-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找值为val的节点</span></span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (p_current-&gt;data == val)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">p_prev = p_current;</span><br><span class="line">p_current = p_prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果p_current为NULL，表示没有找到</span></span><br><span class="line"><span class="keyword">if</span> (p_current == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除当前节点： 重新建立待删除节点(p_current)的前驱后继节点关系</span></span><br><span class="line">p_prev-&gt;next = p_current-&gt;next;</span><br><span class="line"><span class="comment">//释放待删除节点的内存</span></span><br><span class="line"><span class="built_in">free</span>(p_current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-5-销毁链表"><a href="#8-2-5-销毁链表" class="headerlink" title="8.2.5 销毁链表"></a>8.2.5 <strong>销毁链表</strong></h4><p>编写函数: <code>void destroy_linklist(link_node* head)</code></p><p>销毁链表，释放所有节点的空间.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_linklist</span><span class="params">(link_node* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值指针</span></span><br><span class="line">link_node* p_current = head;</span><br><span class="line"><span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//缓存当前节点下一个节点</span></span><br><span class="line">link_node* p_next = p_current-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p_current);</span><br><span class="line">p_current = p_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、函数指针"><a href="#九、函数指针" class="headerlink" title="九、函数指针"></a>九、函数指针</h2><h3 id="9-1-函数类型"><a href="#9-1-函数类型" class="headerlink" title="9.1 函数类型"></a>9.1 函数类型</h3><p>通过什么来区分两个不同的函数？</p><p>一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，<strong>函数名代表函数的入口地址</strong>。</p><p>函数三要素： 名称、参数、返回值。C语言中的函数有自己特定的类型。</p><p>c 语言中通过 typedef 为函数类型重命名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;<span class="comment">// f 为函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">// p 为函数类型</span></span><br></pre></td></tr></table></figure><p>这一点和数组一样，因此我们可以用一个指针变量来存放这个入口地址，然后通过该指针变量调用函数。</p><p><strong>注意：</strong>通过函数类型定义的变量是不能够直接执行，因为没有函数体。只能通过类型定义一个函数指针指向某一个具体函数，才能调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(p)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">p p1;</span><br><span class="line"><span class="comment">//p1(10,20); //错误，不能直接调用，只描述了函数类型，但是并没有定义函数体，没有函数体无法调用</span></span><br><span class="line">p* p2 = my_func;</span><br><span class="line">p2(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//正确，指向有函数体的函数入口地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-函数指针-指向函数的指针"><a href="#9-2-函数指针-指向函数的指针" class="headerlink" title="9.2 函数指针(指向函数的指针)"></a>9.2 函数指针(指向函数的指针)</h3><ul><li>函数指针定义方式(先定义函数类型，根据类型定义指针变量);</li><li>先定义函数指针类型，根据类型定义指针变量;</li><li>直接定义函数指针变量;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret:%d\n"</span>, a + b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 先定义函数类型，通过类型定义指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(FUNC_TYPE)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">FUNC_TYPE* f = my_func;</span><br><span class="line"><span class="comment">//如何调用？</span></span><br><span class="line">(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FUNC_POINTER)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">FUNC_POINTER f = my_func;</span><br><span class="line"><span class="comment">//如何调用？</span></span><br><span class="line">(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 直接定义函数指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>(*f)(<span class="keyword">int</span>, <span class="keyword">int</span>) = my_func;</span><br><span class="line"><span class="comment">//如何调用？</span></span><br><span class="line">(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-函数指针数组"><a href="#9-3-函数指针数组" class="headerlink" title="9.3 函数指针数组"></a>9.3 <strong>函数指针数组</strong></h3><p>函数指针数组，每个元素都是函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func01</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func01:%d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func02</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func02:%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func03</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func03:%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//定义函数指针</span></span><br><span class="line"><span class="keyword">void</span>(*func_array[])(<span class="keyword">int</span>) = &#123; func01, func02, func03 &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">void</span>(*func_array[<span class="number">3</span>])(<span class="keyword">int</span>);</span><br><span class="line">func_array[<span class="number">0</span>] = func01;</span><br><span class="line">func_array[<span class="number">1</span>] = func02;</span><br><span class="line">func_array[<span class="number">2</span>] = func03;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)&#123;</span><br><span class="line">func_array[i](<span class="number">10</span> + i);</span><br><span class="line">(*func_array[i])(<span class="number">10</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-函数指针做函数参数-回调函数"><a href="#9-4-函数指针做函数参数-回调函数" class="headerlink" title="9.4 函数指针做函数参数(回调函数)"></a>9.4 <strong>函数指针做函数参数(回调函数)</strong></h3><p>函数参数除了是普通变量，还可以是函数指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参为普通变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">int</span> x )</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//形参为函数指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">int</span>(*p)(<span class="keyword">int</span> a) )</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>函数指针变量常见的用途之一是把指针作为参数传递到其他函数，指向函数的指针也可以作为参数，以实现函数地址的传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caculator</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>(*func)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> func(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FUNC_POINTER)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caculator</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, FUNC_POINTER func)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> func(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>函数指针和指针函数的区别：</p><ul><li><p>函数指针是指向函数的指针；</p></li><li><p>指针函数是返回类型为指针的函数；</p></li></ul><h2 id="十、预处理"><a href="#十、预处理" class="headerlink" title="十、预处理"></a>十、预处理</h2><h3 id="10-1-预处理的基本概念"><a href="#10-1-预处理的基本概念" class="headerlink" title="10.1 预处理的基本概念"></a>10.1 预处理的基本概念</h3><p>C 语言对源程序处理的四个步骤：<strong>预处理、编译、汇编、链接</strong>。</p><p>预处理是在程序源代码被编译之前，由预处理器（Preprocessor）对程序源代码进行的处理。这个过程并不对程序的源代码语法进行解析，但它会把源代码分割或处理成为特定的符号为下一步的编译做准备工作。</p><h3 id="10-2-文件包含指令-include"><a href="#10-2-文件包含指令-include" class="headerlink" title="10.2 文件包含指令(#include)"></a>10.2 文件包含指令(#include)</h3><p>“文件包含处理”是指一个源文件可以将另外一个文件的全部内容包含进来。Ｃ语言提供了 #include 命令用来实现“文件包含”的操作。</p><p><strong>#incude&lt;&gt; 和 #include”” 区别</strong></p><ul><li><p><strong>“”</strong> 表示系统先在 file1.c 所在的当前目录找 file1.h，如果找不到，再按系统指定的目录检索。</p></li><li><p><strong>&lt; &gt;</strong> 表示系统直接按系统指定的目录检索。</p></li></ul><p>注意：</p><p>​    1. #include &lt;&gt; 常用于包含库函数的头文件；</p><p>​    2. #include “” 常用于包含自定义的头文件；</p><p>​    3. 理论上 #include 可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含；</p><h3 id="10-3-宏定义"><a href="#10-3-宏定义" class="headerlink" title="10.3 宏定义"></a>10.3 宏定义</h3><h4 id="10-3-1-无参数的宏定义-宏常量"><a href="#10-3-1-无参数的宏定义-宏常量" class="headerlink" title="10.3.1 无参数的宏定义(宏常量)"></a>10.3.1 无参数的宏定义(宏常量)</h4><p>如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为：</p><p>const int num = 100; 但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用：</p><p>#define num 100</p><p>在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。<strong>宏定义，只在宏定义的文件中起作用</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> r = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">double</span> s = PI * r * r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s = %lf\n"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>1)宏名一般用大写，以便于与变量区别；</p></li><li><p>2) 宏定义可以是常数、表达式等；</p></li><li><p>3) 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错；</p></li><li><p>4) 宏定义不是C语言，不在行末加分号；</p></li><li><p>5) <strong>宏名有效范围为从定义到本源文件结束</strong>；</p></li><li><p>6) <strong>可以用#undef命令终止宏定义的作用域</strong>；</p></li><li><p>7) 在宏定义中，可以引用已定义的宏名；</p></li></ul><h4 id="10-3-2-带参数的宏定义-宏函数"><a href="#10-3-2-带参数的宏定义-宏函数" class="headerlink" title="10.3.2 带参数的宏定义(宏函数)"></a>10.3.2 带参数的宏定义(宏函数)</h4><p>在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。</p><p>宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(x,y) ((x)+(y))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//仅仅只是做文本替换 下例替换为 int ret = ((10)+(20));</span></span><br><span class="line"><span class="comment">//不进行计算</span></span><br><span class="line"><span class="keyword">int</span> ret = SUM(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret:%d\n"</span>,ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p>1) 宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格；</p></li><li><p>2) 用括号括住每一个参数，并括住宏的整体定义。</p></li><li><p>3) 用大写字母表示宏的函数名。</p></li><li><p>4) 如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。</p></li></ul><h3 id="10-4-条件编译"><a href="#10-4-条件编译" class="headerlink" title="10.4 条件编译"></a>10.4 条件编译</h3><p>一般情况下，源程序中所有的行都参加编译。但有时希望对部分源程序行只在满足一定条件时才编译，即对这部分源程序行指定编译条件。</p><img src="/images/imageProgramC/条件编译.png"><p><strong>条件编译</strong></p><ul><li>防止头文件被重复包含引用；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SOMEFILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SOMEFILE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要声明的变量、函数</span></span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="10-5-一些特殊的预定宏"><a href="#10-5-一些特殊的预定宏" class="headerlink" title="10.5 一些特殊的预定宏"></a>10.5 <strong>一些特殊的预定宏</strong></h3><p>C 编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__FILE__宏所在文件的源文件名 </span></span><br><span class="line"><span class="comment">//__LINE__宏所在行的行号</span></span><br><span class="line"><span class="comment">//__DATE__代码编译的日期</span></span><br><span class="line"><span class="comment">//__TIME__代码编译的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __FILE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, __LINE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __DATE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __TIME__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、动态库的封装和使用"><a href="#十一、动态库的封装和使用" class="headerlink" title="十一、动态库的封装和使用"></a>十一、动态库的封装和使用</h2><h3 id="11-1-库的基本概念"><a href="#11-1-库的基本概念" class="headerlink" title="11.1 库的基本概念"></a>11.1 库的基本概念</h3><p>库是已经写好的、成熟的、可复用的代码。每个程序都需要依赖很多底层库，不可能每个人的代码从零开始编写代码，因此库的存在具有非常重要的意义。</p><p>在我们的开发的应用中经常有一些公共代码是需要反复使用的，就把这些代码编译为库文件。</p><p>库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。像在Windows这样的平台上，最常用的 c 语言库是由集成按开发环境所附带的运行库，这些库一般由编译厂商提供。</p><p>库：就是已经编写好的，后续可以直接使用的代码。</p><p>c++静态库：会合入到最终生成的程序，<strong>使得结果文件比较大</strong>。优点是不再有任何依赖。</p><p>c++动态库：动态库，<strong>一个文件可以多个代码同时使用内存中只有一份，节省内存</strong>，可以随主代码一起编译。缺点是需要头文件。</p><p><strong>网友说：库就是除了main函数之外的其他代码，都可以组成库</strong>。</p><h3 id="11-2-静态库优缺点"><a href="#11-2-静态库优缺点" class="headerlink" title="11.2 静态库优缺点"></a>11.2 静态库优缺点</h3><ul><li><p><strong>静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系</strong>；</p></li><li><p>程序在运行时与函数库再无瓜葛，移植方便。</p></li><li><p><strong>浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</strong>。</p></li></ul><p><strong>内存和磁盘空间</strong></p><ul><li>静态链接这种方法很简单，原理上也很容易理解，在操作系统和硬件不发达的早期，绝大部门系统采用这种方案。随着计算机软件的发展，这种方法的缺点很快暴露出来，那就是静态链接的方式对于计算机内存和磁盘空间浪费非常严重。特别是多进程操作系统下，静态链接极大的浪费了内存空间。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。</li></ul><p><strong>程序开发和发布</strong></p><ul><li>空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也会带来很多麻烦。比如程序中所使用的mylib.lib是由一个第三方厂商提供的，当该厂商更新容量mylib.lib的时候，那么我们的程序就要拿到最新版的mylib.lib，然后将其重新编译链接后，将新的程序整个发布给用户。这样的做缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。</li></ul><p>要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，<strong>把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想</strong>。</p><h3 id="11-3-Linux-下-gcc-编译器生成和使用静态库和动态库"><a href="#11-3-Linux-下-gcc-编译器生成和使用静态库和动态库" class="headerlink" title="11.3 Linux 下 gcc 编译器生成和使用静态库和动态库"></a>11.3 Linux 下 gcc 编译器生成和使用静态库和动态库</h3><p>我们通常把一些公用函数制作成函数库，供其它程序使用。函数库分为静态库和动态库两种。</p><ul><li><p>静态库<strong>在程序编译时会被链接并拷贝到目标代码中，程序运行时将不再需要该静态库</strong>。</p></li><li><p>动态库<strong>在程序编译时并不会被拷贝到目标代码中，而是在程序运行时才被载入</strong>，因此在程序运行时还需要动态库存在。本质上说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。</p></li></ul><p>windows 和 linux 库的二进制是不兼容的（主要是编译器、汇编器和连接器的不同）。</p><h4 id="11-3-1-基本概念"><a href="#11-3-1-基本概念" class="headerlink" title="11.3.1 基本概念"></a>11.3.1 基本概念</h4><p><strong>库的种类</strong>：</p><p>linux下的库有两种：</p><ul><li>静态库</li><li>共享库（动态库）。</li></ul><p>二者区别在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。</p><p><strong>库文件是如何产生的</strong>：</p><p>静态库的后缀是 <code>.a</code>，它的产生分两步:</p><ul><li><p>Step 1. 由源文件编译生成一堆 <code>.o</code>，每个 <code>.o</code> 里都包含这个编译单元的符号表</p></li><li><p>Step 2. ar 命令将很多 <code>.o</code> 转换成 <code>.a</code>，成为静态库</p></li></ul><p>动态库的后缀是 <code>.so</code>，它由 gcc 加特定参数编译产生。</p><p><strong>库文件命名规范</strong>：</p><p>库文件一般放在 <code>/usr/local/lib</code>，<code>/usr/lib</code>，<code>/lib</code>，或者其他自定义的 <code>lib</code> 下。</p><ul><li><p>静态库的名字一般为 <code>libxxxx.a</code>，其中 <code>xxxx</code> 是该 <code>lib</code> 的名称</p></li><li><p>动态库的名字一般为 <code>libxxxx.so.major.minor</code>， <code>xxxx</code> 是该 <code>lib</code> 的名称，<code>major</code> 是主版本号， <code>minor</code> 是副版本号</p></li></ul><p><strong>如何知道一个可执行程序依赖哪些库</strong>：</p><p><code>ldd</code> 命令可以查看一个可执行程序依赖的共享库，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd /lib/i386-linux-gnu/libc.so.6</span></span><br><span class="line">/lib/ld-linux.so.2 (0xf7740000)</span><br><span class="line">linux-gate.so.1 =&gt;  (0xf773f000)</span><br></pre></td></tr></table></figure><p>可以看到 <code>libc</code> 命令依赖于 <code>linux-gate</code> 库和 <code>ld-linux</code> 库</p><p><strong>可执行程序在执行的时候如何定位共享库文件</strong>：</p><p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(<code>dynamic linker/loader</code>)</p><p>对于 <code>elf</code> 格式的可执行程序，是由 <code>ld-linux.so*</code> 来完成的，它先后搜索 <code>elf</code> 文件的 <code>DT_RPATH</code> 段—环境变量 <code>LD_LIBRARY_PATH—/etc/ld.so.cache</code> 文件列表— <code>/lib/,/usr/lib</code> 目录找到库文件后将其载入内存</p><p>如：<code>export LD_LIBRARY_PATH=’pwd’</code></p><p>将当前文件目录添加为共享目录</p><p><strong>在新安装一个库之后如何让系统能够找到他</strong>：</p><p>如果安装在 <code>/lib</code> 或者 <code>/usr/lib</code> 下，那么 <code>ld</code> 默认能够找到，无需其他操作。如果安装在其他目录，需要将其添加到 <code>/etc/ld.so.cache</code> 文件中，步骤如下：</p><ol><li><p>编辑 <code>/etc/ld.so.conf</code> 文件，加入库文件所在目录的路径</p></li><li><p>运行 <code>ldconfig</code>，该命令会重建 <code>/etc/ld.so.cache</code> 文件</p></li></ol><h4 id="11-3-2-用-gcc-生成静态和动态链接库的示例"><a href="#11-3-2-用-gcc-生成静态和动态链接库的示例" class="headerlink" title="11.3.2 用 gcc 生成静态和动态链接库的示例"></a>11.3.2 用 gcc 生成静态和动态链接库的示例</h4><p>假设有1个类 hello，和一个 main 函数。如下：</p><p><strong>hello.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HELLO_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_H </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>hello.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    hello(<span class="string">"world!"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello.c 是一个没有 main 函数的 <code>.c</code> 程序，因此不够成一个完整的程序，如果使用 <code>gcc –o</code> 编译并连接它，<code>gcc</code> 将报错，无法通过编译。</p><p>前面提过，无论静态库，还是动态库，都是由 <code>.o</code>文件创建的。那么我们如何才能让 main.c 调用 hello 类呢？也就是说该如何才能将 hello.c 通过 gcc 先编译成 <code>.o</code> 文件，并且让 main.c 在编译时能找到它？有三种途径可以实现：</p><ul><li><p>1）通过编译多个源文件，直接将目标代码合成一个 <code>.o</code> 文件。</p></li><li><p>2）通过创建静态链接库 <code>libmyhello.a</code>，使得 main 函数调用 hello 函数时可调用静态链接库。</p></li><li><p>3）通过创建动态链接库 <code>libmyhello.so</code>，使得 main 函数调用 hello 函数时可调用动态链接库。</p></li></ul><h5 id="11-3-2-1-途径一：编译多个源文件"><a href="#11-3-2-1-途径一：编译多个源文件" class="headerlink" title="11.3.2.1 途径一：编译多个源文件"></a>11.3.2.1 途径一：编译多个源文件</h5><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c main.c</span></span><br></pre></td></tr></table></figure><p>这里提醒一下：<code>gcc –o</code> 是将 <code>.c</code> 源文件编译成为一个可执行的二进制代码。而 <code>gcc –c</code> 是使用GNU汇编器将源文件转化为目标代码。更多 gcc 编译选项的常识点<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FyYWNrZXRoaXMvYXJ0aWNsZS9kZXRhaWxzLzQzMzcwMzA3" title="https://blog.csdn.net/arackethis/article/details/43370307">这里<i class="fa fa-external-link"></i></span>。</p><p>这时可以看到生成了 hello.o 和 main.o 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c  main.o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将两个文件链接成一个 `.o` 文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看此时已经生成了可执行文件sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c  main.o  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure><h5 id="11-3-2-2-途径二：静态链接库"><a href="#11-3-2-2-途径二：静态链接库" class="headerlink" title="11.3.2.2 途径二：静态链接库"></a>11.3.2.2 途径二：静态链接库</h5><p>静态库文件名是以 lib 为前缀，紧接着是静态库名，扩展名为 <code>.a</code>。例如：我们将创建的静态库名为myhello，则静态库文件名就是 <code>libmyhello.a</code> 。创建静态库用 <code>ar</code> 命令。</p><p>删除途径一中生成的3个文件，回到原始的三个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm hello.o main.o sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始尝试途径二，创建静态库文件libmyhello.a：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs libmyhello.a hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下已经生成了：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  libmyhello.a  main.c</span><br></pre></td></tr></table></figure><p>静态库制作完了，如何使用它内部的函数呢？</p><p><strong>只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明，然后在用 gcc 命令生成目标文件时指明静态库名，gcc 将会从静态库中将公用函数连接到目标文件中</strong>。</p><p><strong>注意</strong>，gcc 会在静态库名前加上前缀 lib，然后追加扩展名 <code>.a</code> 得到的静态库文件名来查找静态库文件。</p><p>因此，我们在写需要连接的库时，只写静态库名就可以，如 <code>libmyhello.a</code> 的库，只写: <code>-lmyhello</code><br>在 main.c 中，我们已包含了该静态库的头文件 hello.h。现在在主程序 main.c 中直接调用它内部的函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里-L.告诉 gcc 先在当前目录下查找库文件。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.c -static -L. -lmyhello       </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下，已经生成可执行文件sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  libmyhello.a  main.c  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure><p>前面提过静态库在编译过程中会被拷贝到目标程序中，运行时不再需要静态库的存在。这里可以简单验证一下：我们删除静态库文件，然后再试着调用函数 hello 看是否还能调用成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm libmyhello.a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure><p>程序照常运行，静态库中的函数已经被复制到目标程序中了，编译完成后，静态库就没用了，执行时不再需要静态库的存在。</p><p><strong>静态链接库的一个缺点是</strong>：</p><ul><li>如果我们同时运行了许多程序，并且它们使用了同一个库函数，这样，在内存中会大量拷贝同一库函数。这样，就会浪费内存和存储空间。</li></ul><p>使用了共享链接库的Linux就可以避免这个问题。共享函数库和静态函数在同一个地方，只是后缀不同。比如，在Linux系统，标准的共享数序函数库是 <code>/usr/lib/libm.so</code>。<strong>当一个程序使用共享函数库时，在连接阶段并不把函数代码连接进来，而只是链接函数的一个引用。当最终的函数导入内存开始真正执行时，函数引用被解析，共享函数库的代码才真正导入到内存中</strong>。这样，共享链接库的函数就可以被许多程序同时共享，并且只需存储一次就可以了。<strong>共享函数库的另一个优点是，它可以独立更新，与调用它的函数毫不影响</strong>。</p><h5 id="11-3-2-3-途径三：动态链接库（共享函数库）"><a href="#11-3-2-3-途径三：动态链接库（共享函数库）" class="headerlink" title="11.3.2.3 途径三：动态链接库（共享函数库）"></a>11.3.2.3 途径三：动态链接库（共享函数库）</h5><p>动态库文件名和静态库类似，也是在动态库名增加前缀 lib，但其文件扩展名为 <code>.so</code>。例如：我们将创建的动态库名为 myhello，则动态库文件名就是 <code>libmyhello.so</code> 。用 gcc 来创建动态库。</p><p>删除途径二中生成的2个文件，回到原始的三个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm hello.o sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始尝试途径三，创建静态库文件libmyhello.so：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按教程里，会报错：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -fPIC -o libmyhello.so hello.o</span></span><br><span class="line">/usr/bin/ld: hello.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC</span><br><span class="line">hello.o: could not read symbols: Bad value</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>正确方法是，这样就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared -o libmyhello.so hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 已生成libmyhello.so，是绿色。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  libmyhello.so  main.c</span><br></pre></td></tr></table></figure><p>最主要的是 GCC 命令行的选项:</p><ul><li><p><code>-shared</code>：指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件</p></li><li><p><code>-fPIC</code>：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。</p></li></ul><p>下面调用该动态链接库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.c -L. -lmyhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  libmyhello.so  main.c  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br><span class="line">成功！</span><br></pre></td></tr></table></figure><p>按教程里说的：他以这种方式调用动态链接库出错，找不到动态库文件 <code>libmyhello.so</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sayhello: error while loading shared libraries: libmyhello.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>程序在运行时，会在 /usr/lib 和 /lib 等目录中查找需要的动态库文件。若找到，则载入动态库，否则将提示类似上述错误而终止程序运行。解决此类问题有如下三种方法：</p><ul><li><p>（1）我们将文件 libmyhello.so复制到目录/usr/lib中。</p></li><li><p>（2）既然连接器会搜寻LD_LIBRARY_PATH所指定的目录，那么我们只要将当前目录添加到环境变量：</p><p><code>export LD_LIBRARY_PATH=$(pwd)</code></p></li><li><p>（3）执行： <code>ldconfig /usr/zhsoft/lib</code></p></li></ul><p>说明：当用户在某个目录下面创建或拷贝了一个动态链接库，若想使其被系统共享，可以执行一下 “ldconfig 目录名” 这个命令。此命令的功能在于让 ldconfig 将指定目录下的动态链接库被系统共享起来，意即：在缓存文件 <code>/etc/ld.so.cache</code> 中追加进指定目录下的共享库。该命令会重建 <code>/etc/ld.so.cache</code> 文件。</p><p>参考教程：</p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlheW91eGpoL2FydGljbGUvZGV0YWlscy83NjAyNzI5" title="http://blog.csdn.net/jiayouxjh/article/details/7602729">http://blog.csdn.net/jiayouxjh/article/details/7602729<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzU0ZjgyY2MyMDEwMTE1M3guaHRtbA==" title="http://blog.sina.com.cn/s/blog_54f82cc20101153x.html">http://blog.sina.com.cn/s/blog_54f82cc20101153x.html<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25hdnlhaWptLmJsb2cuNTFjdG8uY29tLzQ2NDcwNjgvODA5NDI0" title="http://navyaijm.blog.51cto.com/4647068/809424">http://navyaijm.blog.51cto.com/4647068/809424<i class="fa fa-external-link"></i></span></p><h2 id="十二、递归函数"><a href="#十二、递归函数" class="headerlink" title="十二、递归函数"></a>十二、递归函数</h2><h3 id="12-1-递归函数基本概念"><a href="#12-1-递归函数基本概念" class="headerlink" title="12.1 递归函数基本概念"></a>12.1 <strong>递归函数基本概念</strong></h3><p>C通过运行时堆栈来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。</p><h3 id="12-2-普通函数调用"><a href="#12-2-普通函数调用" class="headerlink" title="12.2 普通函数调用"></a>12.2 普通函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funB</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b = %d\n"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">funB(a - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">funA(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用流程如下：</p><img src="/images/imageProgramC/递归函数.png"><h3 id="12-3-递归函数调用"><a href="#12-3-递归函数调用" class="headerlink" title="12.3 递归函数调用"></a>12.3 递归函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//中断函数很重要</span></span><br><span class="line">&#125;</span><br><span class="line">fun(a - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">fun(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用流程如下：</p><img src="/images/imageProgramC/递归函数-01.png"><p><strong>递归实现给出一个数8793，依次打印千位数字8、百位数字7、十位数字9、个位数字3。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (val == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret = val / <span class="number">10</span>;</span><br><span class="line">recursion(ret);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,val % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-递归实现字符串反转"><a href="#12-4-递归实现字符串反转" class="headerlink" title="12.4 递归实现字符串反转"></a>12.4 递归实现字符串反转</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse1</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">'\0'</span>) &#123;  <span class="comment">// 函数递归调用结束条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse1(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, *str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( *str == <span class="string">'\0'</span> ) &#123;<span class="comment">// 函数递归调用结束条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse2(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strncat</span>(buf, str, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse3</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> *dst)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span> || dst == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">'\0'</span>) &#123;<span class="comment">// 函数递归调用结束条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse3(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strncat</span>(dst, str, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-递归实现链表逆序打印"><a href="#12-5-递归实现链表逆序打印" class="headerlink" title="12.5 递归实现链表逆序打印"></a>12.5 递归实现链表逆序打印</h3><p>TODO</p><h2 id="十三、面向接口编程"><a href="#十三、面向接口编程" class="headerlink" title="十三、面向接口编程"></a>十三、面向接口编程</h2><h3 id="13-1-案例背景"><a href="#13-1-案例背景" class="headerlink" title="13.1 案例背景"></a>13.1 案例背景</h3><p>一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。</p><h3 id="13-2-案例需求"><a href="#13-2-案例需求" class="headerlink" title="13.2 案例需求"></a>13.2 案例需求</h3><p>要求在企业信息系统框架中集成第三方厂商的socket通信产品和第三方厂商加密产品。软件设计要求：模块要求松、接口要求紧。</p><h3 id="13-3-案例要求"><a href="#13-3-案例要求" class="headerlink" title="13.3 案例要求"></a>13.3 案例要求</h3><ul><li><p>1）能支持多个厂商的 socket 通信产品入围</p></li><li><p>2）能支持多个第三方厂商加密产品的入围</p></li><li><p>3）企业信息系统框架不轻易发生框架</p></li></ul><h3 id="13-4-编程提示"><a href="#13-4-编程提示" class="headerlink" title="13.4 编程提示"></a>13.4 编程提示</h3><ul><li><p>1）抽象通信接口结构体设计（CSocketProtocol）</p></li><li><p>2）框架接口设计（framework）</p></li><li><p>3）   a) 通信厂商1入围（CSckImp1）  b) 通信厂商2入围（CSckImp2）</p></li><li><p>4）   a) 抽象加密接口结构体设计（CEncDesProtocol） b) 升级框架函数（增加加解密功能）  c) 加密厂商1入围(CHwImp)、加密厂商2入围(CCiscoImp)</p></li><li><p>5）框架接口分文件</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-语言进阶&quot;&gt;&lt;a href=&quot;#C-语言进阶&quot; class=&quot;headerlink&quot; title=&quot;C 语言进阶&quot;&gt;&lt;/a&gt;C 语言进阶&lt;/h1&gt;&lt;h2 id=&quot;一、-内存分区&quot;&gt;&lt;a href=&quot;#一、-内存分区&quot; class=&quot;headerlink&quot; title=&quot;一、 内存分区&quot;&gt;&lt;/a&gt;一、 内存分区&lt;/h2&gt;&lt;p&gt;栈区&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>C 基础</title>
    <link href="http://miaopei.github.io/2016/05/10/Program-C/program-c/"/>
    <id>http://miaopei.github.io/2016/05/10/Program-C/program-c/</id>
    <published>2016-05-10T02:14:50.000Z</published>
    <updated>2019-06-14T06:12:55.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C 语言基础"></a>C 语言基础</h1><h2 id="一、C-语言概述"><a href="#一、C-语言概述" class="headerlink" title="一、C 语言概述"></a>一、C 语言概述</h2><a id="more"></a><img src="/images/imageProgramC/03_C语言概述.png"><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><img src="/images/imageProgramC/04_数据类型.png"><h2 id="三、字符串处理和函数"><a href="#三、字符串处理和函数" class="headerlink" title="三、字符串处理和函数"></a>三、字符串处理和函数</h2><ul><li><p>声明变量不需要建立存储空间，如：extern int a;</p></li><li><p>定义变量需要建立存储空间，如：int b;</p></li><li><p>全局数组若不初始化，编译器将其初始化为零。局部数组若不初始化，内容为随机值。</p></li><li><p>数字 0 (和字符 ‘\0’ 等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。</p></li></ul><p>gets(str)与scanf(“%s”,str)的区别：</p><ul><li><p>gets(str)允许输入的字符串含有空格</p></li><li><p>scanf(“%s”,str)不允许含有空格</p></li><li><p>注意：由于scanf()和gets()无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字符数组越界(缓冲区溢出)的情况。</p></li></ul><p>gets() 、puts()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">功能：从标准输入读入字符，并保存到s指定的内存空间，直到出现换行符或读到文件结尾为止。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">功能：标准设备输出s字符串，在输出完成后自动输出一个<span class="string">'\n'</span>。</span><br></pre></td></tr></table></figure><p>fgets() 、fputs()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line">功能：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - <span class="number">1</span>个字符为止，最后会自动加上字符 <span class="string">'\0'</span> 作为字符串结束。</span><br><span class="line">fgets()在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。通过<span class="built_in">scanf</span>和gets输入一个字符串的时候，不包含结尾的“\n”，但通过fgets结尾多了“\n”。fgets()函数是安全的，不存在缓冲区溢出的问题。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, FILE * stream)</span></span>;</span><br><span class="line">功能：将str所指定的字符串写入到stream指定的文件中， 字符串结束符 <span class="string">'\0'</span>  不写入文件。</span><br><span class="line"><span class="built_in">fputs</span>()是<span class="built_in">puts</span>()的文件操作版本，但<span class="built_in">fputs</span>()不会自动输出一个<span class="string">'\n'</span>。</span><br></pre></td></tr></table></figure><p>strlen() 、strcpy() 、strncpy() 、strcat() 、strncat() 、strcmp() 、strncmp() 、sprintf() 、sscanf() 、strchr() 、strstr() 、strtok() 、atoi()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">功能：计算指定指定字符串s的长度，不包含字符串结束符‘\<span class="number">0</span>’</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br><span class="line">功能：把src所指向的字符串复制到dest所指向的空间中，<span class="string">'\0'</span>也会拷贝过去</span><br><span class="line">注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含<span class="string">'\0'</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br><span class="line">功能：将src字符串连接到dest的尾部，‘\<span class="number">0</span>’也会追加过去</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：将src字符串前n个字符连接到dest的尾部，‘\<span class="number">0</span>’也会追加过去</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line">功能：比较 s1 和 s2 的大小，比较的是字符ASCII码大小。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *_CRT_SECURE_NO_WARNINGS, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line">功能：在字符串s中查找字母c出现的位置</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle)</span></span>;</span><br><span class="line">功能：在字符串haystack中查找字符串needle出现的位置</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *delim)</span></span>;</span><br><span class="line">功能：来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\<span class="number">0</span> 字符，当连续出现多个时只替换第一个为\<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br><span class="line">功能：atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(<span class="string">'\0'</span>)才结束转换，并将结果返回返回值。</span><br><span class="line">类似的函数有：</span><br><span class="line">- atof()：把一个小数形式的字符串转化为一个浮点数。</span><br><span class="line">- atol()：将一个字符串转化为<span class="keyword">long</span>类型</span><br></pre></td></tr></table></figure><p>形参列表</p><ul><li>在定义函数时指定的形参，<strong>在未出现函数调用时，它们并不占内存中的存储单元</strong>，因此称它们是形式参数或虚拟参数，简称形参，表示它们并不是实际存在的数据，所以，形参里的变量不能赋值。</li></ul><p>如果函数返回的类型和return语句中表达式的值不一致，则以函数返回类型为准，即<strong>函数返回类型决定返回值的类型</strong>。对数值型数据，可以自动进行类型转换。</p><p><strong>注意</strong>：如果函数返回的类型和return语句中表达式的值不一致，而它又无法自动进行类型转换，程序则会报错。</p><p><strong>当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</strong> </p><p><strong>extern告诉编译器这个变量或函数在其他文档里已被定义了。</strong></p><p>static法则：</p><ul><li>A、若全局变量仅在单个C文档中访问，则能够将这个变量修改为静态全局变量，以降低模块间的耦合度; </li><li>B、若全局变量仅由单个函数访问，则能够将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； </li><li>C、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多文件编译</span></span><br><span class="line">gcc -o 可执行程序 文件<span class="number">1.</span>c 文件<span class="number">2.</span>c 头文件.h</span><br></pre></td></tr></table></figure><h2 id="四、指针和指针变量"><a href="#四、指针和指针变量" class="headerlink" title="四、指针和指针变量"></a>四、指针和指针变量</h2><ul><li><strong>内存区的每一个字节都有一个编号，这就是“地址”</strong>。</li><li>如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)</li><li>指针的实质就是内存“地址”。指针就是地址，地址就是指针。</li><li><strong>指针是内存单元的编号，指针变量是存放地址的变量</strong>。</li><li>通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。</li><li>指针也是一种数据类型，指针变量也是一种变量</li><li>指针变量指向谁，就把谁的地址赋值给指针变量</li><li><strong>“*” 操作符操作的是指针变量指向的内存空间</strong></li></ul><p>指针大小</p><ul><li><strong>使用sizeof()测量指针的大小，得到的总是：4或8</strong></li><li>sizeof()测的是指针变量指向存储地址的大小</li><li>在32位平台，所有的指针（地址）都是32位(4字节)</li><li>在64位平台，所有的指针（地址）都是64位(8字节)</li></ul><p>野指针和空指针</p><ul><li>指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，<strong>任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针</strong>，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，<strong>野指针不会直接引发错误，操作野指针指向的内存区域才会出问题</strong>。</li><li>但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。</li><li>NULL是一个值为0的宏常量：<code>#define NULL    ((void *)0)</code></li></ul><p>万能指针 <code>void *</code></p><p><code>void *</code> 指针可以指向任意变量的内存空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">p = (<span class="keyword">void</span> *)&amp;a; <span class="comment">//指向变量时，最好转换为void *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指针变量指向的内存时，转换为int *</span></span><br><span class="line">*( (<span class="keyword">int</span> *)p ) = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br></pre></td></tr></table></figure><p>const修饰的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向常量的指针</span></span><br><span class="line"><span class="comment">//修饰*，指针指向内存区域不能修改，指针指向可以变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a; <span class="comment">//等价于int const *p1 = &amp;a;</span></span><br><span class="line"><span class="comment">//*p1 = 111; //err</span></span><br><span class="line">p1 = &amp;b; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//修饰p1，指针指向不能变，指针指向的内存可以修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; //err</span></span><br><span class="line">*p2 = <span class="number">222</span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>指针操作数组元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf("%d, ", a[i]);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(a+i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a; <span class="comment">//定义一个指针变量保存a的地址</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(p + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针加减运算</p><ul><li>指针计算不是简单的整数相加</li><li>如果是一个<code>int *</code>，+1的结果是增加一个int的大小</li><li>如果是一个<code>char *</code>，+1的结果是增加一个char大小</li></ul><p>通过改变指针指向操作数组元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *p);</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针数组</p><ul><li>指针数组，它是数组，数组的每个元素都是指针类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//指针数组</span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>] = &amp;a;</span><br><span class="line">p[<span class="number">1</span>] = &amp;b;</span><br><span class="line">p[<span class="number">2</span>] = &amp;c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(p[<span class="number">0</span>]); i++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(p[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多级指针 </p><ul><li>C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针。</li><li>二级指针就是指向一个一级指针变量地址的指针。</li><li>三级指针基本用不着，但考试会考。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">//一级指针</span></span><br><span class="line">*p = <span class="number">100</span>; <span class="comment">//*p就是a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **q = &amp;p;</span><br><span class="line"><span class="comment">//*q就是p</span></span><br><span class="line"><span class="comment">//**q就是a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ***t = &amp;q;</span><br><span class="line"><span class="comment">//*t就是q</span></span><br><span class="line"><span class="comment">//**t就是p</span></span><br><span class="line"><span class="comment">//***t就是a</span></span><br></pre></td></tr></table></figure><p>数组名做函数参数</p><ul><li>数组名做函数参数，函数的形参会退化为指针：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void printArrary(int a[10], int n)</span></span><br><span class="line"><span class="comment">//void printArrary(int a[], int n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArrary</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组名做函数参数</span></span><br><span class="line">printArrary(a, n); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针做为函数的返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*( getA() ) = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针和字符串</p><ul><li>字符指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = str;</span><br><span class="line">*p = <span class="string">'m'</span>;</span><br><span class="line">p++;</span><br><span class="line">*p = <span class="string">'i'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);  <span class="comment">// millo world</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">"mike jiang"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p); <span class="comment">// mike jiang</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *q = <span class="string">"test"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, q); <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const修饰的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//const修饰一个变量为只读</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//a = 100; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量， 指针指向的内存， 2个不同概念</span></span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"aklgjdlsgjlkds"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从左往右看，跳过类型，看修饰哪个字符</span></span><br><span class="line"><span class="comment">//如果是*， 说明指针指向的内存不能改变</span></span><br><span class="line"><span class="comment">//如果是指针变量，说明指针的指向不能改变，指针的值不能修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = buf;</span><br><span class="line"><span class="comment">// 等价于上面 char const *p1 = buf;</span></span><br><span class="line"><span class="comment">//p[1] = '2'; //err</span></span><br><span class="line">p = <span class="string">"agdlsjaglkdsajgl"</span>; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p2 = buf;</span><br><span class="line">p2[<span class="number">1</span>] = <span class="string">'3'</span>;</span><br><span class="line"><span class="comment">//p2 = "salkjgldsjaglk"; //err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p3为只读，指向不能变，指向的内存也不能变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p3 = buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、内存管理"><a href="#五、内存管理" class="headerlink" title="五、内存管理"></a>五、内存管理</h2><h3 id="5-1-作用域"><a href="#5-1-作用域" class="headerlink" title="5.1 作用域"></a>5.1 作用域</h3><p>C语言变量的作用域分为：</p><ul><li>代码块作用域(代码块是{}之间的一段代码)</li><li>函数作用域</li><li>文件作用域</li></ul><p>局部变量也叫auto自动变量(auto可写可不写)，一般情况下代码块{}内部定义的变量都是自动变量，它有如下特点：</p><ul><li>在一个函数内定义，只在函数范围内有效</li><li>在复合语句中定义，只在复合语句中有效</li><li><strong>随着函数调用的结束或复合语句的结束局部变量的声明声明周期也结束</strong></li><li>如果没有赋初值，内容为随机</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//auto写不写是一样的</span></span><br><span class="line"><span class="comment">//auto只能出现在&#123;&#125;内部</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">int</span> b = <span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//b = 100; //err， 在main作用域中没有b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在复合语句中定义，只在复合语句中有效</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = 10; //err离开if()的复合语句，a已经不存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态(static)局部变量</p><ul><li>static局部变量的作用域也是在定义的函数内有效</li><li>static局部变量的生命周期和程序运行周期一样，同时staitc局部变量的值<strong>只初始化一次，但可以赋值多次</strong></li><li>static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0，字符型变量赋空字符</li></ul><p>全局变量</p><ul><li>在函数外定义，可被本文件及其它文件中的函数所共用，<strong>若其它文件中的函数调用此变量,须用extern声明</strong></li><li>全局变量的生命周期和程序运行周期一样</li><li>不同文件的全局变量不可重名</li></ul><p>静态(static)全局变量</p><ul><li>在函数外定义,作用范围被限制在所定义的文件中</li><li>不同文件静态全局变量可以重名,但作用域不冲突</li><li>static全局变量的生命周期和程序运行周期一样，同时staitc全局变量的值只初始化一次</li></ul><p>extern全局变量声明</p><ul><li>extern int a; 声明一个变量，这个变量在别的文件中已经定义了，这里只是声明，而不是定义</li></ul><p>全局函数和静态函数</p><ul><li>在C语言中函数默认都是全局的，使用关键字static可以将函数声明为静态，函数定义为static就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数都没用。</li></ul><p><strong>注意</strong>：</p><ul><li>允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰。</li><li>同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。</li><li>所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。</li></ul><p>总结：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th></tr></thead><tbody><tr><td>auto变量</td><td>一对{}内</td><td>当前函数</td></tr><tr><td>static局部变量</td><td>一对{}内</td><td>整个程序运行期</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>register变量</td><td>一对{}内</td><td>当前函数</td></tr></tbody></table><h3 id="5-2-内存布局"><a href="#5-2-内存布局" class="headerlink" title="5.2 内存布局"></a>5.2 内存布局</h3><p>内存分区</p><ul><li>C代码经过<strong>预处理、编译、汇编、链接</strong>4步后生成一个可执行程序。</li></ul><p>在 Linux 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况：</p><img src="/images/imageProgramC/fileinfo.png"><p>通过上图可以得知，在没有运行程序前，也就是说<strong>程序没有加载到内存前</strong>，可执行程序内部已经分好3段信息，分别为<strong>代码区（text）、数据区（data）和未初始化数据区（bss）</strong>3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。</p><ul><li><p><strong>代码区</strong></p><ul><li>存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。<strong>代码区通常是只读的</strong>，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。</li></ul></li><li><p><strong>全局初始化数据区/静态数据区（data段）</strong></p><ul><li>该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</li></ul></li><li><p><strong>未初始化数据区（又叫 bss 区）</strong></p><ul><li>存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。</li></ul><p>程序在加载到内存前，<strong>代码区和全局区(data和bss)的大小就是固定的</strong>，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，<strong>除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区</strong>。</p></li></ul><img src="/images/imageProgramC/内存分区.png"><ul><li><p>代码区（text segment）</p><ul><li>加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。</li></ul></li><li><p>未初始化数据区（BSS）</p><ul><li>加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。</li></ul></li><li><p>全局初始化数据区/静态数据区（data segment）</p><ul><li>加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。</li></ul></li><li><p>栈区（stack）</p><ul><li><strong>栈是一种先进后出的内存结构</strong>，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。</li></ul></li><li><p>堆区（heap）</p><ul><li>堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。<strong>堆在内存中位于BSS区和栈区之间</strong>。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</li></ul></li></ul><p>存储类型总结：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th><th><strong>存储位置</strong></th></tr></thead><tbody><tr><td>auto变量</td><td>一对{}内</td><td>当前函数</td><td>栈区</td></tr><tr><td>static局部变量</td><td>一对{}内</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td><td>代码区</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td><td>代码区</td></tr><tr><td>register变量</td><td>一对{}内</td><td>当前函数</td><td>运行时存储在CPU寄存器</td></tr><tr><td>字符串常量</td><td>当前文件</td><td>整个程序运行期</td><td>data段</td></tr></tbody></table><p><strong>存储类型总结内存操作函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：将s的内存区域的前n个字节以参数c填入</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。</span><br><span class="line"></span><br><span class="line">memmove()</span><br><span class="line">memmove()功能用法和<span class="built_in">memcpy</span>()一样，区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比<span class="built_in">memcpy</span>()低些。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">功能：比较s1和s2所指向内存区域的前n个字节</span><br></pre></td></tr></table></figure><p><strong>堆区内存分配和释放</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用<span class="built_in">memset</span>初始化。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count, *<span class="built_in">array</span>, n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入要申请数组的个数:\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"申请空间失败!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将申请到空间清0</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; n; count++) <span class="comment">/*给数组赋值*/</span></span><br><span class="line"><span class="built_in">array</span>[count] = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; n; count++) <span class="comment">/*打印数组元素*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%2d"</span>, <span class="built_in">array</span>[count]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回堆区地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">tmp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*tmp = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;<span class="comment">//返回堆区地址，函数调用完毕，不释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = fun();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, *p);<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//堆区空间，使用完毕，手动释放</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、复合类型-自定义类型"><a href="#六、复合类型-自定义类型" class="headerlink" title="六、复合类型(自定义类型)"></a>六、复合类型(自定义类型)</h2><h3 id="6-1-结构体"><a href="#6-1-结构体" class="headerlink" title="6.1 结构体"></a>6.1 结构体</h3><p>定义结构体变量的方式：</p><ul><li>先声明结构体类型再定义变量名</li><li>在声明类型的同时定义变量</li><li>直接定义结构体类型变量（无类型名）</li></ul><img src="/images/imageProgramC/结构体.png"><p>结构体类型和结构体变量关系：</p><ul><li>结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。</li><li>结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先定义类型，再定义变量（常用）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span> = &#123;</span> <span class="string">"mike"</span>, <span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类型同时定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;s2 = &#123; <span class="string">"lily"</span>, <span class="number">22</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;s3 = &#123; <span class="string">"yuri"</span>, <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure><p>结构体成员的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是普通变量，通过点运算符操作结构体成员</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1.name, <span class="string">"abc"</span>);</span><br><span class="line">s1.age = <span class="number">18</span>;   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s1.name = %s, s1.age = %d\n"</span>, s1.name, s1.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line"><span class="built_in">strcpy</span>((&amp;s1)-&gt;name, <span class="string">"test"</span>);</span><br><span class="line">(&amp;s1)-&gt;age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(&amp;s1)-&gt;name = %s, (&amp;s1)-&gt;age = %d\n"</span>, (&amp;s1)-&gt;name, (&amp;s1)-&gt;age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体套结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">info</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[2] = &#123;</span> <span class="number">1</span>, <span class="string">"lily"</span>, <span class="string">'F'</span>, <span class="number">2</span>, <span class="string">"yuri"</span>, <span class="string">'M'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d\tinfo.name=%s\tinfo.sex=%c\n"</span>, s[i].id, s[i].info.name, s[i].info.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体套一级指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *name; <span class="comment">//一级指针</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">p = (struct stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct  stu));</span><br><span class="line">p-&gt;name = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">"test"</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(p-&gt;name, <span class="string">"test"</span>);</span><br><span class="line">p-&gt;age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p-&gt;name = %s, p-&gt;age=%d\n"</span>, p-&gt;name, p-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(*p).name = %s, (*p).age=%d\n"</span>, (*p).name, (*p).age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;name != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p-&gt;name);</span><br><span class="line">p-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体普通变量做函数参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数参数为结构体普通变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stu</span><span class="params">(struct stu tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp.name, <span class="string">"mike"</span>);</span><br><span class="line">tmp.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"tmp.name = %s, tmp.age = %d\n"</span>, tmp.name, tmp.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">set_stu(s); <span class="comment">//值传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s.name = %s, s.age = %d\n"</span>, s.name, s.age);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体指针变量做函数参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数参数为结构体指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stu_pro</span><span class="params">(struct stu *tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp-&gt;name, <span class="string">"mike"</span>);</span><br><span class="line">tmp-&gt;age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">set_stu_pro(&amp;s); <span class="comment">//地址传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s.name = %s, s.age = %d\n"</span>, s.name, s.age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体数组名做函数参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void set_stu_pro(struct stu tmp[100], int n)</span></span><br><span class="line"><span class="comment">//void set_stu_pro(struct stu tmp[], int n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stu_pro</span><span class="params">(struct stu *tmp, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(tmp-&gt;name, <span class="string">"name%d%d%d"</span>, i, i, i);</span><br><span class="line">tmp-&gt;age = <span class="number">20</span> + i;</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[3] = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">set_stu_pro(s, n); <span class="comment">//数组名传递</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s, %d\n"</span>, s[i].name, s[i].age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-共用体-联合体"><a href="#6-2-共用体-联合体" class="headerlink" title="6.2 共用体(联合体)"></a>6.2 共用体(联合体)</h3><ul><li>联合union是一个能在同一个存储空间存储不同类型数据的类型；</li><li>联合体所占的内存长度等于其最长成员的长度，也有叫做共用体；</li><li>同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用；</li><li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖；</li><li>共用体变量的地址和它的各成员的地址都是同一地址。</li></ul><h3 id="6-3-枚举"><a href="#6-3-枚举" class="headerlink" title="6.3 枚举"></a>6.3 枚举</h3><p>枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p><p>枚举类型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  枚举名</span><br><span class="line">&#123;</span><br><span class="line">枚举值表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在枚举值表中应列出所有可用值，也称为枚举元素。</li><li>枚举值是常量，不能在程序中用赋值语句再对它赋值。</li><li>枚举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 …</li></ul><h3 id="6-4-typedef"><a href="#6-4-typedef" class="headerlink" title="6.4 typedef"></a>6.4 typedef</h3><p>typedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，<strong>不能创建新类型</strong>。</p><ul><li><p>与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值</p></li><li><p>#define发生在预处理，typedef发生在编译阶段</p></li></ul><h2 id="七、文件操作"><a href="#七、文件操作" class="headerlink" title="七、文件操作"></a>七、文件操作</h2><p>磁盘文件和设备文件</p><ul><li>磁盘文件<ul><li>指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。</li></ul></li><li>设备文件<ul><li>在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。</li></ul></li></ul><h3 id="7-1-文件的打开和关闭"><a href="#7-1-文件的打开和关闭" class="headerlink" title="7.1 文件的打开和关闭"></a>7.1 文件的打开和关闭</h3><p>文件指针</p><ul><li>在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">short</span>           level;<span class="comment">//缓冲区"满"或者"空"的程度 </span></span><br><span class="line"><span class="keyword">unsigned</span>        flags;<span class="comment">//文件状态标志 </span></span><br><span class="line"><span class="keyword">char</span>            fd;<span class="comment">//文件描述符</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>   hold;<span class="comment">//如无缓冲区不读取字符</span></span><br><span class="line"><span class="keyword">short</span>           bsize;<span class="comment">//缓冲区的大小</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>   *buffer;<span class="comment">//数据缓冲区的位置 </span></span><br><span class="line"><span class="keyword">unsigned</span>        ar; <span class="comment">//指针，当前的指向</span></span><br><span class="line"><span class="keyword">unsigned</span>        istemp;<span class="comment">//临时文件，指示器</span></span><br><span class="line"><span class="keyword">short</span>           token;<span class="comment">//用于有效性的检查 </span></span><br><span class="line">&#125;FILE;</span><br></pre></td></tr></table></figure><p>FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，<strong>结构中含有文件名、文件状态和文件当前位置等信息</strong>。</p><p>声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 </p><p>文件的打开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line">功能：打开文件</span><br></pre></td></tr></table></figure><p>第二个参数的几种形式(打开文件的方式)：</p><table><thead><tr><th><strong>打开模式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>r或rb</td><td>以只读方式打开一个文本文件（不创建文件，若文件不存在则报错）</td></tr><tr><td>w或wb</td><td>以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a或ab</td><td>以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件</td></tr><tr><td>r+或rb+</td><td>以可读、可写的方式打开文件(不创建新文件)</td></tr><tr><td>w+或wb+</td><td>以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a+或ab+</td><td>以添加方式打开文件，打开文件并在末尾更改文件,若文件不存在则创建文件</td></tr></tbody></table><p>注意：</p><ul><li><p>b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的</p></li><li><p>Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾</p></li><li><p>在Windows平台下，以“文本”方式打开文件，不加b：</p><ul><li>当读取文件的时候，系统会将所有的 “\r\n” 转换成 “\n”</li><li>当写入文件的时候，系统会将 “\n” 转换成 “\r\n” 写入 </li><li><strong>以”二进制”方式打开文件，则读\写都不会进行这样的转换</strong></li></ul></li><li><p>在Unix/Linux平台下，“文本”与“二进制”模式没有区别，”\r\n” 作为两个字符原样输入输出</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径可以是相对路径，也可是绝对路径</span></span><br><span class="line">fp = fopen(<span class="string">"../test"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="comment">//fp = fopen("..\\test", "w");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) <span class="comment">//返回空，说明打开失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//perror()是标准出错打印函数，能打印调用库函数出错原因</span></span><br><span class="line">perror(<span class="string">"open"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-文件的顺序读写"><a href="#7-2-文件的顺序读写" class="headerlink" title="7.2 文件的顺序读写"></a>7.2 文件的顺序读写</h3><ul><li>按照字符读写文件fgetc、fputc</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE * stream)</span></span>;</span><br><span class="line">功能：将ch转换为<span class="keyword">unsigned</span> <span class="keyword">char</span>后写入stream指定的文件中</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：从stream指定的文件中读取一个字符</span><br></pre></td></tr></table></figure><p>在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，<strong>这种以EOF作为文件结束标志的文件，必须是文本文件</strong>。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。<code>#define EOF    (-1)</code></p><p>当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。<strong>feof函数既可用以判断二进制文件又可用以判断文本文件</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：检测是否读取到了文件结尾。**判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)**。</span><br></pre></td></tr></table></figure><ul><li>按照行读写文件fgets、fputs</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, FILE * stream)</span></span>;</span><br><span class="line">功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 <span class="string">'\0'</span>  不写入文件。 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> * str, <span class="keyword">int</span> size, FILE * stream)</span></span>;</span><br><span class="line">功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - <span class="number">1</span>个字符为止，最后会自动加上字符 <span class="string">'\0'</span> 作为字符串结束。</span><br></pre></td></tr></table></figure><ul><li>按照格式化文件fprintf、fscanf</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</span><br></pre></td></tr></table></figure><ul><li>按照块读写文件fread、fwrite</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式给文件写入内容</span><br><span class="line">参数：</span><br><span class="line">ptr：准备写入文件数据的地址</span><br><span class="line">size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定写入文件内容的块数据大小</span><br><span class="line">nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功写入文件数据的块数目，此值和nmemb相等</span><br><span class="line">失败：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式从文件中读取内容</span><br></pre></td></tr></table></figure><h3 id="7-3-文件的随机读写"><a href="#7-3-文件的随机读写" class="headerlink" title="7.3 文件的随机读写"></a>7.3 文件的随机读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line">功能：移动文件流（文件光标）的读写位置。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line">whence：其取值如下：</span><br><span class="line">SEEK_SET：从文件开头移动offset个字节</span><br><span class="line">SEEK_CUR：从当前位置移动offset个字节</span><br><span class="line">SEEK_END：从文件末尾移动offset个字节</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">功能：获取文件流（文件光标）的读写位置。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：当前文件流（文件光标）的读写位置</span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">功能：把文件流（文件光标）的读写位置移动到文件开头。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">无返回值</span><br></pre></td></tr></table></figure><h3 id="7-4-获取文件状态"><a href="#7-4-获取文件状态" class="headerlink" title="7.4 获取文件状态"></a>7.4 获取文件状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line">功能：获取文件状态信息</span><br><span class="line">参数：</span><br><span class="line">path：文件名</span><br><span class="line">buf：保存文件信息的结构体</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="keyword">dev_t</span>         st_dev;         <span class="comment">//文件的设备编号</span></span><br><span class="line"><span class="keyword">ino_t</span>         st_ino;          <span class="comment">//节点</span></span><br><span class="line"><span class="keyword">mode_t</span>        st_mode;   <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line"><span class="keyword">nlink_t</span>       st_nlink;     <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line"><span class="keyword">uid_t</span>         st_uid;         <span class="comment">//用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span>         st_gid;         <span class="comment">//组ID</span></span><br><span class="line"><span class="keyword">dev_t</span>         st_rdev;      <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line"><span class="keyword">off_t</span>         st_size;        <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;   <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks;    <span class="comment">//块数</span></span><br><span class="line"><span class="keyword">time_t</span>        st_atime;     <span class="comment">//最后一次访问时间</span></span><br><span class="line"><span class="keyword">time_t</span>        st_mtime;    <span class="comment">//最后一次修改时间</span></span><br><span class="line"><span class="keyword">time_t</span>        st_ctime;     <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">stat(args[<span class="number">1</span>], &amp;st);</span><br><span class="line"><span class="keyword">int</span> size = st.st_size;<span class="comment">//得到结构体中的成员变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, size);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-删除文件、重命名文件名"><a href="#7-5-删除文件、重命名文件名" class="headerlink" title="7.5 删除文件、重命名文件名"></a>7.5 删除文件、重命名文件名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line">功能：删除文件</span><br><span class="line">参数：</span><br><span class="line">pathname：文件名</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line">功能：把oldpath的文件名改为newpath</span><br><span class="line">参数：</span><br><span class="line">oldpath：旧文件名</span><br><span class="line">newpath：新文件名</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="7-6-文件缓冲区"><a href="#7-6-文件缓冲区" class="headerlink" title="7.6 文件缓冲区"></a>7.6 文件缓冲区</h3><p>ANSI C标准采用“缓冲文件系统”处理数据文件。</p><p>所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。</p><p>如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。</p><p>磁盘文件的存取：</p><img src="/images/imageProgramC/磁盘文件的读取.png"><ul><li><p>磁盘文件，一般保存在硬盘、U盘等掉电不丢失的磁盘设备中，在需要时调入内存</p></li><li><p>在内存中对文件进行编辑处理后，保存到磁盘中</p></li><li><p>程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率</p></li></ul><p>更新缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">功能：更新缓冲区，让缓冲区的数据立马写到文件中。</span><br><span class="line">参数：</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-语言基础&quot;&gt;&lt;a href=&quot;#C-语言基础&quot; class=&quot;headerlink&quot; title=&quot;C 语言基础&quot;&gt;&lt;/a&gt;C 语言基础&lt;/h1&gt;&lt;h2 id=&quot;一、C-语言概述&quot;&gt;&lt;a href=&quot;#一、C-语言概述&quot; class=&quot;headerlink&quot; title=&quot;一、C 语言概述&quot;&gt;&lt;/a&gt;一、C 语言概述&lt;/h2&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Program-C 交叉编译</title>
    <link href="http://miaopei.github.io/2016/05/05/Program-C/compile/"/>
    <id>http://miaopei.github.io/2016/05/05/Program-C/compile/</id>
    <published>2016-05-05T02:14:50.000Z</published>
    <updated>2019-06-14T06:11:29.888Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><img src="/images/imageProgramC/03_C语言概述.png"><h1 id="建立ARM交叉编译环境arm-none-linux-gnueabi-gcc"><a href="#建立ARM交叉编译环境arm-none-linux-gnueabi-gcc" class="headerlink" title="建立ARM交叉编译环境arm-none-linux-gnueabi-gcc"></a>建立ARM交叉编译环境arm-none-linux-gnueabi-gcc</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> add2line：将你要找的地址转成文件和行号，它要使用 debug 信息</span></span><br><span class="line">arm-none-linux-gnueabi-addr2line </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ar：产生、修改和解开一个存档文件</span></span><br><span class="line">arm-none-linux-gnueabi-ar </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> as：gnu的汇编器</span></span><br><span class="line">arm-none-linux-gnueabi-as   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ld：gnu 的连接器</span></span><br><span class="line">arm-none-linux-gnueabi-ld </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gprof：gnu 汇编器预编译器</span></span><br><span class="line">arm-none-linux-gnueabi-gprof </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nm：列出目标文件的符号和对应的地址</span></span><br><span class="line">arm-none-linux-gnueabi-nm      </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> objdump：显示目标文件的信息</span></span><br><span class="line">arm-none-linux-gnueabi-objdump </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> readelf：显示 elf 格式的目标文件的信息</span></span><br><span class="line">arm-none-linux-gnueabi-readelf </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> strings：打印出目标文件中可以打印的字符串，有个默认的长度，为4</span></span><br><span class="line">arm-none-linux-gnueabi-strings </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> c++filt：C++ 和 java 中有一种重载函数，所用的重载函数最后会被编译转化成汇编的标，c++filt 就是实现这种反向的转化，根据标号得到函数名</span></span><br><span class="line">arm-none-linux-gnueabi-c++filt </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> objcopy：将某种格式的目标文件转化成另外格式的目标文件</span></span><br><span class="line">arm-none-linux-gnueabi-objcopy </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ranlib：为一个存档文件产生一个索引，并将这个索引存入存档文件中</span></span><br><span class="line">arm-none-linux-gnueabi-ranlib  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> size：显示目标文件各个节的大小和目标文件的大小</span></span><br><span class="line">arm-none-linux-gnueabi-size    </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> strip：剥掉目标文件的所有的符号信息</span></span><br><span class="line">arm-none-linux-gnueabi-strip</span><br></pre></td></tr></table></figure><h1 id="C调用C-库和C-调用C库的方法"><a href="#C调用C-库和C-调用C库的方法" class="headerlink" title="C调用C++库和C++调用C库的方法"></a>C调用C++库和C++调用C库的方法</h1><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW9zdW5yaXNlL2FydGljbGUvZGV0YWlscy84MTE3Njg4MA==" title="https://blog.csdn.net/shaosunrise/article/details/81176880">C调用C++库和C++调用C库的方法<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="C-调用C的静态库-动态库"><a href="#C-调用C的静态库-动态库" class="headerlink" title="C++调用C的静态库/动态库"></a>C++调用C的静态库/动态库</h2><p>C++ 调用 C 的函数比较简单，直接使用 <code>extern &quot;C&quot; {}</code> 告诉编译器用 C 的规则去调用 C 函数就可以了。</p><p><strong>CAdd.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>CAdd.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CAdd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"from C function.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译libCAdd.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c CAdd.c           # 生成CAdd.o</span><br><span class="line">ar -r libCAdd.a CAdd.o  # 归档生成libCAdd.a</span><br></pre></td></tr></table></figure><p><strong>编译动态库 libCAdd.so</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libCAdd.so CAdd.c</span><br></pre></td></tr></table></figure><p><strong>cppmain.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CAdd.h"</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = cadd(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1+2 = %d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译main</strong></p><p><code>-l</code> 指定库名称，优先链接so动态库，没有动态库再链接 <code>.a</code> 静态库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o cppmain cppmain.cpp -L. -lCAdd</span><br></pre></td></tr></table></figure><p><strong>运行</strong> </p><p>如果链接的是静态库就可以直接运行了，如果链接的是动态库可能会提示 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cppmain: error while loading shared libraries: libCAdd.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>是因为Linux系统程序和Windows不一样，Linux系统只会从系统环境变量指定的路径加载动态库，可以把生成的动态库放到系统目录，或者执行 <code>export LD_LIBRARY_PATH=./</code> 设置当前路径为系统链接库目录就可以了。</p><p>*<em>注释 *</em></p><p>这里是在 include 头文件的外面包裹了 <code>extern &quot;C&quot; { }</code>，是告诉编译器以 C 语言的命名方式去加载这个符号。还有一种比较常见的方式是在头文件中进行编译声明，如下所示，这样的话，无论 C 还是 C++ 直接正常include就可以使用了。</p><p><strong>CAdd.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C-调用-C-的静态库"><a href="#C-调用-C-的静态库" class="headerlink" title="C 调用 C++ 的静态库"></a>C 调用 C++ 的静态库</h2><p>C 语言没法直接调用 C++ 的函数，<strong>但可以使用包裹函数来实现</strong>。C++ 文件 <code>.cpp</code> 中可以调用 C 和 C++ 的函数，但是 C 代码 <code>.c</code> 只能调用 C 的函数，所以可以用包裹函数去包裹C ++ 函数，然后把这个包裹函数以 C 的规则进行编译，这样 C 就可以调用这个包裹函数了。</p><p><strong>CppAdd.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>CppAdd.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAdd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from C++ function.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译静态库 libCppAdd.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c CppAdd.cpp</span><br><span class="line">ar -r libCppAdd.a CppAdd.o</span><br></pre></td></tr></table></figure><p><strong>CppAddWrapper.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppaddwrapper</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>CppAddWrapper.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAddWrapper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAdd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cppaddwrapper</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from wrapper.\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = cppadd(x, y);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译 wrapper 静态库 libCppAddWrapper.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c CppAddWrapper.cpp</span><br><span class="line">ar -r libCppAddWrapper.a CppAddWrapper.o</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppAddWrapper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = cppaddwrapper(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"1+2 = %d\n"</span>, sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译 main，同时指定 libCppAdd.a 和 libCppAddWrapper.a。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -L. -lCppAddWrapper -lCppAdd</span><br></pre></td></tr></table></figure><p>或者把 libCppAdd.a 合并到 libCppAddWrapper.a 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ar -x libCppAdd.a         # 提取CppAdd.o</span><br><span class="line">ar -x libCppAddWrapper.a  # 提取CppAddWrapper.o</span><br><span class="line">ar -r libCppAddWrapper.a CppAdd.o CppAddWrapper.o # 打包libCppAddWrapper.a</span><br><span class="line">gcc -o main main.c -L. -lCppAddWrapper  # 只需要连接libCppAddWrapper.a即可</span><br></pre></td></tr></table></figure><p>如果是 C 调用 C++ 的 so 动态库的话，类似于调用静态库的方法应该也是有效的，太麻烦我没试过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>C/C++ 函数符号的区别</strong></p><p>C++ 可以兼容 C 的语法，C/C++ 主要的区别是编译函数符号规则不一样，C 语言代码编译后的函数名还是原来函数名，C++ 代码编译后的函数名带有参数信息。 </p><p>做个测试来检验一下。一个简单的函数，分别用 C 和 C++ 进行编译。 </p><p><strong>hello1.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hello2.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello1.c     # 生成hello1.o</span><br><span class="line">g++ -c hello1.cpp   # 生成hello2.o</span><br></pre></td></tr></table></figure><p><strong>查看符号表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nm hello1.o</span></span><br><span class="line">0000000000000000 T test</span><br><span class="line"><span class="meta">$</span><span class="bash"> nm hello2.o</span></span><br><span class="line">0000000000000000 T _Z4testiPc</span><br></pre></td></tr></table></figure><p>从上面信息可以看出，C 语言编译后的函数符号还是原函数名，而 C++ 编译后的函数符号由test变成了 <code>_Z4testiPc</code>，从这个符号名字可以看出 test 前面有个数字 4 应该是函数名长度，test 后面 <code>iPc</code> 应该就是函数的参数签名。C++ 之所以这样规定编译后的函数符号是因为对面对象的 C++ 具有函数重载功能，以此来区分不同的函数。</p><p><strong>.so 动态库、.a 静态库和 .o 中间文件的关系</strong></p><p>程序的运行都要经过<strong>编译和链接</strong>两个步骤。假如有文件 <code>add.c</code>，可以使用命令 <code>gcc -c add.c</code> 进行编译，生成 add.o 中间文件，使用命令 <code>ar -r libadd.a add.o</code> 可以生成 <code>libadd.a</code> 静态库文件。静态库文件其实就是对 <code>.o</code> 中间文件进行的封装，使用 <code>nm libadd.a</code> 命令可以查看其中封装的中间文件以及函数符号。 </p><p>链接静态库就是链接静态库中的 <code>.o</code> 文件，这和直接编译多个文件再链接成可执行文件一样。 </p><p>动态链接库是程序执行的时候直接调用的“插件”，使用命令 <code>gcc -shared -o libadd.so add.c</code> 生成 so 动态库。动态库链接的时候可以像静态库一样链接，告诉编译器函数的定义在这个静态库中（避免找不到函数定义的错误），只是不把这个 so 打包到可执行文件中。如果没有头文件的话，可以使用 <code>dlopen/dlsum</code> 函数手动去加载相应的动态库。详细做法参考上一篇文章《<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW9zdW5yaXNlL2FydGljbGUvZGV0YWlscy84MTE2MTA2NA==" title="https://blog.csdn.net/shaosunrise/article/details/81161064">C语言调用so动态库的两种方式<i class="fa fa-external-link"></i></span>》。</p><h1 id="ar-nm-命令的详细解释"><a href="#ar-nm-命令的详细解释" class="headerlink" title="ar nm 命令的详细解释"></a>ar nm 命令的详细解释</h1><p>功能说明：建立或修改备存文件，或是从备存文件中抽取文件。</p><p>语　　法：<code>ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件]</code></p><p>补充说明：ar 可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p><p>参　　数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指令参数</span></span><br><span class="line">　-d 　删除备存文件中的成员文件。</span><br><span class="line">　-m 　变更成员文件在备存文件中的次序。</span><br><span class="line">　-p 　显示备存文件中的成员文件内容。</span><br><span class="line">　-q 　将问家附加在备存文件末端。</span><br><span class="line">　-r 　将文件插入备存文件中。</span><br><span class="line">　-t 　显示备存文件中所包含的文件。</span><br><span class="line">　-x 　自备存文件中取出成员文件。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项参数</span></span><br><span class="line">　a&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之后。</span><br><span class="line">　b&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</span><br><span class="line">　c 　建立备存文件。</span><br><span class="line">　f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。</span><br><span class="line">　i&lt;成员文件&gt; 　将问家插入备存文件中指定的成员文件之前。</span><br><span class="line">　o 　保留备存文件中文件的日期。</span><br><span class="line">　s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。</span><br><span class="line">　S 　不产生符号表。</span><br><span class="line">　u 　只将日期较新文件插入备存文件中。</span><br><span class="line">　v 　程序执行时显示详细的信息。</span><br><span class="line">　V 　显示版本信息。</span><br></pre></td></tr></table></figure><h2 id="ar基本用法"><a href="#ar基本用法" class="headerlink" title="ar基本用法"></a>ar基本用法</h2><p>ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。</p><p>下面是ar命令的格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ar [-]&#123;dmpqrtx&#125;[abcfilNoPsSuvV][membername] [count] archive files...</span></span><br></pre></td></tr></table></figure><p>例如我们可以用<strong>ar rv libtest.a hello.o hello1.o</strong>来生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-‘字符，也可以没有。下面我们来看看命令的操作选项<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q9JUU1JTkyJThDJUU0JUJCJUJCJnRuPTI0MDA0NDY5X29lbV9kZyZyc3ZfZGw9Z2hfcGxfc2xfY3Nk" title="https://www.baidu.com/s?wd=%E5%92%8C%E4%BB%BB&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">和任<i class="fa fa-external-link"></i></span>选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。</p><p>{dmpqrtx} 中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：</p><ul><li>d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。</li><li>m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用’a’，’b’，或’I’任选项移动到指定的位置。</li><li>p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。</li><li>q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。’a’，’b’，或’I’任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用’ar s’或ranlib来更新库的符号表索引。</li><li>r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。</li><li>t：显示库的模块表清单。一般只显示模块名。</li><li>x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。</li></ul><p>　　下面在看看可与操作选项结合使用的任选项：</p><ul><li>a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。</li><li>b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。</li><li>c：创建一个库。不管库是否存在，都将创建。</li><li>f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。</li><li>i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。</li><li>l：暂未使用</li><li>N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。</li><li>o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。</li><li>P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。</li><li>s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。</li><li>S：不创建目标文件索引，这在创建较大的库时能加快时间。</li><li>u：一般说来，命令ar r…插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。</li><li>v：该选项用来显示执行操作选项的附加信息。</li><li>V：显示ar的版本。</li></ul><h2 id="nm基本用法命令"><a href="#nm基本用法命令" class="headerlink" title="nm基本用法命令"></a>nm基本用法命令</h2><p>nm用来列出目标文件的符号清单。下面是nm命令的格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [-a|--debug-syms][-g|--extern-only] [-B][-C|--demangle] [-D|--dynamic][-s|--print-armap][-o|--print-file-name][-n|--numeric-sort][-p|--no-sort][-r|--reverse-sort] [--size-sort][-u|--undefined-only] [-l|--line-numbers][--help][--version][-t radix|--radix=radix][-P|--portability][-f format|--format=format][--target=bfdname][objfile...]</span><br></pre></td></tr></table></figure><p>如果没有为 nm 命令指出目标文件，则 nm 假定目标文件是a.out。下面列出该命令的任选项，大部分支持”-“开头的短格式和”—“开头的长格式。</p><ul><li><p>-A、-o或–print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。</p><p>例如nm libtest.a的输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CPThread.o:</span><br><span class="line">00000068 T Main__8CPThreadPv</span><br><span class="line">00000038 T Start__8CPThread</span><br><span class="line">00000014 T _._8CPThread</span><br><span class="line">00000000 T __8CPThread</span><br><span class="line">00000000 ? __FRAME_BEGIN__</span><br><span class="line">.......................................</span><br><span class="line"><span class="meta">#</span><span class="bash"> 则nm -A 的输出如下：</span></span><br><span class="line">libtest.a:CPThread.o:00000068 T Main__8CPThreadPv</span><br><span class="line">libtest.a:CPThread.o:00000038 T Start__8CPThread</span><br><span class="line">libtest.a:CPThread.o:00000014 T _._8CPThread</span><br><span class="line">libtest.a:CPThread.o:00000000 T __8CPThread</span><br><span class="line">libtest.a:CPThread.o:00000000 ? __FRAME_BEGIN__</span><br><span class="line">..................................................................</span><br></pre></td></tr></table></figure></li><li><p>-a或–debug-syms：显示调试符号。</p></li><li><p>-B：等同于–format=bsd，用来兼容MIPS的nm。</p></li><li><p>-C或–demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</p></li><li><p>-D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</p></li><li><p>-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。</p></li><li><p>-g或–extern-only：仅显示外部符号。</p></li><li><p>-n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。</p></li><li><p>-p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。</p></li><li><p>-P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。</p></li><li><p>-s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。</p></li><li><p>-r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。</p></li><li><p>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。</p></li><li><p>-t radix或–radix=radix：使用radix进制显示符号值。radix只能为”d”表示十进制、”o”表示八进制或”x”表示十六进制。</p></li><li><p>–target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。</p></li><li><p>-u或–undefined-only：仅显示没有定义的符号(那些外部符号)。</p></li><li><p>-l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。</p></li><li><p>-V或–version：显示nm的版本号。</p></li><li><p>–help：显示nm的任选项。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;img src=&quot;/images/imageProgramC/03_C语言概述.png&quot;&gt;

&lt;h1 id=&quot;建立ARM交叉编译环境arm-none-linux-gnueabi-gcc&quot;&gt;&lt;a href=&quot;#建立ARM交叉编译环境arm-n
      
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程</title>
    <link href="http://miaopei.github.io/2016/05/01/Program-C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://miaopei.github.io/2016/05/01/Program-C/Linux系统编程基础/</id>
    <published>2016-05-01T02:14:50.000Z</published>
    <updated>2019-06-14T06:12:24.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-Note"><a href="#Linux-Note" class="headerlink" title="Linux Note"></a>Linux Note</h1><blockquote><h3 id="C-语言之解析局部变量返回"><a href="#C-语言之解析局部变量返回" class="headerlink" title="C 语言之解析局部变量返回"></a>C 语言之解析局部变量返回</h3><p>一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。</p><p>准确的来说，<strong>函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)</strong>。</p></blockquote><a id="more"></a><h2 id="1-Linux-基础命令"><a href="#1-Linux-基础命令" class="headerlink" title="1. Linux 基础命令"></a>1. Linux 基础命令</h2><blockquote><p><strong>stat命令</strong>用于显示文件的状态信息。stat命令的输出信息比 <span class="exturl" data-url="aHR0cDovL21hbi5saW51eGRlLm5ldC9scw==" title="http://man.linuxde.net/ls">ls<i class="fa fa-external-link"></i></span> 命令的输出信息要更详细。</p></blockquote><h3 id="1-0-创建用户"><a href="#1-0-创建用户" class="headerlink" title="1.0 创建用户"></a>1.0 创建用户</h3><p><strong>创建用户命令两条</strong>：</p><ul><li><p>adduser</p></li><li><p>useradd</p></li></ul><p><strong>用户删除命令</strong>：</p><ul><li>userdel</li></ul><p><strong>两个用户创建命令之间的区别</strong>：</p><ul><li><p>adduser： 会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。</p></li><li><p>useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 adduser</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adduser apple</span></span><br><span class="line">正在添加用户"apple"...</span><br><span class="line">正在添加新组"apple" (1007)...</span><br><span class="line">正在添加新用户"apple" (1007) 到组"apple"...</span><br><span class="line">创建主目录"/home/apple"...</span><br><span class="line">正在从"/etc/skel"复制文件...</span><br><span class="line">输入新的 UNIX 密码： </span><br><span class="line">重新输入新的 UNIX 密码： </span><br><span class="line">passwd：已成功更新密码</span><br><span class="line">正在改变 apple 的用户信息</span><br><span class="line">请输入新值，或直接敲回车键以使用默认值</span><br><span class="line">        全名 []: </span><br><span class="line">        房间号码 []: </span><br><span class="line">        工作电话 []: </span><br><span class="line">        家庭电话 []: </span><br><span class="line">        其它 []: </span><br><span class="line">这些信息是否正确？ [Y/n] y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样在创建用户名时，就创建了用户的主目录以及密码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> adduser在创建用户时会主动调用  /etc/adduser.conf；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在创建用户主目录时默认在/home下，而且创建为 /home/用户名   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果主目录已经存在，就不再创建，但是此主目录虽然作为新用户的主目录，而且默认登录时会进入这个目录下，但是这个目录并不是属于新用户，当使用userdel删除新用户时，并不会删除这个主目录，因为这个主目录在创建前已经存在且并不属于这个用户。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为用户指定shell版本为：/bin/bash</span></span><br></pre></td></tr></table></figure><p>因此 adduser 常用参数选项为：</p><ul><li><p><code>--home</code>：  指定创建主目录的路径，默认是在/home目录下创建用户名同名的目录，这里可以指定；如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。</p></li><li><p><code>--quiet</code>：  即只打印警告和错误信息，忽略其他信息。</p></li><li><p><code>--debug</code>：  定位错误信息。</p></li><li><p><code>--conf</code>：   在创建用户时使用指定的configuration文件。</p></li><li><p><code>--force-badname</code>：  默认在创建用户时会进行/etc/adduser.conf中的正则表达式检查用户名是否合法，如果想使用弱检查，则使用这个选项，如果不想检查，可以将/etc/adduser.conf中相关选项屏蔽。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 useradd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意： 在使用useradd命令创建新用户时，不会为用户创建主目录，不会为用户指定shell版本，不会为用户创建密码。</span></span><br></pre></td></tr></table></figure><p>为用户指定参数的 useradd 命令，常用命令行选项：</p><ul><li><p><code>-d</code>：   指定用户的主目录</p></li><li><p><code>-m</code>：   如果存在不再创建，但是此目录并不属于新创建用户；如果主目录不存在，则强制创建； -m和-d一块使用。</p></li><li><p><code>-s</code>：   指定用户登录时的shell版本</p></li><li><p><code>-M</code>：   不创建主目录</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解释：   </span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -d   “/home/tt<span class="string">" ：就是指定/home/tt为主目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -m   就是如果/home/tt不存在就强制创建</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -s   就是指定shell版本           </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo  useradd  -d  <span class="string">"/home/tt"</span>  -m   -s <span class="string">"/bin/bash"</span>   tt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 tt 密码：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo passwd tt</span></span><br></pre></td></tr></table></figure><p><strong>删除用户命令</strong></p><ul><li><p>userdel</p></li><li><p>只删除用户：</p><ul><li><code>sudo   userdel   用户名</code></li></ul></li><li><p>连同用户主目录一块删除：</p><ul><li><code>sudo  userdel   -r   用户名</code></li></ul></li></ul><p><strong>相关文件</strong>：</p><ul><li>/etc/passwd - 使 用 者 帐 号 资 讯，可以查看用户信息</li><li>/etc/shadow - 使 用 者 帐 号 资 讯 加 密</li><li>/etc/group - 群 组 资 讯</li><li>/etc/default/useradd - 定 义 资 讯</li><li>/etc/login.defs - 系 统 广 义 设 定</li><li>/etc/skel - 内 含 定 义 档 的 目 录</li></ul><p><strong>为组用户增加 root 权限</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改 /etc/sudoers 文件，找到下面一行，在 root 下面添加一行，如下所示：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line">tommy   ALL=(ALL)     ALL</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改完毕，现在可以用 tommy 帐号登录，然后用命令 sudo – ，即可获得 root 权限进行操作。</span></span><br></pre></td></tr></table></figure><h3 id="1-1-ln-软硬链接"><a href="#1-1-ln-软硬链接" class="headerlink" title="1.1 ln 软硬链接"></a>1.1 ln 软硬链接</h3><p><strong>硬链接</strong></p><p>硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。可以用: ln 命令来建立硬链接。</p><p>尽管硬链接节省空间，也是Linux系统整合文件系统的传统方式，但是存在一下不足之处：</p><ul><li><p>（1）不可以在不同文件系统的文件间建立链接</p></li><li><p>（2）只有超级用户才可以为目录创建硬链接。</p></li></ul><p><strong>软链接（符号链接）</strong></p><p>软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。<br>建立软链接，只要在 ln 后面加上选项  –s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ln -s abc cde <span class="comment"># 建立 abc 的软连接</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln abc cde <span class="comment"># 建立 abc 的硬连接，</span></span></span><br></pre></td></tr></table></figure><p><strong>删除链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf symbolic_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> unlink symbolic_name</span></span><br></pre></td></tr></table></figure><h3 id="1-2-find-grep-xargs"><a href="#1-2-find-grep-xargs" class="headerlink" title="1.2 find grep xargs"></a>1.2 find grep xargs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前目录及子目录下所有文件和文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在/home目录下查找以.txt结尾的文件名 但忽略大小写</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /home -iname <span class="string">"*.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . \( -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span> \)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 匹配文件路径或者文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /usr/ -path <span class="string">"*local*"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于正则表达式匹配文件路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -regex <span class="string">".*\(\.txt\|\.pdf\)$"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，但忽略大小写</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -iregex <span class="string">".*\(\.txt\|\.pdf\)$"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出/home下 不是 以 .txt 结尾的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /home ! -name <span class="string">"*.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件类型进行搜索</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 类型参数列表：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  f 普通文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  l 符号连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  d 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  c 字符设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  b 块设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  s 套接字</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  p Fifo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> 类型参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于目录深度搜索 向下最大深度限制为3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -maxdepth 3 -<span class="built_in">type</span> f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索出深度距离当前目录至少2个子目录的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -mindepth 2 -<span class="built_in">type</span> f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件时间戳进行搜索</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UNIX/Linux文件系统每个文件都有三种时间戳：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索最近七天内被访问过的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -atime -7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索恰好在七天前被访问过的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -atime 7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索超过七天内被访问过的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -atime +7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索访问时间超过10分钟的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -amin +10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出比 file.log 修改时间更长的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -newer file.log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件大小进行匹配</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件大小单元：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  b —— 块（512字节）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  c —— 字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  w —— 字（2字节）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  k —— 千字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  M —— 兆字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  G —— 吉字节</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size 文件大小单元</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索大于10KB的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size +10k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索小于10KB的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size -10k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索等于10KB的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size 10k</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除匹配文件 删除当前目录下所有.txt文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -delete</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件权限/所有权进行匹配 当前目录下搜索出权限为777的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -perm 777</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录下权限不是644的php文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.php"</span> ! -perm 644</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录用户tom拥有的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -user tom</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录用户组sunk拥有的所有文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -group sunk</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 借助-<span class="built_in">exec</span>选项与其他命令结合使用 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录下所有root的文件，并把所有权更改为用户tom</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;&#125; 用于与 -<span class="built_in">exec</span> 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find .-<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> chown tom &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出自己家目录下所有的.txt文件并删除</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ok 和 -<span class="built_in">exec</span> 行为一样，不过它会给出提示，是否执行相应的操作。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find <span class="variable">$HOME</span>/. -name <span class="string">"*.txt"</span> -ok rm &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> cat &#123;&#125; \;&gt; all.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将30天前的.<span class="built_in">log</span>文件移动到old目录中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -mtime +30 -name <span class="string">"*.log"</span> -<span class="built_in">exec</span> cp &#123;&#125; old \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找出当前目录下所有.txt文件并以 “File:文件名” 的形式打印出来</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> <span class="built_in">printf</span> <span class="string">"File: %s\n"</span> &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为单行命令中 -<span class="built_in">exec</span> 参数中无法使用多个命令，以下方法可以实现在 -<span class="built_in">exec</span> 之后接受多条命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -<span class="built_in">exec</span> ./text.sh &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索但跳出指定的目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -path <span class="string">"./sk"</span> -prune -o -name <span class="string">"*.txt"</span> -<span class="built_in">print</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> find其他技巧收集</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要列出所有长度为零的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -empty</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -<span class="built_in">exec</span> 接收 find 传过来的所有内容，容易造成溢出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xargs find 的好伴侣，xargs 将 find 命令查找的结果分成若干模块输出给后面的指令</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> grep 内容过滤</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep match_pattern file_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"match_pattern"</span> file_name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出除之外的所有行 -v 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -v <span class="string">"match_pattern"</span> file_name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 标记匹配颜色 --color=auto 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"match_pattern"</span> file_name --color=auto</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用正则表达式 -E 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -E <span class="string">"[1-9]+"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> egrep <span class="string">"[1-9]+"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只输出文件中匹配到的部分 -o 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a <span class="built_in">test</span> line. | grep -o -E <span class="string">"[a-z]+\."</span></span></span><br><span class="line">line.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a <span class="built_in">test</span> line. | egrep -o <span class="string">"[a-z]+\."</span></span></span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计文件或者文本中包含匹配字符串的行数 -c 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -c <span class="string">"text"</span> file_name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出包含匹配字符串的行数 -n 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"text"</span> -n file_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file_name | grep <span class="string">"text"</span> -n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索多个文件并查找匹配文本在哪些文件中：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -l <span class="string">"text"</span> file1 file2 file3...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在多级目录中对文本进行递归搜索：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"text"</span> . -r -n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 忽略匹配样式中的字符大小写：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span> | grep -i <span class="string">"HELLO"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项 -e 制动多个匹配样式：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a text line | grep -e <span class="string">"is"</span> -e <span class="string">"line"</span> -o</span></span><br><span class="line">is</span><br><span class="line">line</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。</span></span><br><span class="line">cat patfile</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> aaa bbb ccc ddd eee | grep -f patfile -o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在grep搜索结果中包括或者排除指定文件：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只在目录中所有的.php和.html文件中递归搜索字符<span class="string">"main()"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"main()"</span> . -r --include *.&#123;php,html&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在搜索结果中排除所有README文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"main()"</span> . -r --exclude <span class="string">"README"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在搜索结果中排除filelist文件列表里的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"main()"</span> . -r --exclude-from filelist</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用0值字节后缀的grep与xargs：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"aaa"</span> &gt; file1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"bbb"</span> &gt; file2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"aaa"</span> &gt; file3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">"aaa"</span> file* -lZ | xargs -0 rm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后会删除 file1 和 file3，grep 输出用 -Z 选项来指定以 0 值字节作为终结符文件名（\0），xargs -0 读取输入并用 0 值字节终结符分隔文件名，然后删除匹配文件，-Z 通常和 -l 结合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> grep静默输出：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -q <span class="string">"test"</span> filename</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印出匹配文本之前或者之后的行：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配某个结果 之后的3行，使用 -A 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">"5"</span> -A 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配某个结果 之前的3行，使用 -B 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">"5"</span> -B 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配某个结果的 前三行和后三行，使用 -C 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">"5"</span> -C 3</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> xargs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数：</span></span><br><span class="line">-a file 从文件中读入作为sdtin</span><br><span class="line">-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</span><br><span class="line">-p 当每次执行一个argument的时候询问一次用户。</span><br><span class="line">-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</span><br><span class="line">-t 表示先打印命令，然后再执行。</span><br><span class="line">-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 &#123;&#125;，可以用 &#123;&#125; 代替。</span><br><span class="line">-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</span><br><span class="line">-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</span><br><span class="line">-L num 从标准输入一次读取 num 行送给 command 命令。</span><br><span class="line">-l 同 -L。</span><br><span class="line">-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</span><br><span class="line">-x exit的意思，主要是配合-s使用。。</span><br><span class="line">-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</span><br></pre></td></tr></table></figure><h3 id="1-3-VIM"><a href="#1-3-VIM" class="headerlink" title="1.3 VIM"></a>1.3 VIM</h3><p>设置 ~/.bashrc</p><p>添加 set -o vi     – 可以直接使用 vim 的各种快捷键</p><p>VIM 快捷键：</p><img src="/images/imageProgramC/vim.gif"><h3 id="1-4-GCC"><a href="#1-4-GCC" class="headerlink" title="1.4 GCC"></a>1.4 GCC</h3><p>gcc 工作流程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 预处理 头文件展开 宏替换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -E hello.c</span></span><br><span class="line">hello.i</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成汇编代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -S hello.i</span></span><br><span class="line">hello.s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将汇编编译成二进制文件 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hell0.s</span></span><br><span class="line">hello.o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc hello.o</span></span><br><span class="line">a.out</span><br></pre></td></tr></table></figure><p>gcc 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定编译输出的名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 -Wall 参数启用所有警告</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -E 参数只产生预处理输出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -E main.c &gt; main.i</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -S 参数只产生汇编代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -S main.c &gt; main.s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -C 参数只产生编译的代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -C main.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面的代码产生main.o, 包含机器级别的代码或者编译的代码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用-save-temps参数产生所有的中间步骤的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -save-temps main.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">a.out  main.c  main.i  main.o  main.s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -l 参数链接共享库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc  -Wall main.c -o main -lCPPfile</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -fPIC 产生位置无关的代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当产生共享库的时候，应该创建位置无关的代码，这会让共享库使用任意的地址而不是固定的地址，要实现这个功能，需要使用-fPIC参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面的例子产生libCfile.so动态库。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c -Wall -Werror -fPIC Cfile.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -o libCfile.so Cfile.o</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 产生共享库的时候使用了-fPIC 参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意 -shared 产生共享库。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -V 打印所有的执行命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -v main.c -o main</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/4.6/lto-wrapper</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -D 参数可以使用编译时的宏</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -D MY_MACRO main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -Werror 将警告升级为错误</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -Werror main.c -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 @ 参数从文件中读取参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc参数可以从文件中读取，通过@后跟文件名的方式提供， 多个参数可以使用空格区隔。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat opt_file </span></span><br><span class="line">-Wall -omain</span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c @opt_file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用参数 -I 指定头文件的文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -I/home/codeman/include input-file.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I 取消前一个参数功能，一般用在 -Idir 之后。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用参数-std指定支持的c++/c的标准</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -std=c++11 hello-world.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -static 生成静态链接的文件 静态编译文件(把动态库的函数和其它依赖都编译进最终文件)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -static -o main -lpthread</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相反的使用 -shared 使用动态库链接。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -g 用于 gdb 调试</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -static -o main -g</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -lstdc++ 指定 gcc 以 c++ 方式编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.cpp -lstdc++ -o main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -O 优化选项， 1-3 越高优先级越高</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.cpp -lstdc++ -o main -O1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -M 生成文件关联的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -M main.c</span></span><br><span class="line">main.o: main.c /usr/include/stdc-predef.h /usr/include/stdio.h \</span><br><span class="line"> /usr/include/features.h /usr/include/sys/cdefs.h \</span><br><span class="line"> /usr/include/bits/wordsize.h /usr/include/gnu/stubs.h \</span><br><span class="line"> /usr/include/gnu/stubs-64.h \</span><br><span class="line"> /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h \</span><br><span class="line"> /usr/include/bits/types.h /usr/include/bits/typesizes.h \</span><br><span class="line"> /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \</span><br><span class="line"> /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdarg.h \</span><br><span class="line"> /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h</span><br></pre></td></tr></table></figure><h3 id="1-5-库文件制作"><a href="#1-5-库文件制作" class="headerlink" title="1.5 库文件制作"></a>1.5 库文件制作</h3><p><strong>静态库制作和使用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 步骤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 编译为 .o 文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将 .o 文件打包：ar rcs libmycalc.a file1.0 file2.o ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 将头文件与库一起发布</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看库信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nm libmycalc.a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译时 需要加静态库名（记得路径），-I 包含头文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -o app -I include/ -L lib/ -lmycalc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 优点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行快</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 发布应用时不需要发布库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缺点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行程序体积比较大</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 库变更时需要重新编译应用</span></span><br></pre></td></tr></table></figure><p><strong>动态库制作和使用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 步骤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 编译与位置无关的代码，生成 .o 关键参数 -fPIC</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将 .o 文件打包， 关键参数 -shared</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 将库与头文件一起发布</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -o libcalc.so *.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -L 指定动态库路径 -I 指定库名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c -o app -I include/ -L lib/ -lcalc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ldd 查看库依赖</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd libcalc.so</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 优点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行程序体积小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 库变更时，一般不需要重新发布动态库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缺点：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 执行时需要加载动态库，相对而言，比静态库慢</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 发布应用时需要同时发布动态库</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决不能加载动态库的问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 拷贝到 /lib 下。 一般不允许</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将库路径增加到环境变量 LD_LIBRARY_PATH 中，不是特别推荐</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 配置 /etc/ld.so.conf 文件，增加 当前项目库路径，执行 sudo ldconfig -v</span></span><br></pre></td></tr></table></figure><img src="/images/imageProgramC/数据段.png"><h3 id="1-6-Makefile"><a href="#1-6-Makefile" class="headerlink" title="1.6 Makefile"></a>1.6 Makefile</h3><p>makefile 的三要素：</p><ul><li>目标</li><li>依赖</li><li>规则命令</li></ul><p>写法：</p><ul><li>目标：依赖</li><li>tab键 规则命令</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app: main.c add.c sub.c div.c mul.c</span></span><br><span class="line">gcc -o app -I./<span class="keyword">include</span>/ main.c add.c sub.c div.c mul.c</span><br></pre></td></tr></table></figure><p>如果更改其中一个文件，所有的源码都重新编译</p><p>可以考虑编译过程分解，先生成 .o 文件，然后使用 .o 文件编程结果</p><p>规则是递归的，依赖文件如果比目标文件新，则重新生成目标文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ObjFiles=main.o add.o sub.o div.o mul.o</span><br><span class="line">app: $(ObjFiles)</span><br><span class="line">gcc -o app -I./include/ $(ObjFiles)</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">gcc -c main.c -I./include/</span><br><span class="line">add.o: add.c</span><br><span class="line">gcc -c add.c -I./include/</span><br><span class="line">sub.o: sub.c</span><br><span class="line">gcc -c sub.c -I./include/</span><br><span class="line">div.o: div.c</span><br><span class="line">gcc -c div.c -I./include/</span><br><span class="line">mul.o: mul.c</span><br><span class="line">gcc -c mul.c -I./include/</span><br></pre></td></tr></table></figure><p>makefile 的隐含规则：默认处理第一个目标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> get all .c files</span></span><br><span class="line">SrcFiles=$(wildcard *.c)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> all .c files --&gt; .o file</span></span><br><span class="line">ObjFiles=$(patsubst %.c,%.o,$(SrcFiles))</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">echo $(SrcFiles)</span><br><span class="line">echo $(ObjFiles)</span><br></pre></td></tr></table></figure><p>makefile 变量：</p><ul><li>$@    代表目标</li><li>$^    代表全部依赖</li><li>$&lt;    第一个依赖</li><li>$?    第一个变化的依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> get all .c files</span></span><br><span class="line">SrcFiles=$(wildcard *.c)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> all .c files --&gt; .o file</span></span><br><span class="line">ObjFiles=$(patsubst %.c,%.o,$(SrcFiles))</span><br><span class="line"></span><br><span class="line">all:app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目标文件用法 $(Var)</span></span><br><span class="line">app: $(ObjFiles)</span><br><span class="line">gcc -o $@ -I./include/ $(ObjFiles)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模式匹配规则， <span class="variable">$@</span> $&lt; 这样的变量，只能在规则中出现</span></span><br><span class="line"><span class="meta">%</span><span class="bash">.o:%.c</span></span><br><span class="line">gcc -c $&lt; -I./include/ -o $@</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> @ 在规则前代表不输出该条规则的命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 规则前的“-”，代表该条规则报错，仍然继续执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .PHONY 定义伪目标，防止有歧义</span></span><br><span class="line">.PHONY:clean all</span><br><span class="line">clean:</span><br><span class="line">-@rm -f *.o</span><br><span class="line">-@rm -f app</span><br></pre></td></tr></table></figure><p>make -f makefile1    指定makefile文件进行编译</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SrcFiles=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">TargetFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(TargetFiles)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">%:%.c</span></span><br><span class="line">gcc -o <span class="variable">$@</span> %^</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f <span class="variable">$(TargetFiles)</span></span><br></pre></td></tr></table></figure><h3 id="1-7-gdb-调试"><a href="#1-7-gdb-调试" class="headerlink" title="1.7 gdb 调试"></a>1.7 gdb 调试</h3><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMTA3NzU5Lw==" title="http://blog.jobbole.com/107759/">gdb 调试入门，大牛写的高质量指南<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eHRvb2xzLXJzdC5yZWFkdGhlZG9jcy5pby96aF9DTi9sYXRlc3QvdG9vbC9nZGIuaHRtbA==" title="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">gdb 调试利器<i class="fa fa-external-link"></i></span></p></blockquote><p>启动gdb：gdb app</p><p>在gdb启动程序：</p><ul><li>r(un)   – 启动  可以带参数启动</li><li>start   – 启动 - 停留在main函数，分步调试</li><li>n(ent)   – 下一条指令</li><li>s(tep)  – 下一条指令，可以进入函数内部，库函数不能进</li><li>q(uit)   – 退出 gdb</li><li>b(reak)  num  – 指定行号，函数, 文件:行号  设置断点<ul><li>b 行号  – 主函数所在文件的行</li><li>b 函数名</li><li>b 文件名:行号</li></ul></li><li>l(ist) 文件：行号   – 查看代码<ul><li>l – 显示主函数对应的文件</li><li>l 文件名:行号</li></ul></li><li>info b   – 查看断点信息</li><li>d(el)  num – 删除断点</li><li>c – continue 跳到下一个断点</li><li>p(rint) – 打印参数，或者变量值</li><li>ptype 变量  – 查看变量类型</li><li>set  – 设置变量的值<ul><li>set argc=4</li><li>set argv[1]=“12”</li><li>set argv[2] = “7”</li></ul></li><li>display argc  –  跟踪显示参数或者变量的变化</li><li>info display</li><li>undisplay num</li><li>b num if xx == xx  – 条件断点</li></ul><p><strong>gdb跟踪core</strong></p><ul><li><p>设置生成 core ：ulimit -c unlimited</p></li><li><p>取消生成 core： ulimit -c 0</p></li><li><p>设置 core 文件格式：/proc/sys/kernel/core_pattern</p><p>文件不能 vi，可以用后面的套路：echo “/corefile/core-%e-%p-%t” &gt; core_pattern</p></li></ul><p>core 文件如何使用：</p><ul><li><p>gdb app core</p></li><li><p>如果看不到在哪儿core  可以用 where 查看在哪儿产生的 core</p></li></ul><h2 id="2-系统api与库函数的关系"><a href="#2-系统api与库函数的关系" class="headerlink" title="2. 系统api与库函数的关系"></a>2. 系统api与库函数的关系</h2><img src="/images/imageProgramC/系统api与函数关系.png"><h2 id="3-Linux-系统编程"><a href="#3-Linux-系统编程" class="headerlink" title="3. Linux 系统编程"></a>3. Linux 系统编程</h2><p>ulimit -a 查看所有资源的上限</p><p>env 查看环境变量</p><p>echo $PATH  打印指定的环境变量</p><p><code>char *getenv()</code> 获取环境变量</p><p><strong>创建一个进程</strong>：</p><p><code>pid_t fork(void)</code></p><p>返回值：</p><ul><li>失败 -1</li><li>成功，返回两次<ul><li>父进程返回子进程的 id</li><li>子进程返回 0</li></ul></li></ul><p>获得pid，进程 id，获得当前进程</p><p><code>pid_t getpid(void)</code></p><p>获得当前进程父进程的 id</p><p><code>pid_t getppid(void)</code></p><p>ps ajx 查看父进程和子进程相关信息</p><p><strong>进程共享</strong>：</p><p>父子进程之间在fork后，有哪些相同和不同：</p><ul><li>父子相同处：<ul><li>全局变量</li><li>data、text、栈、堆、环境变量</li><li>用户 ID</li><li>宿主目录、进程工作目录、信号处理方式…</li></ul></li><li>父子不同处：<ul><li>进程 ID</li><li>父进程 ID</li><li>进程运行时间</li><li>闹钟（定时器）</li><li>未决信号集</li></ul></li></ul><p>似乎，子进程复制了父进程 0-3G 用户空间内容，以及父进程的 PCB， 但 pid 不同。真的每 fork 一个子进程都要将父进程的 0-3G 地址空间完全拷贝一份，然后在映射至屋里内存吗？当然不是，父子进程间遵循<strong>读时共享写时复制</strong>。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p><p><strong>孤儿进程与僵尸进程</strong>：</p><ul><li>孤儿进程<ul><li>父进程死了，子进程被 init 进程领养</li></ul></li><li>僵尸进程<ul><li>子进程死了，父进程没有回收子进程的资源（PCB）</li></ul></li></ul><p>回收子进程，知道子进程的死亡原因，作用：</p><ul><li>阻塞等待</li><li>回收子进程资源</li><li>查看死亡原因</li></ul><p><code>pid_t wait(int *status)</code></p><ul><li>status 传出参数</li><li>返回值<ul><li>成功返回终止的子进程 ID</li><li>失败 返回 -1</li></ul></li></ul><p>子进程的死亡原因：</p><ul><li>正常死亡 WIFEXITED<ul><li>如果 WIFEXITED 为真，使用 WEXITSTATUS 得到退出的状态</li></ul></li><li>非正常死亡 WIFSIGNALED<ul><li>如果 WIFSIGNALED 为真，使用 WTERMSIG 得到信号</li></ul></li></ul><p><code>pid_t waitpid(pid_t pid, int *status, int options)</code></p><ul><li>pid<ul><li><code>&lt; -1</code> 组ID</li><li><code>-1</code> 回收任意</li><li><code>0</code> 回收和调用进程组 ID 相同组内的子进程</li><li><code>&gt;0</code> 回收指定的 pid</li></ul></li><li>option<ul><li>0 与 wait 相同，也会阻塞</li><li>WNOHANG 如果当前没有子进程退出，会立刻返回</li></ul></li><li>返回值<ul><li>如果设置了 WNOHANG ，那么如果没有子进程退出，返回 0<ul><li>如果有子进程退出返回退出的 pid</li></ul></li><li>失败返回 -1 （没有子进程）</li></ul></li></ul><h3 id="3-1-IPC-概念"><a href="#3-1-IPC-概念" class="headerlink" title="3.1 IPC 概念"></a>3.1 IPC 概念</h3><p>IPC ： 进程间通信，通过内核提供的缓存区进行数据交换的机制</p><p>IPC 通信的方式有几种：</p><ul><li>pipe 管道 – 最简单</li><li>fifo 有名管道</li><li>mmap 文件映射共享IO – 速度最快</li><li>本地 socket 最稳定</li><li>信号 携带信息量最小</li><li>共享内存</li><li>消息队列</li></ul><p><strong>读管道</strong>：</p><ul><li>写端全部关闭 – read 读到 0， 想当于读到文件末尾</li><li>写端没有全部关闭<ul><li>有数据 – read 读到数据</li><li>没有数据 – read 阻塞 fcntl 函数可以更改非阻塞</li></ul></li></ul><p><strong>写管道</strong>：</p><ul><li>读端全部关闭 – ？ 产生一个信号 SIGPIPE，程序异常终止</li><li>读端未全部关闭<ul><li>管道已满 – write 阻塞 – 如果要显示现象，读端一直不读，写端狂写。</li><li>管道未满 – write 正常写入</li></ul></li></ul><p><strong>管道缓冲区大小</strong></p><p>可以使用 <code>ulimit –a</code> 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe size            (512 bytes, -p) 8</span><br></pre></td></tr></table></figure><p>也可以使用 <code>fpathconf</code> 函数，借助参数选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p><p><code>long fpathconf(int fd, int name);</code>    </p><ul><li>成功：返回管道的大小    </li><li>失败：-1，设置errno</li></ul><p><strong>管道的优劣</strong></p><ul><li><p>优点：</p><ul><li>简单，相比信号，套接字实现进程间通信，简单很多。</li></ul></li><li><p>缺点：</p><ul><li>只能单向通信，双向通信需建立两个管道。</li><li>只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。</li></ul></li></ul><p><strong>FIFO通信</strong></p><p>FIFO 有名管道，实现无血缘关系进程通信</p><ul><li>创建一个管道的伪文件<ul><li>mkfifo myfifo 命令创建</li><li>也可以使用函数 <code>int mkfifo(const char *pathname,  mode_t mode);</code></li></ul></li><li>内核会针对 fifo 文件开辟一个缓存区，操作 fifo 文件，可以操作缓存区，实现进程间通信 – 实际上就是文件读写</li></ul><p><strong>mmap映射共享区</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *adrr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>返回：</p><ul><li>成功：返回创建的映射区首地址；</li><li><strong>失败：MAP_FAILED宏</strong></li></ul></li><li><p>参数：    </p><ul><li>addr:     建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</li><li>length：   欲创建映射区的大小</li><li>prot：       映射区权限 PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</li><li>flags：      标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)<ul><li>MAP_SHARED:  会将映射区所做的操作反映到物理设备（磁盘）上。（共享的）</li><li>MAP_PRIVATE:  映射区所做的修改不会反映到物理设备。（私有的）</li></ul></li><li>fd：      用来建立映射区的文件描述符</li><li>offset：   映射文件的偏移(4k的整数倍)</li></ul></li></ul><p>释放映射区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>匿名映射</strong></p><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。</p><p>使用 <code>MAP_ANONYMOUS</code>(或 <code>MAP_ANON</code> )， 如: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// "4"随意举例，该位置表大小，可依实际需要填写。</span></span><br></pre></td></tr></table></figure><p>需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/dev/zero 聚宝盆，可以随意映射</span></span><br><span class="line"><span class="comment">/dev/null 无底洞，一般错误信息重定向到这个文件中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fd = open(<span class="string">"/dev/zero"</span>, O_RDWR);</span><br><span class="line">p = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>信号的概念</strong></p><ul><li><p>信号的特点</p><ul><li>简单，不能带大量信息，满足特定条件发生</li></ul></li><li><p>信号的机制</p><ul><li>进程 B 发送给进程 A ，内核产生信号，内核处理</li></ul></li><li><p>信号的产生</p><ul><li>按键产生 </li><li>函数调用 kill、raise、abort</li><li>定时器 alarm、setitimer</li><li>命令产生 kill</li><li>硬件异常、段错误、浮点型错误、总线错误、SIGPIPE</li></ul></li><li><p>信号的状态</p><ul><li>产生</li><li>递达 信号到达并且处理完</li><li>未决 信号被阻塞</li></ul></li><li><p>信号的默认处理方式</p><ul><li>忽略</li><li>执行默认动作</li><li>捕捉</li></ul></li><li><p>信号的 4 要素</p><ul><li>编号</li><li>事件</li><li>名称</li><li>默认处理动作<ul><li>忽略</li><li>终止</li><li>终止 + core</li><li>暂停</li><li>继续</li></ul></li></ul></li></ul><h3 id="3-2-进程和线程"><a href="#3-2-进程和线程" class="headerlink" title="3.2 进程和线程"></a>3.2 进程和线程</h3><ul><li>进程组</li><li>会话</li><li>守护进程</li></ul><p>创建一个会话需要注意以下 5 点注意事项：</p><ul><li>调用进程不能是进程组组长，该进程编程新会话首进程（session header）</li><li>该进程成为一个新进程组的组长进程</li><li>新会话丢弃原有的控制终端，该会话没有控制终端</li><li>该调用进程是组长进程，则出错返回</li><li>建立会话时，先调用fork，父进程终止，子进程调用 setsid</li></ul><p>守护进程：</p><p>Daemon 进程，是 Linux 中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p><p>创建守护进程，最关键的一步是调用 setsid 函数创建一个新的 session 。并成为 session leader。</p><p><strong>创建守护进程模型</strong>：</p><ul><li>创建子进程，父进程退出<ul><li>所有工作在子进程中进行形式上脱离了控制终端</li></ul></li><li>在子进程中创建新会话<ul><li>setsid() 函数</li><li>使子进程完全能独立出来，脱离控制</li></ul></li><li>改变当前目录为根目录<ul><li>chdir() 函数</li><li>防止占用可卸载的文件系统</li><li>也可以换成其他路径</li></ul></li><li>重设文件权限掩码<ul><li>umask() 函数</li><li>防止继承的文件创建屏蔽字拒绝某些权限</li><li>增加守护进程灵活性</li></ul></li><li>关闭文件描述符<ul><li>继承的打开文件不会用到，浪费系统资源，无法卸载</li></ul></li><li>开始执行守护进程核心工作</li><li>守护进程退出处理程序模型</li></ul><blockquote><p>会话：进程组的更高一级，多个进程组对应一个会话</p><p>进程组：多个进程在同一个组，第一个进程默认是进程组的组长</p><p>创建会话的时候，组长不可以创建，必须是组员创建。</p><p>创建会话的步骤：创建子进程，父进程终止，子进程当会长</p><p>守护进程的步骤：</p><ul><li>创建子进程 fork</li><li>父进程退出</li><li>子进程当会长 setsid</li><li>切换工作目录 $HOME</li><li>设置掩码 umask</li><li>关闭文件描述符，为了避免浪费资源</li><li>执行核心逻辑</li><li>退出</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strFileName[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(strFileName, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(strFileName));</span><br><span class="line">        <span class="built_in">sprintf</span>(strFileName, <span class="string">"%s/log/Mr.Miaow.%ld"</span>, getenv(<span class="string">"HOME"</span>), time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> fd = open(strFileName, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"open err"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        sleep(<span class="number">5</span>);                                                                                      </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展了解：</p><p>通过 nohup 指令也可以达到守护进程创建的效果</p><p>nohup cmd [&gt; 1.log] &amp;</p><ul><li>nohup 指令会让 cmd 收不到 SIGHUP 信号</li><li>&amp; 代表后台运行</li></ul><p>线程是最小的执行单位，进程是最小的系统资源分配单位</p><p>查看 LWP 号：<code>ps -Lf pid</code> 查看指定线程的 lwp 号</p><p>线程非共享资源</p><ul><li>线程 ID</li><li>处理器现场和栈指针（内核栈）</li><li>独立的栈空间（用户空间栈）</li><li>errno 变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><p>线程优缺点：</p><ul><li>优点：<ul><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ul></li><li>缺点：<ul><li>库函数 不稳定</li><li>调试、编写困难</li><li>对信号支持不好</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alias echomake=`cat ~/bin/makefile.template &gt;&gt; makefile`</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/bin/makefile.template</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> create by Mr.Miaow `date +%Y%m%d`</span></span><br><span class="line">SrcFiles=$(wildcard *.c)</span><br><span class="line">TargetFiles=$(patsubst %.c,%,$(SrcFiles))</span><br><span class="line">all:$(TargetFiles)</span><br><span class="line"><span class="meta">%</span><span class="bash">:%.c</span></span><br><span class="line">gcc -o $@ %&lt; -lpthread -g</span><br><span class="line">clean:</span><br><span class="line">-rm -f $(TargetFiles)</span><br></pre></td></tr></table></figure><p><strong>线程退出注意事项</strong>：</p><ul><li>在线程中使用pthread_exit</li><li>在线程中使用 return （主控线程return 代表退出进程）</li><li>exit 代表退出整个进程</li></ul><p>线程回收函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><p>杀死线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>被pthread_cancel 杀死的线程，退出状态为 PTHREAD_CANCELED</p><p>线程分离：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>此时不需要 pthread_join回收资源</p><p>线程 ID 在进程内部是唯一的</p><p><strong>进程属性控制</strong>：</p><ul><li><p>初始化线程属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>销毁线程属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>设置属性分离态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="meta"># attr init 初始化的属性</span></span><br><span class="line"><span class="meta"># detachstate</span></span><br><span class="line"># - PTHREAD_CREATE_DETACHED 线程分离</span><br><span class="line"># - PTHREAD_CREATE_JOINABLE 允许回收</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>查看线程库版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> getconf GNU_LIBPTHREAD_VERSION</span></span><br></pre></td></tr></table></figure><p>创建多少个线程？</p><ul><li>cpu核数 * 2 + 2</li></ul><p><strong>线程同步</strong>：</p><ul><li>协调步骤，顺序执行</li></ul><p>解决同步的问题：加锁</p><p><strong>mutex 互斥量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> fastmutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">// 常量初始化，此时可以使用init</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>读写锁的特点：读共享，写独占，写优先级高</p><p>读写说任然是一把锁，有不同状态：</p><ul><li>未加锁</li><li>读锁</li><li>写锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>条件变量</strong>（生产者消费者模型）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒至少一个阻塞在条件变量 cond 上的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量 cond 上的全部线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 条件变量阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 超时等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> struct timespec *abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>信号量 加强版的互斥锁</strong>：</p><p>信号量是进化版的互斥量，允许多个线程访问共享资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="meta"># pshared</span></span><br><span class="line"># - <span class="number">0</span> 代表线程信号量</span><br><span class="line"># - 非<span class="number">0</span> 代表进程信号量</span><br><span class="line"><span class="meta"># value 定义信号量的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请信号量，申请成功 value--</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// 释放信号量 value++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abs_timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Link with -pthread.</span></span><br></pre></td></tr></table></figure><p><strong>文件锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-Note&quot;&gt;&lt;a href=&quot;#Linux-Note&quot; class=&quot;headerlink&quot; title=&quot;Linux Note&quot;&gt;&lt;/a&gt;Linux Note&lt;/h1&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;C-语言之解析局部变量返回&quot;&gt;&lt;a href=&quot;#C-语言之解析局部变量返回&quot; class=&quot;headerlink&quot; title=&quot;C 语言之解析局部变量返回&quot;&gt;&lt;/a&gt;C 语言之解析局部变量返回&lt;/h3&gt;&lt;p&gt;一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。&lt;/p&gt;
&lt;p&gt;准确的来说，&lt;strong&gt;函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://miaopei.github.io/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://miaopei.github.io/tags/c-c/"/>
    
  </entry>
  
</feed>
