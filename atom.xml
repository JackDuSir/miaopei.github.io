<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Miaow Blog</title>
  
  <subtitle>天道酬勤，地道酬善，人道酬誠，商道酬信，業道酬精</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://miaopei.github.io/"/>
  <updated>2019-06-03T08:10:56.878Z</updated>
  <id>http://miaopei.github.io/</id>
  
  <author>
    <name>苗沛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FFmpeg命令大全</title>
    <link href="http://miaopei.github.io/2019/05/04/FFmpeg/FFmpeg%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://miaopei.github.io/2019/05/04/FFmpeg/FFmpeg命令大全/</id>
    <published>2019-05-04T02:14:50.000Z</published>
    <updated>2019-06-03T08:10:56.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p><p>本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。</p><h2 id="2-FFMPEG-目录及作用"><a href="#2-FFMPEG-目录及作用" class="headerlink" title="2. FFMPEG 目录及作用"></a>2. FFMPEG 目录及作用</h2><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各类工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><a id="more"></a><h2 id="3-FFMPEG-基本概念"><a href="#3-FFMPEG-基本概念" class="headerlink" title="3. FFMPEG 基本概念"></a>3. FFMPEG 基本概念</h2><p>在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。</p><ul><li><p>音／视频流</p><p>在音视频领域，我们把一路音／视频称为一路<strong>流</strong>。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p></li><li><p>容器</p><p>我们一般把 MP4､ FLV、MOV 等文件格式称之为<strong>容器</strong>。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p></li><li><p>channel</p><p>channel 是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p></li></ul><h2 id="4-FFMPEG-命令"><a href="#4-FFMPEG-命令" class="headerlink" title="4. FFMPEG 命令"></a>4. FFMPEG 命令</h2><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解 / 复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><img src="_asset/音视频处理流程.png"><p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。</p><p>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。</p><p>您可以通过使用 <code>-vn / -an / -sn / -dn</code> 选项来禁用某些默认设置。 要进行全面的手动控制，请使用 <code>-map</code>选项，该选项禁用刚描述的默认设置。</p><p>下面我们就来详细介绍一下这些命令。</p><h2 id="5-基本信息查询命令"><a href="#5-基本信息查询命令" class="headerlink" title="5. 基本信息查询命令"></a>5. 基本信息查询命令</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 <code>ffmpeg -filters</code> 来查询。详细参数说明如下：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-version</td><td>显示版本。</td></tr><tr><td>-formats</td><td>显示可用的格式（包括设备）。</td></tr><tr><td>-demuxers</td><td>显示可用的demuxers。</td></tr><tr><td>-muxers</td><td>显示可用的muxers。</td></tr><tr><td>-devices</td><td>显示可用的设备。</td></tr><tr><td>-codecs</td><td>显示libavcodec已知的所有编解码器。</td></tr><tr><td>-decoders</td><td>显示可用的解码器。</td></tr><tr><td>-encoders</td><td>显示所有可用的编码器。</td></tr><tr><td>-bsfs</td><td>显示可用的比特流filter。</td></tr><tr><td>-protocols</td><td>显示可用的协议。</td></tr><tr><td>-filters</td><td>显示可用的libavfilter过滤器。</td></tr><tr><td>-pix_fmts</td><td>显示可用的像素格式。</td></tr><tr><td>-sample_fmts</td><td>显示可用的采样格式。</td></tr><tr><td>-layouts</td><td>显示channel名称和标准channel布局。</td></tr><tr><td>-colors</td><td>显示识别的颜色名称。</td></tr></tbody></table><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。</p><h2 id="6-命令基本格式及参数"><a href="#6-命令基本格式及参数" class="headerlink" title="6. 命令基本格式及参数"></a>6. 命令基本格式及参数</h2><p>下面是 FFMPEG 的基本命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ...</span></span><br><span class="line">                         &#123;[output_file_options] output_url&#125; ...</span><br></pre></td></tr></table></figure><p>ffmpeg 通过 <code>-i</code> 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等），并写入任意数量的输出“文件”。</p><p>原则上，每个输入 / 输出“文件”都可以包含任意数量的不同类型的视频流（视频 / 音频 / 字幕 / 附件 / 数据）。 <strong>流的数量和 / 或类型是由容器格式来限制</strong>。 选择从哪个输入进入到哪个输出将自动完成或使用 <code>-map</code> 选项。</p><p>要引用选项中的输入文件，您必须使用它们的索引（从 0 开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 <strong>例如： 2：3 是指第三个输入文件中的第四个流</strong>。</p><p>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p><h3 id="6-1-主要参数"><a href="#6-1-主要参数" class="headerlink" title="6.1 主要参数"></a>6.1 主要参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-f fmt（输入/输出）</td><td>强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。</td></tr><tr><td>-i url（输入）</td><td>输入文件的网址</td></tr><tr><td>-y（全局参数）</td><td>覆盖输出文件而不询问。</td></tr><tr><td>-n（全局参数）</td><td>不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。</td></tr><tr><td>-c [：stream_specifier] codec（输入/输出，每个流）</td><td>选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：<code>ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT</code></td></tr><tr><td>-codec [：stream_specifier]编解码器（输入/输出，每个流）</td><td>同 -c</td></tr><tr><td>-t duration（输入/输出）</td><td>当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</td></tr><tr><td>-ss位置（输入/输出）</td><td>当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</td></tr><tr><td>-frames [：stream_specifier] framecount（output，per-stream）</td><td>停止在帧计数帧之后写入流。</td></tr><tr><td>-filter [：stream_specifier] filtergraph（output，per-stream）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</td></tr></tbody></table><h3 id="6-2-视频参数"><a href="#6-2-视频参数" class="headerlink" title="6.2 视频参数"></a>6.2 视频参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-vframes num（输出）</td><td>设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。</td></tr><tr><td>-r [：stream_specifier] fps（输入/输出，每个流）</td><td>设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。</td></tr><tr><td>-s [：stream_specifier]大小（输入/输出，每个流）</td><td>设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。</td></tr><tr><td>-aspect [：stream_specifier] 宽高比（输出，每个流）</td><td>设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。</td></tr><tr><td>-vn（输出）</td><td>禁用视频录制。</td></tr><tr><td>-vcodec编解码器（输出）</td><td>设置视频编解码器。这是 <code>-codec：v</code> 的别名。</td></tr><tr><td>-vf filtergraph（输出）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><h3 id="6-3-音频参数"><a href="#6-3-音频参数" class="headerlink" title="6.3 音频参数"></a>6.3 音频参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-aframes（输出）</td><td>设置要输出的音频帧的数量。这是 <code>-frames：a</code> 的一个过时的别名。</td></tr><tr><td>-ar [：stream_specifier] freq（输入/输出，每个流）</td><td>设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td>-ac [：stream_specifier]通道（输入/输出，每个流）</td><td>设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td>-an（输出）</td><td>禁用录音。</td></tr><tr><td>-acodec编解码器（输入/输出）</td><td>设置音频编解码器。这是-codec的别名：a。</td></tr><tr><td>-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</td><td>设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。</td></tr><tr><td>-af filtergraph（输出）</td><td>创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><p>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p><h2 id="7-录制"><a href="#7-录制" class="headerlink" title="7. 录制"></a>7. 录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -list_devices <span class="literal">true</span> -i <span class="string">""</span></span></span><br></pre></td></tr></table></figure><p><strong>录屏</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span></span><br></pre></td></tr></table></figure><ul><li><p>-f 指定使用 avfoundation 采集数据。</p></li><li><p>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</p></li><li><p>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而 -r 用于限制输出。</p></li></ul><p>注意：桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</p><p><strong>录屏+声音</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</span></span><br></pre></td></tr></table></figure><ul><li><p>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</p></li><li><p>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</p></li><li><p>-crf 是 x264 的参数。 0 表式无损压缩。</p></li><li><p>-c:a 与参数 -acodec 一样，表示音频编码器。</p></li><li><p>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</p></li><li><p>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</p></li></ul><p><strong>录视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</p></li><li><p>-f 指定使用 avfoundation 采集数据。</p></li><li><p>-i 指定视频设备的索引号。</p></li></ul><p><strong>视频+音频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</span></span><br></pre></td></tr></table></figure><p><strong>录音</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f avfoundation -i :0 out.wav</span></span><br></pre></td></tr></table></figure><p><strong>录制音频裸数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</span></span><br></pre></td></tr></table></figure><h2 id="8-分解与复用"><a href="#8-分解与复用" class="headerlink" title="8. 分解与复用"></a>8. 分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p><img src="_asset/分解与复用.png"><p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p><p><strong>抽取音频流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -acodec copy -vn out.aac</span></span><br></pre></td></tr></table></figure><ul><li><p>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</p></li><li><p>vn: v 代表视频，n 代表 no 也就是无视频的意思。</p></li></ul><p><strong>抽取视频流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -vcodec copy -an out.h264</span></span><br></pre></td></tr></table></figure><ul><li><p>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</p></li><li><p>an: a 代表视频，n 代表 no 也就是无音频的意思。</p></li></ul><p><strong>转格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span></span><br></pre></td></tr></table></figure><p>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了 flv。</p><p><strong>音视频合并</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</span></span><br></pre></td></tr></table></figure><h2 id="9-处理原始数据"><a href="#9-处理原始数据" class="headerlink" title="9. 处理原始数据"></a>9. <strong>处理原始数据</strong></h2><p><strong>提取YUV数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffplay -s wxh out.yuv</span></span><br></pre></td></tr></table></figure><ul><li><p>-c:v rawvideo 指定将视频转成原始数据</p></li><li><p>-pixel_format yuv420p 指定转换格式为 yuv420p</p></li></ul><p><strong>YUV 转 H264</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</span></span><br></pre></td></tr></table></figure><p><strong>提取 PCM 数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</span></span><br></pre></td></tr></table></figure><p><strong>PCM 转 WAV</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</span></span><br></pre></td></tr></table></figure><h2 id="10-滤镜"><a href="#10-滤镜" class="headerlink" title="10. 滤镜"></a>10. <strong>滤镜</strong></h2><p>在编码之前，ffmpeg 可以使用 libavfilter 库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg 区分两种类型的过滤器图形：简单和复杂。</p><h3 id="10-1-简单滤镜"><a href="#10-1-简单滤镜" class="headerlink" title="10.1 简单滤镜"></a>10.1 简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p><img src="_asset/简单滤镜.png"><p>简单的 filtergraphs 配置了 per-stream-filter 选项（分别为视频和音频使用 <code>-vf</code> 和 <code>-af</code> 别名）。 一个简单的视频 filtergraph 可以看起来像这样的例子：</p><img src="_asset/简单滤镜-01.png"><p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的 fps 过滤器会改变帧数，但不会触及帧内容。 另一个例子是 setpts 过滤器，它只设置时间戳，否则不改变帧。</p><h3 id="10-2-复杂滤镜"><a href="#10-2-复杂滤镜" class="headerlink" title="10.2 复杂滤镜"></a>10.2 复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p><img src="_asset/复杂滤镜.png"><p>复杂的过滤器图使用 <code>-filter_complex</code> 选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。</p><p><code>-lavfi</code> 选项等同于 <code>-filter_complex</code>。</p><p>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是 amix 滤波器。</p><p><strong>添加水印</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4  -vf <span class="string">"movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]"</span> water.mp4</span></span><br></pre></td></tr></table></figure><ul><li>-vf 中的 movie 指定 logo 位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。</li></ul><p><strong>删除水印</strong></p><p>先通过 ffplay 找到要删除 LOGO 的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -i test.flv -vf delogo=x=806:y=20:w=70:h=80:show=1</span></span><br></pre></td></tr></table></figure><p>使用 delogo 滤镜删除 LOGO</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.flv -vf delogo=x=806:y=20:w=70:h=80 output.flv</span></span><br></pre></td></tr></table></figure><p><strong>视频缩小一倍</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4</span></span><br></pre></td></tr></table></figure><ul><li>-vf scale 指定使用简单过滤器 scale，<code>iw/2:-1</code> 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</li></ul><p><strong>视频裁剪</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i VR.mov  -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</span></span><br></pre></td></tr></table></figure><p>crop 格式：<code>crop=out_w:out_h:x:y</code></p><ul><li><p>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</p></li><li><p>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</p></li><li><p>x : X坐标</p></li><li><p>y : Y坐标</p></li></ul><p>如果 x 和 y 设置为 0, 说明从左上角开始裁剪。如果不写是从中心点裁剪。</p><p><strong>倍速播放</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -filter_complex <span class="string">"[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]"</span> -map <span class="string">"[v]"</span> -map <span class="string">"[a]"</span> speed2.0.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-filter_complex 复杂滤镜，<code>[0:v]</code> 表示第一个（文件索引号是 0）文件的视频作为输入。<code>setpts=0.5*PTS</code> 表示每帧视频的 pts 时间戳都乘 0.5 ，也就是差少一半。<code>[v]</code> 表示输出的别名。音频同理就不详述了。</p></li><li><p>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</p></li></ul><p><strong>对称视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -i out.mp4 -filter_complex <span class="string">"[0:v]pad=w=2*iw[a];[0:v]hflip[b];[a][b]overlay=x=w"</span> duicheng.mp4</span></span><br></pre></td></tr></table></figure><ul><li>hflip 水平翻转</li></ul><p>如果要修改为垂直翻转可以用 vflip。</p><p><strong>画中画</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -i out1.mp4 -filter_complex <span class="string">"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart new.mp4</span></span><br></pre></td></tr></table></figure><p><strong>录制画中画</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation -i <span class="string">"0:0"</span> </span></span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast </span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 </span><br><span class="line">-filter_complex "[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[a];[0:v][a]overlay=x=W-w-10:y=0[out]" </span><br><span class="line">-map "[out]" -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure><p><strong>多路视频拼接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation   -i <span class="string">"0:0"</span> -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex <span class="string">"[0:v]scale=320:240[a];[a]pad=640:240[b];[b][1:v]overlay=320:0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart  -map 1:a  c.mp4</span></span><br></pre></td></tr></table></figure><h2 id="11-音视频的拼接与裁剪"><a href="#11-音视频的拼接与裁剪" class="headerlink" title="11. 音视频的拼接与裁剪"></a>11. <strong>音视频的拼接与裁剪</strong></h2><p><strong>裁剪</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</span></span><br></pre></td></tr></table></figure><ul><li><p>-ss 指定裁剪的开始时间，精确到秒</p></li><li><p>-t 被裁剪后的时长。</p></li></ul><p><strong>合并</strong></p><p>首先创建一个 inputs.txt 文件，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'1.flv'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'2.flv'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file <span class="string">'3.flv'</span></span></span><br></pre></td></tr></table></figure><p>然后执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f concat -i inputs.txt -c copy output.flv</span></span><br></pre></td></tr></table></figure><p><strong>hls切片</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</span></span><br></pre></td></tr></table></figure><ul><li><p>-strict -2 指明音频使有AAC。</p></li><li><p>-f hls 转成 m3u8 格式。</p></li></ul><h2 id="12-视频图片互转"><a href="#12-视频图片互转" class="headerlink" title="12. 视频图片互转"></a>12. 视频图片互转</h2><p><strong>视频转 JPEG</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</span></span><br></pre></td></tr></table></figure><p><strong>视频转 gif</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</span></span><br></pre></td></tr></table></figure><p><strong>图片转视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</span></span><br></pre></td></tr></table></figure><h2 id="13-直播相关"><a href="#13-直播相关" class="headerlink" title="13. 直播相关"></a>13. <strong>直播相关</strong></h2><p><strong>推流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span></span><br></pre></td></tr></table></figure><p><strong>拉流保存</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><p><strong>转流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream</span></span><br></pre></td></tr></table></figure><p><strong>实时推流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -framerate 15 -f avfoundation -i <span class="string">"1"</span> -s 1280x720 -c:v libx264  -f  flv rtmp://localhost:1935/live/room</span></span><br></pre></td></tr></table></figure><h2 id="14-ffplay"><a href="#14-ffplay" class="headerlink" title="14. ffplay"></a>14. <strong>ffplay</strong></h2><p><strong>播放 YUV 数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -pix_fmt nv12 -s 192x144 1.yuv</span></span><br></pre></td></tr></table></figure><p><strong>播放 YUV 中的 Y 平面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes=<span class="string">'y'</span> 1.yuv</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。&lt;/p&gt;
&lt;p&gt;本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。&lt;/p&gt;
&lt;h2 id=&quot;2-FFMPEG-目录及作用&quot;&gt;&lt;a href=&quot;#2-FFMPEG-目录及作用&quot; class=&quot;headerlink&quot; title=&quot;2. FFMPEG 目录及作用&quot;&gt;&lt;/a&gt;2. FFMPEG 目录及作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;libavcodec： 提供了一系列编码器的实现。&lt;/li&gt;
&lt;li&gt;libavformat： 实现在流协议，容器格式及其本IO访问。&lt;/li&gt;
&lt;li&gt;libavutil： 包括了hash器，解码器和各类工具函数。&lt;/li&gt;
&lt;li&gt;libavfilter： 提供了各种音视频过滤器。&lt;/li&gt;
&lt;li&gt;libavdevice： 提供了访问捕获设备和回放设备的接口。&lt;/li&gt;
&lt;li&gt;libswresample： 实现了混音和重采样。&lt;/li&gt;
&lt;li&gt;libswscale： 实现了色彩转换和缩放工能。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频核心技术</title>
    <link href="http://miaopei.github.io/2019/04/30/FFmpeg/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>http://miaopei.github.io/2019/04/30/FFmpeg/音视频核心技术/</id>
    <published>2019-04-30T06:14:50.000Z</published>
    <updated>2019-06-03T08:10:56.878Z</updated>
    
    <content type="html"><![CDATA[<img src="/imageFFmpeg/FFmpeg音视频架构-01.png"><a id="more"></a><img src="/imageFFmpeg/FFmpeg音视频架构-02.png"><h2 id="1-学习大纲"><a href="#1-学习大纲" class="headerlink" title="1. 学习大纲"></a>1. 学习大纲</h2><p><strong>FFmpeg 常用命令</strong>：</p><ul><li>视频录制命令</li><li>多媒体文件的分解/复用命令</li><li>裁剪与合并命令</li><li>图片/视频互转命令</li><li>直播相关命令</li><li>各种滤镜命令</li></ul><p><strong>FFmpeg 基本开发</strong>：</p><ul><li>C 语言回顾</li><li>FFmpeg 核心概念与常用结构体</li><li>实战 - 多媒体文件的分解与复用</li><li>实战 - 多媒体格式的互转</li><li>实战 - 从 MP4 裁剪一段视频</li><li>作业 - 实现一个简单的小咖秀</li></ul><p><strong>音视频编解码实战</strong>：</p><ul><li>实战 - H264 解码</li><li>实战 - H264 编码</li><li>实战 - 音频 AAC 解码</li><li>实战 - 音频 AAC 编码</li><li>实战 - 视频转图片</li></ul><p><strong>音视频渲染实战</strong>：</p><ul><li>SDL 事件处理</li><li>SDL 视频文理渲染</li><li>SDL 音频渲染</li><li>实战1 - 实现 YUV 视频播放</li><li>实战2 - YUV 视频倍数播放</li><li>实战3 - 实现 PCM 播放器</li></ul><p><strong>FFmpeg 开发播放器核心功能</strong>：</p><ul><li>实战 - 实现 MP4 文件的视频播放</li><li>实战 - 实现 MP4 文件的音频播放</li><li>实战 - 实现一个初级播放器</li><li>实战 - 音视频同步</li><li>实战 - 实现播放器内核</li></ul><p><strong>Android 中实战 FFmpeg</strong>：</p><ul><li>编译 Android 端可以使用的 FFmpeg</li><li>Java 与 C 语言相互调用</li><li>实战 - Android 调用 FFmpeg</li></ul><p><strong>学习建议</strong>：</p><ul><li>牢牢抓住音视频的处理机制，了解其本质</li><li>勤加练习，熟能生巧</li><li>待着问题去学习，事半功倍</li></ul><p><strong>音视频的广泛应用</strong>：</p><ul><li>直播类：音视频会议、教育直播、娱乐/游戏直播</li><li>短视频：抖音、快手、小咖秀</li><li>网络视频：优酷、腾讯视频、爱奇艺等</li><li>音视频通话：微信、QQ、Skype等</li><li>视频监控</li><li>人工智能：人脸识别，智能音箱等，更关注算法</li></ul><p><strong>播放器架构</strong>：</p><img src="_asset/播放器架构.png"><p><strong>渲染流程</strong>：</p><img src="_asset/渲染流程.png"><p><strong>FFmpeg 都能做啥</strong>：</p><ul><li>FFmpeg 是一个非常优秀的多媒体框架</li><li>FFmpeg 可以运行在 Linux、Mac、Windows 等平台上</li><li>能够解码、编码、转码、复用、解复用、过滤音视频数据</li></ul><p><strong>FFmpeg 下载便于与安装</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://git.ffmpeg.org/ffmpeg.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> config -- <span class="built_in">help</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure><h2 id="2-FFmpeg-常用命令实战"><a href="#2-FFmpeg-常用命令实战" class="headerlink" title="2. FFmpeg 常用命令实战"></a>2. FFmpeg 常用命令实战</h2><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解 / 复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><img src="_asset/FFmpeg处理音视频流程.png"><img src="_asset/FFmpeg基本信息查询命令.png"><img src="_asset/FFmpeg录屏命令.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffplay -s 2560x1600 -pix_fmt uyvy422 out.yuv</span></span><br></pre></td></tr></table></figure><img src="_asset/分解与复用-01.png"><img src="_asset/多媒体格式转换.png"><h2 id="3-初级开发内容"><a href="#3-初级开发内容" class="headerlink" title="3. 初级开发内容"></a>3. 初级开发内容</h2><ul><li>FFmpeg 日志的使用及目录的操作</li><li>介绍 FFmpeg 的基本概念及常用的结构体</li><li>对复用/解复用及流程操作的各种实践</li></ul><p>FFmpeg 代码结构：</p><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各类工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h3 id="3-1-FFmpeg-日志系统"><a href="#3-1-FFmpeg-日志系统" class="headerlink" title="3.1 FFmpeg 日志系统"></a>3.1 FFmpeg 日志系统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">av_log_set_level(AV_LOG_DEBUG)</span><br><span class="line">    </span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"...%s\n"</span>, op)</span><br></pre></td></tr></table></figure><ul><li>AV_LOG_ERROR</li><li>AV_LOG_WARNING</li><li>AV_LOG_INFO</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line"></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"hello world: %s!\n"</span>, <span class="string">"aaa"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-FFmpeg-文件与目录操作"><a href="#3-2-FFmpeg-文件与目录操作" class="headerlink" title="3.2 FFmpeg 文件与目录操作"></a>3.2 FFmpeg 文件与目录操作</h3><p>文件的删除与重命名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">avpriv_io_delete()</span><br><span class="line">    </span><br><span class="line">avpriv_io_move(src, dst)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = avpriv_io_delete(<span class="string">"./mytestfile.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to delete file mytestfile.txt\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = avpriv_io_move(<span class="string">"111.txt"</span>, <span class="string">"222.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Filed to rename\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --libs libavformat`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pkg-config --libs libavformat 指令可以搜索libavformat库所在路径</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> pkg-config --libs libavformat</span></span><br><span class="line">-L/usr/local/ffmpeg/lib -lavformat</span><br></pre></td></tr></table></figure><h3 id="3-3-FFmpeg-操作目录重要函数"><a href="#3-3-FFmpeg-操作目录重要函数" class="headerlink" title="3.3 FFmpeg 操作目录重要函数"></a>3.3 FFmpeg 操作目录重要函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line">avio_open_dir()</span><br><span class="line">avio_read_dir()</span><br><span class="line">avio_close_dir()</span><br></pre></td></tr></table></figure><p>操作目录重要结构体：</p><ul><li><p>AVIODirContext</p><p>操作目录的上下文</p></li><li><p>AVIODirEntry</p><p>目录项。用于存放文件名，文件大小等信息</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVIODirContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVIODirEntry *entry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = avio_open_dir(&amp;ctx, <span class="string">"./"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant open dir:%s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = avio_read_dir(ctx, &amp;entry);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant read dir: %s\n"</span>, av_err2str(ret));</span><br><span class="line">            <span class="keyword">goto</span> __fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"%l2"</span>PRId64<span class="string">" %s\n"</span>,</span><br><span class="line">               entry-&gt;size,</span><br><span class="line">               entry-&gt;name);</span><br><span class="line"></span><br><span class="line">        avio_free_directory_entry(&amp;entry);</span><br><span class="line">    &#125;</span><br><span class="line">__fail:</span><br><span class="line">    avio_close_dir(&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o list ffmpeg_list.c `pkg-config --libs libavformat libavutil`</span></span><br></pre></td></tr></table></figure><h3 id="3-4-多媒体文件的基本概念"><a href="#3-4-多媒体文件的基本概念" class="headerlink" title="3.4 多媒体文件的基本概念"></a>3.4 多媒体文件的基本概念</h3><ul><li>多媒体文件其实是个容器</li><li>在容器里有很多流（Stream/Track)</li><li>每种流是由不同的编码器编码的</li><li>从流中读出的数据称为包</li><li>在一个包中包含着一个或多个帧</li></ul><p>几个重要的结构体：</p><ul><li>AVFormatContext</li><li>AVStream</li><li>AVPacket</li></ul><p>FFmpeg 操作流数据的基本步骤：</p><p>解复用 —&gt; 获取流 —&gt; 读取数据包 —&gt;  释放资源</p><h3 id="3-5-实战-打印音-视频信息"><a href="#3-5-实战-打印音-视频信息" class="headerlink" title="3.5 [实战] 打印音/视频信息"></a>3.5 [实战] 打印音/视频信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_register_all()</span><br><span class="line">avformat_open_input() / avformat_close_input()</span><br><span class="line">av_dump_format()</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    ret = avformat_open_input(&amp;fmt_ctx, <span class="string">"./test.mp4"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open file: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, <span class="string">"./test.mp4"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;fmt_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-实战-抽取音频数据"><a href="#3-6-实战-抽取音频数据" class="headerlink" title="3.6 [实战] 抽取音频数据"></a>3.6 [实战] 抽取音频数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_init_packet()</span><br><span class="line">av_find_best_stream()</span><br><span class="line">av_read_frame() / av_packet_unref()</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> audio_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *src = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *dst = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. read two params form console</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"eg: %s in_file out_file\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    src = argv[<span class="number">1</span>];</span><br><span class="line">    dst = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (!src || !dst) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"src or dst is null\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = avformat_open_input(&amp;fmt_ctx, src, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open file: %s\n"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *dst_fd = fopen(dst, <span class="string">"wb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dst_fd) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open out file!\n"</span>);</span><br><span class="line">        avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, src, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. get stream</span></span><br><span class="line">    ret = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't find the best stream!\n"</span>);</span><br><span class="line">        avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">        fclose(dst_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_index = ret;</span><br><span class="line">    av_init_packet(&amp;pkt);</span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(fmt_ctx, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt.stream_index == audio_index) &#123;</span><br><span class="line">            <span class="comment">// 3. write audio data to aac file.</span></span><br><span class="line">            len = fwrite(pkt.data, <span class="number">1</span>, pkt.size, dst_fd);</span><br><span class="line">            <span class="keyword">if</span> (len != pkt.size) &#123;</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">"warning, length of data is not equal size of pkt!\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">    <span class="keyword">if</span> (dst_fd) &#123;</span><br><span class="line">        fclose(dst_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lang -g -o extra_audio extra_audio.c `pkg-config --libs libavutil libavformat`</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./extra_audio test.mp4 killer.aa</span></span><br></pre></td></tr></table></figure><h3 id="3-7-实战-抽取视频数据"><a href="#3-7-实战-抽取视频数据" class="headerlink" title="3.7 [实战] 抽取视频数据"></a>3.7 [实战] 抽取视频数据</h3><ul><li>Start code</li><li>SPS/PPS</li><li>codec -&gt; extradata</li></ul><h3 id="3-8-实战-将-MP4-转成-FLV-格式"><a href="#3-8-实战-将-MP4-转成-FLV-格式" class="headerlink" title="3.8 [实战] 将 MP4 转成 FLV 格式"></a>3.8 [实战] 将 MP4 转成 FLV 格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">avformat_alloc_output_context2() / avformat_free_context();</span><br><span class="line">avformat_new_stream();</span><br><span class="line">avcodec_parameters_copy();</span><br><span class="line">avformat_write_header();</span><br><span class="line">av_write_frame() / av_interleaved_write_frame();</span><br><span class="line">av_write_trailer()</span><br></pre></td></tr></table></figure><h3 id="3-9-实战-从-MP4-截取一段视频"><a href="#3-9-实战-从-MP4-截取一段视频" class="headerlink" title="3.9 [实战] 从 MP4 截取一段视频"></a>3.9 [实战] 从 MP4 截取一段视频</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_seek_frame()</span><br></pre></td></tr></table></figure><h3 id="3-10-实战-一个简单的小咖秀"><a href="#3-10-实战-一个简单的小咖秀" class="headerlink" title="3.10 [实战] 一个简单的小咖秀"></a>3.10 [实战] 一个简单的小咖秀</h3><ul><li><p>将两个媒体文件中分别抽取音频与视频轨</p></li><li><p>将音频与视频轨合并成一个新文件</p></li><li><p>对音频与视频轨进行裁剪</p><h2 id="4-FFmpeg-中级开发内容"><a href="#4-FFmpeg-中级开发内容" class="headerlink" title="4. FFmpeg 中级开发内容"></a>4. FFmpeg 中级开发内容</h2></li><li><p>FFmpeg H264 解码</p></li><li><p>FFmpeg H264 编码</p></li><li><p>FFmpeg AAC 解码</p></li><li><p>FFmpeg AAC 编码</p></li></ul><h3 id="4-1-FFmpeg-H264-解码"><a href="#4-1-FFmpeg-H264-解码" class="headerlink" title="4.1 FFmpeg H264 解码"></a>4.1 FFmpeg H264 解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>常用数据结构：</p><ul><li><p>AVCodec 编码器结构体</p></li><li><p>AVCodecContext 编码器上下文</p></li><li><p>AVFrame 解码后的帧</p><p>结构体内存的分配与释放：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_frame_alloc / av_frame_free();</span><br><span class="line">avcodec_alloc_context3();</span><br><span class="line">avcodec_free_context();</span><br></pre></td></tr></table></figure><p>解码步骤：</p><ul><li>查找解码器（avcodec_find_decoder）</li><li>打开解码器（avcodec_open2）</li><li>解码（avcodec_decode_video2）</li></ul><h3 id="4-2-FFmpeg-H264-编码"><a href="#4-2-FFmpeg-H264-编码" class="headerlink" title="4.2 FFmpeg H264 编码"></a>4.2 FFmpeg H264 编码</h3><p>H264编码流程：</p><ul><li>查找编码器（avcodec_find_encoder_by_name）</li><li>设置参数，打开编码器（avcondec_open2）</li><li>编码（avcondec_encode_video2）</li></ul><h3 id="4-3-视频转图片"><a href="#4-3-视频转图片" class="headerlink" title="4.3 视频转图片"></a>4.3 视频转图片</h3><p>TODO</p><h3 id="4-4-FFmpeg-AAC-编码"><a href="#4-4-FFmpeg-AAC-编码" class="headerlink" title="4.4 FFmpeg AAC 编码"></a>4.4 FFmpeg AAC 编码</h3><ul><li>编码流程与视频相同</li><li>编码函数 avcodec_encodec_audio2</li></ul><h2 id="5-SDL-介绍"><a href="#5-SDL-介绍" class="headerlink" title="5. SDL 介绍"></a>5. SDL 介绍</h2><blockquote><p><a href="[http://www.libsdl.org](http://www.libsdl.org/)">SDL 官网</a></p></blockquote><ul><li>SDL（Simple DirectMedia Layer） 是一套<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTk2JThCJUU2JTk0JUJFJUU1JThFJTlGJUU1JUE3JThCJUU3JUEyJUJD" title="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%8E%9F%E5%A7%8B%E7%A2%BC">开放源代码<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUE4JUU1JUI5JUIzJUU1JThGJUIw" title="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JTlBJUU1JUFBJTkyJUU5JUFCJTk0" title="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E9%AB%94">多媒体<i class="fa fa-external-link"></i></span>开发<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg3JUJEJUU1JUJDJThGJUU1JUJBJUFC" title="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">库<i class="fa fa-external-link"></i></span></li><li>由 C 语言实现的跨平台的媒体开源库</li><li>多用于开发游戏、模拟器、媒体播放器等多媒体应用领域</li></ul><p>语法与子系统：</p><p>SDL将功能分成下列数个子系统（subsystem）：</p><ul><li><strong>Video（图像）</strong>—图像控制以及线程（thread）和事件管理（event）。</li><li><strong>Audio（声音）</strong>—声音控制</li><li><strong>Joystick（摇杆）</strong>—游戏摇杆控制</li><li><strong>CD-ROM（光盘驱动器）</strong>—光盘媒体控制</li><li><strong>Window Management（视窗管理）</strong>－与视窗程序设计集成</li><li><strong>Event（事件驱动）</strong>－处理事件驱动</li></ul><p>以下是一支用C语言写成、非常简单的SDL示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Headers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SDL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize SDL</span></span><br><span class="line">    <span class="keyword">if</span>(SDL_Init(SDL_INIT_EVERYTHING) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delay 2 seconds</span></span><br><span class="line">    SDL_Delay(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Quit SDL</span></span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序会加载所有SDL子系统（出错则退出程序），然后暂停两秒，最后关闭SDL并退出程序。</p><h3 id="5-1-SDL-编译与安装"><a href="#5-1-SDL-编译与安装" class="headerlink" title="5.1 SDL 编译与安装"></a>5.1 SDL 编译与安装</h3><ul><li>下载 SDL 源码</li><li>生成Makefile configure –prefix=/usr/local</li><li>安装 sudo make -j 8 &amp;&amp; make install</li></ul><h3 id="5-2-使用-SDL-基本步骤"><a href="#5-2-使用-SDL-基本步骤" class="headerlink" title="5.2 使用 SDL 基本步骤"></a>5.2 使用 SDL 基本步骤</h3><ul><li>添加头文件 #include &lt;SDL.h&gt;</li><li>初始化 SDL</li><li>退出 SDL</li></ul><p>SDL 渲染窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_Init() / SDL_Quit();</span><br><span class="line">SDL_CreateWindow() / SDL_DestoryWindow();</span><br><span class="line">SDL_CreateRender();  <span class="comment">// 创建渲染器</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o first_sdl first_sdl.c `pkg-config --libs sdl2`</span></span><br></pre></td></tr></table></figure><p>SDL 渲染窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateRender() / SDL_DestoryRenderer();</span><br><span class="line">SDL_RenderClear();</span><br><span class="line">SDL_RenderPresent();</span><br></pre></td></tr></table></figure><h3 id="5-3-SDL-事件基本原理"><a href="#5-3-SDL-事件基本原理" class="headerlink" title="5.3 SDL 事件基本原理"></a>5.3 SDL 事件基本原理</h3><ul><li>SDL 将所有的事件都存放在一个队列中</li><li>所有对事件的操作，其实就是队列的操作</li></ul><p>SDL 事件种类：</p><ul><li>SDL_WindowEvent：窗口事件</li><li>SDL_KeyboardEvent：键盘事件</li><li>SDL_MouseMotionEvent：鼠标事件</li><li>自定义事件</li></ul><p>SDL 事件处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_PollEvent(); <span class="comment">// 轮询检测</span></span><br><span class="line">SDL_WaitEvent(); <span class="comment">// 常用的方式</span></span><br><span class="line">SDL_WaitEventTimeout();</span><br></pre></td></tr></table></figure><h3 id="5-4-文理渲染"><a href="#5-4-文理渲染" class="headerlink" title="5.4 文理渲染"></a>5.4 文理渲染</h3><p>SDL 渲染基本原理：</p><img src="_asset/SDL渲染基本原理.png"><p>SDL 文理相关 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateTexture();</span><br><span class="line">- format: YUV, RGB</span><br><span class="line">- access: Texture 类型， Target， Stream</span><br><span class="line"></span><br><span class="line">SDL_DestroyTexture();</span><br></pre></td></tr></table></figure><p>SDL 渲染相关 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_SetRenderTarget();</span><br><span class="line">SDL_RenderClear();</span><br><span class="line">SDL_RenderCopy();</span><br><span class="line">SDL_RenderPresent();</span><br></pre></td></tr></table></figure><h3 id="5-5-实战-YUV-视频播放器"><a href="#5-5-实战-YUV-视频播放器" class="headerlink" title="5.5 [实战] YUV 视频播放器"></a>5.5 [实战] YUV 视频播放器</h3><p>创建线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateThread();</span><br><span class="line">- fn: 线程执行函数</span><br><span class="line">- name: 线程名</span><br><span class="line">- data: 执行函数参数</span><br></pre></td></tr></table></figure><p>SDL 更新文理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_UpdateTexture();</span><br><span class="line">SDL_UpdateYUVTexture();</span><br></pre></td></tr></table></figure><h3 id="5-6-SDL-播放音频"><a href="#5-6-SDL-播放音频" class="headerlink" title="5.6 SDL 播放音频"></a>5.6 SDL 播放音频</h3><p>播放音频基本流程：</p><img src="_asset/播放音频基本流程.png"><p>播放音频的基本原则：</p><ul><li>声卡向你要数据而不是你主动推给声卡</li><li>数据的多少由音频参数决定的</li></ul><p>SDL 音频 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_OpenAudio() / SDL_CloseAudio();</span><br><span class="line">SDL_PauseAudio();</span><br><span class="line">SDL_MixAudio();</span><br></pre></td></tr></table></figure><h3 id="5-7-实现-PCM-播放器"><a href="#5-7-实现-PCM-播放器" class="headerlink" title="5.7 实现 PCM 播放器"></a>5.7 实现 PCM 播放器</h3><p>TODO</p><h2 id="6-最简单的播放器"><a href="#6-最简单的播放器" class="headerlink" title="6. 最简单的播放器"></a>6. 最简单的播放器</h2><ul><li>该播放器只实现视频播放</li><li>将 FFmpeg 与 SDL 结合到一起</li><li>通过 FFmpeg 解码视频数据</li><li>通过 SDL 进行渲染</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -g -o player2 player2.c `pkg-config --cflags --libs sdl2 libavformat libavutil libswscale libavcodec libswresample`</span></span><br></pre></td></tr></table></figure><p>最简单的播放器之二：</p><ul><li>可以同时播放音频与视频</li><li>使用队列存放音频包</li></ul><h3 id="6-1-多线程与锁"><a href="#6-1-多线程与锁" class="headerlink" title="6.1 多线程与锁"></a>6.1 多线程与锁</h3><p>为什么要用多线程：</p><ul><li>多线程的好处</li><li>多线程带来的问题</li></ul><p>线程的互斥与同步：</p><ul><li><p>互斥</p></li><li><p>同步</p><p>大的任务分为很多小任务通过信号协调</p></li></ul><p>锁与信号量：</p><ul><li>锁的种类</li><li>通过信号进行同步</li></ul><p>锁的中种类：</p><ul><li>读写锁</li><li>自旋锁</li><li>可重入锁</li></ul><p>SDL 线程的创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateThread();</span><br><span class="line">SDL_WaitThread();</span><br></pre></td></tr></table></figure><p>SDL 锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateMutex() / SDL_DestroyMutex();  <span class="comment">// 创建互斥量</span></span><br><span class="line">SDL_LockMutex() / SDL_UnlockMutex(); <span class="comment">// 锁互斥量于解锁互斥量</span></span><br></pre></td></tr></table></figure><p>SDL 条件变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDL_CreateCond() / SDL_DestroyCond();</span><br><span class="line">SDL_CondWait() / SDL_CondSignal();</span><br></pre></td></tr></table></figure><h3 id="6-2-锁与条件变量的使用"><a href="#6-2-锁与条件变量的使用" class="headerlink" title="6.2 锁与条件变量的使用"></a>6.2 锁与条件变量的使用</h3><p>TODO</p><h3 id="6-3-播放器线程模型"><a href="#6-3-播放器线程模型" class="headerlink" title="6.3 播放器线程模型"></a>6.3 播放器线程模型</h3><img src="_asset/播放器线程模型.png"><h3 id="6-4-线程的退出机制"><a href="#6-4-线程的退出机制" class="headerlink" title="6.4 线程的退出机制"></a>6.4 线程的退出机制</h3><ul><li>主线程接收到退出事件</li><li>解复用线程在循环分流时对 quit 进行判断</li><li>视频解码线程从视频流队列中取包时对 quit 进行判断</li><li>音视解码从音频流队列中取包时对 quit 进行判断</li><li>音视循环解码时对 quit 进行判断</li><li>在收到信号变量消息时对 quit 进行判断</li></ul><h2 id="6-5-音视频同步"><a href="#6-5-音视频同步" class="headerlink" title="6.5 音视频同步"></a>6.5 音视频同步</h2><p>时间戳：</p><ul><li>PTS：Presentation timestamp  渲染时间戳</li><li>DTS：Decoding timestamp 解码时间戳</li><li>I（intra）/ B（bidirectional）/ P（predicted）帧</li></ul><p>时间戳顺序：</p><ul><li>实际帧顺序：I B B P</li><li>存放帧顺序：I P B B</li><li>解码时间戳：1 4 2 3</li><li>展示时间戳：1 2 3 4</li></ul><p>从哪儿获得 PTS：</p><ul><li>AVPacket 中的 PTS</li><li>AVFrame 中的 PTS</li><li>av_frame_get_best_effort_timestamp()</li></ul><p>时间基：</p><ul><li>tbr：帧率</li><li>tbn：time base of stream 流的时间基</li><li>tbc：time base of codec 解码的时间基</li></ul><p>计算当前帧的 PTS：</p><ul><li><code>PTS = PTS * av_q2d(video_stream-&gt;time_base)</code></li><li><code>av_q2d(AVRotional a){ return a.num / (double)a.den; }</code></li></ul><p>计算下一帧的 PTS：</p><ul><li>video_clock：预测的下一帧视频的 PTS</li><li>frame_delay：1/tbr</li><li>audio_clock：音频当前播放的时间戳</li></ul><p>音视频同步方式：</p><ul><li>视频同步到音频</li><li>音频同步到视频</li><li>音频和视频都同步到系统时钟  </li></ul><p>视频播放的基本思路：</p><ul><li>一般的做法，展示第一帧视频帧后，获得要显示的下一个视频帧的 PTS，然后设置一个定时器，当定时器超时时后，刷新新的视屏帧，如此反复操作。</li></ul><h2 id="7-如何在-Android-下使用-FFmpeg"><a href="#7-如何在-Android-下使用-FFmpeg" class="headerlink" title="7. 如何在 Android 下使用 FFmpeg"></a>7. 如何在 Android 下使用 FFmpeg</h2><p>Android 架构：</p><img src="_asset/Android架构.png"><p>内容：</p><ul><li>Java 与 C 之间的相互调用</li><li>Android 下 FFmpeg 的编译</li><li>Android 下如何使用FFmpeg</li></ul><p>第一个 JNI 程序：</p><p>TODO</p><p>JNI 基本概念：</p><ul><li>JNIEnv</li><li>JavaVM  一个Android APP只有一个 JavaVM， 一个 JavaVM 可以有多个JNIEnv</li><li>线程  一个线程对应一个JNIEnv</li></ul><p>Java调用C/C++ 方法一：</p><ul><li><p>在Java层定义 native 关键字函数</p></li><li><p>方法一：在C/C++层创建</p><p>Java_packname_classname_methodname 函数</p></li></ul><p>Java调用C/C++方法二：</p><img src="_asset/java调用c方法二.png"><img src="_asset/注册Native方法的最佳时机.png"><p>什么是Signature：</p><ul><li>Java与C/C++ 相互调用时，表式函数参数的描述符</li><li>输入参数放在（）内，输出参数放在（）外</li><li>多个参数之间顺序存放，且用 “；” 分割</li></ul><img src="_asset/原始类型的Signature.png"><img src="_asset/类的Signature.png"> <img src="_asset/例子.png"><p>C/C++ 调用 Java 方法：</p><ul><li>FindClass</li><li>GetMethodID / GetFieldID</li><li>NewObject</li><li><code>Call&lt;TYPE&gt;Method / [G/S]et&lt;type&gt;Field</code></li></ul><h3 id="7-1-实战-Android-下的播放器"><a href="#7-1-实战-Android-下的播放器" class="headerlink" title="7.1 [实战] Android 下的播放器"></a>7.1 [实战] Android 下的播放器</h3><p>TODO</p><h2 id="8-IOS-下使用-FFmpeg"><a href="#8-IOS-下使用-FFmpeg" class="headerlink" title="8. IOS 下使用 FFmpeg"></a>8. IOS 下使用 FFmpeg</h2><p>TODO</p><h2 id="9-音视频进阶"><a href="#9-音视频进阶" class="headerlink" title="9. 音视频进阶"></a>9. 音视频进阶</h2><ul><li>FFmpeg Filter 的使用 </li><li>FFmpeg 裁剪与优化</li><li>视频渲染（OpenGL / Metal）</li><li>声音的特效</li><li>网络传输</li><li>Webrtc - 实时互动、直播、P2P音视频传输</li><li>AR技术</li><li>OpenCV</li></ul><p>行业痛点：</p><ul><li>回音消除</li><li>降噪</li><li>视频秒开</li><li>多人多视频实时互动</li><li>PC端/APP/网页实时视频互通</li><li>实时互动与大并发负载</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/imageFFmpeg/FFmpeg音视频架构-01.png&quot;&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频入门知识</title>
    <link href="http://miaopei.github.io/2019/04/23/FFmpeg/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8/"/>
    <id>http://miaopei.github.io/2019/04/23/FFmpeg/移动端音视频入门/</id>
    <published>2019-04-23T02:14:50.000Z</published>
    <updated>2019-06-03T08:10:56.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-万人直播架构讲解"><a href="#1-万人直播架构讲解" class="headerlink" title="1. 万人直播架构讲解"></a>1. 万人直播架构讲解</h2><p>直播产品的种类：</p><ul><li><p>泛娱乐化直播</p><p>花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播</p></li><li><p>实时互动直播</p><p>音视频会议、教育直播等，像 思科、全时、声网</p></li></ul><p>泛娱乐化直播架构</p><blockquote><p>信令服务器：创建房间、聊天、礼物。。。。</p><p>美女主播 –信令–&gt; 信令服务器</p><p>信令服务器–rtmp流地址–&gt;美女主播</p><p>美女主播 –推流–&gt; 流媒体云CDN</p><p>观众 –信令–&gt; 信令服务器：将观众加入到美女主播间</p><p>信令服务器–rmtp流地址–&gt; 观众</p><p>观众 &lt;–拉流–&gt; 流媒体云CDN</p></blockquote><a id="more"></a><p>泛娱乐化直播架构</p><p>基于TCP协议实现</p><ol><li>发送信令到信令服务器, 服务器收到\执行后, 返回给共享端一个流媒体云的地址</li><li>共享端采集自己音视频数据, 形成rtmp流, 推送到CDN网络(推流)</li><li>获取流媒体云地址</li><li>拉流</li></ol><img src="_asset/泛娱乐化直播架构.png"><p>实时互动直播架构</p><p>基于UDP实现</p><ol><li>自有网络: UDP没有自有网络, 需自己搭建</li><li>多个节点: 为了保障服务的稳定性以及负载均衡</li><li>控制中心: 每个节点定期(心跳)向控制中心报告健康程度, 控制中心根据响应的数据做出决策</li><li>内总线: 数据安全性\吞吐量等可靠性得以保障</li><li>媒体服务器: 将RTP协议的数据转换成RTMP协议的数据</li><li>CDN网络: 根据用户需求进行拉流</li></ol><img src="_asset/实时互动直播架构.png"><h2 id="2-CDN网络介绍"><a href="#2-CDN网络介绍" class="headerlink" title="2. CDN网络介绍"></a>2. CDN网络介绍</h2><blockquote><p>CDN网络是为了解决什么问题而出现的？</p><p>总结为一句话：CDN网络是为了解决用户访问网络资源慢而出现的一个技术，两个原因：</p><ol><li>网络链路太长</li><li>人为因素（南电信北联通，利益相关）</li></ol></blockquote><p>CDN构成：</p><p>边缘结点：用户从边缘节点上获取数据</p><p>二级节点：主干网节点，主要用于缓存、减转源站压力</p><p>源站：CP(内容提供方)将内容放到源站</p><p>查找顺序：边缘结点-&gt;二级节点-&gt;源站</p><img src="_asset/CDN网络.png"><h2 id="3-亲手搭建一套简单的直播系统"><a href="#3-亲手搭建一套简单的直播系统" class="headerlink" title="3. 亲手搭建一套简单的直播系统"></a>3. 亲手搭建一套简单的直播系统</h2><p>安装nginx 配置rtmp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install nginx-full --with-rtmp-module</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">(这一步卡了我好久，安装nginx提示一直找不到nginx-full,网上相关的教程没更新，原因在于nginx仓库已搬迁)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew tap denji/nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nginx -s reload 重启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nginx  启动</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure><img src="_asset/nginx-trmp配置.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><img src="_asset/FFMPEG直播命令.png"><img src="_asset/测试流媒体服务器.png"><h2 id="4-音频基础知识"><a href="#4-音频基础知识" class="headerlink" title="4. 音频基础知识"></a>4. 音频基础知识</h2><img src="_asset/声音三要素.png"><p>图一音量：甲乙的振动频率相同、振幅不同。图二音调：甲乙振幅相同、频率不同</p><img src="_asset/音量与音调.png"><img src="_asset/音色.png"><img src="_asset/人类听觉范围.png"><img src="_asset/听觉-发声范围.png"><h2 id="5-音频的量化与编码"><a href="#5-音频的量化与编码" class="headerlink" title="5. 音频的量化与编码"></a>5. 音频的量化与编码</h2><p>模拟信号进行采样，采样时分频率的从模拟信号获取数据波形值，采样后，进行数据量化，量化后进行编码，把采样的十进制转化为计算机的二进制，也就是数字信号。</p><p>模拟数据——》采样——》量化——》编码——》数字信号</p><img src="_asset/音频量化过程.png"><p>采样大小决定了音频的振幅的高度，采样时指一个采样用多少bit存放，常用的是16bit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bit：位     一个二进制数据0或1，是1bit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> byte：字节  存储空间的基本计量单位，如：MySQL中定义 VARCHAR(45) 即是指 45个字节；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 Byte = 8 Bit = 1 字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2^8 = 256, 2^16 = 65535</span></span><br></pre></td></tr></table></figure><p>aac通常44.1k采样率</p><p>采样率:采样频率8k/秒、16k/秒、32k/秒、44.1k/秒、48k/秒</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzUxNjky" title="https://www.zhihu.com/question/20351692">什么是音频的采样率？采样率和音质有没有关系？<i class="fa fa-external-link"></i></span> - 知乎</p></blockquote><img src="_asset/量化基本概念.png"><p>人能听到的声音范围是20hz-2whz</p><p>码率 = 采样率 x 采样大小 x 声道数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 宽带速率的单位用 bps(或b/s)表示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 B = 8 b   1 B/s = 8 b/s</span></span><br></pre></td></tr></table></figure><img src="_asset/码率计算.png"><p>原始的wav文件，大小是1411.2Kb/s</p><p>做完aaclc的编码，大小是128Kb/s</p><p>如果是aache-vr这种编码，大小是32Kb/s</p><h2 id="6-音频压缩技术讲解"><a href="#6-音频压缩技术讲解" class="headerlink" title="6. 音频压缩技术讲解"></a>6. 音频压缩技术讲解</h2><p>音频压缩技术</p><p>1、消除冗余数据（有损压缩技术）。</p><p>压缩的主要方法是去除采集到的音频冗余信息，所谓冗余信息包括人耳听觉范围外的音频信号以及被掩蔽掉的音频信号</p><p>信号的掩蔽可分为频域掩蔽和时域掩蔽</p><p>频域掩蔽：一个强纯音会掩蔽在其附近同时发声的弱纯音。也称同时掩蔽</p><p>时域掩蔽：在时间上相邻的声音之间也有掩蔽现象，主要原因是人的大脑处理信息需要花费时间。</p><p>同步掩蔽效应和不同频率声音的频率和相对竟是有关，而时间掩蔽则仅仅和时间有关。如果两个声音在时间上特别接近，分辨会有困难（如两个声音音量相差较大且两个声音间隔时间低于5毫秒，则其中弱的那个声音会听不到）。</p><p>2、哈夫曼无损编码</p><img src="_asset/音频压缩技术.png"><p>音频压缩：频域，时域。</p><ul><li><p>频域: 截取人耳能听到的频率范围，滤掉响度低的声音，去掉某个高频周围低频的声音；</p></li><li><p>时域: 滤掉某个长时间说话中的低音</p></li></ul><img src="_asset/音频冗余信息.png"><img src="_asset/频域掩蔽效应.png"><img src="_asset/时域掩蔽效应.png"><img src="_asset/音频编码过程.png"><h2 id="7-音频编解码器选型"><a href="#7-音频编解码器选型" class="headerlink" title="7. 音频编解码器选型"></a>7. 音频编解码器选型</h2><p>网上测评结果：音频编解码器 opus &gt; aac &gt; vorbis </p><p>音频编解码器：</p><p>1：opus，</p><ul><li>口模型：实时互动，对实时性要求非常高 </li><li>耳模型：高保真，对质量要求非常高</li></ul><p>至于什么时候使用那个模型，由opus自己内部来决定，同时，他是性能最好的，压缩率最好。</p><p>2：AAC，经常用于泛娱乐化直播，因为其对实时性要求不是很高但是对音质要求可能较高，所以，选用AAC，当然也可以选用opus的耳模型</p><p>3：sppex，最大的特点就是不仅可以编码音频，还可以对音频进行降噪，优化，尽可能的获取原音频数据</p><p>4：G.711(722)，主要用于音视频会议，为了和固话进行相应的融合</p><img src="_asset/常见的音频编码器.png"><img src="_asset/音频编码器性能对比.png"><h2 id="8-AAC-讲解"><a href="#8-AAC-讲解" class="headerlink" title="8. AAC 讲解"></a>8. AAC 讲解</h2><p>cdn，rtmp  支持 aac</p><p>AAC 产生的目的是取代 MP3 格式：</p><p>AAC 相对优点：压缩率高，损耗低</p><img src="_asset/AAC介绍.png"><img src="_asset/AAC规格.png"><p>aac 三种类型<br>aac<br>aacv1: aac+sbr(频率复用-高频部分采样率高，低频部分采样率低)<br>aacv2: aac+sbr+ps(声道关联，一个声道采集全部，一个声道只采集相对不同的声音)</p><p>AAC规格描述（AAC、AAC HE、AAC HE V2）–&gt; AAC+SBR=AAC HE V1, AAC + SBR + PS = AAC HE V2</p><img src="_asset/AAC规格描述.png"><p>AAC格式：</p><p>1、ADIF(Audio Data Interchange Format):只能从头开始解码，常用在磁盘文件中。</p><p>2、ADTS(Audio Data Transport Stream)：这种格式每一帧都有一个同步字，可以在音频流的任何位置开始解码，它似于数据流格式（缺点：文件比ADIF大，优点:每个帧都可以被单独解码播放）</p><img src="_asset/AAC格式.png"><p>aac 编码库 ffmpeg AAC，libfdk AAC</p><img src="_asset/AAC编码库那个好.png"><h2 id="9-视频基本知识"><a href="#9-视频基本知识" class="headerlink" title="9. 视频基本知识"></a>9. 视频基本知识</h2><p>I帧：关键帧，采用帧内压缩技术</p><p>P帧：向前参考帧，压缩时只参考前一个帧，属于帧间压缩技术</p><p>B帧：双向参考帧，压缩时即参考前一帧也参考后一帧，属于帧间压缩技术</p><p>一般实时互动都不会使用 B 帧</p><img src="_asset/H264基本概念.png"><p>GOF(group of frame): 一组帧，可以将一段时间内画面变化不大的所有帧划为一组帧</p><img src="_asset/GOF.png"><p>SPS与PPS（这两种都划为 I 帧）：</p><ul><li><p>SPS(Sequence Parameter Set): </p><p>序列参数集，存放帧数、参考帧数目、解码图像尺寸、帧场编码模式选择标识等。</p></li><li><p>PPS(Picture Parameter Set):</p><p>图像参数集，存放熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系统数调整标识等</p></li></ul><img src="_asset/SPS与PPS.png"><p>视频花屏/卡顿原因：</p><p>1、如果 GOP 分组中的 P 帧丢失会造成解码端的图像发生错误（于是形成了花屏）。</p><p>2、为了避免花屏问题的发生，一般如果发现 P 帧或者I帧丢失，就不显示本 GOP 内的所有帧，直到下一个 I 帧来后重新刷新图像（因为丢了一组数据，所以形成了卡顿）</p><img src="_asset/视频花屏卡顿的原因.png"><p>视频编码器：</p><p>1、x264/x265。</p><p>2、openH264(支持 SVC（分层传输） 技术)。</p><p>3、vp8/vp9</p><img src="_asset/视频都有哪些视频编码器.png"><h2 id="10-H264-宏块的划分与帧分组"><a href="#10-H264-宏块的划分与帧分组" class="headerlink" title="10. H264 宏块的划分与帧分组"></a>10. H264 宏块的划分与帧分组</h2><p>H264压缩技术</p><ol><li>帧内预测压缩，解决的是空域数据冗余问题（将一幅图里的人眼不是很敏感的色彩、光亮等数据剔除）</li><li>帧间预测压缩，解决的是时域数据冗余问题（将一组图里面连续的重复性高的帧剔除）</li><li>整数离散余弦变换(DCT)，将空间上的相关性变为频域上无关的数据然后进行量化</li><li>CABAC压缩，也叫上下文适应无损压缩</li></ol><img src="_asset/H264压缩技术.png"><p>宏块的划分与分组：</p><p>H264宏块划分与子块划分：宏块里面可以再包含很多子块</p><img src="_asset/H264宏块划分.png"><img src="_asset/宏块划分完成.png"><p>子块划分：</p><img src="_asset/子块划分.png"><p>帧分组(一组连续的图片，一幅图片为一帧)</p><img src="_asset/帧分组.png"><h2 id="11-视频压缩技术详解"><a href="#11-视频压缩技术详解" class="headerlink" title="11. 视频压缩技术详解"></a>11. 视频压缩技术详解</h2><ul><li><p>帧间预测: </p><p>解决时间数据冗余，比较相邻两帧不同给出运动矢量 + 残差值</p></li><li><p>帧内预测: </p><p>解决空间数据冗余，每一个宏块有一个预测模式，然后讲预测后的图像与原图比较算差值，最后存储预测模式和差值即可。帧内压缩是针对于 I 帧的</p></li></ul><h3 id="11-1-帧间预测"><a href="#11-1-帧间预测" class="headerlink" title="11.1 帧间预测"></a>11.1 帧间预测</h3><p>组内宏块查找：</p><img src="_asset/组内宏块查找.png"><img src="_asset/运动估算.png"><img src="_asset/运动矢量与补偿压缩.png"><h3 id="11-2-帧内预测"><a href="#11-2-帧内预测" class="headerlink" title="11.2 帧内预测"></a>11.2 帧内预测</h3><img src="_asset/帧内预测.png"><img src="_asset/计算帧内预测残差值.png"><img src="_asset/预测模式与残差值压缩.png"><h3 id="11-3-DCT-压缩"><a href="#11-3-DCT-压缩" class="headerlink" title="11.3 DCT 压缩"></a>11.3 DCT 压缩</h3><img src="_asset/DCT压缩.png"><img src="_asset/压缩后的结果.png"><h3 id="11-4-VLC-压缩"><a href="#11-4-VLC-压缩" class="headerlink" title="11.4 VLC 压缩"></a>11.4 VLC 压缩</h3><img src="_asset/VLC压缩.png"><h3 id="11-5-CABAC-压缩"><a href="#11-5-CABAC-压缩" class="headerlink" title="11.5 CABAC 压缩"></a>11.5 CABAC 压缩</h3><img src="_asset/CABAC压缩.png"><h2 id="12-H264-结构与码流"><a href="#12-H264-结构与码流" class="headerlink" title="12. H264 结构与码流"></a>12. H264 结构与码流</h2><p>H264编码分层：</p><p>1、NAL层（Network Abstraction Layer）, 视频数据网络抽象层。</p><p>2、VCL层（Video Coding Layer），视频数据编码层，对原始数据进行压缩</p><p>码流基本概念：</p><p>1、SODB（String Of Data Bits）,原始数据比特流，长度不一定是8的倍数，它是由VCL层产生的。</p><p>2、RBSP（Raw Byte Sequence Payload,SODB+trailing bits），算法是在SODB最后一位补1，不按字节对齐则补0。</p><p>3、EBSP(Encapsulate Byte Sequence Payload)，需到两个连续的0x00就增加一个0x03。</p><p>4、NALU，NAL Header(1B)+EBSP</p><img src="_asset/H264结构图.png"><p>以太网最大传输字节 1500 字节。</p><img src="_asset/H264编码分层.png"><img src="_asset/码流基本概念一.png"><img src="_asset/码流基本概念二.png"><p>一个H264帧最少要有一个切片(NAL Unit)</p><img src="_asset/NALUnit.png"><p>切片与宏块的关系：</p><ul><li>每个切片都包括切片头和切片数据，</li><li>每个切片数据又包括了很多宏块，</li><li>每个宏块又包括了宏块的类型、宏块的预测、编码的残渣数据等</li></ul><img src="_asset/切片与宏.png"><img src="_asset/H264切片.png"><img src="_asset/H264码流分层.png"><h2 id="13-NAL-单元详解"><a href="#13-NAL-单元详解" class="headerlink" title="13. NAL 单元详解"></a>13. NAL 单元详解</h2><img src="_asset/NALHeader.png"><p>5 - 关键帧</p><p>7- SPS 序列参数集</p><p>8- PPS 图像参数集</p><img src="_asset/NALType一.png"><img src="_asset/NALType二.png"><img src="_asset/NAL类型介绍.png"><img src="_asset/单一NALU的RTP包.png"><img src="_asset/组合NALU的RTP包.png"><p>如：</p><p>P帧B帧很多都是单一类型。</p><p>SPS和PPS这两个NAL单元一般放在同一个RTP包里头</p><img src="_asset/分片NALU的RTP包.png"><img src="_asset/FUHeader.png"><h2 id="14-YUV-讲解"><a href="#14-YUV-讲解" class="headerlink" title="14. YUV 讲解"></a>14. YUV 讲解</h2><img src="_asset/图像除了RGB还是有YUV.png"><img src="_asset/YUV.png"><p>YUV常见格式：YUV4:2:0、YUV4:2:2、YUV4:4:4</p><p>RGB8:8:8</p><img src="_asset/YUV常见格式.png"><img src="_asset/YUV420.png"><ul><li>UV 混存则为packed(打包存储)，</li><li>UV分开存则为planar(平面存储) </li></ul><img src="_asset/YUV存储格式.png"><h2 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h2><img src="_asset/小结.png"><img src="_asset/音频小结.png"><img src="_asset/视频小结.png"><p>rtmp 实时消息传输: tcp/ip 应用层协议  推送/直播  基本数据单元为消息</p><p>1B 消息类型  2B 长度  3B 时间 4B  流id 消息体</p><p>传输时 消息回被拆分成消息块 chunk chunk header + chunk data</p><p>flv: 大块音视频 加入标记头信息   延迟表现和大规模并发成熟 </p><p>HLS：分成5-10s 用m3u8索引管理 用于朋友圈分享  </p><p>m3u8索引： 直播信号源–视频编码器（后台视频处理）–流切片器–各种ts媒体文件（分发模块）–索引文件（数据库）–客户端</p><p>cdn网络 为了解决用户访问资源慢出现的技术</p><p>边缘节点  二级节点（大城市） 源站</p><p>搭建流媒体服务：</p><p>准备流媒体服务器 linux max 编译安装nginx服务  配置rtmp服务并启动nginx服务</p><p>声音三要素：音调 音量 音色</p><p>音频量化(模数转换)：模拟数据 采样  量化 编码  数字信号  == 0101001110</p><p>码率 = 采样率（1.6w/44.1/48k）x 采样大小(8位-电话/16位-常见) x 声道数（单/双）</p><p>音频压缩： 有损消除冗余数据   哈夫曼无损编码</p><p>音频编码： 时域转频域—心里声学模型—量化编码—比特流格式化—比特流</p><p>音频编解码 ： opus（口 耳 实时互动 最快）  aac(直播用 次快)  speed(回音 降噪等)   g.711（固话）</p><p>aac : 取代mp3 加入 sir ps 技术  </p><p>aac lc 128k / aac he v2 64k /  aac he v2 32k/</p><p>aac 格式 ： adif 从头开始解码，用在磁盘文件中  adts 每一帧都有一个同步字，可以在任何位置解码</p><p>aac 编码库 ： libfdk_aac &gt; ffmpeg aac &gt;libfaac&gt; libvo_aacenc</p><p>H264： I帧 关键 帧内压缩  / p帧 向前参考1帧 / B帧 双向参考帧</p><p>sps: 序列参数集/pps:图像参数集 </p><p>GOF： 一组帧数  p帧丢失 会花屏卡顿</p><p>视频编码器： x264/x265 /open h264(svc)/vp8/vp9</p><p>h264 压缩技术-编码原理： 帧内预测压缩，空域冗余数据/帧间预测压缩，时域冗余数据/dcp整数离散余炫变换，傅立叶变换/cabac压缩</p><p>h264结构：视频序列–图像–片–宏块–子快</p><p>h264编码分层：nal 视频数据网络抽象层–vcl 视频数据编码层</p><p>码率：sodb 原始比特流 / rbsp sodb最后补1 / ebsp 起始码增加一个起始位0x03 /  nalu nal+ebsp</p><p>nal unit = nalu 头部 + 一个切片（头/数据） 切片 </p><p>yuv格式：4：4:4/4:4:2/4：2:0 （平坦编码 /半平坦编码）</p><img src="_asset/后续.png"><img src="_asset/音视频知识01.png"><img src="_asset/音视频知识02.png"><img src="_asset/音视频知识03.png"><img src="_asset/行业痛点-01.png"><img src="_asset/行业痛点-02.png">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-万人直播架构讲解&quot;&gt;&lt;a href=&quot;#1-万人直播架构讲解&quot; class=&quot;headerlink&quot; title=&quot;1. 万人直播架构讲解&quot;&gt;&lt;/a&gt;1. 万人直播架构讲解&lt;/h2&gt;&lt;p&gt;直播产品的种类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;泛娱乐化直播&lt;/p&gt;
&lt;p&gt;花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实时互动直播&lt;/p&gt;
&lt;p&gt;音视频会议、教育直播等，像 思科、全时、声网&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;泛娱乐化直播架构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;信令服务器：创建房间、聊天、礼物。。。。&lt;/p&gt;
&lt;p&gt;美女主播 –信令–&amp;gt; 信令服务器&lt;/p&gt;
&lt;p&gt;信令服务器–rtmp流地址–&amp;gt;美女主播&lt;/p&gt;
&lt;p&gt;美女主播 –推流–&amp;gt; 流媒体云CDN&lt;/p&gt;
&lt;p&gt;观众 –信令–&amp;gt; 信令服务器：将观众加入到美女主播间&lt;/p&gt;
&lt;p&gt;信令服务器–rmtp流地址–&amp;gt; 观众&lt;/p&gt;
&lt;p&gt;观众 &amp;lt;–拉流–&amp;gt; 流媒体云CDN&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://miaopei.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Vim 快捷键</title>
    <link href="http://miaopei.github.io/2018/03/20/vimHotKey/"/>
    <id>http://miaopei.github.io/2018/03/20/vimHotKey/</id>
    <published>2018-03-20T08:53:46.000Z</published>
    <updated>2019-06-03T08:10:56.878Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamlxaW5nd3UvYXJjaGl2ZS8yMDEyLzA2LzE0L3ZpbV9ub3Rlcy5odG1s" title="https://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html">Vim使用笔记<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="1-文档操作"><a href="#1-文档操作" class="headerlink" title="1. 文档操作"></a>1. 文档操作</h2><ul><li><code>:e</code> – 重新加载当前文档。</li><li><code>:e!</code> – 重新加载当前文档，并丢弃已做的改动。</li><li><code>:e file</code> – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。</li><li><code>:e! file</code> – 放弃对当前文件的修改，编辑新的文件。</li><li><code>:e# 或 ctrl+^</code> – 回到刚才编辑的文件，很实用。</li><li><code>gf</code> – 打开以光标所在字符串为文件名的文件。</li><li><code>:saveas newfilename</code> – 另存为</li></ul><a id="more"></a><h2 id="2-光标的移动"><a href="#2-光标的移动" class="headerlink" title="2. 光标的移动"></a>2. 光标的移动</h2><ul><li><code>gj</code> : 移动到一段内的下一行；</li><li><code>gk</code> : 移动到一段内的上一行；</li><li><code>w</code> : 前移一个单词，光标停在下一个单词开头；</li><li><code>b</code> : 后移一个单词，光标停在上一个单词开头；</li><li><code>(</code> : 前移1句。</li><li><code>)</code> : 后移1句。</li><li><code>{</code> : 前移1段。</li><li><code>}</code> : 后移1段。</li><li><code>fc</code> : 把光标移到同一行的下一个 c 字符处</li><li><code>Fc</code> : 把光标移到同一行的上一个 c 字符处</li><li><code>tc</code> : 把光标移到同一行的下一个 c 字符前</li><li><code>Tc</code> : 把光标移到同一行的上一个 c 字符后</li><li><code>;</code> : 配合 <code>f &amp; t</code> 使用，重复一次</li><li><code>,</code> : 配合 <code>f &amp; t</code> 使用，反向重复一次</li></ul><p>上面的操作都可以配合 n 使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动 3 个字符。</p><ul><li><code>0</code> : 移动到行首。</li><li><code>g0</code> : 移到光标所在屏幕行行首。</li><li><code>^</code> : 移动到本行第一个非空白字符。</li><li><code>g^</code>: 同 <code>^</code> ，但是移动到当前屏幕行第一个非空字符处。</li><li><code>$</code> : 移动到行尾。</li><li><code>g$</code> : 移动光标所在屏幕行行尾。</li><li><code>n|</code> : 把光标移到递 n 列上。</li><li><code>nG</code> : 到文件第 n 行。</li><li><code>:n&lt;cr&gt;</code> : 移动到第 n 行。</li><li><code>:$&lt;cr&gt;</code> : 移动到最后一行。</li><li><code>H</code> : 把光标移到屏幕最顶端一行。</li><li><code>M</code> : 把光标移到屏幕中间一行。</li><li><code>L</code> : 把光标移到屏幕最底端一行。</li><li><code>gg</code> : 到文件头部。</li><li><code>G</code> : 到文件尾部。</li></ul><h3 id="2-1-翻屏"><a href="#2-1-翻屏" class="headerlink" title="2.1 翻屏"></a>2.1 翻屏</h3><ul><li><code>ctrl+f</code> : 下翻一屏。</li><li><code>ctrl+b</code> : 上翻一屏。</li><li><code>ctrl+d</code> : 下翻半屏。</li><li><code>ctrl+u</code> : 上翻半屏。</li><li><code>ctrl+e</code> : 向下滚动一行。</li><li><code>ctrl+y</code> : 向上滚动一行。</li><li><code>n%</code> : 到文件 <code>n%</code> 的位置。</li><li><code>zz</code> : 将当前行移动到屏幕中央。</li><li><code>zt</code> : 将当前行移动到屏幕顶端。</li><li><code>zb</code> : 将当前行移动到屏幕底端。</li></ul><h3 id="2-2-标记"><a href="#2-2-标记" class="headerlink" title="2.2 标记"></a>2.2 标记</h3><p>使用标记可以快速移动。到达标记后，可以用 <code>Ctrl+o</code> 返回原来的位置。 <code>Ctrl+o</code> 和 <code>Ctrl+i</code> 很像浏览器上的 <em>后退</em> 和 <em>前进</em> 。</p><ul><li><code>m{a-z}</code> : 标记光标所在位置，局部标记，只用于当前文件。</li><li><code>m{A-Z}</code> : 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li><li>``{a-z}` : 移动到标记位置。</li><li><code>&#39;{a-z}</code> : 移动到标记行的行首。</li><li>``{0-9}` ：回到上[2-10]次关闭vim时最后离开的位置。</li><li>``: 移动到上次编辑的位置。’’ 也可以，不过``精确到列，而 ‘’ 精确到行 。如果想跳转到更老的位置，可以按 C-o，跳转到更新的位置用 C-i。</li><li>`” : 移动到上次离开的地方。</li><li>`. : 移动到最后改动的地方。</li><li><code>:marks</code> – 显示所有标记。</li><li><code>:delmarks a b</code> – 删除标记 a 和 b。</li><li><code>:delmarks a-c</code> – 删除标记 a、b 和 c。</li><li><code>:delmarks a c-f</code> – 删除标记 a、c、d、e、f。</li><li><code>:delmarks!</code> – 删除当前缓冲区的所有标记。</li><li><code>:help mark-motions</code>  – 查看更多关于 mark 的知识。</li></ul><h2 id="3-插入文本"><a href="#3-插入文本" class="headerlink" title="3. 插入文本"></a>3. 插入文本</h2><h3 id="3-1-基本插入"><a href="#3-1-基本插入" class="headerlink" title="3.1 基本插入"></a>3.1 基本插入</h3><ul><li><code>i</code> : 在光标前插入；一个小技巧：按 8，再按 <code>i</code>，进入插入模式，输入 <code>=</code>， 按 <code>esc</code> 进入命令模式，就会出现 8 个 <code>=</code> 。 这在插入分割线时非常有用，如<code>30i+&lt;esc&gt;</code> 就插入了 36 个 <code>+</code> 组成的分割线。</li><li><code>:r filename</code> : 在当前位置插入另一个文件的内容。</li><li><code>:r !date</code> :  在光标处插入当前日期与时间。同理，<code>:r !command</code> 可以将其它 shell 命令的输出插入当前文档。</li></ul><h3 id="3-2-改写插入"><a href="#3-2-改写插入" class="headerlink" title="3.2 改写插入"></a>3.2 改写插入</h3><ul><li><code>c[n]w</code> : 改写光标后 1(n) 个词。</li><li><code>c[n]l</code> : 改写光标后 n 个字母。</li><li><code>c[n]h</code> : 改写光标前 n 个字母。</li><li><code>[n]cc</code> : 修改当前 [n] 行。</li><li><code>[n]s</code> : 以输入的文本替代光标之后 1(n) 个字符，相当于 <code>c[n]l</code>。</li><li><code>[n]S</code> : 删除指定数目的行，并以所输入文本代替之。</li></ul><p>注意，类似 <code>cnw,dnw,ynw</code> 的形式同样可以写为 <code>ncw,ndw,nyw</code>。</p><h2 id="4-剪切复制和寄存器"><a href="#4-剪切复制和寄存器" class="headerlink" title="4. 剪切复制和寄存器"></a>4. 剪切复制和寄存器</h2><h3 id="4-1-剪切和复制、粘贴"><a href="#4-1-剪切和复制、粘贴" class="headerlink" title="4.1 剪切和复制、粘贴"></a>4.1 剪切和复制、粘贴</h3><ul><li><code>[n]x</code> : 剪切光标右边 n 个字符，相当于 <code>d[n]l</code>。</li><li><code>[n]X</code> : 剪切光标左边 n 个字符，相当于 <code>d[n]h</code>。</li><li><code>y</code> : 复制在可视模式下选中的文本。</li><li><code>yy or Y</code> : 复制整行文本。</li><li><code>y[n]w</code> : 复制一 (n) 个词。</li><li><code>y[n]l</code> : 复制光标右边 1(n) 个字符。</li><li><code>y[n]h</code> : 复制光标左边 1(n) 个字符。</li><li><code>y$</code> : 从光标当前位置复制到行尾。</li><li><code>y0</code> : 从光标当前位置复制到行首。</li><li><code>:m,ny&lt;cr&gt;</code> : 复制 m 行到 n 行的内容。</li><li><code>y1G 或 ygg</code> : 复制光标以上的所有行。</li><li><code>yG</code> : 复制光标以下的所有行。</li><li><code>yaw 和 yas</code>：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</li><li><code>d</code> : 删除（剪切）在可视模式下选中的文本。</li><li><code>d$ or D</code> : 删除（剪切）当前位置到行尾的内容。</li><li><code>d[n]w</code>: 删除（剪切）1(n)个单词</li><li><code>d[n]l</code>: 删除（剪切）光标右边 1(n) 个字符。</li><li><code>d[n]h</code>: 删除（剪切）光标左边 1(n) 个字符。</li><li><code>d0</code>: 删除（剪切）当前位置到行首的内容</li><li><code>[n] dd</code>: 删除（剪切）1(n) 行。</li><li><code>:m,nd&lt;cr&gt;</code> : 剪切 m 行到 n 行的内容。</li><li><code>d1G 或 dgg</code> : 剪切光标以上的所有行。</li><li><code>dG</code> : 剪切光标以下的所有行。</li><li><code>daw 和 das</code>：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li><li><code>d/f&lt;cr&gt;</code>：这是一个比较高级的组合命令，它将删除当前位置 到下一个 f 之间的内容。</li><li><code>p</code>: 在光标之后粘贴。</li><li><code>P</code> : 在光标之前粘贴。</li></ul><h3 id="4-2-文本对象"><a href="#4-2-文本对象" class="headerlink" title="4.2 文本对象"></a>4.2 文本对象</h3><ul><li><code>aw</code>：一个词</li><li><code>as</code>：一句。</li><li><code>ap</code>：一段。</li><li><code>ab</code>：一块（包含在圆括号中的）。</li></ul><p><code>y, d, c, v</code> 都可以跟文本对象。</p><h3 id="4-3-寄存器"><a href="#4-3-寄存器" class="headerlink" title="4.3 寄存器"></a>4.3 寄存器</h3><ul><li><code>a-z</code>：都可以用作寄存器名。<code>&quot;ayy</code> 把当前行的内容放入 a 寄存器。</li><li><code>A-Z</code>：用大写字母索引寄存器，可以在寄存器中追加内容。 如 <code>&quot;Ayy</code> 把当前行的内容追加到 a 寄存器中。</li><li><code>:reg</code> : 显示所有寄存器的内容。</li><li><code>&quot;&quot;</code>：不加寄存器索引时，默认使用的寄存器。</li><li><code>&quot;*</code>：当前选择缓冲区，<code>&quot;*yy</code> 把当前行的内容放入当前选择缓冲区。</li><li><code>&quot;+</code>：系统剪贴板。<code>&quot;+yy</code> 把当前行的内容放入系统剪贴板。</li></ul><h2 id="5-查找与替换"><a href="#5-查找与替换" class="headerlink" title="5. 查找与替换"></a>5. 查找与替换</h2><h3 id="5-1-查找"><a href="#5-1-查找" class="headerlink" title="5.1 查找"></a>5.1 查找</h3><ul><li><code>/something</code> : 在后面的文本中查找 something。</li><li><code>?something</code> : 在前面的文本中查找 something。</li><li><code>/pattern/+number</code> : 将光标停在包含 pattern 的行后面第 number 行上。</li><li><code>/pattern/-number</code> : 将光标停在包含 pattern 的行前面第 number 行上。</li><li><code>n</code> : 向后查找下一个。</li><li><code>N</code> : 向前查找下一个。</li></ul><p>可以用 grep 或 vimgrep 查找一个模式都在哪些地方出现过，其中 <code>:grep</code> 是调用外部的 grep 程序，而 <code>:vimgrep</code> 是 vim 自己的查找算法。</p><p>用法为： <code>:vim[grep]/pattern/[g] [j] files</code></p><ul><li><p><code>g</code> 的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p></li><li><p><code>j</code> 的含义是 grep 结束后，结果停在第 j 项，默认是停在第一项。</p></li></ul><p>vimgrep 前面可以加数字限定搜索结果的上限，如 <code>:1vim/pattern/ %</code> 只查找那个模式在本文件中的第一个出现。</p><p>其实 vimgrep 在读纯文本电子书时特别有用，可以生成导航的目录。</p><p>比如电子书中每一节的标题形式为：<code>n. xxxx</code>。你就可以这样：<code>:vim/^d{1,}./ %</code> 然后用 <code>:cw</code> 或 <code>:copen</code> 查看结果，可以用 <code>C-w H</code> 把 quickfix 窗口移到左侧，就更像个目录了。</p><h3 id="5-2-替换"><a href="#5-2-替换" class="headerlink" title="5.2 替换"></a>5.2 替换</h3><ul><li><code>:s/old/new</code> – 用 new 替换当前行第一个 old。</li><li><code>:s/old/new/g</code> – 用 new 替换当前行所有的 old。</li><li><code>:n1,n2s/old/new/g</code> – 用 new 替换文件 n1 行到 n2 行所有的 old。</li><li><code>:%s/old/new/g</code> – 用 new 替换文件中所有的 old。</li><li><code>:%s/^/xxx/g</code> – 在每一行的行首插入 xxx，<code>^</code> 表示行首。</li><li><code>:%s/$/xxx/g</code> – 在每一行的行尾插入 xxx，<code>$</code> 表示行尾。</li><li>所有替换命令末尾加上 c，每个替换都将需要用户确认。 如：<code>%s/old/new/gc</code>，加上i则忽略大小写(ignore)。</li></ul><p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p><p>语法为 <code>:[range]g/pattern/command</code></p><p>例如 <code>: %g/^ xyz/normal dd</code>。</p><p>表示对于以一个空格和 xyz 开头的行执行 normal 模式下的 dd 命令。</p><p>关于 range 的规定为：</p><ul><li>如果不指定 range，则表示当前行。</li><li><code>m,n</code> : 从 m 行到 n 行。</li><li><code>0</code> : 最开始一行（可能是这样）。</li><li><code>$</code> : 最后一行</li><li><code>.</code> : 当前行</li><li><code>%</code> : 所有行</li></ul><h3 id="5-3-正则表达式"><a href="#5-3-正则表达式" class="headerlink" title="5.3 正则表达式"></a>5.3 正则表达式</h3><p>高级的查找替换就要用到正则表达式。</p><ul><li><code>\d</code> : 表示十进制数（我猜的）</li><li><code>\s</code> : 表示空格</li><li><code>\S</code> : 非空字符</li><li><code>\a</code> : 英文字母</li><li><code>\|</code> : 表示 或</li><li><code>\.</code> : 表示.</li><li><code>{m,n}</code> : 表示 m 到 n 个字符。这要和 <code>\s</code> 与 <code>\a</code> 等连用，如 <code>\a\{m,n}</code> 表示 m 到 n 个英文字母。</li><li><code>{m,}</code>: 表示 m 到无限多个字符。</li><li><code>**</code>: 当前目录下的所有子目录。</li></ul><p><code>:help pattern</code> 得到更多帮助。</p><h2 id="6-编辑多个文件"><a href="#6-编辑多个文件" class="headerlink" title="6. 编辑多个文件"></a>6. 编辑多个文件</h2><h3 id="6-1-一次编辑多个文件"><a href="#6-1-一次编辑多个文件" class="headerlink" title="6.1 一次编辑多个文件"></a>6.1 一次编辑多个文件</h3><p>我们可以一次打开多个文件，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi a.txt b.txt c.txt</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>:next(:n)</code> 编辑下一个文件。</li><li><code>:2n</code> 编辑下 2 个文件。</li><li>使用 <code>:previous或:N</code> 编辑上一个文件。</li><li>使用 <code>:wnext</code>，保存当前文件，并编辑下一个文件。</li><li>使用 <code>:wprevious</code>，保存当前文件，并编辑上一个文件。</li><li>使用 <code>:args</code> 显示文件列表。</li><li><code>:n filenames 或 :args filenames</code> 指定新的文件列表。</li><li><code>vi -o filenames</code> 在水平分割的多个窗口中编辑多个文件。</li><li><code>vi -O filenames</code> 在垂直分割的多个窗口中编辑多个文件。</li></ul><h3 id="6-2-多标签编辑"><a href="#6-2-多标签编辑" class="headerlink" title="6.2 多标签编辑"></a>6.2 多标签编辑</h3><ul><li><code>vim -p files</code> : 打开多个文件，每个文件占用一个标签页。</li><li><code>:tabe, tabnew</code> – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li><li><code>^w gf</code> – 在新的标签页里打开光标下路径指定的文件。</li><li><code>:tabn</code> – 切换到下一个标签。<code>Control + PageDown</code>，也可以。</li><li><code>:tabp</code> – 切换到上一个标签。<code>Control + PageUp</code>，也可以。</li><li><code>[n] gt</code> – 切换到下一个标签。如果前面加了 n ， 就切换到第 n 个标签。第一个标签的序号就是 1。</li><li><code>:tab split</code> – 将当前缓冲区的内容在新页签中打开。</li><li><code>:tabc[lose]</code> – 关闭当前的标签页。</li><li><code>:tabo[nly]</code> – 关闭其它的标签页。</li><li><code>:tabs</code> – 列出所有的标签页和它们包含的窗口。</li><li><code>:tabm[ove] [N]</code> – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li></ul><h3 id="6-3-缓冲区"><a href="#6-3-缓冲区" class="headerlink" title="6.3 缓冲区"></a>6.3 缓冲区</h3><ul><li><code>:buffers 或 :ls 或 :files</code> 显示缓冲区列表。</li><li><code>ctrl+^</code>：在最近两个缓冲区间切换。</li><li><code>:bn</code> – 下一个缓冲区。</li><li><code>:bp</code> – 上一个缓冲区。</li><li><code>:bl</code> – 最后一个缓冲区。</li><li><code>:b[n] 或 :[n]b</code> – 切换到第 n 个缓冲区。</li><li><code>:nbw(ipeout)</code> – 彻底删除第 n 个缓冲区。</li><li><code>:nbd(elete)</code> – 删除第 n 个缓冲区，并未真正删除，还在 unlisted 列表中。</li><li><code>:ba[ll]</code> – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li></ul><h2 id="7-分屏编辑"><a href="#7-分屏编辑" class="headerlink" title="7. 分屏编辑"></a>7. 分屏编辑</h2><ul><li><code>vim -o file1 file2</code> : 水平分割窗口，同时打开 file1 和 file2</li><li><code>vim -O file1 file2</code> : 垂直分割窗口，同时打开 file1 和 file2</li></ul><h3 id="7-1-水平分割"><a href="#7-1-水平分割" class="headerlink" title="7.1 水平分割"></a>7.1 水平分割</h3><ul><li><code>:split(:sp)</code> – 把当前窗水平分割成两个窗口。(<code>CTRL-W s</code> 或 <code>CTRL-W CTRL-S</code>) 注意如果在终端下，<code>CTRL-S</code> 可能会冻结终端，请按 <code>CTRL-Q</code> 继续。</li><li><code>:split filename</code> – 水平分割窗口，并在新窗口中显示另一个文件。</li><li><code>:nsplit(:nsp)</code> – 水平分割出一个 n 行高的窗口。</li><li><code>:[N]new</code> – 水平分割出一个N行高的窗口，并编辑一个新文件。 ( <code>CTRL-W n</code> 或  <code>CTRL-W CTRL-N</code>)</li><li><code>ctrl+w f</code> –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li><li><code>C-w C-^</code> – 水平分割一个窗口，打开刚才编辑的文件。</li></ul><h3 id="7-2-垂直分割"><a href="#7-2-垂直分割" class="headerlink" title="7.2 垂直分割"></a>7.2 垂直分割</h3><ul><li><code>:vsplit(:vsp)</code> – 把当前窗口分割成水平分布的两个窗口。 (<code>CTRL-W v</code> 或 <code>CTRL CTRL-V</code>)</li><li><code>:[N]vne[w]</code> – 垂直分割出一个新窗口。</li><li><code>:vertical 水平分割的命令</code>： 相应的垂直分割。</li></ul><h3 id="7-3-关闭子窗口"><a href="#7-3-关闭子窗口" class="headerlink" title="7.3 关闭子窗口"></a>7.3 关闭子窗口</h3><ul><li><code>:qall</code> – 关闭所有窗口，退出 vim。</li><li><code>:wall</code> – 保存所有修改过的窗口。</li><li><code>:only</code> – 只保留当前窗口，关闭其它窗口。(<code>CTRL-W o</code>)</li><li><code>:close</code> – 关闭当前窗口，<code>CTRL-W c</code>能实现同样的功能。 (象 <code>:q :x</code> 同样工作 )</li></ul><h3 id="7-4-调整窗口大小"><a href="#7-4-调整窗口大小" class="headerlink" title="7.4 调整窗口大小"></a>7.4 调整窗口大小</h3><ul><li><code>ctrl+w +</code> –当前窗口增高一行。也可以用 n 增高 n 行。</li><li><code>ctrl+w -</code> –当前窗口减小一行。也可以用 n 减小 n 行。</li><li><code>ctrl+w _</code> –当前窗口扩展到尽可能的大。也可以用 n 设定行数。</li><li><code>:resize n</code> – 当前窗口 n 行高。</li><li><code>ctrl+w =</code> – 所有窗口同样高度。</li><li><code>n ctrl+w _</code> – 当前窗口的高度设定为 n 行。</li><li><code>ctrl+w &lt;</code> –当前窗口减少一列。也可以用 n 减少 n 列。</li><li><code>ctrl+w &gt;</code> –当前窗口增宽一列。也可以用 n 增宽 n 列。</li><li><code>ctrl+w |</code> –当前窗口尽可能的宽。也可以用 n 设定列数。</li></ul><h3 id="7-5-切换和移动窗口"><a href="#7-5-切换和移动窗口" class="headerlink" title="7.5 切换和移动窗口"></a>7.5 切换和移动窗口</h3><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p><ul><li><code>ctrl+w ctrl+w</code> : 切换到下一个窗口。或者是 <code>ctrl+w w</code>。</li><li><code>ctrl+w p</code> : 切换到前一个窗口。</li><li><code>ctrl+w h(l,j,k)</code> :切换到左（右，下，上）的窗口。</li><li><code>ctrl+w t(b)</code> :切换到最上（下）面的窗口。</li><li><code>ctrl+w H(L,K,J)</code> : 将当前窗口移动到最左（右、上、下）面。</li><li><code>ctrl+w r</code>：旋转窗口的位置。</li><li><code>ctrl+w T</code> : 将当前的窗口移动到新的标签页上。</li></ul><h2 id="8-快速编辑"><a href="#8-快速编辑" class="headerlink" title="8. 快速编辑"></a>8. 快速编辑</h2><h3 id="8-1-改变大小写"><a href="#8-1-改变大小写" class="headerlink" title="8.1 改变大小写"></a>8.1 改变大小写</h3><ul><li><code>~</code> : 反转光标所在字符的大小写。</li><li>可视模式下的 U 或 u：把选中的文本变为大写或小写。</li><li><code>gu(U)</code> 接范围（如<code>$</code>，或 <code>G</code>），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如<code>ggguG</code>，就是把开头到最后一行之间的字母全部变为小 写。再如 <code>gu5j</code>，把当前行和下面四行全部变成小写。</li></ul><h3 id="8-2-替换（normal模式）"><a href="#8-2-替换（normal模式）" class="headerlink" title="8.2 替换（normal模式）"></a>8.2 替换（normal模式）</h3><ul><li><code>r</code> : 替换光标处的字符，同样支持汉字。</li><li><code>R</code> : 进入替换模式，按 <code>esc</code> 回到正常模式。</li></ul><h3 id="8-3-撤消与重做（normal模式）"><a href="#8-3-撤消与重做（normal模式）" class="headerlink" title="8.3 撤消与重做（normal模式）"></a>8.3 撤消与重做（normal模式）</h3><ul><li><code>[n] u</code> : 取消一(n)个改动。</li><li><code>:undo 5</code> – 撤销 5 个改变。</li><li><code>:undolist</code> – 你的撤销历史。</li><li><code>ctrl + r</code> : 重做最后的改动。</li><li><code>U</code> : 取消当前行中所有的改动。</li><li><code>:earlier 4m</code> – 回到 4 分钟前</li><li><code>:later 55s</code> – 前进 55 秒</li></ul><h3 id="8-4-宏"><a href="#8-4-宏" class="headerlink" title="8.4 宏"></a>8.4 宏</h3><ul><li><code>.</code> –重复上一个编辑动作</li><li><code>qa</code>：开始录制宏 a（键盘操作记录）</li><li><code>q</code>：停止录制</li><li><code>@a</code>：播放宏 a</li></ul><h2 id="9-编辑特殊文件"><a href="#9-编辑特殊文件" class="headerlink" title="9. 编辑特殊文件"></a>9. 编辑特殊文件</h2><h3 id="9-1-文件加解密"><a href="#9-1-文件加解密" class="headerlink" title="9.1 文件加解密"></a>9.1 文件加解密</h3><ul><li><code>vim -x file</code> : 开始编辑一个加密的文件。</li><li><code>:X</code> – 为当前文件设置密码。</li><li><code>:set key=</code> – 去除文件的密码。</li></ul><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hZG1pbi92aW0tcXVpY2stZWRpdC5odG1s" title="http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html">这里是<i class="fa fa-external-link"></i></span> 滇狐总结的比较高级的 vi 技巧。</p><h3 id="9-2-文件的编码"><a href="#9-2-文件的编码" class="headerlink" title="9.2 文件的编码"></a>9.2 文件的编码</h3><ul><li><code>:e ++enc=utf8 filename</code>, 让 vim 用 utf-8 的编码打开这个文件。</li><li><code>:w ++enc=gbk</code>，不管当前文件什么编码，把它转存成 gbk 编码。</li><li><code>:set fenc 或 :set fileencoding</code>，查看当前文件的编码。</li><li>在 vimrc 中添加 <code>set fileencoding=ucs-bom,utf-8,cp936</code>，vim 会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936 对应于 gbk 编码。 ucs-bom 对应于 windows 下的文件格式。</li></ul><p>让 vim 正确处理文件格式和文件编码，有赖于 <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qaXFpbmd3dS9hZG1pbi92aW1yYy5odG1s" title="http://www.cnblogs.com/jiqingwu/admin/vimrc.html">~/.vimrc的正确配置<i class="fa fa-external-link"></i></span></p><h3 id="9-3-文件格式"><a href="#9-3-文件格式" class="headerlink" title="9.3 文件格式"></a>9.3 文件格式</h3><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p><ul><li><code>:e ++ff=dos filename</code>, 让 vim 用 dos 格式打开这个文件。</li><li><code>:w ++ff=mac filename</code>, 以 mac 格式存储这个文件。</li><li><code>:set ff</code>，显示当前文件的格式。</li><li>在 vimrc 中添加 <code>set fileformats=unix,dos,mac</code>，让 vim 自动识别文件格式。</li></ul><h2 id="10-编程辅助"><a href="#10-编程辅助" class="headerlink" title="10. 编程辅助"></a>10. 编程辅助</h2><h3 id="10-1-一些按键"><a href="#10-1-一些按键" class="headerlink" title="10.1 一些按键"></a>10.1 一些按键</h3><ul><li><code>gd</code> : 跳转到局部变量的定义处；</li><li><code>gD</code> : 跳转到全局变量的定义处，从当前文件开头开始搜索；</li><li><code>g;</code> : 上一个修改过的地方；</li><li><code>g,</code> : 下一个修改过的地方；</li><li><code>[[</code> : 跳转到上一个函数块开始，需要有单独一行的 {。</li><li><code>]]</code> : 跳转到下一个函数块开始，需要有单独一行的 {。</li><li><code>[]</code> : 跳转到上一个函数块结束，需要有单独一行的 }。</li><li><code>][</code> : 跳转到下一个函数块结束，需要有单独一行的 }。</li><li><code>[{</code> : 跳转到当前块开始处；</li><li><code>]}</code> : 跳转到当前块结束处；</li><li><code>[/</code> : 跳转到当前注释块开始处；</li><li><code>]/</code> : 跳转到当前注释块结束处；</li><li><code>%</code> : 不仅能移动到匹配的 <code>(),{} 或 []</code>上，而且能在 <code>#if，#else， #endif</code> 之间跳跃。</li></ul><p>下面的括号匹配对编程很实用的。</p><ul><li><code>ci&#39;, di&#39;, yi&#39;</code>：修改、剪切或复制 <code>&#39;</code> 之间的内容。</li><li><code>ca&#39;, da&#39;, ya&#39;</code>：修改、剪切或复制 <code>&#39;</code> 之间的内容，包含 <code>&#39;</code>。</li><li><code>ci&quot;, di&quot;, yi&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容。</li><li><code>ca&quot;, da&quot;, ya&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容，包含 <code>&quot;</code>。</li><li><code>ci(, di(, yi(</code>：修改、剪切或复制 <code>()</code>之间的内容。</li><li><code>ca(, da(, ya(</code>：修改、剪切或复制 <code>()</code> 之间的内容，包含 <code>()</code>。</li><li><code>ci[, di[, yi[</code>：修改、剪切或复制 <code>[]</code> 之间的内容。</li><li><code>ca[, da[, ya[</code>：修改、剪切或复制 <code>[]</code>之间的内容，包含 <code>[]</code>。</li><li><code>ci{, di{, yi{</code>：修改、剪切或复制 <code>{}</code> 之间的内容。</li><li><code>ca{, da{, ya{</code>：修改、剪切或复制 <code>{}</code> 之间的内容，包含 <code>{}</code>。</li><li><code>ci&lt;, di&lt;, yi&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容。</li><li><code>ca&lt;, da&lt;, ya&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容，包含<code>&lt;&gt;</code>。</li></ul><h3 id="10-2-ctags"><a href="#10-2-ctags" class="headerlink" title="10.2 ctags"></a>10.2 ctags</h3><table><thead><tr><th align="left"><code>Ctrl + ]</code></th><th>找到光标所在位置的标签定义的地方</th></tr></thead><tbody><tr><td align="left"><code>Ctrl + t</code></td><td>回到跳转之前的标签处</td></tr><tr><td align="left"><code>Ctrl + o</code></td><td>退回原来的地方</td></tr><tr><td align="left"><code>[I</code></td><td>查找全局标识符. Vim会列出它所找出的匹配行，<br>不仅在当前文件内查找，还会在所有的包含文件中查找</td></tr><tr><td align="left"><code>[i</code></td><td>从当前文件起始位置开始查找第一处包含光标所指关键字的位置</td></tr><tr><td align="left"><code>]i</code></td><td>类似上面的 <code>[i</code>，但这里是从光标当前位置开始往下搜索</td></tr><tr><td align="left"><code>[{</code></td><td>转到上一个位于第一列的”{“。（前提是 “{” 和 “}” 都在第一列。）</td></tr><tr><td align="left"><code>]}</code></td><td>转到下一个位于第一列的”}”</td></tr><tr><td align="left"><code>Ctrl+＼+ s</code></td><td>会出现所有调用、定义该函数的地方，输入索引号，回车即可</td></tr></tbody></table><ul><li><code>ctags -R</code> : 生成 tag 文件，<code>-R</code> 表示也为子目录中的文件生成 tags</li><li><code>:set tags=path/tags</code> – 告诉 ctags 使用哪个 tag 文件</li><li><code>:tag xyz</code> – 跳到 xyz 的定义处，或者将光标放在 xyz 上按 <code>C-]</code>，返回用 <code>C-t</code></li><li><code>:stag xyz</code> – 用分割的窗口显示 xyz 的定义，或者 <code>C-w ]</code>， 如果用 <code>C-w n ]</code>，就会打开一个 n 行高的窗口</li><li><code>:ptag xyz</code> – 在预览窗口中打开 xyz 的定义，热键是 <code>C-w }</code>。</li><li><code>:pclose</code> – 关闭预览窗口。热键是 <code>C-w z</code>。</li><li><code>:pedit abc.h</code> – 在预览窗口中编辑 abc.h</li><li><code>:psearch abc</code> – 搜索当前文件和当前文件 include 的文件，显示包含 abc 的行。</li></ul><p>有时一个 tag 可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p><ul><li><code>:[n]tnext</code> – 下一 <code>[n]</code> 个匹配。</li><li><code>:[n]tprev</code> – 上一 <code>[n]</code>个匹配。</li><li><code>:tfirst</code> – 第一个匹配</li><li><code>:tlast</code> – 最后一个匹配</li><li><code>:tselect tagname</code> – 打开选择列表</li></ul><p>tab 键补齐</p><ul><li><code>:tag xyz&lt;tab&gt;</code> – 补齐以 xyz 开头的 tag 名，继续按 tab 键，会显示其他的。</li><li><code>:tag /xyz&lt;tab&gt;</code> – 会用名字中含有 xyz 的 tag 名补全。</li></ul><p><strong>ctags 对 c++ 生成 tags</strong> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q</span><br></pre></td></tr></table></figure><p>每个参数解释如下：</p><ul><li><p><code>-R</code> : ctags 循环生成子目录的 tags</p></li><li><p><code>--c++-kinds=+px</code> : ctags 记录 c++ 文件中的函数声明和各种外部和前向声明</p></li><li><p><code>--fields=+iaS</code> : ctags 要求描述的信息</p><ul><li>其中 <code>i</code> 表示如果有继承，则标识出父类；</li><li><code>a</code> 表示如果元素是类成员的话，要标明其调用权限（即是 public 还是 private）；</li><li><code>S</code> 表示如果是函数，则标识函数的 signature。</li></ul></li><li><p><code>--extra=+q</code> : 强制要求 ctags 做如下操作—如果某个语法元素是类的一个成员，ctags 默认会给其记录一行，可以要求 ctags 对同一个语法元斯屹记一行，这样可以保证在 VIM 中多个同名函数可以通过路径不同来区分。</p></li></ul><h3 id="10-3-cscope"><a href="#10-3-cscope" class="headerlink" title="10.3 cscope"></a>10.3 cscope</h3><p>查看阅读 c++ 代码</p><p>cscope 缺省只解析 C 文件 (<code>.c</code> 和 <code>.h</code>)、lex 文件( <code>.l</code> )和 yacc 文件( <code>.y</code> )，虽然它也可以支持 C++ 以及 Java，但它在扫描目录时会跳过 C++ 及  Java 后缀的文件。如果希望 <code>cscope</code> 解析 C++ 或 Java 文件，需要把这些文件的名字和路径保存在一个名为 cscope.files 的文件。当 cscope 发现在当前目录中存在 cscope.files 时，就会为 cscope.files 中列出的所有文件生成索引数据库。</p><p>下面的命令会查找当前目录及子目录中所有后缀名为 <code>&quot;.h&quot;, &quot;.c&quot;, &quot;cc&quot;</code> 和 <code>&quot;.cpp&quot;</code> 的文件，并把查找结果重定向到文件 cscope.files 中。然后 cscope 根据 cscope.files 中的所有文件，生成符号索引文件。最后一条命令使用 ctags 命令，生成一个 tags 文件，在 vim 中执行 <code>&quot;:help tags&quot;</code> 命令查询它的用法。它可以和 cscope 一起使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"*.h"</span> -o -name <span class="string">"*.c"</span> -o -name <span class="string">"*.cc"</span> -o <span class="string">"*.cpp"</span> &gt; cscope.files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cscope -bkq -i cscope.files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ctags -R</span></span><br></pre></td></tr></table></figure><p>​    </p><ul><li><code>cscope -Rbq</code> : 生成 cscope.out 文件</li><li><code>:cs add /path/to/cscope.out /your/work/dir</code></li><li><code>:cs find c func</code> – 查找 func 在哪些地方被调用<ul><li>s: 查找 C 语言符号，即查找函数名、宏、枚举值等出现的地方</li><li>g: 查找函数、宏、枚举等定义的位置，类似 ctags 所提供的功能</li><li>d: 查找本函数调用的函数</li><li>c: 查找调用本函数的函数</li><li>t: 查找指定的字符串</li><li>e: 查找 egrep 模式，相当于 egrep 功能，但查找速度快多了</li><li>f: 查找并打开文件，类似 vim 的 find 功能</li><li>i: 查找包含本文件的文件</li></ul></li><li><code>:cw</code> – 打开 quickfix 窗口查看结果</li></ul><h3 id="10-4-gtags"><a href="#10-4-gtags" class="headerlink" title="10.4 gtags"></a>10.4 gtags</h3><p>Gtags 综合了 ctags 和 cscope 的功能。 使用 Gtags 之前，你需要安装 GNU Gtags。 然后在工程目录运行 gtags 。</p><ul><li><code>:Gtags funcname</code> 定位到 funcname 的定义处。</li><li><code>:Gtags -r funcname</code> 查询 funcname被引用的地方。</li><li><code>:Gtags -s symbol</code> 定位 symbol 出现的地方。</li><li><code>:Gtags -g string</code> Goto string 出现的地方。 <code>:Gtags -gi string</code> 忽略大小写。</li><li><code>:Gtags -f filename</code> 显示 filename 中的函数列表。 你可以用 <code>:Gtags -f %</code> 显示当前文件。</li><li><code>:Gtags -P pattern</code> 显示路径中包含特定模式的文件。 如 <code>:Gtags -P .h$</code> 显示所有头文件， <code>:Gtags -P /vm/</code> 显示 vm 目录下的文件。</li></ul><h3 id="10-5-编译"><a href="#10-5-编译" class="headerlink" title="10.5 编译"></a>10.5 编译</h3><p>vim 提供了 <code>:make</code> 来编译程序，默认调用的是 make， 如果你当前目录下有 makefile，简单地 <code>:make</code> 即可。</p><p>如果你没有 make 程序，你可以通过配置 makeprg 选项来更改 make 调用的程序。 如果你只有一个 abc.java 文件，你可以这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set makeprg=javac\ abc.java</span><br></pre></td></tr></table></figure><p>然后 <code>:make</code> 即可。如果程序有错，可以通过 quickfix 窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让 vim 识别错误信息。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure><p><code>%f</code> 表示文件名，<code>%l</code> 表示行号， <code>%m</code> 表示错误信息，其它的还不能理解。 请参考 <code>:help errorformat</code>。</p><h3 id="10-6-快速修改窗口"><a href="#10-6-快速修改窗口" class="headerlink" title="10.6 快速修改窗口"></a>10.6 快速修改窗口</h3><p>其实是 quickfix 插件提供的功能， 对编译调试程序非常有用 </p><ul><li><code>:copen</code> – 打开快速修改窗口。</li><li><code>:cclose</code> – 关闭快速修改窗口。</li></ul><p>快速修改窗口在 make 程序时非常有用，当 make 之后：</p><ul><li><code>:cl</code> – 在快速修改窗口中列出错误。</li><li><code>:cn</code> – 定位到下一个错误。</li><li><code>:cp</code> – 定位到上一个错误。</li><li><code>:cr</code> – 定位到第一个错误。</li></ul><h3 id="10-7-自动补全"><a href="#10-7-自动补全" class="headerlink" title="10.7 自动补全"></a>10.7 自动补全</h3><ul><li><code>C-x C-s</code> – 拼写建议。</li><li><code>C-x C-v</code> – 补全 vim 选项和命令。</li><li><code>C-x C-l</code> – 整行补全。</li><li><code>C-x C-f</code> – 自动补全文件路径。弹出菜单后，按 <code>C-f</code> 循环选择，当然也可以按 <code>C-n 和 C-p</code>。</li><li><code>C-x C-p 和C-x C-n</code> – 用文档中出现过的单词补全当前的词。 直接按 <code>C-p 和 C-n</code>也可以。</li><li><code>C-x C-o</code> – 编程时可以补全关键字和函数名啊。</li><li><code>C-x C-i</code> – 根据头文件内关键字补全。</li><li><code>C-x C-d</code> – 补全宏定义。</li><li><code>C-x C-n</code> – 按缓冲区中出现过的关键字补全。 直接按 <code>C-n 或 C-p</code> 即可。</li></ul><p>当弹出补全菜单后：</p><ul><li><code>C-p</code> 向前切换成员；</li><li><code>C-n</code> 向后切换成员；</li><li><code>C-e</code> 退出下拉菜单，并退回到原来录入的文字；</li><li><code>C-y</code> 退出下拉菜单，并接受当前选项。</li></ul><h3 id="10-8-多行缩进缩出"><a href="#10-8-多行缩进缩出" class="headerlink" title="10.8 多行缩进缩出"></a>10.8 多行缩进缩出</h3><ul><li>正常模式下，按两下 <code>&gt;;</code> 光标所在行会缩进。</li><li>如果先按了 n，再按两下 <code>&gt;;</code>，光标以下的 n 行会缩进。</li><li>对应的，按两下 <code>&lt;;</code>，光标所在行会缩出。</li><li>如果在编辑代码文件，可以用 <code>=</code> 进行调整。</li><li>在可视模式下，选择要调整的代码块，按 <code>=</code>，代码会按书写规则缩排好。</li><li>或者 <code>n =</code>，调整 n 行代码的缩排。</li></ul><h3 id="10-9-折叠"><a href="#10-9-折叠" class="headerlink" title="10.9 折叠"></a>10.9 折叠</h3><ul><li><code>zf</code> – 创建折叠的命令，可以在一个可视区域上使用该命令；</li><li><code>zd</code> – 删除当前行的折叠；</li><li><code>zD</code> – 删除当前行的折叠；</li><li><code>zfap</code> – 折叠光标所在的段；</li><li><code>zo</code> – 打开折叠的文本；</li><li><code>zc</code> – 收起折叠；</li><li><code>za</code> – 打开/关闭当前折叠；</li><li><code>zr</code> – 打开嵌套的折行；</li><li><code>zm</code> – 收起嵌套的折行；</li><li><code>zR (zO)</code> – 打开所有折行；</li><li><code>zM (zC)</code> – 收起所有折行；</li><li><code>zj</code> – 跳到下一个折叠处；</li><li><code>zk</code> – 跳到上一个折叠处；</li><li><code>zi -- enable/disable fold</code>;</li></ul><h2 id="11-其它"><a href="#11-其它" class="headerlink" title="11. 其它"></a>11. 其它</h2><h3 id="11-1-工作目录"><a href="#11-1-工作目录" class="headerlink" title="11.1 工作目录"></a>11.1 工作目录</h3><ul><li><code>:pwd</code> 显示vim的工作目录。</li><li><code>:cd path</code> 改变 vim 的工作目录。</li><li><code>:set autochdir</code>  可以让 vim 根据编辑的文件自动切换工作目录。</li></ul><h3 id="11-2-一些快捷键（收集中）"><a href="#11-2-一些快捷键（收集中）" class="headerlink" title="11.2 一些快捷键（收集中）"></a>11.2 一些快捷键（收集中）</h3><ul><li><code>K</code> : 打开光标所在词的 manpage。</li><li><code>*</code> : 向下搜索光标所在词。</li><li><code>g*</code> : 同上，但部分符合即可。</li><li><code>\#</code> : 向上搜索光标所在词。</li><li><code>g#</code> : 同上，但部分符合即可。</li><li><code>g C-g</code> : 统计全文或统计部分的字数。</li></ul><h3 id="11-3-在线帮助"><a href="#11-3-在线帮助" class="headerlink" title="11.3 在线帮助"></a>11.3 在线帮助</h3><ul><li><code>:h(elp) 或 F1</code> 打开总的帮助。</li><li><code>:help user-manual</code> 打开用户手册。</li><li>命令帮助的格式为<code>：</code>第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li><li><code>:helptags somepath</code> 为 somepath 中的文档生成索引。</li><li><code>:helpgrep</code> 可以搜索整个帮助文档，匹配的列表显示在 quickfix 窗口中。</li><li><code>Ctrl+]</code> 跳转到 tag 主题，<code>Ctrl+t</code> 跳回。</li><li><code>:ver</code> 显示版本信息。</li></ul><p>高亮所有搜索模式匹配</p><ul><li><p><code>shift + *</code> 向后搜索光标所在位置的单词</p></li><li><p><code>shift + #</code> 向前搜索光标所在位置的单词</p></li><li><p>n 和 N 可以继续向后或者向前搜索匹配的字符串</p></li><li><p><code>:set hlsearch</code>  高亮所有匹配的字符串</p></li><li><p><code>:nohlsearch</code> 临时关闭</p></li><li><p><code>:set nohlsearch</code> 彻底关闭，只有重新 <code>:set hlsearch</code> 才可以高亮搜索</p></li><li><p>vim 高亮显示光标所在的单词，在单词的地方输入 <code>gd</code></p></li></ul><p>语法高亮</p><ul><li><p>syntax on</p></li><li><p>syntax off</p></li></ul><p>vim自动补全</p><ul><li><code>ctrl + n</code> 或者 <code>ctrl + p</code></li></ul><p>复制 vim 文件中所有内容</p><ul><li><p><code>gg</code> 回到文件首</p></li><li><p><code>shift + v</code> 进入 VISUAL LINE 模式</p></li><li><p><code>shift + g</code>  全选所有内容</p></li><li><p><code>ctrl + insert</code> 复制所选的内容</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamlxaW5nd3UvYXJjaGl2ZS8yMDEyLzA2LzE0L3ZpbV9ub3Rlcy5odG1s&quot; title=&quot;https://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html&quot;&gt;Vim使用笔记&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-文档操作&quot;&gt;&lt;a href=&quot;#1-文档操作&quot; class=&quot;headerlink&quot; title=&quot;1. 文档操作&quot;&gt;&lt;/a&gt;1. 文档操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:e&lt;/code&gt; – 重新加载当前文档。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e!&lt;/code&gt; – 重新加载当前文档，并丢弃已做的改动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e file&lt;/code&gt; – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e! file&lt;/code&gt; – 放弃对当前文件的修改，编辑新的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e# 或 ctrl+^&lt;/code&gt; – 回到刚才编辑的文件，很实用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gf&lt;/code&gt; – 打开以光标所在字符串为文件名的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:saveas newfilename&lt;/code&gt; – 另存为&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://miaopei.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket教程</title>
    <link href="http://miaopei.github.io/2017/05/16/WebSocket%E6%95%99%E7%A8%8B/"/>
    <id>http://miaopei.github.io/2017/05/16/WebSocket教程/</id>
    <published>2017-05-16T06:15:08.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<p>转自<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDUvd2Vic29ja2V0Lmh0bWw=" title="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰网络编程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3dlYnNvY2tldC5vcmcv" title="http://websocket.org/">WebSocket<i class="fa fa-external-link"></i></span> 是一种网络通信协议，很多高级功能都需要它。</p><h2 id="为什么需要-WebSocker"><a href="#为什么需要-WebSocker" class="headerlink" title="为什么需要 WebSocker"></a>为什么需要 WebSocker</h2><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><a id="more"></a><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p><img src="http://i.imgur.com/5mUfWtm.jpg" alt></p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<span class="exturl" data-url="aHR0cHM6Ly93d3cucHVibnViLmNvbS9ibG9nLzIwMTQtMTItMDEtaHR0cC1sb25nLXBvbGxpbmcv" title="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”<i class="fa fa-external-link"></i></span>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVzaF90ZWNobm9sb2d5" title="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术<i class="fa fa-external-link"></i></span>的一种。</p><p><img src="http://i.imgur.com/Qutxs2j.png" alt></p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是 <code>ws</code>（如果加密，则为 <code>wss</code> ），服务器网址就是 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/UWC2xr3.jpg" alt></p><h2 id="客户端的简单示例"><a href="#客户端的简单示例" class="headerlink" title="客户端的简单示例"></a>客户端的简单示例</h2><p>WebSocket 的用法相当简单。</p><p>下面是一个网页脚本的例子（点击<span class="exturl" data-url="aHR0cDovL2pzYmluLmNvbS9tdXFhbWlxaW11L2VkaXQ/anMsY29uc29sZQ==" title="http://jsbin.com/muqamiqimu/edit?js,console">这里<i class="fa fa-external-link"></i></span>看运行结果），基本上一眼就能明白。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>); </span><br><span class="line">  ws.send(<span class="string">"Hello WebSockets!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"Received Message: "</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="客户端的-API"><a href="#客户端的-API" class="headerlink" title="客户端的 API"></a>客户端的 API</h2><p>WebSocket 客户端的 API 如下。</p><h3 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。</p><p>实例对象的所有属性和方法清单，参见<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldA==" title="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">这里<i class="fa fa-external-link"></i></span>。</p><h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p><code>readyState</code> 属性返回实例对象的当前状态，共有四种。</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><p>下面是一个示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的 <code>onopen</code> 属性，用于指定连接成功后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要指定多个回调函数，可以使用addEventListener`方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h3><p>实例对象的 <code>onmessage</code> 属性，用于指定收到服务器数据后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，服务器数据可能是文本，也可能是二进制数据（ <code>blob</code> 对象或 <code>Arraybuffer</code> 对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received data string"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received arraybuffer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"blob"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send( )"></a>webSocket.send( )</h3><p>实例对象的 <code>send( )</code> 方法用于向服务器发送数据。</p><p>发送文本的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">'your message'</span>);</span><br></pre></td></tr></table></figure><p>发送 Blob 对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">'input[type="file"]'</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure><p>发送 ArrayBuffer 对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure><h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的 <code>bufferedAmount</code> 属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>WebSocket 服务器的实现，可以查看维基百科的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcGFyaXNvbl9vZl9XZWJTb2NrZXRfaW1wbGVtZW50YXRpb25z" title="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">列表<i class="fa fa-external-link"></i></span>。</p><p>常用的 Node 实现有以下三种。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VXZWJTb2NrZXRzL3VXZWJTb2NrZXRz" title="https://github.com/uWebSockets/uWebSockets">µWebSockets<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3NvY2tldC5pby8=" title="http://socket.io/">Socket.IO<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2Rl" title="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node<i class="fa fa-external-link"></i></span></li></ul><p>具体的用法请查看它们的文档，这里不详细介绍了。</p><h2 id="WebSocketd"><a href="#WebSocketd" class="headerlink" title="WebSocketd"></a>WebSocketd</h2><p>下面，我要推荐一款非常特别的 WebSocket 服务器：<span class="exturl" data-url="aHR0cDovL3dlYnNvY2tldGQuY29tLw==" title="http://websocketd.com/">Websocketd<i class="fa fa-external-link"></i></span>。</p><p>它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。</p><p><img src="http://i.imgur.com/a51CR69.png" alt></p><p>举例来说，下面是一个 Bash 脚本 <code>counter.sh</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 2</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 3</span><br></pre></td></tr></table></figure><p>命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bash ./counter.sh</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>现在，启动<code>websocketd</code>，指定这个脚本作为服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 bash ./counter.sh</span><br></pre></td></tr></table></figure><p>上面的命令会启动一个 WebSocket 服务器，端口是 <code>8080</code> 。每当客户端连接这个服务器，就会执行 <code>counter.sh</code> 脚本，并将它的输出推送给客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/'</span>);</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。</p><p>有了它，就可以很方便地将命令行的输出，发给浏览器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 ls</span><br></pre></td></tr></table></figure><p>上面的命令会执行<code>ls</code>命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWItdm1zdGF0cw==" title="https://github.com/joewalnes/web-vmstats">代码<i class="fa fa-external-link"></i></span>）。</p><p><img src="http://i.imgur.com/WMUStsh.jpg" alt></p><p>更多的用法可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL3RyZWUvbWFzdGVyL2V4YW1wbGVzL2Jhc2g=" title="https://github.com/joewalnes/websocketd/tree/master/examples/bash">官方示例<i class="fa fa-external-link"></i></span>。</p><ul><li>Bash 脚本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2Jhc2gvZ3JlZXRlci5zaA==" title="https://github.com/joewalnes/websocketd/blob/master/examples/bash/greeter.sh">读取客户端输入<i class="fa fa-external-link"></i></span>的例子</li><li>五行代码实现一个最简单的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2Jhc2gvY2hhdC5zaA==" title="https://github.com/joewalnes/websocketd/blob/master/examples/bash/chat.sh">聊天服务器<i class="fa fa-external-link"></i></span></li></ul><p><img src="http://i.imgur.com/KfZKSmD.png" alt></p><p>websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL25vZGVqcy9ncmVldGVyLmpz" title="https://github.com/joewalnes/websocketd/blob/master/examples/nodejs/greeter.js"><code>greeter.js</code><i class="fa fa-external-link"></i></span>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">'data: '</span> + chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动这个脚本的命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websocketd --port=8080 node ./greeter.js</span><br></pre></td></tr></table></figure><p>官方仓库还有其他<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy93ZWJzb2NrZXRkL3RyZWUvbWFzdGVyL2V4YW1wbGVz" title="https://github.com/joewalnes/websocketd/tree/master/examples">各种语言<i class="fa fa-external-link"></i></span>的例子。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><span class="exturl" data-url="aHR0cDovL2NqaWhyaWcuY29tL2Jsb2cvaG93LXRvLXVzZS13ZWJzb2NrZXRzLw==" title="http://cjihrig.com/blog/how-to-use-websockets/">How to Use WebSockets<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL3dlYnNvY2tldHMvd2Vic29ja2V0c19zZW5kX3JlY2VpdmVfbWVzc2FnZXMuaHRt" title="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">WebSockets - Send &amp; Receive Messages<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL3dlYnNvY2tldHMvYmFzaWNzLw==" title="https://www.html5rocks.com/en/tutorials/websockets/basics/">Introducing WebSockets: Bringing Sockets to the Web<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDUvd2Vic29ja2V0Lmh0bWw=&quot; title=&quot;http://www.ruanyifeng.com/blog/2017/05/websocket.html&quot;&gt;阮一峰网络编程&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3dlYnNvY2tldC5vcmcv&quot; title=&quot;http://websocket.org/&quot;&gt;WebSocket&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt; 是一种网络通信协议，很多高级功能都需要它。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要-WebSocker&quot;&gt;&lt;a href=&quot;#为什么需要-WebSocker&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 WebSocker&quot;&gt;&lt;/a&gt;为什么需要 WebSocker&lt;/h2&gt;&lt;p&gt;初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？&lt;/p&gt;
&lt;p&gt;答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://miaopei.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="WebSocket" scheme="http://miaopei.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>定制支持串口安装的ubuntu系统镜像</title>
    <link href="http://miaopei.github.io/2017/05/15/%E5%AE%9A%E5%88%B6%E6%94%AF%E6%8C%81%E4%B8%B2%E5%8F%A3%E5%AE%89%E8%A3%85%E7%9A%84ubuntu%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/"/>
    <id>http://miaopei.github.io/2017/05/15/定制支持串口安装的ubuntu系统镜像/</id>
    <published>2017-05-15T07:48:06.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、所需环境："><a href="#1、所需环境：" class="headerlink" title="1、所需环境："></a>1、所需环境：</h2><p><strong>硬件环境：</strong></p><ul><li>笔记本</li><li>串口调试线缆</li><li>光盘</li><li>显示器</li><li>FWA产品的任一机型（此次使用的是FWA-4210）</li><li>SATA或者USB光驱×1</li></ul><p><strong>软件环境：</strong></p><ul><li>带有genisoimage(旧版是mkisofs)的linux发行版（此次使用的是Ubuntu 16.04 server版）</li><li>Ubuntu官网通用镜像ISO文件</li></ul><a id="more"></a><h2 id="2、操作过程："><a href="#2、操作过程：" class="headerlink" title="2、操作过程："></a>2、操作过程：</h2><h3 id="2-1-开机进入系统，将光盘挂载到Ubuntu系统"><a href="#2-1-开机进入系统，将光盘挂载到Ubuntu系统" class="headerlink" title="2.1 开机进入系统，将光盘挂载到Ubuntu系统"></a>2.1 开机进入系统，将光盘挂载到Ubuntu系统</h3><p>CLI命令如下；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -o loop ubuntu-16.04.2-server-amd64.iso /mnt/temp</span><br></pre></td></tr></table></figure><h3 id="2-2-更改配置"><a href="#2-2-更改配置" class="headerlink" title="2.2 更改配置"></a>2.2 更改配置</h3><p>相关配置文件（menu.cfg、txt.cfg、isolinux.cfg此文件不是必须要修改，具体见下边解释）。将光盘文件，拷贝到临时目录（家目录或者自己新建目录均可，但建议拷贝到/var或/temp目录下），具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -rf /mnt/temp/ /var/mycdrom</span><br></pre></td></tr></table></figure><p>因为 <code>/mnt</code> 目录的默认权限是 <code>333</code> ，所以在此使用 <code>-r</code> 和 <code>-f</code> 参数，<code>-r</code> 代表递归，即文件夹下所有文件都拷贝，<code>-f</code> 代表强制执行；</p><p>更改 <code>menu.cfg</code> 文件，如下图，主要是注释掉标准安装的配置文件，以便可以定制安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/mycdrom/temp/isolinux</span><br><span class="line"></span><br><span class="line">$ vi menu.cfg</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><blockquote><p>vi有三种模式，普通模式、编辑模式、命令行模式；</p><p>I o a进入编辑模式，</p><p>普通模式下数字+yy复制</p><p>P黏贴</p><p>命令行模式：w写入，q离开，！强制执行</p></blockquote><p>注释 <code>menu.cfg</code> 内容如下红框所示：</p><p><img src="http://i.imgur.com/JM99sFZ.png" alt></p><p>更改 <code>txt.cfg</code> 文件，主要用于定制串口安装（如下图）：</p><p><img src="http://i.imgur.com/pA7ruhP.png" alt></p><p>更改 <code>isolinux.cfg</code> 文件，主要修改grub菜单等待时间（如下图），也可不修改；</p><p><img src="http://i.imgur.com/jE4zoMG.png" alt></p><h3 id="2-3-重新打包ISO文件"><a href="#2-3-重新打包ISO文件" class="headerlink" title="2.3 重新打包ISO文件"></a>2.3 重新打包ISO文件</h3><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ genisoimage -o ubuntu-16.04.2-server-adm64-console_115200.iso -r -J -no-emul-boot -boot-load-size 4 -boot-info-table -b isolinux/isolinux.bin -c isolinux/boot.cat /var/mycdrom/temp</span><br></pre></td></tr></table></figure><p><code>genisoimage</code> 是linux各大发行版制作ISO镜像比较流行的工具，若要定制系统，最好在linux下更改相关配置，并使用此工具重新打包；若在Windows平台使用UltraISO等工具解压更改重新打包会出现不稳定的情况（无法找到镜像，无法找到安装源等）。</p><ul><li><code>-o</code> ：是output缩写，用来指定输出镜像名称</li><li><code>-r</code> ： 即rational-rock，用来开放ISO文件所有权限（r、w、x） </li><li><code>-J</code> ： 即Joliet，一种ISO9600扩展格式，用来增加兼容性，最好加上</li><li><code>-no-emul-boot</code>  <code>-boot-load-size 4</code>  <code>-boot-info-table</code> ：指定兼容模式下虚拟扇区的数量，若不指定，有些BISO会出现一些问题</li><li><code>-b</code> ：指定开机映像文件</li><li><code>-c</code> ：具体开机配置文件</li><li>最后加上输出目录</li></ul><p>Reboot系统U盘启动，即可安装系统。</p><h2 id="3、文本安装系统注意事项"><a href="#3、文本安装系统注意事项" class="headerlink" title="3、文本安装系统注意事项"></a>3、文本安装系统注意事项</h2><h3 id="3-1-进入安装模式"><a href="#3-1-进入安装模式" class="headerlink" title="3.1 进入安装模式"></a>3.1 进入安装模式</h3><p>关闭系统插入U盘，启动系统，看到如下提示按F12进入安装系统模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Press  F12  for  boot  menu..</span><br></pre></td></tr></table></figure><p>选择U盘所在的选项。</p><h3 id="3-2-分区"><a href="#3-2-分区" class="headerlink" title="3.2 分区"></a>3.2 分区</h3><p>若是硬盘已有linux发行版系统，那在如下界面，必须umount分区，才能将更改写入分区表</p><h3 id="3-3-自动更新"><a href="#3-3-自动更新" class="headerlink" title="3.3 自动更新"></a>3.3 自动更新</h3><p>如下界面，若有特许需求（需要安装一些特许软件apache、weblogic等）可以选择自动更新（需要联网），一般情况不选则自动更新</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、所需环境：&quot;&gt;&lt;a href=&quot;#1、所需环境：&quot; class=&quot;headerlink&quot; title=&quot;1、所需环境：&quot;&gt;&lt;/a&gt;1、所需环境：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;硬件环境：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;笔记本&lt;/li&gt;
&lt;li&gt;串口调试线缆&lt;/li&gt;
&lt;li&gt;光盘&lt;/li&gt;
&lt;li&gt;显示器&lt;/li&gt;
&lt;li&gt;FWA产品的任一机型（此次使用的是FWA-4210）&lt;/li&gt;
&lt;li&gt;SATA或者USB光驱×1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;软件环境：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带有genisoimage(旧版是mkisofs)的linux发行版（此次使用的是Ubuntu 16.04 server版）&lt;/li&gt;
&lt;li&gt;Ubuntu官网通用镜像ISO文件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="http://miaopei.github.io/categories/Ubuntu/"/>
    
    
      <category term="ubuntu" scheme="http://miaopei.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本攻略笔记</title>
    <link href="http://miaopei.github.io/2017/05/15/Shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://miaopei.github.io/2017/05/15/Shell脚本攻略笔记/</id>
    <published>2017-05-15T07:40:41.000Z</published>
    <updated>2019-06-03T08:50:47.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><h3 id="1-1-shell-格式输出"><a href="#1-1-shell-格式输出" class="headerlink" title="1.1 shell 格式输出"></a>1.1 shell 格式输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'Hello world !'</span></span><br><span class="line">-n<span class="comment"># 忽略结尾的换行符</span></span><br><span class="line">-e<span class="comment"># 激活转义字符</span></span><br><span class="line">-E<span class="comment"># disable转义字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>打印彩色输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 彩色文本</span></span><br><span class="line"><span class="comment"># 重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;31m This is red text \e[0m"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 彩色背景</span></span><br><span class="line"><span class="comment"># 重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;42m Green Background \e[0m"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4s\n"</span> No Name Mark</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p><code>%-5s</code> 指明了一个格式为左对齐且宽度为5的字符串替换（ <code>-</code>表示左对齐）。如果不用 <code>-</code> 指定对齐方式，字符串就采用右对齐形式。</p><p><code>%s</code> 、 <code>%c</code> 、<code>%d</code> 和 <code>%f</code> 都是格式替换符（format substitution character），其所对应的参数可以置于带引号的格式字符串之后。 </p><h3 id="1-2-替换命令-tr"><a href="#1-2-替换命令-tr" class="headerlink" title="1.2 替换命令 tr"></a>1.2 替换命令 tr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tr 是 translate的简写</span></span><br><span class="line">$ tr <span class="string">'\0'</span> <span class="string">'\n'</span><span class="comment"># 将 \0 替换成 \n</span></span><br><span class="line">$ tr [选项]… 集合1 [集合2]</span><br><span class="line">选项说明：</span><br><span class="line">-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。</span><br><span class="line">-d, –delete 删除集合1中的字符而不是转换</span><br><span class="line">-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。</span><br><span class="line">-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符</span><br><span class="line"></span><br><span class="line">字符集合的范围：</span><br><span class="line">\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)</span><br><span class="line">\\ 反斜杠</span><br><span class="line">\a Ctrl-G 铃声</span><br><span class="line">\b Ctrl-H 退格符</span><br><span class="line">\f Ctrl-L 走行换页</span><br><span class="line">\n Ctrl-J 新行</span><br><span class="line">\r Ctrl-M 回车</span><br><span class="line">\t Ctrl-I tab键</span><br><span class="line">\v Ctrl-X 水平制表符</span><br><span class="line">CHAR1-CHAR2 从CHAR1 到 CHAR2的所有字符按照ASCII字符的顺序</span><br><span class="line">[CHAR*] <span class="keyword">in</span> SET2, copies of CHAR until length of SET1</span><br><span class="line">[CHAR*REPEAT] REPEAT copies of CHAR, REPEAT octal <span class="keyword">if</span> starting with 0</span><br><span class="line">[:alnum:] 所有的字母和数字</span><br><span class="line">[:alpha:] 所有字母</span><br><span class="line">[:blank:] 水平制表符，空白等</span><br><span class="line">[:cntrl:] 所有控制字符</span><br><span class="line">[:digit:] 所有的数字</span><br><span class="line">[:graph:] 所有可打印字符，不包括空格</span><br><span class="line">[:lower:] 所有的小写字符</span><br><span class="line">[:<span class="built_in">print</span>:] 所有可打印字符，包括空格</span><br><span class="line">[:punct:] 所有的标点字符</span><br><span class="line">[:space:] 所有的横向或纵向的空白</span><br><span class="line">[:upper:] 所有大写字母</span><br></pre></td></tr></table></figure><h3 id="1-3-打印变量"><a href="#1-3-打印变量" class="headerlink" title="1.3 打印变量"></a>1.3 打印变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ var=<span class="string">"value"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">或者</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-设置环境变量"><a href="#1-4-设置环境变量" class="headerlink" title="1.4 设置环境变量"></a>1.4 设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在PATH中添加一条新路径</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:/home/user/bin"</span></span><br><span class="line">也可以使用：</span><br><span class="line">$ PATH=<span class="string">"<span class="variable">$PATH</span>:/home/user/bin"</span></span><br><span class="line">$ <span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure><h3 id="1-5-Shell中三种引号的用法"><a href="#1-5-Shell中三种引号的用法" class="headerlink" title="1.5 Shell中三种引号的用法"></a>1.5 Shell中三种引号的用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="comment"># 使用单引号时，变量不会被扩展（expand），将依照原样显示。</span></span><br><span class="line">$ var=<span class="string">"123"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'$var'</span> will <span class="built_in">print</span> <span class="variable">$var</span></span><br><span class="line">结果为：<span class="string">'$var'</span> will <span class="built_in">print</span> 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="comment"># 输出引号中的内容，若存在命令、变量等，会先执行命令解析出结果再输出</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span> will <span class="built_in">print</span> <span class="variable">$var</span></span><br><span class="line">结果为：123 will <span class="built_in">print</span> 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反引号</span></span><br><span class="line"><span class="comment"># 命令替换</span></span><br><span class="line">$ var=`whoami`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">结果为：root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备注：反引号和$()作用相同</span></span><br></pre></td></tr></table></figure><h3 id="1-6-获得字符串的长度"><a href="#1-6-获得字符串的长度" class="headerlink" title="1.6 获得字符串的长度"></a>1.6 获得字符串的长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法</span></span><br><span class="line">$ length=<span class="variable">$&#123;#var&#125;</span></span><br><span class="line"></span><br><span class="line">$ var=12345678901234567890</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="1-7-识别当前shell"><a href="#1-7-识别当前shell" class="headerlink" title="1.7 识别当前shell"></a>1.7 识别当前shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">也可以使用：</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br></pre></td></tr></table></figure><h3 id="1-8-使用shell进行数学运算"><a href="#1-8-使用shell进行数学运算" class="headerlink" title="1.8 使用shell进行数学运算"></a>1.8 使用shell进行数学运算</h3><p>在Bash shell环境中，可以利用 <code>let</code>、<code>(( ))</code> 和<code>[]</code> 执行基本的算术操作。而在进行高级操作时，<code>expr</code> 和 <code>bc</code> 这两个工具也会非常有用。</p><p>使用 <code>let</code> 时，变量名之前不需要再添加 <code>$</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ no1=4</span><br><span class="line">$ <span class="built_in">let</span> no1++</span><br><span class="line">$ <span class="built_in">let</span> no1+=6<span class="comment"># 等同于let no=no+6</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 操作符[]的使用方法和let命令类似</span></span><br><span class="line">$ result=$[ no1 + no2 ]</span><br><span class="line"><span class="comment"># 在[]中也可以使用$前缀</span></span><br><span class="line">$ result=$[ <span class="variable">$no1</span> + 5 ]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用(())时，变量名之前需要加上$</span></span><br><span class="line">$ result=$(( no1 + 50 ))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># expr同样可以用于基本算术操作</span></span><br><span class="line">$ result=`expr 3 + 4`</span><br><span class="line">$ result=$(expr <span class="variable">$no1</span> + 5)</span><br></pre></td></tr></table></figure><p>bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项 。此处不多介绍。</p><h3 id="1-9-shell中各种括号的作用-、-、-、-、"><a href="#1-9-shell中各种括号的作用-、-、-、-、" class="headerlink" title="1.9 shell中各种括号的作用()、(())、[]、[[]]、{}"></a>1.9 shell中各种括号的作用()、(())、[]、[[]]、{}</h3><h4 id="1-9-1-小括号，圆括号（）"><a href="#1-9-1-小括号，圆括号（）" class="headerlink" title="1.9.1 小括号，圆括号（）"></a>1.9.1 小括号，圆括号（）</h4><p>1、单小括号 ( )</p><ul><li><strong>命令组。</strong>括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。</li><li><strong>命令替换。</strong>等同于<code>cmd</code>，shell扫描一遍命令行，发现了<code>$(cmd)结构</code> ，便将 <code>$(cmd)</code> 中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</li><li><strong>用于初始化数组。</strong>如：array=(a b c d)。</li></ul><p>2、双小括号 (( ))</p><ul><li><strong>整数扩展。</strong>这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。</li><li><strong>只要括号中的运算符、表达式符合C语言运算规则，都可用在 <code>$((exp))</code>中，甚至是三目运算符</strong>。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)。</li><li><strong>单纯用 (( )) 也可重定义变量值</strong>，比如 a=5; ((a++)) 可将 $a 重定义为6。</li><li><strong>常用于算术运算比较，双括号中的变量可以不使用<code>$</code> 符号前缀</strong>。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i&lt;5;i++)), 如果不使用双括号, 则为for i in <code>seq 0 4</code>或者for i in {0..4}。再如可以直接使用 <code>if (($i&lt;5))</code> , 如果不使用双括号, 则为 <code>if [ $i -lt 5 ]</code> 。</li></ul><h4 id="1-9-2-中括号，方括号"><a href="#1-9-2-中括号，方括号" class="headerlink" title="1.9.2 中括号，方括号[]"></a>1.9.2 中括号，方括号[]</h4><p>1、单中括号 []</p><ul><li>bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</li><li>Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</li><li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</li><li>在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</li></ul><p>2、双中括号 [[ ]]</p><ul><li>[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</li><li>支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</li><li>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用 <code>if [[ $a != 1 &amp;&amp; $a != 2 ]]</code> , 如果不适用双括号, 则为 <code>if [ $a -ne 1] &amp;&amp; [ $a != 2 ]</code>或者 <code>if [ $a -ne 1 -a $a != 2 ]</code> 。</li><li>bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</li></ul><h4 id="1-9-3-大括号、花括号"><a href="#1-9-3-大括号、花括号" class="headerlink" title="1.9.3 大括号、花括号 {}"></a>1.9.3 大括号、花括号 {}</h4><p>1）常规用法</p><ul><li>大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt</li><li>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</li></ul><p>2）几种特殊的替换结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var:-string&#125;</span>,<span class="variable">$&#123;var:+string&#125;</span>,<span class="variable">$&#123;var:=string&#125;</span>,<span class="variable">$&#123;var:?string&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>${var:-string}</code> 和 <code>${var:=string}:</code> 若变量var为空，则用在命令行中用string来替换 <code>${var:-string}</code>，否则变量var不为空时，则用变量var的值来替换 <code>${var:-string}</code> ；对于 <code>${var:=string}</code> 的替换规则和 <code>${var:-string}</code> 是一样的，所不同之处是 <code>${var:=string}</code> 若var为空时，用string替换 <code>${var:=string}</code> 的同时，把string赋给变量 <code>var： ${var:=string}</code> 很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</li><li><code>${var:+string}</code> 的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 。</li><li><code>${var:?string}</code> 替换规则为：若变量var不为空，则用变量var的值来替换 <code>${var:?string}</code> ；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。</li></ul><p>补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p><p>3）四种模式匹配替换结构</p><p>模式匹配记忆方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 是去掉左边(在键盘上#在$之左边)</span><br><span class="line">% 是去掉右边(在键盘上%在$之右边)</span><br><span class="line">#和%中的单一符号是最小匹配，两个相同符号是最大匹配。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var%pattern&#125;</span>,<span class="variable">$&#123;var%%pattern&#125;</span>,<span class="variable">$&#123;var#pattern&#125;</span>,<span class="variable">$&#123;var##pattern&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第一种模式：<code>${variable%pattern}</code> ，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式</li></ul><ul><li>第二种模式：<code>${variable%%pattern}</code>，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</li><li>第三种模式：<code>${variable#pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式</li><li>第四种模式：<code>${variable##pattern}</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</li></ul><p>这四种模式中都不会改变variable的值，其中，只有在pattern中使用了匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。</p><p>4）字符串提取和替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var:num&#125;</span>,<span class="variable">$&#123;var:num1:num2&#125;</span>,<span class="variable">$&#123;var/pattern/pattern&#125;</span>,<span class="variable">$&#123;var//pattern/pattern&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第一种模式：<code>${var:num}</code> ，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如 <code>${var: -2}</code> 、<code>${var:1-3}</code> 或 <code>${var:(-2)}</code>。         </li><li>第二种模式：<code>${var:num1:num2}</code>，num1是位置，num2是长度。表示从 <code>$var字符串的第$num1</code> 个位置开始提取长度为$num2的子串。不能为负数。</li><li>第三种模式：<code>${var/pattern/pattern}</code>表示将var字符串的第一个匹配的pattern替换为另一个pattern。。         </li><li>第四种模式：<code>${var//pattern/pattern}</code> 表示将var字符串中的所有能匹配的pattern替换为另一个pattern。</li></ul><h4 id="1-9-4-符号-后的括号"><a href="#1-9-4-符号-后的括号" class="headerlink" title="1.9.4 符号$后的括号"></a>1.9.4 符号$后的括号</h4><ul><li><code>${a}</code> 变量a的值, 在不引起歧义的情况下可以省略大括号。</li><li><code>$(cmd)</code>  命令替换，和<code>cmd</code>效果相同，结果为shell命令cmd的输，过某些Shell版本不支持 <code>$()</code> 形式的命令替换, 如tcsh。</li><li><code>$((expression))</code> 和<code>exprexpression</code>效果相同, 计算数学表达式exp的数值, 其中exp只要符合<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2M=" title="http://lib.csdn.net/base/c">C语言<i class="fa fa-external-link"></i></span>的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。</li></ul><h4 id="1-9-5-多条命令执行"><a href="#1-9-5-多条命令执行" class="headerlink" title="1.9.5 多条命令执行"></a>1.9.5 多条命令执行</h4><ul><li>单小括号，<code>(cmd1;cmd2;cmd3)</code>  新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。</li><li>单大括号，<code>{ cmd1;cmd2;cmd3;}</code>  在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。</li></ul><p>对 <code>{}</code> 和 <code>()</code> 而言, 括号中的重定向符只影响该条命令，而括号外的重定向符影响到括号中的所有命令。</p><h3 id="1-10-Shell特殊变量-0-和命令行参数"><a href="#1-10-Shell特殊变量-0-和命令行参数" class="headerlink" title="1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数"></a>1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数</h3><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名。</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n是一个数字，表示几个参数。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有采纳数。被双引号(“ “)包含是，与$* 稍有不同。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前shell进程ID。对于shell脚本，就是这个脚本所在的进程ID。</td></tr></tbody></table><h4 id="1-10-1-命令行参数"><a href="#1-10-1-命令行参数" class="headerlink" title="1.10.1 命令行参数"></a>1.10.1 命令行参数</h4><p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 <code>$n</code> 表示，例如，<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数，依次类推。</p><h4 id="1-10-2-和-的区别"><a href="#1-10-2-和-的区别" class="headerlink" title="1.10.2 $* 和 $@ 的区别"></a>1.10.2 <code>$*</code> 和 <code>$@</code> 的区别</h4><p><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</p><p>但是当它们被双引号(“ “)包含时，<code>&quot;$*&quot;</code> 会将所有的参数作为一个整体，以<code>&quot;$1 $2 … $n&quot;</code> 的形式输出所有参数；<code>&quot;$@&quot;</code> 会将各个参数分开，以 <code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code>的形式输出所有参数。</p><h4 id="1-10-3-退出状态"><a href="#1-10-3-退出状态" class="headerlink" title="1.10.3 退出状态"></a>1.10.3 退出状态</h4><p><code>$?</code> 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。</p><p>退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</p><p>不过，也有一些命令返回其他值，表示不同类型的错误。</p><p><code>$?</code> 也可以表示函数的返回值，此处不展开。</p><h3 id="1-11-Shell重定向"><a href="#1-11-Shell重定向" class="headerlink" title="1.11 Shell重定向"></a>1.11 Shell重定向</h3><p>1、重定向符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;               输出重定向到一个文件或设备 覆盖原来的文件</span><br><span class="line">&gt;!              输出重定向到一个文件或设备 强制覆盖原来的文件</span><br><span class="line">&gt;&gt;              输出重定向到一个文件或设备 追加原来的文件</span><br><span class="line">&lt;               输入重定向到一个程序</span><br></pre></td></tr></table></figure><p>2、标准输入刷出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 bash 命令执行的过程中，主要有三种输出入的状况，分别是：</span><br><span class="line">1. 标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt;</span><br><span class="line">2. 标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt;</span><br><span class="line">3. 错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt;</span><br></pre></td></tr></table></figure><p>3、使用实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。</span></span><br><span class="line"><span class="comment"># 1&gt;&amp;2 意思是把标准输出重定向到标准错误.</span></span><br><span class="line"><span class="comment"># 2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。</span></span><br><span class="line"><span class="comment"># &amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中</span></span><br><span class="line"></span><br><span class="line">$ cmd &lt;&gt; file<span class="comment"># 以读写方式打开文件 file</span></span><br><span class="line">$ cmd &gt;&amp;n<span class="comment"># 将 cmd 的输出发送到文件描述符 n</span></span><br><span class="line">$ cmd m&gt;&amp;n<span class="comment"># 将本该输出到文件描述符 m 的内容, 发送到文件描述符 n</span></span><br><span class="line">$ cmd m&lt;&amp;n <span class="comment"># 除了本该从文件描述符 m 处获取输入，改为从文件描述符 n 处获取</span></span><br><span class="line">$ cmd &gt;&amp;-<span class="comment"># 关闭标准输出</span></span><br><span class="line">$ cmd &lt;&amp;-<span class="comment"># 关闭标准输入</span></span><br><span class="line">$ cmd  &gt;&amp; file<span class="comment"># 将标准输出和标准错误都发送到文件 file </span></span><br><span class="line">$ cmd  &amp;&gt; file<span class="comment"># 作用同上, 更好的格式</span></span><br></pre></td></tr></table></figure><p>要在终端中打印stdout，同时将它重定向到一个文件中，那么可以这样使用tee 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法：command | tee FILE1 FILE2</span></span><br><span class="line">$ cat a* | tee out.txt | cat -n</span><br><span class="line"><span class="comment"># 默认情况下， tee命令会将文件覆盖，但它提供了一个-a选项，用于追加内容</span></span><br><span class="line">$ cat a* | tee -a out.txt | cat –n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以使用stdin作为命令参数。只需要将-作为命令的文件名参数即可</span></span><br><span class="line"><span class="comment"># 用法：$ cmd1 | cmd2 | cmd -</span></span><br><span class="line">$ <span class="built_in">echo</span> who is this | tee -</span><br></pre></td></tr></table></figure><h3 id="1-12-Shell数组和关联数组"><a href="#1-12-Shell数组和关联数组" class="headerlink" title="1.12 Shell数组和关联数组"></a>1.12 Shell数组和关联数组</h3><h4 id="1-12-1-简介"><a href="#1-12-1-简介" class="headerlink" title="1.12.1 简介"></a>1.12.1 简介</h4><p>数组是Shell脚本非常重要的组成部分，它借助索引将多个独立的独立的数据存储为一个集合。普通数组只能使用整数作为数组索引，关联数组不仅可以使用整数作为索引，也可以使用字符串作为索引。通常情况下，使用字符串做索引更容易被人们理解。Bash从4.0之后开始引入关联数组。</p><h4 id="1-12-2-定义打印普通数组"><a href="#1-12-2-定义打印普通数组" class="headerlink" title="1.12.2 定义打印普通数组"></a>1.12.2 定义打印普通数组</h4><p>数组的方法有如下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在一行上列出所有元素</span></span><br><span class="line">$ array_var=(1 2 3 4 5 6)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以“索引-值”的形式一一列出</span></span><br><span class="line">$ array_var[0]=<span class="string">"test1"</span></span><br><span class="line">$ array_var[1]=<span class="string">"test2"</span></span><br><span class="line">$ array_var[2]=<span class="string">"test3"</span></span><br></pre></td></tr></table></figure><p>注意：第一种方法要使用圆括号，否则后面会报错。</p><p>数组元素的方法有如下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[0]&#125;</span>         <span class="comment">#输出结果为 test1</span></span><br><span class="line">$ index=2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[$index]&#125;</span>    <span class="comment">#输出结果为 test3</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[*]&#125;</span>         <span class="comment">#输出所有数组元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array_var[@]&#125;</span>         <span class="comment">#输出所有数组元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#array_var[*]&#125;</span>        <span class="comment">#输出值为 3</span></span><br></pre></td></tr></table></figure><p>注意：在ubuntu 14.04中，shell脚本要以#!/bin/bash开头，且执行脚本的方式为 bash test.sh。</p><h4 id="1-12-3-定义打印关联数组"><a href="#1-12-3-定义打印关联数组" class="headerlink" title="1.12.3 定义打印关联数组"></a>1.12.3 定义打印关联数组</h4><p>定义关联数组<br>在关联数组中，可以使用任何文本作为数组索引。定义关联数组时，首先需要使用声明语句将一个变量声明为关联数组，然后才可以在数组中添加元素，过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -A ass_array                           <span class="comment">#声明一个关联数组</span></span><br><span class="line">$ ass_array=([<span class="string">"index1"</span>]=index1 [<span class="string">"index2"</span>]=index2)<span class="comment">#内嵌“索引-值”列表法</span></span><br><span class="line">$ ass_array[<span class="string">"index3"</span>]=index3</span><br><span class="line">$ ass_array[<span class="string">"index4"</span>]=index4</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;ass_array["index1"]&#125;</span>                    <span class="comment">#输出为index1</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;ass_array["index4"]&#125;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[*]&#125;</span>                          <span class="comment">#输出索引列表</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[@]&#125;</span>                          <span class="comment">#输出索引列表</span></span><br></pre></td></tr></table></figure><p>注意：对于普通数组，使用上面的方法依然可以列出索引列表，在声明关联数组以及添加数组元素时，都不能在前面添加美元符$。</p><h3 id="1-13-使用别名"><a href="#1-13-使用别名" class="headerlink" title="1.13 使用别名"></a>1.13 使用别名</h3><p>alias命令的作用只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名设置一直保持作用，可以将它放入~/.bashrc文件中。因为每当一个新的shell进程生成时，都会执行 ~/.bashrc中的命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> install=<span class="string">'sudo apt-get install'</span></span><br></pre></td></tr></table></figure><h3 id="1-14-获取、设置日期和延时"><a href="#1-14-获取、设置日期和延时" class="headerlink" title="1.14 获取、设置日期和延时"></a>1.14 获取、设置日期和延时</h3><p>时间方面 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% : 印出</span><br><span class="line">% %n : 下一行</span><br><span class="line">%t : 跳格</span><br><span class="line">%H : 小时(00..23)</span><br><span class="line">%I : 小时(01..12)</span><br><span class="line">%k : 小时(0..23)</span><br><span class="line">%l : 小时(1..12)</span><br><span class="line">%M : 分钟(00..59)</span><br><span class="line">%p : 显示本地 AM 或 PM</span><br><span class="line">%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</span><br><span class="line">%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数 %S : 秒(00..61)</span><br><span class="line">%T : 直接显示时间 (24 小时制)</span><br><span class="line">%X : 相当于 %H:%M:%S</span><br><span class="line">%Z : 显示时区</span><br></pre></td></tr></table></figure><p>日期方面 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%a : 星期几 (Sun..Sat)</span><br><span class="line">%A : 星期几 (Sunday..Saturday)</span><br><span class="line"></span><br><span class="line">%b : 月份 (Jan..Dec)</span><br><span class="line">%B : 月份 (January..December)</span><br><span class="line"></span><br><span class="line">%y : 年份的最后两位数字 (00.99)</span><br><span class="line">%Y : 完整年份 (0000..9999)</span><br><span class="line"></span><br><span class="line">%c : 直接显示日期与时间</span><br><span class="line">%d : 日 (01..31)</span><br><span class="line">%D : 直接显示日期 (mm/dd/yy)</span><br><span class="line">%h : 同 %b</span><br><span class="line">%j : 一年中的第几天 (001..366)</span><br><span class="line">%m : 月份 (01..12)</span><br><span class="line">%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)</span><br><span class="line">%w : 一周中的第几天 (0..6)</span><br><span class="line">%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)</span><br><span class="line">%x : 直接显示日期 (mm/dd/yy)</span><br></pre></td></tr></table></figure><p>若是不以加号作为开头，则表示要设定时间，而时间格式为 <code>MMDDhhmm[[CC]YY][.ss]</code>，其中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MM 为月份，</span><br><span class="line">DD 为日，</span><br><span class="line">hh 为小时，</span><br><span class="line">mm 为分钟，</span><br><span class="line">CC 为年份前两位数字，</span><br><span class="line">YY 为年份后两位数字，</span><br><span class="line">ss 为秒数</span><br></pre></td></tr></table></figure><p>参数 :</p><p>-d datestr : 显示 datestr 中所设定的时间 (非系统时间)</p><p>–help : 显示辅助讯息</p><p>-s datestr : 将系统时间设为 datestr 中所设定的时间</p><p>-u : 显示目前的格林威治时间</p><p>–version : 显示版本编号</p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ date<span class="comment"># 获取日期</span></span><br><span class="line">$ date +%s<span class="comment"># 打印纪元时</span></span><br><span class="line">$ date <span class="string">"+%d %B %Y"</span><span class="comment"># 用格式串结合 + 作为date命令的参数，可以按照你的选择打印出对应格式的日期</span></span><br><span class="line">20 May 2010</span><br><span class="line">$ date -s <span class="string">"21 June 2009 11:01:22"</span> <span class="comment"># 设置日期和时间</span></span><br></pre></td></tr></table></figure><h3 id="1-15-脚本调试"><a href="#1-15-脚本调试" class="headerlink" title="1.15 脚本调试"></a>1.15 脚本调试</h3><h4 id="1-15-1使用选项–x，启用shell脚本的跟踪调试功能"><a href="#1-15-1使用选项–x，启用shell脚本的跟踪调试功能" class="headerlink" title="1.15.1使用选项–x，启用shell脚本的跟踪调试功能"></a>1.15.1使用选项–x，启用shell脚本的跟踪调试功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash -x script.sh</span><br></pre></td></tr></table></figure><h4 id="1-15-2-使用set-x和set-x对脚本进行部分调试"><a href="#1-15-2-使用set-x和set-x对脚本进行部分调试" class="headerlink" title="1.15.2 使用set -x和set +x对脚本进行部分调试"></a>1.15.2 使用set -x和set +x对脚本进行部分调试</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#文件名: debug.sh</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.6</span>&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">set</span> -x</span><br><span class="line">echo $i</span><br><span class="line"><span class="keyword">set</span> +x</span><br><span class="line">done</span><br><span class="line">echo <span class="string">"Script executed"</span></span><br></pre></td></tr></table></figure><ul><li>set –x：在执行时显示参数和命令。 </li><li>set +x：禁止调试。 </li><li>set –v：当命令进行读取时显示输入。 </li><li>set +v：禁止打印输入。 </li></ul><h4 id="1-15-3-通过传递-DEBUG环境变量调试"><a href="#1-15-3-通过传递-DEBUG环境变量调试" class="headerlink" title="1.15.3 通过传递 _DEBUG环境变量调试"></a>1.15.3 通过传递 _DEBUG环境变量调试</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DEBUG</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">[ <span class="string">"$_DEBUG"</span> == <span class="string">"on"</span> ] &amp;&amp; $@ || :</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.10</span>&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">DEBUG echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>可以将调试功能置为”on”来运行上面的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ _DEBUG=on ./script.sh</span><br></pre></td></tr></table></figure><p>我们在每一个需要打印调试信息的语句前加上DEBUG。如果没有把 _DEBUG=on传递给脚本，那么调试信息就不会打印出来。在Bash中，命令 <code>:</code> 告诉shell不要进行任何操作。 </p><h4 id="1-15-4-利用shebang来进行调试"><a href="#1-15-4-利用shebang来进行调试" class="headerlink" title="1.15.4 利用shebang来进行调试"></a>1.15.4 利用shebang来进行调试</h4><p>shebang的妙用<br>把shebang从 <code>#!/bin/bash</code> 改成 <code>#!/bin/bash -xv</code>，这样一来，不用任何其他选项就可以启用调试功能了。 </p><h3 id="1-16-函数参数"><a href="#1-16-函数参数" class="headerlink" title="1.16 函数参数"></a>1.16 函数参数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$<span class="number">0</span> # 脚本名</span><br><span class="line">$<span class="number">1</span># 第一个参数</span><br><span class="line">$<span class="number">2</span># 第二个参数</span><br><span class="line">$n# 第n个参数</span><br><span class="line"><span class="string">"$@"</span># 被扩展成 <span class="string">"$1"</span> <span class="string">"$2"</span> <span class="string">"$3"</span>等</span><br><span class="line"><span class="string">"$*"</span># 被扩展成 <span class="string">"$1c$2c$3"</span>，其中c是IFS的第一个字符</span><br><span class="line"><span class="string">"$@"</span> 要比<span class="string">"$*"</span>用得多。由于 <span class="string">"$*"</span>将所有的参数当做单个字符串，因此它很少被使用。</span><br></pre></td></tr></table></figure><p><strong>导出函数：</strong></p><p>函数也能像环境变量一样用export导出，如此一来，函数的作用域就可以扩展到子进程中，例如： </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> -f fname</span><br></pre></td></tr></table></figure><h3 id="1-17-read命令"><a href="#1-17-read命令" class="headerlink" title="1.17 read命令"></a>1.17 read命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从输入中读取n个字符并存入变量</span></span><br><span class="line">$ <span class="built_in">read</span> -n 2 var</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用无回显的方式读取密码</span></span><br><span class="line">$ <span class="built_in">read</span> -s var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示提示信息</span></span><br><span class="line">$ <span class="built_in">read</span> -p <span class="string">"Enter input:"</span> var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在特定时(秒)限内读取输入</span></span><br><span class="line">$ <span class="built_in">read</span> -t timeout var</span><br></pre></td></tr></table></figure><h3 id="1-18-条件比较与测试"><a href="#1-18-条件比较与测试" class="headerlink" title="1.18 条件比较与测试"></a>1.18 条件比较与测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if条件</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># else if和else</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> condition <span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>if的条件判断部分可能会变得很长，但可以用逻辑运算符将它变得简洁一些： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition ] &amp;&amp; action <span class="comment"># 如果condition为真，则执行action</span></span><br><span class="line">[ condition ] || action <span class="comment"># 如果condition为假，则执行action</span></span><br></pre></td></tr></table></figure><p><code>&amp;&amp;</code> 是逻辑与运算符， <code>||</code> 是逻辑或运算符。编写Bash脚本时，这是一个很有用的技巧。现在来了解一下条件和比较操作。 </p><p>算术比较：</p><ul><li><code>-gt</code> ：大于。 </li><li><code>-lt</code> ：小于。 </li><li><code>-ge</code> ：大于或等于。 </li><li><code>-le</code> ：小于或等于。 </li></ul><p>可以按照下面的方法结合多个条件进行测试： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="variable">$var1</span> -ne 0 -a <span class="variable">$var2</span> -gt 2 ] <span class="comment">#使用逻辑与-a</span></span><br><span class="line">[ <span class="variable">$var1</span> -ne 0 -o var2 -gt 2 ] <span class="comment">#逻辑或 -o</span></span><br></pre></td></tr></table></figure><p>文件系统相关测试：</p><p>我们可以使用不同的条件标志测试不同的文件系统相关的属性。 </p><ul><li><code>[ -f $file_var ]</code> ：如果给定的变量包含正常的文件路径或文件名，则返回真。 </li><li><code>[ -x $var ]</code> ：如果给定的变量包含的文件可执行，则返回真。 </li><li><code>[ -d $var ]</code> ：如果给定的变量包含的是目录，则返回真。 </li><li><code>[ -e $var ]</code> ：如果给定的变量包含的文件存在，则返回真。 </li><li><code>[ -c $var ]</code> ：如果给定的变量包含的是一个字符设备文件的路径，则返回真。 </li><li><code>[ -b $var ]</code> ：如果给定的变量包含的是一个块设备文件的路径，则返回真。 </li><li><code>[ -w $var ]</code> ：如果给定的变量包含的文件可写，则返回真。 </li><li><code>[ -r $var ]</code> ：如果给定的变量包含的文件可读，则返回真。 </li><li><code>[ -L $var ]</code> ：如果给定的变量包含的是一个符号链接，则返回真。 </li></ul><p>字符串比较：</p><p style="color: red;">使用字符串比较时，最好用双中括号，因为有时候采用单个中括号会产生错误，所以最好避开它们。 </p><p>可以用下面的方法检查两个字符串，看看它们是否相同。 </p><ul><li><code>[[ $str1 = $str2 ]]</code>：当str1等于str2时，返回真。也就是说， str1和str2包含<br>的文本是一模一样的。 </li><li><code>[[ $str1 == $str2 ]]</code> ：这是检查字符串是否相等的另一种写法。 </li></ul><p>也可以检查两个字符串是否不同。 </p><ul><li><code>[[ $str1 != $str2 ]]</code> ：如果str1和str2不相同，则返回真。 </li></ul><p>我们还可以检查字符串的字母序情况，具体如下所示。 </p><ul><li><code>[[ $str1 &gt; $str2 ]]</code> ：如果str1的字母序比str2大，则返回真。 </li><li><code>[[ $str1 &lt; $str2 ]]</code> ：如果str1的字母序比str2小，则返回真。 </li><li><code>[[ -z $str1 ]]</code> ：如果str1包含的是空字符串，则返回真。 </li><li><code>[[ -n $str1 ]]</code> ：如果str1包含的是非空字符串，则返回真。 </li></ul><p>使用逻辑运算符 &amp;&amp; 和 || 能够很容易地将多个条件组合起来： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$str1</span> ]] &amp;&amp; [[ -z <span class="variable">$str2</span> ]] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>test命令可以用来执行条件检测。用test可以避免使用过多的括号。之前讲过的[]中的测试条件同样可以用于test命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> -eq 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"True"</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 也可以写成：</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$var</span> -eq 0 ; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"True"</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><h4 id="1-利用子shell生成一个独立的进程"><a href="#1-利用子shell生成一个独立的进程" class="headerlink" title="1. 利用子shell生成一个独立的进程"></a>1. 利用子shell生成一个独立的进程</h4><p>子shell本身就是独立的进程。可以使用 <code>( )</code>操作符来定义一个子shell ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd;</span><br><span class="line">(cd /bin; ls);</span><br><span class="line">pwd;</span><br></pre></td></tr></table></figure><h4 id="2-无限循环的实例"><a href="#2-无限循环的实例" class="headerlink" title="2. 无限循环的实例"></a>2. 无限循环的实例</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> $@ &amp;&amp; <span class="keyword">return</span>; done &#125;</span><br></pre></td></tr></table></figure><p>工作原理：</p><p>函数repeat，它包含了一个无限while循环，该循环执行以参数形式（通过 <code>$@</code> 访问）传入函数的命令。如果命令执行成功，则返回，进而退出循环。 </p><p><strong>一种更快的做法 ：</strong></p><p>在大多数现代系统中， <code>true</code> 是作为 <code>/bin</code> 中的一个二进制文件来实现的。</p><p style="color: red;">这就意味着每执行一次while循环， shell就不得不生成一个进程。</p>如果不想这样，可以使用shell内建的 <code>:</code>命令，它总是会返回为0的退出码： <p></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; <span class="keyword">while</span> :; <span class="keyword">do</span> $@ &amp;&amp; <span class="keyword">return</span>; done &#125;</span><br></pre></td></tr></table></figure><p>尽管可读性不高，但是肯定比第一种方法快。 </p><h2 id="2-命令之乐"><a href="#2-命令之乐" class="headerlink" title="2. 命令之乐"></a>2. 命令之乐</h2><h3 id="2-1-cat命令"><a href="#2-1-cat命令" class="headerlink" title="2.1 cat命令"></a>2.1 cat命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摆脱多余的空白行</span></span><br><span class="line">$ cat -s file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示行号</span></span><br><span class="line">$ cat -n file</span><br><span class="line"><span class="comment"># -n甚至会为空白行加上行号。如果你想跳过空白行，那么可以使用选项-b。</span></span><br></pre></td></tr></table></figure><h3 id="2-2-find命令"><a href="#2-2-find命令" class="headerlink" title="2.2 find命令"></a>2.2 find命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录及子目录下所有的文件和文件夹</span></span><br><span class="line">$ find base_path</span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># -print指明打印出匹配文件的文件名（路径）。当使用 -print时， '\n'作为用于对输出的文件名进行分隔。就算你忽略-print， find命令仍会打印出文件名。</span></span><br><span class="line"><span class="comment"># -print0指明使用'\0'作为匹配的文件名之间的定界符。</span></span><br></pre></td></tr></table></figure><p>1、find命令有一个选项 <code>-iname</code>（忽略字母大小写） </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">example.txt EXAMPLE.txt file.txt</span><br><span class="line">$ find . -iname <span class="string">"example*"</span> -<span class="built_in">print</span></span><br><span class="line">./example.txt</span><br><span class="line">./EXAMPLE.txt</span><br></pre></td></tr></table></figure><p>2、如果想匹配多个条件中的一个，可以采用OR条件操作 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">new.txt some.jpg text.pdf</span><br><span class="line">$ find . \( -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span> \) -<span class="built_in">print</span></span><br><span class="line">./text.pdf</span><br><span class="line">./new.txt</span><br></pre></td></tr></table></figure><p>3、选项-path的参数可以使用通配符来匹配文件路径。 <code>-name</code> 总是用给定的文件名进行匹配。<code>-path</code> 则将文件路径作为一个整体进行匹配。例如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find /home/users -path <span class="string">"*/slynux/*"</span> -<span class="built_in">print</span></span><br><span class="line">/home/users/list/slynux.txt</span><br><span class="line">/home/users/slynux/eg.css</span><br></pre></td></tr></table></figure><p>4、选项 <code>-regex</code> 的参数和 <code>-path</code> 的类似，只不过 <code>-regex</code> 是基于正则表达式来匹配文件路径的。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">new.PY next.jpg test.py</span><br><span class="line">$ find . -regex <span class="string">".*\(\.py\|\.sh\)$"</span></span><br><span class="line">./test.py</span><br><span class="line"><span class="comment"># 类似地， -iregex可以让正则表达式忽略大小写。例如：</span></span><br><span class="line">$ find . -iregex <span class="string">".*\(\.py\|\.sh\)$"</span></span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure><p>5、find也可以用“!”否定参数的含义。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">list.txt new.PY new.txt next.jpg test.py</span><br><span class="line">$ find . ! -name <span class="string">"*.txt"</span> -<span class="built_in">print</span></span><br><span class="line">.</span><br><span class="line">./next.jpg</span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure><p>6、基于目录深度的搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 深度选项-maxdepth和 -mindepth来限制find命令遍历的目录深度</span></span><br><span class="line"><span class="comment"># 下列命令将find命令向下的最大深度限制为1:</span></span><br><span class="line">$ find . -maxdepth 1 -name <span class="string">"f*"</span> -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出深度距离当前目录至少两个子目录的所有文件:</span></span><br><span class="line">$ find . -mindepth 2 -name <span class="string">"f*"</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>-maxdepth和-mindepth应该作为find的第三个参数出现。如果作为第4个或之后的参数，就可能会影响到find的效率，因为它不得不进行一些不必要的检查。 </p><p>根据文件类型搜索</p><p>7、根据文件类型搜索</p><p><code>-type</code> 可以对文件搜索进行过滤 </p><table><thead><tr><th>文件类型</th><th>类型参数</th></tr></thead><tbody><tr><td>普通文件</td><td>f</td></tr><tr><td>符号链接</td><td>l</td></tr><tr><td>目录</td><td>d</td></tr><tr><td>字符设备</td><td>c</td></tr><tr><td>块设备</td><td>b</td></tr><tr><td>套接字</td><td>s</td></tr><tr><td>FIFO</td><td>p</td></tr></tbody></table><p>8、根据文件时间进行搜索</p><ul><li>访问时间（-atime）：用户最近一次访问文件的时间。</li><li>修改时间（-mtime）：文件内容最后一次被修改的时间。</li><li>变化时间（-ctime）：文件元数据（例如权限或所有权）最后一次改变的时间。</li></ul><blockquote><p>-atime、 -mtime、 -ctime可作为find的时间选项。它们可以用整数值指定，单位是天。这些整数值通常还带有 - 或 + ： - 表示小于， + 表示大于。 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出在最近7天内被访问过的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime -7 -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出恰好在7天前被访问过的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime 7 -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出访问时间超过7天的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -atime +7 -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>-atime、 -mtime以及-ctime都是基于时间的参数，其计量单位是“天”。还有其他一些基于时间的参数是以分钟作为计量单位的。这些参数包括： </p><ul><li>-amin（访问时间）</li><li>-mmin（修改时间）</li><li>-cmin（变化时间）</li></ul><p>使用 <code>-newer</code> ，我们可以指定一个用于比较时间戳的参考文件，然后找出比参考文件更新的（更近的修改时间）所有文件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出比file.txt修改时间更近的所有文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -newer file.txt -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>9、基于文件大小的搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -size +2k</span><br><span class="line"><span class="comment"># 大于2KB的文件</span></span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -size -2k</span><br><span class="line"><span class="comment"># 小于2KB的文件</span></span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -size 2k</span><br><span class="line"><span class="comment"># 大小等于2KB的文件</span></span><br></pre></td></tr></table></figure><ul><li>b —— 块（512字节）</li><li>c —— 字节</li><li>w —— 字（2字节）</li><li>k —— 1024字节</li><li>M —— 1024k字节</li><li>G —— 1024M字节</li></ul><p>10、删除匹配的文件</p><p><code>-delete</code> 可以用来删除find查找到的匹配文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除当前目录下所有的 .swp文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.swp"</span> -delete</span><br></pre></td></tr></table></figure><p>11、基于文件权限和所有权的匹配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -perm 644 -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印出权限为644的文件</span></span><br></pre></td></tr></table></figure><p>-perm指明find应该只匹配具有特定权限值的文件。 </p><p>12、利用find执行命令或动作 </p><p>find命令可以借助选项-exec与其他命名进行结合。 -exec算得上是find最强大的特性之一。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> chown slynux &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#125;是一个与 -exec选项搭配使用的特殊字符串。对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名。</span></span><br></pre></td></tr></table></figure><p><code>-exec</code> 结合多个命令 :</p><p>我们无法在-exec参数中直接使用多个命令。它只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个shell脚本中（例如command.sh），然后在-exec中使用这个脚本：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec ./commands.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>13、让find跳过特定的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find devel/source_path \( -name <span class="string">".git"</span> -prune \) -o \( -<span class="built_in">type</span> f -<span class="built_in">print</span> \)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令打印出不包括在.git目录中的所有文件的名称（路径）。</span></span><br></pre></td></tr></table></figure><p><code>\( -name &quot;.git&quot; -prune \)</code> 的作用是用于进行排除，它指明了 .git目录应该被排除在外，而<code>\( -type f -print \)</code> 指明了需要执行的动作。这些动作需要被放置在第二个语句块中（打印出所有文件的名称和路径）。 </p><h3 id="2-3-玩转xargs"><a href="#2-3-玩转xargs" class="headerlink" title="2.3 玩转xargs"></a>2.3 玩转xargs</h3><p><code>xargs</code> 擅长将标准输入数据转换成命令行参数。</p><p><code>xargs</code> 命令把从 stdin接收到的数据重新格式化，再将其作为参数提供给其他命令。 </p><h4 id="2-3-1-将多行输入转换成单行输出"><a href="#2-3-1-将多行输入转换成单行输出" class="headerlink" title="2.3.1 将多行输入转换成单行输出"></a>2.3.1 将多行输入转换成单行输出</h4><p>只需要将换行符移除，再用” “（空格）进行代替，就可以实现多行输入的转换。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.txt <span class="comment"># 样例文件</span></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">7 8 9 10</span><br><span class="line">11 12</span><br><span class="line">$ cat example.txt | xargs</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12</span><br></pre></td></tr></table></figure><h4 id="2-3-2-将单行输入转换成多行输出"><a href="#2-3-2-将单行输入转换成多行输出" class="headerlink" title="2.3.2 将单行输入转换成多行输出"></a>2.3.2 将单行输入转换成多行输出</h4><p>指定每行最大的参数数量 <code>n</code>，我们可以将任何来自stdin的文本划分成多行，每行 <code>n</code> 个参数。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.txt | xargs -n 3</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">10 11 12</span><br></pre></td></tr></table></figure><h4 id="2-3-3-定制定界符"><a href="#2-3-3-定制定界符" class="headerlink" title="2.3.3 定制定界符"></a>2.3.3 定制定界符</h4><p>用 <code>-d</code> 选项为输入指定一个定制的定界符： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X</span><br><span class="line">split split split split</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X -n 2</span><br><span class="line">split split</span><br><span class="line">split split</span><br></pre></td></tr></table></figure><p>在这里，我们明确指定X作为输入定界符，而在默认情况下， xargs采用内部字段分隔符（空格）作为输入定界符。 </p><h4 id="2-3-4-读取stdin，将格式化参数传递给命令"><a href="#2-3-4-读取stdin，将格式化参数传递给命令" class="headerlink" title="2.3.4 读取stdin，将格式化参数传递给命令"></a>2.3.4 读取stdin，将格式化参数传递给命令</h4><p><code>-I</code> 指定替换字符串，这个字符串在xargs扩展时会被替换掉。如果将 <code>-I</code> 与 <code>xargs</code> 结合使用，对于每一个参数，命令都会被执行一次。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat args.txt</span><br><span class="line">arg1</span><br><span class="line">arg2</span><br><span class="line">arg3</span><br><span class="line">$ cat args.txt | xargs -I &#123;&#125; ./cecho.sh -p &#123;&#125; -l</span><br><span class="line">-p arg1 -l <span class="comment">#</span></span><br><span class="line">-p arg2 -l <span class="comment">#</span></span><br><span class="line">-p arg3 -l <span class="comment">#</span></span><br></pre></td></tr></table></figure><p><code>-I {}</code> 指定了替换字符串。对于每一个命令参数，字符串 <code>{}</code> 都会被从stdin读取到的参数替换掉。 </p><p>使用 <code>-I</code> 的时候，命令以循环的方式执行。 </p><p>xargs和find算是一对死党。两者结合使用可以让任务变得更轻松。 不过人们通常却是以一种错误的组合方式使用它们。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">print</span> | xargs rm -f</span><br></pre></td></tr></table></figure><p>这样做很危险。 有时可能会删除不必要删除的文件。 </p><p>只要我们把 <code>find</code> 的输出作为 <code>xargs</code> 的输入，就必须将 <code>-print0</code> 与 <code>find</code> 结合使用，以字符<code>null（&#39;\0&#39;）</code>来分隔输出。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -print0 | xargs -0 rm -f</span><br><span class="line"><span class="comment"># xargs -0将\0作为输入定界符。</span></span><br><span class="line"></span><br><span class="line">$ find source_code_dir_path -<span class="built_in">type</span> f -name <span class="string">"*.c"</span> -print0 | xargs -0 wc -l</span><br><span class="line"><span class="comment"># 统计源代码目录中所有C程序文件的行数</span></span><br></pre></td></tr></table></figure><h3 id="2-4-校验和与核实"><a href="#2-4-校验和与核实" class="headerlink" title="2.4 校验和与核实"></a>2.4 校验和与核实</h3><p>校验和（checksum）程序用来从文件中生成校验和密钥，然后利用这个校验和密钥核实文件的完整性。文件可以通过网络或任何存储介质分发到不同的地点。 </p><p>最知名且使用最为广泛的校验和技术是md5sum和SHA-1。它们对文件内容使用相应的算法来生成校验和。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum filename</span><br><span class="line">68b329da9893e34099c7d8ad5cb9c940 filename</span><br><span class="line"></span><br><span class="line">$ md5sum filename &gt; file_sum.md5</span><br><span class="line"></span><br><span class="line">$ md5sum file1 file2 file3 ..</span><br><span class="line"></span><br><span class="line">$ md5sum -c file_sum.md5</span><br><span class="line"><span class="comment"># 这个命令会输出校验和是否匹配的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要用所有的.md5信息来检查所有的文件，可以使用：</span></span><br><span class="line">$ md5sum -c *.md5</span><br></pre></td></tr></table></figure><p>计算SAH-1串的命令是sha1sum。其用法和md5sum的非常相似。只需要把先前讲过的那些命令中的md5sum替换成sha1sum就行了，记住将输入文件名从file_sum.md5改为file_sum.sha1。 </p><p>对目录进行校验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ md5deep -rl directory_path &gt; directory.md5</span><br><span class="line"><span class="comment"># -r使用递归的方式</span></span><br><span class="line"><span class="comment"># -l使用相对路径。默认情况下， md5deep会输出文件的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者也可以结合find来递归计算校验和：</span></span><br><span class="line">$ find directory_path -<span class="built_in">type</span> f -print0 | xargs -0 md5sum &gt;&gt; directory.md5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的命令进行核实：</span></span><br><span class="line">$ md5sum -c directory.md5</span><br></pre></td></tr></table></figure><h4 id="2-4-1-加密工具与散列"><a href="#2-4-1-加密工具与散列" class="headerlink" title="2.4.1 加密工具与散列"></a>2.4.1 加密工具与散列</h4><p><code>crypt</code>、 <code>gpg</code>、 <code>base64</code>、 <code>md5sum</code>、 <code>sha1sum</code> 以及 <code>openssl</code> 的用法。 </p><p>1）crypt是一个简单的加密工具，它从stdin接受一个文件以及口令作为输入，然后将加密数据输出到Stdout（因此要对输入、输出文件使用重定向）。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ crypt &lt;input_file &gt;output_file</span><br><span class="line">Enter passphrase:</span><br><span class="line"><span class="comment"># 它会要求输入一个口令。我们也可以通过命令行参数来提供口令。</span></span><br><span class="line"></span><br><span class="line">$ crypt PASSPHRASE &lt;input_file &gt;encrypted_file</span><br><span class="line"><span class="comment"># 如果需要解密文件，可以使用：</span></span><br><span class="line">$ crypt PASSPHRASE -d &lt;encrypted_file &gt;output_file</span><br></pre></td></tr></table></figure><p>2）gpg（GNU隐私保护）是一种应用广泛的工具，它使用加密技术来保护文件，以确保数据在送达目的地之前无法被读取。这里我们讨论如何加密、解密文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用gpg加密文件：</span></span><br><span class="line">$ gpg -c filename</span><br><span class="line"><span class="comment"># 该命令采用交互方式读取口令，并生成filename.gpg。使用以下命令解密gpg文件：</span></span><br><span class="line">$ gpg filename.gpg</span><br><span class="line"><span class="comment"># 该命令读取口令，然后对文件进行解密。</span></span><br></pre></td></tr></table></figure><p>3）Base64是一组相似的编码方案，它将ASCII字符转换成以64为基数的形式，以可读的ASCII字符串来描述二进制数据。 base64命令可以用来编码/解码Base64字符串。要将文件编码为Base64格式，可以使用： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ base64 filename &gt; outputfile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat file | base64 &gt; outputfile</span><br><span class="line"><span class="comment"># base64可以从stdin中进行读取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码Base64数据：</span></span><br><span class="line">$ base64 -d file &gt; outputfile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat base64_file | base64 -d &gt; outputfile</span><br></pre></td></tr></table></figure><p>4）md5sum与sha1sum都是单向散列算法，均无法逆推出原始数据。它们通常用于验证数据完整性或为特定数据生成唯一的密钥： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum file</span><br><span class="line">8503063d5488c3080d4800ff50850dc9 file</span><br><span class="line">$ sha1sum file</span><br><span class="line">1ba02b66e2e557fede8f61b7df282cd0a27b816b file</span><br></pre></td></tr></table></figure><p>这种类型的散列算法是存储密码的理想方案。密码使用其对应的散列值来存储。如果某个用户需要进行认证，读取该用户提供的密码并转换成散列值，然后将其与之前存储的散列值进行比对。如果相同，用户就通过认证，被允许访问；否则，就会被拒绝访问。 </p><p>5）openssl</p><p>用openssl生成shadow密码。 shadow密码通常都是salt密码。所谓SALT就是额外的一个字符串，用来起一个混淆的作用，使加密更加不易被破解。 salt由一些随机位组成，被用作密钥生成函数的输入之一，以生成密码的salt散列值。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ opensslpasswd -1 -salt SALT_STRING PASSWORD</span><br><span class="line"><span class="variable">$1</span><span class="variable">$SALT_STRING</span><span class="variable">$323VkWkSLHuhbt1zkSsUG</span>.</span><br><span class="line"><span class="comment"># 将SALT_STRING替换为随机字符串，并将PASSWORD替换成你想要使用的密码。</span></span><br></pre></td></tr></table></figure><h3 id="2-5-排序、唯一与重复"><a href="#2-5-排序、唯一与重复" class="headerlink" title="2.5 排序、唯一与重复"></a>2.5 排序、唯一与重复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对一组文件进行排序：</span></span><br><span class="line">$ sort file1.txt file2.txt &gt; sorted.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照数字顺序进行排序：</span></span><br><span class="line">$ sort -n file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照逆序进行排序：</span></span><br><span class="line">$ sort -r file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照月份进行排序（依照一月，二月，三月……）：</span></span><br><span class="line">$ sort -M months.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两个已排序过的文件：</span></span><br><span class="line">$ sort -m sorted1 sorted2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出已排序文件中不重复的行：</span></span><br><span class="line">$ sort file1.txt file2.txt | uniq</span><br></pre></td></tr></table></figure><p>检查文件是否已经排序过：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#功能描述：排序</span><br><span class="line">sort -C filename ;</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ]; then</span><br><span class="line">echo Sorted;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo Unsorted;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><code>-k</code> 指定了排序应该按照哪一个键（key）来进行。键指的是列号，而列号就是执行排序时的依据。 <code>-r</code> 告诉sort命令按照逆序进行排序。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依据第1列，以逆序形式排序</span></span><br><span class="line">$ sort -nrk 1 data.txt</span><br><span class="line">4 linux 1000</span><br><span class="line">3 bsd 1000</span><br><span class="line">2 winxp 4000</span><br><span class="line">1 mac 2000</span><br><span class="line"><span class="comment"># -nr表明按照数字，采用逆序形式排序</span></span><br><span class="line"><span class="comment"># 依据第2列进行排序</span></span><br><span class="line">$ sort -k 2 data.txt</span><br><span class="line">3 bsd 1000</span><br><span class="line">4 linux 1000</span><br><span class="line">1 mac 2000</span><br><span class="line">2 winxp 4000</span><br></pre></td></tr></table></figure><p>有时文本中可能会包含一些像空格之类的不必要的多余字符。如果需要忽略这些字符，并以字典序进行排序，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sort -bd unsorted.txt</span><br><span class="line"><span class="comment"># 选项-b用于忽略文件中的前导空白行，选项-d用于指明以字典序进行排序。</span></span><br></pre></td></tr></table></figure><p>sort选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-b：忽略每行前面开始出的空格字符；</span><br><span class="line"></span><br><span class="line">-c：检查文件是否已经按照顺序排序； </span><br><span class="line"></span><br><span class="line">-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符； </span><br><span class="line"></span><br><span class="line">-f：排序时，将小写字母视为大写字母； </span><br><span class="line"></span><br><span class="line">-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</span><br><span class="line"></span><br><span class="line">-m：将几个排序号的文件进行合并； </span><br><span class="line"></span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序； </span><br><span class="line"></span><br><span class="line">-n：依照数值的大小排序； </span><br><span class="line"></span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件； </span><br><span class="line"></span><br><span class="line">-r：以相反的顺序来排序； </span><br><span class="line"></span><br><span class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符； </span><br><span class="line"></span><br><span class="line">+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</span><br></pre></td></tr></table></figure><p>uniq选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：在每列旁边显示该行重复出现的次数； </span><br><span class="line"></span><br><span class="line">-d或--repeated：仅显示重复出现的行列； </span><br><span class="line"></span><br><span class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位； </span><br><span class="line"></span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符； </span><br><span class="line"></span><br><span class="line">-u或——unique：仅显示出一次的行列； </span><br><span class="line"></span><br><span class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。</span><br></pre></td></tr></table></figure><p>wc选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-c或--bytes或——chars：只显示Bytes数； <span class="comment"># 统计字符数</span></span><br><span class="line"></span><br><span class="line">-l或——lines：只显示列数； <span class="comment"># 统计行数</span></span><br><span class="line"></span><br><span class="line">-w或——words：只显示字数。<span class="comment"># 统计单词数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当不使用任何选项执行wc时，它会分别打印出文件的行数、单词数和字符数：</span></span><br><span class="line">$ wc file</span><br><span class="line">1435 15763 112200</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-L选项打印出文件中最长一行的长度：</span></span><br><span class="line">$ wc file -L</span><br><span class="line">205</span><br></pre></td></tr></table></figure><h3 id="2-6-临时文件命名与随机数"><a href="#2-6-临时文件命名与随机数" class="headerlink" title="2.6 临时文件命名与随机数"></a>2.6 临时文件命名与随机数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建临时文件：</span></span><br><span class="line">$ filename=`mktemp`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$filename</span></span><br><span class="line">/tmp/tmp.8xvhkjF5fH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时目录：</span></span><br><span class="line">$ dirname=`mktemp -d`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$dirname</span></span><br><span class="line">tmp.NI8xzW7VRX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果仅仅是想生成文件名，又不希望创建实际的文件或目录，方法如下：</span></span><br><span class="line">$ tmpfile=`mktemp -u`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$tmpfile</span></span><br><span class="line">/tmp/tmp.RsGmilRpcT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模板创建临时文件名：</span></span><br><span class="line"><span class="variable">$mktemp</span> test.XXX</span><br><span class="line">test.2tc</span><br></pre></td></tr></table></figure><p>如果提供了定制模板， X会被随机的字符（字母或数字）替换。注意， mktemp正常工作的前提是保证模板中只少要有3个X。 </p><h3 id="2-7-split-分割文件和数据"><a href="#2-7-split-分割文件和数据" class="headerlink" title="2.7 split 分割文件和数据"></a>2.7 split 分割文件和数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件分割成多个大小为10KB的文件</span></span><br><span class="line">$ split -b 10k data.file</span><br><span class="line">$ ls</span><br><span class="line">data.file xaa xab xac xad xae xaf xag xah xai xaj</span><br></pre></td></tr></table></figure><p>上面的命令将data.file分割成多个文件，每一个文件大小为10KB。这些文件以xab、 xac、 xad的形式命名。这表明它们都有一个字母后缀。如果想以数字为后缀，可以另外使用-d参数。此外，使用 -a length可以指定后缀长度： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 10k data.file -d -a 4</span><br><span class="line">$ ls</span><br><span class="line">data.file x0009 x0019 x0029 x0039 x0049 x0059 x0069 x0079</span><br></pre></td></tr></table></figure><p>除了k（KB）后缀，我们还可以使用M（MB）、 G（GB）、 c（byte）、 w（word）等后缀。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为分割后的文件指定文件名前缀 </span></span><br><span class="line">$ split -b 10k data.file -d -a 4 split_file</span><br><span class="line">$ ls</span><br><span class="line">data.file   split_file0002 split_file0005 split_file0008 strtok.c</span><br><span class="line">split_file0000 split_file0003 split_file0006 split_file0009</span><br><span class="line">split_file0001 split_file0004 split_file0007</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想按照数据块大小，而是需要根据行数来分割文件的话，可以使用 -l no_of_lines：</span></span><br><span class="line">$ split -l 10 data.file</span><br><span class="line"><span class="comment"># 分割成多个文件，每个文件包含10行</span></span><br></pre></td></tr></table></figure><p>csplit。它能够依据指定的条件和字符串匹配选项对日志文件进行分割。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat server.log</span><br><span class="line">SERVER-1</span><br><span class="line">[connection] 192.168.0.1 success</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 success</span><br><span class="line">SERVER-2</span><br><span class="line">[connection] 192.168.0.1 failed</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 success</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line">SERVER-3</span><br><span class="line">[connection] 192.168.0.1 pending</span><br><span class="line">[connection] 192.168.0.2 pending</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line">$ csplit server.log /SERVER/ -n 2 -s &#123;*&#125; -f server -b <span class="string">"%02d.log"</span> ; rm server00.log</span><br><span class="line">$ ls</span><br><span class="line">server01.log server02.log server03.log server.log</span><br></pre></td></tr></table></figure><p>有关这个命令的详细说明如下。 </p><ul><li>/SERVER/ 用来匹配某一行，分割过程即从此处开始。 </li><li>/[REGEX]/ 表示文本样式。包括从当前行（第一行）直到（但不包括）包含“SERVER”的匹配行。 </li><li>{*} 表示根据匹配重复执行分割，直到文件末尾为止。可以用{整数}的形式来指定分割执行的次数。 </li><li>-s 使命令进入静默模式，不打印其他信息。 </li><li>-n 指定分割后的文件名后缀的数字个数，例如01、 02、 03等。 </li><li>-f 指定分割后的文件名前缀（在上面的例子中， server就是前缀）。 </li><li>-b 指定后缀格式。例如%02d.log，类似于C语言中printf的参数格式。在这里文件名=前缀+后缀=server + %02d.log。 </li></ul><p>因为分割后的第一个文件没有任何内容（匹配的单词就位于文件的第一行中），所以我们删除了server00.log。 </p><h4 id="2-7-1-根据扩展名切分文件名-、"><a href="#2-7-1-根据扩展名切分文件名-、" class="headerlink" title="2.7.1 根据扩展名切分文件名$、"></a>2.7.1 根据扩展名切分文件名$、</h4><p>借助 <code>%</code> 操作符可以轻松将名称部分从 “名称.扩展名” 这种格式中提取出来。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">name=$&#123;file_jpg%.*&#125;</span><br><span class="line">echo File name is: $name</span><br><span class="line">输出结果：</span><br><span class="line">File name is: sample</span><br></pre></td></tr></table></figure><p>将文件名的扩展名部分提取出来，这可以借助 # 操作符实现。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension=$&#123;file_jpg#*.&#125;</span><br><span class="line">echo Extension is: jpg</span><br><span class="line">输出结果：</span><br><span class="line">Extension is: jpg</span><br></pre></td></tr></table></figure><p><code>${VAR%.*}</code>  的含义如下所述： </p><ul><li>从 $VAR中删除位于 % 右侧的通配符（在前例中是.*）所匹配的字符串。通配符从右向左进行匹配。 </li><li>给VAR赋值， VAR=sample.jpg。那么，通配符从右向左就会匹配到.jpg，因此，从 $VAR中删除匹配结果，就会得到输出sample。 </li></ul><p>%属于非贪婪（non-greedy）操作。它从右到左找出匹配通配符的最短结果。还有另一个操作符 %%，这个操作符与%相似，但行为模式却是贪婪的，这意味着它会匹配符合条件的最长的字符串。 </p><p>操作符%%则用.*从右向左执行贪婪匹配（.fun.book.txt）。 </p><p><code>${VAR#*.}</code> 的含义如下所述：<br>从$VAR中删除位于#右侧的通配符（即在前例中使用的*.）所匹配的字符串。通配<br>符从左向右进行匹配。<br>和 %% 类似， #也有一个相对应的贪婪操作符 ##。</p><p><code>##</code>从左向右进行贪婪匹配，并从指定变量中删除匹配结果。</p><p>这里有个能够提取域名不同部分的实用案例。假定 <code>URL=&quot;www.google.com&quot;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL%.*&#125;</span> <span class="comment"># 移除.*所匹配的最右边的内容</span></span><br><span class="line">www.google</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL%%.*&#125;</span> <span class="comment"># 将从右边开始一直匹配到最左边的*.移除（贪婪操作符）</span></span><br><span class="line">www</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL#*.&#125;</span> <span class="comment"># 移除*.所匹配的最左边的内容</span></span><br><span class="line">google.com</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;URL##*.&#125;</span> <span class="comment"># 将从左边开始一直匹配到最右边的*.移除（贪婪操作符）</span></span><br><span class="line">com</span><br></pre></td></tr></table></figure><h3 id="2-8-批量重命名和移动"><a href="#2-8-批量重命名和移动" class="headerlink" title="2.8 批量重命名和移动"></a>2.8 批量重命名和移动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 *.JPG更名为 *.jpg：</span></span><br><span class="line">$ rename *.JPG *.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件名中的空格替换成字符“_”：</span></span><br><span class="line">$ rename <span class="string">'s/ /_/g'</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换文件名的大小写：</span></span><br><span class="line">$ rename <span class="string">'y/A-Z/a-z/'</span> *</span><br><span class="line">$ rename <span class="string">'y/a-z/A-Z/'</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的 .mp3文件移入给定的目录：</span></span><br><span class="line">$ find path -<span class="built_in">type</span> f -name <span class="string">"*.mp3"</span> -<span class="built_in">exec</span> mv &#123;&#125; target_dir \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有文件名中的空格替换为字符“_”：</span></span><br><span class="line">$ find path -<span class="built_in">type</span> f -<span class="built_in">exec</span> rename <span class="string">'s/ /_/g'</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="3-以文件之名"><a href="#3-以文件之名" class="headerlink" title="3 以文件之名"></a>3 以文件之名</h2><h3 id="3-1-生成任意大小的文件"><a href="#3-1-生成任意大小的文件" class="headerlink" title="3.1 生成任意大小的文件"></a>3.1 生成任意大小的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=junk.data bs=1M count=1</span><br></pre></td></tr></table></figure><p>该命令会创建一个1MB大小的文件junk.data。来看一下命令参数： if代表输入文件（input file），of代表输出文件（output file）， bs代表以字节为单位的块大小（block size）， count代表需要被复制的块数。</p><p>使用dd命令时一定得留意，该命令运行在设备底层。要是你不小心出了岔子，搞不好会把磁盘清空或是损坏数据。所以一定要反复检查dd命令所用的语法是否正确，尤其是参数of=。 </p><table><thead><tr><th>单元大小</th><th>代码</th></tr></thead><tbody><tr><td>字节（1B）</td><td>c</td></tr><tr><td>字（2B）</td><td>w</td></tr><tr><td>块（512B）</td><td>b</td></tr><tr><td>千字节（1024B）</td><td>k</td></tr><tr><td>兆字节（1024KB）</td><td>M</td></tr><tr><td>吉字节（1024MB）</td><td>G</td></tr></tbody></table><p><code>ls -lS</code> 对当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息。  </p><h3 id="3-2-文件权限、所有权和粘滞位"><a href="#3-2-文件权限、所有权和粘滞位" class="headerlink" title="3.2 文件权限、所有权和粘滞位"></a>3.2 文件权限、所有权和粘滞位</h3><p>用命令ls -l可以列出文件的权限： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 slynux slynux 2497 2010-02-28 11:22 bot.py</span><br><span class="line">drwxr-xr-x 2 slynux slynux 4096 2010-05-27 14:31 a.py</span><br><span class="line">-rw-r--r-- 1 slynux slynux 539 2010-02-10 09:11 cl.pl</span><br></pre></td></tr></table></figure><ul><li><code>-</code>—— 普通文件。 </li><li>d —— 目录。 </li><li>c —— 字符设备。 </li><li>b —— 块设备。 </li><li>l —— 符号链接。 </li><li>s —— 套接字。 </li><li>p —— 管道。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改所有权</span></span><br><span class="line">$ chown user.group filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置粘滞位</span></span><br><span class="line"><span class="comment"># 要设置粘滞位，利用chmod将 +t应用于目录：</span></span><br><span class="line">$ chmod a+t directory_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以递归的方式设置权限</span></span><br><span class="line">$ chmod 777 . -R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以递归的方式设置所有权</span></span><br><span class="line">$ chown user.group . -R</span><br></pre></td></tr></table></figure><h3 id="3-3-创建不可修改的文件"><a href="#3-3-创建不可修改的文件" class="headerlink" title="3.3 创建不可修改的文件"></a>3.3 创建不可修改的文件</h3><p>chattr能够将文件设置为不可修改。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用下列命令将一个文件设置为不可修改：</span></span><br><span class="line">$ chattr +i file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要使文件恢复可写状态，移除不可修改属性即可：</span></span><br><span class="line">$ chattr -i file</span><br></pre></td></tr></table></figure><h3 id="3-4-查找符号链接及其指向目标"><a href="#3-4-查找符号链接及其指向目标" class="headerlink" title="3.4 查找符号链接及其指向目标"></a>3.4 查找符号链接及其指向目标</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符号链接：</span></span><br><span class="line">$ ln -s target symbolic_link_name</span><br><span class="line">例如：</span><br><span class="line">$ ln -l -s /var/www/ ~/web</span><br><span class="line"><span class="comment">#这个命令在已登录用户的home目录中创建了一个名为Web的符号链接。该链接指向/var/www。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的命令来验证是否创建链接：</span></span><br><span class="line">$ ls -l web</span><br><span class="line">lrwxrwxrwx 1 slynux slynux 8 2010-06-25 21:34 web -&gt; /var/www</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出当前目录下的符号链接：</span></span><br><span class="line">$ ls -l | grep <span class="string">"^l"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用find打印当前目录以及子目录下的符号链接：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> l -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用readlink打印出符号链接所指向的目标路径：</span></span><br><span class="line">$ readlink web</span><br><span class="line">/var/www</span><br></pre></td></tr></table></figure><h3 id="3-5-列举文件类型统计信息"><a href="#3-5-列举文件类型统计信息" class="headerlink" title="3.5 列举文件类型统计信息"></a>3.5 列举文件类型统计信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用下面的命令打印文件类型信息：</span></span><br><span class="line">$ file filename</span><br><span class="line">$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印不包括文件名在内的文件类型信息：</span></span><br><span class="line">$ file -b filename</span><br><span class="line">ASCII text</span><br></pre></td></tr></table></figure><h3 id="3-6-使用环回文件"><a href="#3-6-使用环回文件" class="headerlink" title="3.6 使用环回文件"></a>3.6 使用环回文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令可以创建一个1GB大小的文件：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=loobackfile.img bs=1G count=1</span><br><span class="line">1024+0 records <span class="keyword">in</span></span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 37.3155 s, 28.8 MB/s</span><br><span class="line"><span class="comment"># 你会发现创建好的文件大小超过了1GB。这是因为硬盘作为块设备，其分配存储空间时是按照块大小的整数倍来进行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用mkfs命令将1GB的文件格式化成ext4文件系统：</span></span><br><span class="line">$ mkfs.ext4 loopbackfile.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的命令检查文件系统：</span></span><br><span class="line">$ file loobackfile.img</span><br><span class="line">loobackfile.img: Linux rev 1.0 ext4 filesystem data,</span><br><span class="line">UUID=c9d56c42-f8e6-4cbd-aeab-369d5056660a (extents) (large files) (huge files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在就可以挂载环回文件了：</span></span><br><span class="line">$ mkdir /mnt/loopback</span><br><span class="line">$ mount -o loop loopbackfile.img /mnt/loopback</span><br><span class="line"><span class="comment"># -o loop用来挂载环回文件系统。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以手动来操作：</span></span><br><span class="line">$ losetup /dev/loop1 loopbackfile.img</span><br><span class="line">$ mount /dev/loop1 /mnt/loopback</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下面的方法进行卸载（umount）：</span></span><br><span class="line">$ umount mount_point</span><br></pre></td></tr></table></figure><h3 id="3-7-生成-ISO-文件及混合型-ISO"><a href="#3-7-生成-ISO-文件及混合型-ISO" class="headerlink" title="3.7 生成 ISO 文件及混合型 ISO"></a>3.7 生成 ISO 文件及混合型 ISO</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用下面的命令从/dev/cdrom创建一个ISO镜像：</span></span><br><span class="line">$ cat /dev/cdrom &gt; image.iso</span><br><span class="line"></span><br><span class="line"><span class="comment">#尽管可以奏效。但创建ISO镜像最好的方法还是使用dd工具：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/cdrom of=image.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># mkisofs命令用于创建ISO文件系统。</span></span><br><span class="line">$ mkisofs -V <span class="string">"Label"</span> -o image.iso source_dir/</span><br><span class="line"><span class="comment"># 选项 -o指定了ISO文件的路径。 source_dir是作为ISO文件内容来源的目录路径，选项 -V指定了ISO文件的卷标。</span></span><br></pre></td></tr></table></figure><h3 id="3-8-diff命令"><a href="#3-8-diff命令" class="headerlink" title="3.8 diff命令"></a>3.8 diff命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- 　<span class="comment"># 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。</span></span><br><span class="line">-a或--text 　<span class="comment"># diff预设只会逐行比较文本文件。</span></span><br><span class="line">-b或--ignore-space-change 　<span class="comment"># 不检查空格字符的不同。</span></span><br><span class="line">-B或--ignore-blank-lines 　 <span class="comment"># 不检查空白行。</span></span><br><span class="line">-c 　<span class="comment"># 显示全部内文，并标出不同之处。</span></span><br><span class="line">-C或--context <span class="comment"># 与执行"-c-"指令相同。</span></span><br><span class="line">-d或--minimal <span class="comment"># 使用不同的演算法，以较小的单位来做比较。</span></span><br><span class="line">-D或ifdef<span class="comment"># 此参数的输出格式可用于前置处理器巨集。</span></span><br><span class="line">-e或--ed<span class="comment"># 此参数的输出格式可用于ed的script文件。</span></span><br><span class="line">-f或-forward-ed<span class="comment"># 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span></span><br><span class="line">-H或--speed-large-files 　<span class="comment"># 比较大文件时，可加快速度。</span></span><br><span class="line">-l或--ignore-matching-lines 　<span class="comment"># 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</span></span><br><span class="line">-i或--ignore-case 　<span class="comment"># 不检查大小写的不同。</span></span><br><span class="line">-l或--paginate   <span class="comment"># 将结果交由pr程序来分页。</span></span><br><span class="line">-n或--rcs 　  <span class="comment"># 将比较结果以RCS的格式来显示。</span></span><br><span class="line">-N或--new-file 　  <span class="comment"># 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span></span><br><span class="line">-p 　  <span class="comment"># 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span></span><br><span class="line">-P或--unidirectional-new-file 　<span class="comment"># 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span></span><br><span class="line">-q或--brief 　<span class="comment"># 仅显示有无差异，不显示详细的信息。</span></span><br><span class="line">-r或--recursive 　<span class="comment"># 比较子目录中的文件。</span></span><br><span class="line">-s或--report-identical-files 　<span class="comment"># 若没有发现任何差异，仍然显示信息。</span></span><br><span class="line">-S或--starting-file 　<span class="comment"># 在比较目录时，从指定的文件开始比较。</span></span><br><span class="line">-t或--expand-tabs 　<span class="comment"># 在输出时，将tab字符展开。</span></span><br><span class="line">-T或--initial-tab 　<span class="comment"># 在每行前面加上tab字符以便对齐。</span></span><br><span class="line">-u,-U或--unified= 　<span class="comment"># 以合并的方式来显示文件内容的不同。</span></span><br><span class="line">-v或--version 　<span class="comment"># 显示版本信息。</span></span><br><span class="line">-w或--ignore-all-space 　<span class="comment"># 忽略全部的空格字符。</span></span><br><span class="line">-W或--width 　<span class="comment"># 在使用-y参数时，指定栏宽。</span></span><br><span class="line">-x或--exclude 　<span class="comment"># 不比较选项中所指定的文件或目录。</span></span><br><span class="line">-X或--exclude-from 　 <span class="comment"># 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件。</span></span><br><span class="line">-y或--side-by-side 　 <span class="comment"># 以并列的方式显示文件的异同之处。</span></span><br><span class="line">--<span class="built_in">help</span> 　 <span class="comment"># 显示帮助。</span></span><br><span class="line">--left-column 　<span class="comment"># 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</span></span><br><span class="line">--suppress-common-lines 　<span class="comment"># 在使用-y参数时，仅显示不同之处。</span></span><br></pre></td></tr></table></figure><p>生成目录的差异信息 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diff -Naur directory1 directory2</span><br></pre></td></tr></table></figure><ul><li>-N：将所有缺失的文件视为空文件。 </li><li>-a：将所有文件视为文本文件。 </li><li>-u：生成一体化输出。 </li><li>-r：遍历目录下的所有文件。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成patch文件</span></span><br><span class="line">$ diff -u version1.txt version2.txt &gt; version.patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下列命令来进行修补：</span></span><br><span class="line">$ patch -p1 version1.txt &lt; version.patch</span><br><span class="line">patching file version1.txt</span><br><span class="line"><span class="comment"># version1.txt的内容现在和verson2.txt的内容一模一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令可以撤销做出的修改：</span></span><br><span class="line">$ patch -p1 version1.txt &lt; version.patch</span><br><span class="line">patching file version1.txt</span><br><span class="line">Reversed (or previously applied) patch detected! Assume -R? [n] y</span><br><span class="line"><span class="comment"># 修改被撤销</span></span><br></pre></td></tr></table></figure><h3 id="3-9-more、less、head与tail命令"><a href="#3-9-more、less、head与tail命令" class="headerlink" title="3.9 more、less、head与tail命令"></a>3.9 more、less、head与tail命令</h3><h4 id="3-9-1-more文件内容输出查看工具"><a href="#3-9-1-more文件内容输出查看工具" class="headerlink" title="3.9.1 more文件内容输出查看工具"></a>3.9.1 more文件内容输出查看工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ more [参数选项] [文件] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数如下： </span></span><br><span class="line">+num   <span class="comment"># 从第num行开始显示； </span></span><br><span class="line">-num   <span class="comment"># 定义屏幕大小，为num行； </span></span><br><span class="line">+/pattern   <span class="comment"># 从pattern 前两行开始显示； </span></span><br><span class="line">-c   <span class="comment"># 从顶部清屏然后显示； </span></span><br><span class="line">-d   <span class="comment"># 提示Press space to continue, 'q' to quit.（按空格键继续，按q键退出），禁用响铃功能； </span></span><br><span class="line">-l    <span class="comment"># 忽略Ctrl+l （换页）字符； </span></span><br><span class="line">-p    <span class="comment"># 通过清除窗口而不是滚屏来对文件进行换页。和-c参数有点相似； </span></span><br><span class="line">-s    <span class="comment"># 把连续的多个空行显示为一行； </span></span><br><span class="line">-u    <span class="comment"># 把文件内容中的下划线去掉退出more的动作指令是q</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示提示，并从终端或控制台顶部显示；</span></span><br><span class="line">$ more -dc /etc/profile </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从profile的第4行开始显示；</span></span><br><span class="line">$ more +4 /etc/profile     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每屏显示4行；</span></span><br><span class="line">$ more -4 /etc/profile    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从profile中的第一个MAIL单词的前两行开始显示；</span></span><br><span class="line">$ more +/MAIL /etc/profile</span><br></pre></td></tr></table></figure><p>more 的动作指令：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter       # 向下n行，需要定义，默认为<span class="number">1</span>行； </span><br><span class="line">Ctrl+f    # 向下滚动一屏； </span><br><span class="line">空格键 # 向下滚动一屏； </span><br><span class="line">Ctrl+b  # 返回上一屏； </span><br><span class="line">=         # 输出当前行的行号； </span><br><span class="line">:f      # 输出文件名和当前行的行号； </span><br><span class="line">v      # 调用vi编辑器； </span><br><span class="line">! 命令          # 调用Shell，并执行命令； </span><br><span class="line">q     # 退出more当我们查看某一文件时，想调用vi来编辑它，不要忘记了v动作指令，这是比较方便的；</span><br></pre></td></tr></table></figure><p>其它命令通过管道和more结合的运用例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /etc |more</span><br></pre></td></tr></table></figure><h4 id="3-9-2-less查看文件内容工具"><a href="#3-9-2-less查看文件内容工具" class="headerlink" title="3.9.2 less查看文件内容工具"></a>3.9.2 less查看文件内容工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-c <span class="comment"># 从顶部（从上到下）刷新屏幕，并显示文件内容。而不是通过底部滚动完成刷新； </span></span><br><span class="line">-f <span class="comment"># 强制打开文件，二进制文件显示时，不提示警告； </span></span><br><span class="line">-i <span class="comment"># 搜索时忽略大小写；除非搜索串中包含大写字母； </span></span><br><span class="line">-I <span class="comment"># 搜索时忽略大小写，除非搜索串中包含小写字母； </span></span><br><span class="line">-m <span class="comment"># 显示读取文件的百分比； </span></span><br><span class="line">-M <span class="comment"># 显法读取文件的百分比、行号及总行数； </span></span><br><span class="line">-N <span class="comment"># 在每行前输出行号； </span></span><br><span class="line">-p <span class="comment"># pattern 搜索pattern；比如在/etc/profile搜索单词MAIL，就用 less -p MAIL /etc/profile </span></span><br><span class="line">-s <span class="comment"># 把连续多个空白行作为一个空白行显示； </span></span><br><span class="line">-Q <span class="comment"># 在终端下不响铃；</span></span><br></pre></td></tr></table></figure><p>less的动作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">回车键 <span class="comment"># 向下移动一行； </span></span><br><span class="line">y   <span class="comment"># 向上移动一行； </span></span><br><span class="line">空格键 <span class="comment"># 向下滚动一屏； </span></span><br><span class="line">b   <span class="comment"># 向上滚动一屏； </span></span><br><span class="line">d   <span class="comment"># 向下滚动半屏； </span></span><br><span class="line">h   <span class="comment"># less的帮助； </span></span><br><span class="line">u   <span class="comment"># 向上洋动半屏； </span></span><br><span class="line">w   <span class="comment"># 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示； </span></span><br><span class="line">g   <span class="comment"># 跳到第一行； </span></span><br><span class="line">G   <span class="comment"># 跳到最后一行； </span></span><br><span class="line">p   <span class="comment"># n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示； </span></span><br><span class="line">/pattern  <span class="comment"># 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词； </span></span><br><span class="line">v   <span class="comment"># 调用vi编辑器； </span></span><br><span class="line">q   <span class="comment"># 退出less </span></span><br><span class="line">!<span class="built_in">command</span>  <span class="comment"># 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件；</span></span><br></pre></td></tr></table></figure><h4 id="3-9-3-head"><a href="#3-9-3-head" class="headerlink" title="3.9.3 head"></a>3.9.3 head</h4><p>head 是显示一个文件的内容的前多少行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ head -n 10 /etc/profile</span><br></pre></td></tr></table></figure><h4 id="3-9-4-tail"><a href="#3-9-4-tail" class="headerlink" title="3.9.4 tail"></a>3.9.4 tail</h4><p>tail 是显示一个文件的内容的最后多少行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -n 5 /etc/profile</span><br></pre></td></tr></table></figure><h3 id="3-10-getopts-参数解析"><a href="#3-10-getopts-参数解析" class="headerlink" title="3.10 getopts 参数解析"></a>3.10 getopts 参数解析</h3><h4 id="3-10-1-getopts（shell内置命令）"><a href="#3-10-1-getopts（shell内置命令）" class="headerlink" title="3.10.1 getopts（shell内置命令）"></a>3.10.1 getopts（shell内置命令）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> getopt</span><br><span class="line">getopt 是 /usr/bin/getopt</span><br><span class="line">$ <span class="built_in">type</span> <span class="built_in">getopts</span> </span><br><span class="line"><span class="built_in">getopts</span> 是 shell 内建</span><br></pre></td></tr></table></figure><p>getopts不能直接处理长的选项（如：–prefix=/home等）</p><p>关于getopts的使用方法，可以man bash  搜索getopts。</p><p>getopts有两个参数，第一个参数是一个字符串，包括字符和“：”，每一个字符都是一个有效的选项，如果字符后面带有“：”，表示这个字符有自己的参数。getopts从命令中获取这些参数，并且删去了“-”，并将其赋值在第二个参数中，如果带有自己参数，这个参数赋值在 <code>$OPTARG</code>中。提供getopts的shell内置了 <code>$OPTARG</code> 这个变变，getopts修改了这个变量。</p><p>这里变量 <code>$OPTARG</code> 存储相应选项的参数，而 <code>$OPTIND</code> 总是存储原始 <code>$*</code> 中下一个要处理的元素位置。<code>while getopts &quot;:a:bc&quot; opt</code>   #第一个冒号表示忽略错误；字符后面的冒号表示该选项必须有自己的参数</p><p>getopts后面的字符串就是可以使用的选项列表，每个字母代表一个选项，后面带:的意味着选项除了定义本身之外，还会带上一个参数作为选项的值，比如d:在实际的使用中就会对应-d 30，选项的值就是30；getopts字符串中没有跟随:的是开关型选项，不需要再指定值，相当于true/false，只要带了这个参数就是true。如果命令行中包含了没有在getopts列表中的选项，会有警告信息，如果在整个getopts字符串前面也加上个:，就能消除警告信息了。</p><p>两个特殊变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$OPTIND</span>     <span class="comment"># 特殊变量，option index，会逐个递增, 初始值为1</span></span><br><span class="line"><span class="variable">$OPTARG</span>     <span class="comment"># 特殊变量，option argument，不同情况下有不同的值</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">echo $*</span><br><span class="line"><span class="keyword">while</span> getopts <span class="string">":a:bc"</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> $opt <span class="keyword">in</span></span><br><span class="line">                a ) echo $OPTARG</span><br><span class="line">                    echo $OPTIND;;</span><br><span class="line">                b ) echo <span class="string">"b $OPTIND"</span>;;</span><br><span class="line">                c ) echo <span class="string">"c $OPTIND"</span>;;</span><br><span class="line">                ? ) echo <span class="string">"error"</span></span><br><span class="line">                    exit <span class="number">1</span>;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo $OPTIND</span><br><span class="line">shift $(($OPTIND - <span class="number">1</span>))</span><br><span class="line">#通过shift $(($OPTIND - <span class="number">1</span>))的处理，$*中就只保留了除去选项内容的参数，可以在其后进行正常的shell编程处理了。</span><br><span class="line">echo $<span class="number">0</span></span><br><span class="line">echo $*</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./getopts.sh -a 11 -b -c</span><br><span class="line">-a 11 -b -c</span><br><span class="line">11</span><br><span class="line">3</span><br><span class="line">b 4</span><br><span class="line">c 5</span><br><span class="line">5</span><br><span class="line">./getopts.sh</span><br></pre></td></tr></table></figure><h4 id="3-10-2-getopt（一个外部工具）"><a href="#3-10-2-getopt（一个外部工具）" class="headerlink" title="3.10.2 getopt（一个外部工具）"></a>3.10.2 getopt（一个外部工具）</h4><p>具体用用法可以 man getopt</p><p><code>-o</code> 表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，如 <code>-carg</code> 而不能是 <code>-c arg</code>。</p><p><code>--long</code> 表示长选项</p><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"></span><br><span class="line"># A small example program <span class="keyword">for</span> using the <span class="keyword">new</span> getopt(<span class="number">1</span>) program.</span><br><span class="line"># This program will only work <span class="keyword">with</span> bash(<span class="number">1</span>)</span><br><span class="line"># An similar program using the tcsh(<span class="number">1</span>) script. language can be found</span><br><span class="line"># <span class="keyword">as</span> parse.tcsh</span><br><span class="line"></span><br><span class="line"># Example input and output (<span class="keyword">from</span> the bash prompt):</span><br><span class="line"># ./parse.bash -a par1 <span class="string">'another arg'</span> --c-long <span class="string">'wow!*\?'</span> -cmore -b <span class="string">" very long "</span></span><br><span class="line"># Option a</span><br><span class="line"># Option c, no argument</span><br><span class="line"># Option c, argument <span class="string">`more'</span></span><br><span class="line"><span class="string"># Option b, argument `</span> very long <span class="string">'</span></span><br><span class="line"><span class="string"># Remaining arguments:</span></span><br><span class="line"><span class="string"># --&gt; `par1'</span></span><br><span class="line"># --&gt; <span class="string">`another arg'</span></span><br><span class="line"><span class="string"># --&gt; `</span>wow!*\?<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note that we use `"$@"'</span> to <span class="keyword">let</span> each command-line parameter expand to a</span><br><span class="line"># separate word. The quotes around <span class="string">`$@' are essential!</span></span><br><span class="line"><span class="string"># We need TEMP as the `</span><span class="built_in">eval</span> <span class="keyword">set</span> --<span class="string">' would nuke the return value of getopt.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项</span></span><br><span class="line"><span class="string">#如-carg 而不能是-c arg</span></span><br><span class="line"><span class="string">#--long表示长选项</span></span><br><span class="line"><span class="string">#"$@"在上面解释过</span></span><br><span class="line"><span class="string"># -n:出错时的信息</span></span><br><span class="line"><span class="string"># -- ：举一个例子比较好理解：</span></span><br><span class="line"><span class="string">#我们要创建一个名字为 "-f"的目录你会怎么办？</span></span><br><span class="line"><span class="string"># mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用</span></span><br><span class="line"><span class="string"># mkdir -- -f 这样-f就不会被作为选项。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \</span></span><br><span class="line"><span class="string">     -n '</span>example.bash<span class="string">' -- "$@"`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if [ $? != 0 ] ; then echo "Terminating..." &gt;&amp;2 ; exit 1 ; fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note the quotes around `$TEMP'</span>: they are essential!</span><br><span class="line">#<span class="keyword">set</span> 会重新排列参数的顺序，也就是改变$<span class="number">1</span>,$<span class="number">2.</span>..$n的值，这些值在getopt中重新排列过了</span><br><span class="line"><span class="built_in">eval</span> <span class="keyword">set</span> -- <span class="string">"$TEMP"</span></span><br><span class="line"></span><br><span class="line">#经过getopt的处理，下面处理具体选项。</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"$1"</span> <span class="keyword">in</span></span><br><span class="line">                -a|--a-long) echo <span class="string">"Option a"</span> ; shift ;;</span><br><span class="line">                -b|--b-long) echo <span class="string">"Option b, argument \`$2'"</span> ; shift <span class="number">2</span> ;;</span><br><span class="line">                -c|--c-long)</span><br><span class="line">                        # c has an optional argument. As we are <span class="keyword">in</span> quoted mode,</span><br><span class="line">                        # an empty parameter will be generated <span class="keyword">if</span> its optional</span><br><span class="line">                        # argument is not found.</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"$2"</span> <span class="keyword">in</span></span><br><span class="line">                                <span class="string">""</span>) echo <span class="string">"Option c, no argument"</span>; shift <span class="number">2</span> ;;</span><br><span class="line">                                *)  echo <span class="string">"Option c, argument \`$2'"</span> ; shift <span class="number">2</span> ;;</span><br><span class="line">                        esac ;;</span><br><span class="line">                --) shift ; <span class="keyword">break</span> ;;</span><br><span class="line">                *) echo <span class="string">"Internal error!"</span> ; exit <span class="number">1</span> ;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo <span class="string">"Remaining arguments:"</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">do</span></span><br><span class="line">   echo <span class="string">'--&gt; '</span><span class="string">"\`$arg'"</span> ;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./getopt.sh --b-long abc -a -c33 remain</span><br><span class="line">Option b, argument `abc<span class="string">'</span></span><br><span class="line"><span class="string">Option a</span></span><br><span class="line"><span class="string">Option c, argument `33'</span></span><br><span class="line">Remaining arguments:</span><br><span class="line">--&gt; `remain<span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="3-11-只列出目录的各种方法"><a href="#3-11-只列出目录的各种方法" class="headerlink" title="3.11 只列出目录的各种方法"></a>3.11 只列出目录的各种方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ls –d：</span></span><br><span class="line">$ ls -d */</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用grep结合ls –F：</span></span><br><span class="line">$ ls -F | grep <span class="string">"/$"</span></span><br><span class="line"><span class="comment"># 当使用-F时，所有的输出项都会添加上一个代表文件类型的字符，如@、 *、 |等。目录对应的是 / 字符。我们用grep只过滤那些以 /$ 作为行尾标记的输出项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用grep结合ls –l：</span></span><br><span class="line">$ ls -l | grep <span class="string">"^d"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用find：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> d -maxdepth 1 -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><h3 id="3-12-使用pushd和popd进行快速定位"><a href="#3-12-使用pushd和popd进行快速定位" class="headerlink" title="3.12 使用pushd和popd进行快速定位"></a>3.12 使用pushd和popd进行快速定位</h3><p>使用pushd和popd时，可以无视cd命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压入并切换路径：</span></span><br><span class="line">$ <span class="built_in">pushd</span> /var/www</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再压入下一个目录路径：</span></span><br><span class="line">$ <span class="built_in">pushd</span> /usr/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的命令查看栈内容：</span></span><br><span class="line">$ <span class="built_in">dirs</span></span><br><span class="line">/usr/src /var/www ~ /usr/share /etc</span><br><span class="line">0 1   2 3 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当你想切换到列表中任意一个路径时，将每条路径从0到n进行编号，然后使用你希望切换到的路径编号，例如：</span></span><br><span class="line">$ <span class="built_in">pushd</span> +3</span><br><span class="line"><span class="comment"># 这条命令会将栈进行翻转并切换到目录 /use/share。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除最后添加的路径并把当前目录更改为上一级目录，可以使用以下命令：</span></span><br><span class="line">$ <span class="built_in">popd</span></span><br><span class="line"><span class="comment"># 用popd +num可以从列表中移除特定的路径。num是从左到右，从0到n开始计数的。</span></span><br></pre></td></tr></table></figure><h3 id="3-13-tree打印目录树"><a href="#3-13-tree打印目录树" class="headerlink" title="3.13 tree打印目录树"></a>3.13 tree打印目录树</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重点标记出匹配某种样式的文件：</span></span><br><span class="line">$ tree PATH -P <span class="string">"*.sh"</span> <span class="comment"># 用一个目录路径代替PATH</span></span><br><span class="line">|-- home</span><br><span class="line">| |-- packtpub</span><br><span class="line">| | `-- automate.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重点标记出除符合某种样式之外的那些文件：</span></span><br><span class="line">$ tree path -I PATTERN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -h选项同时打印出文件和目录的大小：</span></span><br><span class="line">$ tree -h</span><br></pre></td></tr></table></figure><h2 id="4-让文件飞"><a href="#4-让文件飞" class="headerlink" title="4 让文件飞"></a>4 让文件飞</h2><h3 id="4-1-正则表达式"><a href="#4-1-正则表达式" class="headerlink" title="4.1 正则表达式"></a>4.1 正则表达式</h3><table><thead><tr><th>正则表达式</th><th>描述</th><th align="left">示例</th></tr></thead><tbody><tr><td>^</td><td>行起始标记</td><td align="left">^tux 匹配以tux起始的行</td></tr><tr><td>$</td><td>行尾标记</td><td align="left">tux$ 匹配以tux结尾的行</td></tr><tr><td>.</td><td>匹配任意一个字符</td><td align="left">Hack.匹配Hackl和Hacki，它只能匹配单个字符</td></tr><tr><td>[ ]</td><td>匹配包含在 [字符] 之中的任意一个字符</td><td align="left">coo[kl] 匹配cook或cool</td></tr><tr><td>[ ^ ]</td><td>匹配除 <code>[^字符]</code> 之外的任意一个字符</td><td align="left"><code>9[^01]</code>匹配92、 93，但是不匹配91或90</td></tr><tr><td>[ - ]</td><td>匹配 [ ] 中指定范围内的任意一个字符</td><td align="left">[1-5] 匹配从1～5的任意一个数字</td></tr><tr><td>?</td><td>匹配之前的项1次或0次</td><td align="left">colou?r 匹配color或colour，但是不能匹配colouur</td></tr><tr><td>+</td><td>匹配之前的项1次或多次</td><td align="left">Rollno-9+ 匹配Rollno-99、Rollno-9，但是不能匹配Rollno-</td></tr><tr><td>*</td><td>匹配之前的项0次或多次</td><td align="left">co*l 匹配cl、 col、 coool等</td></tr><tr><td>( )</td><td>创建一个用于匹配的子串</td><td align="left">ma(tri)?x 匹配max或maxtrix</td></tr><tr><td>{n}</td><td>匹配之前的项n次</td><td align="left">[0-9]{3} 匹 配 任 意 一 个 三 位 数 ， [0-9]{3} 可 以 扩 展 为<code>[0-9][0-9][0-9]</code></td></tr><tr><td>{n, }</td><td>之前的项至少需要匹配n次</td><td align="left">[0-9]{2,} 匹配任意一个两位或更多位的数字</td></tr><tr><td>{n, m}</td><td>指定之前的项所必需匹配的最小次数和最大次数</td><td align="left">[0-9]{2,5} 匹配从两位数到五位数之间的任意一个数字</td></tr><tr><td>|</td><td>交替——匹配 | 两边的任意一项</td><td align="left">Oct  (1st | 2nd) 匹配Oct 1st或Oct 2nd</td></tr><tr><td>\</td><td>转义符可以将上面介绍的特殊字符进行转义</td><td align="left"><code>a\.b</code> 匹配a.b，但不能匹配ajb。通过在 . 之间加上前缀 \ ，从而忽略了 . 的特殊意义</td></tr></tbody></table><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>所有的字母和数字</td></tr><tr><td>[:alpha:]</td><td>所有字母</td></tr><tr><td>[:blank:]</td><td>水平制表符，空白等</td></tr><tr><td>[:cntrl:]</td><td>所有控制字符</td></tr><tr><td>[:digit:]</td><td>所有的数字</td></tr><tr><td><code>[:graph:]</code></td><td>所有可打印字符，不包括空格</td></tr><tr><td>[:lower:]</td><td>所有的小写字符</td></tr><tr><td>[:print:]</td><td>所有可打印字符，包括空格</td></tr><tr><td>[:punct:]</td><td>所有的标点字符</td></tr><tr><td>[:space:]</td><td>所有的横向或纵向的空白</td></tr><tr><td>[:upper:]</td><td>所有大写字母</td></tr></tbody></table><h3 id="4-2-grep命令"><a href="#4-2-grep命令" class="headerlink" title="4.2 grep命令"></a>4.2 grep命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-a<span class="comment"># 不要忽略二进制的数据。</span></span><br><span class="line">-A&lt;显示列数&gt;  <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之后的内容。</span></span><br><span class="line">-b<span class="comment"># 在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。</span></span><br><span class="line">-B&lt;显示列数&gt; <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前的内容。</span></span><br><span class="line">-c<span class="comment"># 计算符合范本样式的列数。</span></span><br><span class="line">-C&lt;显示列数&gt;或-&lt;显示列数&gt;<span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span></span><br><span class="line">-d&lt;进行动作&gt; <span class="comment"># 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</span></span><br><span class="line">-e&lt;范本样式&gt; <span class="comment"># 指定字符串做为查找文件内容的范本样式。</span></span><br><span class="line">-E<span class="comment"># 将范本样式为延伸的普通表示法来使用。</span></span><br><span class="line">-f&lt;范本文件&gt; <span class="comment"># 指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。</span></span><br><span class="line">-F<span class="comment"># 将范本样式视为固定字符串的列表。</span></span><br><span class="line">-G<span class="comment"># 将范本样式视为普通的表示法来使用。</span></span><br><span class="line">-h<span class="comment"># 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span></span><br><span class="line">-H<span class="comment"># 在显示符合范本样式的那一列之前，表示该列所属的文件名称。</span></span><br><span class="line">-i<span class="comment"># 忽略字符大小写的差别。</span></span><br><span class="line">-l<span class="comment"># 列出文件内容符合指定的范本样式的文件名称。</span></span><br><span class="line">-L<span class="comment"># 列出文件内容不符合指定的范本样式的文件名称。</span></span><br><span class="line">-n<span class="comment"># 在显示符合范本样式的那一列之前，标示出该列的列数编号。</span></span><br><span class="line">-q<span class="comment"># 不显示任何信息。</span></span><br><span class="line">-r<span class="comment"># 此参数的效果和指定“-d recurse”参数相同。</span></span><br><span class="line">-s<span class="comment"># 不显示错误信息。</span></span><br><span class="line">-v<span class="comment"># 反转查找。</span></span><br><span class="line">-V<span class="comment"># 显示版本信息。</span></span><br><span class="line">-w<span class="comment"># 只显示全字符合的列。</span></span><br><span class="line">-x<span class="comment"># 只显示全列符合的列。</span></span><br><span class="line">-o <span class="comment"># 只输出文件中匹配到的部分。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个grep命令也可以对多个文件进行搜索：</span></span><br><span class="line">$ grep <span class="string">"match_text"</span> file1 file2 file3 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># grep -E选项——这意味着使用扩展（extended）正则表达式：</span></span><br><span class="line">$ grep -E <span class="string">"[a-z]+"</span> filename</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ egrep <span class="string">"[a-z]+"</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只输出文件中匹配到的文本部分，可以使用选项 -o：</span></span><br><span class="line">$ <span class="built_in">echo</span> this is a line. | egrep -o <span class="string">"[a-z]+\."</span></span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印除包含match_pattern行之外的所有行，选项-v可以将匹配结果进行反转（invert）。可使用：</span></span><br><span class="line">$ grep -v match_pattern file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件或文本中包含匹配字符串的行数：</span></span><br><span class="line">$ grep -c <span class="string">"text"</span> filename</span><br><span class="line">10</span><br><span class="line"><span class="comment"># 需要注意的是-c只是统计匹配行的数量，并不是匹配的次数。。例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1 2 3 4\nhello\n5 6"</span> | egrep -c <span class="string">"[0-9]"</span></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要文件中统计匹配项的数量，可以使用下面的技巧：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"1 2 3 4\nhello\n5 6"</span> | egrep -o <span class="string">"[0-9]"</span> | wc -l</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模式匹配所位于的字符或字节偏移：</span></span><br><span class="line">$ <span class="built_in">echo</span> gnu is not unix | grep -b -o <span class="string">"not"</span></span><br><span class="line">7:not</span><br><span class="line"><span class="comment"># 选项 -b总是和 -o配合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索多个文件并找出匹配文本位于哪一个文件中：</span></span><br><span class="line">$ grep -l linux sample1.txt sample2.txt</span><br><span class="line">sample1.txt</span><br><span class="line">sample2.txt</span><br><span class="line"><span class="comment"># 和-l相反的选项是-L，它会返回一个不匹配的文件列表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep的选项-R和-r功能一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略样式中的大小写</span></span><br><span class="line">$ <span class="built_in">echo</span> hello world | grep -i <span class="string">"HELLO"</span></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># grep匹配多个样式</span></span><br><span class="line">$ <span class="built_in">echo</span> this is a line of text | grep -e <span class="string">"this"</span> -e <span class="string">"line"</span> -o</span><br><span class="line">this</span><br><span class="line">line</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在grep搜索中指定或排除文件</span></span><br><span class="line">$ grep <span class="string">"main()"</span> . -r --include *.&#123;c,cpp&#125; <span class="comment"># 目录中递归搜索所有的 .c和 .cpp文件</span></span><br><span class="line"><span class="comment"># 如果需要排除目录，可以使用 --exclude-dir选项。</span></span><br><span class="line"><span class="comment"># 如果需要从文件中读取所需排除的文件列表，使用--exclude-from FILE。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用0值字节作为后缀的grep与xargs，为了指明输入的文件名是以0值字节（\0）作为终止符，需要在xargs中使用-0。</span></span><br><span class="line"><span class="comment"># grep使用-Z选项输出以0值字节作为终结符的文件名（\0）。</span></span><br><span class="line">$ grep <span class="string">"test"</span> file* -lZ | xargs -0 rm</span><br><span class="line"><span class="comment"># -Z通常和 -l结合使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep的静默输出</span></span><br><span class="line"><span class="comment"># grep的静默选项（-q）来实现。在静默模式中， grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之后的3行，使用 -A选项：</span></span><br><span class="line">$ seq 10 | grep 5 -A 3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之前的3行，使用 -B选项：</span></span><br><span class="line">$ seq 10 | grep 5 -B 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要打印匹配某个结果之前以及之后的3行，使用-C选项：</span></span><br><span class="line">$ seq 10 | grep 5 -C 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有多个匹配，那么使用--作为各部分之间的定界符：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"a\nb\nc\na\nb\nc"</span> | grep a -A 1</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h3 id="4-3-cut-按列切分文件"><a href="#4-3-cut-按列切分文件" class="headerlink" title="4.3 cut 按列切分文件"></a>4.3 cut 按列切分文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示第2列和第3列：</span></span><br><span class="line">$ cut -f 2,3 filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>记法</th><th>范围</th></tr></thead><tbody><tr><td>N -</td><td>从第N个字节，字符或字段到行尾</td></tr><tr><td>N - M</td><td>从第N个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td></tr><tr><td>- M</td><td>第1个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td></tr></tbody></table><p>结合下列选项将字段指定为某个范围内的字节或字符 ：</p><ul><li>-b ：表示字节</li><li>-c ：表示字符</li><li>-f ：用于定义字段</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat range_fields.txt</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印第1个到第5个字符：</span></span><br><span class="line">$ cut -c1-5 range_fields.txt</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line"><span class="comment"># 打印前2个字符：</span></span><br><span class="line">$ cut range_fields.txt -c -2</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br></pre></td></tr></table></figure><h3 id="4-4-sed-进行文本替换"><a href="#4-4-sed-进行文本替换" class="headerlink" title="4.4 sed 进行文本替换"></a>4.4 sed 进行文本替换</h3><p>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-e &lt;script&gt;<span class="comment"># 以选项中指定的script来处理输入的文本文件</span></span><br><span class="line">-f &lt;script&gt;<span class="comment"># 以选项中指定的script文件来处理输入的文本文件</span></span><br><span class="line">-h<span class="comment"># 显示帮助</span></span><br><span class="line">-n<span class="comment"># 仅显示script处理后的结果</span></span><br><span class="line">-V<span class="comment"># 显示版本信息</span></span><br></pre></td></tr></table></figure><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a\ <span class="comment"># 在当前行下面插入文本。</span></span><br><span class="line">i\ <span class="comment"># 在当前行上面插入文本。</span></span><br><span class="line">c\ <span class="comment"># 把选定的行改为新的文本。 </span></span><br><span class="line">d <span class="comment"># 删除，删除选择的行。 </span></span><br><span class="line">D <span class="comment"># 删除模板块的第一行。</span></span><br><span class="line">s <span class="comment"># 替换指定字符 h 拷贝模板块的内容到内存中的缓冲区。 </span></span><br><span class="line">H <span class="comment"># 追加模板块的内容到内存中的缓冲区。 </span></span><br><span class="line">g <span class="comment"># 获得内存缓冲区的内容，并替代当前模板块中的文本。 </span></span><br><span class="line">G <span class="comment"># 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 </span></span><br><span class="line">l <span class="comment"># 列表不能打印字符的清单。 </span></span><br><span class="line">n <span class="comment"># 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 </span></span><br><span class="line">N <span class="comment"># 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 </span></span><br><span class="line">p <span class="comment"># 打印模板块的行。 P(大写) 打印模板块的第一行。 </span></span><br><span class="line">q <span class="comment"># 退出Sed。 </span></span><br><span class="line">b lable <span class="comment"># 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 </span></span><br><span class="line">r file <span class="comment"># 从file中读行。 </span></span><br><span class="line">t label <span class="comment"># if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 </span></span><br><span class="line">T label <span class="comment"># 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span></span><br><span class="line">w file <span class="comment"># 写并追加模板块到file末尾。 </span></span><br><span class="line">W file <span class="comment"># 写并追加模板块的第一行到file末尾。 </span></span><br><span class="line">! <span class="comment"># 表示后面的命令对所有没有被选定的行发生作用。 </span></span><br><span class="line">= <span class="comment"># 打印当前行号码。 </span></span><br><span class="line"><span class="comment"># 把注释扩展到下一个换行符以前。</span></span><br></pre></td></tr></table></figure><p>sed 替换标记：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g <span class="comment"># 表示行内全面替换。</span></span><br><span class="line">p <span class="comment"># 表示打印行。 </span></span><br><span class="line">w <span class="comment"># 表示把行写入一个文件。 </span></span><br><span class="line">x <span class="comment"># 表示互换模板块中的文本和缓冲区中的文本。 </span></span><br><span class="line">y <span class="comment"># 表示把一个字符翻译为另外的字符（但是不用于正则表达式） </span></span><br><span class="line">\1 <span class="comment"># 子串匹配标记 </span></span><br><span class="line">&amp; <span class="comment"># 已匹配字符串标记</span></span><br></pre></td></tr></table></figure><p>sed 元字符集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">^ <span class="comment"># 匹配行开始，如：/^sed/匹配所有以sed开头的行。</span></span><br><span class="line">$ <span class="comment"># 匹配行结束，如：/sed$/匹配所有以sed结尾的行。 </span></span><br><span class="line">. <span class="comment"># 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 </span></span><br><span class="line">* <span class="comment"># 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 </span></span><br><span class="line">[] <span class="comment"># 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 </span></span><br><span class="line">[^] <span class="comment"># 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/ 匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</span></span><br><span class="line">\(..\) <span class="comment"># 匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。 </span></span><br><span class="line">&amp; <span class="comment"># 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 </span></span><br><span class="line">\&lt;  <span class="comment"># 匹配单词的开始，如:/\&lt;love/匹配包含以开头的单词的行。</span></span><br><span class="line">\&gt;<span class="comment"># 匹配单词的结束，如:/love\&gt;/匹配包含以love结尾的单词的行。</span></span><br><span class="line">x\&#123;m\&#125; <span class="comment"># 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。 </span></span><br><span class="line">x\&#123;m,\&#125; <span class="comment"># 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。 </span></span><br><span class="line">x\&#123;m,n\&#125; <span class="comment"># 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed可以替换给定文本中的字符串。</span></span><br><span class="line">$ sed <span class="string">'s/pattern/replace_string/'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要在替换的同时保存更改，可以使用-i选项</span></span><br><span class="line">$ sed -i <span class="string">'s/text/replace/'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后缀/g意味着sed会替换每一处匹配。但是有时候我们只需要从第n处匹配开始替换。对此，可以使用/Ng选项。</span></span><br><span class="line">$ sed <span class="string">'s/pattern/replace_string/g'</span> file</span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/2g'</span></span><br><span class="line">thisTHISTHISTHIS</span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/3g'</span></span><br><span class="line">thisthisTHISTHIS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符/在sed中被作为定界符使用。我们可以像下面一样使用任意的定界符：</span></span><br><span class="line">$ sed <span class="string">'s:text:replace:g'</span></span><br><span class="line">$ sed <span class="string">'s|text|replace|g'</span></span><br><span class="line"><span class="comment"># 当定界符出现在样式内部时，我们必须用前缀\对它进行转义：</span></span><br><span class="line">$ sed <span class="string">'s|te\|xt|replace|g'</span></span><br><span class="line"><span class="comment"># \|是一个出现在样式内部并经过转义的定界符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除空白行</span></span><br><span class="line">$ sed <span class="string">'/^$/d'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已匹配字符串标记（&amp;）在sed中，我们可以用 &amp;标记匹配样式的字符串，这样就能够在替换字符串时使用已匹配的内容。</span></span><br><span class="line">$ <span class="built_in">echo</span> this is an example | sed <span class="string">'s/\w\+/[&amp;]/g'</span></span><br><span class="line">[this] [is] [an] [example]</span><br><span class="line"><span class="comment"># 正则表达式 \w\+ 匹配每一个单词，然后我们用[&amp;]替换它。 &amp; 对应于之前所匹配到的单词。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合多个表达式</span></span><br><span class="line">$ sed <span class="string">'expression'</span> | sed <span class="string">'expression'</span></span><br><span class="line"><span class="comment"># 它等价于</span></span><br><span class="line">$ sed <span class="string">'expression; expression'</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ sed -e <span class="string">'expression'</span> -e expression<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 引用。sed表达式通常用单引号来引用。双引号会通过对表达式求值来对其进行扩展。</span></span><br><span class="line"><span class="string">$ text=hello</span></span><br><span class="line"><span class="string">$ echo hello world | sed "s/$text/HELLO/"</span></span><br><span class="line"><span class="string">HELLO world</span></span><br></pre></td></tr></table></figure><h3 id="4-5-awk-进行高级文本处理"><a href="#4-5-awk-进行高级文本处理" class="headerlink" title="4.5 awk 进行高级文本处理"></a>4.5 awk 进行高级文本处理</h3><h4 id="4-5-1-awk-常用命令选项"><a href="#4-5-1-awk-常用命令选项" class="headerlink" title="4.5.1 awk 常用命令选项"></a>4.5.1 awk 常用命令选项</h4><ul><li><code>-F fs</code>        fs指定输入分隔符，fs可以是字符串或正则表达式，如<code>-F:</code><ul><li><code>-v var=value</code>   赋值一个用户定义变量，将外部变量传递给awk </li></ul></li><li><code>-f scripfile</code>      从脚本文件中读取awk命令 </li><li><code>-m[fr] val</code>          对val值设置内在限制，<code>-mf</code> 选项限制分配给val的最大块数目；<code>-mr</code> 选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li></ul><h4 id="4-5-2-awk-脚本基本结构"><a href="#4-5-2-awk-脚本基本结构" class="headerlink" title="4.5.2 awk 脚本基本结构"></a>4.5.2 awk 脚本基本结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; print "start" &#125; pattern&#123; commands &#125; END&#123; print "end" &#125;'</span> file</span><br><span class="line"><span class="comment"># 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;'</span> filename </span><br><span class="line">$ awk <span class="string">"BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;"</span> filename</span><br></pre></td></tr></table></figure><h4 id="4-5-3-awk-的工作原理"><a href="#4-5-3-awk-的工作原理" class="headerlink" title="4.5.3 awk 的工作原理"></a>4.5.3 awk 的工作原理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;'</span></span><br></pre></td></tr></table></figure><ul><li>第一步：执行 <code>BEGIN{ commands }</code> 语句块中的语句</li><li>第二步：从文件或标准输入(stdin)读取一行，然后执行 <code>pattern{ commands }</code> 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕</li><li>第三步：当读至输入流末尾时，执行 <code>END{ commands }</code> 语句块</li></ul><h4 id="4-5-4-awk-内置变量（预定义变量）"><a href="#4-5-4-awk-内置变量（预定义变量）" class="headerlink" title="4.5.4 awk 内置变量（预定义变量）"></a>4.5.4 awk 内置变量（预定义变量）</h4><p><strong>说明：</strong>  <code>[A][N][P][G]</code>表示第一个支持变量的工具，<code>[A]=awk</code>、<code>[N]=nawk</code>、<code>[P]=POSIXawk</code>、<code>[G]=gawk</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$n</span> <span class="comment"># 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 </span></span><br><span class="line"><span class="variable">$0</span> <span class="comment"># 这个变量包含执行过程中当前行的文本内容。 </span></span><br><span class="line">[N] ARGC <span class="comment"># 命令行参数的数目。 </span></span><br><span class="line">[G] ARGIND <span class="comment"># 命令行中当前文件的位置（从0开始算）。 </span></span><br><span class="line">[N] ARGV <span class="comment"># 包含命令行参数的数组。 </span></span><br><span class="line">[G] CONVFMT <span class="comment"># 数字转换格式（默认值为%.6g）。 </span></span><br><span class="line">[P] ENVIRON <span class="comment"># 环境变量关联数组。 </span></span><br><span class="line">[N] ERRNO <span class="comment"># 最后一个系统错误的描述。 </span></span><br><span class="line">[G] FIELDWIDTHS <span class="comment"># 字段宽度列表（用空格键分隔）。 </span></span><br><span class="line">[A] FILENAME <span class="comment"># 当前输入文件的名。 </span></span><br><span class="line">[P] FNR <span class="comment"># 同NR，但相对于当前文件。 </span></span><br><span class="line">[A] FS <span class="comment"># 字段分隔符（默认是任何空格）。 </span></span><br><span class="line">[G] IGNORECASE <span class="comment"># 如果为真，则进行忽略大小写的匹配。 </span></span><br><span class="line">[A] NF <span class="comment"># 表示字段数，在执行过程中对应于当前的字段数。 </span></span><br><span class="line">[A] NR <span class="comment"># 表示记录数，在执行过程中对应于当前的行号。 </span></span><br><span class="line">[A] OFMT <span class="comment"># 数字的输出格式（默认值是%.6g）。 </span></span><br><span class="line">[A] OFS <span class="comment"># 输出字段分隔符（默认值是一个空格）。 </span></span><br><span class="line">[A] ORS <span class="comment"># 输出记录分隔符（默认值是一个换行符）。 </span></span><br><span class="line">[A] RS <span class="comment"># 记录分隔符（默认是一个换行符）。 </span></span><br><span class="line">[N] RSTART <span class="comment"># 由match函数所匹配的字符串的第一个位置。 </span></span><br><span class="line">[N] RLENGTH <span class="comment"># 由match函数所匹配的字符串的长度。 </span></span><br><span class="line">[N] SUBSEP <span class="comment"># 数组下标分隔符（默认值是34）。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3nline2 f4 f5nline3 f6 f7"</span> | awk <span class="string">'&#123;print "Line No:"NR", No of fields:"NF, "$0="$0, "$1="$1, "$2="$2, "$3="$3&#125;'</span> </span><br><span class="line">Line No:1, No of fields:3 <span class="variable">$0</span>=line1 f2 f3 <span class="variable">$1</span>=line1 <span class="variable">$2</span>=f2 <span class="variable">$3</span>=f3 </span><br><span class="line">Line No:2, No of fields:3 <span class="variable">$0</span>=line2 f4 f5 <span class="variable">$1</span>=line2 <span class="variable">$2</span>=f4 <span class="variable">$3</span>=f5 </span><br><span class="line">Line No:3, No of fields:3 <span class="variable">$0</span>=line3 f6 f7 <span class="variable">$1</span>=line3 <span class="variable">$2</span>=f6 <span class="variable">$3</span>=f7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推：</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3n line2 f4 f5"</span> | awk <span class="string">'&#123;print $NF&#125;'</span> </span><br><span class="line">f3</span><br><span class="line">f5</span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3n line2 f4 f5"</span> | awk <span class="string">'&#123;print $(NF-1)&#125;'</span> </span><br><span class="line">f2 </span><br><span class="line">f4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每一行的第二和第三个字段：</span></span><br><span class="line">$ awk <span class="string">'&#123; print $2,$3 &#125;'</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件中的行数：</span></span><br><span class="line">$ awk <span class="string">'END&#123; print NR &#125;'</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个每一行中第一个字段值累加的例子：</span></span><br><span class="line">$ seq 5 | awk <span class="string">'BEGIN&#123; sum=0; print "总和：" &#125; &#123; print $1"+"; sum+=$1 &#125; END&#123; print "等于"; print sum &#125;'</span> </span><br><span class="line">总和： </span><br><span class="line">1+ </span><br><span class="line">2+ </span><br><span class="line">3+ </span><br><span class="line">4+ </span><br><span class="line">5+ </span><br><span class="line">等于 </span><br><span class="line">15</span><br></pre></td></tr></table></figure><h4 id="4-5-5-将外部变量值传递给awk"><a href="#4-5-5-将外部变量值传递给awk" class="headerlink" title="4.5.5 将外部变量值传递给awk"></a>4.5.5 将外部变量值传递给awk</h4><p>借助 <code>-v</code> 选项，可以将外部值（并非来自stdin）传递给awk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ VAR=10000 </span><br><span class="line">$ <span class="built_in">echo</span> | awk -v VARIABLE=<span class="variable">$VAR</span> <span class="string">'&#123; print VARIABLE &#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种传递外部变量方法：</span></span><br><span class="line">$ var1=<span class="string">"aaa"</span> </span><br><span class="line">$ var2=<span class="string">"bbb"</span> </span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当输入来自于文件时使用：</span></span><br><span class="line">$ awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span> filename</span><br></pre></td></tr></table></figure><h4 id="4-5-6-awk-运算与判断"><a href="#4-5-6-awk-运算与判断" class="headerlink" title="4.5.6 awk 运算与判断"></a>4.5.6 awk 运算与判断</h4><p><strong>算数运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+ -</td><td>加、减</td></tr><tr><td>* / &amp;</td><td>乘，除与求余</td></tr><tr><td>+ - !</td><td>一元加、减和逻辑非</td></tr><tr><td>^ ***</td><td>求幂</td></tr><tr><td>++ –</td><td>增加或减少，作为前缀或后缀</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";print a++,++a;&#125;'</span> </span><br><span class="line">0 2</span><br></pre></td></tr></table></figure><p style="color=red">**注意：**所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</p><p><strong>赋值运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>= += -= <em>= /= %= ^= *</em>=</td><td>赋值语句</td></tr></tbody></table><p><strong>逻辑运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>||</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);&#125;'</span></span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><p><strong>正则运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>~  ~!</td><td>匹配正则表达式和不匹配正则表达式</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="100testa";if(a ~ /^100*/)&#123;print "ok";&#125;&#125;'</span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><strong>关系运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&lt;  &lt;=  &gt;  &gt;=  !=  ==</td><td>关系运算符</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a=11;if(a &gt;= 9)&#123;print "ok";&#125;&#125;'</span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p style="color=red">**注意：**>  < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。</p><p><strong>其他运算符：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>字段引用</td></tr><tr><td>空格</td><td>字符串连接符</td></tr><tr><td>? :</td><td>C条件表达式</td></tr><tr><td>in</td><td>数组中是否存在某键值</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";print a=="b"?"ok":"err";&#125;'</span> </span><br><span class="line">ok </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";arr[0]="b";arr[1]="c";print (a in arr);&#125;'</span> </span><br><span class="line">0 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;a="b";arr[0]="b";arr["b"]="c";print (a in arr);&#125;'</span> </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>运算级优先级表：</p><table><thead><tr><th>级别</th><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>=, +=, -=, *=, /=, %=, &amp;=, ^=, |=, &lt;&lt;=, &gt;&gt;=</td><td>赋值、运算</td></tr><tr><td>2</td><td>||</td><td>逻辑或</td></tr><tr><td>3</td><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>4</td><td>|</td><td>按位或</td></tr><tr><td>5</td><td>^</td><td>按位异或</td></tr><tr><td>6</td><td>&amp;</td><td>按位与</td></tr><tr><td>7</td><td>==, !=</td><td>等于、不等于</td></tr><tr><td>8</td><td>&lt;=, &gt;=, &lt;, &gt;</td><td>小于等于、大于等于、小于、大于</td></tr><tr><td>9</td><td>&lt;&lt;, &gt;&gt;</td><td>按位左移，按位右移</td></tr><tr><td>10</td><td>+, -</td><td>加、减</td></tr><tr><td>11</td><td>*, /, %</td><td>乘、除、取模</td></tr><tr><td>12</td><td>!, ~</td><td>逻辑非、按位取反或补码</td></tr><tr><td>13</td><td>-, +</td><td>正、负</td></tr></tbody></table><p>级别越高越优先</p><h4 id="4-5-7-awk-高级输入输出"><a href="#4-5-7-awk-高级输入输出" class="headerlink" title="4.5.7 awk 高级输入输出"></a>4.5.7 awk 高级输入输出</h4><p><strong>读取下一条记录：</strong></p><p>awk中 <code>next</code> 语句使用：在循环逐行匹配，如果遇到 <code>next</code>，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。net语句一般用于多行合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt </span><br><span class="line">a </span><br><span class="line">b </span><br><span class="line">c </span><br><span class="line">d </span><br><span class="line">e </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;'</span> text.txt </span><br><span class="line">2 b </span><br><span class="line">4 d</span><br></pre></td></tr></table></figure><p>当记录行号除以2余1，就跳过当前行。下面的 <code>print NR,$0</code> 也不会执行。下一行开始，程序有开始判断 <code>NR%2</code> 值。这个时候记录行号是 <code>：2</code>  ，就会执行下面语句块：<code>&#39;print NR,$0&#39;</code> </p><p>分析发现需要将包含有 “web” 行进行跳过，然后需要将内容与下面行合并为一行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat text.txt </span><br><span class="line">web01[192.168.2.100] </span><br><span class="line">httpd ok </span><br><span class="line">tomcat ok </span><br><span class="line">sendmail ok </span><br><span class="line">web02[192.168.2.101] </span><br><span class="line">httpd ok </span><br><span class="line">postfix ok </span><br><span class="line">web03[192.168.2.102] </span><br><span class="line">mysqld ok </span><br><span class="line">httpd ok </span><br><span class="line">0 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'/^web/&#123;T=$0;next;&#125;&#123;print T":t"$0;&#125;'</span> test.txt </span><br><span class="line">web01[192.168.2.100]: httpd ok </span><br><span class="line">web01[192.168.2.100]: tomcat ok </span><br><span class="line">web01[192.168.2.100]: sendmail ok </span><br><span class="line">web02[192.168.2.101]: httpd ok </span><br><span class="line">web02[192.168.2.101]: postfix ok </span><br><span class="line">web03[192.168.2.102]: mysqld ok </span><br><span class="line">web03[192.168.2.102]: httpd ok</span><br></pre></td></tr></table></figure><p><strong>简单地读取一条记录：</strong></p><p><code>awk getline</code> 用法：输出重定向需用到 <code>getline函数</code>。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。</p><p style="color=red">如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。 </p><p></p><blockquote><p>getline语法：getline var，变量var包含了特定行的内容。 </p></blockquote><p>awk getline从整体上来说，用法说明：</p><ul><li><strong>当其左右<p style="color=red">无</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline作用于当前文件，读入当前文件的第一行给其后跟的变量 <code>var</code> 或 <code>$0</code>（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。</li><li><strong>当其左右<p style="color=red">有</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; "date" | getline out; print out &#125;'</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，split函数把变量out转化成数组mon，然后打印数组mon的第二个元素：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; "date" | getline out; split(out,mon); print mon[2] &#125;'</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; while( "ls" | getline) print &#125;'</span></span><br></pre></td></tr></table></figure><p><strong>关闭文件：</strong></p><p>awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(<span class="string">"filename"</span>)</span><br></pre></td></tr></table></figure><p>filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。</p><p><strong>输出到一个文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt; "datafile"&#125;'</span></span><br><span class="line">或 </span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt;&gt; "datafile"&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="4-5-8-设置字段定界符"><a href="#4-5-8-设置字段定界符" class="headerlink" title="4.5.8 设置字段定界符"></a>4.5.8 设置字段定界符</h4><p style="color=red">默认的字段定界符是空格</p>，可以使用 `-F "定界符"` 明确指定一个定界符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F: <span class="string">'&#123; print $NF &#125;'</span> /etc/passwd </span><br><span class="line">或 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123; FS=":" &#125; &#123; print $NF &#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>在 <code>BEGIN语句块</code> 中则可以用 <code>OFS=“定界符”</code> 设置输出字段的定界符。</p><h4 id="4-5-9-流程控制语句"><a href="#4-5-9-流程控制语句" class="headerlink" title="4.5.9 流程控制语句"></a>4.5.9 流程控制语句</h4><p><strong>条件判断语句：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100; </span></span><br><span class="line"><span class="string">if(test&gt;90)&#123; </span></span><br><span class="line"><span class="string">print "very good"; </span></span><br><span class="line"><span class="string">&#125; else if(test&gt;60)&#123; </span></span><br><span class="line"><span class="string">print "good"; </span></span><br><span class="line"><span class="string">&#125; else&#123; </span></span><br><span class="line"><span class="string">print "no pass"; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">very good</span><br></pre></td></tr></table></figure><p>每条命令语句后面可以用 <code>;</code> </p><p style="color=red">分号</p>结尾。<p></p><p><strong>循环语句：</strong></p><p>while语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">while(i&lt;=test)&#123; </span></span><br><span class="line"><span class="string">total+=i; i++; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>for循环：</p><p>格式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(k in ENVIRON)&#123; </span></span><br><span class="line"><span class="string">print k"="ENVIRON[k]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line">TERM=linux </span><br><span class="line">G_BROKEN_FILENAMES=1 </span><br><span class="line">SHLVL=1 </span><br><span class="line"><span class="built_in">pwd</span>=/root/text </span><br><span class="line">... </span><br><span class="line">logname=root </span><br><span class="line">HOME=/root </span><br><span class="line">SSH_CLIENT=192.168.1.21 53087 22</span><br></pre></td></tr></table></figure><p><strong>注：</strong>ENVIRON是awk常量，是子典型数组。</p><p>格式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">for(i=0;i&lt;=100;i++)&#123; </span></span><br><span class="line"><span class="string">total+=i; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>do循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0; </span></span><br><span class="line"><span class="string">i=0; </span></span><br><span class="line"><span class="string">do &#123;</span></span><br><span class="line"><span class="string">total+=i;i++;</span></span><br><span class="line"><span class="string">&#125; while(i&lt;=100) </span></span><br><span class="line"><span class="string">print total; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p><strong>其他语句：</strong></p><ul><li><strong>break</strong>          当 break 语句用于 while 或 for 语句时，导致退出程序循环</li><li><strong>continue</strong>       当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代</li><li><strong>next</strong>               能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程</li><li><strong>exit</strong>                 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行</li></ul><h4 id="4-5-10-数组应用"><a href="#4-5-10-数组应用" class="headerlink" title="4.5.10 数组应用"></a>4.5.10 数组应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到数组长度</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";lens=split(info,tA," ");print length(tA),lens;&#125;'</span> </span><br><span class="line">4 4</span><br><span class="line"><span class="comment"># length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># asort对数组进行排序，返回数组长度。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";split(info,tA," ");print asort(tA);&#125;'</span> </span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组内容（无序，有序输出）：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";split(info,tA," ");for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">4 <span class="built_in">test</span> </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line"></span><br><span class="line"><span class="comment"># for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="it is a test";tlen=split(info,tA," ");for(k=1;k&lt;=tlen;k++)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line">4 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 注意：数组下标是从1开始，与C数组不一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断键值存在以及删除键值：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";if( "c" in tB)&#123;print "ok";&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;'</span> </span><br><span class="line">a a1 </span><br><span class="line">b b1</span><br><span class="line"><span class="comment"># 删除键值： </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";delete tB["a"];for(k in tB)&#123;print k,tB[k];&#125;&#125;'</span> </span><br><span class="line">b b1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维、多维数组使用</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(i=1;i&lt;=9;i++)&#123; </span></span><br><span class="line"><span class="string">for(j=1;j&lt;=9;j++)&#123; </span></span><br><span class="line"><span class="string">tarr[i,j]=i*j; </span></span><br><span class="line"><span class="string">print i,"*",j,"=",tarr[i,j]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span> </span><br><span class="line">1 * 1 = 1 </span><br><span class="line">1 * 2 = 2 </span><br><span class="line">1 * 3 = 3 </span><br><span class="line">1 * 4 = 4 </span><br><span class="line">1 * 5 = 5 </span><br><span class="line">1 * 6 = 6 </span><br><span class="line">... </span><br><span class="line">9 * 6 = 54 </span><br><span class="line">9 * 7 = 63 </span><br><span class="line">9 * 8 = 72 </span><br><span class="line">9 * 9 = 81</span><br><span class="line"><span class="comment"># 可以通过array[k,k2]引用获得数组内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方法：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123; </span></span><br><span class="line"><span class="string">for(i=1;i&lt;=9;i++)&#123; </span></span><br><span class="line"><span class="string">for(j=1;j&lt;=9;j++)&#123; </span></span><br><span class="line"><span class="string">tarr[i,j]=i*j; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">for(m in tarr)&#123; </span></span><br><span class="line"><span class="string">split(m,tarr2,SUBSEP); print tarr2[1],"*",tarr2[2],"=",tarr[m]; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="4-5-11-内置函数"><a href="#4-5-11-内置函数" class="headerlink" title="4.5.11 内置函数"></a>4.5.11 内置函数</h4><p>awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数。</p><p><strong>算数函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>atan2( y, x )</td><td>返回 y/x 的反正切</td></tr><tr><td>cos( x )</td><td>返回 x 的余弦；x 是弧度</td></tr><tr><td>sin( x )</td><td>返回 x 的正弦；x 是弧度</td></tr><tr><td>exp( x )</td><td>返回 x 幂函数</td></tr><tr><td>log( x )</td><td>返回 x 的自然对数</td></tr><tr><td>sqrt( x )</td><td>返回 x 平方根</td></tr><tr><td>int( x )</td><td>返回 x 的截断至整数的值</td></tr><tr><td>rand( )</td><td>返回任意数字 n，其中 0 &lt;= n &lt; 1</td></tr><tr><td>srand( [expr] )</td><td>将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;OFMT="%.3f";fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;&#125;'</span> </span><br><span class="line">0.841 22026.466 2.303 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得随机数：</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">78 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">31 </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;'</span> </span><br><span class="line">41</span><br></pre></td></tr></table></figure><p><strong>字符串函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>gsub( Ere, Repl, [ In ] )</td><td>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行</td></tr><tr><td>sub( Ere, Repl, [ In ] )</td><td>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）</td></tr><tr><td>index( String1, String2 )</td><td>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）</td></tr><tr><td>length [(String)]</td><td>返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td></tr><tr><td>blength [(String)]</td><td>返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td></tr><tr><td>substr( String, M, [ N ] )</td><td>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度</td></tr><tr><td>match( String, Ere )</td><td>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）</td></tr><tr><td>split( String, A, [Ere] )</td><td>将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建</td></tr><tr><td>tolower( String )</td><td>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td></tr><tr><td>toupper( String )</td><td>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td></tr><tr><td>sprintf(Format, Expr, Expr, . . . )</td><td>根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串</td></tr></tbody></table><p><strong>注：</strong>Ere都可以是正则表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gsub,sub使用 </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";gsub(/[0-9]+/,"!",info);print info&#125;'</span> </span><br><span class="line">this is a <span class="built_in">test</span>!<span class="built_in">test</span>!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找字符串（index使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print index(info,"test")?"ok":"no found";&#125;'</span> </span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式匹配查找(match使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print match(info,/[0-9]+/)?"ok":"no found";&#125;'</span> </span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取字符串(substr使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print substr(info,4,10);&#125;'</span> </span><br><span class="line">s is a tes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串分割（split使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;info="this is a test";split(info,tA," ");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span> </span><br><span class="line">4 </span><br><span class="line">4 <span class="built_in">test</span> </span><br><span class="line">1 this </span><br><span class="line">2 is </span><br><span class="line">3 a</span><br></pre></td></tr></table></figure><p><strong>格式化字符串输出（sprintf使用）</strong> </p><p>格式化字符串格式：</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%d</td><td>十进制有符号整数</td></tr><tr><td>%u</td><td>十进制无符号整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%c</td><td>单个字符</td></tr><tr><td>%p</td><td>指针的值</td></tr><tr><td>%e</td><td>指数形式的浮点数</td></tr><tr><td>%x</td><td>%X 无符号以十六进制表示的整数</td></tr><tr><td>%o</td><td>无符号以八进制表示的整数</td></tr><tr><td>%g</td><td>自动选择合适的表示法</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;n1=124.113;n2=-1.224;n3=1.2345; printf("%.2f,%.2u,%.2g,%X,%on",n1,n2,n3,n1,n1);&#125;'</span> </span><br><span class="line">124.11,18446744073709551615,1.2,7C,174</span><br></pre></td></tr></table></figure><p><strong>一般函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>close( Expression )</td><td>用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的</td></tr><tr><td>system(command )</td><td>执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程</td></tr><tr><td>Expression | getline [ Variable ]</td><td>从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td></tr><tr><td>getline [ Variable ] &lt; Expression</td><td>从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td></tr><tr><td>getline [ Variable ]</td><td>将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开外部文件（close用法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;while("cat /etc/passwd"|getline)&#123;print $0;&#125;;close("/etc/passwd");&#125;'</span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐行读取外部文件(getline使用方法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;while(getline &lt; "/etc/passwd")&#123;print $0;&#125;;close("/etc/passwd");&#125;'</span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin </span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin </span><br><span class="line">$ awk <span class="string">'BEGIN&#123;print "Enter your name:";getline name;print name;&#125;'</span> </span><br><span class="line">Enter your name: </span><br><span class="line">chengmo </span><br><span class="line">chengmo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用外部应用程序(system使用方法） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;b=system("ls -al");print b;&#125;'</span> </span><br><span class="line">total 42092 </span><br><span class="line">drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 . </span><br><span class="line">drwxr-xr-x 95 root root 4096 10-08 14:01 .. </span><br><span class="line"><span class="comment"># b返回值，是执行结果。</span></span><br></pre></td></tr></table></figure><p><strong>时间函数：</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>函数名</td><td>说明</td></tr><tr><td>mktime( YYYY MM dd HH MM ss[ DST])</td><td>生成时间格式</td></tr><tr><td>strftime([format [, timestamp]])</td><td>格式化时间输出，将时间戳转为时间字符串 具体格式，见下表.</td></tr><tr><td>systime()</td><td>得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建指定时间(mktime使用） </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp=mktime("2001 01 01 12 12 12");print strftime("%c",tstamp);&#125;'</span> </span><br><span class="line">2001年01月01日 星期一 12时12分12秒 </span><br><span class="line"></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=mktime("2001 02 01 0 0 0");print tstamp2-tstamp1;&#125;'</span> </span><br><span class="line">2634468 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 求2个时间段中间时间差，介绍了strftime使用方法 </span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=systime();print tstamp2-tstamp1;&#125;'</span> </span><br><span class="line">308201392</span><br></pre></td></tr></table></figure><p>strftime日期和时间格式说明符</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%a</td><td>星期几的缩写（Sun）</td></tr><tr><td>%A</td><td>星期几的完整写法（Sunday）</td></tr><tr><td>%b</td><td>月名的缩写（Oct）</td></tr><tr><td>%B</td><td>月名的完整写法（October）</td></tr><tr><td>%c</td><td>本地日期和时间</td></tr><tr><td>%d</td><td>十进制日期</td></tr><tr><td>%D</td><td>日期 08/20/99</td></tr><tr><td>%e</td><td>日期，如果只有一位会补上一个空格</td></tr><tr><td>%H</td><td>用十进制表示24小时格式的时间</td></tr><tr><td>%I</td><td>用十进制表示12小时格式的时间</td></tr><tr><td>%j</td><td>从1月1日期一年中的第几天</td></tr><tr><td>%m</td><td>十进制表示的月份</td></tr><tr><td>%M</td><td>十进制表示的分钟</td></tr><tr><td>%p</td><td>12小时表示法（AM/PM）</td></tr><tr><td>%S</td><td>十进制表示的秒</td></tr><tr><td>%U</td><td>十进制表示的一年中的第几个星期（星期天作为一个星期的开始）</td></tr><tr><td>%w</td><td>十进制表示的星期几（星期天是0）</td></tr><tr><td>%W</td><td>十进制表示的一年中的第几个星期（星期一作为一个星期的开始）</td></tr><tr><td>%x</td><td>重新设置本地日期（08/20/99）</td></tr><tr><td>%X</td><td>重新设置本地时间（12 : 00 : 00）</td></tr><tr><td>%y</td><td>两位数字表示的年（99）</td></tr><tr><td>%Y</td><td>当前月份</td></tr><tr><td>%Z</td><td>时区（PDT）</td></tr><tr><td>%%</td><td>百分号（%）</td></tr></tbody></table><h3 id="4-6-find-对目录中的所有文件进行文本替换"><a href="#4-6-find-对目录中的所有文件进行文本替换" class="headerlink" title="4.6 find 对目录中的所有文件进行文本替换"></a>4.6 find 对目录中的所有文件进行文本替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有.cpp文件中的Copyright替换成Copyleft：</span></span><br><span class="line">$ find . -name *.cpp -print0 | xargs -I&#123;&#125; -0 sed -i <span class="string">'s/Copyright/Copyleft/g'</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-exec实现同样的效果：</span></span><br><span class="line">$ find . -name *.cpp -<span class="built_in">exec</span> sed -i <span class="string">'s/Copyright/Copyleft/g'</span> \&#123;\&#125; \;</span><br></pre></td></tr></table></figure><h2 id="5-一团乱麻"><a href="#5-一团乱麻" class="headerlink" title="5 一团乱麻"></a>5 一团乱麻</h2><h3 id="5-1-wget命令"><a href="#5-1-wget命令" class="headerlink" title="5.1 wget命令"></a>5.1 wget命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-a&lt;日志文件&gt;：<span class="comment"># 在指定的日志文件中记录资料的执行过程； </span></span><br><span class="line">-A&lt;后缀名&gt;： <span class="comment"># 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔； </span></span><br><span class="line">-b：   <span class="comment"># 进行后台的方式运行wget； </span></span><br><span class="line">-B&lt;连接地址&gt;：<span class="comment"># 设置参考的连接地址的基地地址； </span></span><br><span class="line">-c：   <span class="comment"># 继续执行上次终端的任务； </span></span><br><span class="line">-C&lt;标志&gt;： <span class="comment"># 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； </span></span><br><span class="line">-d：   <span class="comment"># 调试模式运行指令； </span></span><br><span class="line">-D&lt;域名列表&gt;：    <span class="comment"># 设置顺着的域名列表，域名之间用“，”分隔； </span></span><br><span class="line">-e&lt;指令&gt;： <span class="comment"># 作为文件“.wgetrc”中的一部分执行指定的指令； </span></span><br><span class="line">-h：   <span class="comment"># 显示指令帮助信息； </span></span><br><span class="line">-i&lt;文件&gt;： <span class="comment"># 从指定文件获取要下载的URL地址； </span></span><br><span class="line">-l&lt;目录列表&gt;：<span class="comment"># 设置顺着的目录列表，多个目录用“，”分隔； </span></span><br><span class="line">-L：   <span class="comment"># 仅顺着关联的连接； </span></span><br><span class="line">-r：   <span class="comment"># 递归下载方式； </span></span><br><span class="line">-nc：   <span class="comment"># 文件存在时，下载文件不覆盖原有文件； </span></span><br><span class="line">-nv：   <span class="comment"># 下载时只显示更新和出错信息，不显示指令的详细执行过程； </span></span><br><span class="line">-q：   <span class="comment"># 不显示指令执行过程； </span></span><br><span class="line">-nh：   <span class="comment"># 不查询主机名称； </span></span><br><span class="line">-v：   <span class="comment"># 显示详细执行过程； </span></span><br><span class="line">-V：   <span class="comment"># 显示版本信息； </span></span><br><span class="line">--passive-ftp：   <span class="comment"># 使用被动模式PASV连接FTP服务器； </span></span><br><span class="line">--follow-ftp：   <span class="comment"># 从HTML文件中下载FTP连接文件。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget下载单个文件 </span></span><br><span class="line">$ wget http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并以不同的文件名保存 </span></span><br><span class="line">$ wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># wget限速下载 </span></span><br><span class="line">$ wget --<span class="built_in">limit</span>-rate=300k http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用wget断点续传 </span></span><br><span class="line">$ wget -c http://www.linuxde.net/testfile.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用wget后台下载 </span></span><br><span class="line">$ wget -b http://www.linuxde.net/testfile.zip </span><br><span class="line">Continuing <span class="keyword">in</span> background, pid 1840. </span><br><span class="line">Output will be written to `wget-log<span class="string">'.</span></span><br><span class="line"><span class="string"># 对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载，你可以使用以下命令来察看下载进度： </span></span><br><span class="line"><span class="string">$ tail -f wget-log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 伪装代理名称下载 </span></span><br><span class="line"><span class="string">$ wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.linuxde.net/testfile.zip</span></span><br><span class="line"><span class="string"># 有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装。</span></span><br></pre></td></tr></table></figure><p><strong>测试下载链接：</strong></p><p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --spider URL</span><br></pre></td></tr></table></figure><p>如果下载链接正确，将会显示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spider mode enabled. Check if remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 200 OK </span><br><span class="line">Length: unspecified [text/html] </span><br><span class="line">Remote file exists and could contain further links, </span><br><span class="line">but recursion is disabled -- not retrieving.</span><br></pre></td></tr></table></figure><p>这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget --spider url </span><br><span class="line">Spider mode enabled. Check <span class="keyword">if</span> remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 404 Not Found </span><br><span class="line">Remote file does not exist -- broken link!!!</span><br></pre></td></tr></table></figure><p>你可以在以下几种情况下使用–spider参数：</p><ul><li>定时下载之前进行检查</li><li>间隔检测网站是否可用</li><li>检查网站页面的死链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加重试次数 </span></span><br><span class="line">$ wget --tries=40 URL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载多个文件 </span></span><br><span class="line">$ wget -i filelist.txt </span><br><span class="line"><span class="comment"># 首先，保存一份下载链接文件： </span></span><br><span class="line">$ cat &gt; filelist.txt </span><br><span class="line">url1 </span><br><span class="line">url2 </span><br><span class="line">url3 </span><br><span class="line">url4 </span><br><span class="line"><span class="comment"># 接着使用这个文件和参数-i下载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤指定格式下载 </span></span><br><span class="line">$ wget --reject=gif ur </span><br><span class="line"><span class="comment"># 下载一个网站，但你不希望下载图片，可以使用这条命令。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把下载信息存入日志文件 </span></span><br><span class="line">$ wget -o download.log URL </span><br><span class="line"><span class="comment"># 不希望下载信息直接显示在终端而是在一个日志文件，可以使用。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制总下载文件大小 </span></span><br><span class="line">$ wget -Q5m -i filelist.txt </span><br><span class="line"><span class="comment"># 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</span></span><br></pre></td></tr></table></figure><p><strong>镜像网站：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --mirror -p --convert-links -P ./LOCAL URL</span><br></pre></td></tr></table></figure><p>下载整个网站到本地。</p><ul><li>–mirror 开户镜像下载</li><li>-p 下载所有为了html页面显示正常的文件</li><li>–convert-links 下载后，转换成本地的链接</li><li>-P ./LOCAL URL 保存所有文件和目录到本地指定目录</li></ul><p><strong>下载指定格式文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -A.pdf url</span><br></pre></td></tr></table></figure><p>可以在以下情况使用该功能：</p><ul><li>下载一个网站的所有图片</li><li>下载一个网站的所有视频</li><li>下载一个网站的所有PDF文件</li></ul><p><strong>FTP下载：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp-url </span><br><span class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><p>可以使用wget来完成ftp链接的下载。 </p><p>使用wget匿名ftp下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp-url</span><br></pre></td></tr></table></figure><p>使用wget用户名和密码认证的ftp下载： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><h3 id="5-2-curl-命令"><a href="#5-2-curl-命令" class="headerlink" title="5.2 curl 命令"></a>5.2 curl 命令</h3><p>常见参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-A/--user-agent &lt;string&gt;              <span class="comment"># 设置用户代理发送给服务器</span></span><br><span class="line">-b/--cookie &lt;name=string/file&gt;      <span class="comment"># cookie字符串或文件读取位置</span></span><br><span class="line">-c/--cookie-jar &lt;file&gt;                <span class="comment"># 操作结束后把cookie写入到这个文件中</span></span><br><span class="line">-C/--<span class="built_in">continue</span>-at &lt;offset&gt;             <span class="comment"># 断点续转</span></span><br><span class="line">-D/--dump-header &lt;file&gt;               <span class="comment"># 把header信息写入到该文件中</span></span><br><span class="line">-e/--referer                          <span class="comment"># 来源网址</span></span><br><span class="line">-f/--fail                             <span class="comment"># 连接失败时不显示http错误</span></span><br><span class="line">-o/--output                           <span class="comment"># 把输出写到该文件中</span></span><br><span class="line">-O/--remote-name                      <span class="comment"># 把输出写到该文件中，保留远程文件的文件名</span></span><br><span class="line">-r/--range &lt;range&gt;                    <span class="comment"># 检索来自HTTP/1.1或FTP服务器字节范围</span></span><br><span class="line">-s/--silent                           <span class="comment"># 静音模式。不输出任何东西</span></span><br><span class="line">-T/--upload-file &lt;file&gt;               <span class="comment"># 上传文件</span></span><br><span class="line">-u/--user &lt;user[:password]&gt;           <span class="comment"># 设置服务器的用户和密码</span></span><br><span class="line">-w/--write-out [format]               <span class="comment"># 什么输出完成后</span></span><br><span class="line">-x/--proxy &lt;host[:port]&gt;              <span class="comment"># 在给定的端口上使用HTTP代理</span></span><br><span class="line">-<span class="comment">#/--progress-bar                     # 进度条显示当前的传送状态</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不显示进度信息使用--silent选项。</span></span><br><span class="line">$ curl URL --silent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用选项 -O 将下载的数据写入到文件，必须使用文件的绝对地址：</span></span><br><span class="line">$ curl http://man.linuxde.net/text.iso --silent -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条：</span></span><br><span class="line">$ curl http://man.linuxde.net/test.iso -o filename.iso --progress</span><br><span class="line"><span class="comment">######################################### 100.0%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断点续传</span></span><br><span class="line">$ curl URL/File -C 偏移量 </span><br><span class="line"><span class="comment"># 偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -： </span></span><br><span class="line">$ curl -C -URL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--referer选项指定参照页字符串： </span></span><br><span class="line">$ curl --referer http://www.google.com http://man.linuxde.net </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl设置cookies 使用--cookie "COKKIES"选项来指定cookie，多个cookie使用分号分隔： </span></span><br><span class="line">$ curl http://man.linuxde.net --cookie <span class="string">"user=root;pass=123456"</span> </span><br><span class="line"><span class="comment"># 将cookie另存为一个文件，使用--cookie-jar选项： </span></span><br><span class="line">$ curl URL --cookie-jar cookie_file </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl设置用户代理字符串 有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用--user-agent或者-A选项：</span></span><br><span class="line">$ curl URL --user-agent <span class="string">"Mozilla/5.0"</span> curl URL -A <span class="string">"Mozilla/5.0"</span> </span><br><span class="line"><span class="comment"># 其他HTTP头部信息也可以使用curl来发送，使用-H"头部信息" 传递多个头部信息，例如： </span></span><br><span class="line">$ curl -H <span class="string">"Host:man.linuxde.net"</span> -H <span class="string">"accept-language:zh-cn"</span> URL </span><br><span class="line"></span><br><span class="line"><span class="comment"># curl的带宽控制和下载配额 使用--limit-rate限制curl的下载速度： </span></span><br><span class="line">$ curl URL --<span class="built_in">limit</span>-rate 50k </span><br><span class="line"><span class="comment"># 命令中用k（千字节）和m（兆字节）指定下载速度限制。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--max-filesize指定可下载的最大文件大小： </span></span><br><span class="line">$ curl URL --max-filesize bytes </span><br><span class="line"><span class="comment"># 如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl进行认证 使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码： </span></span><br><span class="line">$ curl -u user:<span class="built_in">pwd</span> http://man.linuxde.net </span><br><span class="line">$ curl -u user http://man.linuxde.net </span><br><span class="line"></span><br><span class="line"><span class="comment"># 只打印响应头部信息 通过-I或者-head可以只打印出HTTP头部信息： </span></span><br><span class="line">$ curl -I http://man.linuxde.net </span><br><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Server: nginx/1.2.5 </span><br><span class="line">date: Mon, 10 Dec 2012 09:24:34 GMT </span><br><span class="line">Content-Type: text/html; charset=UTF-8 </span><br><span class="line">Connection: keep-alive </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Pingback: http://man.linuxde.net/xmlrpc.php</span><br></pre></td></tr></table></figure><p>其他参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">-a/--append                    <span class="comment"># 上传文件时，附加到目标文件</span></span><br><span class="line">--anyauth                      <span class="comment"># 可以使用“任何”身份验证方法</span></span><br><span class="line">--basic                        <span class="comment"># 使用HTTP基本验证</span></span><br><span class="line">-B/--use-ascii                 <span class="comment"># 使用ASCII文本传输</span></span><br><span class="line">-d/--data &lt;data&gt;               <span class="comment"># HTTP POST方式传送数据</span></span><br><span class="line">--data-ascii &lt;data&gt;            <span class="comment"># 以ascii的方式post数据</span></span><br><span class="line">--data-binary &lt;data&gt;           <span class="comment"># 以二进制的方式post数据</span></span><br><span class="line">--negotiate                    <span class="comment"># 使用HTTP身份验证</span></span><br><span class="line">--digest                       <span class="comment"># 使用数字身份验证</span></span><br><span class="line">--<span class="built_in">disable</span>-eprt                 <span class="comment"># 禁止使用EPRT或LPRT</span></span><br><span class="line">--<span class="built_in">disable</span>-epsv                 <span class="comment"># 禁止使用EPSV</span></span><br><span class="line">--egd-file &lt;file&gt;              <span class="comment"># 为随机数据(SSL)设置EGD socket路径</span></span><br><span class="line">--tcp-nodelay                  <span class="comment"># 使用TCP_NODELAY选项</span></span><br><span class="line">-E/--cert &lt;cert[:passwd]&gt;      <span class="comment"># 客户端证书文件和密码 (SSL)</span></span><br><span class="line">--cert-type &lt;<span class="built_in">type</span>&gt;             <span class="comment"># 证书文件类型 (DER/PEM/ENG) (SSL)</span></span><br><span class="line">--key &lt;key&gt;                    <span class="comment"># 私钥文件名 (SSL)</span></span><br><span class="line">--key-type &lt;<span class="built_in">type</span>&gt;              <span class="comment"># 私钥文件类型 (DER/PEM/ENG) (SSL)</span></span><br><span class="line">--pass  &lt;pass&gt;                 <span class="comment"># 私钥密码 (SSL)</span></span><br><span class="line">--engine &lt;eng&gt;                 <span class="comment"># 加密引擎使用 (SSL). "--engine list" for list</span></span><br><span class="line">--cacert &lt;file&gt;                <span class="comment"># CA证书 (SSL)</span></span><br><span class="line">--capath &lt;directory&gt;           <span class="comment"># CA目   (made using c_rehash) to verify peer against (SSL)</span></span><br><span class="line">--ciphers &lt;list&gt;               <span class="comment"># SSL密码</span></span><br><span class="line">--compressed                   <span class="comment"># 要求返回是压缩的形势 (using deflate or gzip)</span></span><br><span class="line">--connect-timeout &lt;seconds&gt;    <span class="comment"># 设置最大请求时间</span></span><br><span class="line">--create-dirs                  <span class="comment"># 建立本地目录的目录层次结构</span></span><br><span class="line">--crlf                         <span class="comment"># 上传是把LF转变成CRLF</span></span><br><span class="line">--ftp-create-dirs              <span class="comment"># 如果远程目录不存在，创建远程目录</span></span><br><span class="line">--ftp-method [multicwd/nocwd/singlecwd]    <span class="comment"># 控制CWD的使用</span></span><br><span class="line">--ftp-pasv                     <span class="comment"># 使用 PASV/EPSV 代替端口</span></span><br><span class="line">--ftp-skip-pasv-ip             <span class="comment"># 使用PASV的时候,忽略该IP地址</span></span><br><span class="line">--ftp-ssl                      <span class="comment"># 尝试用 SSL/TLS 来进行ftp数据传输</span></span><br><span class="line">--ftp-ssl-reqd                 <span class="comment"># 要求用 SSL/TLS 来进行ftp数据传输</span></span><br><span class="line">-F/--form &lt;name=content&gt;       <span class="comment"># 模拟http表单提交数据</span></span><br><span class="line">-form-string &lt;name=string&gt;     <span class="comment"># 模拟http表单提交数据</span></span><br><span class="line">-g/--globoff                   <span class="comment"># 禁用网址序列和范围使用&#123;&#125;和[]</span></span><br><span class="line">-G/--get                       <span class="comment"># 以get的方式来发送数据</span></span><br><span class="line">-h/--<span class="built_in">help</span>                      <span class="comment"># 帮助</span></span><br><span class="line">-H/--header &lt;line&gt;             <span class="comment"># 自定义头信息传递给服务器</span></span><br><span class="line">--ignore-content-length        <span class="comment"># 忽略的HTTP头信息的长度</span></span><br><span class="line">-i/--include                   <span class="comment"># 输出时包括protocol头信息</span></span><br><span class="line">-I/--head                      <span class="comment"># 只显示文档信息</span></span><br><span class="line">-j/--junk-session-cookies      <span class="comment"># 读取文件时忽略session cookie</span></span><br><span class="line">--interface &lt;interface&gt;        <span class="comment"># 使用指定网络接口/地址</span></span><br><span class="line">--krb4 &lt;level&gt;                 <span class="comment"># 使用指定安全级别的krb4</span></span><br><span class="line">-k/--insecure                  <span class="comment"># 允许不使用证书到SSL站点</span></span><br><span class="line">-K/--config                    <span class="comment"># 指定的配置文件读取</span></span><br><span class="line">-l/--list-only                 <span class="comment"># 列出ftp目录下的文件名称</span></span><br><span class="line">--<span class="built_in">limit</span>-rate &lt;rate&gt;            <span class="comment"># 设置传输速度</span></span><br><span class="line">--<span class="built_in">local</span>-port&lt;NUM&gt;              <span class="comment"># 强制使用本地端口号</span></span><br><span class="line">-m/--max-time &lt;seconds&gt;        <span class="comment"># 设置最大传输时间</span></span><br><span class="line">--max-redirs &lt;num&gt;             <span class="comment"># 设置最大读取的目录数</span></span><br><span class="line">--max-filesize &lt;bytes&gt;         <span class="comment"># 设置最大下载的文件总量</span></span><br><span class="line">-M/--manual                    <span class="comment"># 显示全手动</span></span><br><span class="line">-n/--netrc                     <span class="comment"># 从netrc文件中读取用户名和密码</span></span><br><span class="line">--netrc-optional               <span class="comment"># 使用 .netrc 或者 URL来覆盖-n</span></span><br><span class="line">--ntlm                         <span class="comment"># 使用 HTTP NTLM 身份验证</span></span><br><span class="line">-N/--no-buffer                 <span class="comment"># 禁用缓冲输出</span></span><br><span class="line">-p/--proxytunnel               <span class="comment"># 使用HTTP代理</span></span><br><span class="line">--proxy-anyauth                <span class="comment"># 选择任一代理身份验证方法</span></span><br><span class="line">--proxy-basic                  <span class="comment"># 在代理上使用基本身份验证</span></span><br><span class="line">--proxy-digest                 <span class="comment"># 在代理上使用数字身份验证</span></span><br><span class="line">--proxy-ntlm                   <span class="comment"># 在代理上使用ntlm身份验证</span></span><br><span class="line">-P/--ftp-port &lt;address&gt;        <span class="comment"># 使用端口地址，而不是使用PASV</span></span><br><span class="line">-Q/--quote &lt;cmd&gt;               <span class="comment"># 文件传输前，发送命令到服务器</span></span><br><span class="line">--range-file                   <span class="comment"># 读取（SSL）的随机文件</span></span><br><span class="line">-R/--remote-time               <span class="comment"># 在本地生成文件时，保留远程文件时间</span></span><br><span class="line">--retry &lt;num&gt;                  <span class="comment"># 传输出现问题时，重试的次数</span></span><br><span class="line">--retry-delay &lt;seconds&gt;        <span class="comment"># 传输出现问题时，设置重试间隔时间</span></span><br><span class="line">--retry-max-time &lt;seconds&gt;     <span class="comment"># 传输出现问题时，设置最大重试时间</span></span><br><span class="line">-S/--show-error                <span class="comment"># 显示错误</span></span><br><span class="line">--socks4 &lt;host[:port]&gt;         <span class="comment"># 用socks4代理给定主机和端口</span></span><br><span class="line">--socks5 &lt;host[:port]&gt;         <span class="comment"># 用socks5代理给定主机和端口</span></span><br><span class="line">-t/--telnet-option &lt;OPT=val&gt;   <span class="comment"># Telnet选项设置</span></span><br><span class="line">--trace &lt;file&gt;                 <span class="comment"># 对指定文件进行debug</span></span><br><span class="line">--trace-ascii &lt;file&gt;           <span class="comment"># Like --跟踪但没有hex输出</span></span><br><span class="line">--trace-time                   <span class="comment"># 跟踪/详细输出时，添加时间戳</span></span><br><span class="line">--url &lt;URL&gt;                    <span class="comment"># Spet URL to work with</span></span><br><span class="line">-U/--proxy-user &lt;user[:password]&gt;  <span class="comment"># 设置代理用户名和密码</span></span><br><span class="line">-V/--version                   <span class="comment"># 显示版本信息</span></span><br><span class="line">-X/--request &lt;<span class="built_in">command</span>&gt;         <span class="comment"># 指定什么命令</span></span><br><span class="line">-y/--speed-time                <span class="comment"># 放弃限速所要的时间。默认为30</span></span><br><span class="line">-Y/--speed-limit               <span class="comment"># 停止传输速度的限制，速度时间'秒</span></span><br><span class="line">-z/--time-cond                 <span class="comment"># 传送时间设置</span></span><br><span class="line">-0/--http1.0                   <span class="comment"># 使用HTTP 1.0</span></span><br><span class="line">-1/--tlsv1                     <span class="comment"># 使用TLSv1（SSL）</span></span><br><span class="line">-2/--sslv2                     <span class="comment"># 使用SSLv2的（SSL）</span></span><br><span class="line">-3/--sslv3                     <span class="comment"># 使用的SSLv3（SSL）</span></span><br><span class="line">--3p-quote                     <span class="comment"># like -Q for the source URL for 3rd party transfer</span></span><br><span class="line">--3p-url                       <span class="comment"># 使用url，进行第三方传送</span></span><br><span class="line">--3p-user                      <span class="comment"># 使用用户名和密码，进行第三方传送</span></span><br><span class="line">-4/--ipv4                      <span class="comment"># 使用IP4</span></span><br><span class="line">-6/--ipv6                      <span class="comment"># 使用IP6</span></span><br></pre></td></tr></table></figure><h3 id="5-3-curl-wget两种方法模拟http的get-post请求"><a href="#5-3-curl-wget两种方法模拟http的get-post请求" class="headerlink" title="5.3 curl wget两种方法模拟http的get post请求"></a>5.3 curl wget两种方法模拟http的get post请求</h3><p><strong>get请求：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用curl命令：</span></span><br><span class="line">$ curl <span class="string">"http://www.baidu.com"</span>  <span class="comment"># 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span></span><br><span class="line">$ curl -i <span class="string">"http://www.baidu.com"</span>  <span class="comment"># 显示全部信息</span></span><br><span class="line">$ curl -l <span class="string">"http://www.baidu.com"</span> <span class="comment"># 只显示头部信息</span></span><br><span class="line">$ curl -v <span class="string">"http://www.baidu.com"</span> <span class="comment"># 显示get请求全过程解析</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget命令：</span></span><br><span class="line">$ wget <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure><p><strong>post请求：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用curl命令(通过-d参数，把访问参数放在里面)：</span></span><br><span class="line">$ curl -d <span class="string">"param1=value1&amp;param2=value2"</span> <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用wget命令：（--post-data参数来实现）</span></span><br><span class="line">$ wget --post-data <span class="string">'user=foo&amp;password=bar'</span>  http://server.com/auth.PHP</span><br></pre></td></tr></table></figure><h2 id="6-B计划"><a href="#6-B计划" class="headerlink" title="6 B计划"></a>6 B计划</h2><h3 id="6-1-用tar归档"><a href="#6-1-用tar归档" class="headerlink" title="6.1 用tar归档"></a>6.1 用tar归档</h3><p>tar支持的参数包括： <code>A</code>、 <code>c</code>、 <code>d</code>、 <code>r</code>、 <code>u</code>、 <code>x</code>、 <code>f</code> 和 <code>v</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用tar对文件进行归档：</span></span><br><span class="line">$ tar -cf output.tar file1 file2 file3 folder1 ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用选项-t列出归档文件中所包含的文件：</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要在归档或列出归档文件列表时获知更多的细节信息，可以使用-v或-vv参数</span></span><br><span class="line">$ $ tar -tvf archive.tar</span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file1</span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file2</span><br><span class="line"><span class="comment"># 文件名必须紧跟在-f之后，而且-f应该是选项中的最后一个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向归档文件中添加文件,追加选项-r</span></span><br><span class="line">$ tar -rvf original.tar new_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的方法列出归档文件中的内容：</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档文件中提取文件或文件夹, -x 表示提取</span></span><br><span class="line">$ tar -xf archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用选项-C来指定需要将文件提取到哪个目录：</span></span><br><span class="line">$ tar -xf archive.tar -C /path/to/extraction_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过将文件名指定为命令行参数来提取特定的文件：</span></span><br><span class="line">$ tar -xvf file.tar file1 file4</span><br><span class="line"><span class="comment"># 上面的命令只提取file1和file4，忽略其他文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在tar中使用stdin和stdout</span></span><br><span class="line">$ tar cvf - files/ | ssh user@example.com <span class="string">"tar xv -C Documents/"</span></span><br><span class="line"><span class="comment"># 在上面的例子中，对files目录中的内容进行了归档并输出到stdout（由'-'指明）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接两个归档文件, -A 选项轻松地合并多个tar文件</span></span><br><span class="line">$ tar -Af file1.tar file2.tar</span><br><span class="line"><span class="comment"># 查看内容，验证操作是否成功：</span></span><br><span class="line">$ tar -tvf file1.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过检查时间戳来更新归档文件中的内容</span></span><br><span class="line"><span class="comment"># 可以用更新选项-u指明：只有比归档文件中的同名文件更新时才会被添加。</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅当filea自上次被加入archive.tar后出现了变动才对其进行追加，可以使用：</span></span><br><span class="line">$ tar -uf archive.tar filea</span><br><span class="line"><span class="comment"># 如果两个filea的时间戳相同，则什么都不会发生。</span></span><br><span class="line"><span class="comment"># 可用touch命令修改文件的时间戳，然后再用tar命令：</span></span><br><span class="line">$ tar -uvvf archive.tar filea</span><br><span class="line">-rw-r--r-- slynux/slynux 0 2010-08-14 17:53 filea</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较归档文件与文件系统中的内容, 选项 -d 可以打印出两者之间的差别：</span></span><br><span class="line">$ tar -df archive.tar</span><br><span class="line">afile: Mod time differs</span><br><span class="line">afile: Size differs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档文件中删除文件, --delete选项从给定的归档文件中删除文件</span></span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"><span class="comment"># 删除filea：</span></span><br><span class="line">$ tar --delete --file archive.tar filea</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">fileb</span><br><span class="line">filec</span><br></pre></td></tr></table></figure><p><strong>压缩tar归档文件：</strong></p><p>归档文件通常被压缩成下列格式之一： </p><ul><li>file.tar.gz </li><li>file.tar.bz2 </li><li>file.tar.lzma </li></ul><p>不同的tar选项可以用来指定不同的压缩格式： </p><ul><li>-j 指定bunzip2格式； </li><li>-z 指定gzip格式； </li><li>–lzma 指定lzma格式。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了让tar支持根据扩展名自动进行压缩，使用 -a或 --auto-compress选项：</span></span><br><span class="line">$ tar acvf archive.tar.gz filea fileb filec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档中排除部分文件,  --exclude [PATTERN]排除匹配通配符样式的文件</span></span><br><span class="line">$ tar -cf arch.tar * --exclude <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># 样式应该使用双引号来引用，避免shell对其进行扩展。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以将需要排除的文件列表放入文件中，同时配合选项 -X：</span></span><br><span class="line">$ cat list</span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">$ tar -cf arch.tar * -X list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排除版本控制目录， 可以使用tar的 --exclude-vcs选项。例如：</span></span><br><span class="line">$ tar --exclude-vcs -czvvf source_code.tar.gz eye_of_gnome_svn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印总字节数，用–totals就可以在归档完成之后打印出总归档字节数：</span></span><br><span class="line">$ tar -cf arc.tar * --exclude <span class="string">"*.txt"</span> --totals</span><br><span class="line">Total bytes written: 20480 (20KiB, 12MiB/s)</span><br></pre></td></tr></table></figure><h3 id="6-2-用cpio归档"><a href="#6-2-用cpio归档" class="headerlink" title="6.2 用cpio归档"></a>6.2 用cpio归档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试文件：</span></span><br><span class="line">$ touch file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将测试文件按照下面的方法进行归档：</span></span><br><span class="line">$ <span class="built_in">echo</span> file1 file2 file3 | cpio -ov &gt; archive.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出cpio归档文件中的内容：</span></span><br><span class="line">$ cpio -it &lt; archive.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从cpio归档文件中提取文件：</span></span><br><span class="line">$ cpio -id &lt; archive.cpio</span><br></pre></td></tr></table></figure><p>对于归档命令： </p><ul><li>-o 指定了输出； </li><li>-v 用来打印归档文件列表。 </li></ul><p>在列出给定cpio归档文件所有内容的命令中： </p><ul><li>-i 用于指定输入； </li><li>-t 表示列出归档文件中的内容。 </li></ul><p>当使用命令进行提取时， -d用来表示提取。 cpio在覆盖文件时不会发出提示。 </p><h3 id="6-3-使用gzip压缩数据"><a href="#6-3-使用gzip压缩数据" class="headerlink" title="6.3 使用gzip压缩数据"></a>6.3 使用gzip压缩数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要使用gzip压缩文件，可以使用下面的命令：</span></span><br><span class="line">$ gzip filename</span><br><span class="line">$ ls</span><br><span class="line">filename.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将gzip文件解压缩的方法如下：</span></span><br><span class="line">$ gunzip filename.gz</span><br><span class="line">$ ls</span><br><span class="line">file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩文件的属性信息：</span></span><br><span class="line">$ gzip -l test.txt.gz</span><br><span class="line">compressed uncompressed ratio uncompressed_name</span><br><span class="line">35 6 -33.3% test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip命令可以从stdin中读入文件，也可以将压缩文件写出到stdout，选项 -c用来将输出指定到stdout。</span></span><br><span class="line">$ cat file | gzip -c &gt; file.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以指定gzip的压缩级别。用 --fast或 --best选项分别提供最低或最高的压缩比。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩归档文件</span></span><br><span class="line"><span class="comment"># 方法 1</span></span><br><span class="line">$ tar -czvvf archive.tar.gz [FILES]</span><br><span class="line">或者</span><br><span class="line">$ tar -cavvf archive.tar.gz [FILES]</span><br><span class="line"><span class="comment"># 选项 -a表明从文件扩展名自动推断压缩格式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 2</span></span><br><span class="line"><span class="comment"># 首先，创建一个tar归档文件：</span></span><br><span class="line">$ tar -cvvf archive.tar [FILES]</span><br><span class="line"><span class="comment"># 压缩tar归档文件：</span></span><br><span class="line">$ gzip archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># zcat——无需解压缩，直接读取gzip格式文件</span></span><br><span class="line">$ ls</span><br><span class="line">test.gz</span><br><span class="line">$ zcat test.gz</span><br><span class="line">A <span class="built_in">test</span> file</span><br><span class="line"><span class="comment"># 文件test包含了一行文本"A test file"</span></span><br><span class="line">$ ls</span><br><span class="line">test.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩率</span></span><br><span class="line"><span class="comment"># 我们可以指定压缩率，它共有9级，其中：</span></span><br><span class="line"><span class="comment"># 1级的压缩率最低，但是压缩速度最快；</span></span><br><span class="line"><span class="comment"># 9级的压缩率最高，但是压缩速度最慢。</span></span><br><span class="line">$ gzip -5 test.img</span><br><span class="line"><span class="comment"># 这应该能在压缩速度和压缩比之间获得一个不错的平衡。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bzip2，唯一的不同在于bzip2的压缩效率比gzip更高，但花费的时间比gzip更长</span></span><br><span class="line">$ bzip2 filename</span><br><span class="line"><span class="comment"># 解压缩bzip2格式的文件：</span></span><br><span class="line">$ bunzip2 filename.bz2</span><br><span class="line"><span class="comment"># 生成tar.bz2文件并从中提取内容的方法同之前介绍的tar.gz类似：</span></span><br><span class="line">$ tar -xjvf archive.tar.bz2</span><br><span class="line"><span class="comment"># 其中-j表明该归档文件是bzip2格式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用lzma</span></span><br><span class="line"><span class="comment"># lzma是另一种压缩工具，它的压缩率甚至比gzip和bzip2更好。</span></span><br><span class="line">$ lzma filename</span><br><span class="line"><span class="comment"># 解压缩lzma文件：</span></span><br><span class="line">$ unlzma filename.lzma</span><br><span class="line"><span class="comment"># 可以使用tar命令的--lzma选项对生成的tar归档文件进行压缩或提取：</span></span><br><span class="line">$ tar -cvvf --lzma archive.tar.lzma [FILES]</span><br><span class="line">或者</span><br><span class="line">$ tar -cavvf archive.tar.lzma [FILES]</span><br><span class="line"><span class="comment"># 如果要将经过lzma压缩过的tar归档文件中的内容提取到指定的目录中，可以使用：</span></span><br><span class="line">$ tar -xvvf --lzma archive.tar.lzma -C extract_directory</span><br><span class="line"><span class="comment"># 其中， -x用于提取内容， --lzma指定使用lzma对归档文件进行解压缩。</span></span><br><span class="line"><span class="comment"># 我们也可以用：</span></span><br><span class="line">$ tar -xavvf archive.tar.lzma -C extract_directory</span><br></pre></td></tr></table></figure><h3 id="6-4-用-zip-归档和压缩"><a href="#6-4-用-zip-归档和压缩" class="headerlink" title="6.4 用 zip 归档和压缩"></a>6.4 用 zip 归档和压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对归档文件采用ZIP格式进行压缩：</span></span><br><span class="line">$ zip file.zip file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对目录和文件进行递归操作, -r 用于指定递归操作：</span></span><br><span class="line">$ zip -r archive.zip folder1 folder2</span><br><span class="line"></span><br><span class="line"><span class="comment">#  要从ZIP文件中提取内容，可以使用：</span></span><br><span class="line">$ unzip file.zip</span><br><span class="line"><span class="comment"># 在完成提取操作之后， unzip并不会删除file.zip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要更新压缩文件中的内容，使用选项 -u：</span></span><br><span class="line">$ zip file.zip -u newfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从压缩文件中删除内容，则使用-d：</span></span><br><span class="line">$ zip -d arc.zip file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩文件中的内容：</span></span><br><span class="line">$ unzip -l archive.zip</span><br></pre></td></tr></table></figure><h3 id="6-5-更快的归档工具-pbzip2"><a href="#6-5-更快的归档工具-pbzip2" class="headerlink" title="6.5 更快的归档工具 pbzip2"></a>6.5 更快的归档工具 pbzip2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩单个文件：</span></span><br><span class="line">$ pbzip2 myfile.tar</span><br><span class="line"><span class="comment"># pbzip2会自动检测系统中处理器核心的数量，然后将myfile.tar压缩成myfile.tar.bz2。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将多个文件或目录进行归档及压缩，可以使用tar配合pbzip2来实现：</span></span><br><span class="line">$ tar cf myfile.tar.bz2 --use-compress-prog=pbzip2 dir_to_compress/</span><br><span class="line">或者</span><br><span class="line">$ tar -c directory_to_compress/ | pbzip2 -c &gt; myfile.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从pbzip2格式的文件中进行提取。</span></span><br><span class="line"><span class="comment"># 如果是tar.bz2文件，我们可以一次性完成解压缩和提取工作：</span></span><br><span class="line">$ pbzip2 -dc myfile.tar.bz2 | tar x</span><br><span class="line"><span class="comment"># 如果是经过pbzip2压缩过的归档文件，可以使用：</span></span><br><span class="line">$ pbzip2 -d myfile.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动指定处理器数量, 使用pbzip2的-p选项来手动指定处理器核心的数量</span></span><br><span class="line">$ pbzip2 -p4 myfile.tar</span><br><span class="line"><span class="comment"># 上面的命令告诉pbzip2使用4个处理器核心。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定压缩比</span></span><br><span class="line"><span class="comment"># 像其他压缩工具一样，我们可以使用从1到9的选项来分别指定最快和最优的压缩比。</span></span><br></pre></td></tr></table></figure><h3 id="6-6-创建压缩文件系统"><a href="#6-6-创建压缩文件系统" class="headerlink" title="6.6 创建压缩文件系统"></a>6.6 创建压缩文件系统</h3><p>squashfs是一种具有超高压缩率的只读型文件系统，这种文件系统能够将2GB~3GB的数据压缩成一个700MB的文件。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加源目录和文件，创建一个squashfs文件：</span></span><br><span class="line">$ sudo mksquashfs /etc test.squashfs</span><br><span class="line">Parallel mksquashfs: Using 2 processors</span><br><span class="line">Creating 4.0 filesystem on test.squashfs, block size 131072.</span><br><span class="line">[=======================================] 1867/1867 100%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用环回形式挂载squashfs文件：</span></span><br><span class="line">$ mkdir /mnt/squash</span><br><span class="line">$ mount -o loop compressedfs.squashfs /mnt/squash</span><br><span class="line"><span class="comment"># 你可以访问/mnt/squashfs访问其中的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在创建squashfs文件时排除部分文件, 选项-e，将需要排除的文件列表以命令行参数的方式来指定。例如：</span></span><br><span class="line">$ sudo mksquashfs /etc test.squashfs -e /etc/passwd /etc/shadow</span><br><span class="line"><span class="comment"># 也可以将需要排除的文件名列表写入文件，然后用 -ef指定该文件：</span></span><br><span class="line">$ cat excludelist</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line">$ sudo mksquashfs /etc test.squashfs -ef excludelist</span><br></pre></td></tr></table></figure><h3 id="6-7-使用-rsync-备份系统快照"><a href="#6-7-使用-rsync-备份系统快照" class="headerlink" title="6.7 使用 rsync 备份系统快照"></a>6.7 使用 rsync 备份系统快照</h3><p>rsync可以对位于不同位置的文件和目录进行同步，它利用差异计算以及压缩技术来最小化数据传输量。 </p><p>rsync也支持压缩、加密等多种特性。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将源目录复制到目的端：</span></span><br><span class="line">$ rsync -av /home/slynux/data slynux@192.168.0.6:/home/backups/data</span><br><span class="line"><span class="comment"># 其中：</span></span><br><span class="line"> -a表示要进行归档；</span><br><span class="line"> -v表示在stdout上打印出细节信息或进度。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据备份到远程服务器或主机：</span></span><br><span class="line">$ rsync -av source_dir username@host:PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面的方法将远程主机上的数据恢复到本地主机：</span></span><br><span class="line">$ rsync -av username@host:PATH destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过网络进行传输时，压缩数据能够明显改善传输效率。我们可以用rsync的选项 -z 指定在网络传输时压缩数据。例如：</span></span><br><span class="line">$ rsync -avz <span class="built_in">source</span> destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个目录中的内容同步到另一个目录：</span></span><br><span class="line">$ rsync -av /home/<span class="built_in">test</span>/ /home/backups</span><br><span class="line"><span class="comment"># 这条命令将源目录（/home/test）中的内容（不包括目录本身）复制到现有的backups目录中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在使用rsync进行归档的过程中排除部分文件</span></span><br><span class="line">$ rsync -avz /home/code/some_code /mnt/disk/backup/code --exclude <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># 或者我们可以通过一个列表文件指定需要排除的文件。</span></span><br><span class="line"><span class="comment"># 这可以利用--exclude-from FILEPATH。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在更新rsync备份时，删除不存在的文件, rsync并不会在目的端删除那些在源端已不存在的文件</span></span><br><span class="line">$ rsync -avz SOURCE DESTINATION --delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定期进行备份</span></span><br><span class="line">$ crontab -ev</span><br><span class="line"><span class="comment"># 添加上这么一行：</span></span><br><span class="line">0 */10 * * * rsync -avz /home/code user@IP_ADDRESS:/home/backups</span><br><span class="line"><span class="comment"># 上面的crontab条目将rsync调度为每10个小时运行一次。</span></span><br></pre></td></tr></table></figure><h3 id="6-8-用-fsarchiver-创建全盘镜像"><a href="#6-8-用-fsarchiver-创建全盘镜像" class="headerlink" title="6.8 用 fsarchiver 创建全盘镜像"></a>6.8 用 fsarchiver 创建全盘镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件系统/分区备份。</span></span><br><span class="line"><span class="comment"># 使用fsarchiver的savefs选项：</span></span><br><span class="line">$ fsarchiver savefs backup.fsa /dev/sda1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时备份多个分区。</span></span><br><span class="line">$ fsarchiver savefs backup.fsa /dev/sda1 /dev/sda2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份归档中恢复分区。</span></span><br><span class="line">$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1</span><br><span class="line"><span class="comment"># id=0 表 明 我 们 希 望 从 备 份 归 档 中 提 取 第 一 个 分 区 的 内 容 ， 将 其 恢 复 到 由 dest=/dev/sda1所指定的分区中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份归档中恢复多个分区。</span></span><br><span class="line"><span class="comment"># 像之前一样，使用restfs选项：</span></span><br><span class="line">$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1 id=1,dest=/dev/sdb1</span><br></pre></td></tr></table></figure><h2 id="7-无网不利"><a href="#7-无网不利" class="headerlink" title="7 无网不利"></a>7 无网不利</h2><h3 id="7-1-设置网络"><a href="#7-1-设置网络" class="headerlink" title="7.1 设置网络"></a>7.1 设置网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动设置网络接口的IP地址：</span></span><br><span class="line">$ ifconfig wlan0 192.168.0.80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用以下命令设置比IP地址的子网掩码：</span></span><br><span class="line">$ ifconfig wlan0 192.168.0.80 netmask 255.255.252.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动配置网络接口</span></span><br><span class="line">$ dhclient eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印网络接口列表</span></span><br><span class="line">$ ifconfig | cut -c-10 | tr -d <span class="string">' '</span> | tr -s <span class="string">'\n'</span></span><br><span class="line">lo</span><br><span class="line">wlan0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示IP地址</span></span><br><span class="line">$ ifconfig wlan0 | egrep -o <span class="string">"inet addr:[^ ]*"</span> | grep -o <span class="string">"[0-9.]*"</span></span><br><span class="line">192.168.0.82</span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬件地址（MAC地址）欺骗</span></span><br><span class="line">$ ifconfig eth0 hw ether 00:1c:bf:87:25:d5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 名字服务器与DNS（域名服务）</span></span><br><span class="line">$ cat /etc/resolv.conf</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line"><span class="comment"># 我们可以像下面这样手动添加名字服务器：</span></span><br><span class="line">$ <span class="built_in">echo</span> nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS查找</span></span><br><span class="line">$ host google.com</span><br><span class="line">google.com has address 64.233.181.105</span><br><span class="line">google.com has address 64.233.181.99</span><br><span class="line">google.com has address 64.233.181.147</span><br><span class="line">google.com has address 64.233.181.106</span><br><span class="line">google.com has address 64.233.181.103</span><br><span class="line">google.com has address 64.233.181.104</span><br><span class="line"></span><br><span class="line">$ nslookup google.com</span><br><span class="line">Server: 8.8.8.8</span><br><span class="line">Address: 8.8.8.8<span class="comment">#53</span></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.105</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.99</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.147</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.106</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.103</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.104</span><br><span class="line">Server: 8.8.8.8</span><br><span class="line"><span class="comment"># 上面最后一行对应着用于DNS解析的默认名字服务器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用DNS服务器，也可以为IP地址解析添加符号名，这只需要向文件 /etc/hosts中加入条目即可。</span></span><br><span class="line"><span class="comment"># 用下面的方法进行添加：</span></span><br><span class="line">$ <span class="built_in">echo</span> IP_ADDRESS symbolic_name &gt;&gt; /etc/hosts</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ <span class="built_in">echo</span> 192.168.0.9 backupserver &gt;&gt; /etc/hosts</span><br><span class="line"><span class="comment"># 添加了条目之后，任何时候解析backupserver，都会返回192.168.0.9。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示路由表信息</span></span><br><span class="line">$ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref UseIface</span><br><span class="line">192.168.0.0 * 255.255.252.0 U 2 0 0wlan0</span><br><span class="line">link-local * 255.255.0.0 U 1000 0 0wlan0</span><br><span class="line">default p4.local 0.0.0.0 UG 0 0 0wlan0</span><br><span class="line"><span class="comment"># 也可以使用：</span></span><br><span class="line">$ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref Use Iface</span><br><span class="line">192.168.0.0 0.0.0.0 255.255.252.0 U 2 0 0 wlan0</span><br><span class="line">169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 wlan0</span><br><span class="line">0.0.0.0 192.168.0.4 0.0.0.0 UG 0 0 0 wlan0</span><br><span class="line"><span class="comment"># -n指定以数字形式显示地址。如果使用-n， route会以数字形式的IP地址显示每一个条目；否则，如果IP地址具有对应的DNS条目，就会显示符号形式的主机名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认网关：</span></span><br><span class="line">$ route add default gw 192.168.0.1 wlan0</span><br></pre></td></tr></table></figure><h3 id="7-2-traceroute-命令"><a href="#7-2-traceroute-命令" class="headerlink" title="7.2 traceroute 命令"></a>7.2 traceroute 命令</h3><p>traceroute，它可以显示分组途径的所有网关的地址。 traceroute信息可以帮助我们搞明白分组到达目的地需要经过多少跳（hop）。中途的网关或路由器的数量给出了一个测量网络上两个节点之间距离的度量<br>（metric）。 traceroute的输出如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ traceroute google.com</span><br><span class="line">traceroute to google.com (74.125.77.104), 30 hops max, 60 byte packets</span><br><span class="line">1 gw-c6509.lxb.as5577.net (195.26.4.1) 0.313 ms 0.371 ms 0.457 ms</span><br><span class="line">2 40g.lxb-fra.as5577.net (83.243.12.2) 4.684 ms 4.754 ms 4.823 ms</span><br><span class="line">3 de-cix10.net.google.com (80.81.192.108) 5.312 ms 5.348 ms 5.327 ms</span><br><span class="line">4 209.85.255.170 (209.85.255.170) 5.816 ms 5.791 ms 209.85.255.172</span><br><span class="line">(209.85.255.172) 5.678 ms</span><br><span class="line">5 209.85.250.140 (209.85.250.140) 10.126 ms 9.867 ms 10.754 ms</span><br><span class="line">6 64.233.175.246 (64.233.175.246) 12.940 ms 72.14.233.114</span><br><span class="line">(72.14.233.114) 13.736 ms 13.803 ms</span><br><span class="line">7 72.14.239.199 (72.14.239.199) 14.618 ms 209.85.255.166</span><br><span class="line">(209.85.255.166) 12.755 ms 209.85.255.143 (209.85.255.143) 13.803 ms</span><br><span class="line">8 209.85.255.98 (209.85.255.98) 22.625 ms 209.85.255.110</span><br><span class="line">(209.85.255.110) 14.122 ms</span><br><span class="line">*</span><br><span class="line">9 ew-in-f104.1e100.net (74.125.77.104) 13.061 ms 13.256 ms 13.484 ms</span><br></pre></td></tr></table></figure><h3 id="7-3-列出网络上所有的活动主机-fping"><a href="#7-3-列出网络上所有的活动主机-fping" class="headerlink" title="7.3 列出网络上所有的活动主机 (fping)"></a>7.3 列出网络上所有的活动主机 (fping)</h3><p>fping的选项如下： </p><ul><li>选项 -a指定打印出所有活动主机的IP地址； </li><li>选项 -u指定打印出所有无法到达的主机； </li><li>选项 -g指定从 “IP地址/子网掩码”记法或者”IP地址范围”记法中生成一组IP地址； </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ fping -a 192.160.1/24 -g</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ fping -a 192.160.1 192.168.0.255 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以用已有的命令行工具来查询网络上的主机状态：</span></span><br><span class="line">$ fping -a 192.160.1/24 -g 2&gt; /dev/null</span><br><span class="line">192.168.0.1</span><br><span class="line">192.168.0.90</span><br><span class="line"><span class="comment"># 或者，使用：</span></span><br><span class="line">$ fping -a 192.168.0.1 192.168.0.255 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;/dev/null将由于主机无法到达所产生的错误信息打印到null设备。</span></span><br><span class="line">$ fping -a 192.168.0.1 192.168.0.5 192.168.0.6</span><br><span class="line"><span class="comment"># 将IP地址作为参数传递</span></span><br><span class="line">$ fping -a &lt; ip.list</span><br><span class="line"><span class="comment"># 从文件中传递一组IP地址</span></span><br></pre></td></tr></table></figure><h3 id="7-4-ssh-命令"><a href="#7-4-ssh-命令" class="headerlink" title="7.4 ssh 命令"></a>7.4 ssh 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SSH的压缩功能,选项-C启用这一功能：</span></span><br><span class="line">$ ssh -C user@hostname COMMANDS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据重定向至远程shell命令的stdin</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'text'</span> | ssh user@remote_host <span class="string">'echo'</span></span><br><span class="line">text</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 将文件中的数据进行重定向</span></span><br><span class="line">$ ssh user@remote_host <span class="string">'echo'</span> &lt; file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在远程主机中执行图形化命令</span></span><br><span class="line"><span class="comment"># 对此，你需要像这样设置变量$DISPLAY：</span></span><br><span class="line">$ ssh user@host <span class="string">"export DISPLAY=:0 ; command1; command2"</span><span class="string">""</span></span><br><span class="line"><span class="comment"># 这将启用远程主机上的图形化输出。如果你想在本地主机上也显示图形化输出，使用SSH的X11转发选项（forwarding option）：</span></span><br><span class="line">$ ssh -X user@host <span class="string">"command1; command2</span></span><br></pre></td></tr></table></figure><h3 id="7-5-通过网络传输文件"><a href="#7-5-通过网络传输文件" class="headerlink" title="7.5 通过网络传输文件"></a>7.5 通过网络传输文件</h3><p>计算机联网的主要目的就是资源共享。在资源共享方面，使用最多的是文件共享。有多种方法可以用来在网络中传输文件。这则攻略就讨论了如何用常见的协议FTP、 SFTP、 RSYNC和SCP传输文件。 </p><p>通过FTP传输文件可以使用lftp命令，通过SSH连接传输文件可以使用sftp， RSYNC使用SSH与rsync命令， scp通过SSH进行传输。 </p><p><strong>文件传输协议（File Transfer Protocol， FTP） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要连接FTP服务器传输文件，可以使用：</span></span><br><span class="line">$ lftp username@ftphost</span><br><span class="line"><span class="comment"># 它会提示你输入密码，然后显示一个像下面那样的登录提示符：</span></span><br><span class="line">lftp username@ftphost:~&gt;</span><br></pre></td></tr></table></figure><p>你可以在提示符后输入命令，如下所示。 </p><ul><li>用cd directory改变目录。 </li><li>用lcd改变本地主机的目录。 </li><li>用mkdir创建目录。 </li><li>列出远程机器当前目录下的文件使用Is。 </li><li>用get filename下载文件：<br><code>lftp username@ftphost:~&gt; get filename</code></li><li>用put filename从当前目录上传文件：<br><code>lftp username@ftphost:~&gt; put filename</code></li><li>用quit退出lftp会话。 </li></ul><p><strong>FTP自动传输 ：</strong></p><p>ftp是另一个可用于FTP文件传输的命令。相比较而言， lftp的用法更灵活。 lftp和ftp为用户启动一个交互式会话（通过显示消息来提示用户输入）。 </p><p><strong>SFTP（Secure FTP，安全FTP） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/slynux</span><br><span class="line">$ put testfile.jpg</span><br><span class="line">$ get serverfile.jpg</span><br><span class="line"><span class="comment"># 运行sftp：</span></span><br><span class="line">$ sftp user@domainname</span><br></pre></td></tr></table></figure><p><strong>rsync命令 ：</strong></p><p>rsync广泛用于网络文件复制及系统备份。 </p><p><strong>SCP（Secure Copy Program，安全复制程序） ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp filename user@remotehost:/home/path</span><br><span class="line"></span><br><span class="line">$ scp user@remotehost:/home/path/filename filename</span><br></pre></td></tr></table></figure><p>用SCP进行递归复制 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r /home/slynux user@remotehost:/home/backups</span><br><span class="line"><span class="comment"># 将目录/home/slynux递归复制到远程主机中</span></span><br><span class="line"><span class="comment"># scp的 -p 选项能够在复制文件的同时保留文件的权限和模式。</span></span><br></pre></td></tr></table></figure><h3 id="7-6-连接网线网络"><a href="#7-6-连接网线网络" class="headerlink" title="7.6 连接网线网络"></a>7.6 连接网线网络</h3><p>我们需要用ifconfig分配IP地址和子网掩码才能连接上有线网络。对于无线网络来说，还需要其他工具（如iwconfig和iwlist）来配置更多的参数。 </p><p>iwlist工具扫描并列出可用的无线网络。用下面的命令进行扫描： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ iwlist scan</span><br><span class="line">wlan0 Scan completed :</span><br><span class="line">Cell 01 - Address: 00:12:17:7B:1C:65</span><br><span class="line">Channel:11</span><br><span class="line">Frequency:2.462 GHz (Channel 11)</span><br><span class="line">Quality=33/70 Signal level=-77 dBm</span><br><span class="line">                    Encryption key:on</span><br><span class="line">ESSID:<span class="string">"model-2"</span></span><br></pre></td></tr></table></figure><h3 id="7-7-在本地挂载点上挂载远程驱动器"><a href="#7-7-在本地挂载点上挂载远程驱动器" class="headerlink" title="7.7 在本地挂载点上挂载远程驱动器"></a>7.7 在本地挂载点上挂载远程驱动器</h3><p>sshfs允许你将远程文件系统挂载到本地挂载点上。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将位于远程主机上的文件系统挂载到本地挂载点上：</span></span><br><span class="line">$ sshfs -o allow_other user@remotehost:/home/path /mnt/mountpoint</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成任务后，可用下面的方法卸载：</span></span><br><span class="line">$ umount /mnt/mountpoint</span><br></pre></td></tr></table></figure><h3 id="7-8-网络流量与端口分析"><a href="#7-8-网络流量与端口分析" class="headerlink" title="7.8 网络流量与端口分析"></a>7.8 网络流量与端口分析</h3><p>列出系统中的开放端口以及运行在端口上的服务的详细信息，可以使用以下命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要列出本地主机当前的开放端口，可以使用：</span></span><br><span class="line">$ lsof -i | grep <span class="string">":[0-9]\+-&gt;"</span> -o | grep <span class="string">"[0-9]\+"</span> -o | sort | uniq</span><br></pre></td></tr></table></figure><p>用netstat查看开放端口与服务 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -tnp列出开放端口与服务：</span></span><br><span class="line">$ netstat -tnp</span><br></pre></td></tr></table></figure><h3 id="7-9-创建套接字"><a href="#7-9-创建套接字" class="headerlink" title="7.9 创建套接字"></a>7.9 创建套接字</h3><p>最简单的方法就是使用netcat命令（或nc）。我们需要两个套接字：一个用来侦听，一个用来连接。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置侦听套接字：</span></span><br><span class="line">$ nc -l 1234</span><br><span class="line"><span class="comment"># 这会在本地主机的端口1234上创建一个侦听套接字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到该套接字：</span></span><br><span class="line">$ nc HOST 1234</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想发送消息，只需要在执行第2步操作的主机终端中输入信息并按回车键就行了。消息会出现在执行第1步操作的主机终端中。</span></span><br></pre></td></tr></table></figure><p>在网络上进行快速文件复制 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在接收端执行下列命令：</span></span><br><span class="line">$ nc -l 1234 &gt; destination_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在发送端执行下列命令：</span></span><br><span class="line">$ nc HOST 1234 &lt; source_filename</span><br></pre></td></tr></table></figure><h3 id="7-10-iptables防火墙设置"><a href="#7-10-iptables防火墙设置" class="headerlink" title="7.10 iptables防火墙设置"></a>7.10 iptables防火墙设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阻塞发送到特定IP地址的流量：</span></span><br><span class="line">$ iptables -A OUTPUT -d 8.8.8.8 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞发送到特定端口的流量：</span></span><br><span class="line">$ iptables -A OUTPUT -p tcp -dport 21 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment">#  iptables中的第一个选项-A表明向链（chain）中添加一条新的规则，该规则由后续参数给出。OUTPUT链，它可以对所有出站（outgoing）的流量进行控制。-d指定了所要匹配的分组目的地址。-j来使iptables丢弃（DROP）符合条件的分组。-p指定该规则是适用于TCP， -dport指定了对应的端口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除对iptables链所做出的所有改动。</span></span><br><span class="line">$ iptables --flush</span><br></pre></td></tr></table></figure><h2 id="8-当个好管家"><a href="#8-当个好管家" class="headerlink" title="8 当个好管家"></a>8 当个好管家</h2><h3 id="8-1-监视磁盘使用情况"><a href="#8-1-监视磁盘使用情况" class="headerlink" title="8.1 监视磁盘使用情况"></a>8.1 监视磁盘使用情况</h3><p><code>df</code> 是disk free的缩写， <code>du</code> 是disk usage的缩写。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出某个文件（或多个文件）占用的磁盘空间：</span></span><br><span class="line">$ du file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要获得某个目录中所有文件的磁盘使用情况，并在每一行中显示各个文件的磁盘占用详情，可以使用：</span></span><br><span class="line">$ du -a DIRECTORY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以KB、 MB或块（block）为单位显示磁盘使用情况</span></span><br><span class="line">$ du -h FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示磁盘使用总计, -c 可以输出作为命令参数的所有文件和目录的磁盘使用情况</span></span><br><span class="line">$ du -c process_log.shpcpu.sh</span><br><span class="line">4 process_log.sh</span><br><span class="line">4 pcpu.sh</span><br><span class="line">8 total</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s（summarize，合计）则只输出合计数据。它可以配合 -h打印出人们易读的格式。</span></span><br><span class="line">$ du -sh slynux</span><br><span class="line">680K slynux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以字节（默认输出）为单位的文件大小：</span></span><br><span class="line">$ du -b FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以KB为单位的文件大小：</span></span><br><span class="line">$ du -k FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以MB为单位的文件大小：</span></span><br><span class="line">$ du -m FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印以指定块为单位的文件大小：</span></span><br><span class="line">$ du -B BLOCK_SIZE FILE(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从磁盘使用统计中排除部分文件</span></span><br><span class="line">$ du --exclude <span class="string">"*.txt"</span> FILES(s)</span><br><span class="line"><span class="comment"># 排除所有的.txt文件</span></span><br><span class="line">$ du --exclude-from EXCLUDE.txt DIRECTORY</span><br><span class="line"><span class="comment"># EXCLUDE.txt包含了需要排除的文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --max-depth指定du应该遍历的目录层次的最大深度。</span></span><br><span class="line">$ du --max-depth 2 DIRECTORY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出指定目录中最大的10个文件</span></span><br><span class="line">$ du -ak /home/slynux | sort -nrk 1 | head -n 4</span><br><span class="line"></span><br><span class="line">$ find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> du -k &#123;&#125; \; | sort -nrk 1 | head</span><br></pre></td></tr></table></figure><p>du提供磁盘使用情况信息，而df提供磁盘可用空间信息。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem Size Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1 9.2G 2.2G 6.6G 25% /</span><br><span class="line">none 497M 240K 497M 1% /dev</span><br><span class="line">none 502M 168K 501M 1% /dev/shm</span><br><span class="line">none 502M 88K 501M 1% /var/run</span><br><span class="line">none 502M 0 502M 0% /var/lock</span><br><span class="line">none 502M 0 502M 0% /lib/init/rw</span><br><span class="line">none 9.2G 2.2G 6.6G 25% /var/lib/ureadahead/debugfs</span><br></pre></td></tr></table></figure><h3 id="8-2-计算命令执行时间"><a href="#8-2-计算命令执行时间" class="headerlink" title="8.2 计算命令执行时间"></a>8.2 计算命令执行时间</h3><ul><li>real: %e </li><li>user: %U </li><li>sys: %S </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ time COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用选项-o filename将相关的时间统计信息写入文件：</span></span><br><span class="line">$ /usr/bin/time -o output.txt COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将命令执行时间添加到文件而不影响其原有内容，使用选项-a以及-o：</span></span><br><span class="line">$ /usr/bin/time -a -o output.txt COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建格式化输出：</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Time: %U"</span> -a -o timing.log uname</span><br><span class="line">Linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用错误重定向操作符（2&gt;）对时间信息重定向。</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Time: %U"</span> uname&gt; command_output.txt 2&gt;time.log</span><br><span class="line">$ cat time.log</span><br><span class="line">Time: 0.00</span><br><span class="line">$ cat command_output.txt</span><br><span class="line">Linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用参数%Z显示系统页面大小：</span></span><br><span class="line">$ /usr/bin/time -f <span class="string">"Page size: %Z bytes"</span> ls&gt; /dev/null</span><br><span class="line">Page size: 4096 bytes</span><br></pre></td></tr></table></figure><p>三种不同类型的时：</p><ul><li>Real时间指的是挂钟时间（wall clock time），也就是命令从开始执行到结束的时间。这段时间包括其他进程所占用的时间片（time slice）以及进程被阻塞时所花费的时间（例如，为等待I/O操作完成所用的时间）。 </li><li>User时间是指进程花费在用户模式（内核之外）中的CPU时间。这是唯一真正用于执行进程所花费的时间。执行其他进程以及花费在阻塞状态中的时间并没有计算在内。 </li><li>Sys时间是指进程花费在内核中的CPU时间。它代表在内核中执行系统调用所使用的时间，这和库代码（library code）不同，后者仍旧运行在用户空间。与“user时间”类似，这也是真正由进程使用的CPU时间。 </li></ul><p>time命令 一些可以使用的参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>%C</td><td>进行计时的命令名称以及命令行参数</td></tr><tr><td>%D</td><td>进程非共享数据区域的大小，以KB为单位</td></tr><tr><td>%E</td><td>进程使用的real时间（挂钟时间），显示格式为[小时:]分钟:秒</td></tr><tr><td>%x</td><td>命令的退出状态</td></tr><tr><td>%k</td><td>进程接收到的信号数量</td></tr><tr><td>%W</td><td>进程被交换出主存的次数</td></tr><tr><td>%Z</td><td>系统的页面大小。这是一个系统常量，但在不同的系统中，这个常量值也不同</td></tr><tr><td>%P</td><td>进程所获得的CPU时间百分比。这个值等于user+system时间除以总运行时间。结果以百分比形式显示</td></tr><tr><td>%K</td><td>进程的平均总（data+stack+text）内存使用量，以KB为单位</td></tr><tr><td>%w</td><td>进程主动进行上下文切换的次数，例如等待I/O操作完成</td></tr><tr><td>%c</td><td>进程被迫进行上下文切换的次数（由于时间片到期）</td></tr></tbody></table><h3 id="8-3-收集与当前登录用户、启动日志及启动故障的相关信息"><a href="#8-3-收集与当前登录用户、启动日志及启动故障的相关信息" class="headerlink" title="8.3 收集与当前登录用户、启动日志及启动故障的相关信息"></a>8.3 收集与当前登录用户、启动日志及启动故障的相关信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前登录用户的相关信息：</span></span><br><span class="line">$ who</span><br><span class="line">slynux pts/0 2010-09-29 05:24 (slynuxs-macbook-pro.local)</span><br><span class="line">slynux tty7 2010-09-29 07:08 (:0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得有关登录用户更详细的信息：</span></span><br><span class="line">$ w</span><br><span class="line">  07:09:05 up 1:45, 2 users, load average: 0.12, 0.06, 0.02</span><br><span class="line">USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</span><br><span class="line">slynux pts/0 slynuxs 05:24 0.00s 0.65s 0.11s sshd: slynux</span><br><span class="line">slynux tty7 :007:08 1:45m 3.28s 0.26s gnome-session</span><br><span class="line"><span class="comment"># 第一行列出了当前时间，系统运行时间，当前登录的用户数量以及过去的1分钟、 5分钟、 15分钟内的系统平均负载。接下来的每一行显示了每一个登录用户的详细信息，其中包括登录名、 TTY、远程主机、登录时间、空闲时间、自该用户登录后所使用的总CPU时间、当前运行进程所使用的CPU时间以及进程所对应的命令行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录主机的用户列表：</span></span><br><span class="line">$ users</span><br><span class="line">slynux slynux slynux hacker</span><br><span class="line">$ users | tr <span class="string">' '</span> <span class="string">'\n'</span> | sort | uniq</span><br><span class="line">slynux</span><br><span class="line">hacker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统已经加电运行了多长时间：</span></span><br><span class="line">$ uptime</span><br><span class="line">21:44:33 up 3:17, 8 users, load average: 0.09, 0.14, 0.09</span><br><span class="line">$ uptime | grep -Po <span class="string">'\d&#123;2&#125;\:\d&#123;2&#125;\:\d&#123;2&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取上一次启动以及用户登录会话的信息：</span></span><br><span class="line">$ last</span><br><span class="line">slynux tty7 :0 Tue Sep 28 18:27 still logged <span class="keyword">in</span></span><br><span class="line">reboot system boot 2.6.32-21-generic Tue Sep 28 18:10 - 21:46 (03:35)</span><br><span class="line">slynux pts/0 :0.0 Tue Sep 28 05:31 - crash (12:39)</span><br><span class="line"><span class="comment"># last命令可以提供登录会话信息。它实际上是一个系统登录日志，包括了登录tty、登录时间、状态等信息。</span></span><br><span class="line"><span class="comment"># last命令以日志文件/var/log/wtmp作为输入日志数据。它也可以用选项-f明确地指定日志文件。例如：</span></span><br><span class="line">$ last -f /var/<span class="built_in">log</span>/wtmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个用户登录会话的信息：</span></span><br><span class="line">$ last USER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取重启会话（reboot session）信息：</span></span><br><span class="line">$ last reboot</span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 18:10 - 21:48 (03:37)</span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 05:14 - 21:48 (16:33)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取失败的用户登录会话信息：</span></span><br><span class="line">$ lastb</span><br><span class="line"><span class="built_in">test</span> tty8 :0 Wed Dec 15 03:56 - 03:56 (00:00)</span><br><span class="line">slynux tty8 :0 Wed Dec 15 03:55 - 03:55 (00:00)</span><br></pre></td></tr></table></figure><h3 id="8-4-使用-watch-监视命令输出"><a href="#8-4-使用-watch-监视命令输出" class="headerlink" title="8.4 使用 watch 监视命令输出"></a>8.4 使用 watch 监视命令输出</h3><p>watch命令可以用来在终端中以固定的间隔监视命令输出。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ watch ls</span><br><span class="line"></span><br><span class="line">$ watch <span class="string">'ls -l | grep "^d"'</span></span><br><span class="line"><span class="comment"># 只列出目录</span></span><br><span class="line"><span class="comment"># 命令默认每2秒更新一次输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -n SECOND指定更新输出的时间间隔。例如：</span></span><br><span class="line">$ watch -n 5 <span class="string">'ls -l'</span></span><br><span class="line"><span class="comment"># 以5秒为间隔，监视ls -l的输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 突出标示watch输出中的差异, -d 可以启用这一功能：</span></span><br><span class="line">$ watch -d <span class="string">'COMMANDS'</span></span><br></pre></td></tr></table></figure><h3 id="8-5-用-logrotate-管理日志文件"><a href="#8-5-用-logrotate-管理日志文件" class="headerlink" title="8.5 用 logrotate 管理日志文件"></a>8.5 用 logrotate 管理日志文件</h3><p>用一种被称为轮替（rotation）的技术来限制日志文件的体积，一旦它超过了限定的大小，就对其内容进行抽取（strip），同时将 日志文件中的旧条目存储到日志目录中的归档文件内。旧的日志文件就会得以保存以便随后参阅。 </p><p><code>logrotate</code> 的配置目录位于/etc/logrotate.d。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/logrotate.d/program</span><br><span class="line">/var/<span class="built_in">log</span>/program.log &#123;</span><br><span class="line">missingok</span><br><span class="line">notifempty</span><br><span class="line">size 30k</span><br><span class="line">compress</span><br><span class="line">weekly</span><br><span class="line">rotate 5</span><br><span class="line">create 0600 root root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中各个参数的含义：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>missingok</td><td>如果日志文件丢失，则忽略；然后返回（不对日志文件进行轮替）</td></tr><tr><td>notifempty</td><td>仅当源日志文件非空时才对其进行轮替</td></tr><tr><td>size 30k</td><td>限制实施轮替的日志文件的大小。可以用1M表示1MB</td></tr><tr><td>compress</td><td>允许用gzip压缩较旧的日志</td></tr><tr><td>weekly</td><td>指定进行轮替的时间间隔。可以是weekly、 yearly或daily</td></tr><tr><td>rotate 5</td><td>这是需要保留的旧日志文件的归档数量。在这里指定的是5，所以这些文件名将会是program.log.1.gz、 program.log.2.gz等直到program.log.5.gz</td></tr><tr><td>create 0600 root root</td><td>指定所要创建的归档文件的模式、用户以及用户组</td></tr></tbody></table><h3 id="8-6-用-syslog-记录日志"><a href="#8-6-用-syslog-记录日志" class="headerlink" title="8.6 用 syslog 记录日志"></a>8.6 用 syslog 记录日志</h3><p>每一个标准应用进程都可以利用syslog记录日志信息。 </p><p>使用命令logger通过syslogd记录日志。 </p><p>Linux中一些重要的日志文件 ：</p><table><thead><tr><th>日志文件</th><th>描述</th></tr></thead><tbody><tr><td>/var/log/boot.log</td><td>系统启动信息</td></tr><tr><td>/var/log/httpd</td><td>Apache Web服务器日志</td></tr><tr><td>/var/log/messages</td><td>发布内核启动信息</td></tr><tr><td>/var/log/auth.log</td><td>用户认证日志</td></tr><tr><td>/var/log/dmesg</td><td>系统启动信息</td></tr><tr><td>/var/log/mail.log</td><td>邮件服务器日志</td></tr><tr><td>/var/log/Xorg.0.log</td><td>X服务器日志</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向系统日志文件/var/log/message中写入日志信息：</span></span><br><span class="line">$ logger This is a <span class="built_in">test</span> <span class="built_in">log</span> line</span><br><span class="line">$ tail -n 1 /var/<span class="built_in">log</span>/messages</span><br><span class="line">Sep 29 07:47:44 slynux-laptop slynux: This is a <span class="built_in">test</span> <span class="built_in">log</span> line</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果要记录特定的标记（tag），可以使用：</span></span><br><span class="line">$ logger -t TAG This is a message</span><br><span class="line">$ tail -n 1 /var/<span class="built_in">log</span>/messages</span><br><span class="line">Sep 29 07:48:42 slynux-laptop TAG: This is a message</span><br><span class="line"><span class="comment"># 但是当logger发送消息时，它用标记字符串来确定应该记录到哪一个日志文件中。 syslogd使用与日志相关联的TAG来决定应该将其记录到哪一个文件中。你可以从/etc/rsyslog.d/目录下的配置文件中看到标记字符串以及与其相关联的日志文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要将另一个日志文件的最后一行记录到系统日志中，可以使用：</span></span><br><span class="line">$ logger -f /var/<span class="built_in">log</span>/source.log</span><br></pre></td></tr></table></figure><h3 id="8-7-通过监视用户登录找出入侵者"><a href="#8-7-通过监视用户登录找出入侵者" class="headerlink" title="8.7 通过监视用户登录找出入侵者"></a>8.7 通过监视用户登录找出入侵者</h3><p>入侵者定义为：屡次试图登入系统达两分钟以上，并且期间的登录过程全部失败。凡是这类用户都应该被检测出来并生成包含以下细节信息的报告： </p><ul><li>试图登录的账户 </li><li>试图登录的次数 </li><li>攻击者的IP地址 </li><li>IP地址所对应的主机 </li><li>进行登录的时间段 </li></ul><p>为了处理SSH登录失败的情况，还得知道用户认证会话日志会被记录在日志文件/var/log/auth.log中。脚本需要扫描这个日志文件来检测出失败的登录信息，执行各种检查来获取所需要的数据。我们可以用host命令找出IP地址所对应的主机。 </p><h3 id="8-8-监视磁盘活动"><a href="#8-8-监视磁盘活动" class="headerlink" title="8.8 监视磁盘活动"></a>8.8 监视磁盘活动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互式监视, iotop的-o选项只显示出那些正在进行I/O活动的进程：</span></span><br><span class="line">$ iotop -o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于shell脚本的非交互式用法：</span></span><br><span class="line">$ iotop -b -n 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视特定进程</span></span><br><span class="line">$ iotop -p PID</span><br></pre></td></tr></table></figure><h3 id="8-9-检查磁盘及文件系统错误"><a href="#8-9-检查磁盘及文件系统错误" class="headerlink" title="8.9 检查磁盘及文件系统错误"></a>8.9 检查磁盘及文件系统错误</h3><p>使用fsck的各种选项对文件系统错误进行检查和修复。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要检查分区或文件系统的错误，只需要将路径作为fsck的参数：</span></span><br><span class="line">$ fsck /dev/sdb3</span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">e2fsck 1.42.5 (29-Jul-2012)</span><br><span class="line">HDD2 has been mounted 26 <span class="built_in">times</span> without being checked, check forced.</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">HDD2: 75540/16138240 files (0.7% non-contiguous), 48756390/64529088 blocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查/etc/fstab中所配置的所有文件系统：</span></span><br><span class="line">$ fsck -A</span><br><span class="line"><span class="comment"># 该命令会依次检查/etc/fstab中列出的文件系统。 fstab文件对磁盘及其挂载点之间的映射关系进行了配置，以便于更便捷地挂载文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定fsck自动修复错误，无需询问是否进行修复：</span></span><br><span class="line">$ fsck -a /dev/sda2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟fsck要执行的操作：</span></span><br><span class="line">$ fsck -AN</span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /] fsck.ext4 /dev/sda8</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /home] fsck.ext4 /dev/sda7</span><br><span class="line">[/sbin/fsck.ext3 (1) -- /media/Data] fsck.ext3 /dev/sda6</span><br></pre></td></tr></table></figure><h2 id="9-管理重任"><a href="#9-管理重任" class="headerlink" title="9 管理重任"></a>9 管理重任</h2><h3 id="9-1-收集进程信息"><a href="#9-1-收集进程信息" class="headerlink" title="9.1 收集进程信息"></a>9.1 收集进程信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了包含更多的信息，可以使用-f（表示full）来显示多列，如下所示：</span></span><br><span class="line">$ ps -f</span><br><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">slynux 1220 1219 0 18:18 pts/0 00:00:00 -bash</span><br><span class="line">slynux 1587 1220 0 18:59 pts/0 00:00:00 ps -f</span><br><span class="line"><span class="comment"># 使用选项 -e（every）。选项-ax（all）也可以生成同样的输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行如下命令之一： ps –e， ps –ef， ps -ax或ps –axf。</span></span><br><span class="line">$ ps -e | head</span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1 ? 00:00:00 init</span><br><span class="line">2 ? 00:00:00 kthreadd</span><br><span class="line">3 ? 00:00:00 migration/0</span><br><span class="line">4 ? 00:00:00 ksoftirqd/0</span><br><span class="line">5 ? 00:00:00 watchdog/0</span><br><span class="line">6 ? 00:00:00 events/0</span><br><span class="line">7 ? 00:00:00 cpuset</span><br><span class="line">8 ? 00:00:00 khelper</span><br><span class="line">9 ? 00:00:00 netns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 -o 来指定想要显示的列，以便只打印出我们需要的内容。</span></span><br><span class="line"><span class="comment"># -o 的参数以逗号操作符（,）作为定界符。值得注意的是，逗号操作符与它分隔的参数之间是没有空格的。</span></span><br><span class="line"><span class="comment"># -e和过滤器结合使用没有任何实际效果，依旧会显示所有的进程。</span></span><br><span class="line"><span class="comment"># 示例如下，其中comm表示COMMAND， pcpu表示CPU占用率：</span></span><br><span class="line">$ ps -eo comm,pcpu | head</span><br><span class="line">COMMAND %CPU</span><br><span class="line">init 0.0</span><br><span class="line">kthreadd 0.0</span><br><span class="line">migration/0 0.0</span><br><span class="line">ksoftirqd/0 0.0</span><br><span class="line">watchdog/0 0.0</span><br><span class="line">events/0 0.0</span><br><span class="line">cpuset 0.0</span><br><span class="line">khelper 0.0</span><br><span class="line">netns 0.0</span><br></pre></td></tr></table></figure><p>选项-o可以使用不同的参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pcpu</td><td>CPU占用率</td></tr><tr><td>pid</td><td>进程ID</td></tr><tr><td>ppid</td><td>父进程ID</td></tr><tr><td>pmem</td><td>内存使用率</td></tr><tr><td>comm</td><td>可执行文件名</td></tr><tr><td>cmd</td><td>简单命令</td></tr><tr><td>user</td><td>启动进程的用户</td></tr><tr><td>nice</td><td>优先级</td></tr><tr><td>time</td><td>累计的CPU时间</td></tr><tr><td>etime</td><td>进程启动后流逝的时间</td></tr><tr><td>tty</td><td>所关联的TTY设备</td></tr><tr><td>euid</td><td>有效用户ID</td></tr><tr><td>stat</td><td>进程状态</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top, 默认会输出一个占用CPU最多的进程列表。输出结果每隔几秒就会更新。</span></span><br><span class="line">$ top</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据参数对ps输出进行排序</span></span><br><span class="line">$ ps -eo comm,pcpu --sort -pcpu | head</span><br><span class="line">COMMAND %CPU</span><br><span class="line">Xorg 0.1</span><br><span class="line">hald-addon-stor 0.0</span><br><span class="line">ata/0 0.0</span><br><span class="line">scsi_eh_0 0.0</span><br><span class="line">gnome-settings- 0.0</span><br><span class="line">init 0.0</span><br><span class="line">hald 0.0</span><br><span class="line">pulseaudio 0.0</span><br><span class="line">gdm-simple-gree 0.0</span><br><span class="line">$ ps -eo comm,pid,pcpu,pmem | grep bash</span><br><span class="line">bash 1255 0.0 0.3</span><br><span class="line">bash 1680 5.5 0.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出给定命令名所对应的进程ID，在参数后加上=就可以移除列名。</span></span><br><span class="line">$ ps -C bash -o pid=</span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line">$ pgrep bash</span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用换行符作为定界符，而是要自行指定可以像下面这样：</span></span><br><span class="line">$ pgrep bash -d <span class="string">":"</span></span><br><span class="line">1255:1680</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定进程的用户（拥有者）列表：</span></span><br><span class="line">$ pgrep -u root,slynux COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据真实用户或ID以及有效用户或ID过滤ps输出</span></span><br><span class="line"> 用 -u EUSER1,EUSER2 …，指定有效用户列表；</span><br><span class="line"> 用 -U RUSER1,RUSER2 …，指定真实用户列表</span><br><span class="line">$ ps -u root -U root -o user,pcpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用TTY过滤ps输出, 可以通过指定进程所属的TTY选择ps的输出。用选项 -t指定TTY列表：</span></span><br><span class="line">$ ps -t pts/0,pts/1</span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1238 pts/0 00:00:00 bash</span><br><span class="line">1835 pts/1 00:00:00 bash</span><br><span class="line">1864 pts/0 00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程线程的相关信息</span></span><br><span class="line"><span class="comment"># 通常与进程线程相关的信息在ps输出中是看不到的。我们可以用选项 –L 在ps输出中显示线程的相关信息。这会显示出两列： NLWP和NLP。 NLWP是进程的线程数量， NLP是ps输出中每个条目的线程ID。例如：</span></span><br><span class="line">$ ps -eLf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出宽度以及所要显示的列</span></span><br><span class="line"><span class="comment"># 可以按照你自己的使用方式来进行应用。尝试以下选项:</span></span><br><span class="line"> -f ps –ef</span><br><span class="line"> u ps -e u</span><br><span class="line"> ps ps -e w（w表示宽松输出）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示进程的环境变量</span></span><br><span class="line"><span class="comment"># 了解某个进程依赖哪些环境变量，这类信息我们通常都用得着。进程的运行方式可能极其依赖某组环境变量。我们可以利用环境变量调试并修复与进程相关的问题。</span></span><br><span class="line">$ ps -eo pid,cmd e | tail -n 3</span><br><span class="line">1162 hald-addon-acpi: listening on acpid socket /var/run/acpid.socket</span><br><span class="line">1172 sshd: slynux [priv]</span><br><span class="line">1237 sshd: slynux@pts/0</span><br><span class="line">1238 -bash USER=slynux LOGNAME=slynux HOME=/home/slynux</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</span><br><span class="line">MAIL=/var/mail/slynux SHELL=/bin/bash SSH_CLIENT=10.211.55.2 49277 22</span><br><span class="line">SSH_CONNECTION=10.211.55.2 49277 10.211.55.4 22 SSH_TTY=/dev/pts/0 TERM=xterm-color</span><br><span class="line">LANG=en_IN XDG_SESSION_COOKIE=d1e96f5cc8a7a3bc3a0a73e44c95121a-1286499339.</span><br><span class="line">592429-1573657095</span><br></pre></td></tr></table></figure><h3 id="9-2-which、-whereis、-file、-whatis与平均负载"><a href="#9-2-which、-whereis、-file、-whatis与平均负载" class="headerlink" title="9.2 which、 whereis、 file、 whatis与平均负载"></a>9.2 which、 whereis、 file、 whatis与平均负载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># which, which命令用来找出某个命令的位置。</span></span><br><span class="line">$ <span class="built_in">which</span> ls</span><br><span class="line">/bin/ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis</span></span><br><span class="line"><span class="comment"># whereis与which命令类似，但它不仅返回命令的路径，还能够打印出其对应的命令手册的位置以及命令源代码的路径（如果有的话）</span></span><br><span class="line">$ whereis ls</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># file</span></span><br><span class="line">$ file FILENAME</span><br><span class="line"><span class="comment"># 该命令会打印出与该文件类型相关的细节信息。</span></span><br><span class="line">$ file /bin/ls</span><br><span class="line">/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked</span><br><span class="line">(uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.15, stripped</span><br><span class="line"></span><br><span class="line"><span class="comment"># whatis, whatis命令会输出作为参数的命令的简短描述信息。</span></span><br><span class="line">$ whatis ls</span><br><span class="line">ls (1) - list directory contents</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平均负载</span></span><br><span class="line">$ uptime</span><br><span class="line">12:40:53 up 6:16, 2 users, load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure><h3 id="9-3-杀死进程以及发送或响应信号"><a href="#9-3-杀死进程以及发送或响应信号" class="headerlink" title="9.3 杀死进程以及发送或响应信号"></a>9.3 杀死进程以及发送或响应信号</h3><p>信号是Linux中的一种进程间通信机制。 当进程接收到一个信号时，它会通过执行对应的信号处理程序（signal handler）来进行响应。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有可用的信号：</span></span><br><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止进程：</span></span><br><span class="line">$ <span class="built_in">kill</span> PROCESS_ID_LIST</span><br><span class="line"><span class="comment"># kill命令默认发出一个TERM信号。进程ID列表使用空格作为进程ID之间的定界符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要通过kill命令向进程发送指定的信号，可以使用：</span></span><br><span class="line">$ <span class="built_in">kill</span> -s SIGNAL PID</span><br><span class="line"><span class="comment"># 参数SIGNAL要么是信号名称，要么是信号编号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们经常要强行杀死进程，可以使用：</span></span><br><span class="line">$ <span class="built_in">kill</span> -s SIGKILL PROCESS_ID</span><br><span class="line">或者</span><br><span class="line">$ <span class="built_in">kill</span> -9 PROCESS_ID</span><br></pre></td></tr></table></figure><p>常用到的信号量：</p><ul><li>SIGHUP 1——对控制进程或终端的终结进行挂起检测（hangup detection）</li><li>SIGINT 2——当按下Ctrl + C时发送该信号 </li><li>SIGKILL 9——用于强行杀死进程 </li><li>SIGTERM 15——默认用于终止进程 </li><li>SIGTSTP 20——当按下Ctrl + Z时发送该信号 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># killall命令通过命令名终止进程：</span></span><br><span class="line">$ killall process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称向进程发送信号：</span></span><br><span class="line">$ killall -s SIGNAL process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称强行杀死进程：</span></span><br><span class="line">$ killall -9 process_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># pkill命令和kill命令类似，不过默认情况下pkill接受的是进程名，而非进程ID。例如：</span></span><br><span class="line">$ pkill process_name</span><br><span class="line">$ pkill -s SIGNAL process_name</span><br><span class="line"><span class="comment"># pkill不支持信号名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕捉并响应信号</span></span><br><span class="line"><span class="comment"># trap命令在脚本中用来为信号分配信号处理程序。</span></span><br><span class="line">$ <span class="built_in">trap</span> <span class="string">'signal_handler_function_name'</span> SIGNAL LIST</span><br></pre></td></tr></table></figure><h3 id="9-4-向用户终端发送消息"><a href="#9-4-向用户终端发送消息" class="headerlink" title="9.4 向用户终端发送消息"></a>9.4 向用户终端发送消息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wall命令用来向当前所有登录用户的终端写入消息。</span></span><br><span class="line">$ cat message | wall</span><br><span class="line">或者</span><br><span class="line">$ wall&lt; message</span><br><span class="line">Broadcast Message from slynux@slynux-laptop</span><br><span class="line">(/dev/pts/1) at 12:54 ...</span><br><span class="line">This is a messag</span><br></pre></td></tr></table></figure><h3 id="9-5-采集系统信息"><a href="#9-5-采集系统信息" class="headerlink" title="9.5 采集系统信息"></a>9.5 采集系统信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印当前系统的主机名：</span></span><br><span class="line">$ hostname</span><br><span class="line">或者</span><br><span class="line">$ uname -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印Linux内核版本、硬件架构等详细信息：</span></span><br><span class="line">$ uname -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内核发行版本：</span></span><br><span class="line">$ uname -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印主机类型：</span></span><br><span class="line">$ uname -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印CPU相关信息：</span></span><br><span class="line">$ cat /proc/cpuinfo</span><br><span class="line"><span class="comment"># 获取处理器名称：</span></span><br><span class="line">$ cat /proc/cpuinfo | sed -n 5p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内存的详细信息：</span></span><br><span class="line">$ cat /proc/meminfo</span><br><span class="line"><span class="comment"># 打印系统可用内存总量：</span></span><br><span class="line">$ cat /proc/meminfo | head -1</span><br><span class="line">MemTotal: 1026096 kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出系统的分区信息：</span></span><br><span class="line">$ cat /proc/partitions</span><br><span class="line">或者</span><br><span class="line">$ fdisk -l <span class="comment">#如果没有输出，切换到root用户执行该命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取系统的详细信息：</span></span><br><span class="line">$ lshw <span class="comment">#建议以root用户来执行</span></span><br></pre></td></tr></table></figure><h3 id="9-6-使用-proc-采集信息"><a href="#9-6-使用-proc-采集信息" class="headerlink" title="9.6 使用 proc 采集信息"></a>9.6 使用 proc 采集信息</h3><p>以Bash为例，它的进程ID是4295（pgrep bash），那么就会有一个对应的目录/proc/4295。进程对应的目录中包含了大量有关进程的信息。 /proc/PID中一些重要的文件如下所示。 </p><ul><li><p>environ：包含与进程相关的环境变量。使用cat /proc/4295/environ，可以显示所有传递给该进程的环境变量 </p></li><li><p>cwd： 是一个到进程工作目录（working directory）的符号链接 </p></li><li><p>exe：是一个到当前进程所对应的可执行文件的符号链接 </p><p>$ readlink /proc/4295/exe<br>/bin/bash</p></li><li><p>fd：包含了进程所使用的文件描述符 </p></li></ul><h3 id="9-7-用-cron-进行调度"><a href="#9-7-用-cron-进行调度" class="headerlink" title="9.7 用 cron 进行调度"></a>9.7 用 cron 进行调度</h3><p><strong>crontab任务配置基本格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  *　 *　 *　   *　　command</span><br><span class="line">分钟(0-59)　小时(0-23)　日期(1-31)　 月份(1-12)　星期(0-6,0代表星期天)　  命令</span><br></pre></td></tr></table></figure><p>cron表中的每一个条目都由6部分组成，并按照下列顺序排列： </p><ul><li>分钟（0～59） </li><li>小时（0～23） </li><li>天（1～31） </li><li>月份（1～12） </li><li>工作日（0～6） </li><li>命令（在指定时间执行的脚本或命令） </li></ul><p>星号（*）指定命令应该在每个时间段执行。 </p><p>除了数字还有几个个特殊的符号就是 <code>&quot;*&quot;</code> 、<code>&quot;/&quot;</code> 和 <code>&quot;-&quot;</code> 、<code>&quot;,&quot;</code> ，<code>*</code> 代表所有的取值范围内的数字，<code>&quot;/&quot;</code> 代表每的意思, <code>&quot;*/5&quot;</code> 表示每5个单位，<code>&quot;-&quot;</code> 代表从某个数字到某个数字, <code>&quot;,&quot;</code> 分开几个离散的数字。以下举几个例子说明问题： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定每小时的第5分钟执行一次ls命令</span></span><br><span class="line">5 * * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每天的 5:30 执行ls命令</span></span><br><span class="line">30 5 * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每月8号的7：30分执行ls命令</span></span><br><span class="line">30 7 8 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每年的6月8日5：30执行ls命令</span></span><br><span class="line">30 5 8 6 * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定每星期日的6:30执行ls命令 [ 注：0表示星期天，1表示星期1，以此类推，也可以用英文来表示，sun表示星期天，mon表示星期一等。 ]</span></span><br><span class="line">30 6 * * 0 ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月10号及20号的3：30执行ls命令 [注：“，”用来连接多个不连续的时段 ]</span></span><br><span class="line">30 3 10,20 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天8-11点的第25分钟执行ls命令 [注：“-”用来连接连续的时段 ]</span></span><br><span class="line">25 8-11 * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每15分钟执行一次ls命令 [即每个小时的第0 15 30 45 60分钟执行ls命令 ]</span></span><br><span class="line">*/15 * * * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个月中，每隔10天6:30执行一次ls命令[即每月的1、11、21、31日是的6：30执行一次ls命令。 ]</span></span><br><span class="line">30 6 */10 * * ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天7：50以root 身份执行/etc/cron.daily目录中的所有可执行文件</span></span><br><span class="line">50 7 * * * root run-parts /etc/cron.daily   <span class="comment"># [ 注：run-parts参数表示，执行后面目录中的所有可执行文件。 ]</span></span><br></pre></td></tr></table></figure><p><strong>配置用户定时任务的语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ crontab [-u user]file</span><br><span class="line"></span><br><span class="line">$ crontab -u user[-i]</span><br></pre></td></tr></table></figure><p>参数与说明：</p><ul><li>crontab -u        //设定某个用户的cron服务</li><li>crontab -l        //列出某个用户cron服务的详细内容</li><li>crontab -r              //删除没个用户的cron服务</li><li>crontab -e             //编辑某个用户的cron服务</li></ul><h3 id="9-8-从终端截图"><a href="#9-8-从终端截图" class="headerlink" title="9.8 从终端截图"></a>9.8 从终端截图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取整个屏幕：</span></span><br><span class="line">$ import -window root screenshot.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动选择部分区域进行抓取：</span></span><br><span class="line">$ import screenshot.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取特定窗口：</span></span><br><span class="line">$ import -window window_id screenshot.png</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本命令&quot;&gt;&lt;a href=&quot;#1-基本命令&quot; class=&quot;headerlink&quot; title=&quot;1. 基本命令&quot;&gt;&lt;/a&gt;1. 基本命令&lt;/h2&gt;&lt;h3 id=&quot;1-1-shell-格式输出&quot;&gt;&lt;a href=&quot;#1-1-shell-格式输出&quot; class=&quot;headerlink&quot; title=&quot;1.1 shell 格式输出&quot;&gt;&lt;/a&gt;1.1 shell 格式输出&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Hello world !&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n	&lt;span class=&quot;comment&quot;&gt;# 忽略结尾的换行符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-e	&lt;span class=&quot;comment&quot;&gt;# 激活转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-E	&lt;span class=&quot;comment&quot;&gt;# disable转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; -e &lt;span class=&quot;string&quot;&gt;&quot;1\t2\t3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://miaopei.github.io/categories/Shell/"/>
    
    
      <category term="shell" scheme="http://miaopei.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令eval的用法</title>
    <link href="http://miaopei.github.io/2017/04/13/Linux%E5%91%BD%E4%BB%A4eval%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://miaopei.github.io/2017/04/13/Linux命令eval的用法/</id>
    <published>2017-04-13T11:50:19.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eval-command-line"><a href="#eval-command-line" class="headerlink" title="eval command-line"></a>eval command-line</h2><p>其中command－line是在终端上键入的一条普通命令行。<strong>然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次</strong>。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pipe=<span class="string">"|"</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> ls <span class="variable">$pipe</span> wc -l</span><br></pre></td></tr></table></figure><p>shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。</p><p><strong>如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（；｜ &amp;），I／o重定向符（&lt; &gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。</strong></p><a id="more"></a><h2 id="eval-echo-取得最后一个参数"><a href="#eval-echo-取得最后一个参数" class="headerlink" title="eval echo $$# 取得最后一个参数"></a>eval echo $$# 取得最后一个参数</h2><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat last</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $<span class="variable">$#</span></span><br><span class="line"></span><br><span class="line">$ ./last one two three four</span><br><span class="line">four</span><br></pre></td></tr></table></figure><p>第一遍扫描后，shell把反斜杠去掉了。当shell再次扫描该行时，它替换了$4的值，并执行echo命令</p><h2 id="以下示意如何用eval命令创建指向变量的“指针”："><a href="#以下示意如何用eval命令创建指向变量的“指针”：" class="headerlink" title="以下示意如何用eval命令创建指向变量的“指针”："></a>以下示意如何用eval命令创建指向变量的“指针”：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ x=100</span><br><span class="line"></span><br><span class="line">$ ptrx=x</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> <span class="built_in">echo</span> $<span class="variable">$ptrx</span>  <span class="comment">#指向ptrx，用这里的方法可以理解b中的例子</span></span><br><span class="line">100 打印100</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">eval</span> <span class="variable">$ptrx</span>=50  <span class="comment">#将50存到ptrx指向的变量中。</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">50 打印50</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;eval-command-line&quot;&gt;&lt;a href=&quot;#eval-command-line&quot; class=&quot;headerlink&quot; title=&quot;eval command-line&quot;&gt;&lt;/a&gt;eval command-line&lt;/h2&gt;&lt;p&gt;其中command－line是在终端上键入的一条普通命令行。&lt;strong&gt;然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次&lt;/strong&gt;。如：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pipe=&lt;span class=&quot;string&quot;&gt;&quot;|&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;eval&lt;/span&gt; ls &lt;span class=&quot;variable&quot;&gt;$pipe&lt;/span&gt; wc -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（；｜ &amp;amp;），I／o重定向符（&amp;lt; &amp;gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://miaopei.github.io/categories/Shell/"/>
    
    
      <category term="Linux Shell" scheme="http://miaopei.github.io/tags/Linux-Shell/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议原理分析</title>
    <link href="http://miaopei.github.io/2017/04/13/HTTP%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://miaopei.github.io/2017/04/13/HTTP协议原理分析/</id>
    <published>2017-04-13T04:26:05.000Z</published>
    <updated>2019-06-03T08:10:56.878Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1oMTI1MDYvYXJ0aWNsZS9kZXRhaWxzLzc3OTQ1MTI=" title="http://blog.csdn.net/lmh12506/article/details/7794512">深入理解HTTP协议、HTTP协议原理分析<i class="fa fa-external-link"></i></span></p><h3 id="基础概念篇"><a href="#基础概念篇" class="headerlink" title="基础概念篇"></a>基础概念篇</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。</p><a id="more"></a><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><h4 id="在TCP-IP协议栈中的位置"><a href="#在TCP-IP协议栈中的位置" class="headerlink" title="在TCP/IP协议栈中的位置"></a>在TCP/IP协议栈中的位置</h4><p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：</p><p><img src="http://i.imgur.com/mvKKFdQ.jpg" alt></p><p>默认HTTP的端口号为80，HTTPS的端口号为443。</p><h4 id="HTTP的请求响应模型"><a href="#HTTP的请求响应模型" class="headerlink" title="HTTP的请求响应模型"></a>HTTP的请求响应模型</h4><p>HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：</p><p><img src="http://i.imgur.com/1p1vQjT.jpg" alt></p><p>这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p><p>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><p>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</p><p>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p><p>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p><p>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p><h4 id="使用Wireshark抓TCP、http包"><a href="#使用Wireshark抓TCP、http包" class="headerlink" title="使用Wireshark抓TCP、http包"></a>使用Wireshark抓TCP、http包</h4><p>打开Wireshark，选择工具栏上的“Capture”-&gt;“Options”。</p><p>一般读者只需要选择最上边的下拉框，选择合适的Device，而后点击“Capture Filter”，此处选择的是“HTTP TCP port（80）”，选择后点击上图的“Start”开始抓包。</p><p>例如在浏览器中打开 <span class="exturl" data-url="aHR0cDovL2ltYWdlLmJhaWR1LmNvbS/vvIzmipPljIXlpoLkuIvlm77miYDnpLrvvJo=" title="http://image.baidu.com/，抓包如下图所示：">http://image.baidu.com/，抓包如下图所示：<i class="fa fa-external-link"></i></span></p><p><img src="http://i.imgur.com/1Ss1ckI.jpg" alt></p><p>在上图中，可清晰的看到客户端浏览器（ip为192.168.2.33）与服务器的交互过程：</p><p>1）No1：浏览器（192.168.2.33）向服务器（220.181.50.118）发出连接请求。此为TCP三次握手第一步，此时从图中可以看出，为SYN，seq:X （x=0）</p><p>2）No2：服务器（220.181.50.118）回应了浏览器（192.168.2.33）的请求，并要求确认，此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）。此为三次握手的第二步；</p><p>3）No3：浏览器（192.168.2.33）回应了服务器（220.181.50.118）的确认，连接成功。为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。此为三次握手的第三步；</p><p>4）No4：浏览器（192.168.2.33）发出一个页面HTTP请求；</p><p>5）No5：服务器（220.181.50.118）确认；</p><p>6）No6：服务器（220.181.50.118）发送数据；</p><p>7）No7：客户端浏览器（192.168.2.33）确认；</p><p>8）No14：客户端（192.168.2.33）发出一个图片HTTP请求；</p><p>9）No15：服务器（220.181.50.118）发送状态响应码200 OK</p><p>……</p><h4 id="头域"><a href="#头域" class="headerlink" title="头域"></a>头域</h4><p>每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p><p>在抓包的图中，No14点开可看到如下图所示：</p><p><img src="http://i.imgur.com/p2B4j3L.jpg" alt></p><p>回应的消息如下图所示：</p><p><img src="http://i.imgur.com/W0pbbs1.jpg" alt></p><h5 id="host头域"><a href="#host头域" class="headerlink" title="host头域"></a>host头域</h5><p>Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。</p><p>上图中host那行为：</p><p><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-6.jpg" alt="img"> </p><h5 id="Referer头域"><a href="#Referer头域" class="headerlink" title="Referer头域"></a>Referer头域</h5><p>Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。</p><p>在图4中，Referer行的内容为：<br>   <img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-7.jpg" alt="img"></p><h5 id="User-Agent头域"><a href="#User-Agent头域" class="headerlink" title="User-Agent头域"></a>User-Agent头域</h5><p>User-Agent头域的内容包含发出请求的用户信息。</p><p>在图4中，User-Agent行的内容为：</p><p><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-8.jpg" alt="img"></p><h5 id="Cache-Control头域"><a href="#Cache-Control头域" class="headerlink" title="Cache-Control头域"></a>Cache-Control头域</h5><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。</p><p>在图5中的该头域为：<br><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-9.jpg" alt="img"> </p><h5 id="Date头域"><a href="#Date头域" class="headerlink" title="Date头域"></a>Date头域</h5><p>Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p><p>图5中，该头域如下图所示：<br><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-10.jpg" alt="img"> </p><h4 id="HTTP的几个重要概念"><a href="#HTTP的几个重要概念" class="headerlink" title="HTTP的几个重要概念"></a>HTTP的几个重要概念</h4><h5 id="连接：connection"><a href="#连接：connection" class="headerlink" title="连接：connection"></a>连接：connection</h5><p>一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。</p><p>在http1.1，request和reponse头中都有可能出现一个connection的头，此header的含义是当client和server通信时对于长链接如何进行处理。</p><p>在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</p><h5 id="消息：Message"><a href="#消息：Message" class="headerlink" title="消息：Message"></a>消息：Message</h5><p>HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。</p><h5 id="请求：Request"><a href="#请求：Request" class="headerlink" title="请求：Request"></a>请求：Request</h5><p>一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号。</p><h5 id="响应：Response"><a href="#响应：Response" class="headerlink" title="响应：Response"></a>响应：Response</h5><p>一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。</p><h5 id="资源：Resource"><a href="#资源：Resource" class="headerlink" title="资源：Resource"></a>资源：Resource</h5><p>由URI标识的网络数据对象或服务。</p><h5 id="实体：Entity"><a href="#实体：Entity" class="headerlink" title="实体：Entity"></a>实体：Entity</h5><p>数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。</p><h5 id="客户机：Client"><a href="#客户机：Client" class="headerlink" title="客户机：Client"></a>客户机：Client</h5><p>一个为发送请求目的而建立连接的应用程序。</p><h5 id="用户代理：UserAgent"><a href="#用户代理：UserAgent" class="headerlink" title="用户代理：UserAgent"></a>用户代理：UserAgent</h5><p>初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。</p><h5 id="服务器：Server"><a href="#服务器：Server" class="headerlink" title="服务器：Server"></a>服务器：Server</h5><p>一个接受连接并对请求返回信息的应用程序。</p><h5 id="源服务器：Originserver"><a href="#源服务器：Originserver" class="headerlink" title="源服务器：Originserver"></a>源服务器：Originserver</h5><p>是一个给定资源可以在其上驻留或被创建的服务器。</p><h5 id="代理：Proxy"><a href="#代理：Proxy" class="headerlink" title="代理：Proxy"></a>代理：Proxy</h5><p>一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。</p><p>代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p><h5 id="网关：Gateway"><a href="#网关：Gateway" class="headerlink" title="网关：Gateway"></a>网关：Gateway</h5><p>一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。</p><p>网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</p><h5 id="通道：Tunnel"><a href="#通道：Tunnel" class="headerlink" title="通道：Tunnel"></a>通道：Tunnel</h5><p>是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p><h5 id="缓存：Cache"><a href="#缓存：Cache" class="headerlink" title="缓存：Cache"></a>缓存：Cache</h5><p>反应信息的局域存储。</p><h4 id="附录：参考资料"><a href="#附录：参考资料" class="headerlink" title="附录：参考资料"></a>附录：参考资料</h4><p><a href="[http://baike.baidu.com/view/9472.htm](http://baike.baidu.com/view/9472.htm)">ttp_百度百科</a></p><p><a href="[http://blog.tieniu1980.cn/archives/377](http://blog.tieniu1980.cn/archives/377)">结果编码和http状态响应码</a></p><p><a href="[http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763104c8c711923d030678197027fa3c215cc7905141130a8e5747e0d548d9](http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763104c8c711923d030678197027fa3c215cc7905141130a8e5747e0d548d98297a5ae91e03f7f63772315477e3cacdd94cdbbdc42225d82c36734f844315c419d891007a9f34d507a9f916a2e1b065d2f48193864353bb15543897f1fb4d711edd1b86033093b1e94e022e67adec40728e2e605f983431c5508fe4&p=c6769a46c5820efd08e2973b42&user=baidu)">分析TCP的三次握手</a></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuMTYzLmNvbS93YW5nYm9fdGVzdGVyL2Jsb2cvc3RhdGljLzEyODA2NzkyMTIwMDk4MTc0MTYyMjg4Lw==" title="http://blog.163.com/wangbo_tester/blog/static/12806792120098174162288/">使用Wireshark来检测一次HTTP连接过程<i class="fa fa-external-link"></i></span></p><p><a href="[http://nc.mofcom.gov.cn/news/10819972.html](http://nc.mofcom.gov.cn/news/10819972.html)">http协议的几个重要概念</a></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFyZm9vL2FyY2hpdmUvMjAwOC8wNi8wNS8yNTE0NjY3LmFzcHg=" title="http://blog.csdn.net/barfoo/archive/2008/06/05/2514667.aspx">http协议中connection头的作用<i class="fa fa-external-link"></i></span></p><h3 id="协议详解篇"><a href="#协议详解篇" class="headerlink" title="协议详解篇"></a>协议详解篇</h3><h4 id="HTTP-1-0和HTTP-1-1的比较"><a href="#HTTP-1-0和HTTP-1-1的比较" class="headerlink" title="HTTP/1.0和HTTP/1.1的比较"></a>HTTP/1.0和HTTP/1.1的比较</h4><p>RFC 1945定义了HTTP/1.0版本，RFC 2616定义了HTTP/1.1版本。</p><p>笔者在blog上提供了这两个RFC中文版的下载地址。</p><p>RFC1945下载地址：</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ibG9namF2YVsuTmV0XShodHRwOi8vbGliLmNzZG4ubmV0L2Jhc2UvZG90bmV0KS9GaWxlcy9hbWlnb3hpZS9SRkMxOTQ1" title="http://www.blogjava[.Net](http://lib.csdn.net/base/dotnet)/Files/amigoxie/RFC1945">（HTTP）中文版.rar<i class="fa fa-external-link"></i></span></p><p>RFC2616下载地址：</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ibG9namF2YS5uZXQvRmlsZXMvYW1pZ294aWUvUkZDMjYxNg==" title="http://www.blogjava.net/Files/amigoxie/RFC2616">（HTTP）中文版.rar<i class="fa fa-external-link"></i></span></p><h5 id="建立连接方面"><a href="#建立连接方面" class="headerlink" title="建立连接方面"></a>建立连接方面</h5><p>HTTP/1.0 每次请求都需要建立新的TCP连接，连接不能复用。HTTP/1.1 新的请求可以在上次请求建立的TCP连接之上发送，连接可以复用。优点是减少重复进行TCP三次握手的开销，提高效率。</p><p>注意：在同一个TCP连接中，新的请求需要等上次请求收到响应后，才能发送。</p><h5 id="Host域"><a href="#Host域" class="headerlink" title="Host域"></a>Host域</h5><p>HTTP1.1在Request消息头里头多了一个Host域, HTTP1.0则没有这个域。</p><p>Eg：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">    GET /pub/WWW/TheProject.html HTTP/1.1<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">    Host: <span class="exturl" data-url="aHR0cDovL3d3dy53My5vcmc=" title="http://www.w3.org">www.w3.org<i class="fa fa-external-link"></i></span></p><p>​    可能HTTP1.0的时候认为，建立TCP连接的时候已经指定了IP地址，这个IP地址上只有一个host。</p><h5 id="日期时间戳"><a href="#日期时间戳" class="headerlink" title="日期时间戳"></a>日期时间戳</h5><p>(接收方向)</p><p>无论是HTTP1.0还是HTTP1.1，都要能解析下面三种date/time stamp：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Sun, 06 Nov 1994 08:49:37 GMT ; RFC 822, updated by RFC 1123<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Sun Nov 6 08:49:37 1994       ; ANSI C’s asctime() format</p><p>(发送方向)</p><p>HTTP1.0要求不能生成第三种asctime格式的date/time stamp；</p><p>HTTP1.1则要求只生成RFC 1123(第一种)格式的date/time stamp。</p><h5 id="状态响应码"><a href="#状态响应码" class="headerlink" title="状态响应码"></a>状态响应码</h5><p>状态响应码100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p><p>客户端在Request头部中包含</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Expect: 100-continue</p><p>​       Server看到之后呢如果回100 (Continue) 这个状态代码，客户端就继续发request body。这个是HTTP1.1才有的。</p><p>另外在HTTP/1.1中还增加了101、203、205等等性状态响应码</p><h5 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h5><p>HTTP1.1增加了OPTIONS, PUT, DELETE, TRACE, CONNECT这些Request方法.</p><p>​       Method         = “<strong>OPTIONS</strong>“                ; Section 9.2</p><p>​                      | “GET”                    ; Section 9.3</p><p>​                      | “HEAD”                   ; Section 9.4</p><p>​                      | “POST”                   ; Section 9.5</p><p>​                      | “<strong>PUT</strong>“                    ; Section 9.6</p><p>​                      | “<strong>DELETE</strong>“                 ; Section 9.7</p><p>​                      | “<strong>TRACE</strong>“                  ; Section 9.8</p><p>​                      | “<strong>CONNECT</strong>“                ; Section 9.9</p><p>​                      | extension-method</p><p>​       extension-method = token</p><h4 id="HTTP请求消息"><a href="#HTTP请求消息" class="headerlink" title="HTTP请求消息"></a>HTTP请求消息</h4><h5 id="请求消息格式"><a href="#请求消息格式" class="headerlink" title="请求消息格式"></a>请求消息格式</h5><p>请求消息格式如下所示：</p><blockquote><p> 请求行</p></blockquote><blockquote><p> 通用信息头|请求头|实体头</p></blockquote><blockquote><p> CRLF(回车换行)</p></blockquote><blockquote><p> 实体内容</p></blockquote><blockquote><p> 其中“请求行”为：请求行 = 方法 [空格] 请求URI [空格] 版本号 [回车换行]</p></blockquote><p>请求行实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Eg1：</span><br><span class="line">GET /index.html HTTP/1.1</span><br><span class="line"></span><br><span class="line">Eg2：</span><br><span class="line">POST http://192.168.2.217:8080/index.jsp HTTP/1.1</span><br><span class="line"></span><br><span class="line">HTTP请求消息实例：</span><br><span class="line">GET /hello.htm HTTP/1.1</span><br><span class="line">Accept: /</span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">If-Modified-Since: Wed, 17 Oct 2007 02:15:55 GMT</span><br><span class="line">If-None-Match: W/&quot;158-1192587355000&quot;</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)</span><br><span class="line">Host: 192.168.2.162:8080</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>HTTP的请求方法包括如下几种：</p><p><strong><code>GET</code></strong></p><p><strong><code>POST</code></strong></p><p><strong><code>HEAD</code></strong></p><p><strong><code>PUT</code></strong></p><p><strong><code>DELETE</code></strong></p><p><strong><code>OPTIONS</code></strong></p><p><strong><code>TRACE</code></strong></p><p><strong><code>CONNECT</code></strong></p><h4 id="HTTP响应消息"><a href="#HTTP响应消息" class="headerlink" title="HTTP响应消息"></a>HTTP响应消息</h4><h5 id="响应消息格式"><a href="#响应消息格式" class="headerlink" title="响应消息格式"></a>响应消息格式</h5><p>HTTP响应消息的格式如下所示：</p><blockquote><p> 状态行</p></blockquote><blockquote><p> 通用信息头|响应头|实体头</p></blockquote><blockquote><p> CRLF</p></blockquote><blockquote><p> 实体内容</p></blockquote><blockquote><p> 其中：状态行 = 版本号 [空格] 状态码 [空格] 原因 [回车换行]</p></blockquote><p>状态行举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Eg1：</span><br><span class="line">HTTP/1.0 200 OK </span><br><span class="line"></span><br><span class="line">Eg2：</span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">     </span><br><span class="line">HTTP响应消息实例如下所示：</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">ETag: W/&quot;158-1192590101000&quot;</span><br><span class="line">Last-Modified: Wed, 17 Oct 2007 03:01:41 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 158</span><br><span class="line">Date: Wed, 17 Oct 2007 03:01:59 GMT</span><br><span class="line">Server: Apache-Coyote/1.1</span><br></pre></td></tr></table></figure><h5 id="htpp的状态响应码"><a href="#htpp的状态响应码" class="headerlink" title="htpp的状态响应码"></a>htpp的状态响应码</h5><h6 id="1-：请求收到，继续处理"><a href="#1-：请求收到，继续处理" class="headerlink" title="1**：请求收到，继续处理"></a>1**：请求收到，继续处理</h6><p>100——客户必须继续发出请求</p><p>101——客户要求服务器根据请求转换HTTP协议版本</p><h6 id="2-：操作成功收到，分析、接受"><a href="#2-：操作成功收到，分析、接受" class="headerlink" title="2**：操作成功收到，分析、接受"></a>2**：操作成功收到，分析、接受</h6><p>200——交易成功</p><p>201——提示知道新文件的URL</p><p>202——接受和处理、但处理未完成</p><p>203——返回信息不确定或不完整</p><p>204——请求收到，但返回信息为空</p><p>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</p><p>206——服务器已经完成了部分用户的GET请求</p><h6 id="3-：完成此请求必须进一步处理"><a href="#3-：完成此请求必须进一步处理" class="headerlink" title="3**：完成此请求必须进一步处理"></a>3**：完成此请求必须进一步处理</h6><p>300——请求的资源可在多处得到</p><p>301——删除请求数据</p><p>302——在其他地址发现了请求数据</p><p>303——建议客户访问其他URL或访问方式</p><p>304——客户端已经执行了GET，但文件未变化</p><p>305——请求的资源必须从服务器指定的地址得到</p><p>306——前一版本HTTP中使用的代码，现行版本中不再使用</p><p>307——申明请求的资源临时性删除</p><h6 id="4-：请求包含一个错误语法或者不能完成"><a href="#4-：请求包含一个错误语法或者不能完成" class="headerlink" title="4**：请求包含一个错误语法或者不能完成"></a>4**：请求包含一个错误语法或者不能完成</h6><p>400——错误请求，如语法错误</p><p>401——未授权</p><p>HTTP 401.1 - 未授权：登录失败</p><p>　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败</p><p>　　HTTP 401.3 - ACL 禁止访问资源</p><p>　　HTTP 401.4 - 未授权：授权被筛选器拒绝</p><p>HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</p><p>402——保留有效ChargeTo头响应</p><p>403——禁止访问</p><p>HTTP 403.1 禁止访问：禁止可执行访问</p><p>　　HTTP 403.2 - 禁止访问：禁止读访问</p><p>　　HTTP 403.3 - 禁止访问：禁止写访问</p><p>　　HTTP 403.4 - 禁止访问：要求 SSL</p><p>　　HTTP 403.5 - 禁止访问：要求 SSL 128</p><p>　　HTTP 403.6 - 禁止访问：IP 地址被拒绝</p><p>　　HTTP 403.7 - 禁止访问：要求客户证书</p><p>　　HTTP 403.8 - 禁止访问：禁止站点访问</p><p>　　HTTP 403.9 - 禁止访问：连接的用户过多</p><p>　　HTTP 403.10 - 禁止访问：配置无效</p><p>　　HTTP 403.11 - 禁止访问：密码更改</p><p>　　HTTP 403.12 - 禁止访问：映射器拒绝访问</p><p>　　HTTP 403.13 - 禁止访问：客户证书已被吊销</p><p>　　HTTP 403.15 - 禁止访问：客户访问许可过多</p><p>　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效</p><p>HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</p><p>404——没有发现文件、查询或URl</p><p>405——用户在Request-Line字段定义的方法不允许</p><p>406——根据用户发送的Accept拖，请求资源不可访问</p><p>407——类似401，用户必须首先在代理服务器上得到授权</p><p>408——客户端没有在用户指定的饿时间内完成请求</p><p>409——对当前资源状态，请求不能完成</p><p>410——服务器上不再有此资源且无进一步的参考地址</p><p>411——服务器拒绝用户定义的Content-Length属性请求</p><p>412——一个或多个请求头字段在当前请求中错误</p><p>413——请求的资源大于服务器允许的大小</p><p>414——请求的资源URL长于服务器允许的长度</p><p>415——请求资源不支持请求项目格式</p><p>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</p><p>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p><h6 id="5-：服务器执行一个完全有效请求失败"><a href="#5-：服务器执行一个完全有效请求失败" class="headerlink" title="5**：服务器执行一个完全有效请求失败"></a>5**：服务器执行一个完全有效请求失败</h6><p>HTTP 500 - 内部服务器错误</p><p>HTTP 500.100 - 内部服务器错误 - ASP 错误</p><p>HTTP 500-11 服务器关闭</p><p>HTTP 500-12 应用程序重新启动</p><p>HTTP 500-13 - 服务器太忙</p><p>HTTP 500-14 - 应用程序无效</p><p>HTTP 500-15 - 不允许请求 global.asa</p><p>Error 501 - 未实现</p><p>HTTP 502 - 网关错误</p><h4 id="使用Telnet进行http测试"><a href="#使用Telnet进行http测试" class="headerlink" title="使用Telnet进行http测试"></a>使用Telnet进行http测试</h4><p> 在Windows下，可使用命令窗口进行http简单<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL3NvZnR3YXJldGVzdA==" title="http://lib.csdn.net/base/softwaretest">测试<i class="fa fa-external-link"></i></span>。</p><p>输入cmd进入命令窗口，在命令行键入如下命令后按回车：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ telnet www.baicu.com 80</span><br></pre></td></tr></table></figure><p>而后在窗口中按下“Ctrl+]”后按回车可让返回结果回显。</p><p>接着开始发请求消息，例如发送如下请求消息请求baidu的首页消息，使用的HTTP协议为HTTP/1.1：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">GET /index.html HTTP/1.1</p><p>   注意：copy如上的消息到命令窗口后需要按两个回车换行才能得到响应的消息，第一个回车换行是在命令后键入回车换行，是HTTP协议要求的。第二个是确认输入，发送请求。</p><p>可看到返回了200 OK的消息，如下图所示：</p><p><img src="http://i.imgur.com/LcFwiM2.jpg" alt></p><p>可看到，当采用HTTP/1.1时，连接不是在请求结束后就断开的。若采用HTTP1.0，在命令窗口键入：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">GET /index.html HTTP/1.0</p><p>此时可以看到请求结束之后马上断开。</p><p>读者还可以尝试在使用GET或POST等时，带上头域信息，例如键入如下信息：</p><p><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">GET /index.html HTTP/1.1<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">connection: close<br><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">Host: <span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20=" title="http://www.baidu.com">www.baidu.com<i class="fa fa-external-link"></i></span></p><h4 id="常用的请求方式"><a href="#常用的请求方式" class="headerlink" title="常用的请求方式"></a>常用的请求方式</h4><p>常用的请求方式是GET和POST.</p><blockquote><p> <strong>GET方式</strong>：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。</p><p> <strong>POST方式</strong>：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能：</p><blockquote><p>1：对现有资源的解释；</p><p>2：向电子公告栏、新闻组、邮件列表或类似讨论组发信息；</p><p>3：提交数据块；</p><p>4：通过附加操作来扩展<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL215c3Fs" title="http://lib.csdn.net/base/mysql">数据库<i class="fa fa-external-link"></i></span> 。</p></blockquote></blockquote><p>从上面描述可以看出，Get是向服务器发索取数据的一种请求；而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。</p><p>GET与POST方法有以下区别：</p><p>（1）   在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。</p><p>（2）   GET方式提交的数据最多只能有1024字节，而POST则没有此限制。</p><p>（3）   安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。</p><p>（4）   安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比方说文章下面出现一条注解）。</p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>HTTP最常见的请求头如下：</p><p><strong><code>Accept</code></strong>：浏览器可接受的MIME类型；</p><p><strong><code>Accept-Charset</code></strong>：浏览器可接受的字符集；</p><p><strong><code>Accept-Encoding</code></strong>：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间；</p><p><strong><code>Accept-Language</code></strong>：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到；</p><p><strong><code>Authorization</code></strong>：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；</p><p><strong><code>Connection</code></strong>：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；</p><p><strong><code>Content-Length</code></strong>：表示请求消息正文的长度；</p><p><strong><code>Cookie</code></strong>：这是最重要的请求头信息之一；</p><p><strong><code>From</code></strong>：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它；</p><p><strong><code>Host</code></strong>：初始URL中的主机和端口；</p><p><strong><code>If-Modified-Since</code></strong>：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答；</p><p><strong><code>Pragma</code></strong>：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；</p><p><strong><code>Referer</code></strong>：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p><p><strong><code>User-Agent</code></strong>：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用；</p><p><strong><code>UA-Pixels，UA-Color，UA-OS，UA-CPU</code></strong>：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL29wZXJhdGluZ3N5c3RlbQ==" title="http://lib.csdn.net/base/operatingsystem">操作系统<i class="fa fa-external-link"></i></span>和CPU类型。</p><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>HTTP最常见的响应头如下所示：</p><p><strong><code>Allow</code></strong>：服务器支持哪些请求方法（如GET、POST等）；</p><p><strong><code>Content-Encoding</code></strong>：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2phdmFzZQ==" title="http://lib.csdn.net/base/javase">Java<i class="fa fa-external-link"></i></span>的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面；</p><p><strong><code>Content-Length</code></strong>：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容；</p><p><strong><code>Content-Type</code></strong>： 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系；</p><p><strong><code>Date</code></strong>：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦；</p><p><strong><code>Expires</code></strong>：指明应该在什么时候认为文档已经过期，从而不再缓存它。</p><p><strong><code>Last-Modified</code></strong>：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置；</p><p><strong><code>Location</code></strong>：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；</p><p><strong><code>Refresh</code></strong>：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=””)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的&lt;META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=””&gt;实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是&lt;META HTTP-EQUIV=”Refresh” …&gt;。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p><h4 id="实体头"><a href="#实体头" class="headerlink" title="实体头"></a>实体头</h4><p>实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。</p><p><strong><code>Allow</code></strong>：GET,POST</p><p><strong><code>Content-Encoding</code></strong>：文档的编码（Encode）方法，例如：gzip，见“2.5 响应头”；</p><p><strong><code>Content-Language</code></strong>：内容的语言类型，例如：zh-cn；</p><p><strong><code>Content-Length</code></strong>：表示内容长度，eg：80，可参考“2.5响应头”；</p><p><strong><code>Content-Location</code></strong>：表示客户应当到哪里去提取文档，例如：<span class="exturl" data-url="aHR0cDovL3d3dy5kZmRmLm9yZy9kZmRmLmh0bWzvvIzlj6/lj4LogIPigJwyLjXlk43lupTlpLTigJ3vvJs=" title="http://www.dfdf.org/dfdf.html，可参考“2.5响应头”；">http://www.dfdf.org/dfdf.html，可参考“2.5响应头”；<i class="fa fa-external-link"></i></span></p><p><strong><code>Content-MD5</code></strong>：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5: &lt;base64 of 128 MD5 digest&gt;。Eg2：dfdfdfdfdfdfdff==；</p><p><strong><code>Content-Range</code></strong>：随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898</p><p><strong><code>Content-Type</code></strong>：标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312       主类型/子类型；</p><p><strong><code>Expires</code></strong>：为0证明不缓存；</p><p><strong>`Last-Modified</strong>`：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT<strong>.</strong></p><h4 id="扩展头"><a href="#扩展头" class="headerlink" title="扩展头"></a>扩展头</h4><p>在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。</p><p>现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。</p><p><strong><code>Refresh</code></strong>：1;url=<span class="exturl" data-url="aHR0cDovL3d3dy5kZmRmLm9yZw==" title="http://www.dfdf.org">http://www.dfdf.org<i class="fa fa-external-link"></i></span>  //过1秒跳转到指定位置；</p><p><strong><code>Content-Disposition</code></strong>：头字段,可参考“2.5响应头”；</p><p><strong><code>Content-Type</code></strong>：WEB 服务器告诉浏览器自己响应的对象的类型。</p><p>eg1：Content-Type：application/xml ；</p><p>eg2：applicaiton/octet-stream；</p><p><strong>Content-Disposition</strong>：attachment; filename=aaa.zip。</p><h4 id="附录：参考资料-1"><a href="#附录：参考资料-1" class="headerlink" title="附录：参考资料"></a>附录：参考资料</h4><p><a href="[http://blog.csdn.net/yanghehong/archive/2009/05/28/4222594.aspx](http://blog.csdn.net/yanghehong/archive/2009/05/28/4222594.aspx)">HTTP1.1和HTTP1.0的区别</a></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ibG9namF2YS5uZXQvaG9uZXliZWUvYXJ0aWNsZXMvMTY0MDA4Lmh0bWw=" title="http://www.blogjava.net/honeybee/articles/164008.html">HTTP请求（GET和POST区别）和响应<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3poaWRhby5iYWlkdS5jb20vcXVlc3Rpb24vMzI1MTc0MjcuaHRtbA==" title="http://zhidao.baidu.com/question/32517427.html">HTTP请求头概述_百度知道<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS90b25nemhpeW9uZy9hcmNoaXZlLzIwMDgvMDMvMTYvMTEwODc3Ni5odG1s" title="http://www.cnblogs.com/tongzhiyong/archive/2008/03/16/1108776.html">实体头和扩展头实体头和扩展头<i class="fa fa-external-link"></i></span></p><h3 id="深入了解篇"><a href="#深入了解篇" class="headerlink" title="深入了解篇"></a>深入了解篇</h3><h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><p>Cookie和Session都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决HTTP无状态的问题而所做的努力。</p><p>Session可以用Cookie来实现，也可以用URL回写的机制来实现。用Cookie来实现的Session可以认为是对Cookie更高级的应用。</p><h5 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h5><p>Cookie和Session有以下明显的不同点：</p><p>1）Cookie将状态保存在客户端，Session将状态保存在服务器端；</p><p>2）Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。Cookie最早在RFC2109中实现，后续RFC2965做了增强。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。Session并没有在HTTP的协议中定义；</p><p>3）Session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器；</p><p>4）就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的SESSION机制更安全些.因为它不会任意读取客户存储的信息。</p><h5 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h5><p>Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p><p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为 session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个 session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id将被在本次响应中返回给客户端保存。</p><h5 id="Session的实现机制"><a href="#Session的实现机制" class="headerlink" title="Session的实现机制"></a>Session的实现机制</h5><h6 id="使用Cookie来实现"><a href="#使用Cookie来实现" class="headerlink" title="使用Cookie来实现"></a>使用Cookie来实现</h6><p>服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。</p><p>当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID。这样服务器能够找到这个客户端对应的Session。</p><p>流程如下图所示：</p><p><img src="http://i.imgur.com/88bVlwm.jpg" alt></p><h6 id="使用URL回显来实现"><a href="#使用URL回显来实现" class="headerlink" title="使用URL回显来实现"></a>使用URL回显来实现</h6><p>URL回写是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带会服务器。</p><p>如果直接在浏览器输入服务端资源的url来请求该资源，那么Session是匹配不到的。</p><p>Tomcat对Session的实现，是一开始同时使用Cookie和URL回写机制，如果发现客户端支持Cookie，就继续使用Cookie，停止使用URL回写。如果发现Cookie被禁用，就一直使用URL回写。jsp开发处理到Session的时候，对页面中的链接记得使用response.encodeURL() 。</p><h5 id="在J2EE项目中Session失效的几种情况"><a href="#在J2EE项目中Session失效的几种情况" class="headerlink" title="在J2EE项目中Session失效的几种情况"></a>在J2EE项目中Session失效的几种情况</h5><p>1）Session超时：Session在指定时间内失效，例如30分钟，若在30分钟内没有操作，则Session会失效，例如在web.xml中进行了如下设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span> //单位：分钟</span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）使用 <code>session.invalidate()</code> 明确的去掉Session。</p><h5 id="与Cookie相关的HTTP扩展头"><a href="#与Cookie相关的HTTP扩展头" class="headerlink" title="与Cookie相关的HTTP扩展头"></a>与Cookie相关的HTTP扩展头</h5><p>1）<strong>Cookie</strong>：客户端将服务器设置的Cookie返回到服务器；</p><p>2）<strong>Set-Cookie</strong>：服务器向客户端设置Cookie；</p><p>3）<strong>Cookie2</strong> (RFC2965)）：客户端指示服务器支持Cookie的版本；</p><p>4）<strong>Set-Cookie2</strong> (RFC2965)：服务器向客户端设置Cookie。</p><h5 id="Cookie的流程"><a href="#Cookie的流程" class="headerlink" title="Cookie的流程"></a>Cookie的流程</h5><p>服务器在响应消息中用Set-Cookie头将Cookie的内容回送给客户端，客户端在新的请求中将相同的内容携带在Cookie头中发送给服务器。从而实现会话的保持。</p><p>流程如下图所示：</p><p><img src="http://i.imgur.com/FqfZ73s.jpg" alt></p><h4 id="缓存的实现原理"><a href="#缓存的实现原理" class="headerlink" title="缓存的实现原理"></a>缓存的实现原理</h4><h5 id="什么是Web缓存"><a href="#什么是Web缓存" class="headerlink" title="什么是Web缓存"></a>什么是Web缓存</h5><p>WEB缓存(cache)位于Web服务器和客户端之间。</p><p>缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p><p>HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。</p><h5 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a>缓存的优点</h5><blockquote><p> <strong>减少相应延迟</strong>：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让web服务器看上去相应更快。</p></blockquote><blockquote><p> <strong>减少网络带宽消耗</strong>：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。</p></blockquote><h5 id="与缓存相关的HTTP扩展消息头"><a href="#与缓存相关的HTTP扩展消息头" class="headerlink" title="与缓存相关的HTTP扩展消息头"></a>与缓存相关的HTTP扩展消息头</h5><blockquote><p> <strong>Expires</strong>：指示响应内容过期的时间，格林威治时间GMT</p></blockquote><blockquote><p> <strong>Cache-Control</strong>：更细致的控制缓存的内容</p></blockquote><blockquote><p> <strong>Last-Modified</strong>：响应中资源最后一次修改的时间</p></blockquote><blockquote><p> <strong>ETag</strong>：响应中资源的校验值，在服务器上某个时段是唯一标识的。</p></blockquote><blockquote><p> <strong>Date</strong>：服务器的时间</p></blockquote><blockquote><p> <strong>If-Modified-Since</strong>：客户端存取的该资源最后一次修改的时间，同Last-Modified。</p></blockquote><blockquote><p> <strong>If-None-Match</strong>：客户端存取的该资源的检验值，同ETag。</p></blockquote><h5 id="客户端缓存生效的常见流程"><a href="#客户端缓存生效的常见流程" class="headerlink" title="客户端缓存生效的常见流程"></a>客户端缓存生效的常见流程</h5><p>服务器收到请求时，会在200OK中回送该资源的Last-Modified和ETag头，客户端将该资源保存在cache中，并记录这两个属性。当客户端需要发送相同的请求时，会在请求中携带If-Modified-Since和If-None-Match两个头。两个头的值分别是响应中Last-Modified和ETag头的值。服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回304响应。常见流程如下图所示：</p><p><img src="http://i.imgur.com/VsalGBW.jpg" alt></p><h5 id="Web缓存机制"><a href="#Web缓存机制" class="headerlink" title="Web缓存机制"></a>Web缓存机制</h5><p>HTTP/1.1中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。前者减少了网络回路的数量；HTTP利用一个“过期（expiration）”机制来为此目的。后者减少了网络应用的带宽；HTTP用“验证（validation）”机制来为此目的。</p><p>HTTP定义了3种缓存机制：</p><p>1）<strong>Freshness</strong>：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。例如，Expires回应头给了一个文档不可用的时间。Cache-Control中的max-age标识指明了缓存的最长时间；</p><p>2）<strong>Validation</strong>：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个Last-Modified回应头，缓存能够使用If-Modified-Since来判断是否已改变，以便判断根据情况发送请求；</p><p>3）<strong>Invalidation：</strong> 在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个URL关联到一个缓存回应，但是其后跟着POST、PUT和DELETE的请求的话，缓存就会过期。</p><h4 id="断点续传和多线程下载的实现原理"><a href="#断点续传和多线程下载的实现原理" class="headerlink" title="断点续传和多线程下载的实现原理"></a>断点续传和多线程下载的实现原理</h4><blockquote><p> HTTP协议的GET方法，支持只请求某个资源的某一部分；</p></blockquote><blockquote><p> 206 Partial Content 部分内容响应；</p></blockquote><blockquote><p> Range 请求的资源范围；</p></blockquote><blockquote><p> Content-Range 响应的资源范围；</p></blockquote><blockquote><p> 在连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，来实现断点续传。</p></blockquote><p>分块请求资源实例：</p><p>Eg1：*<em>Range: bytes=306302- *</em>：请求这个资源从306302个字节到末尾的部分；</p><p>Eg2：<strong>Content-Range: bytes 306302-604047/604048</strong>：响应中指示携带的是该资源的第306302-604047的字节，该资源共604048个字节；</p><p>客户端通过并发的请求相同资源的不同片段，来实现对某个资源的并发分块下载。从而达到快速下载的目的。目前流行的FlashGet和迅雷基本都是这个原理。</p><p>多线程下载的原理：</p><blockquote><p> 下载工具开启多个发出HTTP请求的线程；</p></blockquote><blockquote><p> 每个http请求只请求资源文件的一部分：Content-Range: bytes 20000-40000/47000；</p></blockquote><blockquote><p> 合并每个线程下载的文件。</p></blockquote><h4 id="https通信过程"><a href="#https通信过程" class="headerlink" title="https通信过程"></a>https通信过程</h4><h5 id="什么是https"><a href="#什么是https" class="headerlink" title="什么是https"></a>什么是https</h5><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容请看SSL。</p><p>见下图：</p><p><img src="http://i.imgur.com/mvKKFdQ.jpg" alt></p><p>https所用的端口号是443。</p><h5 id="https的实现原理"><a href="#https的实现原理" class="headerlink" title="https的实现原理"></a>https的实现原理</h5><p>有两种基本的加解密<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2RhdGFzdHJ1Y3R1cmU=" title="http://lib.csdn.net/base/datastructure">算法<i class="fa fa-external-link"></i></span>类型：</p><p>1）<strong>对称加密</strong>：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p><p>2）<strong>非对称加密</strong>：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p><p>下面看一下https的通信过程：</p><p><img src="http://i.imgur.com/Oh4J5PJ.jpg" alt></p><p>https通信的优点：</p><p>1）客户端产生的密钥只有客户端和服务器端能得到；</p><p>2）加密的数据只有客户端和服务器端才能得到明文；</p><p>3）客户端到服务端的通信是安全的。</p><h4 id="http代理"><a href="#http代理" class="headerlink" title="http代理"></a>http代理</h4><h5 id="http代理服务器"><a href="#http代理服务器" class="headerlink" title="http代理服务器"></a>http代理服务器</h5><p>代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。</p><p>代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p><p>而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。</p><p>更重要的是：Proxy Server(代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI)模型的对话层。</p><h5 id="http代理服务器的主要功能"><a href="#http代理服务器的主要功能" class="headerlink" title="http代理服务器的主要功能"></a>http代理服务器的主要功能</h5><p>主要功能如下：</p><p>1）突破自身IP访问限制，访问国外站点。如：教育网、169网等网络用户可以通过代理访问国外网站；</p><p>2）访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育 网开放的各类FTP下载上传，以及各类资料查询共享等服务；</p><p>3）突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国 外的代理服务器试试；</p><p>4）提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度；</p><p>5）隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p><h5 id="http代理图示"><a href="#http代理图示" class="headerlink" title="http代理图示"></a>http代理图示</h5><p>http代理的图示见下图：</p><p><img src="http://i.imgur.com/cuHWPm5.jpg" alt></p><p>对于客户端浏览器而言，http代理服务器相当于服务器。</p><p>而对于Web服务器而言，http代理服务器又担当了客户端的角色。</p><h4 id="虚拟主机的实现"><a href="#虚拟主机的实现" class="headerlink" title="虚拟主机的实现"></a>虚拟主机的实现</h4><h5 id="什么是虚拟主机"><a href="#什么是虚拟主机" class="headerlink" title="什么是虚拟主机"></a>什么是虚拟主机</h5><p><strong>虚拟主机</strong>：是在<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzgxMy5odG0=" title="http://baike.baidu.com/view/813.htm">网络服务器<i class="fa fa-external-link"></i></span>上划分出一定的磁盘空间供用户放置<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzM5MTEwOS5odG0=" title="http://baike.baidu.com/view/391109.htm">站点<i class="fa fa-external-link"></i></span>、应用组件等，提供必要的站点功能与数据存放、传输功能。  </p><p>所谓虚拟主机，也叫“<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzQwODUxLmh0bQ==" title="http://baike.baidu.com/view/40851.htm">网站空间<i class="fa fa-external-link"></i></span>”就是把一台运行在互联网上的服务器划分成多个“虚拟”的服务器，每一个虚拟主机都<strong>具有独立的域名和完整的Internet服务器</strong>（支持<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzE0NTMuaHRt" title="http://baike.baidu.com/view/1453.htm">WWW<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzM2OS5odG0=" title="http://baike.baidu.com/view/369.htm">FTP<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3Lzg0MDkuaHRt" title="http://baike.baidu.com/view/8409.htm">E-mail<i class="fa fa-external-link"></i></span>等）功能。一台服务器上的不同虚拟主机是各自独立的，并由用户自行管理。但一台服务器主机只能够支持一定数量的虚拟主机，当超过这个数量时，用户将会感到性能急剧下降。</p><h5 id="虚拟主机的实现原理"><a href="#虚拟主机的实现原理" class="headerlink" title="虚拟主机的实现原理"></a>虚拟主机的实现原理</h5><p>虚拟主机是用同一个WEB服务器，为不同域名网站提供服务的技术。Apache、Tomcat等均可通过配置实现这个功能。</p><p>相关的HTTP消息头：Host。</p><p>例如：Host: <span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20v" title="http://www.baidu.com/">www.baidu.com<i class="fa fa-external-link"></i></span></p><p>客户端发送HTTP请求的时候，会携带Host头，Host头记录的是客户端输入的域名。这样服务器可以根据Host头确认客户要访问的是哪一个域名。</p><h4 id="附录：参考资料-2"><a href="#附录：参考资料-2" class="headerlink" title="附录：参考资料"></a>附录：参考资料</h4><p><a href="[http://sumongh.javaeye.com/blog/82498](http://sumongh.javaeye.com/blog/82498)">理解Cookie和Session机制</a></p><p><a href="[http://203.208.39.132/search?q=cache:CdXly_88gjIJ:www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html+http%E5%8D%8F%E8%AE%AE+web%E7%BC%93%E5%AD%98&cd=27&hl=zh-CN&ct=clnk&gl=cn&st_usg=ALhdy2-vzOcP8XTG1h7lcRr2GJrkTbH2Cg](http://203.208.39.132/search?q=cache:CdXly_88gjIJ:www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html+http%E5%8D%8F%E8%AE%AE+web%E7%BC%93%E5%AD%98&cd=27&hl=zh-CN&ct=clnk&gl=cn&st_usg=ALhdy2-vzOcP8XTG1h7lcRr2GJrkTbH2Cg)">浅析HTTP协议</a></p><p><a href="[http://baike.baidu.com/view/1159398.htm](http://baike.baidu.com/view/1159398.htm)">http代理_百度百科</a></p><p><a href="[http://baike.baidu.com/view/7383.htm](http://baike.baidu.com/view/7383.htm)">虚拟主机_百度百科</a></p><p><a href="[http://baike.baidu.com/view/14121.htm](http://baike.baidu.com/view/14121.htm)">https_百度百科</a></p><p><span class="exturl" data-url="aHR0cHM6Ly9tLmJhaWR1LmNvbS9mcm9tPTg0NGIvYmRfcGFnZV90eXBlPTEvc3NpZD0wL3VpZD0wL3B1PXVzbSU0MDElMkNzeiU0MDEzMjBfMjAwMSUyQ3RhJTQwaXBob25lXzFfMTAuMl8zXzYwMi9iYWlkdWlkPTA5RDU2NkE5M0EwMEI2MDk4RDlBOTA5NEUxQjQwODc1L3c9MF8xMF8vdD1pcGhvbmUvbD0zL3RjP3JlZj13d3dfaXBob25lJmxpZD05MTk2MTkxMDUwMzUyNDIwODgxJm9yZGVyPTImZm09YWxvcCZ0aj13d3dfbm9ybWFsXzJfMF8xMF90aXRsZSZ2aXQ9b3NyZXMmbT04JnNyZD0xJmNsdGo9Y2xvdWRfdGl0bGUmYXNyZXM9MSZudD13bm9yJnRpdGxlPUhUVFAlRTQlQjglOEVIVFRQUyVFNyU5QSU4NCVFNSU4QyVCQSVFNSU4OCVBQi0lRTklQTklQUMlRTYlQjUlQjclRTclQTUlQTUlRTUlOEQlOUElRTUlQUUlQTImZGljdD0zMCZ3X3FkPUlsUFQyQUVwdHlvQV95aXhDRk94V3lrZ3F4TEkmc2VjPTE5Nzc5JmRpPWYyZmZhOGZlYjg5NGI3MDcmYmRlbmM9MSZuc3JjPUlsUFQyQUVwdHlvQV95aXhDRk94WG5BTmVkVDYydjNJRVFHR195RlpfamU4bFVTN2hQT2xJdGdmRUZYN0xtdVRFVWZ3c0NQUXB4OUR3OE8tUnlKcmxL" title="https://m.baidu.com/from=844b/bd_page_type=1/ssid=0/uid=0/pu=usm%401%2Csz%401320_2001%2Cta%40iphone_1_10.2_3_602/baiduid=09D566A93A00B6098D9A9094E1B40875/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&lid=9196191050352420881&order=2&fm=alop&tj=www_normal_2_0_10_title&vit=osres&m=8&srd=1&cltj=cloud_title&asres=1&nt=wnor&title=HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%A9%AC%E6%B5%B7%E7%A5%A5%E5%8D%9A%E5%AE%A2&dict=30&w_qd=IlPT2AEptyoA_yixCFOxWykgqxLI&sec=19779&di=f2ffa8feb894b707&bdenc=1&nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_yFZ_je8lUS7hPOlItgfEFX7LmuTEUfwsCPQpx9Dw8O-RyJrlK">HTTP与HTTPS的区别<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGE4ZjMyOTVjNDk3ZDAwNWZiZDU4YjE=" title="https://juejin.im/post/58a8f3295c497d005fbd58b1">HTTPS 为什么更安全，先看这些<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章来自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1oMTI1MDYvYXJ0aWNsZS9kZXRhaWxzLzc3OTQ1MTI=&quot; title=&quot;http://blog.csdn.net/lmh12506/article/details/7794512&quot;&gt;深入理解HTTP协议、HTTP协议原理分析&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础概念篇&quot;&gt;&lt;a href=&quot;#基础概念篇&quot; class=&quot;headerlink&quot; title=&quot;基础概念篇&quot;&gt;&lt;/a&gt;基础概念篇&lt;/h3&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://miaopei.github.io/categories/http/"/>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HTTP思维导图</title>
    <link href="http://miaopei.github.io/2017/04/12/HTTP%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://miaopei.github.io/2017/04/12/HTTP思维导图/</id>
    <published>2017-04-12T07:41:58.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自<span class="exturl" data-url="aHR0cDovL3lycTExMC5tZS8yMDE3LzAzLzA0LzIwMTcwMzA0LWh0dHAtbWluZG1hcC8=" title="http://yrq110.me/2017/03/04/20170304-http-mindmap/">HTTP思维导图<i class="fa fa-external-link"></i></span>。</p><p>HTTP mindmap整理</p><p>source from 《HTTP权威指南》</p><a id="more"></a><h3 id="概述-Summary"><a href="#概述-Summary" class="headerlink" title="概述-Summary"></a>概述-Summary</h3><img src="/img/http/HTTP-1.svg"><h3 id="报文-Message"><a href="#报文-Message" class="headerlink" title="报文-Message"></a>报文-Message</h3><img src="/img/http/HTTP-2.svg"><h3 id="连接-Connection"><a href="#连接-Connection" class="headerlink" title="连接-Connection"></a>连接-Connection</h3><img src="/img/http/HTTP-3.svg"><h3 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理-Proxy"></a>代理-Proxy</h3><img src="/img/http/HTTP-4.svg"><h3 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存-Cache"></a>缓存-Cache</h3><img src="/img/http/HTTP-5.svg"><h3 id="网关、隧道与中继-Gateway、Tunnel-and-Relay"><a href="#网关、隧道与中继-Gateway、Tunnel-and-Relay" class="headerlink" title="网关、隧道与中继-Gateway、Tunnel and Relay"></a>网关、隧道与中继-Gateway、Tunnel and Relay</h3><img src="/img/http/HTTP-6.svg"><h3 id="识别-Identification"><a href="#识别-Identification" class="headerlink" title="识别-Identification"></a>识别-Identification</h3><img src="/img/http/HTTP-7.svg"><h3 id="认证-Authentication"><a href="#认证-Authentication" class="headerlink" title="认证-Authentication"></a>认证-Authentication</h3><img src="/img/http/HTTP-8.svg"><h3 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全-Security"></a>安全-Security</h3><img src="/img/http/HTTP-9.svg"><h3 id="实体与编码-Entity-and-Encoding"><a href="#实体与编码-Entity-and-Encoding" class="headerlink" title="实体与编码-Entity and Encoding"></a>实体与编码-Entity and Encoding</h3><img src="/img/http/HTTP-10.svg">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章来自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3lycTExMC5tZS8yMDE3LzAzLzA0LzIwMTcwMzA0LWh0dHAtbWluZG1hcC8=&quot; title=&quot;http://yrq110.me/2017/03/04/20170304-http-mindmap/&quot;&gt;HTTP思维导图&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;HTTP mindmap整理&lt;/p&gt;
&lt;p&gt;source from 《HTTP权威指南》&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://miaopei.github.io/categories/http/"/>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Webpack创建、运行vue.js项目及其目录结构详解</title>
    <link href="http://miaopei.github.io/2017/04/10/Webpack%E5%88%9B%E5%BB%BA%E3%80%81%E8%BF%90%E8%A1%8Cvue-js%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://miaopei.github.io/2017/04/10/Webpack创建、运行vue-js项目及其目录结构详解/</id>
    <published>2017-04-10T10:18:27.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目环境搭建："><a href="#项目环境搭建：" class="headerlink" title="项目环境搭建："></a>项目环境搭建：</h3><p>1.安装node</p><p>进入<a href="[https://nodejs.org/en/](https://nodejs.org/en/">node官网</a>进行下载。</p><p>版本查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v6.10.1</span><br></pre></td></tr></table></figure><p style="color:red;">**注意：**node版本最好新一点，推介6.0以上。 </p><a id="more"></a><p>2.全局安装vue-cli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g vue-cli</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果安装失败可能需要root权限重新安装。</p><p>3.创建一个基于 <code>webpack</code> 模板的新项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vue init webpack project-name <span class="comment">#(默认安装2.0版本)</span></span><br><span class="line">$ vue init webpack<span class="comment">#1.0 project-name #(安装1.0版本)</span></span><br></pre></td></tr></table></figure><h3 id="项目目录结构："><a href="#项目目录结构：" class="headerlink" title="项目目录结构："></a>项目目录结构：</h3><p><img src="http://i.imgur.com/P64Q8uK.png" alt></p><p><img src="http://i.imgur.com/beLRmUA.png" alt></p><ul><li><p>main.js是入口文件，主要作用是初始化vue实例并使用需要的插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。其实你也可以理解为所有的路由也是App.vue的子组件。所以我将router标示为App.vue的子组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;hello&gt;&lt;/hello&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Hello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>index.html文件入口</p></li><li><p>src放置组件和入口文件</p></li><li><p>node_modules为依赖的模块</p></li><li><p>config中配置了路径端口值等</p></li><li><p>build中配置了webpack的基本配置、开发环境配置、生产环境配置等</p></li></ul><h3 id="运行项目："><a href="#运行项目：" class="headerlink" title="运行项目："></a>运行项目：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> project-name</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br><span class="line"><span class="comment"># 上述步骤都完成后在浏览器输入：localhost:8080</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;项目环境搭建：&quot;&gt;&lt;a href=&quot;#项目环境搭建：&quot; class=&quot;headerlink&quot; title=&quot;项目环境搭建：&quot;&gt;&lt;/a&gt;项目环境搭建：&lt;/h3&gt;&lt;p&gt;1.安装node&lt;/p&gt;
&lt;p&gt;进入&lt;a href=&quot;[https://nodejs.org/en/](https://nodejs.org/en/&quot;&gt;node官网&lt;/a&gt;进行下载。&lt;/p&gt;
&lt;p&gt;版本查看：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ node -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v6.10.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p style=&quot;color:red;&quot;&gt;**注意：**node版本最好新一点，推介6.0以上。 &lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://miaopei.github.io/categories/Docker/"/>
    
    
      <category term="webpack" scheme="http://miaopei.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>lighttpd+fastcgi</title>
    <link href="http://miaopei.github.io/2017/03/31/lighttpd-fastcgi/"/>
    <id>http://miaopei.github.io/2017/03/31/lighttpd-fastcgi/</id>
    <published>2017-03-31T04:34:28.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>lighttpd</code> 提供了一种外部程序调用的接口，即 <code>FastCGI</code> 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。</p><p>这就意味着能够在 <code>Apache</code> 服务器上运行的 <code>FastCGI</code> 程序，也一定可以无缝的在 <code>lighttpd</code> 上使用。</p><a id="more"></a><h3 id="FastCGI介绍"><a href="#FastCGI介绍" class="headerlink" title="FastCGI介绍"></a>FastCGI介绍</h3><p>1）就像 <code>CGI</code> 一样，<code>FastCGI</code> 也是独立于编程语言的。<br>2）就像 <code>CGI</code> 一样，<code>FastCGI</code> 程序运行在完全独立于核心 <code>Web Server</code> 之外的进程中，和 <code>API</code> 方式相比，提供了很大的安全性。（API会将程序代码与核心Web Server挂接在一起，这就意味着基于问题API的应用程序可能会使整个Web Server或另一个应用程序崩溃；一个恶意API还可以从核心Web Server或另一个应用程序中盗取安全密钥）</p><p>3) 虽然 <code>FastCGI</code> 不能一夜之间复制CGI的所有功能，但是 <code>FastCGI</code> 一直宣扬开放，这也使得我们拥有很多免费的 <code>FastCGI</code> 应用程序库（C/C++、Java、Perl、TCL）和免费的Server模块（Apache、ISS、Lighttpd）。</p><p>4) 就像 <code>CGI</code> 一样，<code>FastCGI</code> 并不依附于任何 <code>Web Server</code> 的内部架构，因此即使 <code>Server</code> 的技术实现变动，<code>FastCGI</code> 仍然非常稳定；而 <code>API</code> 设计是反映 <code>Web Server</code> 内部架构的，因此，一旦架构改变，API要随之变动。</p><p>5) <code>FastCGI</code> 程序可以运行在任何机器上，完全可以和 <code>Web Server</code> 不在一台机器上。这种分布式计算的思想可以确保可扩展性、提高系统可用性和安全性。</p><p>6) <code>CGI</code> 程序主要是对 <code>HTTP</code> 请求做计算处理，而 <code>FastCGI</code> 却还可以做得更多，例如模块化认证、授权检查、数据类型转换等等。在未来，<code>FastCGI</code> 还会有能力扮演更多角色。</p><p>7) <code>FastCGI</code> 移除了 <code>CGI</code> 程序的许多弊端。例如，针对每一个新请求，<code>WebServer</code> 都必须重启 <code>CGI</code> 程序来处理新请求，这导致 <code>WebServer</code> 的性能会大受影响。而 <code>FastCGI</code> 通过保持进程处理运行状态并持续处理请求的方式解决了该问题，这就将进程创建和销毁的时间节省了出来。</p><p>8) <code>CGI</code> 程序需要通过管道（pipe）方式与 <code>Web Server</code> 通信，而 <code>FastCGI</code> 则是通过 <code>Unix-Domain-Sockets</code> 或 <code>TCP/IP</code> 方式来实现与 <code>Web Server</code> 的通信。这确保了 <code>FastCGI</code> 可以运行在 <code>Web Server</code> 之外的服务器上。<code>FastCGI</code> 提供了 <code>FastCGI</code> 负载均衡器，它可以有效控制多个独立的 <code>FastCGI Server</code> 的负载，这种方式比 <code>load-balancer+apache+mod_php</code> 方式能够承担更多的流量。</p><h3 id="FastCGI-模块"><a href="#FastCGI-模块" class="headerlink" title="FastCGI 模块"></a>FastCGI 模块</h3><p>若要 <code>lighttpd</code> 支持 <code>fastcgi</code>，则需要配置如下内容：</p><p>在 <code>fastcgi.conf</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.modules += ( &quot;mod_fastcgi&quot; )</span><br></pre></td></tr></table></figure><p>及在 <code>module.conf</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;conf.d/fastcgi.conf&quot;</span><br></pre></td></tr></table></figure><h3 id="FastCGI-配置选项"><a href="#FastCGI-配置选项" class="headerlink" title="FastCGI 配置选项"></a>FastCGI 配置选项</h3><p><code>lighttpd</code> 通过 <code>fastcgi</code> 模块的方式实现了对 <code>fastcgi</code> 的支持，并且在配置文件中提供了三个相关的选项：</p><p>1） fastcgi.debug</p><p>可以设置一个从0到65535的值，用于设定 <code>FastCGI</code> 模块的调试等级。当前仅有0和1可用。<strong>1表示开启调试（会输出调试信息），0表示禁用</strong>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.debug = 1</span><br></pre></td></tr></table></figure><p>2） fastcgi.map-extentsions</p><p>同一个 <code>fastcgi server</code> 能够映射多个扩展名，如 <code>.php3</code> 和 <code>.php4</code> 都对应 <code>.php</code>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot; )</span><br></pre></td></tr></table></figure><p>or for multiple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot;, &quot;.php4&quot; =&gt; &quot;.php&quot; )</span><br></pre></td></tr></table></figure><p>3） fastcgi.server</p><p>这个配置是告诉 <code>Web Server</code> 将 <code>FastCGI</code> 请求发送到哪里，其中每一个文件扩展名可以处理一个类型的请求。负载均衡器可以实现对同一扩展名的多个对象的负载均衡。</p><p><code>fastcgi.server</code> 的结构语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">( &lt;extension&gt; =&gt;</span><br><span class="line">  ( [ &lt;name&gt; =&gt; ]</span><br><span class="line">    ( <span class="comment"># Be careful: lighty does *not* warn you if it doesn't know a specified option here (make sure you have no typos)</span></span><br><span class="line">      <span class="string">"host"</span> =&gt; &lt;string&gt; ,</span><br><span class="line">      <span class="string">"port"</span> =&gt; &lt;<span class="built_in">integer</span>&gt; ,</span><br><span class="line">      <span class="string">"socket"</span> =&gt; &lt;string&gt;,                 <span class="comment"># either socket or host+port</span></span><br><span class="line">      <span class="string">"bin-path"</span> =&gt; &lt;string&gt;,               <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"bin-environment"</span> =&gt; &lt;array&gt;,         <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"bin-copy-environment"</span> =&gt; &lt;array&gt;,    <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"mode"</span> =&gt; &lt;string&gt;,                   <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"docroot"</span> =&gt; &lt;string&gt; ,               <span class="comment"># optional if "mode" is not "authorizer"</span></span><br><span class="line">      <span class="string">"check-local"</span> =&gt; &lt;string&gt;,            <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"max-procs"</span> =&gt; &lt;<span class="built_in">integer</span>&gt;,             <span class="comment"># optional - when omitted, default is 4</span></span><br><span class="line">      <span class="string">"broken-scriptfilename"</span> =&gt; &lt;boolean&gt;, <span class="comment"># optional</span></span><br><span class="line">      <span class="string">"kill-signal"</span> =&gt; &lt;<span class="built_in">integer</span>&gt;,           <span class="comment"># optional, default is SIGTERM(15) (v1.4.14+)</span></span><br><span class="line">    ),</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; ...</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中：</p><blockquote><p><strong>extentsion</strong> ：文件名后缀或以”/”开头的前缀（也可为文件名）<br><strong>name</strong> ：这是一个可选项，表示handler的名称，在mod_status中用于统计功能，可以清晰的分辨出是哪一个handler处理了<extension>。<strong>host</strong> ：FastCGI进程监听的IP地址。此处不支持hostname形式。<br><strong>port</strong> ：FastCGI进程所监听的TCP端口号<br><strong>bin-path</strong> ：本地FastCGI二进制程序的路径，当本地没有FastCGI正在运行时，会启动这个FastCGI程序。<br><strong>socket</strong> ：unix-domain-socket所在路径。<br><strong>mode</strong> ：可以选择FastCGI协议的模式，默认是“responder”，还可以选择authorizer。<br><strong>docroot</strong> ：这是一个可选项，对于responder模式来讲，表示远程主机docroot；对于authorizer模式来说，它表示MANDATORY，并且指向授权请求的docroot。<br><strong>check_local</strong> ：这是一个可选项，默认是enable。如果是enable，那么server会首先在本地（server.document-root）目录中检查被请求的文件是否存在，如果不存在，则给用户返回404（Not Found），而不会把这个请求传递给FastCGI。如果是disable，那么server不会检查本地文件，而是直接将请求转发给FastCGI。（disable的话，server从某种意义上说就变为了一个转发器）<br><strong>broken-scriptfilename</strong> ：以类似PHP抽取PATH_INFO的方式，抽取URL中的SCRIPT_FILENAME。</extension></p></blockquote><p>如果 <code>bin-path</code> 被设置了，那么：</p><blockquote><p><strong>max-procs</strong> ：设置多少个FastCGI进程被启动<br><strong>bin-environment</strong> ：在FastCGI进程启动时设置一个环境变量<br><strong>bin-copy-environment</strong> ：清除环境，并拷贝指定的变量到全新的环境中。<br><strong>kill-signal</strong> ：默认的话，在停止FastCGI进程时，lighttpd会发送SIGTERM(-15)信号给子进程。此处可以设置发送的信号。</p></blockquote><p><strong>举例</strong> ：</p><p>使用前缀来对应主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = (</span><br><span class="line">  <span class="string">"/remote_scripts/"</span> =&gt;</span><br><span class="line">  (( <span class="string">"host"</span> =&gt; <span class="string">"192.168.0.3"</span>,</span><br><span class="line">     <span class="string">"port"</span> =&gt; 9000,</span><br><span class="line">     <span class="string">"check-local"</span> =&gt; <span class="string">"disable"</span>,</span><br><span class="line">     <span class="string">"docroot"</span> =&gt; <span class="string">"/"</span> <span class="comment"># remote server may use</span></span><br><span class="line">                      <span class="comment"># it's own docroot</span></span><br><span class="line">  ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果有一个请求 “<span class="exturl" data-url="aHR0cDovL215LmV4YW1wbGUub3JnL3JlbW90ZV9zY3JpcHRzL3Rlc3QuY2dpJnF1b3Q777yM6YKj5LmIc2VydmVy5Lya5bCG5YW26L2s5Y+R57uZMTkyLjE2OC4wLjPnmoQ5MDAw56uv5Y+j77yM5bm25LiU" title="http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且">http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且<i class="fa fa-external-link"></i></span> <code>SCRIPT_NAME</code> 会被赋值为 <code>“/remote_scripts/test.cgi”</code>。如果所设置的 <code>handler</code> 的末尾不是 <code>“/”</code> ，那么会被认为是一个文件。</p><p><strong>负载均衡</strong> ：</p><p><code>FastCGI</code> 模块提供了一种在多台 <code>FastCGI</code> 服务器间负载均衡的方法。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = ( <span class="string">".php"</span> =&gt;</span><br><span class="line">  (</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; <span class="string">"10.0.0.2"</span>,</span><br><span class="line">      <span class="string">"port"</span> =&gt; 1030</span><br><span class="line">    ),</span><br><span class="line">    ( <span class="string">"host"</span> =&gt; <span class="string">"10.0.0.3"</span>,</span><br><span class="line">      <span class="string">"port"</span> =&gt; 1030 )</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>为了更好的理解负载均衡实现的原理，建议你置 <code>fastcgi.debug</code> 为 <code>1</code> 。即使对于本机的多个 <code>FastCGI</code> ，你也会获得如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proc: 127.0.0.1 1031  1 1 1 31454</span><br><span class="line">proc: 127.0.0.1 1028  1 1 1 31442</span><br><span class="line">proc: 127.0.0.1 1030  1 1 1 31449</span><br><span class="line">proc: 127.0.0.1 1029  1 1 2 31447</span><br><span class="line">proc: 127.0.0.1 1026  1 1 2 31438</span><br><span class="line">got proc: 34 31454</span><br><span class="line">release proc: 40 31438</span><br><span class="line">proc: 127.0.0.1 1026  1 1 1 31438</span><br><span class="line">proc: 127.0.0.1 1028  1 1 1 31442</span><br><span class="line">proc: 127.0.0.1 1030  1 1 1 31449</span><br><span class="line">proc: 127.0.0.1 1031  1 1 2 31454</span><br><span class="line">proc: 127.0.0.1 1029  1 1 2 31447</span><br></pre></td></tr></table></figure><p>上述信息显示出了IP地址，端口号、当前链接数（也就是负载）（倒数第二列）、进程ID（倒数第一列）等等。整个输出信息总是以负载域来从小到大排序的。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><span class="exturl" data-url="aHR0cDovL3JlZG1pbmUubGlnaHR0cGQubmV0L3Byb2plY3RzLzEvd2lraS9Eb2NzOk1vZEZhc3RDR0k=" title="http://redmine.lighttpd.net/projects/1/wiki/Docs:ModFastCGI"><i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5mYXN0Y2dpLmNvbQ==" title="http://www.fastcgi.com"><i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3JvY2xpbnV4LmNuLz9wPTIzNDc=" title="http://roclinux.cn/?p=2347">说说lighttpd的fastcgi<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3luZXQvcC80MTczNDUwLmh0bWw=" title="http://www.cnblogs.com/skynet/p/4173450.html">Nginx + CGI/FastCGI + C/Cpp<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDAwNjU5Ng==" title="https://segmentfault.com/a/1190000004006596">FastCGI+lighttpd开发之介绍和环境搭建<i class="fa fa-external-link"></i></span></p><h3 id="附：QC-V3-PP-版本-lighttpd-conf"><a href="#附：QC-V3-PP-版本-lighttpd-conf" class="headerlink" title="附：QC V3 PP 版本 lighttpd.conf"></a>附：QC V3 PP 版本 lighttpd.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/qtilighttpd.conf </span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Copyright (c) 2016 Qualcomm Technologies, Inc.</span></span><br><span class="line"><span class="comment"># All Rights Reserved.</span></span><br><span class="line"><span class="comment"># Confidential and Proprietary - Qualcomm Technologies, Inc.</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">server.document-root = <span class="string">"/opt/qcom/www"</span></span><br><span class="line"></span><br><span class="line">server.port    = 80</span><br><span class="line">server.username    = <span class="string">"apps"</span></span><br><span class="line">server.groupname  = <span class="string">"apps"</span></span><br><span class="line">server.bind    = <span class="string">"0.0.0.0"</span></span><br><span class="line">server.tag    = <span class="string">"lighttpd"</span></span><br><span class="line"><span class="variable">$SERVER</span>[<span class="string">"socket"</span>] == <span class="string">"[::]:80"</span> &#123;  &#125;</span><br><span class="line"></span><br><span class="line">server.errorlog-use-syslog  = <span class="string">"enable"</span></span><br><span class="line">accesslog.use-syslog    = <span class="string">"enable"</span></span><br><span class="line"></span><br><span class="line">server.modules    = (</span><br><span class="line">  <span class="string">"mod_access"</span>,<span class="string">"mod_accesslog"</span>, <span class="string">"mod_cgi"</span>, <span class="string">"mod_fastcgi"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fastcgi.debug = 1</span><br><span class="line">fastcgi.server = (</span><br><span class="line">    <span class="string">"/fsmoam"</span> =&gt; (</span><br><span class="line">    <span class="string">"fsmoam.fcgi.handler"</span> =&gt; (</span><br><span class="line">        <span class="string">"socket"</span> =&gt; <span class="string">"/tmp/fsmoam.fcgi.socket"</span>,</span><br><span class="line">        <span class="string">"check-local"</span> =&gt; <span class="string">"disable"</span>,</span><br><span class="line">        <span class="string">"bin-path"</span> =&gt; <span class="string">"/opt/qcom/bin/tests/fsmWebServer --default-log-level=DEBUG"</span>,</span><br><span class="line">        <span class="string">"max-procs"</span> =&gt; 1)</span><br><span class="line">     )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mimetype mapping</span></span><br><span class="line">mimetype.assign    = (</span><br><span class="line">  <span class="string">".pdf"</span>    =&gt;  <span class="string">"application/pdf"</span>,</span><br><span class="line">  <span class="string">".sig"</span>    =&gt;  <span class="string">"application/pgp-signature"</span>,</span><br><span class="line">  <span class="string">".spl"</span>    =&gt;  <span class="string">"application/futuresplash"</span>,</span><br><span class="line">  <span class="string">".class"</span>  =&gt;  <span class="string">"application/octet-stream"</span>,</span><br><span class="line">  <span class="string">".ps"</span>    =&gt;  <span class="string">"application/postscript"</span>,</span><br><span class="line">  <span class="string">".torrent"</span>  =&gt;  <span class="string">"application/x-bittorrent"</span>,</span><br><span class="line">  <span class="string">".dvi"</span>    =&gt;  <span class="string">"application/x-dvi"</span>,</span><br><span class="line">  <span class="string">".gz"</span>    =&gt;  <span class="string">"application/x-gzip"</span>,</span><br><span class="line">  <span class="string">".pac"</span>    =&gt;  <span class="string">"application/x-ns-proxy-autoconfig"</span>,</span><br><span class="line">  <span class="string">".swf"</span>    =&gt;  <span class="string">"application/x-shockwave-flash"</span>,</span><br><span class="line">  <span class="string">".tar.gz"</span>  =&gt;  <span class="string">"application/x-tgz"</span>,</span><br><span class="line">  <span class="string">".tgz"</span>    =&gt;  <span class="string">"application/x-tgz"</span>,</span><br><span class="line">  <span class="string">".tar"</span>    =&gt;  <span class="string">"application/x-tar"</span>,</span><br><span class="line">  <span class="string">".zip"</span>    =&gt;  <span class="string">"application/zip"</span>,</span><br><span class="line">  <span class="string">".mp3"</span>    =&gt;  <span class="string">"audio/mpeg"</span>,</span><br><span class="line">  <span class="string">".m3u"</span>    =&gt;  <span class="string">"audio/x-mpegurl"</span>,</span><br><span class="line">  <span class="string">".wma"</span>    =&gt;  <span class="string">"audio/x-ms-wma"</span>,</span><br><span class="line">  <span class="string">".wax"</span>    =&gt;  <span class="string">"audio/x-ms-wax"</span>,</span><br><span class="line">  <span class="string">".ogg"</span>    =&gt;  <span class="string">"audio/x-wav"</span>,</span><br><span class="line">  <span class="string">".wav"</span>    =&gt;  <span class="string">"audio/x-wav"</span>,</span><br><span class="line">  <span class="string">".gif"</span>    =&gt;  <span class="string">"image/gif"</span>,</span><br><span class="line">  <span class="string">".jpg"</span>    =&gt;  <span class="string">"image/jpeg"</span>,</span><br><span class="line">  <span class="string">".jpeg"</span>    =&gt;  <span class="string">"image/jpeg"</span>,</span><br><span class="line">  <span class="string">".png"</span>    =&gt;  <span class="string">"image/png"</span>,</span><br><span class="line">  <span class="string">".xbm"</span>    =&gt;  <span class="string">"image/x-xbitmap"</span>,</span><br><span class="line">  <span class="string">".xpm"</span>    =&gt;  <span class="string">"image/x-xpixmap"</span>,</span><br><span class="line">  <span class="string">".xwd"</span>    =&gt;  <span class="string">"image/x-xwindowdump"</span>,</span><br><span class="line">  <span class="string">".css"</span>    =&gt;  <span class="string">"text/css"</span>,</span><br><span class="line">  <span class="string">".html"</span>    =&gt;  <span class="string">"text/html"</span>,</span><br><span class="line">  <span class="string">".htm"</span>    =&gt;  <span class="string">"text/html"</span>,</span><br><span class="line">  <span class="string">".js"</span>    =&gt;  <span class="string">"text/javascript"</span>,</span><br><span class="line">  <span class="string">".asc"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".c"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".conf"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".text"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".txt"</span>    =&gt;  <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">".dtd"</span>    =&gt;  <span class="string">"text/xml"</span>,</span><br><span class="line">  <span class="string">".xml"</span>    =&gt;  <span class="string">"text/xml"</span>,</span><br><span class="line">  <span class="string">".mpeg"</span>    =&gt;  <span class="string">"video/mpeg"</span>,</span><br><span class="line">  <span class="string">".mpg"</span>    =&gt;  <span class="string">"video/mpeg"</span>,</span><br><span class="line">  <span class="string">".mov"</span>    =&gt;  <span class="string">"video/quicktime"</span>,</span><br><span class="line">  <span class="string">".qt"</span>    =&gt;  <span class="string">"video/quicktime"</span>,</span><br><span class="line">  <span class="string">".avi"</span>    =&gt;  <span class="string">"video/x-msvideo"</span>,</span><br><span class="line">  <span class="string">".asf"</span>    =&gt;  <span class="string">"video/x-ms-asf"</span>,</span><br><span class="line">  <span class="string">".asx"</span>    =&gt;  <span class="string">"video/x-ms-asf"</span>,</span><br><span class="line">  <span class="string">".wmv"</span>    =&gt;  <span class="string">"video/x-ms-wmv"</span>,</span><br><span class="line">  <span class="string">".bz2"</span>    =&gt;  <span class="string">"application/x-bzip"</span>,</span><br><span class="line">  <span class="string">".tbz"</span>    =&gt;  <span class="string">"application/x-bzip-compressed-tar"</span>,</span><br><span class="line">  <span class="string">".tar.bz2"</span>  =&gt;  <span class="string">"application/x-bzip-compressed-tar"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">index-file.names = ( <span class="string">"index.html"</span> )</span><br><span class="line"></span><br><span class="line">cgi.assign = ( <span class="string">".sh"</span> =&gt; <span class="string">"/bin/sh"</span> )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;lighttpd&lt;/code&gt; 提供了一种外部程序调用的接口，即 &lt;code&gt;FastCGI&lt;/code&gt; 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。&lt;/p&gt;
&lt;p&gt;这就意味着能够在 &lt;code&gt;Apache&lt;/code&gt; 服务器上运行的 &lt;code&gt;FastCGI&lt;/code&gt; 程序，也一定可以无缝的在 &lt;code&gt;lighttpd&lt;/code&gt; 上使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="lighttpd" scheme="http://miaopei.github.io/tags/lighttpd/"/>
    
      <category term="FastCGI" scheme="http://miaopei.github.io/tags/FastCGI/"/>
    
  </entry>
  
  <entry>
    <title>lighttpd 配置https</title>
    <link href="http://miaopei.github.io/2017/03/31/lighttpd-%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://miaopei.github.io/2017/03/31/lighttpd-配置https/</id>
    <published>2017-03-31T04:34:28.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="确定安装的lighttpd支持ssl"><a href="#确定安装的lighttpd支持ssl" class="headerlink" title="确定安装的lighttpd支持ssl"></a>确定安装的lighttpd支持ssl</h3><p>版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lighttpd -v</span><br><span class="line">lighttpd/1.4.35 (ssl) - a light and fast webserver</span><br><span class="line">Build-Date: Apr 25 2017 10:25:18</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h3><p>完整的ssl证书分为四个部分：</p><ul><li>CA根证书（root CA）</li><li>中级证书（Intermediate Certificate）</li><li>域名证书</li><li>证书秘钥（仅由开发者提供）</li></ul><p>证书相当于公钥，pem相当于私钥。</p><p>Self-Signed Certificates：包含公钥和私钥的结合体，证书（公钥）会在连接请求的时候发给浏览器，以便浏览器解密和加密。</p><p>创建Self-Signed Certificates：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><p>上边的命令生成一个server.pem文件。</p><h3 id="lighttpd-conf-配置"><a href="#lighttpd-conf-配置" class="headerlink" title="lighttpd.conf 配置"></a>lighttpd.conf 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SERVER</span>[<span class="string">"socket"</span>] == <span class="string">"[::]:443"</span> &#123;  </span><br><span class="line">     ssl.engine      = <span class="string">"enable"</span></span><br><span class="line">     ssl.pemfile     = <span class="string">"/mnt/flash/server.pem"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制定向到HTTPS"><a href="#强制定向到HTTPS" class="headerlink" title="强制定向到HTTPS"></a>强制定向到HTTPS</h3><p>下面是 <code>lighttpd.conf</code> 文件中关于强制 HTTP 定向到 HTTPS 的部分配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HTTP</span>[<span class="string">"scheme"</span>] == <span class="string">"http"</span> &#123;</span><br><span class="line">    <span class="comment"># capture vhost name with regex conditiona -&gt; %0 in redirect pattern</span></span><br><span class="line">    <span class="comment"># must be the most inner block to the redirect rule</span></span><br><span class="line">    <span class="variable">$HTTP</span>[<span class="string">"host"</span>] =~ <span class="string">".*"</span> &#123;</span><br><span class="line">        url.redirect = (<span class="string">".*"</span> =&gt; <span class="string">"https://%0<span class="variable">$0</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此功能需要lighttpd <code>mod_redirect</code> 模块支持。使用此功能前确保模块已经安装。</p><h3 id="lighttpd安全配置"><a href="#lighttpd安全配置" class="headerlink" title="lighttpd安全配置"></a>lighttpd安全配置</h3><p><strong>禁用 SSL Compression (抵御 CRIME 攻击)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.use-compression = <span class="string">"disable"</span></span><br></pre></td></tr></table></figure><p><strong>禁用 SSLv2 及 SSLv3</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl.use-sslv2 = <span class="string">"disable"</span></span><br><span class="line">ssl.use-sslv3 = <span class="string">"disable"</span></span><br></pre></td></tr></table></figure><p><strong>抵御 Poodle 和 SSL downgrade 攻击</strong></p><p>需要支持 <code>TLS-FALLBACK-SCSV</code> 以自动开启此功能。下列 openSSL 版本包含对 <code>TLS-FALLBACK-SCSV</code> 的支持，lighttpd 会自动启用此特性。</p><ul><li>OpenSSL <strong>1.0.1</strong> 在 <code>1.0.1j</code> 及之后的版本中支持</li><li>OpenSSL <strong>1.0.0</strong> 在 <code>1.0.0o</code> 及之后的版本中支持</li><li>OpenSSL <strong>0.9.8</strong> 在 <code>0.9.8zc</code> 及之后的版本中支持</li></ul><p><strong>加密及交换算法</strong></p><p>一份推介的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.cipher-list = <span class="string">"EECDH+AESGCM:EDH+AESGCM:AES128+EECDH:AES128+EDH"</span></span><br></pre></td></tr></table></figure><p>如果您需要兼容一些老式系统和浏览器 (例如 Windows XP 和 IE6)，请使用下面的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl.cipher-list = <span class="string">"EECDH+AESGCM:EDH+AESGCM:ECDHE-RSA-AES128-GCM-SHA256:AES256+EECDH:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4"</span></span><br></pre></td></tr></table></figure><p><strong>配置 Forward Secrecy 和 DHE 参数</strong></p><p>生成强 DHE 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/ssl/certs</span><br><span class="line">$ openssl dhparam -out dhparam.pem 4096</span><br></pre></td></tr></table></figure><p><strong>建议您使用性能强劲的平台生成此文件</strong>，例如最新版的至强物理机。如果您只有一台小型 VPS，请使用 <code>openssl dhparam -out dhparam.pem 2048</code> 命令生成 2048bit 的参数文件。</p><p>添加到 SSL 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl.dh-file = <span class="string">"/etc/ssl/certs/dhparam.pem"</span></span><br><span class="line">ssl.ec-curve = <span class="string">"secp384r1"</span></span><br></pre></td></tr></table></figure><p><strong>启用 HSTS</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.modules += ( <span class="string">"mod_setenv"</span> )</span><br><span class="line"><span class="variable">$HTTP</span>[<span class="string">"scheme"</span>] == <span class="string">"https"</span> &#123;</span><br><span class="line">    setenv.add-response-header  = ( <span class="string">"Strict-Transport-Security"</span> =&gt; <span class="string">"max-age=63072000; includeSubdomains; preload"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0xpZ2h0dHBk" title="https://wiki.archlinux.org/index.php/Lighttpd">Lighttpd<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;确定安装的lighttpd支持ssl&quot;&gt;&lt;a href=&quot;#确定安装的lighttpd支持ssl&quot; class=&quot;headerlink&quot; title=&quot;确定安装的lighttpd支持ssl&quot;&gt;&lt;/a&gt;确定安装的lighttpd支持ssl&lt;/h3&gt;&lt;p&gt;版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ lighttpd -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lighttpd/1.4.35 (ssl) - a light and fast webserver&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Build-Date: Apr 25 2017 10:25:18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://miaopei.github.io/tags/http/"/>
    
      <category term="lighttpd" scheme="http://miaopei.github.io/tags/lighttpd/"/>
    
  </entry>
  
  <entry>
    <title>svn 常用操作命令</title>
    <link href="http://miaopei.github.io/2017/03/29/svn-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://miaopei.github.io/2017/03/29/svn-常用操作命令/</id>
    <published>2017-03-29T08:23:27.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span><br><span class="line">$ svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名</span><br><span class="line"><span class="comment"># 也可以使用缩写</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">$ svn co http://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。 不指定本地目录全路径，则检出到当前目录下。</p><a id="more"></a><h2 id="导出（导出一个干净的不带-svn文件夹的目录树）"><a href="#导出（导出一个干净的不带-svn文件夹的目录树）" class="headerlink" title="导出（导出一个干净的不带.svn文件夹的目录树）"></a>导出（导出一个干净的不带.svn文件夹的目录树）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn  <span class="built_in">export</span>  [-r 版本号]  http://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">$ svn  <span class="built_in">export</span>  [-r 版本号]  svn://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">$ svn  <span class="built_in">export</span>  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn <span class="built_in">export</span> svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">$ svn <span class="built_in">export</span> svn://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br><span class="line">$ svn <span class="built_in">export</span> /home/testapp /home/testtools</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：第一种从版本库导出干净工作目录树的形式是指定URL，</p><p>​     如果指定了修订版本号，会导出相应的版本，</p><p>​     如果没有指定修订版本，则会导出最新的，导出到指定位置。</p><p>​     如果省略 本地目录全路径，URL的最后一部分会作为本地目录的名字。</p><p>​     第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留，</p><p>​     但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。</p><h2 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn　add　文件名</span><br><span class="line"><span class="comment"># 注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn add test.php  <span class="comment"># 添加test.php </span></span><br><span class="line">$ svn commit -m <span class="string">"添加我的测试用test.php"</span> test.php</span><br><span class="line">$ svn add *.php  <span class="comment"># 添加当前目录下所有的php文件</span></span><br><span class="line">$ svn commit -m <span class="string">"添加我的测试用全部php文件"</span> *.php</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ svn　commit　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line">$ svn　ci　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line"><span class="comment"># 必须带上-m参数，参数可以为空，但是必须写上-m</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn commit -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> *   <span class="comment"># 注意这个*表示全部文件</span></span><br><span class="line">$ svn commit -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">$ svn commit -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php   <span class="comment"># 保持锁就用–no-unlock开关</span></span><br><span class="line">$ svn ci -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> *   <span class="comment"># 注意这个*表示全部文件</span></span><br><span class="line">$ svn ci -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">$ svn ci -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php   <span class="comment"># 保持锁就用–no-unlock开关</span></span><br></pre></td></tr></table></figure><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ svn　update</span><br><span class="line">$ svn　update　-r　修正版本　文件名</span><br><span class="line">$ svn　update　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span></span><br><span class="line">$ svn update </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将版本库中的文件 test.cpp 还原到修正版本（revision）200</span></span><br><span class="line">$ svn update -r 200 test.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新与版本库同步。提交的时候提示过期冲突，需要先 update 修改文件，然后清除svn resolved，最后再提交commit。</span></span><br><span class="line">$ svn update test.php</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ svn　delete　svn://路径(目录或文件的全路径) -m <span class="string">"删除备注信息文本"</span></span><br><span class="line"><span class="comment"># 推荐如下操作：</span></span><br><span class="line">$ svn　delete　文件名 </span><br><span class="line">$ svn　ci　-m　<span class="string">"删除备注信息文本"</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn delete svn://localhost/testapp/test.php -m <span class="string">"删除测试文件test.php"</span></span><br><span class="line"><span class="comment"># 推荐如下操作：</span></span><br><span class="line">$ svn delete test.php </span><br><span class="line">$ svn ci -m <span class="string">"删除测试文件test.php"</span></span><br></pre></td></tr></table></figure><h2 id="加锁-解锁"><a href="#加锁-解锁" class="headerlink" title="加锁 / 解锁"></a>加锁 / 解锁</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svn　lock　-m　<span class="string">"加锁备注信息文本"</span>　[--force]　文件名 </span><br><span class="line">$ svn　unlock　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn lock -m <span class="string">"锁信测试用test.php文件"</span> test.php </span><br><span class="line">$ svn unlock test.php</span><br></pre></td></tr></table></figure><h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ svn　diff　文件名 </span><br><span class="line">$ svn　diff　-r　修正版本号m:修正版本号n　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 将修改的文件与基础版本比较</span></span><br><span class="line">$ svn diff test.php </span><br><span class="line"></span><br><span class="line"><span class="comment"># 对修正版本号200 和 修正版本号201 比较差异</span></span><br><span class="line">$ svn diff -r 200:201 test.php</span><br></pre></td></tr></table></figure><h2 id="查看文件或者目录状态"><a href="#查看文件或者目录状态" class="headerlink" title="查看文件或者目录状态"></a>查看文件或者目录状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ svn st 目录路径/名</span><br><span class="line"><span class="comment"># 目录下的文件和子目录的状态，正常状态不显示.</span></span><br><span class="line"><span class="comment"># 【?：不在svn的控制中；  M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 </span></span><br><span class="line">$ svn status 目录路径/名　　　　　</span><br><span class="line">$ svn -v 目录路径/名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件和子目录状态</span></span><br><span class="line"><span class="comment"># 【第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人】</span></span><br><span class="line">$ svn status -v 目录路径/名</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。</p><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ svn　<span class="built_in">log</span>　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 显示这个文件的所有修改记录，及其版本号的变化</span></span><br><span class="line">$ svn <span class="built_in">log</span> test.php</span><br></pre></td></tr></table></figure><h2 id="查看文件详细信息"><a href="#查看文件详细信息" class="headerlink" title="查看文件详细信息"></a>查看文件详细信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ svn　info　文件名</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn info test.php</span><br></pre></td></tr></table></figure><h2 id="SVN-帮助"><a href="#SVN-帮助" class="headerlink" title="SVN 帮助"></a>SVN 帮助</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全部功能选项</span></span><br><span class="line">$ svn　<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 具体功能的说明</span></span><br><span class="line">$ svn　<span class="built_in">help</span>　ci</span><br></pre></td></tr></table></figure><h2 id="查看版本库下的文件和目录列表"><a href="#查看版本库下的文件和目录列表" class="headerlink" title="查看版本库下的文件和目录列表"></a>查看版本库下的文件和目录列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn　list　svn://路径(目录或文件的全路径)</span><br><span class="line">$ svn　ls　svn://路径(目录或文件的全路径)</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn list svn://localhost/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示svn://localhost/test目录下的所有属于版本库的文件和目录</span></span><br><span class="line">$ svn ls svn://localhost/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="创建纳入版本控制下的新目录"><a href="#创建纳入版本控制下的新目录" class="headerlink" title="创建纳入版本控制下的新目录"></a>创建纳入版本控制下的新目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svn　mkdir　目录名</span><br><span class="line">$ svn　mkdir　-m　<span class="string">"新增目录备注文本"</span>　http://目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn mkdir newdir</span><br><span class="line">$ svn mkdir -m <span class="string">"Making a new dir."</span> svn://localhost/<span class="built_in">test</span>/newdir</span><br></pre></td></tr></table></figure><p><strong>注</strong> ： 添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn update</span><br></pre></td></tr></table></figure><p><strong>注</strong> ：如果手工在checkout出来的目录里创建了一个新文件夹newsubdir，</p><p>​     再用svn mkdir newsubdir命令后，SVN会提示：</p><p>​     svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？</p><p>​     svn: 无法创建目录“hello”: 文件已经存在</p><pre><code> 此时，用如下命令解决：svn add --non-recursive newsubdir</code></pre><p>​     在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录</p><p>​     再用 svn mkdir -m “添hello功能模块文件” <span class="exturl" data-url="c3ZuOi8vbG9jYWxob3N0L3Rlc3QvbmV3ZGlyL25ld3N1YmRpcg==" title="svn://localhost/test/newdir/newsubdir">svn://localhost/test/newdir/newsubdir<i class="fa fa-external-link"></i></span> 命令，</p><p>​     SVN提示：</p><p>​     svn: File already exists: filesystem ‘/data/svnroot/test/db’, transaction ‘4541-1’,</p><p>​     path ‘/newdir/newsubdir ‘</p><h2 id="恢复本地修改"><a href="#恢复本地修改" class="headerlink" title="恢复本地修改"></a>恢复本地修改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ svn　revert　[--recursive]　文件名</span><br><span class="line"><span class="comment"># 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># 丢弃对一个文件的修改</span></span><br><span class="line">$ svn revert foo.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复一整个目录的文件，. 为当前目录</span></span><br><span class="line">$ svn revert --recursive .</span><br></pre></td></tr></table></figure><h2 id="把工作拷贝更新到别的URL"><a href="#把工作拷贝更新到别的URL" class="headerlink" title="把工作拷贝更新到别的URL"></a>把工作拷贝更新到别的URL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ svn　switch　http://目录全路径　本地目录全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="comment"># (原为123的分支)当前所在目录分支到localhost/test/456</span></span><br><span class="line">$ svn switch http://localhost/<span class="built_in">test</span>/456 .</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ svn　resolved　[本地目录全路径]</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn update</span><br><span class="line">C foo.c</span><br><span class="line">Updated to revision 31.</span><br><span class="line"><span class="comment"># 如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span></span><br><span class="line">$ ls</span><br><span class="line">foo.c</span><br><span class="line">foo.c.mine</span><br><span class="line">foo.c.r30</span><br><span class="line">foo.c.r31</span><br><span class="line"><span class="comment"># 当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span></span><br><span class="line"><span class="comment"># 你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</span></span><br></pre></td></tr></table></figure><h2 id="不checkout而查看输出特定文件或URL的内容"><a href="#不checkout而查看输出特定文件或URL的内容" class="headerlink" title="不checkout而查看输出特定文件或URL的内容"></a>不checkout而查看输出特定文件或URL的内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ svn　cat　http://文件全路径</span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">$ svn cat http://localhost/<span class="built_in">test</span>/readme.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支copy</span></span><br><span class="line"><span class="comment"># 从branchA拷贝出一个新分支branchB</span></span><br><span class="line">$ svn copy branchA branchB  -m <span class="string">"make B branch"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并内容到分支merge</span></span><br><span class="line"><span class="comment"># 把对branchA的修改合并到分支branchB</span></span><br><span class="line">$ svn merge branchA branchB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;检出&quot;&gt;&lt;a href=&quot;#检出&quot; class=&quot;headerlink&quot; title=&quot;检出&quot;&gt;&lt;/a&gt;检出&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 也可以使用缩写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 例子：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ svn co http://localhost/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;/testapp --username wzhnsc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt; ：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。 不指定本地目录全路径，则检出到当前目录下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="svn" scheme="http://miaopei.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>hexo 使用指南</title>
    <link href="http://miaopei.github.io/2017/03/28/hexo-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://miaopei.github.io/2017/03/28/hexo-使用指南/</id>
    <published>2017-03-28T08:53:46.000Z</published>
    <updated>2019-06-03T09:17:59.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装、初始化和配置"><a href="#安装、初始化和配置" class="headerlink" title="安装、初始化和配置"></a>安装、初始化和配置</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>git</li><li>node.js</li><li>github</li></ul><a id="more"></a><h3 id="安装和初始化"><a href="#安装和初始化" class="headerlink" title="安装和初始化"></a>安装和初始化</h3><p>首先确定已经安装好了 <code>nodejs</code> 和 <code>npm</code> 以及 <code>git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAw" title="http://localhost:4000">http://localhost:4000<i class="fa fa-external-link"></i></span>，会看到生成好的博客。</p><h3 id="主目录结构"><a href="#主目录结构" class="headerlink" title="主目录结构"></a>主目录结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-- _config.yml</span><br><span class="line">|-- package.json</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source</span><br><span class="line">   |-- _posts</span><br><span class="line">|-- themes</span><br><span class="line">|-- .gitignore</span><br><span class="line">|-- package.json</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。</p><p><strong>package.json</strong></p><p>hexo框架的参数和所依赖插件，如下：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"3.2.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.10"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>scaffold</strong></p><p>scaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。</p><p><strong>_config.yml文件</strong></p><p>_config.yml 采用YAML语法格式，<span class="exturl" data-url="aHR0cDovL215Lm9zY2hpbmEubmV0L3UvMTg2MTgzNy9ibG9nLzUyNjE0Mj9wPSU3QiU3QnRvdGFsUGFnZSU3RCU3RA==" title="http://my.oschina.net/u/1861837/blog/526142?p=%7B%7BtotalPage%7D%7D">具体语法自行学习<i class="fa fa-external-link"></i></span> 。<br>具体配置可以参考<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbi5odG1s" title="https://hexo.io/zh-cn/docs/configuration.html">官方文档<i class="fa fa-external-link"></i></span>，_config.yml 文件中的内容，并对主要参数做简单的介绍</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span>   <span class="comment">#网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span>     <span class="comment">#网站副标题</span></span><br><span class="line"><span class="attr">description:</span>  <span class="comment">#网站描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span>  <span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span>    <span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span>    <span class="comment">#网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://yoursite.com</span>   <span class="comment">#你的站点Url</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                    <span class="comment">#站点的根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>   <span class="comment">#文章的 永久链接 格式   </span></span><br><span class="line"><span class="attr">permalink_defaults:</span>    <span class="comment">#永久链接中各部分的默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory   </span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span>         <span class="comment">#资源文件夹，这个文件夹用来存放内容</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span>         <span class="comment">#公共文件夹，这个文件夹用于存放生成的站点文件。</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span>              <span class="comment">#标签文件夹     </span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span>      <span class="comment">#归档文件夹</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span>   <span class="comment">#分类文件夹</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span>   <span class="comment">#Include code 文件夹</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span>            <span class="comment">#国际化（i18n）文件夹</span></span><br><span class="line"><span class="attr">skip_render:</span>               <span class="comment">#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>   <span class="comment">#新文章的文件名称</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>       <span class="comment">#预设布局</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span>           <span class="comment">#把标题转换为 title case</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span>        <span class="comment">#在新标签中打开链接</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span>           <span class="comment">#把文件名称转换为 (1) 小写或 (2) 大写</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span>       <span class="comment">#是否显示草稿</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span>   <span class="comment">#是否启动 Asset 文件夹</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span>       <span class="comment">#把链接改为与根目录的相对位址    </span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span>               <span class="comment">#显示未来的文章</span></span><br><span class="line"><span class="attr">highlight:</span>                 <span class="comment">#内容中代码块的设置    </span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span>          <span class="comment">#分类别名</span></span><br><span class="line"><span class="attr">tag_map:</span>               <span class="comment">#标签别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span>         <span class="comment">#日期格式</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span>           <span class="comment">#时间格式    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span>    <span class="comment">#分页数量</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span>   <span class="comment">#主题名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="comment">#  部署部分的设置</span></span><br><span class="line"><span class="attr">deploy:</span>     </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span>  <span class="comment">#类型，常用的git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/nanshanyi/nanshanyi.github.io.git</span> <span class="comment">#github仓库的地址</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>如果页面中出现中文，应以UTF-8无BOM编码格式，所以不要用win自带的记事本，而是用notepad++这种支持编码转换的编辑器。</strong></p><p>由于google在天朝大陆被墙，进入 <code>themes\landscape\layout\_partial</code> ，打开 <code>head.ejs</code> ，删掉第31行 <code>fonts.googleapis.com</code> 的链接。</p><p>下载下来 <code>jQuery-2.0.3.min.js</code> ，放到 <code>themes\landscape\source\js</code> 文件夹中。之后进入 <code>themes\landscape\layout\_partial</code> ，打开 <code>after-footer.ejs</code> ，将第17行的路径替换为 <code>/js/jquery-2.0.3.min.js</code> 。</p><p>至此大功告成。</p><h2 id="写文章-amp-草稿"><a href="#写文章-amp-草稿" class="headerlink" title="写文章&amp;草稿"></a>写文章&amp;草稿</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p>命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post <span class="string">"new article"</span></span><br></pre></td></tr></table></figure><p>之后在 <code>soource/_posts</code> 目录下面多了一个 <code>new-article.md</code> 的文件。</p><h3 id="文章属性"><a href="#文章属性" class="headerlink" title="文章属性"></a>文章属性</h3><table><thead><tr><th>Setting</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>layout</td><td>Layout</td><td>post或page</td></tr><tr><td>title</td><td>文章的标题</td><td></td></tr><tr><td>date</td><td>穿件日期</td><td>文件的创建日期</td></tr><tr><td>updated</td><td>修改日期</td><td>文件的修改日期</td></tr><tr><td>comments</td><td>是否开启评论</td><td>true</td></tr><tr><td>tags</td><td>标签</td><td></td></tr><tr><td>categories</td><td>分类</td><td></td></tr><tr><td>permalink</td><td>url中的名字</td><td>文件名</td></tr><tr><td>toc</td><td>是否开启目录</td><td>true</td></tr><tr><td>reward</td><td>是否开启打赏</td><td>true</td></tr></tbody></table><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - 日记</span><br><span class="line">tags:</span><br><span class="line">  - Hexo</span><br><span class="line">  - node.js</span><br></pre></td></tr></table></figure><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><code>&lt;!--more--&gt;</code> 之上的内容为摘要。</p><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>草稿相当于很多博客都有的“私密文章”功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"new draft"</span></span><br></pre></td></tr></table></figure><p>会在 <code>source/_drafts</code> 目录下生成一个 <code>new-draft.md</code> 文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到 <code>_drafts</code> 目录之中。</p><p>如果你希望强行预览草稿，更改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render_drafts: true</span><br></pre></td></tr></table></figure><p>或者，如下方式启动server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server --drafts</span><br></pre></td></tr></table></figure><p>下面这条命令可以把草稿变成文章，或者页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">$ hexo publish drafts hexo-使用指南</span><br></pre></td></tr></table></figure><h2 id="Blog中出入图片和音乐"><a href="#Blog中出入图片和音乐" class="headerlink" title="Blog中出入图片和音乐"></a>Blog中出入图片和音乐</h2><p>文章推介：<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzUzZTBkMmE2MTdkYQ==" title="http://www.jianshu.com/p/53e0d2a617da">Hexo 博客中插入音乐/视频<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cDovL2Jsb2cuc2hpcWljaGFuLmNvbS91c2UtcWluaXUtc3RvcmUtaW1hZ2UtZm9yLWhleG8v" title="http://blog.shiqichan.com/use-qiniu-store-image-for-hexo/">使用七牛为Hexo存储图片<i class="fa fa-external-link"></i></span></p><pre><code>[hexo主题中添加相册功能](http://www.cnblogs.com/xljzlw/p/5137622.html)</code></pre><p>​           <span class="exturl" data-url="aHR0cDovL3d1Y2hvbmcubWUvYmxvZy8yMDE0LzEyLzEzL2hleG8tdGhlbWUtY3JlYXRpbmctaW1hZ2Utc3R5bGVzLz91dG1fc291cmNlPXR1aWNvb2wmdXRtX21lZGl1bT1yZWZlcnJhbCM=" title="http://wuchong.me/blog/2014/12/13/hexo-theme-creating-image-styles/?utm_source=tuicool&utm_medium=referral#">为 Hexo 主题添加多种图片样式(主题不错考虑移植)<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzg2MDc=" title="https://yq.aliyun.com/articles/8607">Hexo折腾记——基本配置篇<i class="fa fa-external-link"></i></span></p><p>​           <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9qYXJzb24tNzQyNi9wLzU1MTU4NzAuaHRtbA==" title="http://www.cnblogs.com/jarson-7426/p/5515870.html">hexo博客进阶－相册和独立域名<i class="fa fa-external-link"></i></span></p><p>插入图片基本分为两种办法** ：</p><p>（1） 放在本地文件</p><p>首先在根目录下确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。<br>在 hexo 目录，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>之后再使用 <code>hexo new &#39;new&#39;</code>创建新博客的时候，会在 <code>source/_posts</code> 里面创建 <code>.md</code> 文件的同时生成一个相同的名字的文件夹。把该文章中需要使用的图片放在该文件夹下即可。<br>使用的时候</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">“图片描述”（可以不写）</span>](<span class="link">/文件夹名/你的图片名字.JPG</span>)</span><br><span class="line">例如：</span><br><span class="line">！[ ] (new/text.jpg)</span><br></pre></td></tr></table></figure><p>（2）放在<span class="exturl" data-url="aHR0cHM6Ly9wb3J0YWwucWluaXUuY29tL3NpZ251cD9jb2RlPTNsZ2xhczZwZ2kycWE=" title="https://portal.qiniu.com/signup?code=3lglas6pgi2qa">七牛<i class="fa fa-external-link"></i></span>上，需要先注册，上传图片生成链接，直接在文章中使用链接即可。</p><p><strong>插入音乐</strong> ：</p><p>可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器；复制代码，直接粘贴到博文中即可。这样会显示一个网易的播放器，可以把</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">298</span> <span class="attr">height</span>=<span class="string">52</span> <span class="attr">src</span>=<span class="string">"http://music.163.com/outchain/player?type=2&amp;id=32192436&amp;auto=1&amp;height=32"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">//其中的width=298 height=52 均改为0就看不到了，依然可以播放音乐</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/Y60twn8.png" alt></p><p><img src="http://i.imgur.com/i42cvBI.png" alt></p><h2 id="代码高亮highlight-js支持"><a href="#代码高亮highlight-js支持" class="headerlink" title="代码高亮highlight.js支持"></a>代码高亮highlight.js支持</h2><p><span class="exturl" data-url="aHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcv" title="https://highlightjs.org/">highlightjs官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvc3RhdGljL2RlbW8v" title="https://highlightjs.org/static/demo/">highlightjs主题风格<i class="fa fa-external-link"></i></span></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy55ZWhiZWF0cy5jb20vMjAxNS8wNC8wOC9oZXhvLXNlYXJjaC8=" title="http://www.yehbeats.com/2015/04/08/hexo-search/">Hexo，Yilia主题添加站内搜索功能<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2t1YW5ncWkubWUvdHJpY2tzL2VuYWJsZS10YWJsZS1vZi1jb250ZW50cy1vbi1oZXhvLw==" title="http://kuangqi.me/tricks/enable-table-of-contents-on-hexo/">为Hexo博客添加目录<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9hcnRpY2xlLzE5OTYyNA==" title="http://www.ituring.com.cn/article/199624">Hexo站点中添加文章目录以及归档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2NyZXNjZW50bW9vbi5pbmZvLzIwMTQvMTIvMTEvcG9wdWxhci13aWRnZXQv" title="http://crescentmoon.info/2014/12/11/popular-widget/">使用LeanCloud平台为Hexo博客添加文章浏览量统计组件<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy50dWljb29sLmNvbS9hcnRpY2xlcy9BQkZuMnFV" title="http://www.tuicool.com/articles/ABFn2qU">使用hexo搭建静态博客<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9hcnRpY2xlLzE5OTAzNT91dG1fc291cmNlPXR1aWNvb2wmdXRtX21lZGl1bT1yZWZlcnJhbA==" title="http://www.ituring.com.cn/article/199035?utm_source=tuicool&utm_medium=referral">Hexo Docs中文 ： （二）基本用法<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装、初始化和配置&quot;&gt;&lt;a href=&quot;#安装、初始化和配置&quot; class=&quot;headerlink&quot; title=&quot;安装、初始化和配置&quot;&gt;&lt;/a&gt;安装、初始化和配置&lt;/h2&gt;&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;node.js&lt;/li&gt;
&lt;li&gt;github&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://miaopei.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>nodejs+webpack+vuejs 搭建开发环境学习套路</title>
    <link href="http://miaopei.github.io/2017/03/27/nodejs-webpack-vuejs-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AD%A6%E4%B9%A0%E5%A5%97%E8%B7%AF/"/>
    <id>http://miaopei.github.io/2017/03/27/nodejs-webpack-vuejs-搭建开发环境学习套路/</id>
    <published>2017-03-27T10:02:52.000Z</published>
    <updated>2017-03-28T10:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><span class="exturl" data-url="aHR0cDovL3Z1ZWpzLm9yZy92Mi9ndWlkZS8=" title="http://vuejs.org/v2/guide/">官方手册<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv" title="https://cn.vuejs.org/">中文官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly92dWVmZS5jbi92Mi9ndWlkZS8=" title="https://vuefe.cn/v2/guide/">vuejs 2.0 中文文档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=" title="http://es6.ruanyifeng.com/">ECMAScript 6 入门<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Nub2RlanMub3JnL3RvcGljLzUyOGM5YTM4ZDJiMzg5M2YyYWJiNmVlYg==" title="http://cnodejs.org/topic/528c9a38d2b3893f2abb6eeb">node.js相关的中文文档及教程<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkv" title="http://nodejs.cn/api/">Node.js中文网API<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3dlYnBhY2tkb2MuY29tLw==" title="http://webpackdoc.com/">Webpack 中文指南<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3dlYnBhY2syLw==" title="http://www.css88.com/doc/webpack2/">webpack2.2中文文档<i class="fa fa-external-link"></i></span></p><p>以上是提供的一些官方资料，下面开始我们的套路吧：</p><a id="more"></a><h3 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建"></a>环境构建</h3><p>1.新建一个目录<code>vuepro</code><br>2.初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vuepro</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化的时候可以一路回车，在最后输入"yes"后会生成package.json文件</span></span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>3.安装模块，先装这么多，有需要再安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install vue webpack babel-loader babel-core babel-preset-env babel-cli babel-preset-es2015 html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>4.创建良好的目录层级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir src</span><br><span class="line">$ <span class="built_in">cd</span> src &amp;&amp; mkdir -p html jssrc webapp</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/qkj7kJd.png" alt>    </p><p><code>html</code>放置模板文件，<code>jssrc</code>放置js文件，最终编译好的文件放置在<code>webapp</code>目录里，这个目录也就是我们网站的目录。</p><p>5.在项目根目录下创建webpack配置文件：<code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack=<span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports =</span><br><span class="line">&#123;</span><br><span class="line">    entry:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//入口文件</span></span><br><span class="line">        <span class="string">"index"</span>:__dirname+<span class="string">'/src/jssrc/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname+<span class="string">'/src/webapp/js'</span>,  <span class="comment">//输出文件夹</span></span><br><span class="line">        filename:<span class="string">'[name].js'</span>   <span class="comment">//最终打包生成的文件名(只是文件名，不带路径的哦)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*resolve: &#123;</span></span><br><span class="line"><span class="comment">        alias: &#123;</span></span><br><span class="line"><span class="comment">            vue: 'vue/dist/vue.js'</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;,*/</span></span><br><span class="line">    externals: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,<span class="attr">loader</span>:<span class="string">"babel-loader"</span>,<span class="attr">query</span>:&#123;<span class="attr">compact</span>:<span class="literal">true</span>&#125;&#125;,</span><br><span class="line">            <span class="comment">//这里肯定要加入n个loader 譬如vue-loader、babel-loader、css-loader等等</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            filename: __dirname+<span class="string">'/src/webapp/index.html'</span>,   <span class="comment">//目标文件</span></span><br><span class="line">            template: __dirname+<span class="string">'/src/html/index.html'</span>, <span class="comment">//模板文件</span></span><br><span class="line">            inject:<span class="string">'body'</span>,</span><br><span class="line">            hash:<span class="literal">true</span>,  <span class="comment">//代表js文件后面会跟一个随机字符串,解决缓存问题</span></span><br><span class="line">            chunks:[<span class="string">"index"</span>]</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.同样在根目录下创建babel配置文件：<code>.babelrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot; : [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在webpack里面配置loader，我们上面webpack配置中已经写了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loaders:[</span><br><span class="line">           &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,<span class="attr">loader</span>:<span class="string">"babel-loader"</span>,<span class="attr">query</span>:&#123;<span class="attr">compact</span>:<span class="literal">true</span>&#125;&#125;,</span><br><span class="line">  <span class="comment">// 经过测试旧版用的是loader:"babel",在新版中用的是loader:"babel-loader"</span></span><br><span class="line">       ]</span><br></pre></td></tr></table></figure><p>这句话意思就是：凡是 <code>.js</code> 文件都使用 <code>babel-loader</code> , 并且压缩。</p><h3 id="学习vue最简单的一个套路"><a href="#学习vue最简单的一个套路" class="headerlink" title="学习vue最简单的一个套路"></a>学习vue最简单的一个套路</h3><p>思考：数据如何渲染？</p><p>套路如下：</p><p>首先要有个数据块标记</p><p>vue里面可以像模板引擎一样写上 <code>{\{name\}}</code></p><p>其中 <code>name</code> 就是变量名</p><h3 id="接下来进行实战练习"><a href="#接下来进行实战练习" class="headerlink" title="接下来进行实战练习"></a>接下来进行实战练习</h3><p><img src="http://i.imgur.com/UhW18FI.png" alt>    </p><p>index.htm l如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"me"</span>&gt;</span></span><br><span class="line">        我的年龄是&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index.js 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>; <span class="comment">//会去node_modules\vue\package.json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#me"</span>,</span><br><span class="line">    data:&#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此，我们需要用 <code>webpack</code> 打包，打包到 <code>webapp</code> 目录下。 </p><p>需要修改2个地方： </p><p>(1)因为我们的 <code>webpack</code> 不是全局安装的，所以不能直接执行 <code>webpack</code> 命令，我们这里借助 <code>npm</code> 来执行。所以需要修改项目根目录下的 <code>package.json</code> 文件，加入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">  "build": "webpack"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>表示：执行build，就会去node_modules.bin\下去寻找webpack命令。<code>build</code> 这个名字是自定义的。</p><p>(2)还需要修改 webpack 配置文件：<code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            vue: <span class="string">'vue/dist/vue.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>我们之前把这个注释掉了，现在打开。此处的意义是找到 <code>node_modules/vue/dist/vue.js</code></p><p>最后，我们就来打包，看看结果是怎样的？ </p><p>终端里还是cd到项目根目录下，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/wmjrYdu.png" alt>    </p><p><code>index.html</code>  就是打包之后的模板文件，<code>js/index.js</code> 就是打包之后的js文件，在 <code>index.html</code> 被引用了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"me"</span>&gt;</span></span><br><span class="line">        我的年龄是&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/index.js?43c73980e35f1569ef72"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预览一下index.html: </p><p><img src="http://i.imgur.com/6kHwB4L.png" alt></p><p>这样就完成了 <code>vueJS</code> 的一个简单案列</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3Z1ZWpzLm9yZy92Mi9ndWlkZS8=&quot; title=&quot;http://vuejs.org/v2/guide/&quot;&gt;官方手册&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jbi52dWVqcy5vcmcv&quot; title=&quot;https://cn.vuejs.org/&quot;&gt;中文官网&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly92dWVmZS5jbi92Mi9ndWlkZS8=&quot; title=&quot;https://vuefe.cn/v2/guide/&quot;&gt;vuejs 2.0 中文文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=&quot; title=&quot;http://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Nub2RlanMub3JnL3RvcGljLzUyOGM5YTM4ZDJiMzg5M2YyYWJiNmVlYg==&quot; title=&quot;http://cnodejs.org/topic/528c9a38d2b3893f2abb6eeb&quot;&gt;node.js相关的中文文档及教程&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL25vZGVqcy5jbi9hcGkv&quot; title=&quot;http://nodejs.cn/api/&quot;&gt;Node.js中文网API&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3dlYnBhY2tkb2MuY29tLw==&quot; title=&quot;http://webpackdoc.com/&quot;&gt;Webpack 中文指南&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3dlYnBhY2syLw==&quot; title=&quot;http://www.css88.com/doc/webpack2/&quot;&gt;webpack2.2中文文档&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上是提供的一些官方资料，下面开始我们的套路吧：&lt;/p&gt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://miaopei.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 支持的语言</title>
    <link href="http://miaopei.github.io/2017/03/23/Markdown-%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%AD%E8%A8%80/"/>
    <id>http://miaopei.github.io/2017/03/23/Markdown-支持的语言/</id>
    <published>2017-03-23T15:15:37.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown支持的语言"><a href="#Markdown支持的语言" class="headerlink" title="Markdown支持的语言"></a>Markdown支持的语言</h2><table><thead><tr><th align="left">名称</th><th>关键字</th><th>调用的js</th></tr></thead><tbody><tr><td align="left">AppleScript</td><td>applescript</td><td>shBrushAppleScript.js</td></tr><tr><td align="left">ActionScript 3.0</td><td>actionscript3 , as3</td><td>shBrushAS3.js</td></tr><tr><td align="left">Shell</td><td>bash , shell</td><td>shBrushBash.js</td></tr><tr><td align="left">ColdFusion</td><td>coldfusion , cf</td><td>shBrushColdFusion.js</td></tr><tr><td align="left">C</td><td>cpp , c</td><td>shBrushCpp.js</td></tr><tr><td align="left">C#</td><td>c# , c-sharp , csharp</td><td>shBrushCSharp.js</td></tr><tr><td align="left">CSS</td><td>css</td><td>shBrushCss.js</td></tr><tr><td align="left">Delphi</td><td>delphi , pascal , pas</td><td>shBrushDelphi.js</td></tr><tr><td align="left">diff&amp;patch</td><td>diff patch</td><td>shBrushDiff.js</td></tr><tr><td align="left">Erlang</td><td>erl , erlang</td><td>shBrushErlang.js</td></tr><tr><td align="left">Groovy</td><td>groovy</td><td>shBrushGroovy.js</td></tr><tr><td align="left">Java</td><td>java</td><td>shBrushJava.js</td></tr><tr><td align="left">JavaFX</td><td>jfx , javafx</td><td>shBrushJavaFX.js</td></tr><tr><td align="left">JavaScript</td><td>js , jscript , javascript</td><td>shBrushJScript.js</td></tr><tr><td align="left">Perl</td><td>perl , pl , Perl</td><td>shBrushPerl.js</td></tr><tr><td align="left">PHP</td><td>php</td><td>shBrushPhp.js</td></tr><tr><td align="left">text</td><td>text , plain</td><td>shBrushPlain.js</td></tr><tr><td align="left">Python</td><td>py , python</td><td>shBrushPython.js</td></tr><tr><td align="left">Ruby</td><td>ruby , rails , ror , rb</td><td>shBrushRuby.js</td></tr><tr><td align="left">SASS&amp;SCSS</td><td>sass , scss</td><td>shBrushSass.js</td></tr><tr><td align="left">Scala</td><td>scala</td><td>shBrushScala.js</td></tr><tr><td align="left">SQL</td><td>sql</td><td>shBrushSql.js</td></tr><tr><td align="left">Visual Basic</td><td>vb , vbnet</td><td>shBrushVb.js</td></tr><tr><td align="left">XML</td><td>xml , xhtml , xslt , html</td><td>shBrushXml.js</td></tr><tr><td align="left">Objective C</td><td>objc , obj-c</td><td>shBrushObjectiveC.js</td></tr><tr><td align="left">F#</td><td>f# f-sharp , fsharp</td><td>shBrushFSharp.js</td></tr><tr><td align="left">R</td><td>r , s , splus</td><td>shBrushR.js</td></tr><tr><td align="left">matlab</td><td>matlab</td><td>shBrushMatlab.js</td></tr><tr><td align="left">swift</td><td>swift</td><td>shBrushSwift.js</td></tr><tr><td align="left">GO</td><td>go , golang</td><td>shBrushGo.js</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Markdown支持的语言&quot;&gt;&lt;a href=&quot;#Markdown支持的语言&quot; class=&quot;headerlink&quot; title=&quot;Markdown支持的语言&quot;&gt;&lt;/a&gt;Markdown支持的语言&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th alig
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://miaopei.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;深入解析Go&gt;&gt; 很棒的GitBook</title>
    <link href="http://miaopei.github.io/2017/03/21/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go-%E5%BE%88%E6%A3%92%E7%9A%84GitBook/"/>
    <id>http://miaopei.github.io/2017/03/21/深入解析Go-很棒的GitBook/</id>
    <published>2017-03-21T11:39:42.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<p>很不错的golang剖析，建议有golang基础的再看，讲解的非常详细。<br><span class="exturl" data-url="aHR0cHM6Ly90aWFuY2FpYW1hby5naXRib29rcy5pby9nby1pbnRlcm5hbHMvY29udGVudC96aC8=" title="https://tiancaiamao.gitbooks.io/go-internals/content/zh/">深入解析Go<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很不错的golang剖析，建议有golang基础的再看，讲解的非常详细。&lt;br&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly90aWFuY2FpYW1hby5naXRib29rcy5pby9nby1pbnRlcm5hbHMvY29udG
      
    
    </summary>
    
    
      <category term="golang" scheme="http://miaopei.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Google Rss 加载失败解决</title>
    <link href="http://miaopei.github.io/2017/03/21/Google-Rss-%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3/"/>
    <id>http://miaopei.github.io/2017/03/21/Google-Rss-加载失败解决/</id>
    <published>2017-03-20T19:46:09.000Z</published>
    <updated>2019-06-03T08:10:56.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>博客在google浏览器中使用RSS会出现RSS源码，原因是google浏览器没有安装RSS插件。<br>解决办法，到google网上应用店安装 <b style="color: red">RSS Subscription Extension</b> 即可解决问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;博客在google浏览器中使用RSS会出现RSS源码，原因是google浏览器没有安装RSS插件。&lt;br&gt;解决办法，到google网上应用店安装 &lt;b style=&quot;color: red&quot;&gt;RSS Subscription Extension&lt;/b
      
    
    </summary>
    
    
      <category term="rss" scheme="http://miaopei.github.io/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github 博客多终端同步</title>
    <link href="http://miaopei.github.io/2017/03/20/Hexo-Github-%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/"/>
    <id>http://miaopei.github.io/2017/03/20/Hexo-Github-博客多终端同步/</id>
    <published>2017-03-19T20:20:57.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9ua2V5X0xaTC9hcnRpY2xlL2RldGFpbHMvNjA4NzA4OTE=" title="http://blog.csdn.net/Monkey_LZL/article/details/60870891">原文链接<i class="fa fa-external-link"></i></span></p><p>主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解：</p><h2 id="1-准备条件"><a href="#1-准备条件" class="headerlink" title="1. 准备条件"></a>1. 准备条件</h2><p>安装了Node.js,Git,Hexo环境<br>完成Github与本地Hexo的对接<br>这部分大家可以参考<span class="exturl" data-url="aHR0cHM6Ly94dWFud28ub3JnLzIwMTUvMDMvMjYvaGV4by1pbnRvci8=" title="https://xuanwo.org/2015/03/26/hexo-intor/">史上最详细的Hexo博客搭建图文教程<i class="fa fa-external-link"></i></span></p><p>配置好这些，就可以捋起袖子大干一场了！</p><h2 id="2-在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上"><a href="#2-在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上" class="headerlink" title="2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上"></a>2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上</h2><p>在利用Github+Hexo搭建自己的博客时，新建了一个Hexo的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到Github项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件</span></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line">$ git commit -m <span class="string">"Blog Source Hexo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建hexo分支</span></span><br><span class="line">$ git branch hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到hexo分支上</span></span><br><span class="line">$ git checkout hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地与Github项目对接</span></span><br><span class="line">$ git remote add origin https://github.com/yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># push到Github项目的hexo分支上</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure><p>这样你的github项目中就会多出一个Hexo分支，这个就是用于多终端同步关键的部分。</p><h2 id="3-另一终端完成clone和push更新"><a href="#3-另一终端完成clone和push更新" class="headerlink" title="3. 另一终端完成clone和push更新"></a>3. 另一终端完成clone和push更新</h2><p>此时在另一终端更新博客，只需要将Github的hexo分支clone下来，进行初次的相关配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将Github中hexo分支clone到本地</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b hexo https://github.com/yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到刚刚clone的文件夹内</span></span><br><span class="line">$ <span class="built_in">cd</span> yourname.github.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># cheackout 远程代码到本地hexo分支</span></span><br><span class="line">$ git checkout -b hexo origin/hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init</span></span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个.md文件，并编辑完成自己的博客内容</span></span><br><span class="line">$ hexo new post <span class="string">"new blog name"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客</span></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line">$ git commit -m <span class="string">"XX"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新分支</span></span><br><span class="line">$ git push origin hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master</span></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><h2 id="4-不同终端间愉快地玩耍"><a href="#4-不同终端间愉快地玩耍" class="headerlink" title="4. 不同终端间愉快地玩耍"></a>4. 不同终端间愉快地玩耍</h2><p>在不同的终端已经做完配置，就可以愉快的分享自己更新的博客<br>进入自己相应的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先pull完成本地与远端的融合</span></span><br><span class="line">$ git pull origin hexo</span><br><span class="line"></span><br><span class="line">$ hexo new post <span class="string">" new blog name"</span></span><br><span class="line"></span><br><span class="line">$ git add <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"XX"</span></span><br><span class="line"></span><br><span class="line">$ git push origin hexo</span><br><span class="line"></span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9ua2V5X0xaTC9hcnRpY2xlL2RldGFpbHMvNjA4NzA4OTE=&quot; title=&quot;http://blog.csdn.net/
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://miaopei.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Git远程操作详解</title>
    <link href="http://miaopei.github.io/2017/01/27/git-remote-operation/"/>
    <id>http://miaopei.github.io/2017/01/27/git-remote-operation/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。</p><p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p><a id="more"></a><ul><li>git clone</li><li>git remote</li><li>git fetch</li><li>git pull</li><li>git push</li></ul><p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p><p><img src="http://i.imgur.com/m5Q68Gr.png" alt></p><h2 id="一、git-clone"><a href="#一、git-clone" class="headerlink" title="一、git clone"></a>一、git clone</h2><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到 <code>git clone</code> 命令。</p><pre><code>$ git clone &lt;版本库的网址&gt;</code></pre><p>比如，克隆jQuery的版本库。</p><pre><code>$ git clone https://github.com/jquery/jquery.git</code></pre><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为 <code>git clone</code> 命令的第二个参数。</p><pre><code>$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code></pre><p><code>git clone</code> 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p><pre><code>$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/</code></pre><p>SSH协议还有另一种写法。</p><pre><code>$ git clone [user@]example.com:path/to/repo.git/</code></pre><p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p><h2 id="二、git-remote"><a href="#二、git-remote" class="headerlink" title="二、git remote"></a>二、git remote</h2><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code> 命令就用于管理主机名。</p><p>不带选项的时候，<code>git remote</code> 命令列出所有远程主机。</p><pre><code>$ git remoteorigin</code></pre><p>使用 <code>-v</code> 选项，可以参看远程主机的网址。</p><pre><code>$ git remote -vorigin  git@github.com:jquery/jquery.git (fetch)origin  git@github.com:jquery/jquery.git (push)</code></pre><p>上面命令表示，当前只有一台远程主机，叫做 <code>origin</code>，以及它的网址。</p><p>克隆版本库的时候，所使用的远程主机自动被Git命名为 <code>origin</code>。如果想用其他的主机名，需要用 <code>git clone</code> 命令的 <code>-o</code> 选项指定。</p><pre><code>$ git clone -o jQuery https://github.com/jquery/jquery.git$ git remotejQuery</code></pre><p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p><p><code>git remote show</code> 命令加上主机名，可以查看该主机的详细信息。</p><pre><code>$ git remote show &lt;主机名&gt;</code></pre><p><code>git remote add</code> 命令用于添加远程主机。</p><pre><code>$ git remote add &lt;主机名&gt; &lt;网址&gt;</code></pre><p><code>git remote rm</code> 命令用于删除远程主机。</p><pre><code>$ git remote rm &lt;主机名&gt;</code></pre><p><code>git remote rename</code> 命令用于远程主机的改名。</p><pre><code>$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></pre><h2 id="三、git-fetch"><a href="#三、git-fetch" class="headerlink" title="三、git fetch"></a>三、git fetch</h2><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到 <code>git fetch</code> 命令。</p><pre><code>$ git fetch &lt;远程主机名&gt;</code></pre><p>上面命令将某个远程主机的更新，全部取回本地。</p><p><code>git fetch</code> 命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p><p>默认情况下，<code>git fetch</code> 取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p><pre><code>$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></pre><p>比如，取回 <code>origin</code> 主机的 <code>master</code> 分支。</p><pre><code>$ git fetch origin master</code></pre><p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如 <code>origin</code> 主机的 <code>master</code>，就要用 <code>origin/master</code> 读取。</p><p><code>git branch</code> 命令的 <code>-r</code> 选项，可以用来查看远程分支，<code>-a</code> 选项查看所有分支。</p><pre><code>$ git branch -rorigin/master$ git branch -a* master  remotes/origin/master</code></pre><p>上面命令表示，本地主机的当前分支是 <code>master</code>，远程分支是 <code>origin/master</code>。</p><p>取回远程主机的更新以后，可以在它的基础上，使用 <code>git checkout</code> 命令创建一个新的分支。</p><pre><code>$ git checkout -b newBrach origin/master</code></pre><p>上面命令表示，在 <code>origin/master</code> 的基础上，创建一个新分支。</p><p>此外，也可以使用 <code>git merge</code> 命令或者 <code>git rebase</code> 命令，在本地分支上合并远程分支。</p><pre><code>$ git merge origin/master# 或者$ git rebase origin/master</code></pre><p>上面命令表示在当前分支上，合并 <code>origin/master</code>。</p><h2 id="四、git-pull"><a href="#四、git-pull" class="headerlink" title="四、git pull"></a>四、git pull</h2><p><code>git pull</code> 命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p><pre><code>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>比如，取回 <code>origin</code> 主机的 <code>next</code> 分支，与本地的 <code>master</code> 分支合并，需要写成下面这样。</p><pre><code>$ git pull origin next:master</code></pre><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><pre><code>$ git pull origin next</code></pre><p>上面命令表示，取回 <code>origin/next</code> 分支，再与当前分支合并。实质上，这等同于先做 <code>git fetch</code> ，再做 <code>git merge</code>。</p><pre><code>$ git fetch origin$ git merge origin/next</code></pre><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在 <code>git clone</code> 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 <code>master</code> 分支自动”追踪” <code>origin/master</code> 分支。</p><p>Git也允许手动建立追踪关系。</p><pre><code>git branch --set-upstream master origin/next</code></pre><p>上面命令指定 <code>master</code> 分支追踪 <code>origin/next</code> 分支。</p><p>如果当前分支与远程分支存在追踪关系，<code>git pull</code> 就可以省略远程分支名。</p><pre><code>$ git pull origin</code></pre><p>上面命令表示，本地的当前分支自动与对应的 <code>origin</code> 主机”追踪分支”（remote-tracking branch）进行合并。</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><pre><code>$ git pull</code></pre><p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p><p>如果合并需要采用 <code>rebase</code> 模式，可以使用 <code>--rebase</code> 选项。</p><pre><code>$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致 <code>git pull</code> 不知不觉删除了本地分支。</p><p>但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。</p><pre><code>$ git pull -p# 等同于下面的命令$ git fetch --prune origin $ git fetch -p</code></pre><h2 id="五、git-push"><a href="#五、git-push" class="headerlink" title="五、git push"></a>五、git push</h2><p><code>git push</code> 命令用于将本地分支的更新，推送到远程主机。它的格式与 <code>git pull</code> 命令相仿。</p><pre><code>$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></pre><p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以 <code>git pull</code> 是&lt;远程分支&gt;:&lt;本地分支&gt;，而 <code>git push</code> 是&lt;本地分支&gt;:&lt;远程分支&gt;。</p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><pre><code>$ git push origin master</code></pre><p>上面命令表示，将本地的 <code>master</code> 分支推送到 <code>origin</code> 主机的 <code>master</code> 分支。如果后者不存在，则会被新建。</p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><pre><code>$ git push origin :master# 等同于$ git push origin --delete master</code></pre><p>上面命令表示删除 <code>origin</code> 主机的 <code>master</code> 分支。</p><p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p><pre><code>$ git push origin</code></pre><p>上面命令表示，将当前分支推送到 <code>origin</code> 主机的对应分支。</p><p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p><pre><code>$ git push</code></pre><p>如果当前分支与多个主机存在追踪关系，则可以使用 <code>-u</code> 选项指定一个默认主机，这样后面就可以不加任何参数使用 <code>git push</code>。</p><pre><code>$ git push -u origin master</code></pre><p>上面命令将本地的 <code>master</code> 分支推送到 <code>origin</code> 主机，同时指定 <code>origin</code> 为默认主机，后面就可以不加任何参数使用 <code>git push</code> 了。</p><p>不带任何参数的 <code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用 <code>git config</code> 命令。</p><pre><code>$ git config --global push.default matching# 或者$ git config --global push.default simple</code></pre><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 <code>--all</code> 选项。</p><pre><code>$ git push --all origin</code></pre><p>上面命令表示，将所有本地分支都推送到 <code>origin</code> 主机。</p><p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做 <code>git pull</code> 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 <code>--force</code> 选项。</p><pre><code>$ git push --force origin </code></pre><p>上面命令使用 <code>--force</code> 选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用 <code>--force</code> 选项。</p><p>最后，<code>git push</code> 不会推送标签（tag），除非使用 <code>--tags</code> 选项。</p><pre><code>$ git push origin --tags</code></pre>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git工作流程</title>
    <link href="http://miaopei.github.io/2017/01/27/git-workflow/"/>
    <id>http://miaopei.github.io/2017/01/27/git-workflow/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<p>Git 作为一个源码管理系统，不可避免涉及到多人协作。</p><p>协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。</p><a id="more"></a><p><img src="http://i.imgur.com/KCRatZr.png" alt></p><p>本文介绍三种广泛使用的工作流程：</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow</li></ul><h2 id="一、功能驱动"><a href="#一、功能驱动" class="headerlink" title="一、功能驱动"></a>一、功能驱动</h2><p>本文的三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。</p><p>它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。</p><h2 id="二、Git-Flow"><a href="#二、Git-Flow" class="headerlink" title="二、Git Flow"></a>二、Git Flow</h2><p>最早诞生、并得到广泛采用的一种工作流程，就是Git flow 。</p><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><p>它最主要的特点有两个。</p><p><img src="http://i.imgur.com/8RTngnI.png" alt></p><p>首先，项目存在两个长期分支。</p><ul><li>主分支 <code>master</code></li><li>开发分支 <code>develop</code></li></ul><p>前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放最新的开发版。</p><p>其次，项目存在三种短期分支。</p><ul><li>功能分支（feature branch）</li><li>补丁分支（hotfix branch）</li><li>预发分支（release branch）</li></ul><p>一旦完成开发，它们就会被合并进 <code>develop</code> 或 <code>master</code> ，然后被删除。</p><h3 id="2-2-评价"><a href="#2-2-评价" class="headerlink" title="2.2 评价"></a>2.2 评价</h3><p>Git flow的优点是清晰可控，缺点是相对复杂，需要同时维护两个长期分支。大多数工具都将 <code>master</code> 当作默认分支，可是开发是在 <code>develop</code> 分支进行的，这导致经常要切换分支，非常烦人。</p><p>更大问题在于，这个模式是基于”版本发布”的，目标是一段时间以后产出一个新版本。但是，很多网站项目是”持续发布”，代码一有变动，就部署一次。这时， <code>master</code> 分支和 <code>develop</code> 分支的差别不大，没必要维护两个长期分支。</p><h2 id="三、Github-flow"><a href="#三、Github-flow" class="headerlink" title="三、Github flow"></a>三、Github flow</h2><p>Github flow 是Git flow的简化版，专门配合”持续发布”。它是 Github.com 使用的工作流程。</p><h3 id="3-1-流程"><a href="#3-1-流程" class="headerlink" title="3.1 流程"></a>3.1 流程</h3><p>它只有一个长期分支，就是 <code>master</code> ，因此用起来非常简单。</p><p>官方推荐的流程如下。</p><p><img src="http://i.imgur.com/d7sDto2.png" alt></p><pre><code>第一步：根据需求，从 master 拉出新分支，不区分功能分支或补丁分支。第二步：新分支开发完成后，或者需要讨论的时候，就向 master 发起一个 pull request（简称PR）。第三步：Pull Request 既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。第四步：你的 Pull Request 被接受，合并进 master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</code></pre><h3 id="3-2-评价"><a href="#3-2-评价" class="headerlink" title="3.2 评价"></a>3.2 评价</h3><p>Github flow 的最大优点就是简单，对于”持续发布”的产品，可以说是最合适的流程。</p><p>问题在于它的假设：<code>master</code> 分支的更新与产品的发布是一致的。也就是说，<code>master</code> 分支的最新代码，默认就是当前的线上代码。</p><p>可是，有些时候并非如此，代码合并进入 <code>master</code> 分支，并不代表它就能立刻发布。比如，苹果商店的APP提交审核以后，等一段时间才能上架。这时，如果还有新的代码提交，<code>master</code> 分支就会与刚发布的版本不一致。另一个例子是，有些公司有发布窗口，只有指定时间才能发布，这也会导致线上版本落后于 <code>master</code> 分支。</p><p>上面这种情况，只有 <code>master</code> 一个主分支就不够用了。通常，你不得不在master分支以外，另外新建一个 <code>production</code> 分支跟踪线上版本。</p><h2 id="四、Gitlab-flow"><a href="#四、Gitlab-flow" class="headerlink" title="四、Gitlab flow"></a>四、Gitlab flow</h2><p>Gitlab flow 是 Git flow 与 Github flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。</p><h3 id="4-1-上游优先"><a href="#4-1-上游优先" class="headerlink" title="4.1 上游优先"></a>4.1 上游优先</h3><p>Gitlab flow 的最大原则叫做”上游优先”（upsteam first），即只存在一个主分支 <code>master</code>，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。</p><p>Chromium项目就是一个例子，它明确规定，上游分支依次为：</p><ol><li>Linus Torvalds的分支</li><li>子系统（比如netdev）的分支</li><li>设备厂商（比如三星）的分支</li></ol><h3 id="4-2-持续发布"><a href="#4-2-持续发布" class="headerlink" title="4.2 持续发布"></a>4.2 持续发布</h3><p>Gitlab flow 分成两种情况，适应不同的开发流程。</p><p><img src="http://i.imgur.com/SLLsAER.png" alt></p><p>对于”持续发布”的项目，它建议在 <code>master</code> 分支以外，再建立不同的环境分支。比如，”开发环境”的分支是 <code>master</code>，”预发环境”的分支是 <code>pre-production</code>，”生产环境”的分支是 <code>production</code>。</p><p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到 <code>master</code>，确认没有问题，再 <code>cherry-pick</code> 到 <code>pre-production</code> ，这一步也没有问题，才进入 <code>production</code>。</p><p>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p><h3 id="4-3-版本发布"><a href="#4-3-版本发布" class="headerlink" title="4.3 版本发布"></a>4.3 版本发布</h3><p><img src="http://i.imgur.com/0x3ExTi.png" alt></p><p>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从 <code>master</code> 分支拉出一个分支，比如 <code>2-3-stable</code>、<code>2-4-stable</code> 等等。</p><p>以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。</p><h2 id="五、一些小技巧"><a href="#五、一些小技巧" class="headerlink" title="五、一些小技巧"></a>五、一些小技巧</h2><h3 id="5-1-Pull-Request"><a href="#5-1-Pull-Request" class="headerlink" title="5.1 Pull Request"></a>5.1 Pull Request</h3><p><img src="http://i.imgur.com/pv6ho8H.png" alt></p><p>功能分支合并进 <code>master</code> 分支，必须通过 <code>Pull Request</code>（Gitlab里面叫做 Merge Request）。</p><p><img src="http://i.imgur.com/uXRDTx8.png" alt></p><p>前面说过，Pull Request本质是一种对话机制，你可以在提交的时候，@相关人员或团队，引起他们的注意。</p><h3 id="5-2-Protected-branch"><a href="#5-2-Protected-branch" class="headerlink" title="5.2 Protected branch"></a>5.2 Protected branch</h3><p><code>master</code> 分支应该受到保护，不是每个人都可以修改这个分支，以及拥有审批 <code>Pull Request</code> 的权力。<br>Github 和 Gitlab 都提供”保护分支”（Protected branch）这个功能。</p><h3 id="5-3-Issue"><a href="#5-3-Issue" class="headerlink" title="5.3 Issue"></a>5.3 Issue</h3><p>Issue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。</p><p>功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如”15-require-a-password-to-change-it”。</p><p><img src="http://i.imgur.com/6G4rMsn.png" alt></p><p>开发完成后，在提交说明里面，可以写上 <code>&quot;fixes #14&quot;</code> 或者 <code>&quot;closes #67&quot;</code>。Github规定，只要 <code>commit message</code> 里面有下面这些动词 + 编号，就会关闭对应的issue。</p><ul><li>close</li><li>closes</li><li>closed</li><li>fix</li><li>fixes</li><li>fixed</li><li>resolve</li><li>resolves</li><li>resolved</li></ul><p>这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是 <code>username/repository#issue_number</code>。</p><p><code>Pull Request</code>被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。</p><h3 id="5-4-Merge节点"><a href="#5-4-Merge节点" class="headerlink" title="5.4 Merge节点"></a>5.4 Merge节点</h3><p>Git有两种合并：一种是”直进式合并”（fast forward），不生成单独的合并节点；另一种是”非直进式合并”（none fast-forword），会生成单独节点。</p><p>前者不利于保持 <code>commit</code> 信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用 <code>--no-ff</code> 参数）。只要发生合并，就要有一个单独的合并节点。</p><h3 id="5-5-Squash-多个-commit"><a href="#5-5-Squash-多个-commit" class="headerlink" title="5.5 Squash 多个 commit"></a>5.5 Squash 多个 commit</h3><p>为了便于他人阅读你的提交，也便于 <code>cherry-pick</code> 或撤销代码变化，在发起 <code>Pull Request</code> 之前，应该把多个 <code>commit</code> 合并成一个。（前提是，该分支只有你一个人开发，且没有跟 <code>master</code> 合并过。）</p><p><img src="http://i.imgur.com/NsLF4by.png" alt></p><p>这可以采用rebase命令附带的squash操作，具体方法请参考《Git 使用规范流程》。</p>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git使用规范流程</title>
    <link href="http://miaopei.github.io/2017/01/27/git-using-standard-process/"/>
    <id>http://miaopei.github.io/2017/01/27/git-using-standard-process/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。</p><p>否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。</p><p>下面是ThoughtBot 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。</p><a id="more"></a><p><img src="http://i.imgur.com/WjTakfD.png" alt></p><h2 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h2><p>首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考《Git分支管理策略》）。</p><pre><code># 获取主干最新代码$ git checkout master$ git pull# 新建一个开发分支myfeature$ git checkout -b myfeature</code></pre><h2 id="第二步：提交分支commit"><a href="#第二步：提交分支commit" class="headerlink" title="第二步：提交分支commit"></a>第二步：提交分支commit</h2><p>分支修改后，就可以提交commit了。</p><pre><code>$ git add --all$ git status$ git commit --verbose</code></pre><p><code>git add</code> 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。</p><p><code>git status</code> 命令，用来查看发生变动的文件。</p><p><code>git commit</code> 命令的 <code>verbose</code> 参数，会列出 diff 的结果。</p><h2 id="第三步：撰写提交信息"><a href="#第三步：撰写提交信息" class="headerlink" title="第三步：撰写提交信息"></a>第三步：撰写提交信息</h2><p>提交commit时，必须给出完整扼要的提交信息，下面是一个范本。</p><pre><code>Present-tense summary under 50 characters* More information about commit (under 72 characters).* More information about commit (under 72 characters).http://project.management-system.com/ticket/123</code></pre><p>第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。</p><h2 id="第四步：与主干同步"><a href="#第四步：与主干同步" class="headerlink" title="第四步：与主干同步"></a>第四步：与主干同步</h2><p>分支的开发过程中，要经常与主干保持同步。</p><pre><code>$ git fetch origin$ git rebase origin/master</code></pre><h2 id="第五步：合并commit"><a href="#第五步：合并commit" class="headerlink" title="第五步：合并commit"></a>第五步：合并commit</h2><p>分支开发完成后，很可能有一堆 <code>commit</code>，但是合并到主干的时候，往往希望只有一个（或最多两三个）<code>commit</code>，这样不仅清晰，也容易管理。</p><p>那么，怎样才能将多个 <code>commit</code> 合并呢？这就要用到 <code>git rebase</code> 命令。</p><pre><code>$ git rebase -i origin/master</code></pre><p><code>git rebase</code> 命令的 <code>i</code> 参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usagepick de9b1eb Fix PostChecker::Post#urlspick 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend# Rebase 8db7e8b..fa20af3 onto 8db7e8b## Commands:#  p, pick = use commit#  r, reword = use commit, but edit the commit message#  e, edit = use commit, but stop for amending#  s, squash = use commit, but meld into previous commit#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message#  x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out</code></pre><p>上面的互动界面，先列出当前分支最新的4个 <code>commit</code>（越下面越新）。每个 <code>commit</code> 前面有一个操作命令，默认是 <code>pick</code>，表示该行 <code>commit</code> 被选中，要进行 <code>rebase</code> 操作。</p><p>4个commit的下面是一大堆注释，列出可以使用的命令。</p><ul><li>pick：正常选中</li><li>reword：选中，并且修改提交信息；</li><li>edit：选中，rebase时会暂停，允许你修改这个commit（参考这里）</li><li>squash：选中，会将当前commit与上一个commit合并</li><li>fixup：与squash相同，但不会保存当前commit的提交信息</li><li>exec：执行其他shell命令</li></ul><p>上面这6个命令当中，<code>squash</code> 和 <code>fixup</code> 可以用来合并 <code>commit</code>。先把需要合并的 <code>commit</code> 前面的动词，改成 <code>squash</code>（或者s）。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlss 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend</code></pre><p>这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。</p><pre><code># This is a combination of 3 commits.# The first commit&apos;s message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:Hey kids, stop all the highlighting</code></pre><p>如果将第三行的 <code>squash</code> 命令改成 <code>fixup</code> 命令。</p><pre><code>pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlsf 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend</code></pre><p>运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。</p><pre><code># This is a combination of 3 commits.# The first commit&apos;s message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:# Hey kids, stop all the highlighting</code></pre><p>Pony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。</p><pre><code>$ git reset HEAD~5$ git add .$ git commit -am &quot;Here&apos;s the bug fix that closes #28&quot;$ git push --force</code></pre><p><code>squash</code> 和 <code>fixup</code> 命令，还可以当作命令行参数使用，自动合并commit。</p><pre><code>$ git commit --fixup  $ git rebase -i --autosquash </code></pre><p>这个用法请参考<span class="exturl" data-url="aHR0cDovL2ZsZS5naXRodWIuaW8vZ2l0LXRpcC1rZWVwLXlvdXItYnJhbmNoLWNsZWFuLXdpdGgtZml4dXAtYW5kLWF1dG9zcXVhc2guaHRtbA==" title="http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html">http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html<i class="fa fa-external-link"></i></span>，这里就不解释了。</p><h2 id="第六步：推送到远程仓库"><a href="#第六步：推送到远程仓库" class="headerlink" title="第六步：推送到远程仓库"></a>第六步：推送到远程仓库</h2><p>合并commit后，就可以推送当前分支到远程仓库了。</p><pre><code>$ git push --force origin myfeature</code></pre><p><code>git push</code> 命令要加上 <code>force</code> 参数，因为 <code>rebase</code> 以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送。</p><h2 id="第七步：发出Pull-Request"><a href="#第七步：发出Pull-Request" class="headerlink" title="第七步：发出Pull Request"></a>第七步：发出Pull Request</h2><p>提交到远程仓库以后，就可以发出 <code>Pull Request</code> 到 <code>master</code> 分支，然后请求别人进行代码 <code>review</code>，确认可以合并到 <code>master</code>。</p>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>常用Git命令清单</title>
    <link href="http://miaopei.github.io/2017/01/27/git-common-list/"/>
    <id>http://miaopei.github.io/2017/01/27/git-common-list/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>我每天使用 Git ，但是很多命令记不住。</p><p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p><a id="more"></a><p><img src="http://i.imgur.com/zYeQxr4.png" alt></p><p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><pre><code># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><pre><code># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><pre><code># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><pre><code># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><pre><code># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><pre><code># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]</code></pre><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><pre><code># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><pre><code># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><pre><code># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop</code></pre><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><pre><code># 生成一个可供发布的压缩包$ git archive</code></pre>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git分支管理策略</title>
    <link href="http://miaopei.github.io/2017/01/27/git-branch/"/>
    <id>http://miaopei.github.io/2017/01/27/git-branch/</id>
    <published>2017-01-27T10:02:52.000Z</published>
    <updated>2019-06-03T08:10:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>如果你严肃对待编程，就必定会使用”版本管理系统”（Version Control System）。</p><p>眼下最流行的”版本管理系统”，非Git莫属。</p><a id="more"></a><p>相比同类软件，Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称”快照”）的指针，因此非常快捷易用。</p><p>但是，太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。</p><p>Vincent Driessen提出了一个分支管理的策略，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用，Git只是用来举例而已。如果你不熟悉Git，跳过举例部分就可以了。</p><h2 id="一、主分支Master"><a href="#一、主分支Master" class="headerlink" title="一、主分支Master"></a>一、主分支Master</h2><p>首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。</p><p><img src="http://i.imgur.com/CxJhyfD.png" alt></p><p>Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p><h2 id="二、开发分支Develop"><a href="#二、开发分支Develop" class="headerlink" title="二、开发分支Develop"></a>二、开发分支Develop</h2><p>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。</p><p><img src="http://i.imgur.com/TQ5k5sO.png" alt></p><p>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。</p><p>Git创建Develop分支的命令：</p><pre><code>git checkout -b develop master</code></pre><p>将Develop分支发布到Master分支的命令：</p><pre><code># 切换到Master分支git checkout master# 对Develop分支进行合并git merge --no-ff develop</code></pre><p>这里稍微解释一下，上一条命令的 <code>--no-ff</code> 参数是什么意思。默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。</p><p>使用 <code>--no-ff</code> 参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。</p><p><img src="http://i.imgur.com/X97wbk9.png" alt></p><h2 id="三、临时性分支"><a href="#三、临时性分支" class="headerlink" title="三、临时性分支"></a>三、临时性分支</h2><p>前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。</p><p>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p><pre><code>* 功能（feature）分支* 预发布（release）分支* 修补bug（fixbug）分支</code></pre><p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p><h2 id="四、功能分支"><a href="#四、功能分支" class="headerlink" title="四、功能分支"></a>四、功能分支</h2><p>接下来，一个个来看这三种”临时性分支”。</p><p>第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。</p><p><img src="http://i.imgur.com/OyWvBLR.png" alt></p><p>功能分支的名字，可以采用 <code>feature-*</code> 的形式命名。</p><p>创建一个功能分支：</p><pre><code>git checkout -b feature-x develop</code></pre><p>开发完成后，将功能分支合并到develop分支：</p><pre><code>git checkout developgit merge --no-ff feature-x</code></pre><p>删除feature分支：</p><pre><code>git branch -d feature-x</code></pre><h2 id="五、预发布分支"><a href="#五、预发布分支" class="headerlink" title="五、预发布分支"></a>五、预发布分支</h2><p>第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。</p><p>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用 <code>release-*</code> 的形式。</p><p>创建一个预发布分支：</p><pre><code>git checkout -b release-1.2 develop</code></pre><p>确认没有问题后，合并到master分支：</p><pre><code>git checkout mastergit merge --no-ff release-1.2# 对合并生成的新节点，做一个标签git tag -a 1.2</code></pre><p>再合并到develop分支：</p><pre><code>git checkout developgit merge --no-ff release-1.2</code></pre><p>最后，删除预发布分支：</p><pre><code>git branch -d release-1.2</code></pre><h2 id="六、修补bug分支"><a href="#六、修补bug分支" class="headerlink" title="六、修补bug分支"></a>六、修补bug分支</h2><p>最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。</p><p><strong>修补bug分支是从Master分支上面分出来的</strong>。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用 <code>fixbug-*</code> 的形式。</p><p><img src="http://i.imgur.com/gQoDYSK.png" alt></p><p>创建一个修补bug分支：</p><pre><code>git checkout -b fixbug-0.1 master</code></pre><p>修补结束后，合并到master分支：</p><pre><code>git checkout mastergit merge --no-ff fixbug-0.1git tag -a 0.1.1</code></pre><p>再合并到develop分支：</p><pre><code>git checkout developgit merge --no-ff fixbug-0.1</code></pre><p>最后，删除”修补bug分支”：</p><pre><code>git branch -d fixbug-0.1</code></pre>]]></content>
    
    <summary type="html">
    
      git
    
    </summary>
    
      <category term="git" scheme="http://miaopei.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://miaopei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="http://miaopei.github.io/2016/12/23/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://miaopei.github.io/2016/12/23/Docker-学习笔记/</id>
    <published>2016-12-23T02:14:50.000Z</published>
    <updated>2019-06-03T08:10:56.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h1><h3 id="常用Docker命令"><a href="#常用Docker命令" class="headerlink" title="常用Docker命令"></a>常用Docker命令</h3><hr><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启Docker守护进程调试模式</span></span><br><span class="line">$ sudo docker daemon -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Docker信息</span></span><br><span class="line">$ sudo docker info </span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止或者启动Docker</span></span><br><span class="line">$ sudo service docker stop/start </span><br><span class="line"></span><br><span class="line"><span class="comment"># 以命令行模式运行一个容器</span></span><br><span class="line">$ sudo docker run -i -t ubuntu /bin/bash </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给容器命名</span></span><br><span class="line">$ sudo docker run --name Micheal_container -i -t ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动或者停止运行的容器</span></span><br><span class="line">$ sudo docker start/stop Micheal_container </span><br><span class="line"></span><br><span class="line"><span class="comment"># 附着到正在运行的容器</span></span><br><span class="line">$ sudo docker attach Micheal_container</span><br></pre></td></tr></table></figure><p><strong>创建守护式容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的docker run 使用了<code>-d</code>参数，因此Docker会将容器放到后台运行。</p></blockquote><p><strong>Docker日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取守护式容器的日志</span></span><br><span class="line">$ sudo docker logs daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪守护式容器的日志</span></span><br><span class="line">$ sudo docker logs -f daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取日志的最后10行</span></span><br><span class="line">$ sudo docker logs --tail 10 daemon_dave </span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪某个容器的最新日志</span></span><br><span class="line">$ sudo docker logs --tail 0 -f daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># -t 标志为每条日志项加上时间戳</span></span><br><span class="line">$ sudo docker logs -ft daemon_dave</span><br></pre></td></tr></table></figure><p><strong>Docker日志驱动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --<span class="built_in">log</span>-driver=<span class="string">"syslog"</span> --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p>使用syslog将会禁用docker logs命令，并且将所有容器的日志输出都重定向到Syslog。</p></blockquote><p><strong>查看容器内的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker top daemon_dave</span><br></pre></td></tr></table></figure><p><strong>Docker统计信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker stats daemon_dave daemon_kate daemon_clear daemon_sarah</span><br></pre></td></tr></table></figure><blockquote><p>以上命令可以看到一个守护容器的列表，以及他们的CPU、内存、网络I/O以及存储I/O的性能和指标。这对快速监控一台主机上的一组容器非常有用。</p></blockquote><p><strong>在容器内部运行进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -d daemon_dave touch /etc/new_config_file</span><br></pre></td></tr></table></figure><blockquote><p><code>-d</code>表示需要运行一个后台进程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内运行交互命令</span></span><br><span class="line">$ sudo docker <span class="built_in">exec</span> -t -i daemon_dave /bin/bash</span><br></pre></td></tr></table></figure><p><strong>自动重启容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --restart=always --name daemon_dave -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><blockquote><p><code>--restart</code>标志被设置为always。无论容器的退出代码是什么，Docker都会自动重启改容器。除了always，还可以将这个标志设为<code>on-failure</code>，这样，只有当容器的退出代码为非0值的时候，才会自动重启。另外，on-failure还接受一个可选的重启次数参数，<code>--restart=on-failure:5</code>,Docker会尝试自动重启改容器，最多重启5次。</p></blockquote><p><strong>深入容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect daemon_dave</span><br></pre></td></tr></table></figure><blockquote><p>docker inspect命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置以及很多有用的数据。可以使用<code>-f</code>或者<code>--format</code>标志来选定查看结果。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format=<span class="string">'&#123;.State.Running&#125;'</span> daemon_dave</span><br></pre></td></tr></table></figure><blockquote><p>查看多个容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format <span class="string">'&#123;.Name&#125; &#123;.State.Running&#125;'</span> daemon_dave Micheal_container</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong><br>​    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker rm daemon_dave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line">$ sudo docker rm `sudo docker ps -a -q`</span><br></pre></td></tr></table></figure><p><strong>列出所有镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br></pre></td></tr></table></figure><p><strong>拉去镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure><p><strong>运行一个带标签的Docker镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t --name new_container ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure><p><strong>查找镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker search puppet</span><br></pre></td></tr></table></figure><p><strong>构建镜像</strong></p><ul><li>使用<code>docker commit</code>命令</li><li>使用<code>docker build</code>命令和<code>Dockerfile</code>文件</li></ul><p><strong>用Docker的commit命令创建镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来安装需要安装的工具，安装完成后exit退出容器, eg：</span></span><br><span class="line">$ apt-get -yqq update</span><br><span class="line">$ apt-get -y install apache2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定提交修改过的容器的ID（可以通过docker ps -l -q命令得到刚创建的容器的ID）</span></span><br><span class="line">$ sudo docker commit 4aab3cecb76 micheal/apache2  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查新创建的镜像</span></span><br><span class="line">sudo docker images micheal/apache2  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交另一个新定制容器</span></span><br><span class="line"><span class="comment"># -m 选项用来指定新创建的镜像的提交信息，-a 用来列出该镜像的作者信息。</span></span><br><span class="line">$ sudo docker commit -m<span class="string">"A new custom image"</span> -a<span class="string">"Micheal"</span> 4aab3cecb76 micheal/apache2:webserver</span><br></pre></td></tr></table></figure><p><strong>用Dockerfile构建镜像</strong></p><p>Dockerfile文件示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Vsersion: 0.0.1</span></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER Micheal "miaopei@baicells.com"</span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get -y install nginx</span><br><span class="line">RUN echo 'Hi, I an in your container' &gt; /usr/share/nginx/html/index.html</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><blockquote><p>Dockerfile中的指令会按照顺序从上到下执行，所以根据需要合理安排指令的顺序。</p><p>如果Dockerfile由于某些原因没有正常结束，那么用户得到了一个可以使用的镜像。这对调试非常有帮助：可以基于改镜像运行一个具备交互功能的容器，使用最后创建的镜像对为什么用户指令会失败进行调试。</p><p><strong>每个Dockerfile的第一条指令必须是FROM</strong>,FROM指令指定一个已经存在的镜像，后续指令都将基于该镜像进行，这个镜像被称为基础镜像。</p><p>MAINTAINER指令告诉Docker镜像的作者是谁，以及作者的电子邮件。有助于标识镜像的所有者和联系方式。</p></blockquote><blockquote><p>默认情况下，RUN指令会在shell里使用命令包装器<code>/bin/sh -c</code>来执行，如果是在一个不支持shell的平台上运行或者不希望在shell中运行（比如避免shell字符串篡改），也可以使用<code>exec</code>格式的RUN指令，如下所示：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ "apt-get", " install", "-y", "nginx" ]</span><br></pre></td></tr></table></figure><blockquote><p>EXPOSE指令告诉Docker该容器内的应用程序将会使用该容器的指定端口。</p></blockquote><p><strong>基于Dockerfile构建新镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web"</span> .</span><br><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web:v1"</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里Docker假设在这个Git仓库的根目录下存在Dockerfile文件</span></span><br><span class="line">$ sudo docker build -t=<span class="string">"micheal/static_web:v1"</span> git@github.com:micheal/docker_static_web  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略Dockerfile的构建缓存</span></span><br><span class="line">$ sudo docker build --no-cache -t=<span class="string">"micheal/static_web"</span> .</span><br></pre></td></tr></table></figure><p><strong>查看镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出Docker镜像</span></span><br><span class="line">$ sudo docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像每一层，以及创建这些层的Dockerfile指令</span></span><br><span class="line">$ sudo docker <span class="built_in">history</span> micheal/static_web </span><br><span class="line"></span><br><span class="line">$ sudo docker run -d -p 80 --name statix_web micheal/static_web nginx -g <span class="string">"daemon off;"</span></span><br></pre></td></tr></table></figure><blockquote><p>nginx -g “daemon off;”,这将以前台的方式启动Nginx。</p><p><code>-p</code>标志用来控制Docker在运行时应该公开那些网络端口给外部（宿主机）。运行一个容器时，Docker可以通过两种方式来在宿主机上分配端口。</p><ul><li>Docker可以在宿主机上随机选择一个位于32768 ~ 61000的一个比较大的端口号来映射到容器中的80端口上。</li><li>可以在Docker宿主机只指定一个具体的端口号来映射到容器中的80端口上。</li></ul></blockquote><p><strong>查看Docker端口映射情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回宿主机中映射的端口</span></span><br><span class="line">$ sudo socker port static_web 80 </span><br><span class="line"></span><br><span class="line"><span class="comment"># -p会将容器内的80端口绑定到宿主机的8080端口上</span></span><br><span class="line">$ sudo docker run -d -p 8080:80 --name statix_web micheal/static_web nginx -g <span class="string">"daemon off;"</span></span><br></pre></td></tr></table></figure><p><strong>Dockerfile指令</strong></p><ol><li>CMD</li></ol><blockquote><p>CMD指令用于指定一个容器启动时要运行的命令。这有点儿类似于RUN指令，只是RUN指令是指定容器镜像被构建时要运行的命令，而CMD是指定容器被启动时要运行的命令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/bin/bash/"</span>, <span class="string">"-l"</span>]</span><br></pre></td></tr></table></figure><ol><li>ENTRYPOINT</li></ol><blockquote><p>ENTRYPOINT和CMD指令非常类似，我们可在docker run命令行中覆盖CMD指令，而ENTRYPOINT指令提供的命令则不容易在启动容器的时候被覆盖。</p><p>可以组合使用ENTRYPOINT和CMD指令来完成一些巧妙的工作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">"/usr/sbin/nginx"</span>]</span><br><span class="line">CMD [<span class="string">"-h"</span>]</span><br></pre></td></tr></table></figure><ol><li>WORKDIR</li></ol><blockquote><p>WORKDIR指令用来在从镜像创建一个新容器时，在容器内部设置一个工作目录，ENTRYPOINT和/或CMD指定的程序会在这个目录下执行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /opt/webapp/db</span><br><span class="line">RUN bundle install</span><br><span class="line">WORKDIR /opt/webapp</span><br><span class="line">ENTRYPOINT [<span class="string">"rackup"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>-w</code>标志在运行时覆盖工作目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -ti -w /var/<span class="built_in">log</span> ubuntu <span class="built_in">pwd</span>/var/<span class="built_in">log</span></span><br></pre></td></tr></table></figure><ol><li>ENV</li></ol><blockquote><p>ENV指令用来在镜像构建过程中设置环境变量。这些变量会持久保存到从我们镜像创建的任何容器中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV RVM_PATH /home/rvm</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用docker run命令行的<code>-e</code>标志来传递环境变量。这些环境变量只会在运行时有效。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -ti -e <span class="string">"WEB_PORT=8080"</span> ubuntu env</span><br></pre></td></tr></table></figure><ol><li>USER</li></ol><blockquote><p>USER指令用来指定该镜像会以什么样的用户身份来运行。我们可以指定用户名或者UID以及组或GID，甚至是两者的组合。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure><blockquote><p>也可以在docker run命令行中通过<code>-u</code>标志覆盖该指令指定的值。</p></blockquote><ol><li>VOLUME</li></ol><blockquote><p>VOLUME指令用来向基于镜像创建的容器添加卷。一个卷可以存在于一个或者多个容器内特定的目录，这个目录可以绕过联合文件系统，并提供如下共享数据或者对数据进行持久化的功能。</p><ul><li>卷可以在容器间共享和重用</li><li>一个容器可以不是必须和其他容器共享卷</li><li>对卷的修改是立即生效的</li><li>对卷的修改不会对更新镜像产生影响</li><li>卷会一直存在直到没有任何容器再使用它</li></ul><p>卷功能让我们可以将数据（如源代码）、数据库或者其他内容添加到镜像中而不是将这些内容提交到镜像中，并且允许我们在多个容器间共享这些内容，我们可以利用此功能来测试容器和内部应用程序代码，管理日志，或者处理容器内部的数据库。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/opt/project"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>这条指令将会基于此镜像的任何容器创建一个名为/opt/project的挂载点。</p><p>也可以通过指定数组的方式指定多个卷</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/opt/project"</span>, <span class="string">"/data"</span>]</span><br></pre></td></tr></table></figure><ol><li>ADD</li></ol><blockquote><p>ADD指令用来将构建环境下的文件和目录复制到镜像中。不能对构建目录或者上下文之外的文件进行ADD操作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD software.lic /opt/application/software.lic</span><br><span class="line">ADD latest.tar.gz /var/www/wordpress/   //这条指令会将归档文件解开到指定的目录下</span><br></pre></td></tr></table></figure><ol><li>COPY</li></ol><blockquote><p>COPY指令非常类似ADD，它们根本不同是COPY只关心构建上下文中复制本地文件，而不会去做文件提取（extraction）和解压（decompression）的工作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY conf.d/ /etc/apache2/</span><br></pre></td></tr></table></figure><ol><li>LABEL</li></ol><blockquote><p>LABEL指令用于为Docker镜像添加元数据。元数据以键值对的形式展现</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=<span class="string">"1.0"</span></span><br><span class="line">LABEL location=<span class="string">"New York"</span> <span class="built_in">type</span>=<span class="string">"Data Center"</span> role=<span class="string">"Web Server"</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用docker inspect命令查看容器标签</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect micheal/apache2</span><br></pre></td></tr></table></figure><ol><li>STOPSIGNAL</li></ol><blockquote><p>STOPSIGNAL指令用来设置停止容器时发送什么系统调用信号给容器。</p></blockquote><ol><li>ARG</li></ol><blockquote><p>ARG指令用来定义可以在docker build命令运行时传递给构建运行时的变量，我们只需要在构建时使用–build-arg标志即可。用户只能在构建时指定在Dockerfile文件汇总定义过的参数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG build</span><br><span class="line">ARG webapp_user=user</span><br><span class="line"></span><br><span class="line">$ docker build --build-arg build=1234 -t micheal/webapp .</span><br></pre></td></tr></table></figure><ol><li>ONBUILD</li></ol><blockquote><p>ONBUILD指令能为镜像添加触发器（trigger）。当一个镜像被用做其他镜像的基础镜像时（比如用户的镜像需要从某未准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本），该镜像中的触发器将会被执行。</p><p>触发器会在构建过程中插入新指令，我们可以认为这些指令是紧跟在FROM之后指定的。触发器可以是任何构建指令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN <span class="built_in">cd</span> /app/src/ &amp;&amp; make</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码将会在创建的镜像中加入ONBUILD触发器，ONBUILD指令可以在镜像上运行docker inspect命令查看。</p></blockquote><p><strong>Docker Networking</strong></p><blockquote><p>容器之间的连接用网络创建，这被称为Docker Networking。Docker Networking允许用户创建自己的网络，容器可以通过这个网上互相通信。更重要的是，现在容器可以跨越不同的宿主机来通信，并且网络配置可以更灵活的定制。Docker Networking也和Docker Compose以及Swarm进行了集成。</p><p>要想使用Docker网络，需要先创建一个网络，然后在这个网络下启动容器。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network create app</span><br></pre></td></tr></table></figure><blockquote><p>这里使用docker network命令创建了一个桥接网络，命名为app。可以使用docker network inspect命令查看新创建的这个网络。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect app</span><br></pre></td></tr></table></figure><blockquote><p>我们可以看到这个新网络是一个本地的桥接网络（这非常像docker0网络），而且现在没有容器再这个网络中运行。</p><p>可以使用<code>docker network ls</code>命令列出当前系统中所有的网络。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network ls</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用 <code>docker network rm</code>命令删除一个Docker网络。</p><p>在Docker网络中创建Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --net=app --name db micheal/redis</span><br></pre></td></tr></table></figure><blockquote><p><code>--net</code>标志指定了新容器将会在那个网络中运行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect app</span><br></pre></td></tr></table></figure><blockquote><p>将已有容器连接到Docker网络</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network connect app db2</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>docker network disconnect</code> 命令断开一个容器与指定网络的连接</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network disconnect app db2</span><br></pre></td></tr></table></figure><p><strong>通过Docker链接连接容器</strong></p><blockquote><p>启动一个Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name redis micheal/redis</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里没有公开容器的任何端口。一会就能看到这么做的原因。</p></blockquote><blockquote><p>链接Redis容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -p 4567 --name webapp --link redis:db -t -i -v <span class="variable">$PWD</span>/webapp_redis:/opt/webapp micheal/sinatra /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>这个命令做了不少事情，我们逐一解释。首先，我们使用<code>-p</code>标志公开4567端口，这样就能从外面访问web应用程序。</p><p>我们还使用<code>--name</code>标志给容器命名为webapp，并且使用了<code>-v</code>标志把web应用程序目录作为卷挂载到了容器里。</p><p>然而，这次我们使用了一个新标志<code>--link</code>。<code>--link</code>标志创建了两个容器间的客户-服务链接。这个标志需要两个参数：一个是要链接的容器的名字，另一个是链接的别名。这个例子中我们创建了客户联系，webapp容器是客户，redis容器是“服务”，并且为这个服务增加了db作为别名。这个别名让我们可以一致地访问容器公开信息，而无须关注底层容器的名字。链接让服务容器有能力与客户容器通信，并且能分享一些连接细节，这些细节有助于在应用程序中配置并使用这个链接。</p></blockquote><blockquote><p>连接也能得到一些安全上的好处。注意，启动 Redis 容器时，并没有使用<code>-p</code>标志公开Redis的端口。因为不需要这么做。通过把容器链接在一起，可以让客户直接访问任意服务容器的公开端口（即客户webapp容器可以连接到服务redis容器的6379端口）。更妙的是，只有使用<code>--link</code>标志链接到这个容器的容器才能连接到这个端口。容器的端口不需要对本地宿主机公开，现在我们已经拥有一个非常安全的模型。通过这个安全模型，就可以限制容器化应用程序被攻击面，减少应用暴露的网络。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker基本命令&quot;&gt;&lt;a href=&quot;#Docker基本命令&quot; class=&quot;headerlink&quot; title=&quot;Docker基本命令&quot;&gt;&lt;/a&gt;Docker基本命令&lt;/h1&gt;&lt;h3 id=&quot;常用Docker命令&quot;&gt;&lt;a href=&quot;#常用Docker命令&quot; class=&quot;headerlink&quot; title=&quot;常用Docker命令&quot;&gt;&lt;/a&gt;常用Docker命令&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://miaopei.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://miaopei.github.io/tags/Docker/"/>
    
  </entry>
  
</feed>
